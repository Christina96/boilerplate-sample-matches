<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for webpload.c &amp; heifload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for webpload.c &amp; heifload.c
      </h3>
<h1 align="center">
        25.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>webpload.c (46.53846%)<th>heifload.c (18.005953%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(339-383)<td><a href="#" name="0">(1134-1179)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(218-251)<td><a href="#" name="1">(1226-1261)</a><td align="center"><font color="#d40000">20</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(163-215)<td><a href="#" name="2">(951-996)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(407-423)<td><a href="#" name="3">(1195-1212)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(148-159)<td><a href="#" name="4">(1121-1132)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(251-264)<td><a href="#" name="5">(1270-1284)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(280-302)<td><a href="#" name="6">(1081-1103)</a><td align="center"><font color="#8a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>webpload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include "pforeign.h"
7 #ifdef HAVE_LIBWEBP
8 typedef struct _VipsForeignLoadWebp {
9 	VipsForeignLoad parent_object;
10 	VipsSource *source;
11 	int page;
12 	int n;
13 	double scale; 
14 	int shrink;
15 } VipsForeignLoadWebp;
16 typedef VipsForeignLoadClass VipsForeignLoadWebpClass;
17 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadWebp, vips_foreign_load_webp, 
18 	VIPS_TYPE_FOREIGN_LOAD );
19 static void
20 vips_foreign_load_webp_dispose( GObject *gobject )
21 {
22 	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) gobject;
23 	VIPS_UNREF( webp-&gt;source );
24 	G_OBJECT_CLASS( vips_foreign_load_webp_parent_class )-&gt;
25 		dispose( gobject );
26 }
27 static int
28 vips_foreign_load_webp_build( VipsObject *object )
29 {
30 	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
31 	if( !vips_object_argument_isset( VIPS_OBJECT( webp ), "scale" ) &amp;&amp;
32 		vips_object_argument_isset( VIPS_OBJECT( webp ), "shrink" ) &amp;&amp;
33 		webp-&gt;shrink != 0 )
34 		webp-&gt;scale = 1.0 / webp-&gt;shrink;
35 	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_parent_class )-&gt;
36 		build( object ) )
37 		return( -1 );
38 	return( 0 );
39 }
40 static VipsForeignFlags
41 vips_foreign_load_webp_get_flags( VipsForeignLoad *load )
42 {
43 	return( 0 );
44 }
45 static VipsForeignFlags
46 vips_foreign_load_webp_get_flags_filename( const char *filename )
47 {
48 	return( 0 );
49 }
50 static int
51 vips_foreign_load_webp_header( VipsForeignLoad *load )
52 {
53 	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) load;
54 	if( vips__webp_read_header_source( webp-&gt;source, load-&gt;out, 
55 		webp-&gt;page, webp-&gt;n, webp-&gt;scale ) ) 
56 		return( -1 );
57 	return( 0 );
58 }
59 static int
60 vips_foreign_load_webp_load( VipsForeignLoad *load )
61 {
62 	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) load;
63 <a name="4"></a>
64 	if( vips__webp_read_source( webp-&gt;source, load-&gt;real, 
65 		webp-&gt;page, webp-&gt;n, webp-&gt;scale ) ) 
66 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );
67 	return( 0 );
68 }
69 static void
70 vips_foreign_load_webp_class_init( VipsForeignLoadWebpClass *class )
71 {
72 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
73 	VipsObjectClass *object_class = (VipsObjectClass *) class;
74 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
75 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
76 <a name="2"></a>
77 	gobject_class-&gt;dispose = vips_foreign_load_webp_dispose;
78 	gobject_class-&gt;set_property = vips_object_set_property;
79 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	gobject_class-&gt;get_property = vips_object_get_property;
80 	object_class-&gt;nickname = "webpload_base";
81 	object_class-&gt;description = _( "load webp" );
82 	object_class-&gt;build = vips_foreign_load_webp_build;
83 	foreign_class-&gt;priority = -50;
84 	load_class-&gt;get_flags_filename = 
85 		vips_foreign_load_webp_get_flags_filename;
86 	load_class-&gt;get_flags = vips_foreign_load_webp_get_flags;
87 	load_class-&gt;header = vips_foreign_load_webp_header;
88 	load_class-&gt;load = vips_foreign_load_webp_load;
89 	VIPS_ARG_INT( class, "page", 20,
90 		_( "Page" ),
91 		_( "Load this page from the file" ),
92 		VIPS_ARGUMENT_OPTIONAL_INPUT,
93 		G_STRUCT_OFFSET( VipsForeignLoadWebp, page ),
94 		0, 100000, 0 );
95 	VIPS_ARG_INT( class, "n", 21,
96 		_( "n" ),
97 		_( "Load this many pages" ),
98 		VIPS_ARGUMENT_OPTIONAL_INPUT,
99 		G_STRUCT_OFFSET( VipsForeignLoadWebp, n ),
100 		-1, 100000, 1 );
101 	VIPS_ARG_DOUBLE( class, "scale", 22, 
102 		_( "Scale" ), 
103 		_( "Scale factor on load" ),
104 		VIPS_ARGUMENT_OPTIONAL_INPUT,
105 		G_STRUCT_OFFSET( VipsForeignLoadWebp, scale ),
106 		0.0, 1024.0, 1.0 );
107 	VIPS_ARG_INT( class, "shrink", 23, 
108 		_( "Shrink" ), 
109 		_( "Shrink factor on load" ),
110 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
111 		G_STRUCT_OFFSET( VipsForeignLoadWebp, shrink ),
112 		1, 1024, 1 );
113 }
114 static void
115 vips_foreign_load_webp_init( VipsForeignLoadWebp *webp )
116 {
117 <a name="1"></a>	webp-&gt;n = 1;</b></font>
118 	webp-&gt;shrink = 1;
119 	webp-&gt;scale = 1.0;
120 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
121 typedef struct _VipsForeignLoadWebpSource {
122 	VipsForeignLoadWebp parent_object;
123 	VipsSource *source;
124 } VipsForeignLoadWebpSource;
125 typedef VipsForeignLoadWebpClass VipsForeignLoadWebpSourceClass;
126 G_DEFINE_TYPE( VipsForeignLoadWebpSource, vips_foreign_load_webp_source, 
127 	vips_foreign_load_webp_get_type() );
128 static int
129 vips_foreign_load_webp_source_build( VipsObject *object )
130 {
131 	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
132 	VipsForeignLoadWebpSource *source = 
133 		(VipsForeignLoadWebpSource *) object;
134 	if( source-&gt;source ) {
135 		webp-&gt;source = source-&gt;source;
136 		g_object_ref( webp-&gt;source );
137 	}
138 	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_source_parent_class )-&gt;
139 		build( object ) )
140 		return( -1 );
141 <a name="5"></a>	return( 0 );
142 }
143 static void</b></font><font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>
144 vips_foreign_load_webp_source_class_init( 
145 	VipsForeignLoadWebpSourceClass *class )
146 {
147 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
148 	VipsObjectClass *object_class = (VipsObjectClass *) class;
149 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
150 	gobject_class-&gt;set_property = vips_object_set_property;
151 	gobject_class-&gt;get_property = vips_object_get_property;
152 	object_class-&gt;nickname = "webpload_source";
153 	object_class-&gt;description = _( "load webp from source" );
154 	object_class-&gt;build = vips_foreign_load_webp_source_build;</b></font>
155 	load_class-&gt;is_a_source = vips__iswebp_source; 
156 	VIPS_ARG_OBJECT( class, "source", 1,
157 		_( "Source" ),
158 		_( "Source to load from" ),
159 		VIPS_ARGUMENT_REQUIRED_INPUT, 
160 		G_STRUCT_OFFSET( VipsForeignLoadWebpSource, source ),
161 		VIPS_TYPE_SOURCE );
162 }
163 <a name="6"></a>static void
164 vips_foreign_load_webp_source_init( VipsForeignLoadWebpSource *buffer )
165 {
166 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
167 typedef struct _VipsForeignLoadWebpFile {
168 	VipsForeignLoadWebp parent_object;
169 	char *filename; 
170 } VipsForeignLoadWebpFile;
171 typedef VipsForeignLoadWebpClass VipsForeignLoadWebpFileClass;
172 G_DEFINE_TYPE( VipsForeignLoadWebpFile, vips_foreign_load_webp_file, 
173 	vips_foreign_load_webp_get_type() );
174 static int
175 vips_foreign_load_webp_file_build( VipsObject *object )
176 {
177 	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
178 	VipsForeignLoadWebpFile *file = (VipsForeignLoadWebpFile *) object;
179 	if( file-&gt;filename &amp;&amp;</b></font>
180 		!(webp-&gt;source = 
181 			vips_source_new_from_file( file-&gt;filename )) )
182 		return( -1 );
183 	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_file_parent_class )-&gt;
184 		build( object ) )
185 		return( -1 );
186 	return( 0 );
187 }
188 static gboolean
189 vips_foreign_load_webp_file_is_a( const char *filename )
190 {
191 	VipsSource *source;
192 	gboolean result;
193 	if( !(source = vips_source_new_from_file( filename )) )
194 		return( FALSE );
195 	result = vips__iswebp_source( source );
196 	VIPS_UNREF( source );
197 	return( result );
198 }
199 const char *vips__webp_suffs[] = { ".webp", NULL };
200 static void
201 vips_foreign_load_webp_file_class_init( VipsForeignLoadWebpFileClass *class )
202 {
203 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
204 	VipsObjectClass *object_class = (VipsObjectClass *) class;
205 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
206 <a name="0"></a>	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
207 	gobject_class-&gt;set_property = vips_object_set_property;
208 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	gobject_class-&gt;get_property = vips_object_get_property;
209 	object_class-&gt;nickname = "webpload";
210 	object_class-&gt;description = _( "load webp from file" );
211 	object_class-&gt;build = vips_foreign_load_webp_file_build;
212 	foreign_class-&gt;suffs = vips__webp_suffs;
213 	load_class-&gt;is_a = vips_foreign_load_webp_file_is_a;
214 	VIPS_ARG_STRING( class, "filename", 1, 
215 		_( "Filename" ),
216 		_( "Filename to load from" ),
217 		VIPS_ARGUMENT_REQUIRED_INPUT, 
218 		G_STRUCT_OFFSET( VipsForeignLoadWebpFile, filename ),
219 		NULL );
220 }
221 static void
222 vips_foreign_load_webp_file_init( VipsForeignLoadWebpFile *file )
223 {
224 }
225 typedef struct _VipsForeignLoadWebpBuffer {
226 	VipsForeignLoadWebp parent_object;
227 	VipsBlob *blob;
228 } VipsForeignLoadWebpBuffer;
229 typedef VipsForeignLoadWebpClass VipsForeignLoadWebpBufferClass;
230 G_DEFINE_TYPE( VipsForeignLoadWebpBuffer, vips_foreign_load_webp_buffer, 
231 	vips_foreign_load_webp_get_type() );
232 static int
233 vips_foreign_load_webp_buffer_build( VipsObject *object )
234 {
235 	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
236 	VipsForeignLoadWebpBuffer *buffer = 
237 		(VipsForeignLoadWebpBuffer *) object;
238 	if( buffer-&gt;blob &amp;&amp;</b></font>
239 		!(webp-&gt;source = vips_source_new_from_memory( 
240 			VIPS_AREA( buffer-&gt;blob )-&gt;data, 
241 			VIPS_AREA( buffer-&gt;blob )-&gt;length )) )
242 		return( -1 );
243 	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_buffer_parent_class )-&gt;
244 		build( object ) )
245 		return( -1 );
246 	return( 0 );
247 }
248 static gboolean
249 vips_foreign_load_webp_buffer_is_a_buffer( const void *buf, size_t len )
250 {
251 	VipsSource *source;
252 	gboolean result;
253 	if( !(source = vips_source_new_from_memory( buf, len )) )
254 		return( FALSE );
255 <a name="3"></a>	result = vips__iswebp_source( source );
256 	VIPS_UNREF( source );
257 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( result );
258 }
259 static void
260 vips_foreign_load_webp_buffer_class_init( 
261 	VipsForeignLoadWebpBufferClass *class )
262 {
263 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
264 	VipsObjectClass *object_class = (VipsObjectClass *) class;
265 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
266 	gobject_class-&gt;set_property = vips_object_set_property;
267 	gobject_class-&gt;get_property = vips_object_get_property;
268 	object_class-&gt;nickname = "webpload_buffer";
269 	object_class-&gt;description = _( "load webp from buffer" );
270 	object_class-&gt;build = vips_foreign_load_webp_buffer_build;</b></font>
271 	load_class-&gt;is_a_buffer = vips_foreign_load_webp_buffer_is_a_buffer; 
272 	VIPS_ARG_BOXED( class, "buffer", 1, 
273 		_( "Buffer" ),
274 		_( "Buffer to load from" ),
275 		VIPS_ARGUMENT_REQUIRED_INPUT, 
276 		G_STRUCT_OFFSET( VipsForeignLoadWebpBuffer, blob ),
277 		VIPS_TYPE_BLOB );
278 }
279 static void
280 vips_foreign_load_webp_buffer_init( VipsForeignLoadWebpBuffer *buffer )
281 {
282 }
283 int
284 vips_webpload( const char *filename, VipsImage **out, ... )
285 {
286 	va_list ap;
287 	int result;
288 	va_start( ap, out );
289 	result = vips_call_split( "webpload", ap, filename, out );
290 	va_end( ap );
291 	return( result );
292 }
293 int
294 vips_webpload_buffer( void *buf, size_t len, VipsImage **out, ... )
295 {
296 	va_list ap;
297 	VipsBlob *blob;
298 	int result;
299 	blob = vips_blob_new( NULL, buf, len );
300 	va_start( ap, out );
301 	result = vips_call_split( "webpload_buffer", ap, blob, out );
302 	va_end( ap );
303 	vips_area_unref( VIPS_AREA( blob ) );
304 	return( result );
305 }
306 int
307 vips_webpload_source( VipsSource *source, VipsImage **out, ... )
308 {
309 	va_list ap;
310 	int result;
311 	va_start( ap, out );
312 	result = vips_call_split( "webpload_source", ap, source, out );
313 	va_end( ap );
314 	return( result );
315 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>heifload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/debug.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #if defined(HAVE_HEIF_DECODER) || defined(HAVE_HEIF_ENCODER)
11 #include "pforeign.h"
12 const char *vips__heif_suffs[] = { 
13 	".heic",
14 	".heif",
15 	".avif",
16 	NULL 
17 };
18 #ifdef HAVE_HEIF_DECODER
19 #include &lt;libheif/heif.h&gt;
20 #define VIPS_TYPE_FOREIGN_LOAD_HEIF (vips_foreign_load_heif_get_type())
21 #define VIPS_FOREIGN_LOAD_HEIF( obj ) \
22 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
23 	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeif ))
24 #define VIPS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
25 	(G_TYPE_CHECK_CLASS_CAST( (klass), \
26 	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass))
27 #define VIPS_IS_FOREIGN_LOAD_HEIF( obj ) \
28 	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
29 #define VIPS_IS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
30 	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
31 #define VIPS_FOREIGN_LOAD_HEIF_GET_CLASS( obj ) \
32 	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
33 	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass ))
34 typedef struct _VipsForeignLoadHeif {
35 	VipsForeignLoad parent_object;
36 	int page;
37 	int n;
38 	gboolean thumbnail;
39 	gboolean autorotate;
40 	struct heif_context *ctx;
41 	int n_top;
42 	gboolean has_alpha;
43 	int width;
44 	int height;
45 	int page_width;
46 	int page_height;
47 	int page_no;
48 	gboolean thumbnail_set;
49 	int primary_page;
50 	heif_item_id *id;
51 	struct heif_image_handle *handle;
52 	struct heif_image *img;
53 	int stride;
54 	const uint8_t *data;
55 	VipsSource *source;
56 	struct heif_reader *reader;
57 } VipsForeignLoadHeif;
58 void
59 vips__heif_error( struct heif_error *error )
60 {
61 	if( error-&gt;code ) 
62 		vips_error( "heif", "%s (%d.%d)", error-&gt;message, error-&gt;code,
63 			error-&gt;subcode );
64 }
65 typedef struct _VipsForeignLoadHeifClass {
66 	VipsForeignLoadClass parent_class;
67 } VipsForeignLoadHeifClass;
68 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadHeif, vips_foreign_load_heif, 
69 	VIPS_TYPE_FOREIGN_LOAD );
70 static void
71 vips_foreign_load_heif_dispose( GObject *gobject )
72 {
73 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) gobject;
74 	heif-&gt;data = NULL;
75 	VIPS_FREEF( heif_image_release, heif-&gt;img );
76 	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
77 	VIPS_FREEF( heif_context_free, heif-&gt;ctx );
78 	VIPS_FREE( heif-&gt;id );
79 	VIPS_FREE( heif-&gt;reader );
80 	VIPS_UNREF( heif-&gt;source );
81 	G_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
82 		dispose( gobject );
83 }
84 static int
85 vips_foreign_load_heif_build( VipsObject *object )
86 {
87 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
88 #ifdef DEBUG
89 	printf( "vips_foreign_load_heif_build:\n" );
90 	if( heif-&gt;source &amp;&amp;
91 		vips_source_rewind( heif-&gt;source ) )
92 		return( -1 );
93 	if( !heif-&gt;ctx ) {
94 		struct heif_error error;
95 		heif-&gt;ctx = heif_context_alloc();
96 		error = heif_context_read_from_reader( heif-&gt;ctx, 
97 			heif-&gt;reader, heif, NULL );
98 		if( error.code ) {
99 			vips__heif_error( &amp;error );
100 			return( -1 );
101 		}
102 	}
103 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
104 		build( object ) )
105 		return( -1 );
106 	return( 0 );
107 }
108 static const char *heif_magic[] = {
109 	"ftypheic",		"ftypheix",		"ftyphevc",		"ftypheim",		"ftypheis",		"ftyphevm",		"ftyphevs",		"ftypmif1",		"ftypmsf1",		"ftypavif"	};
110 static int
111 vips_foreign_load_heif_is_a( const char *buf, int len )
112 {
113 	if( len &gt;= 12 ) {
114 		const guint32 chunk_len = 
115 			(guint32) buf[0] &lt;&lt; 24 |
116 			(guint32) buf[1] &lt;&lt; 16 |
117 			(guint32) buf[2] &lt;&lt; 8 |
118 			(guint32) buf[3];
119 		int i;
120 		if( chunk_len &gt; 64 || 
121 			chunk_len % 4 != 0 )
122 			return( 0 );
123 		for( i = 0; i &lt; VIPS_NUMBER( heif_magic ); i++ )
124 			if( strncmp( buf + 4, heif_magic[i], 8 ) == 0 )
125 				return( 1 );
126 	}
127 	return( 0 );
128 }
129 static VipsForeignFlags
130 vips_foreign_load_heif_get_flags( VipsForeignLoad *load )
131 {
132 	return( VIPS_FOREIGN_SEQUENTIAL );
133 }
134 static int
135 vips_foreign_load_heif_set_thumbnail( VipsForeignLoadHeif *heif )
136 {
137 	heif_item_id thumb_ids[1];
138 	int n_thumbs;
139 	struct heif_image_handle *thumb_handle;
140 	struct heif_image *thumb_img;
141 	struct heif_error error;
142 	double main_aspect;
143 	double thumb_aspect;
144 #ifdef DEBUG
145 	printf( "vips_foreign_load_heif_set_thumbnail:\n" );
146 	n_thumbs = heif_image_handle_get_list_of_thumbnail_IDs( 
147 		heif-&gt;handle, thumb_ids, 1 );
148 	if( n_thumbs == 0 )
149 		return( 0 );
150 	error = heif_image_handle_get_thumbnail( heif-&gt;handle,
151 		thumb_ids[0], &amp;thumb_handle );
152 	if( error.code ) {
153 		vips__heif_error( &amp;error );
154 		return( -1 );
155 	}
156 	error = heif_decode_image( thumb_handle, &amp;thumb_img,
157 		heif_colorspace_RGB, 
158 		heif_chroma_interleaved_RGB,
159 		NULL );
160 	if( error.code ) {
161 		VIPS_FREEF( heif_image_handle_release, thumb_handle );
162 		vips__heif_error( &amp;error );
163 		return( -1 );
164 	}
165 	thumb_aspect = (double) 
166 		heif_image_get_width( thumb_img, heif_channel_interleaved ) /
167 		heif_image_get_height( thumb_img, heif_channel_interleaved );
168 	VIPS_FREEF( heif_image_release, thumb_img );
169 	main_aspect = (double) 
170 		heif_image_handle_get_width( heif-&gt;handle ) /
171 		heif_image_handle_get_height( heif-&gt;handle );
172 	if( fabs( main_aspect - thumb_aspect ) &gt; 0.1 ) {
173 		VIPS_FREEF( heif_image_handle_release, thumb_handle );
174 		return( 0 );
175 	}
176 	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
177 	heif-&gt;handle = thumb_handle;
178 	return( 0 );
179 }
180 static int
181 vips_foreign_load_heif_set_page( VipsForeignLoadHeif *heif, 
182 	int page_no, gboolean thumbnail )
183 {
184 	if( !heif-&gt;handle ||
185 		page_no != heif-&gt;page_no ||
186 		thumbnail != heif-&gt;thumbnail_set ) {
187 		struct heif_error error;
188 #ifdef DEBUG
189 		printf( "vips_foreign_load_heif_set_page: %d, thumbnail = %d\n",
190 			page_no, thumbnail );
191 		VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
192 		VIPS_FREEF( heif_image_release, heif-&gt;img );
193 		heif-&gt;data = NULL;
194 		heif-&gt;thumbnail_set = FALSE;
195 		error = heif_context_get_image_handle( heif-&gt;ctx, 
196 			heif-&gt;id[page_no], &amp;heif-&gt;handle );
197 		if( error.code ) {
198 			vips__heif_error( &amp;error );
199 			return( -1 );
200 		}
201 		if( thumbnail ) {
202 			if( vips_foreign_load_heif_set_thumbnail( heif ) )
203 				return( -1 );
204 			heif-&gt;thumbnail_set = TRUE;
205 		}
206 		heif-&gt;page_no = page_no;
207 	}
208 	return( 0 );
209 }
210 static int
211 vips_foreign_load_heif_set_header( VipsForeignLoadHeif *heif, VipsImage *out )
212 {
213 	VipsForeignLoad *load = (VipsForeignLoad *) heif;
214 	int bands;
215 	int i;
216 	heif_item_id id[16];
217 	int n_metadata;
218 	struct heif_error error;
219 	VipsForeignHeifCompression compression;
220 	if( vips_foreign_load_heif_set_page( heif, heif-&gt;page, FALSE ) )
221 		return( -1 );
222 	if ( heif-&gt;page_width &lt; 1 || heif-&gt;page_height &lt; 1 ) {
223 		vips_error( "heifload", "%s", _( "bad dimensions" ) );
224 		return( -1 );
225 	}
226 	heif-&gt;has_alpha = heif_image_handle_has_alpha_channel( heif-&gt;handle );
227 #ifdef DEBUG
228 	printf( "heif_image_handle_has_alpha_channel() = %d\n", 
229 		heif-&gt;has_alpha );
230 	bands = heif-&gt;has_alpha ? 4 : 3;
231 	n_metadata = heif_image_handle_get_list_of_metadata_block_IDs( 
232 		heif-&gt;handle, NULL, id, VIPS_NUMBER( id ) );
233 	for( i = 0; i &lt; n_metadata; i++ ) {
234 		size_t length = heif_image_handle_get_metadata_size( 
235 			heif-&gt;handle, id[i] );
236 		const char *type = heif_image_handle_get_metadata_type( 
237 			heif-&gt;handle, id[i] );
238 		unsigned char *data;
239 		char name[256];
240 #ifdef DEBUG
241 		printf( "metadata type = %s, length = %zu\n", type, length ); 
242 		if( !length )
243 			continue;
244 		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
245 			return( -1 );
246 		error = heif_image_handle_get_metadata( 
247 			heif-&gt;handle, id[i], data );
248 		if( error.code ) {
249 			vips__heif_error( &amp;error );
250 			return( -1 );
251 		}
252 		if( length &gt; 4 &amp;&amp;
253 			g_ascii_strcasecmp( type, "exif" ) == 0 ) {
254 			data += 4;
255 			length -= 4;
256 		}
257 		if( g_ascii_strcasecmp( type, "exif" ) == 0 )
258 			vips_snprintf( name, 256, VIPS_META_EXIF_NAME );
259 		else if( g_ascii_strcasecmp( type, "mime" ) == 0 &amp;&amp;
260 			length &gt; 10 &amp;&amp;
261 			vips_isprefix( "&lt;x:xmpmeta", (const char *) data ) ) 
262 			vips_snprintf( name, 256, VIPS_META_XMP_NAME );
263 		else
264 			vips_snprintf( name, 256, "heif-%s-%d", type, i );
265 		vips_image_set_blob( out, name, 
266 			(VipsCallbackFn) NULL, data, length );
267 	}
268 	vips_autorot_remove_angle( out );
269 #ifdef HAVE_HEIF_COLOR_PROFILE
270 	enum heif_color_profile_type profile_type = 
271 		heif_image_handle_get_color_profile_type( heif-&gt;handle );
272 #ifdef DEBUG
273 {
274 	printf( "profile type = " ); 
275 	switch( profile_type ) {
276 	case heif_color_profile_type_not_present: 
277 		printf( "none" ); 
278 		break;
279 	case heif_color_profile_type_nclx: 
280 		printf( "nclx" ); 
281 		break;
282 	case heif_color_profile_type_rICC: 
283 		printf( "rICC" ); 
284 		break;
285 	case heif_color_profile_type_prof: 
286 		printf( "prof" ); 
287 		break;
288 	default:
289 		printf( "unknown" ); 
290 		break;
291 	}
292 	printf( "\n" ); 
293 }
294 	if( profile_type == heif_color_profile_type_prof ||
295 		profile_type == heif_color_profile_type_rICC ) {
296 		size_t length = heif_image_handle_get_raw_color_profile_size( 
297 			heif-&gt;handle );
298 		unsigned char *data;
299 		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
300 			return( -1 );
301 		error = heif_image_handle_get_raw_color_profile( 
302 			heif-&gt;handle, data );
303 		if( error.code ) {
304 			vips__heif_error( &amp;error );
305 			return( -1 );
306 		}
307 #ifdef DEBUG
308 		printf( "profile data, length = %zd\n", length ); 
309 		vips_image_set_blob( out, VIPS_META_ICC_NAME, 
310 			(VipsCallbackFn) NULL, data, length );
311 	}
312 	else if( profile_type == heif_color_profile_type_nclx ) {
313 		g_warning( "heifload: ignoring nclx profile" );
314 	}
315 	vips_image_set_int( out, "heif-primary", heif-&gt;primary_page );
316 	vips_image_set_int( out, "n-pages", heif-&gt;n_top );
317 	if( vips_object_argument_isset( VIPS_OBJECT( heif ), "n" ) )
318 		vips_image_set_int( out, 
319 			VIPS_META_PAGE_HEIGHT, heif-&gt;page_height );
320 	compression = VIPS_FOREIGN_HEIF_COMPRESSION_HEVC;
321 #ifdef HAVE_HEIF_AVIF
322 {
323 	const unsigned char *brand_data;
324 	if( (brand_data = vips_source_sniff( heif-&gt;source, 12 )) ) {
325 		enum heif_brand brand;
326 		brand = heif_main_brand( brand_data, 12 );
327 		if( brand == heif_avif || 
328 			brand == heif_avis )
329 			compression = VIPS_FOREIGN_HEIF_COMPRESSION_AV1;
330 	}
331 }
332 	vips_image_set_string( out, "heif-compression",
333 		vips_enum_nick( VIPS_TYPE_FOREIGN_HEIF_COMPRESSION,
334 			compression ) );
335 	if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_THINSTRIP, NULL ) )
336 		return( -1 );
337 	vips_image_init_fields( out,
338 		heif-&gt;page_width, heif-&gt;page_height * heif-&gt;n, bands, 
339 		VIPS_FORMAT_UCHAR, VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 
340 		1.0, 1.0 );
341 	VIPS_SETSTR( load-&gt;out-&gt;filename, 
342 		vips_connection_filename( VIPS_CONNECTION( heif-&gt;source ) ) );
343 	return( 0 );
344 }
345 static int
346 vips_foreign_load_heif_header( VipsForeignLoad *load )
347 {
348 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
349 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
350 	struct heif_error error;
351 	heif_item_id primary_id;
352 	int i;
353 #ifdef DEBUG
354 	printf( "vips_foreign_load_heif_header:\n" );
355 	heif-&gt;n_top = heif_context_get_number_of_top_level_images( heif-&gt;ctx );
356 	heif-&gt;id = VIPS_ARRAY( NULL, heif-&gt;n_top, heif_item_id );
357 	heif_context_get_list_of_top_level_image_IDs( heif-&gt;ctx, 
358 		heif-&gt;id, heif-&gt;n_top );
359 	error = heif_context_get_primary_image_ID( heif-&gt;ctx, &amp;primary_id );
360 	if( error.code ) {
361 		vips__heif_error( &amp;error );
362 		return( -1 );
363 	}
364 	for( i = 0; i &lt; heif-&gt;n_top; i++ )
365 		if( heif-&gt;id[i] == primary_id )
366 			heif-&gt;primary_page = i;
367 	if( !vips_object_argument_isset( VIPS_OBJECT( load ), "page" ) &amp;&amp;
368 		!vips_object_argument_isset( VIPS_OBJECT( load ), "n" ) )
369 		heif-&gt;page = heif-&gt;primary_page;
370 	if( heif-&gt;n == -1 )
371 		heif-&gt;n = heif-&gt;n_top - heif-&gt;page;
372 	if( heif-&gt;page &lt; 0 ||
373 		heif-&gt;n &lt;= 0 ||
374 		heif-&gt;page + heif-&gt;n &gt; heif-&gt;n_top ) {
375 		vips_error( class-&gt;nickname, "%s", _( "bad page number" ) ); 
376 		return( -1 ); 
377 	}
378 #ifdef DEBUG
379 	for( i = heif-&gt;page; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
380 		heif_item_id thumb_ids[1];
381 		int n_items;
382 		int n_thumbs;
383 		int j;
384 		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
385 			return( -1 );
386 		n_thumbs = heif_image_handle_get_number_of_thumbnails( 
387 			heif-&gt;handle );
388 		n_items = heif_image_handle_get_list_of_thumbnail_IDs( 
389 			heif-&gt;handle, thumb_ids, 1 );
390 		printf( "page = %d\n", i );
391 		printf( "n_thumbs = %d\n", n_thumbs );
392 		printf( "n_items = %d\n", n_items );
393 		for( j = 0; j &lt; n_items; j++ ) {
394 			struct heif_image_handle *thumb_handle;
395 			error = heif_image_handle_get_thumbnail( heif-&gt;handle,
396 				thumb_ids[j], &amp;thumb_handle );
397 			if( error.code ) {
398 				vips__heif_error( &amp;error );
399 				return( -1 );
400 			}
401 			printf( "  thumb %d\n", j );
402 			printf( "    width = %d\n", 
403 				heif_image_handle_get_width( thumb_handle ) );
404 			printf( "    height = %d\n", 
405 				heif_image_handle_get_height( thumb_handle ) );
406 		}
407 	}
408 	if( vips_foreign_load_heif_set_page( heif, 
409 		heif-&gt;page, heif-&gt;thumbnail ) )
410 		return( -1 );
411 	heif-&gt;page_width = heif_image_handle_get_width( heif-&gt;handle );
412 	heif-&gt;page_height = heif_image_handle_get_height( heif-&gt;handle );
413 	for( i = heif-&gt;page + 1; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
414 		if( vips_foreign_load_heif_set_page( heif, 
415 			i, heif-&gt;thumbnail ) )
416 			return( -1 );
417 		if( heif_image_handle_get_width( heif-&gt;handle ) 
418 				!= heif-&gt;page_width ||
419 			heif_image_handle_get_height( heif-&gt;handle ) 
420 				!= heif-&gt;page_height ) {
421 			vips_error( class-&gt;nickname, "%s", 
422 				_( "not all pages are the same size" ) ); 
423 			return( -1 ); 
424 		}
425 	}
426 #ifdef DEBUG
427 	printf( "page_width = %d\n", heif-&gt;page_width );
428 	printf( "page_height = %d\n", heif-&gt;page_height );
429 	printf( "n_top = %d\n", heif-&gt;n_top );
430 	for( i = 0; i &lt; heif-&gt;n_top; i++ ) {
431 		printf( "  id[%d] = %d\n", i, heif-&gt;id[i] );
432 		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
433 			return( -1 );
434 		printf( "    width = %d\n", 
435 			heif_image_handle_get_width( heif-&gt;handle ) );
436 		printf( "    height = %d\n", 
437 			heif_image_handle_get_height( heif-&gt;handle ) );
438 		printf( "    has_depth = %d\n", 
439 			heif_image_handle_has_depth_image( heif-&gt;handle ) );
440 		printf( "    has_alpha = %d\n", 
441 			heif_image_handle_has_alpha_channel( heif-&gt;handle ) );
442 		printf( "    n_metadata = %d\n", 
443 			heif_image_handle_get_number_of_metadata_blocks( 
444 				heif-&gt;handle, NULL ) );
445 #ifdef HAVE_HEIF_COLOR_PROFILE
446 		printf( "    colour profile type = 0x%xd\n", 
447 			heif_image_handle_get_color_profile_type( 
448 				heif-&gt;handle ) );
449 	}
450 	if( vips_foreign_load_heif_set_header( heif, load-&gt;out ) )
451 		return( -1 );
452 	vips_source_minimise( heif-&gt;source );
453 	return( 0 );
454 }
455 #ifdef DEBUG
456 void
457 vips__heif_image_print( struct heif_image *img )
458 {
459 	const static enum heif_channel channel[] = {
460 		heif_channel_Y,
461 		heif_channel_Cb,
462 		heif_channel_Cr,
463 		heif_channel_R,
464 		heif_channel_G,
465 		heif_channel_B,
466 		heif_channel_Alpha,
467 		heif_channel_interleaved
468 	};
469 	const static char *channel_name[] = {
470 		"heif_channel_Y",
471 		"heif_channel_Cb",
472 		"heif_channel_Cr",
473 		"heif_channel_R",
474 		"heif_channel_G",
475 		"heif_channel_B",
476 		"heif_channel_Alpha",
477 		"heif_channel_interleaved"
478 	};
479 	int i;
480 	printf( "vips__heif_image_print:\n" );
481 	for( i = 0; i &lt; VIPS_NUMBER( channel ); i++ ) {
482 		if( !heif_image_has_channel( img, channel[i] ) )
483 			continue;
484 		printf( "\t%s:\n", channel_name[i] ); 
485 		printf( "\t\twidth = %d\n", 
486 			heif_image_get_width( img, channel[i] ) );
487 		printf( "\t\theight = %d\n", 
488 			heif_image_get_height( img, channel[i] ) );
489 		printf( "\t\tbits = %d\n", 
490 			heif_image_get_bits_per_pixel( img, channel[i] ) );
491 	}
492 }
493 static int
494 vips_foreign_load_heif_generate( VipsRegion *or, 
495 	void *seq, void *a, void *b, gboolean *stop )
496 {
497 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) a;
498 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( heif );
499         VipsRect *r = &amp;or-&gt;valid;
500 	int page = r-&gt;top / heif-&gt;page_height + heif-&gt;page;
501 	int line = r-&gt;top % heif-&gt;page_height;
502 #ifdef DEBUG_VERBOSE
503 	printf( "vips_foreign_load_heif_generate: line %d\n", r-&gt;top );
504 	g_assert( r-&gt;height == 1 );
505 	if( vips_foreign_load_heif_set_page( heif, page, heif-&gt;thumbnail ) )
506 		return( -1 );
507 	if( !heif-&gt;img ) {
508 		struct heif_error error;
509 		struct heif_decoding_options *options;
510 		enum heif_chroma chroma = heif-&gt;has_alpha ? 
511 			heif_chroma_interleaved_RGBA :
512 			heif_chroma_interleaved_RGB;
513 		options = heif_decoding_options_alloc();
514 #ifdef HAVE_HEIF_DECODING_OPTIONS_CONVERT_HDR_TO_8BIT
515 		options-&gt;convert_hdr_to_8bit = TRUE;
516 		error = heif_decode_image( heif-&gt;handle, &amp;heif-&gt;img, 
517 			heif_colorspace_RGB, chroma, 
518 			options );
519 		heif_decoding_options_free( options );
520 		if( error.code ) {
521 			vips__heif_error( &amp;error );
522 			return( -1 );
523 		}
524 #ifdef DEBUG
525 		vips__heif_image_print( heif-&gt;img );
526 	}
527 	if( !heif-&gt;data ) {
528 		int image_width = heif_image_get_width( heif-&gt;img, 
529 			heif_channel_interleaved );
530 		int image_height = heif_image_get_height( heif-&gt;img, 
531 			heif_channel_interleaved );
532 		if( image_width != heif-&gt;page_width ||
533 			image_height != heif-&gt;page_height ) {
534 			vips_error( class-&gt;nickname, 
535 				"%s", _( "bad image dimensions on decode" ) );
536 			return( -1 );
537 		}
538 		if( !(heif-&gt;data = heif_image_get_plane_readonly( heif-&gt;img, 
539 			heif_channel_interleaved, &amp;heif-&gt;stride )) ) {
540 			vips_error( class-&gt;nickname, 
541 				"%s", _( "unable to get image data" ) );
542 			return( -1 );
543 		}
544 	}
545 	memcpy( VIPS_REGION_ADDR( or, 0, r-&gt;top ),
546 		heif-&gt;data + heif-&gt;stride * line, 
547 		VIPS_IMAGE_SIZEOF_LINE( or-&gt;im ) );
548 	return( 0 );
549 }
550 static void
551 vips_foreign_load_heif_minimise( VipsObject *object, VipsForeignLoadHeif *heif )
552 {
553 	vips_source_minimise( heif-&gt;source );
554 }
555 static int
556 vips_foreign_load_heif_load( VipsForeignLoad *load )
557 {
558 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
559 	VipsImage **t = (VipsImage **) 
560 		vips_object_local_array( VIPS_OBJECT( load ), 3 );
561 #ifdef DEBUG
562 	printf( "vips_foreign_load_heif_load: loading image\n" );
563 	t[0] = vips_image_new();
564 	if( vips_foreign_load_heif_set_header( heif, t[0] ) )
565 		return( -1 );
566 	g_signal_connect( t[0], "minimise", 
567 		G_CALLBACK( vips_foreign_load_heif_minimise ), heif ); 
568 	if( vips_image_generate( t[0],
569 		NULL, vips_foreign_load_heif_generate, NULL, heif, NULL ) ||
570 		vips_sequential( t[0], &amp;t[1], NULL ) ||
571 		vips_image_write( t[1], load-&gt;real ) )
572 		return( -1 );
573 	if( vips_source_decode( heif-&gt;source ) )
574 		return( -1 );
575 	return( 0 );
576 }
577 static void
578 vips_foreign_load_heif_class_init( VipsForeignLoadHeifClass *class )
579 {
580 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
581 <a name="2"></a>	VipsObjectClass *object_class = (VipsObjectClass *) class;
582 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
583 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	gobject_class-&gt;dispose = vips_foreign_load_heif_dispose;
584 	gobject_class-&gt;set_property = vips_object_set_property;
585 	gobject_class-&gt;get_property = vips_object_get_property;
586 	object_class-&gt;nickname = "heifload_base";
587 	object_class-&gt;description = _( "load a HEIF image" );
588 	object_class-&gt;build = vips_foreign_load_heif_build;
589 	load_class-&gt;get_flags = vips_foreign_load_heif_get_flags;
590 	load_class-&gt;header = vips_foreign_load_heif_header;
591 	load_class-&gt;load = vips_foreign_load_heif_load;
592 	VIPS_ARG_INT( class, "page", 2,
593 		_( "Page" ),
594 		_( "Load this page from the file" ),
595 		VIPS_ARGUMENT_OPTIONAL_INPUT,
596 		G_STRUCT_OFFSET( VipsForeignLoadHeif, page ),
597 		0, 100000, 0 );
598 	VIPS_ARG_INT( class, "n", 3,
599 		_( "n" ),
600 		_( "Load this many pages" ),
601 		VIPS_ARGUMENT_OPTIONAL_INPUT,
602 		G_STRUCT_OFFSET( VipsForeignLoadHeif, n ),
603 		-1, 100000, 1 );
604 	VIPS_ARG_BOOL( class, "thumbnail", 4, 
605 		_( "Thumbnail" ), 
606 		_( "Fetch thumbnail image" ),
607 		VIPS_ARGUMENT_OPTIONAL_INPUT,
608 		G_STRUCT_OFFSET( VipsForeignLoadHeif, thumbnail ),
609 		FALSE );
610 	VIPS_ARG_BOOL( class, "autorotate", 21, 
611 		_( "Autorotate" ), 
612 		_( "Rotate image using exif orientation" ),
613 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
614 		G_STRUCT_OFFSET( VipsForeignLoadHeif, autorotate ),
615 		FALSE );
616 }
617 static gint64
618 vips_foreign_load_heif_get_position( void *userdata )
619 {
620 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;</b></font>
621 	return( vips_source_seek( heif-&gt;source, 0L, SEEK_CUR ) );
622 }
623 static int
624 vips_foreign_load_heif_read( void *data, size_t size, void *userdata )
625 {
626 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
627 	while( size &gt; 0 ) {
628 		gint64 bytes_read;
629 		bytes_read = vips_source_read( heif-&gt;source, data, size );
630 		if( bytes_read &lt;= 0 ) 
631 			return( -1 );
632 		size -= bytes_read;
633 		data += bytes_read;
634 	}
635 	return( 0 );
636 }
637 static int
638 vips_foreign_load_heif_seek( gint64 position, void *userdata )
639 {
640 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
641 	return( vips_source_seek( heif-&gt;source, position, SEEK_SET ) == -1 );
642 }
643 static enum heif_reader_grow_status 
644 vips_foreign_load_heif_wait_for_file_size( gint64 target_size, void *userdata )
645 {
646 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
647 	gint64 old_position;
648 	gint64 result;
649 	enum heif_reader_grow_status status;
650 	old_position = vips_source_seek( heif-&gt;source, 0L, SEEK_CUR );
651 	result = vips_source_seek( heif-&gt;source, target_size, SEEK_SET );
652 	vips_source_seek( heif-&gt;source, old_position, SEEK_SET );
653 	if( result &lt; 0 )
654 		status = heif_reader_grow_status_size_beyond_eof;
655 	else
656 		status = heif_reader_grow_status_size_reached;
657 	return( status );
658 }
659 static void
660 vips_foreign_load_heif_init( VipsForeignLoadHeif *heif )
661 {
662 	heif-&gt;n = 1;
663 	heif-&gt;reader = VIPS_ARRAY( NULL, 1, struct heif_reader );
664 	heif-&gt;reader-&gt;reader_api_version = 1;
665 	heif-&gt;reader-&gt;get_position = vips_foreign_load_heif_get_position;
666 	heif-&gt;reader-&gt;read = vips_foreign_load_heif_read;
667 <a name="6"></a>	heif-&gt;reader-&gt;seek = vips_foreign_load_heif_seek;
668 	heif-&gt;reader-&gt;wait_for_file_size = 
669 		vips_foreign_load_heif_wait_for_file_size;
670 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
671 typedef struct _VipsForeignLoadHeifFile {
672 	VipsForeignLoadHeif parent_object;
673 	char *filename; 
674 } VipsForeignLoadHeifFile;
675 typedef VipsForeignLoadHeifClass VipsForeignLoadHeifFileClass;
676 G_DEFINE_TYPE( VipsForeignLoadHeifFile, vips_foreign_load_heif_file, 
677 	vips_foreign_load_heif_get_type() );
678 static int
679 vips_foreign_load_heif_file_build( VipsObject *object )
680 {
681 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
682 	VipsForeignLoadHeifFile *file = (VipsForeignLoadHeifFile *) object;
683 	if( file-&gt;filename ) </b></font>
684 		if( !(heif-&gt;source = 
685 			vips_source_new_from_file( file-&gt;filename )) )
686 			return( -1 );
687 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
688 		build( object ) )
689 		return( -1 );
690 	return( 0 );
691 }
692 static int
693 vips_foreign_load_heif_file_is_a( const char *filename )
694 {
695 <a name="4"></a>	char buf[12];
696 	if( vips__get_bytes( filename, (unsigned char *) buf, 12 ) != 12 )
697 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( 0 );
698 	return( vips_foreign_load_heif_is_a( buf, 12 ) );
699 }
700 static void
701 vips_foreign_load_heif_file_class_init( VipsForeignLoadHeifFileClass *class )
702 {
703 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
704 	VipsObjectClass *object_class = (VipsObjectClass *) class;
705 <a name="0"></a>	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
706 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
707 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	gobject_class-&gt;set_property = vips_object_set_property;
708 	gobject_class-&gt;get_property = vips_object_get_property;
709 	object_class-&gt;nickname = "heifload";
710 	object_class-&gt;build = vips_foreign_load_heif_file_build;
711 	foreign_class-&gt;suffs = vips__heif_suffs;
712 	load_class-&gt;is_a = vips_foreign_load_heif_file_is_a;
713 	VIPS_ARG_STRING( class, "filename", 1, 
714 		_( "Filename" ),
715 		_( "Filename to load from" ),
716 		VIPS_ARGUMENT_REQUIRED_INPUT, 
717 		G_STRUCT_OFFSET( VipsForeignLoadHeifFile, filename ),
718 		NULL );
719 }
720 static void
721 vips_foreign_load_heif_file_init( VipsForeignLoadHeifFile *file )
722 {
723 }
724 typedef struct _VipsForeignLoadHeifBuffer {
725 	VipsForeignLoadHeif parent_object;
726 	VipsArea *buf;
727 } VipsForeignLoadHeifBuffer;
728 typedef VipsForeignLoadHeifClass VipsForeignLoadHeifBufferClass;
729 G_DEFINE_TYPE( VipsForeignLoadHeifBuffer, vips_foreign_load_heif_buffer, 
730 	vips_foreign_load_heif_get_type() );
731 static int
732 vips_foreign_load_heif_buffer_build( VipsObject *object )
733 {
734 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
735 	VipsForeignLoadHeifBuffer *buffer = 
736 		(VipsForeignLoadHeifBuffer *) object;
737 	if( buffer-&gt;buf )</b></font>
738 		if( !(heif-&gt;source = vips_source_new_from_memory( 
739 			VIPS_AREA( buffer-&gt;buf )-&gt;data, 
740 			VIPS_AREA( buffer-&gt;buf )-&gt;length )) )
741 			return( -1 );
742 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
743 		build( object ) )
744 		return( -1 );
745 	return( 0 );
746 }
747 <a name="3"></a>static gboolean
748 vips_foreign_load_heif_buffer_is_a( const void *buf, size_t len )
749 {
750 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( vips_foreign_load_heif_is_a( buf, len ) );
751 }
752 static void
753 vips_foreign_load_heif_buffer_class_init( 
754 	VipsForeignLoadHeifBufferClass *class )
755 {
756 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
757 	VipsObjectClass *object_class = (VipsObjectClass *) class;
758 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
759 	gobject_class-&gt;set_property = vips_object_set_property;
760 	gobject_class-&gt;get_property = vips_object_get_property;
761 	object_class-&gt;nickname = "heifload_buffer";
762 	object_class-&gt;build = vips_foreign_load_heif_buffer_build;
763 	load_class-&gt;is_a_buffer = vips_foreign_load_heif_buffer_is_a;</b></font>
764 	VIPS_ARG_BOXED( class, "buffer", 1, 
765 		_( "Buffer" ),
766 		_( "Buffer to load from" ),
767 		VIPS_ARGUMENT_REQUIRED_INPUT, 
768 		G_STRUCT_OFFSET( VipsForeignLoadHeifBuffer, buf ),
769 		VIPS_TYPE_BLOB );
770 }
771 <a name="1"></a>static void
772 vips_foreign_load_heif_buffer_init( VipsForeignLoadHeifBuffer *buffer )
773 {
774 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
775 typedef struct _VipsForeignLoadHeifSource {
776 	VipsForeignLoadHeif parent_object;
777 	VipsSource *source;
778 } VipsForeignLoadHeifSource;
779 typedef VipsForeignLoadHeifClass VipsForeignLoadHeifSourceClass;
780 G_DEFINE_TYPE( VipsForeignLoadHeifSource, vips_foreign_load_heif_source, 
781 	vips_foreign_load_heif_get_type() );
782 static int
783 vips_foreign_load_heif_source_build( VipsObject *object )
784 {
785 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
786 	VipsForeignLoadHeifSource *source = 
787 		(VipsForeignLoadHeifSource *) object;
788 	if( source-&gt;source ) {
789 		heif-&gt;source = source-&gt;source;
790 		g_object_ref( heif-&gt;source );
791 	}
792 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_source_parent_class )-&gt;
793 		build( object ) )
794 		return( -1 );
795 	return( 0 );
796 }
797 static gboolean</b></font>
798 vips_foreign_load_heif_source_is_a_source( VipsSource *source )
799 {
800 	const char *p;
801 	return( (p = (const char *) vips_source_sniff( source, 12 )) &amp;&amp;
802 <a name="5"></a>		vips_foreign_load_heif_is_a( p, 12 ) );
803 }
804 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static void
805 vips_foreign_load_heif_source_class_init( 
806 	VipsForeignLoadHeifSourceClass *class )
807 {
808 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
809 	VipsObjectClass *object_class = (VipsObjectClass *) class;
810 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
811 	gobject_class-&gt;set_property = vips_object_set_property;
812 	gobject_class-&gt;get_property = vips_object_get_property;
813 	object_class-&gt;nickname = "heifload_source";
814 	object_class-&gt;build = vips_foreign_load_heif_source_build;
815 	load_class-&gt;is_a_source = vips_foreign_load_heif_source_is_a_source;</b></font>
816 	VIPS_ARG_OBJECT( class, "source", 1,
817 		_( "Source" ),
818 		_( "Source to load from" ),
819 		VIPS_ARGUMENT_REQUIRED_INPUT, 
820 		G_STRUCT_OFFSET( VipsForeignLoadHeifSource, source ),
821 		VIPS_TYPE_SOURCE );
822 }
823 static void
824 vips_foreign_load_heif_source_init( VipsForeignLoadHeifSource *source )
825 {
826 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
