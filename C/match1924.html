<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for webpload.c & heifload.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for webpload.c & heifload.c
      </h3>
      <h1 align="center">
        25.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>webpload.c (46.53846%)<TH>heifload.c (18.005953%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1924-0.html#0',2,'match1924-1.html#0',3)" NAME="0">(339-383)<TD><A HREF="javascript:ZweiFrames('match1924-0.html#0',2,'match1924-1.html#0',3)" NAME="0">(1134-1179)</A><TD ALIGN=center><FONT COLOR="#ff0000">24</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1924-0.html#1',2,'match1924-1.html#1',3)" NAME="1">(218-251)<TD><A HREF="javascript:ZweiFrames('match1924-0.html#1',2,'match1924-1.html#1',3)" NAME="1">(1226-1261)</A><TD ALIGN=center><FONT COLOR="#d40000">20</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1924-0.html#2',2,'match1924-1.html#2',3)" NAME="2">(163-215)<TD><A HREF="javascript:ZweiFrames('match1924-0.html#2',2,'match1924-1.html#2',3)" NAME="2">(951-996)</A><TD ALIGN=center><FONT COLOR="#bf0000">18</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1924-0.html#3',2,'match1924-1.html#3',3)" NAME="3">(407-423)<TD><A HREF="javascript:ZweiFrames('match1924-0.html#3',2,'match1924-1.html#3',3)" NAME="3">(1195-1212)</A><TD ALIGN=center><FONT COLOR="#b40000">17</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1924-0.html#4',2,'match1924-1.html#4',3)" NAME="4">(148-159)<TD><A HREF="javascript:ZweiFrames('match1924-0.html#4',2,'match1924-1.html#4',3)" NAME="4">(1121-1132)</A><TD ALIGN=center><FONT COLOR="#9f0000">15</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match1924-0.html#5',2,'match1924-1.html#5',3)" NAME="5">(251-264)<TD><A HREF="javascript:ZweiFrames('match1924-0.html#5',2,'match1924-1.html#5',3)" NAME="5">(1270-1284)</A><TD ALIGN=center><FONT COLOR="#940000">14</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match1924-0.html#6',2,'match1924-1.html#6',3)" NAME="6">(280-302)<TD><A HREF="javascript:ZweiFrames('match1924-0.html#6',2,'match1924-1.html#6',3)" NAME="6">(1081-1103)</A><TD ALIGN=center><FONT COLOR="#8a0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>webpload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* load webp images
 *
 * 6/8/13
 * 	- from pngload.c
 * 28/2/16
 * 	- add @shrink
 * 1/11/18
 * 	- add @page, @n
 * 30/4/19
 * 	- deprecate @shrink, use @scale instead
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG_VERBOSE
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;

#include &quot;pforeign.h&quot;

#ifdef HAVE_LIBWEBP

typedef struct _VipsForeignLoadWebp {
	VipsForeignLoad parent_object;

	/* Set by subclasses.
	 */
	VipsSource *source;

	/* Load this page (frame number).
	 */
	int page;

	/* Load this many pages.
	 */
	int n;

	/* Scale by this much during load.
	 */
	double scale; 

	/* Old and deprecated scaling path.
	 */
	int shrink;
} VipsForeignLoadWebp;

typedef VipsForeignLoadClass VipsForeignLoadWebpClass;

G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadWebp, vips_foreign_load_webp, 
	VIPS_TYPE_FOREIGN_LOAD );

static void
vips_foreign_load_webp_dispose( GObject *gobject )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) gobject;

	VIPS_UNREF( webp-&gt;source );

	G_OBJECT_CLASS( vips_foreign_load_webp_parent_class )-&gt;
		dispose( gobject );
}

static int
vips_foreign_load_webp_build( VipsObject *object )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;

	/* BC for the old API.
	 */
	if( !vips_object_argument_isset( VIPS_OBJECT( webp ), &quot;scale&quot; ) &amp;&amp;
		vips_object_argument_isset( VIPS_OBJECT( webp ), &quot;shrink&quot; ) &amp;&amp;
		webp-&gt;shrink != 0 )
		webp-&gt;scale = 1.0 / webp-&gt;shrink;

	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static VipsForeignFlags
vips_foreign_load_webp_get_flags( VipsForeignLoad *load )
{
	return( 0 );
}

static VipsForeignFlags
vips_foreign_load_webp_get_flags_filename( const char *filename )
{
	return( 0 );
}

static int
vips_foreign_load_webp_header( VipsForeignLoad *load )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) load;

	if( vips__webp_read_header_source( webp-&gt;source, load-&gt;out, 
		webp-&gt;page, webp-&gt;n, webp-&gt;scale ) ) 
		return( -1 );

	return( 0 );
}

static int
vips_foreign_load_webp_load( VipsForeignLoad *load )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) load;
<A NAME="4"></A>
	if( vips__webp_read_source( webp-&gt;source, load-&gt;real, 
		webp-&gt;page, webp-&gt;n, webp-&gt;scale ) ) 
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1924-1.html#4',3,'match1924-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_webp_class_init( VipsForeignLoadWebpClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</B></FONT>
<A NAME="2"></A>
	gobject_class-&gt;dispose = vips_foreign_load_webp_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1924-1.html#2',3,'match1924-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;webpload_base&quot;;
	object_class-&gt;description = _( &quot;load webp&quot; );
	object_class-&gt;build = vips_foreign_load_webp_build;

	/* is_a() is not that quick ... lower the priority.
	 */
	foreign_class-&gt;priority = -50;

	load_class-&gt;get_flags_filename = 
		vips_foreign_load_webp_get_flags_filename;
	load_class-&gt;get_flags = vips_foreign_load_webp_get_flags;
	load_class-&gt;header = vips_foreign_load_webp_header;
	load_class-&gt;load = vips_foreign_load_webp_load;

	VIPS_ARG_INT( class, &quot;page&quot;, 20,
		_( &quot;Page&quot; ),
		_( &quot;Load this page from the file&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadWebp, page ),
		0, 100000, 0 );

	VIPS_ARG_INT( class, &quot;n&quot;, 21,
		_( &quot;n&quot; ),
		_( &quot;Load this many pages&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadWebp, n ),
		-1, 100000, 1 );

	VIPS_ARG_DOUBLE( class, &quot;scale&quot;, 22, 
		_( &quot;Scale&quot; ), 
		_( &quot;Scale factor on load&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadWebp, scale ),
		0.0, 1024.0, 1.0 );

	/* Old and deprecated scaling API. A float param lets do
	 * shrink-on-load for thumbnail faster and more accurately.
	 */
	VIPS_ARG_INT( class, &quot;shrink&quot;, 23, 
		_( &quot;Shrink&quot; ), 
		_( &quot;Shrink factor on load&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignLoadWebp, shrink ),
		1, 1024, 1 );

}

static void
vips_foreign_load_webp_init( VipsForeignLoadWebp *webp )
{
<A NAME="1"></A>	webp-&gt;n = 1;</B></FONT>
	webp-&gt;shrink = 1;
	webp-&gt;scale = 1.0;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1924-1.html#1',3,'match1924-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

typedef struct _VipsForeignLoadWebpSource {
	VipsForeignLoadWebp parent_object;

	VipsSource *source;

} VipsForeignLoadWebpSource;

typedef VipsForeignLoadWebpClass VipsForeignLoadWebpSourceClass;

G_DEFINE_TYPE( VipsForeignLoadWebpSource, vips_foreign_load_webp_source, 
	vips_foreign_load_webp_get_type() );

static int
vips_foreign_load_webp_source_build( VipsObject *object )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
	VipsForeignLoadWebpSource *source = 
		(VipsForeignLoadWebpSource *) object;

	if( source-&gt;source ) {
		webp-&gt;source = source-&gt;source;
		g_object_ref( webp-&gt;source );
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_source_parent_class )-&gt;
		build( object ) )
		return( -1 );

<A NAME="5"></A>	return( 0 );
}

static void</B></FONT><FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match1924-1.html#5',3,'match1924-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>
vips_foreign_load_webp_source_class_init( 
	VipsForeignLoadWebpSourceClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;webpload_source&quot;;
	object_class-&gt;description = _( &quot;load webp from source&quot; );
	object_class-&gt;build = vips_foreign_load_webp_source_build;</B></FONT>

	load_class-&gt;is_a_source = vips__iswebp_source; 

	VIPS_ARG_OBJECT( class, &quot;source&quot;, 1,
		_( &quot;Source&quot; ),
		_( &quot;Source to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadWebpSource, source ),
		VIPS_TYPE_SOURCE );

}

<A NAME="6"></A>static void
vips_foreign_load_webp_source_init( VipsForeignLoadWebpSource *buffer )
{
<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match1924-1.html#6',3,'match1924-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

typedef struct _VipsForeignLoadWebpFile {
	VipsForeignLoadWebp parent_object;

	/* Filename for load.
	 */
	char *filename; 

} VipsForeignLoadWebpFile;

typedef VipsForeignLoadWebpClass VipsForeignLoadWebpFileClass;

G_DEFINE_TYPE( VipsForeignLoadWebpFile, vips_foreign_load_webp_file, 
	vips_foreign_load_webp_get_type() );

static int
vips_foreign_load_webp_file_build( VipsObject *object )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
	VipsForeignLoadWebpFile *file = (VipsForeignLoadWebpFile *) object;

	if( file-&gt;filename &amp;&amp;</B></FONT>
		!(webp-&gt;source = 
			vips_source_new_from_file( file-&gt;filename )) )
		return( -1 );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_file_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static gboolean
vips_foreign_load_webp_file_is_a( const char *filename )
{
	VipsSource *source;
	gboolean result;

	if( !(source = vips_source_new_from_file( filename )) )
		return( FALSE );
	result = vips__iswebp_source( source );
	VIPS_UNREF( source );

	return( result );
}

const char *vips__webp_suffs[] = { &quot;.webp&quot;, NULL };

static void
vips_foreign_load_webp_file_class_init( VipsForeignLoadWebpFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
<A NAME="0"></A>	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1924-1.html#0',3,'match1924-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;webpload&quot;;
	object_class-&gt;description = _( &quot;load webp from file&quot; );
	object_class-&gt;build = vips_foreign_load_webp_file_build;

	foreign_class-&gt;suffs = vips__webp_suffs;

	load_class-&gt;is_a = vips_foreign_load_webp_file_is_a;

	VIPS_ARG_STRING( class, &quot;filename&quot;, 1, 
		_( &quot;Filename&quot; ),
		_( &quot;Filename to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadWebpFile, filename ),
		NULL );
}

static void
vips_foreign_load_webp_file_init( VipsForeignLoadWebpFile *file )
{
}

typedef struct _VipsForeignLoadWebpBuffer {
	VipsForeignLoadWebp parent_object;

	/* Load from a buffer.
	 */
	VipsBlob *blob;

} VipsForeignLoadWebpBuffer;

typedef VipsForeignLoadWebpClass VipsForeignLoadWebpBufferClass;

G_DEFINE_TYPE( VipsForeignLoadWebpBuffer, vips_foreign_load_webp_buffer, 
	vips_foreign_load_webp_get_type() );

static int
vips_foreign_load_webp_buffer_build( VipsObject *object )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
	VipsForeignLoadWebpBuffer *buffer = 
		(VipsForeignLoadWebpBuffer *) object;

	if( buffer-&gt;blob &amp;&amp;</B></FONT>
		!(webp-&gt;source = vips_source_new_from_memory( 
			VIPS_AREA( buffer-&gt;blob )-&gt;data, 
			VIPS_AREA( buffer-&gt;blob )-&gt;length )) )
		return( -1 );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_buffer_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static gboolean
vips_foreign_load_webp_buffer_is_a_buffer( const void *buf, size_t len )
{
	VipsSource *source;
	gboolean result;

	if( !(source = vips_source_new_from_memory( buf, len )) )
		return( FALSE );
<A NAME="3"></A>	result = vips__iswebp_source( source );
	VIPS_UNREF( source );

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1924-1.html#3',3,'match1924-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( result );
}

static void
vips_foreign_load_webp_buffer_class_init( 
	VipsForeignLoadWebpBufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;webpload_buffer&quot;;
	object_class-&gt;description = _( &quot;load webp from buffer&quot; );
	object_class-&gt;build = vips_foreign_load_webp_buffer_build;</B></FONT>

	load_class-&gt;is_a_buffer = vips_foreign_load_webp_buffer_is_a_buffer; 

	VIPS_ARG_BOXED( class, &quot;buffer&quot;, 1, 
		_( &quot;Buffer&quot; ),
		_( &quot;Buffer to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadWebpBuffer, blob ),
		VIPS_TYPE_BLOB );
}

static void
vips_foreign_load_webp_buffer_init( VipsForeignLoadWebpBuffer *buffer )
{
}

#endif /*HAVE_LIBWEBP*/

/**
 * vips_webpload:
 * @filename: file to load
 * @out: (out): decompressed image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, page (frame) to read
 * * @n: %gint, load this many pages
 * * @scale: %gdouble, scale by this much on load
 *
 * Read a WebP file into a VIPS image. 
 *
 * Use @page to select a page to render, numbering from zero.
 *
 * Use @n to select the number of pages to render. The default is 1. Pages are
 * rendered in a vertical column, with each individual page aligned to the
 * left. Set to -1 to mean &quot;until the end of the document&quot;. Use vips_grid() 
 * to change page layout.
 *
 * Use @scale to specify a scale-on-load factor. For example, 2.0 to double
 * the size on load.
 *
 * The loader supports ICC, EXIF and XMP metadata. 
 *
 * See also: vips_image_new_from_file().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_webpload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;webpload&quot;, ap, filename, out );
	va_end( ap );

	return( result );
}

/**
 * vips_webpload_buffer:
 * @buf: (array length=len) (element-type guint8): memory area to load
 * @len: (type gsize): size of memory area
 * @out: (out): image to write
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, page (frame) to read
 * * @n: %gint, load this many pages
 * * @scale: %gdouble, scale by this much on load
 *
 * Read a WebP-formatted memory block into a VIPS image. Exactly as
 * vips_webpload(), but read from a memory buffer. 
 *
 * You must not free the buffer while @out is active. The 
 * #VipsObject::postclose signal on @out is a good place to free. 
 *
 * See also: vips_webpload()
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_webpload_buffer( void *buf, size_t len, VipsImage **out, ... )
{
	va_list ap;
	VipsBlob *blob;
	int result;

	/* We don't take a copy of the data or free it.
	 */
	blob = vips_blob_new( NULL, buf, len );

	va_start( ap, out );
	result = vips_call_split( &quot;webpload_buffer&quot;, ap, blob, out );
	va_end( ap );

	vips_area_unref( VIPS_AREA( blob ) );

	return( result );
}

/**
 * vips_webpload_source:
 * @source: source to load from
 * @out: (out): image to write
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, page (frame) to read
 * * @n: %gint, load this many pages
 * * @scale: %gdouble, scale by this much on load
 *
 * Exactly as vips_webpload(), but read from a source. 
 *
 * See also: vips_webpload()
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_webpload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;webpload_source&quot;, ap, source, out );
	va_end( ap );

	return( result );
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>heifload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* load heif images with libheif
 *
 * 19/1/19
 * 	- from niftiload.c
 * 24/7/19 [zhoux2016]
 * 	- always fetch metadata from the main image (thumbs don't have it)
 * 24/7/19
 * 	- close early on minimise 
 * 	- close early on error
 * 1/9/19 [meyermarcel]
 * 	- handle alpha
 * 30/9/19
 * 	- much faster handling of thumbnail=TRUE and missing thumbnail ... we
 * 	  were reselecting the image for each scanline
 * 3/10/19
 * 	- restart after minimise
 * 15/3/20
 * 	- revise for new VipsSource API
 * 10/5/20
 * 	- deprecate autorotate -- it's too difficult to support properly
 * 31/7/20
 * 	- block broken thumbnails, if we can
 * 14/2/21 kleisauke
 * 	- move GObject part to heif2vips.c
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG_VERBOSE
#define VIPS_DEBUG
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/debug.h&gt;
#include &lt;vips/internal.h&gt;

/* These are shared with the encoder.
 */
#if defined(HAVE_HEIF_DECODER) || defined(HAVE_HEIF_ENCODER)

#include &quot;pforeign.h&quot;

const char *vips__heif_suffs[] = { 
	&quot;.heic&quot;,
	&quot;.heif&quot;,
	&quot;.avif&quot;,
	NULL 
};

#endif /*defined(HAVE_HEIF_DECODER) || defined(HAVE_HEIF_ENCODER)*/

#ifdef HAVE_HEIF_DECODER

#include &lt;libheif/heif.h&gt;

#define VIPS_TYPE_FOREIGN_LOAD_HEIF (vips_foreign_load_heif_get_type())
#define VIPS_FOREIGN_LOAD_HEIF( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeif ))
#define VIPS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass))
#define VIPS_IS_FOREIGN_LOAD_HEIF( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
#define VIPS_IS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
#define VIPS_FOREIGN_LOAD_HEIF_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass ))

typedef struct _VipsForeignLoadHeif {
	VipsForeignLoad parent_object;

	/* Pages to load.
	 */
	int page;
	int n;

	/* Fetch the thumbnail instead of the image. If there is no thumbnail,
	 * just fetch the image.
	 */
	gboolean thumbnail;

	/* Apply any orientation tags in the header.
	 *
	 * This is deprecated and does nothing. Non-autorotated reads from
	 * libheif are surprisingly hard to support well, since orientation can
	 * be represented in several different ways in HEIC files and devices
	 * vary in how they do this.
	 */
	gboolean autorotate;

	/* Context for this image.
	 */
	struct heif_context *ctx;

	/* Number of top-level images in this file.
	 */
	int n_top;

	/* TRUE for RGBA ... otherwise, RGB.
	 */
	gboolean has_alpha;

	/* Size of final output image. 
	 */
	int width;
	int height;

	/* Size of each page.
	 */
	int page_width;
	int page_height;

	/* The page number currently in @handle. 
	 */
	int page_no;

	/* TRUE if @handle has selected the thumbnail rather than the main 
	 * image.
	 */
	gboolean thumbnail_set;

	/* The page number of the primary image.
	 */
	int primary_page;

	/* Array of top-level image IDs.
	 */
	heif_item_id *id;

	/* Handle for the currently selected image.
	 */
	struct heif_image_handle *handle;

	/* Decoded pixel data for the current image.
	 */
	struct heif_image *img;

	/* Valid until img is released.
	 */
	int stride;
	const uint8_t *data;

	/* Set from subclasses.
	 */
	VipsSource *source;

	/* The reader struct. We use this to attach to our VipsSource. This
	 * has to be alloced rather than in our struct, since it may change
	 * size in libheif API versions.
	 */
	struct heif_reader *reader;

} VipsForeignLoadHeif;

void
vips__heif_error( struct heif_error *error )
{
	if( error-&gt;code ) 
		vips_error( &quot;heif&quot;, &quot;%s (%d.%d)&quot;, error-&gt;message, error-&gt;code,
			error-&gt;subcode );
}

typedef struct _VipsForeignLoadHeifClass {
	VipsForeignLoadClass parent_class;

} VipsForeignLoadHeifClass;

G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadHeif, vips_foreign_load_heif, 
	VIPS_TYPE_FOREIGN_LOAD );

static void
vips_foreign_load_heif_dispose( GObject *gobject )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) gobject;

	heif-&gt;data = NULL;
	VIPS_FREEF( heif_image_release, heif-&gt;img );
	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
	VIPS_FREEF( heif_context_free, heif-&gt;ctx );
	VIPS_FREE( heif-&gt;id );
	VIPS_FREE( heif-&gt;reader );
	VIPS_UNREF( heif-&gt;source );

	G_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
		dispose( gobject );
}

static int
vips_foreign_load_heif_build( VipsObject *object )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_heif_build:\n&quot; );
#endif /*DEBUG*/

	if( heif-&gt;source &amp;&amp;
		vips_source_rewind( heif-&gt;source ) )
		return( -1 );

	if( !heif-&gt;ctx ) {
		struct heif_error error;

		heif-&gt;ctx = heif_context_alloc();
		error = heif_context_read_from_reader( heif-&gt;ctx, 
			heif-&gt;reader, heif, NULL );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static const char *heif_magic[] = {
	&quot;ftypheic&quot;,	/* A regular heif image */
	&quot;ftypheix&quot;,	/* Extended range (&gt;8 bit) image */
	&quot;ftyphevc&quot;,	/* Image sequence */
	&quot;ftypheim&quot;,	/* Image sequence */
	&quot;ftypheis&quot;,	/* Scaleable image */
	&quot;ftyphevm&quot;,	/* Multiview sequence */
	&quot;ftyphevs&quot;,	/* Scaleable sequence */
	&quot;ftypmif1&quot;,	/* Nokia alpha_ image */
	&quot;ftypmsf1&quot;,	/* Nokia animation image */
	&quot;ftypavif&quot;	/* AV1 image format */
};

/* The API has:
 *
 *	enum heif_filetype_result result = heif_check_filetype( buf, 12 );
 *
 * but it's very conservative and seems to be missing some of the Nokia heif
 * types.
 */
static int
vips_foreign_load_heif_is_a( const char *buf, int len )
{
	if( len &gt;= 12 ) {
		const guint32 chunk_len = 
			(guint32) buf[0] &lt;&lt; 24 |
			(guint32) buf[1] &lt;&lt; 16 |
			(guint32) buf[2] &lt;&lt; 8 |
			(guint32) buf[3];

		int i;

                /* We've seen real files with 36 here, so 64 should be
                 * plenty.
                 */
		if( chunk_len &gt; 64 || 
			chunk_len % 4 != 0 )
			return( 0 );

		for( i = 0; i &lt; VIPS_NUMBER( heif_magic ); i++ )
			if( strncmp( buf + 4, heif_magic[i], 8 ) == 0 )
				return( 1 );
	}

	return( 0 );
}

static VipsForeignFlags
vips_foreign_load_heif_get_flags( VipsForeignLoad *load )
{
	/* FIXME .. could support random access for grid images.
	 */
	return( VIPS_FOREIGN_SEQUENTIAL );
}

/* We've selected the page. Try to select the associated thumbnail instead, 
 * if we can.
 */
static int
vips_foreign_load_heif_set_thumbnail( VipsForeignLoadHeif *heif )
{
	heif_item_id thumb_ids[1];
	int n_thumbs;
	struct heif_image_handle *thumb_handle;
	struct heif_image *thumb_img;
	struct heif_error error;
	double main_aspect;
	double thumb_aspect;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_heif_set_thumbnail:\n&quot; );
#endif /*DEBUG*/

	n_thumbs = heif_image_handle_get_list_of_thumbnail_IDs( 
		heif-&gt;handle, thumb_ids, 1 );
	if( n_thumbs == 0 )
		return( 0 );

	error = heif_image_handle_get_thumbnail( heif-&gt;handle,
		thumb_ids[0], &amp;thumb_handle );
	if( error.code ) {
		vips__heif_error( &amp;error );
		return( -1 );
	}

	/* Just checking the width and height of the handle isn't
	 * enough -- we have to experimentally decode it and test the 
	 * decoded dimensions. 
	 */
	error = heif_decode_image( thumb_handle, &amp;thumb_img,
		heif_colorspace_RGB, 
		heif_chroma_interleaved_RGB,
		NULL );
	if( error.code ) {
		VIPS_FREEF( heif_image_handle_release, thumb_handle );
		vips__heif_error( &amp;error );
		return( -1 );
	}

	thumb_aspect = (double) 
		heif_image_get_width( thumb_img, heif_channel_interleaved ) /
		heif_image_get_height( thumb_img, heif_channel_interleaved );

	VIPS_FREEF( heif_image_release, thumb_img );

	main_aspect = (double) 
		heif_image_handle_get_width( heif-&gt;handle ) /
		heif_image_handle_get_height( heif-&gt;handle );

	/* The bug we are working around has decoded thumbs as 512x512 
	 * with the main image as 6kx4k, so a 0.1 threshold is more 
	 * than tight enough to spot the error.
	 */
	if( fabs( main_aspect - thumb_aspect ) &gt; 0.1 ) {
		VIPS_FREEF( heif_image_handle_release, thumb_handle );
		return( 0 );
	}

	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
	heif-&gt;handle = thumb_handle;

	return( 0 );
}

/* Select a page. If thumbnail is set, select the thumbnail for that page, if
 * there is one.
 */
static int
vips_foreign_load_heif_set_page( VipsForeignLoadHeif *heif, 
	int page_no, gboolean thumbnail )
{
	if( !heif-&gt;handle ||
		page_no != heif-&gt;page_no ||
		thumbnail != heif-&gt;thumbnail_set ) {
		struct heif_error error;

#ifdef DEBUG
		printf( &quot;vips_foreign_load_heif_set_page: %d, thumbnail = %d\n&quot;,
			page_no, thumbnail );
#endif /*DEBUG*/

		VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
		VIPS_FREEF( heif_image_release, heif-&gt;img );
		heif-&gt;data = NULL;
		heif-&gt;thumbnail_set = FALSE;

		error = heif_context_get_image_handle( heif-&gt;ctx, 
			heif-&gt;id[page_no], &amp;heif-&gt;handle );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}

		if( thumbnail ) {
			if( vips_foreign_load_heif_set_thumbnail( heif ) )
				return( -1 );

			/* If we were asked to select the thumbnail, say we
			 * did, even if there are no thumbnails and we just
			 * selected the main image. 
			 *
			 * If we don't do this, next time around in _generate
			 * we'll try to select the thumbnail again, which will
			 * be horribly slow.
			 */
			heif-&gt;thumbnail_set = TRUE;
		}

		heif-&gt;page_no = page_no;
	}

	return( 0 );
}

static int
vips_foreign_load_heif_set_header( VipsForeignLoadHeif *heif, VipsImage *out )
{
	VipsForeignLoad *load = (VipsForeignLoad *) heif;

	int bands;
	int i;
	/* Surely, 16 metadata items will be enough for anyone.
	 */
	heif_item_id id[16];
	int n_metadata;
	struct heif_error error;
	VipsForeignHeifCompression compression;

	/* We take the metadata from the non-thumbnail first page. HEIC 
	 * thumbnails don't have metadata.
	 */
	if( vips_foreign_load_heif_set_page( heif, heif-&gt;page, FALSE ) )
		return( -1 );

	/* Verify dimensions
	 */
	if ( heif-&gt;page_width &lt; 1 || heif-&gt;page_height &lt; 1 ) {
		vips_error( &quot;heifload&quot;, &quot;%s&quot;, _( &quot;bad dimensions&quot; ) );
		return( -1 );
	}

	heif-&gt;has_alpha = heif_image_handle_has_alpha_channel( heif-&gt;handle );
#ifdef DEBUG
	printf( &quot;heif_image_handle_has_alpha_channel() = %d\n&quot;, 
		heif-&gt;has_alpha );
#endif /*DEBUG*/
	bands = heif-&gt;has_alpha ? 4 : 3;

	/* FIXME .. IPTC as well?
	 */
	n_metadata = heif_image_handle_get_list_of_metadata_block_IDs( 
		heif-&gt;handle, NULL, id, VIPS_NUMBER( id ) );
	for( i = 0; i &lt; n_metadata; i++ ) {
		size_t length = heif_image_handle_get_metadata_size( 
			heif-&gt;handle, id[i] );
		const char *type = heif_image_handle_get_metadata_type( 
			heif-&gt;handle, id[i] );

		unsigned char *data;
		char name[256];

#ifdef DEBUG
		printf( &quot;metadata type = %s, length = %zu\n&quot;, type, length ); 
#endif /*DEBUG*/

		if( !length )
			continue;
		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
			return( -1 );
		error = heif_image_handle_get_metadata( 
			heif-&gt;handle, id[i], data );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}

		/* We need to skip the first four bytes of EXIF, they just
		 * contain the offset.
		 */
		if( length &gt; 4 &amp;&amp;
			g_ascii_strcasecmp( type, &quot;exif&quot; ) == 0 ) {
			data += 4;
			length -= 4;
		}

		/* exif has a special name.
		 *
		 * XMP metadata is just attached with the &quot;mime&quot; type, and
		 * usually start with &quot;&lt;x:xmpmeta&quot;.
		 */
		if( g_ascii_strcasecmp( type, &quot;exif&quot; ) == 0 )
			vips_snprintf( name, 256, VIPS_META_EXIF_NAME );
		else if( g_ascii_strcasecmp( type, &quot;mime&quot; ) == 0 &amp;&amp;
			length &gt; 10 &amp;&amp;
			vips_isprefix( &quot;&lt;x:xmpmeta&quot;, (const char *) data ) ) 
			vips_snprintf( name, 256, VIPS_META_XMP_NAME );
		else
			vips_snprintf( name, 256, &quot;heif-%s-%d&quot;, type, i );

		vips_image_set_blob( out, name, 
			(VipsCallbackFn) NULL, data, length );

		/* image_set will automatically parse EXIF, if necessary.
		 */
	}

	/* We use libheif's autorotate, so we need to remove any EXIF
	 * orientaion tags.
	 *
	 * According to the HEIF standard, EXIF orientation tags are only
	 * informational and images should not be rotated because of them.
	 * Unless we strip these tags, there's a danger downstream processing
	 * could double-rotate.
	 */
	vips_autorot_remove_angle( out );

#ifdef HAVE_HEIF_COLOR_PROFILE
	enum heif_color_profile_type profile_type = 
		heif_image_handle_get_color_profile_type( heif-&gt;handle );

#ifdef DEBUG
{
	printf( &quot;profile type = &quot; ); 
	switch( profile_type ) {
	case heif_color_profile_type_not_present: 
		printf( &quot;none&quot; ); 
		break;

	case heif_color_profile_type_nclx: 
		printf( &quot;nclx&quot; ); 
		break;

	case heif_color_profile_type_rICC: 
		printf( &quot;rICC&quot; ); 
		break;

	case heif_color_profile_type_prof: 
		printf( &quot;prof&quot; ); 
		break;

	default:
		printf( &quot;unknown&quot; ); 
		break;
	}
	printf( &quot;\n&quot; ); 
}
#endif /*DEBUG*/

	/* lcms can load standard (prof) and reduced (rICC) profiles
	 */
	if( profile_type == heif_color_profile_type_prof ||
		profile_type == heif_color_profile_type_rICC ) {
		size_t length = heif_image_handle_get_raw_color_profile_size( 
			heif-&gt;handle );

		unsigned char *data;

		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
			return( -1 );
		error = heif_image_handle_get_raw_color_profile( 
			heif-&gt;handle, data );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}

#ifdef DEBUG
		printf( &quot;profile data, length = %zd\n&quot;, length ); 
#endif /*DEBUG*/

		vips_image_set_blob( out, VIPS_META_ICC_NAME, 
			(VipsCallbackFn) NULL, data, length );
	}
	else if( profile_type == heif_color_profile_type_nclx ) {
		g_warning( &quot;heifload: ignoring nclx profile&quot; );
	}
#endif /*HAVE_HEIF_COLOR_PROFILE*/

	vips_image_set_int( out, &quot;heif-primary&quot;, heif-&gt;primary_page );
	vips_image_set_int( out, &quot;n-pages&quot;, heif-&gt;n_top );
	if( vips_object_argument_isset( VIPS_OBJECT( heif ), &quot;n&quot; ) )
		vips_image_set_int( out, 
			VIPS_META_PAGE_HEIGHT, heif-&gt;page_height );

	/* Determine compression from HEIF &quot;brand&quot;. heif_avif and heif_avis
	 * were added in v1.7.
	 */
	compression = VIPS_FOREIGN_HEIF_COMPRESSION_HEVC;

#ifdef HAVE_HEIF_AVIF
{
	const unsigned char *brand_data;

	if( (brand_data = vips_source_sniff( heif-&gt;source, 12 )) ) {
		enum heif_brand brand;
		brand = heif_main_brand( brand_data, 12 );
		if( brand == heif_avif || 
			brand == heif_avis )
			compression = VIPS_FOREIGN_HEIF_COMPRESSION_AV1;
	}
}
#endif /*HAVE_HEIF_AVIF*/

	vips_image_set_string( out, &quot;heif-compression&quot;,
		vips_enum_nick( VIPS_TYPE_FOREIGN_HEIF_COMPRESSION,
			compression ) );

	/* FIXME .. we always decode to RGB in generate. We should check for
	 * all grey images, perhaps. 
	 */
	if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_THINSTRIP, NULL ) )
		return( -1 );
	vips_image_init_fields( out,
		heif-&gt;page_width, heif-&gt;page_height * heif-&gt;n, bands, 
		VIPS_FORMAT_UCHAR, VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 
		1.0, 1.0 );

	VIPS_SETSTR( load-&gt;out-&gt;filename, 
		vips_connection_filename( VIPS_CONNECTION( heif-&gt;source ) ) );

	return( 0 );
}

static int
vips_foreign_load_heif_header( VipsForeignLoad *load )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;

	struct heif_error error;
	heif_item_id primary_id;
	int i;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_heif_header:\n&quot; );
#endif /*DEBUG*/

	heif-&gt;n_top = heif_context_get_number_of_top_level_images( heif-&gt;ctx );
	heif-&gt;id = VIPS_ARRAY( NULL, heif-&gt;n_top, heif_item_id );
	heif_context_get_list_of_top_level_image_IDs( heif-&gt;ctx, 
		heif-&gt;id, heif-&gt;n_top );

	/* Note page number of primary image.
	 */
	error = heif_context_get_primary_image_ID( heif-&gt;ctx, &amp;primary_id );
	if( error.code ) {
		vips__heif_error( &amp;error );
		return( -1 );
	}
	for( i = 0; i &lt; heif-&gt;n_top; i++ )
		if( heif-&gt;id[i] == primary_id )
			heif-&gt;primary_page = i;

	/* If @n and @page have not been set, @page defaults to the primary
	 * page.
	 */
	if( !vips_object_argument_isset( VIPS_OBJECT( load ), &quot;page&quot; ) &amp;&amp;
		!vips_object_argument_isset( VIPS_OBJECT( load ), &quot;n&quot; ) )
		heif-&gt;page = heif-&gt;primary_page;

	if( heif-&gt;n == -1 )
		heif-&gt;n = heif-&gt;n_top - heif-&gt;page;
	if( heif-&gt;page &lt; 0 ||
		heif-&gt;n &lt;= 0 ||
		heif-&gt;page + heif-&gt;n &gt; heif-&gt;n_top ) {
		vips_error( class-&gt;nickname, &quot;%s&quot;, _( &quot;bad page number&quot; ) ); 
		return( -1 ); 
	}

#ifdef DEBUG
	for( i = heif-&gt;page; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
		heif_item_id thumb_ids[1];
		int n_items;
		int n_thumbs;
		int j;

		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
			return( -1 );

		n_thumbs = heif_image_handle_get_number_of_thumbnails( 
			heif-&gt;handle );
		n_items = heif_image_handle_get_list_of_thumbnail_IDs( 
			heif-&gt;handle, thumb_ids, 1 );

		printf( &quot;page = %d\n&quot;, i );
		printf( &quot;n_thumbs = %d\n&quot;, n_thumbs );
		printf( &quot;n_items = %d\n&quot;, n_items );

		for( j = 0; j &lt; n_items; j++ ) {
			struct heif_image_handle *thumb_handle;

			error = heif_image_handle_get_thumbnail( heif-&gt;handle,
				thumb_ids[j], &amp;thumb_handle );
			if( error.code ) {
				vips__heif_error( &amp;error );
				return( -1 );
			}

			printf( &quot;  thumb %d\n&quot;, j );
			printf( &quot;    width = %d\n&quot;, 
				heif_image_handle_get_width( thumb_handle ) );
			printf( &quot;    height = %d\n&quot;, 
				heif_image_handle_get_height( thumb_handle ) );
		}
	}
#endif /*DEBUG*/

	/* All pages must be the same size for libvips toilet roll images.
	 */
	if( vips_foreign_load_heif_set_page( heif, 
		heif-&gt;page, heif-&gt;thumbnail ) )
		return( -1 );
	heif-&gt;page_width = heif_image_handle_get_width( heif-&gt;handle );
	heif-&gt;page_height = heif_image_handle_get_height( heif-&gt;handle );
	for( i = heif-&gt;page + 1; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
		if( vips_foreign_load_heif_set_page( heif, 
			i, heif-&gt;thumbnail ) )
			return( -1 );
		if( heif_image_handle_get_width( heif-&gt;handle ) 
				!= heif-&gt;page_width ||
			heif_image_handle_get_height( heif-&gt;handle ) 
				!= heif-&gt;page_height ) {
			vips_error( class-&gt;nickname, &quot;%s&quot;, 
				_( &quot;not all pages are the same size&quot; ) ); 
			return( -1 ); 
		}
	}

#ifdef DEBUG
	printf( &quot;page_width = %d\n&quot;, heif-&gt;page_width );
	printf( &quot;page_height = %d\n&quot;, heif-&gt;page_height );

	printf( &quot;n_top = %d\n&quot;, heif-&gt;n_top );
	for( i = 0; i &lt; heif-&gt;n_top; i++ ) {
		printf( &quot;  id[%d] = %d\n&quot;, i, heif-&gt;id[i] );
		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
			return( -1 );
		printf( &quot;    width = %d\n&quot;, 
			heif_image_handle_get_width( heif-&gt;handle ) );
		printf( &quot;    height = %d\n&quot;, 
			heif_image_handle_get_height( heif-&gt;handle ) );
		printf( &quot;    has_depth = %d\n&quot;, 
			heif_image_handle_has_depth_image( heif-&gt;handle ) );
		printf( &quot;    has_alpha = %d\n&quot;, 
			heif_image_handle_has_alpha_channel( heif-&gt;handle ) );
		printf( &quot;    n_metadata = %d\n&quot;, 
			heif_image_handle_get_number_of_metadata_blocks( 
				heif-&gt;handle, NULL ) );
#ifdef HAVE_HEIF_COLOR_PROFILE
		printf( &quot;    colour profile type = 0x%xd\n&quot;, 
			heif_image_handle_get_color_profile_type( 
				heif-&gt;handle ) );
#endif /*HAVE_HEIF_COLOR_PROFILE*/
	}
#endif /*DEBUG*/

	if( vips_foreign_load_heif_set_header( heif, load-&gt;out ) )
		return( -1 );

	vips_source_minimise( heif-&gt;source );

	return( 0 );
}

#ifdef DEBUG
void
vips__heif_image_print( struct heif_image *img )
{
	const static enum heif_channel channel[] = {
		heif_channel_Y,
		heif_channel_Cb,
		heif_channel_Cr,
		heif_channel_R,
		heif_channel_G,
		heif_channel_B,
		heif_channel_Alpha,
		heif_channel_interleaved
	};

	const static char *channel_name[] = {
		&quot;heif_channel_Y&quot;,
		&quot;heif_channel_Cb&quot;,
		&quot;heif_channel_Cr&quot;,
		&quot;heif_channel_R&quot;,
		&quot;heif_channel_G&quot;,
		&quot;heif_channel_B&quot;,
		&quot;heif_channel_Alpha&quot;,
		&quot;heif_channel_interleaved&quot;
	};

	int i;

	printf( &quot;vips__heif_image_print:\n&quot; );
	for( i = 0; i &lt; VIPS_NUMBER( channel ); i++ ) {
		if( !heif_image_has_channel( img, channel[i] ) )
			continue;

		printf( &quot;\t%s:\n&quot;, channel_name[i] ); 
		printf( &quot;\t\twidth = %d\n&quot;, 
			heif_image_get_width( img, channel[i] ) );
		printf( &quot;\t\theight = %d\n&quot;, 
			heif_image_get_height( img, channel[i] ) );
		printf( &quot;\t\tbits = %d\n&quot;, 
			heif_image_get_bits_per_pixel( img, channel[i] ) );
	}
}
#endif /*DEBUG*/

static int
vips_foreign_load_heif_generate( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) a;
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( heif );
        VipsRect *r = &amp;or-&gt;valid;

	int page = r-&gt;top / heif-&gt;page_height + heif-&gt;page;
	int line = r-&gt;top % heif-&gt;page_height;

#ifdef DEBUG_VERBOSE
	printf( &quot;vips_foreign_load_heif_generate: line %d\n&quot;, r-&gt;top );
#endif /*DEBUG_VERBOSE*/

	g_assert( r-&gt;height == 1 );

	if( vips_foreign_load_heif_set_page( heif, page, heif-&gt;thumbnail ) )
		return( -1 );

	if( !heif-&gt;img ) {
		struct heif_error error;
		struct heif_decoding_options *options;
		enum heif_chroma chroma = heif-&gt;has_alpha ? 
			heif_chroma_interleaved_RGBA :
			heif_chroma_interleaved_RGB;

		options = heif_decoding_options_alloc();
#ifdef HAVE_HEIF_DECODING_OPTIONS_CONVERT_HDR_TO_8BIT
		/* VIPS_FORMAT_UCHAR is assumed so downsample HDR to 8bpc
		 */
		options-&gt;convert_hdr_to_8bit = TRUE;
#endif /*HAVE_HEIF_DECODING_OPTIONS_CONVERT_HDR_TO_8BIT*/
		error = heif_decode_image( heif-&gt;handle, &amp;heif-&gt;img, 
			heif_colorspace_RGB, chroma, 
			options );
		heif_decoding_options_free( options );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}

#ifdef DEBUG
		vips__heif_image_print( heif-&gt;img );
#endif /*DEBUG*/
	}

	if( !heif-&gt;data ) {
		int image_width = heif_image_get_width( heif-&gt;img, 
			heif_channel_interleaved );
		int image_height = heif_image_get_height( heif-&gt;img, 
			heif_channel_interleaved );

		/* We can sometimes get inconsistency between the dimensions
		 * reported on the handle, and the final image we fetch. Error
		 * out to prevent a segv.
		 */
		if( image_width != heif-&gt;page_width ||
			image_height != heif-&gt;page_height ) {
			vips_error( class-&gt;nickname, 
				&quot;%s&quot;, _( &quot;bad image dimensions on decode&quot; ) );
			return( -1 );
		}

		if( !(heif-&gt;data = heif_image_get_plane_readonly( heif-&gt;img, 
			heif_channel_interleaved, &amp;heif-&gt;stride )) ) {
			vips_error( class-&gt;nickname, 
				&quot;%s&quot;, _( &quot;unable to get image data&quot; ) );
			return( -1 );
		}
	}

	memcpy( VIPS_REGION_ADDR( or, 0, r-&gt;top ),
		heif-&gt;data + heif-&gt;stride * line, 
		VIPS_IMAGE_SIZEOF_LINE( or-&gt;im ) );

	return( 0 );
}

static void
vips_foreign_load_heif_minimise( VipsObject *object, VipsForeignLoadHeif *heif )
{
	vips_source_minimise( heif-&gt;source );
}

static int
vips_foreign_load_heif_load( VipsForeignLoad *load )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;

	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( load ), 3 );

#ifdef DEBUG
	printf( &quot;vips_foreign_load_heif_load: loading image\n&quot; );
#endif /*DEBUG*/

	t[0] = vips_image_new();
	if( vips_foreign_load_heif_set_header( heif, t[0] ) )
		return( -1 );

	/* CLose input immediately at end of read.
	 */
	g_signal_connect( t[0], &quot;minimise&quot;, 
		G_CALLBACK( vips_foreign_load_heif_minimise ), heif ); 

	if( vips_image_generate( t[0],
		NULL, vips_foreign_load_heif_generate, NULL, heif, NULL ) ||
		vips_sequential( t[0], &amp;t[1], NULL ) ||
		vips_image_write( t[1], load-&gt;real ) )
		return( -1 );

	if( vips_source_decode( heif-&gt;source ) )
		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_heif_class_init( VipsForeignLoadHeifClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
<A NAME="2"></A>	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1924-0.html#2',2,'match1924-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	gobject_class-&gt;dispose = vips_foreign_load_heif_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;heifload_base&quot;;
	object_class-&gt;description = _( &quot;load a HEIF image&quot; );
	object_class-&gt;build = vips_foreign_load_heif_build;

	load_class-&gt;get_flags = vips_foreign_load_heif_get_flags;
	load_class-&gt;header = vips_foreign_load_heif_header;
	load_class-&gt;load = vips_foreign_load_heif_load;

	VIPS_ARG_INT( class, &quot;page&quot;, 2,
		_( &quot;Page&quot; ),
		_( &quot;Load this page from the file&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadHeif, page ),
		0, 100000, 0 );

	VIPS_ARG_INT( class, &quot;n&quot;, 3,
		_( &quot;n&quot; ),
		_( &quot;Load this many pages&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadHeif, n ),
		-1, 100000, 1 );

	VIPS_ARG_BOOL( class, &quot;thumbnail&quot;, 4, 
		_( &quot;Thumbnail&quot; ), 
		_( &quot;Fetch thumbnail image&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadHeif, thumbnail ),
		FALSE );

	VIPS_ARG_BOOL( class, &quot;autorotate&quot;, 21, 
		_( &quot;Autorotate&quot; ), 
		_( &quot;Rotate image using exif orientation&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignLoadHeif, autorotate ),
		FALSE );

}

static gint64
vips_foreign_load_heif_get_position( void *userdata )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;</B></FONT>

	return( vips_source_seek( heif-&gt;source, 0L, SEEK_CUR ) );
}

/* libheif read() does not work like unix read(). 
 *
 * This method is cannot return EOF. Instead, the separate wait_for_file_size() 
 * is called beforehand to make sure that there's enough data there.
 */
static int
vips_foreign_load_heif_read( void *data, size_t size, void *userdata )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;

	while( size &gt; 0 ) {
		gint64 bytes_read;

		bytes_read = vips_source_read( heif-&gt;source, data, size );
		if( bytes_read &lt;= 0 ) 
			return( -1 );

		size -= bytes_read;
		data += bytes_read;
	}

	return( 0 );
}

static int
vips_foreign_load_heif_seek( gint64 position, void *userdata )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;

	/* Return 0 on success.
	 */
	return( vips_source_seek( heif-&gt;source, position, SEEK_SET ) == -1 );
}

/* libheif calls this to mean &quot;I intend to read() to this position, please
 * check it is OK&quot;.
 */
static enum heif_reader_grow_status 
vips_foreign_load_heif_wait_for_file_size( gint64 target_size, void *userdata )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;

	gint64 old_position;
	gint64 result;
	enum heif_reader_grow_status status;

	/* We seek the VipsSource to the position and check for errors. 
	 */
	old_position = vips_source_seek( heif-&gt;source, 0L, SEEK_CUR );
	result = vips_source_seek( heif-&gt;source, target_size, SEEK_SET );
	vips_source_seek( heif-&gt;source, old_position, SEEK_SET );

	if( result &lt; 0 )
		/* Unable to seek to this point, so it's beyond EOF.
		 */
		status = heif_reader_grow_status_size_beyond_eof;
	else
		/* Successfully read to the requested point, but the requested
		 * point is not necessarily EOF.
		 */
		status = heif_reader_grow_status_size_reached;

	return( status );
}

static void
vips_foreign_load_heif_init( VipsForeignLoadHeif *heif )
{
	heif-&gt;n = 1;

	heif-&gt;reader = VIPS_ARRAY( NULL, 1, struct heif_reader );

	/* The first version to support heif_reader.
	 */
	heif-&gt;reader-&gt;reader_api_version = 1;
	heif-&gt;reader-&gt;get_position = vips_foreign_load_heif_get_position;
	heif-&gt;reader-&gt;read = vips_foreign_load_heif_read;
<A NAME="6"></A>	heif-&gt;reader-&gt;seek = vips_foreign_load_heif_seek;
	heif-&gt;reader-&gt;wait_for_file_size = 
		vips_foreign_load_heif_wait_for_file_size;
<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1924-0.html#6',2,'match1924-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

typedef struct _VipsForeignLoadHeifFile {
	VipsForeignLoadHeif parent_object;

	/* Filename for load.
	 */
	char *filename; 

} VipsForeignLoadHeifFile;

typedef VipsForeignLoadHeifClass VipsForeignLoadHeifFileClass;

G_DEFINE_TYPE( VipsForeignLoadHeifFile, vips_foreign_load_heif_file, 
	vips_foreign_load_heif_get_type() );

static int
vips_foreign_load_heif_file_build( VipsObject *object )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
	VipsForeignLoadHeifFile *file = (VipsForeignLoadHeifFile *) object;

	if( file-&gt;filename ) </B></FONT>
		if( !(heif-&gt;source = 
			vips_source_new_from_file( file-&gt;filename )) )
			return( -1 );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static int
vips_foreign_load_heif_file_is_a( const char *filename )
{
<A NAME="4"></A>	char buf[12];

	if( vips__get_bytes( filename, (unsigned char *) buf, 12 ) != 12 )
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1924-0.html#4',2,'match1924-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		return( 0 );

	return( vips_foreign_load_heif_is_a( buf, 12 ) );
}

static void
vips_foreign_load_heif_file_class_init( VipsForeignLoadHeifFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
<A NAME="0"></A>	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</B></FONT>

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1924-0.html#0',2,'match1924-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;heifload&quot;;
	object_class-&gt;build = vips_foreign_load_heif_file_build;

	foreign_class-&gt;suffs = vips__heif_suffs;

	load_class-&gt;is_a = vips_foreign_load_heif_file_is_a;

	VIPS_ARG_STRING( class, &quot;filename&quot;, 1, 
		_( &quot;Filename&quot; ),
		_( &quot;Filename to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadHeifFile, filename ),
		NULL );

}

static void
vips_foreign_load_heif_file_init( VipsForeignLoadHeifFile *file )
{
}

typedef struct _VipsForeignLoadHeifBuffer {
	VipsForeignLoadHeif parent_object;

	/* Load from a buffer.
	 */
	VipsArea *buf;

} VipsForeignLoadHeifBuffer;

typedef VipsForeignLoadHeifClass VipsForeignLoadHeifBufferClass;

G_DEFINE_TYPE( VipsForeignLoadHeifBuffer, vips_foreign_load_heif_buffer, 
	vips_foreign_load_heif_get_type() );

static int
vips_foreign_load_heif_buffer_build( VipsObject *object )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
	VipsForeignLoadHeifBuffer *buffer = 
		(VipsForeignLoadHeifBuffer *) object;

	if( buffer-&gt;buf )</B></FONT>
		if( !(heif-&gt;source = vips_source_new_from_memory( 
			VIPS_AREA( buffer-&gt;buf )-&gt;data, 
			VIPS_AREA( buffer-&gt;buf )-&gt;length )) )
			return( -1 );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

<A NAME="3"></A>static gboolean
vips_foreign_load_heif_buffer_is_a( const void *buf, size_t len )
{
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1924-0.html#3',2,'match1924-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( vips_foreign_load_heif_is_a( buf, len ) );
}

static void
vips_foreign_load_heif_buffer_class_init( 
	VipsForeignLoadHeifBufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;heifload_buffer&quot;;
	object_class-&gt;build = vips_foreign_load_heif_buffer_build;

	load_class-&gt;is_a_buffer = vips_foreign_load_heif_buffer_is_a;</B></FONT>

	VIPS_ARG_BOXED( class, &quot;buffer&quot;, 1, 
		_( &quot;Buffer&quot; ),
		_( &quot;Buffer to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadHeifBuffer, buf ),
		VIPS_TYPE_BLOB );

}

<A NAME="1"></A>static void
vips_foreign_load_heif_buffer_init( VipsForeignLoadHeifBuffer *buffer )
{
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1924-0.html#1',2,'match1924-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

typedef struct _VipsForeignLoadHeifSource {
	VipsForeignLoadHeif parent_object;

	/* Load from a source.
	 */
	VipsSource *source;

} VipsForeignLoadHeifSource;

typedef VipsForeignLoadHeifClass VipsForeignLoadHeifSourceClass;

G_DEFINE_TYPE( VipsForeignLoadHeifSource, vips_foreign_load_heif_source, 
	vips_foreign_load_heif_get_type() );

static int
vips_foreign_load_heif_source_build( VipsObject *object )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
	VipsForeignLoadHeifSource *source = 
		(VipsForeignLoadHeifSource *) object;

	if( source-&gt;source ) {
		heif-&gt;source = source-&gt;source;
		g_object_ref( heif-&gt;source );
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_source_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static gboolean</B></FONT>
vips_foreign_load_heif_source_is_a_source( VipsSource *source )
{
	const char *p;

	return( (p = (const char *) vips_source_sniff( source, 12 )) &amp;&amp;
<A NAME="5"></A>		vips_foreign_load_heif_is_a( p, 12 ) );
}

<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1924-0.html#5',2,'match1924-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static void
vips_foreign_load_heif_source_class_init( 
	VipsForeignLoadHeifSourceClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;heifload_source&quot;;
	object_class-&gt;build = vips_foreign_load_heif_source_build;

	load_class-&gt;is_a_source = vips_foreign_load_heif_source_is_a_source;</B></FONT>

	VIPS_ARG_OBJECT( class, &quot;source&quot;, 1,
		_( &quot;Source&quot; ),
		_( &quot;Source to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadHeifSource, source ),
		VIPS_TYPE_SOURCE );

}

static void
vips_foreign_load_heif_source_init( VipsForeignLoadHeifSource *source )
{
}

#endif /*HAVE_HEIF_DECODER*/

/* The C API wrappers are defined in foreign.c.
 */
</PRE>
</div>
  </div>
</body>
</html>
