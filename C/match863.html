<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for pmciscoios.c &amp; omlibdbi.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pmciscoios.c &amp; omlibdbi.c
      </h3>
<h1 align="center">
        10.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pmciscoios.c (18.82353%)<th>omlibdbi.c (7.126949%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(55-63)<td><a href="#" name="0">(109-117)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(114-127)<td><a href="#" name="1">(427-442)</a><td align="center"><font color="#e10000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pmciscoios.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* pmrciscoios.c
 * This is a parser module for CISCO IOS "syslog" format.
 *
 * File begun on 2014-07-07 by RGerhards
 *
 * Copyright 2014-2015 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "template.h"
#include "msg.h"
#include "module-template.h"
#include "glbl.h"
#include "errmsg.h"
#include "parser.h"
#include "datetime.h"
#include "unicode-helper.h"

MODULE_TYPE_PARSER
MODULE_TYPE_NOKEEP
PARSER_NAME("rsyslog.ciscoios")
MODULE_CNFNAME("pmciscoios")

/* internal structures */
DEF_PMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)
<a name="0"></a>

/* parser instance parameters */
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr parserpdescr[] = {
	{ "present.origin", eCmdHdlrBinary, 0 },
	{ "present.xr", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk parserpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
	  parserpdescr
	};</b></font>

struct instanceConf_s {
	int bOriginPresent; /* is ORIGIN field present? */
	int bXrPresent; /* is XR? */
};

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATUREAutomaticSanitazion)
		iRet = RS_RET_OK;
	if(eFeat == sFEATUREAutomaticPRIParsing)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;bOriginPresent = 0;
	inst-&gt;bXrPresent = 0;
	*pinst = inst;
finalize_it:
	RETiRet;
}


BEGINfreeParserInst
CODESTARTfreeParserInst
	dbgprintf("pmciscoios: free parser instance %p\n", pInst);
ENDfreeParserInst


BEGINnewParserInst
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTnewParserInst
	DBGPRINTF("newParserInst (pmciscoios)\n");

	inst = NULL;
	CHKiRet(createInstance(&amp;inst));

<a name="1"></a>	if(lst == NULL)
		FINALIZE;  /* just set defaults, no param block! */

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;parserpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("parser param blk in pmciscoios:\n");
		cnfparamsPrint(&amp;parserpblk, pvals);
	}

	for(i = 0 ; i &lt; parserpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(parserpblk.descr[i].name, "present.origin")) {
			inst-&gt;bOriginPresent = (int) pvals[i].val.d.n;</b></font>
		} else if(!strcmp(parserpblk.descr[i].name, "present.xr")) {
			inst-&gt;bXrPresent = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("pmciscoios: program error, non-handled "
				"param '%s'\n", parserpblk.descr[i].name);
		}
	}
finalize_it:
CODE_STD_FINALIZERnewParserInst
	if(lst != NULL)
		cnfparamvalsDestruct(pvals, &amp;parserpblk);
	if(iRet != RS_RET_OK)
		freeParserInst(inst);
ENDnewParserInst


BEGINparse2
	uchar *p2parse;
	long long msgcounter;
	int lenMsg;
	int i;
	int iHostname = 0;
	uchar bufParseTAG[512];
	uchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE]; /* used by origin */
CODESTARTparse2
	DBGPRINTF("Message will now be parsed by pmciscoios\n");
	assert(pMsg != NULL);
	assert(pMsg-&gt;pszRawMsg != NULL);
	lenMsg = pMsg-&gt;iLenRawMsg - pMsg-&gt;offAfterPRI;
	/* note: offAfterPRI is already the number of PRI chars (do not add one!) */
	p2parse = pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI; /* point to start of text, after PRI */

	/* first obtain the MESSAGE COUNTER. It must be numeric up until
	 * the ": " terminator sequence
	 */
	msgcounter = 0;
	while(lenMsg &gt; 0 &amp;&amp; (*p2parse &gt;= '0' &amp;&amp; *p2parse &lt;= '9') ) {
		msgcounter = msgcounter * 10 + *p2parse - '0';
		++p2parse, --lenMsg;
	}
	DBGPRINTF("pmciscoios: msgcntr %lld\n", msgcounter);

	/* delimiter check */
	if(lenMsg &lt; 2 || *p2parse != ':' || *(p2parse+1) != ' ') {
		DBGPRINTF("pmciscoios: fail after seqno: '%s'\n", p2parse);
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
	}
	p2parse += 2;

	/* ORIGIN (optional) */
	if(pInst-&gt;bOriginPresent) {
		iHostname = 0;
		while(   lenMsg &gt; 1
		      &amp;&amp; !(*p2parse == ':' &amp;&amp; *(p2parse+1) == ' ')  /* IPv6 is e.g. "::1" (loopback) */
		      &amp;&amp; iHostname &lt; (int) sizeof(bufParseHOSTNAME) - 1 ) {
			bufParseHOSTNAME[iHostname++] = *p2parse++;
			--lenMsg;
		}
		bufParseHOSTNAME[iHostname] = '\0';
		/* delimiter check */
		if(lenMsg &lt; 2 || *(p2parse+1) != ' ') {
			DBGPRINTF("pmciscoios: fail after origin: '%s'\n", p2parse);
			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
		}
		p2parse += 2;
	}

	/* XR RSP (optional) */
	if(pInst-&gt;bXrPresent) {
		while(   lenMsg &gt; 1
			&amp;&amp; !(*p2parse == ':')) {
			--lenMsg;
			++p2parse;
		}
		/* delimiter check */
		if(lenMsg &lt; 2) {
			DBGPRINTF("pmciscoios: fail after XR: '%s'\n", p2parse);
			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
		}
		p2parse += 1;
	}

	/* TIMESTAMP */
	if(p2parse[0] == '*' || p2parse[0] == '.') p2parse++;
	if(datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg, PARSE3164_TZSTRING,
	NO_PERMIT_YEAR_AFTER_TIME) == RS_RET_OK) {
		if(pMsg-&gt;dfltTZ[0] != '\0')
			applyDfltTZ(&amp;pMsg-&gt;tTIMESTAMP, pMsg-&gt;dfltTZ);
	} else {
		DBGPRINTF("pmciscoios: fail at timestamp: '%s'\n", p2parse);
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
	}
	/* Note: date parser strips ": ", so we cannot do the delimiter check here */

	/* XR RSP (optional) */
	if(pInst-&gt;bXrPresent) {
		while(   lenMsg &gt; 1
			&amp;&amp; !(*p2parse == '%')) {
			--lenMsg;
			p2parse++;
		}
		/* delimiter check */
		if(lenMsg &lt; 2) {
			DBGPRINTF("pmciscoios: fail after XR tag search: '%s'\n", p2parse);
			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
		}
	}

	/* parse SYSLOG TAG. must always start with '%', else we have a field mismatch */
	if(lenMsg &lt; 1 || *p2parse != '%') {
		DBGPRINTF("pmciscoios: fail at tag begin (no '%%'): '%s'\n", p2parse);
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
	}

	i = 0;
	while(lenMsg &gt; 0 &amp;&amp; *p2parse != ':' &amp;&amp; *p2parse != ' ' &amp;&amp; i &lt; (int) sizeof(bufParseTAG) - 2) {
		bufParseTAG[i++] = *p2parse++;
		--lenMsg;
	}
	/* delimiter check */
	if(pInst-&gt;bXrPresent) p2parse++;
	if(lenMsg &lt; 2 || *p2parse != ':' || *(p2parse+1) != ' ') {
		DBGPRINTF("pmciscoios: fail after tag: '%s'\n", p2parse);
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
	}

	++p2parse;
	bufParseTAG[i++] = ':';
	bufParseTAG[i] = '\0';	/* terminate string */

	/* if we reach this point, we have a wellformed message and can persist the values */
	MsgSetTAG(pMsg, bufParseTAG, i);
	/* if bOriginPresent !=0 iHostname gets initialized */
	if(pInst-&gt;bOriginPresent)
		MsgSetHOSTNAME(pMsg, bufParseHOSTNAME, iHostname);
	MsgSetMSGoffs(pMsg, p2parse - pMsg-&gt;pszRawMsg);
	setProtocolVersion(pMsg, MSG_LEGACY_PROTOCOL);
finalize_it:
ENDparse2


BEGINmodExit
CODESTARTmodExit
	/* release what we no longer need */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(parser, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_PMOD2_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));

	DBGPRINTF("pmciscoios parser init called\n");
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omlibdbi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* omlibdbi.c
 * This is the implementation of the dbi output module.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * This depends on libdbi being present with the proper settings. Older
 * versions do not necessarily have them. Please visit this bug tracker
 * for details: http://bugzilla.adiscon.com/show_bug.cgi?id=31
 *
 * File begun on 2008-02-14 by RGerhards (extracted from syslogd.c)
 *
 * Copyright 2008-2016 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;libgen.h&gt;
#include &lt;dbi/dbi.h&gt;
#include "dirty.h"
#include "syslogd-types.h"
#include "cfsysline.h"
#include "conf.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "debug.h"
#include "errmsg.h"
#include "conf.h"

#undef HAVE_DBI_TXSUPP
/* transaction support disabled in v8 -- TODO: reenable */

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omlibdbi")

/* internal structures
 */
DEF_OMOD_STATIC_DATA
static int bDbiInitialized = 0;	/* dbi_initialize() can only be called one - this keeps track of it */

typedef struct _instanceData {
	uchar *dbiDrvrDir;	/* where do the dbi drivers reside? */
	dbi_conn conn;		/* handle to database */
	uchar *drvrName;	/* driver to use */
	uchar *host;		/* host to connect to */
	uchar *usrName;		/* user name for connect */
	uchar *pwd;		/* password for connect */
	uchar *dbName;		/* database to use */
	unsigned uLastDBErrno;	/* last errno returned by libdbi or 0 if all is well */
	uchar	*tplName;       /* format template to use */
	int txSupport;		/* transaction support */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

typedef struct configSettings_s {
	uchar *dbiDrvrDir;	/* global: where do the dbi drivers reside? */
	uchar *drvrName;	/* driver to use */
	uchar *host;		/* host to connect to */
	uchar *usrName;		/* user name for connect */
	uchar *pwd;		/* password for connect */
	uchar *dbName;		/* database to use */
} configSettings_t;
static configSettings_t cs;
uchar	*pszFileDfltTplName; /* name of the default template to use */

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	uchar *dbiDrvrDir;	/* where do the dbi drivers reside? */
	uchar 	*tplName;	/* default template */
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */
static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */

static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;

<a name="0"></a>
/* tables for interfacing with the v6 config system */
/* module-global parameters */
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static struct cnfparamdescr modpdescr[] = {
	{ "template", eCmdHdlrGetWord, 0 },
	{ "driverdirectory", eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};</b></font>
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ "server", eCmdHdlrGetWord, 1 },
	{ "db", eCmdHdlrGetWord, 1 },
	{ "uid", eCmdHdlrGetWord, 1 },
	{ "pwd", eCmdHdlrGetWord, 1 },
	{ "driver", eCmdHdlrGetWord, 1 },
	{ "template", eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

/* this function gets the default template. It coordinates action between
 * old-style and new-style configuration parts.
 */
static uchar*
getDfltTpl(void)
{
	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
		return loadModConf-&gt;tplName;
	else if(pszFileDfltTplName == NULL)
		return (uchar*)" StdDBFmt";
	else
		return pszFileDfltTplName;
}


BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	cs.dbiDrvrDir = NULL;
	cs.drvrName = NULL;
	cs.host = NULL;
	cs.usrName = NULL;
	cs.pwd = NULL;
	cs.dbName = NULL;
ENDinitConfVars


/* config settings */
#ifdef HAVE_DBI_R
static dbi_inst dbiInst;
#endif


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	/* we do not like repeated message reduction inside the database */
ENDisCompatibleWithFeature


/* The following function is responsible for closing a
 * database connection.
 */
static void closeConn(instanceData *pData)
{
	assert(pData != NULL);
	if(pData-&gt;conn != NULL) {	/* just to be on the safe side... */
		dbi_conn_close(pData-&gt;conn);
		pData-&gt;conn = NULL;
	}
}

BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;drvrName);
	free(pData-&gt;host);
	free(pData-&gt;usrName);
	free(pData-&gt;pwd);
	free(pData-&gt;dbName);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	closeConn(pWrkrData-&gt;pData);
ENDfreeWrkrInstance

BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	/* nothing special here */
ENDdbgPrintInstInfo


/* log a database error with descriptive message.
 * We check if we have a valid database handle. If not, we simply
 * report an error, but can not be specific. RGerhards, 2007-01-30
 */
static void
reportDBError(instanceData *pData, int bSilent)
{
	unsigned uDBErrno;
	char errMsg[1024];
	const char *pszDbiErr;

	assert(pData != NULL);

	/* output log message */
	errno = 0;
	if(pData-&gt;conn == NULL) {
		LogError(0, NO_ERRCODE, "unknown DB error occurred - could not obtain connection handle");
	} else { /* we can ask dbi for the error description... */
		uDBErrno = dbi_conn_error(pData-&gt;conn, &amp;pszDbiErr);
		snprintf(errMsg, sizeof(errMsg), "db error (%d): %s\n", uDBErrno, pszDbiErr);
		if(bSilent || uDBErrno == pData-&gt;uLastDBErrno)
			dbgprintf("libdbi, DBError(silent): %s\n", errMsg);
		else {
			pData-&gt;uLastDBErrno = uDBErrno;
			LogError(0, NO_ERRCODE, "%s", errMsg);
		}
	}

}


/* The following function is responsible for initializing a connection
 */
static rsRetVal initConn(instanceData *pData, int bSilent)
{
	DEFiRet;
	int iDrvrsLoaded;

	assert(pData != NULL);
	assert(pData-&gt;conn == NULL);

	if(bDbiInitialized == 0) {
		/* we need to init libdbi first */
#		ifdef HAVE_DBI_R
		iDrvrsLoaded = dbi_initialize_r((char*) pData-&gt;dbiDrvrDir, &amp;dbiInst);
#		else
		iDrvrsLoaded = dbi_initialize((char*) pData-&gt;dbiDrvrDir);
#		endif
		if(iDrvrsLoaded == 0) {
			LogError(0, RS_RET_SUSPENDED, "libdbi error: libdbi or libdbi drivers not "
			"present on this system - suspending.");
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		} else if(iDrvrsLoaded &lt; 0) {
			LogError(0, RS_RET_SUSPENDED, "libdbi error: libdbi could not be "
				"initialized (do you have any dbi drivers installed?) - suspending.");
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		bDbiInitialized = 1; /* we are done for the rest of our existence... */
	}

#	ifdef HAVE_DBI_R
	pData-&gt;conn = dbi_conn_new_r((char*)pData-&gt;drvrName, dbiInst);
#	else
	pData-&gt;conn = dbi_conn_new((char*)pData-&gt;drvrName);
#	endif
	if(pData-&gt;conn == NULL) {
		LogError(0, RS_RET_SUSPENDED, "can not initialize libdbi connection");
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	} else { /* we could get the handle, now on with work... */
		/* Connect to database */
		dbi_conn_set_option(pData-&gt;conn, "host",     (char*) pData-&gt;host);
		dbi_conn_set_option(pData-&gt;conn, "username", (char*) pData-&gt;usrName);

		/* libdbi-driver-sqlite(2/3) requires to provide sqlite3_db dir which is absolute
		   path, where database file lives,
		 * and dbname, which is database file name itself. So in order to keep the config API unchanged,
		 * we split the dbname to path and filename.
		 */
		int is_sqlite2 = !strcmp((const char *)pData-&gt;drvrName, "sqlite");
		int is_sqlite3 = !strcmp((const char *)pData-&gt;drvrName, "sqlite3");
		if(is_sqlite2 || is_sqlite3) {
			dbi_conn_set_option(pData-&gt;conn, is_sqlite3 ? "sqlite3_dbdir" : "sqlite_dbdir",
							dirname((char *)pData-&gt;dbName));
			dbi_conn_set_option(pData-&gt;conn, "dbname", basename((char *)pData-&gt;dbName ));
		} else {
			dbi_conn_set_option(pData-&gt;conn, "dbname",   (char*) pData-&gt;dbName);
		}
		if(pData-&gt;pwd != NULL)
			dbi_conn_set_option(pData-&gt;conn, "password", (char*) pData-&gt;pwd);
		if(dbi_conn_connect(pData-&gt;conn) &lt; 0) {
			reportDBError(pData, bSilent);
			closeConn(pData); /* ignore any error we may get */
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		pData-&gt;txSupport = dbi_conn_cap_get(pData-&gt;conn, "transaction_support");
	}

finalize_it:
	RETiRet;
}


/* The following function writes the current log entry
 * to an established database connection.
 */
static rsRetVal
writeDB(const uchar *psz, instanceData *const __restrict__ pData)
{
	DEFiRet;
	dbi_result dbiRes = NULL;

	assert(psz != NULL);
	assert(pData != NULL);

	/* see if we are ready to proceed */
	if(pData-&gt;conn == NULL) {
		CHKiRet(initConn(pData, 0));
	}

	/* try insert */
	if((dbiRes = dbi_conn_query(pData-&gt;conn, (const char*)psz)) == NULL) {
		/* error occurred, try to re-init connection and retry */
		closeConn(pData); /* close the current handle */
		CHKiRet(initConn(pData, 0)); /* try to re-open */
		if((dbiRes = dbi_conn_query(pData-&gt;conn, (const char*)psz)) == NULL) { /* re-try insert */
			/* we failed, giving up for now */
			reportDBError(pData, 0);
			closeConn(pData); /* free ressources */
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}

finalize_it:
	if(iRet == RS_RET_OK) {
		pData-&gt;uLastDBErrno = 0; /* reset error for error supression */
	}

	if(dbiRes != NULL)
		dbi_result_free(dbiRes);

	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	if(pWrkrData-&gt;pData-&gt;conn == NULL) {
		iRet = initConn(pWrkrData-&gt;pData, 1);
	}
ENDtryResume

/* transaction support 2013-03 */
BEGINbeginTransaction
CODESTARTbeginTransaction
	if(pWrkrData-&gt;pData-&gt;conn == NULL) {
		CHKiRet(initConn(pWrkrData-&gt;pData, 0));
	}
#	ifdef HAVE_DBI_TXSUPP
	if (pData-&gt;txSupport == 1) {
		if (dbi_conn_transaction_begin(pData-&gt;conn) != 0) {
			const char *emsg;
			dbi_conn_error(pData-&gt;conn, &amp;emsg);
			dbgprintf("libdbi server error: begin transaction "
				  "not successful: %s\n", emsg);
			closeConn(pData);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}
#	endif
finalize_it:
ENDbeginTransaction
/* end transaction */

BEGINdoAction
CODESTARTdoAction
	pthread_mutex_lock(&amp;mutDoAct);
	CHKiRet(writeDB(ppString[0], pWrkrData-&gt;pData));
#	ifdef HAVE_DBI_TXSUPP
	if (pData-&gt;txSupport == 1) {
		iRet = RS_RET_DEFER_COMMIT;
	}
#	endif
finalize_it:
	pthread_mutex_unlock(&amp;mutDoAct);
ENDdoAction

/* transaction support 2013-03 */
BEGINendTransaction
CODESTARTendTransaction
#	ifdef HAVE_DBI_TXSUPP
	if (dbi_conn_transaction_commit(pData-&gt;conn) != 0) {
		const char *emsg;
		dbi_conn_error(pData-&gt;conn, &amp;emsg);
		dbgprintf("libdbi server error: transaction not committed: %s\n",
			  emsg);
		closeConn(pData);
		iRet = RS_RET_SUSPENDED;
	}
#	endif
ENDendTransaction
/* end transaction */

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;tplName = NULL;
	bLegacyCnfModGlobalsPermitted = 1;
ENDbeginCnfLoad

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
<a name="1"></a>	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "omlibdbi: error processing "
			  	"module config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for omlibdbi:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "template")) {
			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			if(pszFileDfltTplName != NULL) {
				LogError(0, RS_RET_DUP_PARAM, "omlibdbi: warning: default template "
						"was already set via legacy directive - may lead to inconsistent "
						"results.");
			}
		} else if(!strcmp(modpblk.descr[i].name, "driverdirectory")) {
			loadModConf-&gt;dbiDrvrDir = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf("omlibdbi: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
	bLegacyCnfModGlobalsPermitted = 0;
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
	/* free legacy config vars */
	free(cs.dbiDrvrDir);
	free(cs.drvrName);
	free(cs.host);
	free(cs.usrName);
	free(cs.pwd);
	free(cs.dbName);
	cs.dbiDrvrDir = NULL;
	cs.drvrName = NULL;
	cs.host = NULL;
	cs.usrName = NULL;
	cs.pwd = NULL;
	cs.dbName = NULL;
	free(pszFileDfltTplName);
	pszFileDfltTplName = NULL;
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;tplName);
	free(pModConf-&gt;dbiDrvrDir);
ENDfreeCnf




static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;tplName = NULL;
}


BEGINnewActInst
	struct cnfparamvals *pvals;
	uchar *tplToUse;
	int i;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	CODE_STD_STRING_REQUESTnewActInst(1)
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "server")) {
			pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "db")) {
			pData-&gt;dbName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "uid")) {
			pData-&gt;usrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "driver")) {
			pData-&gt;drvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf("omlibdbi: program error, non-handled "
			  "param '%s'\n", actpblk.descr[i].name);
		}
	}

	tplToUse = (pData-&gt;tplName == NULL) ? (uchar*)strdup((char*)getDfltTpl()) : pData-&gt;tplName;
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_RQD_TPL_OPT_SQL));
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(!strncmp((char*) p, ":omlibdbi:", sizeof(":omlibdbi:") - 1)) {
		p += sizeof(":omlibdbi:") - 1; /* eat indicator sequence (-1 because of '\0'!) */
	} else {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	CHKiRet(createInstance(&amp;pData));
	/* no create the instance based on what we currently have */
	if(cs.drvrName == NULL) {
		LogError(0, RS_RET_NO_DRIVERNAME, "omlibdbi: no db driver name given - action can not "
				"be created");
		ABORT_FINALIZE(RS_RET_NO_DRIVERNAME);
	}

	if((pData-&gt;drvrName = (uchar*) strdup((char*)cs.drvrName)) == NULL) ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	/* NULL values are supported because drivers have different needs.
	 * They will err out on connect. -- rgerhards, 2008-02-15
	 */
	if(cs.host != NULL)
		CHKmalloc(pData-&gt;host = (uchar*) strdup((char*)cs.host));
	if(cs.usrName != NULL)
		CHKmalloc(pData-&gt;usrName = (uchar*) strdup((char*)cs.usrName));
	if(cs.dbName != NULL)
		CHKmalloc(pData-&gt;dbName = (uchar*) strdup((char*)cs.dbName));
	if(cs.pwd != NULL)
		CHKmalloc(pData-&gt;pwd = (uchar*) strdup((char*)cs.pwd));
	if(cs.dbiDrvrDir != NULL)
		CHKmalloc(loadModConf-&gt;dbiDrvrDir = (uchar*) strdup((char*)cs.dbiDrvrDir));
	iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, getDfltTpl());
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
	/* if we initialized libdbi, we now need to cleanup */
	if(bDbiInitialized) {
#		ifdef HAVE_DBI_R
		dbi_shutdown_r(dbiInst);
#		else
		dbi_shutdown();
#		endif
	}
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_TXIF_OMOD_QUERIES /* we support the transactional interface! */
ENDqueryEtryPt


/* Reset config variables for this module to default values.
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	free(cs.dbiDrvrDir);
	cs.dbiDrvrDir = NULL;
	free(cs.drvrName);
	cs.drvrName = NULL;
	free(cs.host);
	cs.host = NULL;
	free(cs.usrName);
	cs.usrName = NULL;
	free(cs.pwd);
	cs.pwd = NULL;
	free(cs.dbName);
	cs.dbName = NULL;
	RETiRet;
}


BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
#	ifndef HAVE_DBI_TXSUPP
	DBGPRINTF("omlibdbi: no transaction support in libdbi\n");
#	endif
	CHKiRet(regCfSysLineHdlr2((uchar *)"actionlibdbidriverdirectory", 0, eCmdHdlrGetWord, NULL, &amp;cs.dbiDrvrDir,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbidriver", 0, eCmdHdlrGetWord, NULL, &amp;cs.drvrName,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbihost", 0, eCmdHdlrGetWord, NULL, &amp;cs.host,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbiusername", 0, eCmdHdlrGetWord, NULL, &amp;cs.usrName,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbipassword", 0, eCmdHdlrGetWord, NULL, &amp;cs.pwd,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbidbname", 0, eCmdHdlrGetWord, NULL, &amp;cs.dbName,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
	NULL, STD_LOADABLE_MODULE_ID));
	DBGPRINTF("omlibdbi compiled with version %s loaded, libdbi version %s\n", VERSION, dbi_version());
ENDmodInit

/* vim:set ai:
 */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
