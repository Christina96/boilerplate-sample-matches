<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for pmciscoios.c &amp; omlibdbi.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pmciscoios.c &amp; omlibdbi.c
      </h3>
<h1 align="center">
        10.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pmciscoios.c (18.82353%)<th>omlibdbi.c (7.126949%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(55-63)<td><a href="#" name="0">(109-117)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(114-127)<td><a href="#" name="1">(427-442)</a><td align="center"><font color="#e10000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pmciscoios.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdlib.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;assert.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;ctype.h&gt;
8 #include "conf.h"
9 #include "syslogd-types.h"
10 #include "template.h"
11 #include "msg.h"
12 #include "module-template.h"
13 #include "glbl.h"
14 #include "errmsg.h"
15 #include "parser.h"
16 #include "datetime.h"
17 #include "unicode-helper.h"
18 MODULE_TYPE_PARSER
19 MODULE_TYPE_NOKEEP
20 PARSER_NAME("rsyslog.ciscoios")
21 MODULE_CNFNAME("pmciscoios")
22 DEF_PMOD_STATIC_DATA
23 DEFobjCurrIf(glbl)
24 DEFobjCurrIf(parser)
25 DEFobjCurrIf(datetime)
26 <a name="0"></a>
27 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr parserpdescr[] = {
28 	{ "present.origin", eCmdHdlrBinary, 0 },
29 	{ "present.xr", eCmdHdlrBinary, 0 }
30 };
31 static struct cnfparamblk parserpblk =
32 	{ CNFPARAMBLK_VERSION,
33 	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
34 	  parserpdescr
35 	};</b></font>
36 struct instanceConf_s {
37 	int bOriginPresent; 	int bXrPresent; };
38 BEGINisCompatibleWithFeature
39 CODESTARTisCompatibleWithFeature
40 	if(eFeat == sFEATUREAutomaticSanitazion)
41 		iRet = RS_RET_OK;
42 	if(eFeat == sFEATUREAutomaticPRIParsing)
43 		iRet = RS_RET_OK;
44 ENDisCompatibleWithFeature
45 static rsRetVal
46 createInstance(instanceConf_t **pinst)
47 {
48 	instanceConf_t *inst;
49 	DEFiRet;
50 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
51 	inst-&gt;bOriginPresent = 0;
52 	inst-&gt;bXrPresent = 0;
53 	*pinst = inst;
54 finalize_it:
55 	RETiRet;
56 }
57 BEGINfreeParserInst
58 CODESTARTfreeParserInst
59 	dbgprintf("pmciscoios: free parser instance %p\n", pInst);
60 ENDfreeParserInst
61 BEGINnewParserInst
62 	struct cnfparamvals *pvals = NULL;
63 	int i;
64 CODESTARTnewParserInst
65 	DBGPRINTF("newParserInst (pmciscoios)\n");
66 	inst = NULL;
67 	CHKiRet(createInstance(&amp;inst));
68 <a name="1"></a>	if(lst == NULL)
69 		FINALIZE;  
70 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;parserpblk, NULL)) == NULL) {
71 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
72 	}
73 	if(Debug) {
74 		dbgprintf("parser param blk in pmciscoios:\n");
75 		cnfparamsPrint(&amp;parserpblk, pvals);
76 	}
77 	for(i = 0 ; i &lt; parserpblk.nParams ; ++i) {
78 		if(!pvals[i].bUsed)
79 			continue;
80 		if(!strcmp(parserpblk.descr[i].name, "present.origin")) {
81 			inst-&gt;bOriginPresent = (int) pvals[i].val.d.n;</b></font>
82 		} else if(!strcmp(parserpblk.descr[i].name, "present.xr")) {
83 			inst-&gt;bXrPresent = (int) pvals[i].val.d.n;
84 		} else {
85 			dbgprintf("pmciscoios: program error, non-handled "
86 				"param '%s'\n", parserpblk.descr[i].name);
87 		}
88 	}
89 finalize_it:
90 CODE_STD_FINALIZERnewParserInst
91 	if(lst != NULL)
92 		cnfparamvalsDestruct(pvals, &amp;parserpblk);
93 	if(iRet != RS_RET_OK)
94 		freeParserInst(inst);
95 ENDnewParserInst
96 BEGINparse2
97 	uchar *p2parse;
98 	long long msgcounter;
99 	int lenMsg;
100 	int i;
101 	int iHostname = 0;
102 	uchar bufParseTAG[512];
103 	uchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE]; CODESTARTparse2
104 	DBGPRINTF("Message will now be parsed by pmciscoios\n");
105 	assert(pMsg != NULL);
106 	assert(pMsg-&gt;pszRawMsg != NULL);
107 	lenMsg = pMsg-&gt;iLenRawMsg - pMsg-&gt;offAfterPRI;
108 	p2parse = pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI; 
109 	msgcounter = 0;
110 	while(lenMsg &gt; 0 &amp;&amp; (*p2parse &gt;= '0' &amp;&amp; *p2parse &lt;= '9') ) {
111 		msgcounter = msgcounter * 10 + *p2parse - '0';
112 		++p2parse, --lenMsg;
113 	}
114 	DBGPRINTF("pmciscoios: msgcntr %lld\n", msgcounter);
115 	if(lenMsg &lt; 2 || *p2parse != ':' || *(p2parse+1) != ' ') {
116 		DBGPRINTF("pmciscoios: fail after seqno: '%s'\n", p2parse);
117 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
118 	}
119 	p2parse += 2;
120 	if(pInst-&gt;bOriginPresent) {
121 		iHostname = 0;
122 		while(   lenMsg &gt; 1
123 		      &amp;&amp; !(*p2parse == ':' &amp;&amp; *(p2parse+1) == ' ')  		      &amp;&amp; iHostname &lt; (int) sizeof(bufParseHOSTNAME) - 1 ) {
124 			bufParseHOSTNAME[iHostname++] = *p2parse++;
125 			--lenMsg;
126 		}
127 		bufParseHOSTNAME[iHostname] = '\0';
128 		if(lenMsg &lt; 2 || *(p2parse+1) != ' ') {
129 			DBGPRINTF("pmciscoios: fail after origin: '%s'\n", p2parse);
130 			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
131 		}
132 		p2parse += 2;
133 	}
134 	if(pInst-&gt;bXrPresent) {
135 		while(   lenMsg &gt; 1
136 			&amp;&amp; !(*p2parse == ':')) {
137 			--lenMsg;
138 			++p2parse;
139 		}
140 		if(lenMsg &lt; 2) {
141 			DBGPRINTF("pmciscoios: fail after XR: '%s'\n", p2parse);
142 			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
143 		}
144 		p2parse += 1;
145 	}
146 	if(p2parse[0] == '*' || p2parse[0] == '.') p2parse++;
147 	if(datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg, PARSE3164_TZSTRING,
148 	NO_PERMIT_YEAR_AFTER_TIME) == RS_RET_OK) {
149 		if(pMsg-&gt;dfltTZ[0] != '\0')
150 			applyDfltTZ(&amp;pMsg-&gt;tTIMESTAMP, pMsg-&gt;dfltTZ);
151 	} else {
152 		DBGPRINTF("pmciscoios: fail at timestamp: '%s'\n", p2parse);
153 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
154 	}
155 	if(pInst-&gt;bXrPresent) {
156 		while(   lenMsg &gt; 1
157 			&amp;&amp; !(*p2parse == '%')) {
158 			--lenMsg;
159 			p2parse++;
160 		}
161 		if(lenMsg &lt; 2) {
162 			DBGPRINTF("pmciscoios: fail after XR tag search: '%s'\n", p2parse);
163 			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
164 		}
165 	}
166 	if(lenMsg &lt; 1 || *p2parse != '%') {
167 		DBGPRINTF("pmciscoios: fail at tag begin (no '%%'): '%s'\n", p2parse);
168 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
169 	}
170 	i = 0;
171 	while(lenMsg &gt; 0 &amp;&amp; *p2parse != ':' &amp;&amp; *p2parse != ' ' &amp;&amp; i &lt; (int) sizeof(bufParseTAG) - 2) {
172 		bufParseTAG[i++] = *p2parse++;
173 		--lenMsg;
174 	}
175 	if(pInst-&gt;bXrPresent) p2parse++;
176 	if(lenMsg &lt; 2 || *p2parse != ':' || *(p2parse+1) != ' ') {
177 		DBGPRINTF("pmciscoios: fail after tag: '%s'\n", p2parse);
178 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
179 	}
180 	++p2parse;
181 	bufParseTAG[i++] = ':';
182 	bufParseTAG[i] = '\0';	
183 	MsgSetTAG(pMsg, bufParseTAG, i);
184 	if(pInst-&gt;bOriginPresent)
185 		MsgSetHOSTNAME(pMsg, bufParseHOSTNAME, iHostname);
186 	MsgSetMSGoffs(pMsg, p2parse - pMsg-&gt;pszRawMsg);
187 	setProtocolVersion(pMsg, MSG_LEGACY_PROTOCOL);
188 finalize_it:
189 ENDparse2
190 BEGINmodExit
191 CODESTARTmodExit
192 	objRelease(glbl, CORE_COMPONENT);
193 	objRelease(parser, CORE_COMPONENT);
194 	objRelease(datetime, CORE_COMPONENT);
195 ENDmodExit
196 BEGINqueryEtryPt
197 CODESTARTqueryEtryPt
198 CODEqueryEtryPt_STD_PMOD2_QUERIES
199 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
200 ENDqueryEtryPt
201 BEGINmodInit()
202 CODESTARTmodInit
203 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
204 	CHKiRet(objUse(glbl, CORE_COMPONENT));
205 	CHKiRet(objUse(parser, CORE_COMPONENT));
206 	CHKiRet(objUse(datetime, CORE_COMPONENT));
207 	DBGPRINTF("pmciscoios parser init called\n");
208 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omlibdbi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;time.h&gt;
11 #include &lt;libgen.h&gt;
12 #include &lt;dbi/dbi.h&gt;
13 #include "dirty.h"
14 #include "syslogd-types.h"
15 #include "cfsysline.h"
16 #include "conf.h"
17 #include "srUtils.h"
18 #include "template.h"
19 #include "module-template.h"
20 #include "debug.h"
21 #include "errmsg.h"
22 #include "conf.h"
23 #undef HAVE_DBI_TXSUPP
24 MODULE_TYPE_OUTPUT
25 MODULE_TYPE_NOKEEP
26 MODULE_CNFNAME("omlibdbi")
27 DEF_OMOD_STATIC_DATA
28 static int bDbiInitialized = 0;	
29 typedef struct _instanceData {
30 	uchar *dbiDrvrDir;		dbi_conn conn;			uchar *drvrName;		uchar *host;			uchar *usrName;			uchar *pwd;			uchar *dbName;			unsigned uLastDBErrno;		uchar	*tplName;       	int txSupport;		} instanceData;
31 typedef struct wrkrInstanceData {
32 	instanceData *pData;
33 } wrkrInstanceData_t;
34 typedef struct configSettings_s {
35 	uchar *dbiDrvrDir;		uchar *drvrName;		uchar *host;			uchar *usrName;			uchar *pwd;			uchar *dbName;		} configSettings_t;
36 static configSettings_t cs;
37 uchar	*pszFileDfltTplName; 
38 struct modConfData_s {
39 	rsconf_t *pConf;		uchar *dbiDrvrDir;		uchar 	*tplName;	};
40 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static int bLegacyCnfModGlobalsPermitted;
41 static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;
42 <a name="0"></a>
43 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static struct cnfparamdescr modpdescr[] = {
44 	{ "template", eCmdHdlrGetWord, 0 },
45 	{ "driverdirectory", eCmdHdlrGetWord, 0 }
46 };
47 static struct cnfparamblk modpblk =
48 	{ CNFPARAMBLK_VERSION,
49 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
50 	  modpdescr
51 	};</b></font>
52 static struct cnfparamdescr actpdescr[] = {
53 	{ "server", eCmdHdlrGetWord, 1 },
54 	{ "db", eCmdHdlrGetWord, 1 },
55 	{ "uid", eCmdHdlrGetWord, 1 },
56 	{ "pwd", eCmdHdlrGetWord, 1 },
57 	{ "driver", eCmdHdlrGetWord, 1 },
58 	{ "template", eCmdHdlrGetWord, 0 }
59 };
60 static struct cnfparamblk actpblk =
61 	{ CNFPARAMBLK_VERSION,
62 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
63 	  actpdescr
64 	};
65 static uchar*
66 getDfltTpl(void)
67 {
68 	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
69 		return loadModConf-&gt;tplName;
70 	else if(pszFileDfltTplName == NULL)
71 		return (uchar*)" StdDBFmt";
72 	else
73 		return pszFileDfltTplName;
74 }
75 BEGINinitConfVars		CODESTARTinitConfVars
76 	cs.dbiDrvrDir = NULL;
77 	cs.drvrName = NULL;
78 	cs.host = NULL;
79 	cs.usrName = NULL;
80 	cs.pwd = NULL;
81 	cs.dbName = NULL;
82 ENDinitConfVars
83 #ifdef HAVE_DBI_R
84 static dbi_inst dbiInst;
85 #endif
86 BEGINcreateInstance
87 CODESTARTcreateInstance
88 ENDcreateInstance
89 BEGINcreateWrkrInstance
90 CODESTARTcreateWrkrInstance
91 ENDcreateWrkrInstance
92 BEGINisCompatibleWithFeature
93 CODESTARTisCompatibleWithFeature
94 ENDisCompatibleWithFeature
95 static void closeConn(instanceData *pData)
96 {
97 	assert(pData != NULL);
98 	if(pData-&gt;conn != NULL) {			dbi_conn_close(pData-&gt;conn);
99 		pData-&gt;conn = NULL;
100 	}
101 }
102 BEGINfreeInstance
103 CODESTARTfreeInstance
104 	free(pData-&gt;drvrName);
105 	free(pData-&gt;host);
106 	free(pData-&gt;usrName);
107 	free(pData-&gt;pwd);
108 	free(pData-&gt;dbName);
109 ENDfreeInstance
110 BEGINfreeWrkrInstance
111 CODESTARTfreeWrkrInstance
112 	closeConn(pWrkrData-&gt;pData);
113 ENDfreeWrkrInstance
114 BEGINdbgPrintInstInfo
115 CODESTARTdbgPrintInstInfo
116 ENDdbgPrintInstInfo
117 static void
118 reportDBError(instanceData *pData, int bSilent)
119 {
120 	unsigned uDBErrno;
121 	char errMsg[1024];
122 	const char *pszDbiErr;
123 	assert(pData != NULL);
124 	errno = 0;
125 	if(pData-&gt;conn == NULL) {
126 		LogError(0, NO_ERRCODE, "unknown DB error occurred - could not obtain connection handle");
127 	} else { 		uDBErrno = dbi_conn_error(pData-&gt;conn, &amp;pszDbiErr);
128 		snprintf(errMsg, sizeof(errMsg), "db error (%d): %s\n", uDBErrno, pszDbiErr);
129 		if(bSilent || uDBErrno == pData-&gt;uLastDBErrno)
130 			dbgprintf("libdbi, DBError(silent): %s\n", errMsg);
131 		else {
132 			pData-&gt;uLastDBErrno = uDBErrno;
133 			LogError(0, NO_ERRCODE, "%s", errMsg);
134 		}
135 	}
136 }
137 static rsRetVal initConn(instanceData *pData, int bSilent)
138 {
139 	DEFiRet;
140 	int iDrvrsLoaded;
141 	assert(pData != NULL);
142 	assert(pData-&gt;conn == NULL);
143 	if(bDbiInitialized == 0) {
144 #		ifdef HAVE_DBI_R
145 		iDrvrsLoaded = dbi_initialize_r((char*) pData-&gt;dbiDrvrDir, &amp;dbiInst);
146 #		else
147 		iDrvrsLoaded = dbi_initialize((char*) pData-&gt;dbiDrvrDir);
148 #		endif
149 		if(iDrvrsLoaded == 0) {
150 			LogError(0, RS_RET_SUSPENDED, "libdbi error: libdbi or libdbi drivers not "
151 			"present on this system - suspending.");
152 			ABORT_FINALIZE(RS_RET_SUSPENDED);
153 		} else if(iDrvrsLoaded &lt; 0) {
154 			LogError(0, RS_RET_SUSPENDED, "libdbi error: libdbi could not be "
155 				"initialized (do you have any dbi drivers installed?) - suspending.");
156 			ABORT_FINALIZE(RS_RET_SUSPENDED);
157 		}
158 		bDbiInitialized = 1; 	}
159 #	ifdef HAVE_DBI_R
160 	pData-&gt;conn = dbi_conn_new_r((char*)pData-&gt;drvrName, dbiInst);
161 #	else
162 	pData-&gt;conn = dbi_conn_new((char*)pData-&gt;drvrName);
163 #	endif
164 	if(pData-&gt;conn == NULL) {
165 		LogError(0, RS_RET_SUSPENDED, "can not initialize libdbi connection");
166 		ABORT_FINALIZE(RS_RET_SUSPENDED);
167 	} else { 		dbi_conn_set_option(pData-&gt;conn, "host",     (char*) pData-&gt;host);
168 		dbi_conn_set_option(pData-&gt;conn, "username", (char*) pData-&gt;usrName);
169 		int is_sqlite2 = !strcmp((const char *)pData-&gt;drvrName, "sqlite");
170 		int is_sqlite3 = !strcmp((const char *)pData-&gt;drvrName, "sqlite3");
171 		if(is_sqlite2 || is_sqlite3) {
172 			dbi_conn_set_option(pData-&gt;conn, is_sqlite3 ? "sqlite3_dbdir" : "sqlite_dbdir",
173 							dirname((char *)pData-&gt;dbName));
174 			dbi_conn_set_option(pData-&gt;conn, "dbname", basename((char *)pData-&gt;dbName ));
175 		} else {
176 			dbi_conn_set_option(pData-&gt;conn, "dbname",   (char*) pData-&gt;dbName);
177 		}
178 		if(pData-&gt;pwd != NULL)
179 			dbi_conn_set_option(pData-&gt;conn, "password", (char*) pData-&gt;pwd);
180 		if(dbi_conn_connect(pData-&gt;conn) &lt; 0) {
181 			reportDBError(pData, bSilent);
182 			closeConn(pData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
183 		}
184 		pData-&gt;txSupport = dbi_conn_cap_get(pData-&gt;conn, "transaction_support");
185 	}
186 finalize_it:
187 	RETiRet;
188 }
189 static rsRetVal
190 writeDB(const uchar *psz, instanceData *const __restrict__ pData)
191 {
192 	DEFiRet;
193 	dbi_result dbiRes = NULL;
194 	assert(psz != NULL);
195 	assert(pData != NULL);
196 	if(pData-&gt;conn == NULL) {
197 		CHKiRet(initConn(pData, 0));
198 	}
199 	if((dbiRes = dbi_conn_query(pData-&gt;conn, (const char*)psz)) == NULL) {
200 		closeConn(pData); 		CHKiRet(initConn(pData, 0)); 		if((dbiRes = dbi_conn_query(pData-&gt;conn, (const char*)psz)) == NULL) { 			reportDBError(pData, 0);
201 			closeConn(pData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
202 		}
203 	}
204 finalize_it:
205 	if(iRet == RS_RET_OK) {
206 		pData-&gt;uLastDBErrno = 0; 	}
207 	if(dbiRes != NULL)
208 		dbi_result_free(dbiRes);
209 	RETiRet;
210 }
211 BEGINtryResume
212 CODESTARTtryResume
213 	if(pWrkrData-&gt;pData-&gt;conn == NULL) {
214 		iRet = initConn(pWrkrData-&gt;pData, 1);
215 	}
216 ENDtryResume
217 BEGINbeginTransaction
218 CODESTARTbeginTransaction
219 	if(pWrkrData-&gt;pData-&gt;conn == NULL) {
220 		CHKiRet(initConn(pWrkrData-&gt;pData, 0));
221 	}
222 #	ifdef HAVE_DBI_TXSUPP
223 	if (pData-&gt;txSupport == 1) {
224 		if (dbi_conn_transaction_begin(pData-&gt;conn) != 0) {
225 			const char *emsg;
226 			dbi_conn_error(pData-&gt;conn, &amp;emsg);
227 			dbgprintf("libdbi server error: begin transaction "
228 				  "not successful: %s\n", emsg);
229 			closeConn(pData);
230 			ABORT_FINALIZE(RS_RET_SUSPENDED);
231 		}
232 	}
233 #	endif
234 finalize_it:
235 ENDbeginTransaction
236 BEGINdoAction
237 CODESTARTdoAction
238 	pthread_mutex_lock(&amp;mutDoAct);
239 	CHKiRet(writeDB(ppString[0], pWrkrData-&gt;pData));
240 #	ifdef HAVE_DBI_TXSUPP
241 	if (pData-&gt;txSupport == 1) {
242 		iRet = RS_RET_DEFER_COMMIT;
243 	}
244 #	endif
245 finalize_it:
246 	pthread_mutex_unlock(&amp;mutDoAct);
247 ENDdoAction
248 BEGINendTransaction
249 CODESTARTendTransaction
250 #	ifdef HAVE_DBI_TXSUPP
251 	if (dbi_conn_transaction_commit(pData-&gt;conn) != 0) {
252 		const char *emsg;
253 		dbi_conn_error(pData-&gt;conn, &amp;emsg);
254 		dbgprintf("libdbi server error: transaction not committed: %s\n",
255 			  emsg);
256 		closeConn(pData);
257 		iRet = RS_RET_SUSPENDED;
258 	}
259 #	endif
260 ENDendTransaction
261 BEGINbeginCnfLoad
262 CODESTARTbeginCnfLoad
263 	loadModConf = pModConf;
264 	pModConf-&gt;pConf = pConf;
265 	pModConf-&gt;tplName = NULL;
266 	bLegacyCnfModGlobalsPermitted = 1;
267 ENDbeginCnfLoad
268 BEGINsetModCnf
269 	struct cnfparamvals *pvals = NULL;
270 <a name="1"></a>	int i;
271 CODESTARTsetModCnf
272 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
273 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
274 		LogError(0, RS_RET_MISSING_CNFPARAMS, "omlibdbi: error processing "
275 			  	"module config parameters [module(...)]");
276 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
277 	}
278 	if(Debug) {
279 		dbgprintf("module (global) param blk for omlibdbi:\n");
280 		cnfparamsPrint(&amp;modpblk, pvals);
281 	}
282 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
283 		if(!pvals[i].bUsed)
284 			continue;
285 		if(!strcmp(modpblk.descr[i].name, "template")) {
286 			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
287 			if(pszFileDfltTplName != NULL) {
288 				LogError(0, RS_RET_DUP_PARAM, "omlibdbi: warning: default template "
289 						"was already set via legacy directive - may lead to inconsistent "
290 						"results.");
291 			}
292 		} else if(!strcmp(modpblk.descr[i].name, "driverdirectory")) {
293 			loadModConf-&gt;dbiDrvrDir = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
294 		} else {
295 			dbgprintf("omlibdbi: program error, non-handled "
296 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
297 		}
298 	}
299 	bLegacyCnfModGlobalsPermitted = 0;
300 finalize_it:
301 	if(pvals != NULL)
302 		cnfparamvalsDestruct(pvals, &amp;modpblk);
303 ENDsetModCnf
304 BEGINendCnfLoad
305 CODESTARTendCnfLoad
306 	loadModConf = NULL; 	free(cs.dbiDrvrDir);
307 	free(cs.drvrName);
308 	free(cs.host);
309 	free(cs.usrName);
310 	free(cs.pwd);
311 	free(cs.dbName);
312 	cs.dbiDrvrDir = NULL;
313 	cs.drvrName = NULL;
314 	cs.host = NULL;
315 	cs.usrName = NULL;
316 	cs.pwd = NULL;
317 	cs.dbName = NULL;
318 	free(pszFileDfltTplName);
319 	pszFileDfltTplName = NULL;
320 ENDendCnfLoad
321 BEGINcheckCnf
322 CODESTARTcheckCnf
323 ENDcheckCnf
324 BEGINactivateCnf
325 CODESTARTactivateCnf
326 	runModConf = pModConf;
327 ENDactivateCnf
328 BEGINfreeCnf
329 CODESTARTfreeCnf
330 	free(pModConf-&gt;tplName);
331 	free(pModConf-&gt;dbiDrvrDir);
332 ENDfreeCnf
333 static inline void
334 setInstParamDefaults(instanceData *pData)
335 {
336 	pData-&gt;tplName = NULL;
337 }
338 BEGINnewActInst
339 	struct cnfparamvals *pvals;
340 	uchar *tplToUse;
341 	int i;
342 CODESTARTnewActInst
343 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
344 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
345 	}
346 	CHKiRet(createInstance(&amp;pData));
347 	setInstParamDefaults(pData);
348 	CODE_STD_STRING_REQUESTnewActInst(1)
349 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
350 		if(!pvals[i].bUsed)
351 			continue;
352 		if(!strcmp(actpblk.descr[i].name, "server")) {
353 			pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
354 		} else if(!strcmp(actpblk.descr[i].name, "db")) {
355 			pData-&gt;dbName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
356 		} else if(!strcmp(actpblk.descr[i].name, "uid")) {
357 			pData-&gt;usrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
358 		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
359 			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
360 		} else if(!strcmp(actpblk.descr[i].name, "driver")) {
361 			pData-&gt;drvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
362 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
363 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
364 		} else {
365 			dbgprintf("omlibdbi: program error, non-handled "
366 			  "param '%s'\n", actpblk.descr[i].name);
367 		}
368 	}
369 	tplToUse = (pData-&gt;tplName == NULL) ? (uchar*)strdup((char*)getDfltTpl()) : pData-&gt;tplName;
370 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_RQD_TPL_OPT_SQL));
371 CODE_STD_FINALIZERnewActInst
372 	cnfparamvalsDestruct(pvals, &amp;actpblk);
373 ENDnewActInst
374 BEGINparseSelectorAct
375 CODESTARTparseSelectorAct
376 CODE_STD_STRING_REQUESTparseSelectorAct(1)
377 	if(!strncmp((char*) p, ":omlibdbi:", sizeof(":omlibdbi:") - 1)) {
378 		p += sizeof(":omlibdbi:") - 1; 	} else {
379 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
380 	}
381 	CHKiRet(createInstance(&amp;pData));
382 	if(cs.drvrName == NULL) {
383 		LogError(0, RS_RET_NO_DRIVERNAME, "omlibdbi: no db driver name given - action can not "
384 				"be created");
385 		ABORT_FINALIZE(RS_RET_NO_DRIVERNAME);
386 	}
387 	if((pData-&gt;drvrName = (uchar*) strdup((char*)cs.drvrName)) == NULL) ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
388 	if(cs.host != NULL)
389 		CHKmalloc(pData-&gt;host = (uchar*) strdup((char*)cs.host));
390 	if(cs.usrName != NULL)
391 		CHKmalloc(pData-&gt;usrName = (uchar*) strdup((char*)cs.usrName));
392 	if(cs.dbName != NULL)
393 		CHKmalloc(pData-&gt;dbName = (uchar*) strdup((char*)cs.dbName));
394 	if(cs.pwd != NULL)
395 		CHKmalloc(pData-&gt;pwd = (uchar*) strdup((char*)cs.pwd));
396 	if(cs.dbiDrvrDir != NULL)
397 		CHKmalloc(loadModConf-&gt;dbiDrvrDir = (uchar*) strdup((char*)cs.dbiDrvrDir));
398 	iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, getDfltTpl());
399 CODE_STD_FINALIZERparseSelectorAct
400 ENDparseSelectorAct
401 BEGINmodExit
402 CODESTARTmodExit
403 	if(bDbiInitialized) {
404 #		ifdef HAVE_DBI_R
405 		dbi_shutdown_r(dbiInst);
406 #		else
407 		dbi_shutdown();
408 #		endif
409 	}
410 ENDmodExit
411 BEGINqueryEtryPt
412 CODESTARTqueryEtryPt
413 CODEqueryEtryPt_STD_OMOD_QUERIES
414 CODEqueryEtryPt_STD_OMOD8_QUERIES
415 CODEqueryEtryPt_STD_CONF2_QUERIES
416 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
417 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
418 CODEqueryEtryPt_TXIF_OMOD_QUERIES ENDqueryEtryPt
419 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
420 {
421 	DEFiRet;
422 	free(cs.dbiDrvrDir);
423 	cs.dbiDrvrDir = NULL;
424 	free(cs.drvrName);
425 	cs.drvrName = NULL;
426 	free(cs.host);
427 	cs.host = NULL;
428 	free(cs.usrName);
429 	cs.usrName = NULL;
430 	free(cs.pwd);
431 	cs.pwd = NULL;
432 	free(cs.dbName);
433 	cs.dbName = NULL;
434 	RETiRet;
435 }
436 BEGINmodInit()
437 CODESTARTmodInit
438 INITLegCnfVars
439 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
440 #	ifndef HAVE_DBI_TXSUPP
441 	DBGPRINTF("omlibdbi: no transaction support in libdbi\n");
442 #	endif
443 	CHKiRet(regCfSysLineHdlr2((uchar *)"actionlibdbidriverdirectory", 0, eCmdHdlrGetWord, NULL, &amp;cs.dbiDrvrDir,
444 	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
445 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbidriver", 0, eCmdHdlrGetWord, NULL, &amp;cs.drvrName,
446 	STD_LOADABLE_MODULE_ID));
447 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbihost", 0, eCmdHdlrGetWord, NULL, &amp;cs.host,
448 	STD_LOADABLE_MODULE_ID));
449 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbiusername", 0, eCmdHdlrGetWord, NULL, &amp;cs.usrName,
450 	STD_LOADABLE_MODULE_ID));
451 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbipassword", 0, eCmdHdlrGetWord, NULL, &amp;cs.pwd,
452 	STD_LOADABLE_MODULE_ID));
453 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbidbname", 0, eCmdHdlrGetWord, NULL, &amp;cs.dbName,
454 	STD_LOADABLE_MODULE_ID));
455 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
456 	NULL, STD_LOADABLE_MODULE_ID));
457 	DBGPRINTF("omlibdbi compiled with version %s loaded, libdbi version %s\n", VERSION, dbi_version());
458 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
