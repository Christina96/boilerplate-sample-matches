
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-tasks.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
4  #include "FreeRTOS.h"
5  #include "task.h"
6  #include "timers.h"
7  #include "stack_macros.h"
8  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE &bsol;*lint !e961 !e750. */
9  #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
10  	#include <stdio.h>
11  #endif &bsol;* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
12  #if( configUSE_PREEMPTION == 0 )
13  	#define taskYIELD_IF_USING_PREEMPTION()
14  #else
15  	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
16  #endif
17  #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
18  #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
19  #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
20  #define tskSTACK_FILL_BYTE	( 0xa5U )
21  #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
22  #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
23  #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
24  #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
25  #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
26  	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
27  #else
28  	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
29  #endif
30  #define tskRUNNING_CHAR		( 'X' )
31  #define tskBLOCKED_CHAR		( 'B' )
32  #define tskREADY_CHAR		( 'R' )
33  #define tskDELETED_CHAR		( 'D' )
34  #define tskSUSPENDED_CHAR	( 'S' )
35  #ifdef portREMOVE_STATIC_QUALIFIER
36  	#define static
37  #endif
38  #ifndef configIDLE_TASK_NAME
39  	#define configIDLE_TASK_NAME "IDLE"
40  #endif
41  #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
42  	#define taskRECORD_READY_PRIORITY( uxPriority )														\
43  	{																									\
44  		if( ( uxPriority ) > uxTopReadyPriority )														\
45  		{																								\
46  			uxTopReadyPriority = ( uxPriority );														\
47  		}																								\
48  	} &bsol;* taskRECORD_READY_PRIORITY */
49  	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
50  	{																									\
51  	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
52  																										\
53  										\
54  		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
55  		{																								\
56  			configASSERT( uxTopPriority );																\
57  			--uxTopPriority;																			\
58  		}																								\
59  																										\
60  											\
61  		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
62  		uxTopReadyPriority = uxTopPriority;																\
63  	} &bsol;* taskSELECT_HIGHEST_PRIORITY_TASK */
64  	#define taskRESET_READY_PRIORITY( uxPriority )
65  	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
66  #else &bsol;* configUSE_PORT_OPTIMISED_TASK_SELECTION */
67  	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
68  	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
69  	{																								\
70  	UBaseType_t uxTopPriority;																		\
71  																									\
72  										\
73  		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
74  		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
75  		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
76  	} &bsol;* taskSELECT_HIGHEST_PRIORITY_TASK() */
77  	#define taskRESET_READY_PRIORITY( uxPriority )														\
78  	{																									\
79  		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
80  		{																								\
81  			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
82  		}																								\
83  	}
84  #endif &bsol;* configUSE_PORT_OPTIMISED_TASK_SELECTION */
85  #define taskSWITCH_DELAYED_LISTS()																	\
86  {																									\
87  	List_t *pxTemp;																					\
88  																									\
89  							\
90  	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
91  																									\
92  	pxTemp = pxDelayedTaskList;																		\
93  	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
94  	pxOverflowDelayedTaskList = pxTemp;																\
95  	xNumOfOverflows++;																				\
96  	prvResetNextTaskUnblockTime();																	\
97  }
98  #define prvAddTaskToReadyList( pxTCB )																\
99  	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
100  	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
101  	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
102  	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
103  #define prvReaddTaskToReadyList( pxTCB )															\
104  	traceREADDED_TASK_TO_READY_STATE( pxTCB );														\
105  	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
106  	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
107  	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
108  #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
109  #if( configUSE_16_BIT_TICKS == 1 )
110  	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
111  #else
112  	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
113  #endif
114  typedef struct tskTaskControlBlock
115  {
116  	volatile StackType_t	*pxTopOfStack;	&bsol;*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
117  	#if ( portUSING_MPU_WRAPPERS == 1 )
118  		xMPU_SETTINGS	xMPUSettings;		&bsol;*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
119  	#endif
120  	ListItem_t			xStateListItem;	&bsol;*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
121  	ListItem_t			xEventListItem;		&bsol;*< Used to reference a task from an event list. */
122  	UBaseType_t			uxPriority;			&bsol;*< The priority of the task.  0 is the lowest priority. */
123  	StackType_t			*pxStack;			&bsol;*< Points to the start of the stack. */
124  	char				pcTaskName[ configMAX_TASK_NAME_LEN ];&bsol;*< Descriptive name given to the task when created.  Facilitates debugging only. */ &bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
125  	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
126  		StackType_t		*pxEndOfStack;		&bsol;*< Points to the highest valid address for the stack. */
127  	#endif
128  	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
129  		UBaseType_t		uxCriticalNesting;	&bsol;*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
130  	#endif
131  	#if ( configUSE_TRACE_FACILITY == 1 )
132  		UBaseType_t		uxTCBNumber;		&bsol;*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
133  		UBaseType_t		uxTaskNumber;		&bsol;*< Stores a number specifically for use by third party trace code. */
134  	#endif
135  	#if ( configUSE_MUTEXES == 1 )
136  		UBaseType_t		uxBasePriority;		&bsol;*< The priority last assigned to the task - used by the priority inheritance mechanism. */
137  		UBaseType_t		uxMutexesHeld;
138  	#endif
139  	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
140  		TaskHookFunction_t pxTaskTag;
141  	#endif
142  	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
143  		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
144  	#endif
145  	#if( configGENERATE_RUN_TIME_STATS == 1 )
146  		uint32_t		ulRunTimeCounter;	&bsol;*< Stores the amount of time the task has spent in the Running state. */
147  	#endif
148  	#if ( configUSE_NEWLIB_REENTRANT == 1 )
149  		struct	_reent xNewLib_reent;
150  	#endif
151  	#if( configUSE_TASK_NOTIFICATIONS == 1 )
152  		volatile uint32_t ulNotifiedValue;
153  		volatile uint8_t ucNotifyState;
154  	#endif
155  	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &bsol;*lint !e731 Macro has been consolidated for readability reasons. */
156  		uint8_t	ucStaticallyAllocated; 		&bsol;*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
157  	#endif
158  	#if( INCLUDE_xTaskAbortDelay == 1 )
159  		uint8_t ucDelayAborted;
160  	#endif
161  } tskTCB;
162  typedef tskTCB TCB_t;
163  PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
164  PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];&bsol;*< Prioritised ready tasks. */
165  PRIVILEGED_DATA static List_t xDelayedTaskList1;						&bsol;*< Delayed tasks. */
166  PRIVILEGED_DATA static List_t xDelayedTaskList2;						&bsol;*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
167  PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				&bsol;*< Points to the delayed task list currently being used. */
168  PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		&bsol;*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
169  PRIVILEGED_DATA static List_t xPendingReadyList;						&bsol;*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
170  #if( INCLUDE_vTaskDelete == 1 )
171  	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				&bsol;*< Tasks that have been deleted - but their memory not yet freed. */
172  	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
173  #endif
174  #if ( INCLUDE_vTaskSuspend == 1 )
175  	PRIVILEGED_DATA static List_t xSuspendedTaskList;					&bsol;*< Tasks that are currently suspended. */
176  #endif
177  PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
178  PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT;
179  PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
180  PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
181  PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
182  PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
183  PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
184  PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
185  PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; &bsol;* Initialised to portMAX_DELAY before the scheduler starts. */
186  PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			&bsol;*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
187  PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
188  #if ( configGENERATE_RUN_TIME_STATS == 1 )
189  	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	&bsol;*< Holds the value of a timer/counter the last time a task was switched in. */
190  	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		&bsol;*< Holds the total amount of execution time as defined by the run time counter clock. */
191  #endif
192  #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
193  	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
194  #endif
195  #if( configUSE_TICK_HOOK > 0 )
196  	extern void vApplicationTickHook( void );
197  #endif
198  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
199  	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );
200  #endif
201  #if ( INCLUDE_vTaskSuspend == 1 )
202  	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
203  #endif &bsol;* INCLUDE_vTaskSuspend */
204  static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
205  static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
206  #if ( INCLUDE_vTaskDelete == 1 )
207  	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
208  #endif
209  static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
210  static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
211  #if ( configUSE_TRACE_FACILITY == 1 )
212  	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
213  #endif
214  #if ( INCLUDE_xTaskGetHandle == 1 )
215  	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
216  #endif
217  #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
218  	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
219  #endif
220  #if ( configUSE_TICKLESS_IDLE != 0 )
221  	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
222  #endif
223  static void prvResetNextTaskUnblockTime( void );
224  #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
225  	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
226  #endif
227  static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
228  									const char * const pcName, 		&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
229  									const uint32_t ulStackDepth,
230  									void * const pvParameters,
231  									UBaseType_t uxPriority,
232  									TaskHandle_t * const pxCreatedTask,
233  									TCB_t *pxNewTCB,
234  									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
235  static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
236  #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
237  	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
238  #endif
239  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
240  	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
241  									const char * const pcName,		&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
242  									const uint32_t ulStackDepth,
243  									void * const pvParameters,
244  									UBaseType_t uxPriority,
245  									StackType_t * const puxStackBuffer,
246  									StaticTask_t * const pxTaskBuffer )
247  	{
248  	TCB_t *pxNewTCB;
249  	TaskHandle_t xReturn;
250  		configASSERT( puxStackBuffer != NULL );
251  		configASSERT( pxTaskBuffer != NULL );
252  		#if( configASSERT_DEFINED == 1 )
253  		{
254  			volatile size_t xSize = sizeof( StaticTask_t );
255  			configASSERT( xSize == sizeof( TCB_t ) );
256  		}
257  		#endif &bsol;* configASSERT_DEFINED */
258  		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
259  		{
260  			pxNewTCB = ( TCB_t * ) pxTaskBuffer; &bsol;*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
261  			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
262  			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &bsol;*lint !e731 Macro has been consolidated for readability reasons. */
263  			{
264  				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
265  			}
266  			#endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
267  			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
268  			prvAddNewTaskToReadyList( pxNewTCB );
269  		}
270  		else
271  		{
272  			xReturn = NULL;
273  		}
274  		return xReturn;
275  	}
276  #endif &bsol;* SUPPORT_STATIC_ALLOCATION */
277  #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
278  	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
279  	{
280  	TCB_t *pxNewTCB;
281  	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
282  		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
283  		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
284  		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
285  		{
286  			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
287  			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
288  			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
289  			{
290  				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
291  			}
292  			#endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
293  			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
294  									pxTaskDefinition->pcName,
295  									( uint32_t ) pxTaskDefinition->usStackDepth,
296  									pxTaskDefinition->pvParameters,
297  									pxTaskDefinition->uxPriority,
298  									pxCreatedTask, pxNewTCB,
299  									pxTaskDefinition->xRegions );
300  			prvAddNewTaskToReadyList( pxNewTCB );
301  			xReturn = pdPASS;
302  		}
303  		return xReturn;
304  	}
305  #endif &bsol;* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
306  #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
307  	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
308  	{
309  	TCB_t *pxNewTCB;
310  	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
311  		configASSERT( pxTaskDefinition->puxStackBuffer );
312  		if( pxTaskDefinition->puxStackBuffer != NULL )
313  		{
314  			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
315  			if( pxNewTCB != NULL )
316  			{
317  				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
318  				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
319  				{
320  					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
321  				}
322  				#endif
323  				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
324  										pxTaskDefinition->pcName,
325  										( uint32_t ) pxTaskDefinition->usStackDepth,
326  										pxTaskDefinition->pvParameters,
327  										pxTaskDefinition->uxPriority,
328  										pxCreatedTask, pxNewTCB,
329  										pxTaskDefinition->xRegions );
330  				prvAddNewTaskToReadyList( pxNewTCB );
331  				xReturn = pdPASS;
332  			}
333  		}
334  		return xReturn;
335  	}
336  #endif &bsol;* portUSING_MPU_WRAPPERS */
337  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
338  	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
339  							const char * const pcName,		&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
340  							const configSTACK_DEPTH_TYPE usStackDepth,
341  							void * const pvParameters,
342  							UBaseType_t uxPriority,
343  							TaskHandle_t * const pxCreatedTask )
344  	{
345  	TCB_t *pxNewTCB;
346  	BaseType_t xReturn;
347  		#if( portSTACK_GROWTH > 0 )
348  		{
349  			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
350  			if( pxNewTCB != NULL )
351  			{
352  				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
353  				if( pxNewTCB->pxStack == NULL )
354  				{
355  					vPortFree( pxNewTCB );
356  					pxNewTCB = NULL;
357  				}
358  			}
359  		}
360  		#else &bsol;* portSTACK_GROWTH */
361  		{
362  		StackType_t *pxStack;
363  			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
364  			if( pxStack != NULL )
365  			{
366  				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some paths. */
367  				if( pxNewTCB != NULL )
368  				{
369  					pxNewTCB->pxStack = pxStack;
370  				}
371  				else
372  				{
373  					vPortFree( pxStack );
374  				}
375  			}
376  			else
377  			{
378  				pxNewTCB = NULL;
379  			}
380  		}
381  		#endif &bsol;* portSTACK_GROWTH */
382  		if( pxNewTCB != NULL )
383  		{
384  			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &bsol;*lint !e731 Macro has been consolidated for readability reasons. */
385  			{
386  				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
387  			}
388  			#endif &bsol;* configSUPPORT_STATIC_ALLOCATION */
389  			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
390  			prvAddNewTaskToReadyList( pxNewTCB );
391  			xReturn = pdPASS;
392  		}
393  		else
394  		{
395  			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
396  		}
397  		return xReturn;
398  	}
399  #endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
400  static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
401  									const char * const pcName,		&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
402  									const uint32_t ulStackDepth,
403  									void * const pvParameters,
404  									UBaseType_t uxPriority,
405  									TaskHandle_t * const pxCreatedTask,
406  									TCB_t *pxNewTCB,
407  									const MemoryRegion_t * const xRegions )
408  {
409  StackType_t *pxTopOfStack;
410  UBaseType_t x;
411  	#if( portUSING_MPU_WRAPPERS == 1 )
412  		BaseType_t xRunPrivileged;
413  		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
414  		{
415  			xRunPrivileged = pdTRUE;
416  		}
417  		else
418  		{
419  			xRunPrivileged = pdFALSE;
420  		}
421  		uxPriority &= ~portPRIVILEGE_BIT;
422  	#endif &bsol;* portUSING_MPU_WRAPPERS == 1 */
423  	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
424  	{
425  		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
426  	}
427  	#endif &bsol;* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
428  	#if( portSTACK_GROWTH < 0 )
429  	{
430  		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
431  		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); &bsol;*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
432  		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
433  		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
434  		{
435  			pxNewTCB->pxEndOfStack = pxTopOfStack;
436  		}
437  		#endif &bsol;* configRECORD_STACK_HIGH_ADDRESS */
438  	}
439  	#else &bsol;* portSTACK_GROWTH */
440  	{
441  		pxTopOfStack = pxNewTCB->pxStack;
442  		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
443  		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
444  	}
445  	#endif &bsol;* portSTACK_GROWTH */
446  	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
447  	{
448  		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
449  		if( pcName[ x ] == 0x00 )
450  		{
451  			break;
452  		}
453  		else
454  		{
455  			mtCOVERAGE_TEST_MARKER();
456  		}
457  	}
458  	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
459  	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
460  	{
461  		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
462  	}
463  	else
464  	{
465  		mtCOVERAGE_TEST_MARKER();
466  	}
467  	pxNewTCB->uxPriority = uxPriority;
468  	#if ( configUSE_MUTEXES == 1 )
469  	{
470  		pxNewTCB->uxBasePriority = uxPriority;
471  		pxNewTCB->uxMutexesHeld = 0;
472  	}
473  	#endif &bsol;* configUSE_MUTEXES */
474  	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
475  	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
476  	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
477  	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
478  	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
479  	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
480  	{
481  		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
482  	}
483  	#endif &bsol;* portCRITICAL_NESTING_IN_TCB */
484  	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
485  	{
486  		pxNewTCB->pxTaskTag = NULL;
487  	}
488  	#endif &bsol;* configUSE_APPLICATION_TASK_TAG */
489  	#if ( configGENERATE_RUN_TIME_STATS == 1 )
490  	{
491  		pxNewTCB->ulRunTimeCounter = 0UL;
492  	}
493  	#endif &bsol;* configGENERATE_RUN_TIME_STATS */
494  	#if ( portUSING_MPU_WRAPPERS == 1 )
495  	{
496  		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
497  	}
498  	#else
499  	{
500  		( void ) xRegions;
501  	}
502  	#endif
503  	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
504  	{
505  		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
506  		{
507  			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
508  		}
509  	}
510  	#endif
511  	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
512  	{
513  		pxNewTCB->ulNotifiedValue = 0;
514  		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
515  	}
516  	#endif
517  	#if ( configUSE_NEWLIB_REENTRANT == 1 )
518  	{
519  		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
520  	}
521  	#endif
522  	#if( INCLUDE_xTaskAbortDelay == 1 )
523  	{
524  		pxNewTCB->ucDelayAborted = pdFALSE;
525  	}
526  	#endif
527  	#if( portUSING_MPU_WRAPPERS == 1 )
528  	{
529  		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
530  	}
531  	#else &bsol;* portUSING_MPU_WRAPPERS */
532  	{
533  		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
534  	}
535  	#endif &bsol;* portUSING_MPU_WRAPPERS */
536  	if( ( void * ) pxCreatedTask != NULL )
537  	{
538  		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
539  	}
540  	else
541  	{
542  		mtCOVERAGE_TEST_MARKER();
543  	}
544  }
545  static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
546  {
547  	taskENTER_CRITICAL();
548  	{
549  		uxCurrentNumberOfTasks++;
550  		if( pxCurrentTCB == NULL )
551  		{
552  			pxCurrentTCB = pxNewTCB;
553  			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
554  			{
555  				prvInitialiseTaskLists();
556  			}
557  			else
558  			{
559  				mtCOVERAGE_TEST_MARKER();
560  			}
561  		}
562  		else
563  		{
564  			if( xSchedulerRunning == pdFALSE )
565  			{
566  				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
567  				{
<span onclick='openModal()' class='match'>568  					pxCurrentTCB = pxNewTCB;
569  				}
570  				else
571  				{
572  					mtCOVERAGE_TEST_MARKER();
573  				}
574  			}
575  			else
576  			{
577  				mtCOVERAGE_TEST_MARKER();
</span>578  			}
579  		}
580  		uxTaskNumber++;
581  		#if ( configUSE_TRACE_FACILITY == 1 )
582  		{
583  			pxNewTCB->uxTCBNumber = uxTaskNumber;
584  		}
585  		#endif &bsol;* configUSE_TRACE_FACILITY */
586  		traceTASK_CREATE( pxNewTCB );
587  		prvAddTaskToReadyList( pxNewTCB );
588  		portSETUP_TCB( pxNewTCB );
589  	}
590  	taskEXIT_CRITICAL();
591  	if( xSchedulerRunning != pdFALSE )
592  	{
593  		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
594  		{
595  			taskYIELD_IF_USING_PREEMPTION();
596  		}
597  		else
598  		{
599  			mtCOVERAGE_TEST_MARKER();
600  		}
601  	}
602  	else
603  	{
604  		mtCOVERAGE_TEST_MARKER();
605  	}
606  }
607  #if ( INCLUDE_vTaskDelete == 1 )
608  	void vTaskDelete( TaskHandle_t xTaskToDelete )
609  	{
610  	TCB_t *pxTCB;
611  		taskENTER_CRITICAL();
612  		{
613  			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
614  			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
615  			{
616  				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
617  			}
618  			else
619  			{
620  				mtCOVERAGE_TEST_MARKER();
621  			}
622  			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
623  			{
624  				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
625  			}
626  			else
627  			{
628  				mtCOVERAGE_TEST_MARKER();
629  			}
630  			uxTaskNumber++;
631  			if( pxTCB == pxCurrentTCB )
632  			{
633  				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
634  				++uxDeletedTasksWaitingCleanUp;
635  				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
636  			}
637  			else
638  			{
639  				--uxCurrentNumberOfTasks;
640  				prvDeleteTCB( pxTCB );
641  				prvResetNextTaskUnblockTime();
642  			}
643  			traceTASK_DELETE( pxTCB );
644  		}
645  		taskEXIT_CRITICAL();
646  		if( xSchedulerRunning != pdFALSE )
647  		{
648  			if( pxTCB == pxCurrentTCB )
649  			{
650  				configASSERT( uxSchedulerSuspended == 0 );
651  				portYIELD_WITHIN_API();
652  			}
653  			else
654  			{
655  				mtCOVERAGE_TEST_MARKER();
656  			}
657  		}
658  	}
659  #endif &bsol;* INCLUDE_vTaskDelete */
660  #if ( INCLUDE_vTaskDelayUntil == 1 )
661  	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
662  	{
663  	TickType_t xTimeToWake;
664  	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
665  		configASSERT( pxPreviousWakeTime );
666  		configASSERT( ( xTimeIncrement > 0U ) );
667  		configASSERT( uxSchedulerSuspended == 0 );
668  		vTaskSuspendAll();
669  		{
670  			const TickType_t xConstTickCount = xTickCount;
671  			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
672  			if( xConstTickCount < *pxPreviousWakeTime )
673  			{
674  				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
675  				{
676  					xShouldDelay = pdTRUE;
677  				}
678  				else
679  				{
680  					mtCOVERAGE_TEST_MARKER();
681  				}
682  			}
683  			else
684  			{
685  				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
686  				{
687  					xShouldDelay = pdTRUE;
688  				}
689  				else
690  				{
691  					mtCOVERAGE_TEST_MARKER();
692  				}
693  			}
694  			*pxPreviousWakeTime = xTimeToWake;
695  			if( xShouldDelay != pdFALSE )
696  			{
697  				traceTASK_DELAY_UNTIL( xTimeToWake );
698  				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
699  			}
700  			else
701  			{
702  				mtCOVERAGE_TEST_MARKER();
703  			}
704  		}
705  		xAlreadyYielded = xTaskResumeAll();
706  		if( xAlreadyYielded == pdFALSE )
707  		{
708  			portYIELD_WITHIN_API();
709  		}
710  		else
711  		{
712  			mtCOVERAGE_TEST_MARKER();
713  		}
714  	}
715  #endif &bsol;* INCLUDE_vTaskDelayUntil */
716  #if ( INCLUDE_vTaskDelay == 1 )
717  	void vTaskDelay( const TickType_t xTicksToDelay )
718  	{
719  	BaseType_t xAlreadyYielded = pdFALSE;
720  		if( xTicksToDelay > ( TickType_t ) 0U )
721  		{
722  			configASSERT( uxSchedulerSuspended == 0 );
723  			vTaskSuspendAll();
724  			{
725  				traceTASK_DELAY();
726  				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
727  			}
728  			xAlreadyYielded = xTaskResumeAll();
729  		}
730  		else
731  		{
732  			mtCOVERAGE_TEST_MARKER();
733  		}
734  		if( xAlreadyYielded == pdFALSE )
735  		{
736  			portYIELD_WITHIN_API();
737  		}
738  		else
739  		{
740  			mtCOVERAGE_TEST_MARKER();
741  		}
742  	}
743  #endif &bsol;* INCLUDE_vTaskDelay */
744  #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
745  	eTaskState eTaskGetState( TaskHandle_t xTask )
746  	{
747  	eTaskState eReturn;
748  	List_t *pxStateList;
749  	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
750  		configASSERT( pxTCB );
751  		if( pxTCB == pxCurrentTCB )
752  		{
753  			eReturn = eRunning;
754  		}
755  		else
756  		{
757  			taskENTER_CRITICAL();
758  			{
759  				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
760  			}
761  			taskEXIT_CRITICAL();
762  			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
763  			{
764  				eReturn = eBlocked;
765  			}
766  			#if ( INCLUDE_vTaskSuspend == 1 )
767  				else if( pxStateList == &xSuspendedTaskList )
768  				{
769  					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
770  					{
771  						eReturn = eSuspended;
772  					}
773  					else
774  					{
775  						eReturn = eBlocked;
776  					}
777  				}
778  			#endif
779  			#if ( INCLUDE_vTaskDelete == 1 )
780  				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
781  				{
782  					eReturn = eDeleted;
783  				}
784  			#endif
785  			else &bsol;*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
786  			{
787  				eReturn = eReady;
788  			}
789  		}
790  		return eReturn;
791  	} &bsol;*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
792  #endif &bsol;* INCLUDE_eTaskGetState */
793  #if ( INCLUDE_uxTaskPriorityGet == 1 )
794  	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
795  	{
796  	TCB_t *pxTCB;
797  	UBaseType_t uxReturn;
798  		taskENTER_CRITICAL();
799  		{
800  			pxTCB = prvGetTCBFromHandle( xTask );
801  			uxReturn = pxTCB->uxPriority;
802  		}
803  		taskEXIT_CRITICAL();
804  		return uxReturn;
805  	}
806  #endif &bsol;* INCLUDE_uxTaskPriorityGet */
807  #if ( INCLUDE_uxTaskPriorityGet == 1 )
808  	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
809  	{
810  	TCB_t *pxTCB;
811  	UBaseType_t uxReturn, uxSavedInterruptState;
812  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
813  		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
814  		{
815  			pxTCB = prvGetTCBFromHandle( xTask );
816  			uxReturn = pxTCB->uxPriority;
817  		}
818  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
819  		return uxReturn;
820  	}
821  #endif &bsol;* INCLUDE_uxTaskPriorityGet */
822  #if ( INCLUDE_vTaskPrioritySet == 1 )
823  	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
824  	{
825  	TCB_t *pxTCB;
826  	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
827  	BaseType_t xYieldRequired = pdFALSE;
828  		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
829  		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
830  		{
831  			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
832  		}
833  		else
834  		{
835  			mtCOVERAGE_TEST_MARKER();
836  		}
837  		taskENTER_CRITICAL();
838  		{
839  			pxTCB = prvGetTCBFromHandle( xTask );
840  			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
841  			#if ( configUSE_MUTEXES == 1 )
842  			{
843  				uxCurrentBasePriority = pxTCB->uxBasePriority;
844  			}
845  			#else
846  			{
847  				uxCurrentBasePriority = pxTCB->uxPriority;
848  			}
849  			#endif
850  			if( uxCurrentBasePriority != uxNewPriority )
851  			{
852  				if( uxNewPriority > uxCurrentBasePriority )
853  				{
854  					if( pxTCB != pxCurrentTCB )
855  					{
856  						if( uxNewPriority >= pxCurrentTCB->uxPriority )
857  						{
858  							xYieldRequired = pdTRUE;
859  						}
860  						else
861  						{
862  							mtCOVERAGE_TEST_MARKER();
863  						}
864  					}
865  					else
866  					{
867  					}
868  				}
869  				else if( pxTCB == pxCurrentTCB )
870  				{
871  					xYieldRequired = pdTRUE;
872  				}
873  				else
874  				{
875  				}
876  				uxPriorityUsedOnEntry = pxTCB->uxPriority;
877  				#if ( configUSE_MUTEXES == 1 )
878  				{
879  					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
880  					{
881  						pxTCB->uxPriority = uxNewPriority;
882  					}
883  					else
884  					{
885  						mtCOVERAGE_TEST_MARKER();
886  					}
887  					pxTCB->uxBasePriority = uxNewPriority;
888  				}
889  				#else
890  				{
891  					pxTCB->uxPriority = uxNewPriority;
892  				}
893  				#endif
894  				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
895  				{
896  					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
897  				}
898  				else
899  				{
900  					mtCOVERAGE_TEST_MARKER();
901  				}
902  				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
903  				{
904  					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
905  					{
906  						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
907  					}
908  					else
909  					{
910  						mtCOVERAGE_TEST_MARKER();
911  					}
912  					prvReaddTaskToReadyList( pxTCB );
913  				}
914  				else
915  				{
916  					mtCOVERAGE_TEST_MARKER();
917  				}
918  				if( xYieldRequired != pdFALSE )
919  				{
920  					taskYIELD_IF_USING_PREEMPTION();
921  				}
922  				else
923  				{
924  					mtCOVERAGE_TEST_MARKER();
925  				}
926  				( void ) uxPriorityUsedOnEntry;
927  			}
928  		}
929  		taskEXIT_CRITICAL();
930  	}
931  #endif &bsol;* INCLUDE_vTaskPrioritySet */
932  #if ( INCLUDE_vTaskSuspend == 1 )
933  	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
934  	{
935  	TCB_t *pxTCB;
936  		taskENTER_CRITICAL();
937  		{
938  			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
939  			traceTASK_SUSPEND( pxTCB );
940  			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
941  			{
942  				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
943  			}
944  			else
945  			{
946  				mtCOVERAGE_TEST_MARKER();
947  			}
948  			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
949  			{
950  				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
951  			}
952  			else
953  			{
954  				mtCOVERAGE_TEST_MARKER();
955  			}
956  			traceMOVED_TASK_TO_SUSPENDED_LIST(pxTCB);
957  			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
958  			#if( configUSE_TASK_NOTIFICATIONS == 1 )
959  			{
960  				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
961  				{
962  					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
963  				}
964  			}
965  			#endif
966  		}
967  		taskEXIT_CRITICAL();
968  		if( xSchedulerRunning != pdFALSE )
969  		{
970  			taskENTER_CRITICAL();
971  			{
972  				prvResetNextTaskUnblockTime();
973  			}
974  			taskEXIT_CRITICAL();
975  		}
976  		else
977  		{
978  			mtCOVERAGE_TEST_MARKER();
979  		}
980  		if( pxTCB == pxCurrentTCB )
981  		{
982  			if( xSchedulerRunning != pdFALSE )
983  			{
984  				configASSERT( uxSchedulerSuspended == 0 );
985  				portYIELD_WITHIN_API();
986  			}
987  			else
988  			{
989  				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
990  				{
991  					pxCurrentTCB = NULL;
992  				}
993  				else
994  				{
995  					vTaskSwitchContext();
996  				}
997  			}
998  		}
999  		else
1000  		{
1001  			mtCOVERAGE_TEST_MARKER();
1002  		}
1003  	}
1004  #endif &bsol;* INCLUDE_vTaskSuspend */
1005  #if ( INCLUDE_vTaskSuspend == 1 )
1006  	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1007  	{
1008  	BaseType_t xReturn = pdFALSE;
1009  	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1010  		configASSERT( xTask );
1011  		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1012  		{
1013  			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1014  			{
1015  				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) &bsol;*lint !e961.  The cast is only redundant when NULL is used. */
1016  				{
1017  					xReturn = pdTRUE;
1018  				}
1019  				else
1020  				{
1021  					mtCOVERAGE_TEST_MARKER();
1022  				}
1023  			}
1024  			else
1025  			{
1026  				mtCOVERAGE_TEST_MARKER();
1027  			}
1028  		}
1029  		else
1030  		{
1031  			mtCOVERAGE_TEST_MARKER();
1032  		}
1033  		return xReturn;
1034  	} &bsol;*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1035  #endif &bsol;* INCLUDE_vTaskSuspend */
1036  #if ( INCLUDE_vTaskSuspend == 1 )
1037  	void vTaskResume( TaskHandle_t xTaskToResume )
1038  	{
1039  	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1040  		configASSERT( xTaskToResume );
1041  		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1042  		{
1043  			taskENTER_CRITICAL();
1044  			{
1045  				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1046  				{
1047  					traceTASK_RESUME( pxTCB );
1048  					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1049  					prvAddTaskToReadyList( pxTCB );
1050  					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1051  					{
1052  						taskYIELD_IF_USING_PREEMPTION();
1053  					}
1054  					else
1055  					{
1056  						mtCOVERAGE_TEST_MARKER();
1057  					}
1058  				}
1059  				else
1060  				{
1061  					mtCOVERAGE_TEST_MARKER();
1062  				}
1063  			}
1064  			taskEXIT_CRITICAL();
1065  		}
1066  		else
1067  		{
1068  			mtCOVERAGE_TEST_MARKER();
1069  		}
1070  	}
1071  #endif &bsol;* INCLUDE_vTaskSuspend */
1072  #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1073  	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1074  	{
1075  	BaseType_t xYieldRequired = pdFALSE;
1076  	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1077  	UBaseType_t uxSavedInterruptStatus;
1078  		configASSERT( xTaskToResume );
1079  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1080  		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1081  		{
1082  			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1083  			{
1084  				traceTASK_RESUME_FROM_ISR( pxTCB );
1085  				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1086  				{
1087  					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1088  					{
1089  						xYieldRequired = pdTRUE;
1090  					}
1091  					else
1092  					{
1093  						mtCOVERAGE_TEST_MARKER();
1094  					}
1095  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1096  					prvAddTaskToReadyList( pxTCB );
1097  				}
1098  				else
1099  				{
1100  					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1101  				}
1102  			}
1103  			else
1104  			{
1105  				mtCOVERAGE_TEST_MARKER();
1106  			}
1107  		}
1108  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1109  		return xYieldRequired;
1110  	}
1111  #endif &bsol;* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1112  void vTaskStartScheduler( void )
1113  {
1114  BaseType_t xReturn;
1115  	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1116  	{
1117  		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1118  		StackType_t *pxIdleTaskStackBuffer = NULL;
1119  		uint32_t ulIdleTaskStackSize;
1120  		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
1121  		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1122  												configIDLE_TASK_NAME,
1123  												ulIdleTaskStackSize,
1124  												( void * ) NULL, &bsol;*lint !e961.  The cast is not redundant for all compilers. */
1125  												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1126  												pxIdleTaskStackBuffer,
1127  												pxIdleTaskTCBBuffer ); &bsol;*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1128  		if( xIdleTaskHandle != NULL )
1129  		{
1130  			xReturn = pdPASS;
1131  		}
1132  		else
1133  		{
1134  			xReturn = pdFAIL;
1135  		}
1136  	}
1137  	#else
1138  	{
1139  		xReturn = xTaskCreate(	prvIdleTask,
1140  								configIDLE_TASK_NAME,
1141  								configMINIMAL_STACK_SIZE,
1142  								( void * ) NULL,
1143  								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1144  								&xIdleTaskHandle ); &bsol;*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1145  	}
1146  	#endif &bsol;* configSUPPORT_STATIC_ALLOCATION */
1147  	#if ( configUSE_TIMERS == 1 )
1148  	{
1149  		if( xReturn == pdPASS )
1150  		{
1151  			xReturn = xTimerCreateTimerTask();
1152  		}
1153  		else
1154  		{
1155  			mtCOVERAGE_TEST_MARKER();
1156  		}
1157  	}
1158  	#endif &bsol;* configUSE_TIMERS */
1159  	if( xReturn == pdPASS )
1160  	{
1161  		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
1162  		{
1163  			freertos_tasks_c_additions_init();
1164  		}
1165  		#endif
1166  		portDISABLE_INTERRUPTS();
1167  		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1168  		{
1169  			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1170  		}
1171  		#endif &bsol;* configUSE_NEWLIB_REENTRANT */
1172  		xNextTaskUnblockTime = portMAX_DELAY;
1173  		xSchedulerRunning = pdTRUE;
1174  		xTickCount = ( TickType_t ) 0U;
1175  		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1176  		if( xPortStartScheduler() != pdFALSE )
1177  		{
1178  		}
1179  		else
1180  		{
1181  		}
1182  	}
1183  	else
1184  	{
1185  		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
1186  	}
1187  	( void ) xIdleTaskHandle;
1188  }
1189  void vTaskEndScheduler( void )
1190  {
1191  	portDISABLE_INTERRUPTS();
1192  	xSchedulerRunning = pdFALSE;
1193  	vPortEndScheduler();
1194  }
1195  void vTaskSuspendAll( void )
1196  {
1197  	++uxSchedulerSuspended;
1198  }
1199  #if ( configUSE_TICKLESS_IDLE != 0 )
1200  	static TickType_t prvGetExpectedIdleTime( void )
1201  	{
1202  	TickType_t xReturn;
1203  	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1204  		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1205  		{
1206  			if( uxTopReadyPriority > tskIDLE_PRIORITY )
1207  			{
1208  				uxHigherPriorityReadyTasks = pdTRUE;
1209  			}
1210  		}
1211  		#else
1212  		{
1213  			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1214  			if( uxTopReadyPriority > uxLeastSignificantBit )
1215  			{
1216  				uxHigherPriorityReadyTasks = pdTRUE;
1217  			}
1218  		}
1219  		#endif
1220  		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1221  		{
1222  			xReturn = 0;
1223  		}
1224  		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1225  		{
1226  			xReturn = 0;
1227  		}
1228  		else if( uxHigherPriorityReadyTasks != pdFALSE )
1229  		{
1230  			xReturn = 0;
1231  		}
1232  		else
1233  		{
1234  			xReturn = xNextTaskUnblockTime - xTickCount;
1235  		}
1236  		return xReturn;
1237  	}
1238  #endif &bsol;* configUSE_TICKLESS_IDLE */
1239  BaseType_t xTaskResumeAll( void )
1240  {
1241  TCB_t *pxTCB = NULL;
1242  BaseType_t xAlreadyYielded = pdFALSE;
1243  	configASSERT( uxSchedulerSuspended );
1244  	taskENTER_CRITICAL();
1245  	{
1246  		--uxSchedulerSuspended;
1247  		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1248  		{
1249  			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
1250  			{
1251  				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
1252  				{
1253  					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
1254  					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1255  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1256  					prvAddTaskToReadyList( pxTCB );
1257  					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1258  					{
1259  						xYieldPending = pdTRUE;
1260  					}
1261  					else
1262  					{
1263  						mtCOVERAGE_TEST_MARKER();
1264  					}
1265  				}
1266  				if( pxTCB != NULL )
1267  				{
1268  					prvResetNextTaskUnblockTime();
1269  				}
1270  				{
1271  					UBaseType_t uxPendedCounts = uxPendedTicks; &bsol;* Non-volatile copy. */
1272  					if( uxPendedCounts > ( UBaseType_t ) 0U )
1273  					{
1274  						do
1275  						{
1276  							if( xTaskIncrementTick() != pdFALSE )
1277  							{
1278  								xYieldPending = pdTRUE;
1279  							}
1280  							else
1281  							{
1282  								mtCOVERAGE_TEST_MARKER();
1283  							}
1284  							--uxPendedCounts;
1285  						} while( uxPendedCounts > ( UBaseType_t ) 0U );
1286  						uxPendedTicks = 0;
1287  					}
1288  					else
1289  					{
1290  						mtCOVERAGE_TEST_MARKER();
1291  					}
1292  				}
1293  				if( xYieldPending != pdFALSE )
1294  				{
1295  					#if( configUSE_PREEMPTION != 0 )
1296  					{
1297  						xAlreadyYielded = pdTRUE;
1298  					}
1299  					#endif
1300  					taskYIELD_IF_USING_PREEMPTION();
1301  				}
1302  				else
1303  				{
1304  					mtCOVERAGE_TEST_MARKER();
1305  				}
1306  			}
1307  		}
1308  		else
1309  		{
1310  			mtCOVERAGE_TEST_MARKER();
1311  		}
1312  	}
1313  	taskEXIT_CRITICAL();
1314  	return xAlreadyYielded;
1315  }
1316  TickType_t xTaskGetTickCount( void )
1317  {
1318  TickType_t xTicks;
1319  	portTICK_TYPE_ENTER_CRITICAL();
1320  	{
1321  		xTicks = xTickCount;
1322  	}
1323  	portTICK_TYPE_EXIT_CRITICAL();
1324  	return xTicks;
1325  }
1326  TickType_t xTaskGetTickCountFromISR( void )
1327  {
1328  TickType_t xReturn;
1329  UBaseType_t uxSavedInterruptStatus;
1330  	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1331  	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
1332  	{
1333  		xReturn = xTickCount;
1334  	}
1335  	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1336  	return xReturn;
1337  }
1338  UBaseType_t uxTaskGetNumberOfTasks( void )
1339  {
1340  	return uxCurrentNumberOfTasks;
1341  }
1342  char *pcTaskGetName( TaskHandle_t xTaskToQuery ) &bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
1343  {
1344  TCB_t *pxTCB;
1345  	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1346  	configASSERT( pxTCB );
1347  	return &( pxTCB->pcTaskName[ 0 ] );
1348  }
1349  #if ( INCLUDE_xTaskGetHandle == 1 )
1350  	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
1351  	{
1352  	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
1353  	UBaseType_t x;
1354  	char cNextChar;
1355  		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
1356  		{
1357  			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
1358  			do
1359  			{
1360  				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
1361  				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
1362  				{
1363  					cNextChar = pxNextTCB->pcTaskName[ x ];
1364  					if( cNextChar != pcNameToQuery[ x ] )
1365  					{
1366  						break;
1367  					}
1368  					else if( cNextChar == 0x00 )
1369  					{
1370  						pxReturn = pxNextTCB;
1371  						break;
1372  					}
1373  					else
1374  					{
1375  						mtCOVERAGE_TEST_MARKER();
1376  					}
1377  				}
1378  				if( pxReturn != NULL )
1379  				{
1380  					break;
1381  				}
1382  			} while( pxNextTCB != pxFirstTCB );
1383  		}
1384  		else
1385  		{
1386  			mtCOVERAGE_TEST_MARKER();
1387  		}
1388  		return pxReturn;
1389  	}
1390  #endif &bsol;* INCLUDE_xTaskGetHandle */
1391  #if ( INCLUDE_xTaskGetHandle == 1 )
1392  	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) &bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
1393  	{
1394  	UBaseType_t uxQueue = configMAX_PRIORITIES;
1395  	TCB_t* pxTCB;
1396  		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
1397  		vTaskSuspendAll();
1398  		{
1399  			do
1400  			{
1401  				uxQueue--;
1402  				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
1403  				if( pxTCB != NULL )
1404  				{
1405  					break;
1406  				}
1407  			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1408  			if( pxTCB == NULL )
1409  			{
1410  				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
1411  			}
1412  			if( pxTCB == NULL )
1413  			{
1414  				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
1415  			}
1416  			#if ( INCLUDE_vTaskSuspend == 1 )
1417  			{
1418  				if( pxTCB == NULL )
1419  				{
1420  					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
1421  				}
1422  			}
1423  			#endif
1424  			#if( INCLUDE_vTaskDelete == 1 )
1425  			{
1426  				if( pxTCB == NULL )
1427  				{
1428  					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
1429  				}
1430  			}
1431  			#endif
1432  		}
1433  		( void ) xTaskResumeAll();
1434  		return ( TaskHandle_t ) pxTCB;
1435  	}
1436  #endif &bsol;* INCLUDE_xTaskGetHandle */
1437  #if ( configUSE_TRACE_FACILITY == 1 )
1438  	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
1439  	{
1440  	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1441  		vTaskSuspendAll();
1442  		{
1443  			if( uxArraySize >= uxCurrentNumberOfTasks )
1444  			{
1445  				do
1446  				{
1447  					uxQueue--;
1448  					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
1449  				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1450  				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
1451  				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
1452  				#if( INCLUDE_vTaskDelete == 1 )
1453  				{
1454  					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
1455  				}
1456  				#endif
1457  				#if ( INCLUDE_vTaskSuspend == 1 )
1458  				{
1459  					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
1460  				}
1461  				#endif
1462  				#if ( configGENERATE_RUN_TIME_STATS == 1)
1463  				{
1464  					if( pulTotalRunTime != NULL )
1465  					{
1466  						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1467  							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1468  						#else
1469  							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1470  						#endif
1471  					}
1472  				}
1473  				#else
1474  				{
1475  					if( pulTotalRunTime != NULL )
1476  					{
1477  						*pulTotalRunTime = 0;
1478  					}
1479  				}
1480  				#endif
1481  			}
1482  			else
1483  			{
1484  				mtCOVERAGE_TEST_MARKER();
1485  			}
1486  		}
1487  		( void ) xTaskResumeAll();
1488  		return uxTask;
1489  	}
1490  #endif &bsol;* configUSE_TRACE_FACILITY */
1491  #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1492  	TaskHandle_t xTaskGetIdleTaskHandle( void )
1493  	{
1494  		configASSERT( ( xIdleTaskHandle != NULL ) );
1495  		return xIdleTaskHandle;
1496  	}
1497  #endif &bsol;* INCLUDE_xTaskGetIdleTaskHandle */
1498  #if ( configUSE_TICKLESS_IDLE != 0 )
1499  	void vTaskStepTick( const TickType_t xTicksToJump )
1500  	{
1501  		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1502  		xTickCount += xTicksToJump;
1503  		traceINCREASE_TICK_COUNT( xTicksToJump );
1504  	}
1505  #endif &bsol;* configUSE_TICKLESS_IDLE */
1506  #if ( INCLUDE_xTaskAbortDelay == 1 )
1507  	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
1508  	{
1509  	TCB_t *pxTCB = ( TCB_t * ) xTask;
1510  	BaseType_t xReturn;
1511  		configASSERT( pxTCB );
1512  		vTaskSuspendAll();
1513  		{
1514  			if( eTaskGetState( xTask ) == eBlocked )
1515  			{
1516  				xReturn = pdPASS;
1517  				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1518  				taskENTER_CRITICAL();
1519  				{
1520  					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1521  					{
1522  						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1523  						pxTCB->ucDelayAborted = pdTRUE;
1524  					}
1525  					else
1526  					{
1527  						mtCOVERAGE_TEST_MARKER();
1528  					}
1529  				}
1530  				taskEXIT_CRITICAL();
1531  				prvAddTaskToReadyList( pxTCB );
1532  				#if (  configUSE_PREEMPTION == 1 )
1533  				{
1534  					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
1535  					{
1536  						xYieldPending = pdTRUE;
1537  					}
1538  					else
1539  					{
1540  						mtCOVERAGE_TEST_MARKER();
1541  					}
1542  				}
1543  				#endif &bsol;* configUSE_PREEMPTION */
1544  			}
1545  			else
1546  			{
1547  				xReturn = pdFAIL;
1548  			}
1549  		}
1550  		( void ) xTaskResumeAll();
1551  		return xReturn;
1552  	}
1553  #endif &bsol;* INCLUDE_xTaskAbortDelay */
1554  BaseType_t xTaskIncrementTick( void )
1555  {
1556  TCB_t * pxTCB;
1557  TickType_t xItemValue;
1558  BaseType_t xSwitchRequired = pdFALSE;
1559  	traceTASK_INCREMENT_TICK( xTickCount );
1560  	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1561  	{
1562  		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
1563  		xTickCount = xConstTickCount;
1564  		if( xConstTickCount == ( TickType_t ) 0U ) &bsol;*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
1565  		{
1566  			taskSWITCH_DELAYED_LISTS();
1567  		}
1568  		else
1569  		{
1570  			mtCOVERAGE_TEST_MARKER();
1571  		}
1572  		if( xConstTickCount >= xNextTaskUnblockTime )
1573  		{
1574  			for( ;; )
1575  			{
1576  				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1577  				{
1578  					xNextTaskUnblockTime = portMAX_DELAY; &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1579  					break;
1580  				}
1581  				else
1582  				{
1583  					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1584  					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
1585  					if( xConstTickCount < xItemValue )
1586  					{
1587  						xNextTaskUnblockTime = xItemValue;
1588  						break;
1589  					}
1590  					else
1591  					{
1592  						mtCOVERAGE_TEST_MARKER();
1593  					}
1594  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1595  					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1596  					{
1597  						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1598  					}
1599  					else
1600  					{
1601  						mtCOVERAGE_TEST_MARKER();
1602  					}
1603  					prvAddTaskToReadyList( pxTCB );
1604  					#if (  configUSE_PREEMPTION == 1 )
1605  					{
1606  						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1607  						{
1608  							xSwitchRequired = pdTRUE;
1609  						}
1610  						else
1611  						{
1612  							mtCOVERAGE_TEST_MARKER();
1613  						}
1614  					}
1615  					#endif &bsol;* configUSE_PREEMPTION */
1616  				}
1617  			}
1618  		}
1619  		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1620  		{
1621  			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
1622  			{
1623  				xSwitchRequired = pdTRUE;
1624  			}
1625  			else
1626  			{
1627  				mtCOVERAGE_TEST_MARKER();
1628  			}
1629  		}
1630  		#endif &bsol;* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1631  		#if ( configUSE_TICK_HOOK == 1 )
1632  		{
1633  			if( uxPendedTicks == ( UBaseType_t ) 0U )
1634  			{
1635  				vApplicationTickHook();
1636  			}
1637  			else
1638  			{
1639  				mtCOVERAGE_TEST_MARKER();
1640  			}
1641  		}
1642  		#endif &bsol;* configUSE_TICK_HOOK */
1643  	}
1644  	else
1645  	{
1646  		++uxPendedTicks;
1647  		#if ( configUSE_TICK_HOOK == 1 )
1648  		{
1649  			vApplicationTickHook();
1650  		}
1651  		#endif
1652  	}
1653  	#if ( configUSE_PREEMPTION == 1 )
1654  	{
1655  		if( xYieldPending != pdFALSE )
1656  		{
1657  			xSwitchRequired = pdTRUE;
1658  		}
1659  		else
1660  		{
1661  			mtCOVERAGE_TEST_MARKER();
1662  		}
1663  	}
1664  	#endif &bsol;* configUSE_PREEMPTION */
1665  	return xSwitchRequired;
1666  }
1667  #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1668  	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
1669  	{
1670  	TCB_t *xTCB;
1671  		if( xTask == NULL )
1672  		{
1673  			xTCB = ( TCB_t * ) pxCurrentTCB;
1674  		}
1675  		else
1676  		{
1677  			xTCB = ( TCB_t * ) xTask;
1678  		}
1679  		taskENTER_CRITICAL();
1680  			xTCB->pxTaskTag = pxHookFunction;
1681  		taskEXIT_CRITICAL();
1682  	}
1683  #endif &bsol;* configUSE_APPLICATION_TASK_TAG */
1684  #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1685  	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
1686  	{
1687  	TCB_t *xTCB;
1688  	TaskHookFunction_t xReturn;
1689  		if( xTask == NULL )
1690  		{
1691  			xTCB = ( TCB_t * ) pxCurrentTCB;
1692  		}
1693  		else
1694  		{
1695  			xTCB = ( TCB_t * ) xTask;
1696  		}
1697  		taskENTER_CRITICAL();
1698  		{
1699  			xReturn = xTCB->pxTaskTag;
1700  		}
1701  		taskEXIT_CRITICAL();
1702  		return xReturn;
1703  	}
1704  #endif &bsol;* configUSE_APPLICATION_TASK_TAG */
1705  #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1706  	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
1707  	{
1708  	TCB_t *xTCB;
1709  	BaseType_t xReturn;
1710  		if( xTask == NULL )
1711  		{
1712  			xTCB = ( TCB_t * ) pxCurrentTCB;
1713  		}
1714  		else
1715  		{
1716  			xTCB = ( TCB_t * ) xTask;
1717  		}
1718  		if( xTCB->pxTaskTag != NULL )
1719  		{
1720  			xReturn = xTCB->pxTaskTag( pvParameter );
1721  		}
1722  		else
1723  		{
1724  			xReturn = pdFAIL;
1725  		}
1726  		return xReturn;
1727  	}
1728  #endif &bsol;* configUSE_APPLICATION_TASK_TAG */
1729  void vTaskSwitchContext( void )
1730  {
1731  	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
1732  	{
1733  		xYieldPending = pdTRUE;
1734  	}
1735  	else
1736  	{
1737  		xYieldPending = pdFALSE;
1738  		traceTASK_SWITCHED_OUT();
1739  		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1740  		{
1741  				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1742  					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1743  				#else
1744  					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1745  				#endif
1746  				if( ulTotalRunTime > ulTaskSwitchedInTime )
1747  				{
1748  					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
1749  				}
1750  				else
1751  				{
1752  					mtCOVERAGE_TEST_MARKER();
1753  				}
1754  				ulTaskSwitchedInTime = ulTotalRunTime;
1755  		}
1756  		#endif &bsol;* configGENERATE_RUN_TIME_STATS */
1757  		taskCHECK_FOR_STACK_OVERFLOW();
1758  		taskSELECT_HIGHEST_PRIORITY_TASK();
1759  		traceTASK_SWITCHED_IN();
1760  		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1761  		{
1762  			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1763  		}
1764  		#endif &bsol;* configUSE_NEWLIB_REENTRANT */
1765  	}
1766  }
1767  void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
1768  {
1769  	configASSERT( pxEventList );
1770  	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1771  	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
1772  }
1773  void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
1774  {
1775  	configASSERT( pxEventList );
1776  	configASSERT( uxSchedulerSuspended != 0 );
1777  	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
1778  	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1779  	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
1780  }
1781  #if( configUSE_TIMERS == 1 )
1782  	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
1783  	{
1784  		configASSERT( pxEventList );
1785  		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1786  		if( xWaitIndefinitely != pdFALSE )
1787  		{
1788  			xTicksToWait = portMAX_DELAY;
1789  		}
1790  		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
1791  		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
1792  	}
1793  #endif &bsol;* configUSE_TIMERS */
1794  BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
1795  {
1796  TCB_t *pxUnblockedTCB;
1797  BaseType_t xReturn;
1798  	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1799  	configASSERT( pxUnblockedTCB );
1800  	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
1801  	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1802  	{
1803  		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
1804  		prvAddTaskToReadyList( pxUnblockedTCB );
1805  	}
1806  	else
1807  	{
1808  		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1809  	}
1810  	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
1811  	{
1812  		xReturn = pdTRUE;
1813  		xYieldPending = pdTRUE;
1814  	}
1815  	else
1816  	{
1817  		xReturn = pdFALSE;
1818  	}
1819  	#if( configUSE_TICKLESS_IDLE != 0 )
1820  	{
1821  		prvResetNextTaskUnblockTime();
1822  	}
1823  	#endif
1824  	return xReturn;
1825  }
1826  void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
1827  {
1828  TCB_t *pxUnblockedTCB;
1829  	configASSERT( uxSchedulerSuspended != pdFALSE );
1830  	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
1831  	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
1832  	configASSERT( pxUnblockedTCB );
1833  	( void ) uxListRemove( pxEventListItem );
1834  	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
1835  	prvAddTaskToReadyList( pxUnblockedTCB );
1836  	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
1837  	{
1838  		xYieldPending = pdTRUE;
1839  	}
1840  }
1841  void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
1842  {
1843  	configASSERT( pxTimeOut );
1844  	taskENTER_CRITICAL();
1845  	{
1846  		pxTimeOut->xOverflowCount = xNumOfOverflows;
1847  		pxTimeOut->xTimeOnEntering = xTickCount;
1848  	}
1849  	taskEXIT_CRITICAL();
1850  }
1851  void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
1852  {
1853  	pxTimeOut->xOverflowCount = xNumOfOverflows;
1854  	pxTimeOut->xTimeOnEntering = xTickCount;
1855  }
1856  BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
1857  {
1858  BaseType_t xReturn;
1859  	configASSERT( pxTimeOut );
1860  	configASSERT( pxTicksToWait );
1861  	taskENTER_CRITICAL();
1862  	{
1863  		const TickType_t xConstTickCount = xTickCount;
1864  		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
1865  		#if( INCLUDE_xTaskAbortDelay == 1 )
1866  			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
1867  			{
1868  				pxCurrentTCB->ucDelayAborted = pdFALSE;
1869  				xReturn = pdTRUE;
1870  			}
1871  			else
1872  		#endif
1873  		#if ( INCLUDE_vTaskSuspend == 1 )
1874  			if( *pxTicksToWait == portMAX_DELAY )
1875  			{
1876  				xReturn = pdFALSE;
1877  			}
1878  			else
1879  		#endif
1880  		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) &bsol;*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
1881  		{
1882  			xReturn = pdTRUE;
1883  		}
1884  		else if( xElapsedTime < *pxTicksToWait ) &bsol;*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
1885  		{
1886  			*pxTicksToWait -= xElapsedTime;
1887  			vTaskInternalSetTimeOutState( pxTimeOut );
1888  			xReturn = pdFALSE;
1889  		}
1890  		else
1891  		{
1892  			*pxTicksToWait = 0;
1893  			xReturn = pdTRUE;
1894  		}
1895  	}
1896  	taskEXIT_CRITICAL();
1897  	return xReturn;
1898  }
1899  void vTaskMissedYield( void )
1900  {
1901  	xYieldPending = pdTRUE;
1902  }
1903  #if ( configUSE_TRACE_FACILITY == 1 )
1904  	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
1905  	{
1906  	UBaseType_t uxReturn;
1907  	TCB_t *pxTCB;
1908  		if( xTask != NULL )
1909  		{
1910  			pxTCB = ( TCB_t * ) xTask;
1911  			uxReturn = pxTCB->uxTaskNumber;
1912  		}
1913  		else
1914  		{
1915  			uxReturn = 0U;
1916  		}
1917  		return uxReturn;
1918  	}
1919  #endif &bsol;* configUSE_TRACE_FACILITY */
1920  #if ( configUSE_TRACE_FACILITY == 1 )
1921  	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
1922  	{
1923  	TCB_t *pxTCB;
1924  		if( xTask != NULL )
1925  		{
1926  			pxTCB = ( TCB_t * ) xTask;
1927  			pxTCB->uxTaskNumber = uxHandle;
1928  		}
1929  	}
1930  #endif &bsol;* configUSE_TRACE_FACILITY */
1931  static portTASK_FUNCTION( prvIdleTask, pvParameters )
1932  {
1933  	( void ) pvParameters;
1934  	portTASK_CALLS_SECURE_FUNCTIONS();
1935  	for( ;; )
1936  	{
1937  		prvCheckTasksWaitingTermination();
1938  		#if ( configUSE_PREEMPTION == 0 )
1939  		{
1940  			taskYIELD();
1941  		}
1942  		#endif &bsol;* configUSE_PREEMPTION */
1943  		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1944  		{
1945  			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
1946  			{
1947  				taskYIELD();
1948  			}
1949  			else
1950  			{
1951  				mtCOVERAGE_TEST_MARKER();
1952  			}
1953  		}
1954  		#endif &bsol;* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
1955  		#if ( configUSE_IDLE_HOOK == 1 )
1956  		{
1957  			extern void vApplicationIdleHook( void );
1958  			vApplicationIdleHook();
1959  		}
1960  		#endif &bsol;* configUSE_IDLE_HOOK */
1961  		#if ( configUSE_TICKLESS_IDLE != 0 )
1962  		{
1963  		TickType_t xExpectedIdleTime;
1964  			xExpectedIdleTime = prvGetExpectedIdleTime();
1965  			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
1966  			{
1967  				vTaskSuspendAll();
1968  				{
1969  					configASSERT( xNextTaskUnblockTime >= xTickCount );
1970  					xExpectedIdleTime = prvGetExpectedIdleTime();
1971  					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
1972  					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
1973  					{
1974  						traceLOW_POWER_IDLE_BEGIN();
1975  						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
1976  						traceLOW_POWER_IDLE_END();
1977  					}
1978  					else
1979  					{
1980  						mtCOVERAGE_TEST_MARKER();
1981  					}
1982  				}
1983  				( void ) xTaskResumeAll();
1984  			}
1985  			else
1986  			{
1987  				mtCOVERAGE_TEST_MARKER();
1988  			}
1989  		}
1990  		#endif &bsol;* configUSE_TICKLESS_IDLE */
1991  	}
1992  }
1993  #if( configUSE_TICKLESS_IDLE != 0 )
1994  	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
1995  	{
1996  	const UBaseType_t uxNonApplicationTasks = 1;
1997  	eSleepModeStatus eReturn = eStandardSleep;
1998  		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
1999  		{
2000  			eReturn = eAbortSleep;
2001  		}
2002  		else if( xYieldPending != pdFALSE )
2003  		{
2004  			eReturn = eAbortSleep;
2005  		}
2006  		else
2007  		{
2008  			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
2009  			{
2010  				eReturn = eNoTasksWaitingTimeout;
2011  			}
2012  			else
2013  			{
2014  				mtCOVERAGE_TEST_MARKER();
2015  			}
2016  		}
2017  		return eReturn;
2018  	}
2019  #endif &bsol;* configUSE_TICKLESS_IDLE */
2020  #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2021  	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
2022  	{
2023  	TCB_t *pxTCB;
2024  		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2025  		{
2026  			pxTCB = prvGetTCBFromHandle( xTaskToSet );
2027  			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
2028  		}
2029  	}
2030  #endif &bsol;* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2031  #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2032  	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
2033  	{
2034  	void *pvReturn = NULL;
2035  	TCB_t *pxTCB;
2036  		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2037  		{
2038  			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2039  			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
2040  		}
2041  		else
2042  		{
2043  			pvReturn = NULL;
2044  		}
2045  		return pvReturn;
2046  	}
2047  #endif &bsol;* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2048  #if ( portUSING_MPU_WRAPPERS == 1 )
2049  	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2050  	{
2051  	TCB_t *pxTCB;
2052  		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2053  		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2054  	}
2055  #endif &bsol;* portUSING_MPU_WRAPPERS */
2056  static void prvInitialiseTaskLists( void )
2057  {
2058  UBaseType_t uxPriority;
2059  	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
2060  	{
2061  		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
2062  	}
2063  	vListInitialise( &xDelayedTaskList1 );
2064  	vListInitialise( &xDelayedTaskList2 );
2065  	vListInitialise( &xPendingReadyList );
2066  	#if ( INCLUDE_vTaskDelete == 1 )
2067  	{
2068  		vListInitialise( &xTasksWaitingTermination );
2069  	}
2070  	#endif &bsol;* INCLUDE_vTaskDelete */
2071  	#if ( INCLUDE_vTaskSuspend == 1 )
2072  	{
2073  		vListInitialise( &xSuspendedTaskList );
2074  	}
2075  	#endif &bsol;* INCLUDE_vTaskSuspend */
2076  	pxDelayedTaskList = &xDelayedTaskList1;
2077  	pxOverflowDelayedTaskList = &xDelayedTaskList2;
2078  }
2079  static void prvCheckTasksWaitingTermination( void )
2080  {
2081  	#if ( INCLUDE_vTaskDelete == 1 )
2082  	{
2083  		TCB_t *pxTCB;
2084  		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
2085  		{
2086  			taskENTER_CRITICAL();
2087  			{
2088  				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
2089  				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2090  				--uxCurrentNumberOfTasks;
2091  				--uxDeletedTasksWaitingCleanUp;
2092  			}
2093  			taskEXIT_CRITICAL();
2094  			prvDeleteTCB( pxTCB );
2095  		}
2096  	}
2097  	#endif &bsol;* INCLUDE_vTaskDelete */
2098  }
2099  #if( configUSE_TRACE_FACILITY == 1 )
2100  	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
2101  	{
2102  	TCB_t *pxTCB;
2103  		pxTCB = prvGetTCBFromHandle( xTask );
2104  		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
2105  		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
2106  		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
2107  		pxTaskStatus->pxStackBase = pxTCB->pxStack;
2108  		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
2109  		#if ( configUSE_MUTEXES == 1 )
2110  		{
2111  			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
2112  		}
2113  		#else
2114  		{
2115  			pxTaskStatus->uxBasePriority = 0;
2116  		}
2117  		#endif
2118  		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2119  		{
2120  			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
2121  		}
2122  		#else
2123  		{
2124  			pxTaskStatus->ulRunTimeCounter = 0;
2125  		}
2126  		#endif
2127  		if( eState != eInvalid )
2128  		{
2129  			if( pxTCB == pxCurrentTCB )
2130  			{
2131  				pxTaskStatus->eCurrentState = eRunning;
2132  			}
2133  			else
2134  			{
2135  				pxTaskStatus->eCurrentState = eState;
2136  				#if ( INCLUDE_vTaskSuspend == 1 )
2137  				{
2138  					if( eState == eSuspended )
2139  					{
2140  						vTaskSuspendAll();
2141  						{
2142  							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2143  							{
2144  								pxTaskStatus->eCurrentState = eBlocked;
2145  							}
2146  						}
2147  						( void ) xTaskResumeAll();
2148  					}
2149  				}
2150  				#endif &bsol;* INCLUDE_vTaskSuspend */
2151  			}
2152  		}
2153  		else
2154  		{
2155  			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
2156  		}
2157  		if( xGetFreeStackSpace != pdFALSE )
2158  		{
2159  			#if ( portSTACK_GROWTH > 0 )
2160  			{
2161  				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
2162  			}
2163  			#else
2164  			{
2165  				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
2166  			}
2167  			#endif
2168  		}
2169  		else
2170  		{
2171  			pxTaskStatus->usStackHighWaterMark = 0;
2172  		}
2173  	}
2174  #endif &bsol;* configUSE_TRACE_FACILITY */
2175  #if ( configUSE_TRACE_FACILITY == 1 )
2176  	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
2177  	{
2178  	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
2179  	UBaseType_t uxTask = 0;
2180  		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2181  		{
2182  			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2183  			do
2184  			{
2185  				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2186  				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
2187  				uxTask++;
2188  			} while( pxNextTCB != pxFirstTCB );
2189  		}
2190  		else
2191  		{
2192  			mtCOVERAGE_TEST_MARKER();
2193  		}
2194  		return uxTask;
2195  	}
2196  #endif &bsol;* configUSE_TRACE_FACILITY */
2197  #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2198  	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
2199  	{
2200  	uint32_t ulCount = 0U;
2201  		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
2202  		{
2203  			pucStackByte -= portSTACK_GROWTH;
2204  			ulCount++;
2205  		}
2206  		ulCount /= ( uint32_t ) sizeof( StackType_t ); &bsol;*lint !e961 Casting is not redundant on smaller architectures. */
2207  		return ( uint16_t ) ulCount;
2208  	}
2209  #endif &bsol;* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
2210  #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2211  	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
2212  	{
2213  	TCB_t *pxTCB;
2214  	uint8_t *pucEndOfStack;
2215  	UBaseType_t uxReturn;
2216  		pxTCB = prvGetTCBFromHandle( xTask );
2217  		#if portSTACK_GROWTH < 0
2218  		{
2219  			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
2220  		}
2221  		#else
2222  		{
2223  			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
2224  		}
2225  		#endif
2226  		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
2227  		return uxReturn;
2228  	}
2229  #endif &bsol;* INCLUDE_uxTaskGetStackHighWaterMark */
2230  #if (INCLUDE_pxTaskGetStackStart == 1)
2231  	uint8_t* pxTaskGetStackStart( TaskHandle_t xTask)
2232  	{
2233  	    TCB_t *pxTCB;
2234  	    UBaseType_t uxReturn;
2235          (void)uxReturn;
2236  		pxTCB = prvGetTCBFromHandle( xTask );
2237  		return ( uint8_t * ) pxTCB->pxStack;
2238  	}
2239  #endif &bsol;* INCLUDE_pxTaskGetStackStart */
2240  #if ( INCLUDE_vTaskDelete == 1 )
2241  	static void prvDeleteTCB( TCB_t *pxTCB )
2242  	{
2243  		portCLEAN_UP_TCB( pxTCB );
2244  		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2245  		{
2246  			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
2247  		}
2248  		#endif &bsol;* configUSE_NEWLIB_REENTRANT */
2249  		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
2250  		{
2251  			vPortFree( pxTCB->pxStack );
2252  			vPortFree( pxTCB );
2253  		}
2254  		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &bsol;*lint !e731 Macro has been consolidated for readability reasons. */
2255  		{
2256  			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
2257  			{
2258  				vPortFree( pxTCB->pxStack );
2259  				vPortFree( pxTCB );
2260  			}
2261  			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
2262  			{
2263  				vPortFree( pxTCB );
2264  			}
2265  			else
2266  			{
2267  				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
2268  				mtCOVERAGE_TEST_MARKER();
2269  			}
2270  		}
2271  		#endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
2272  	}
2273  #endif &bsol;* INCLUDE_vTaskDelete */
2274  static void prvResetNextTaskUnblockTime( void )
2275  {
2276  TCB_t *pxTCB;
2277  	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2278  	{
2279  		xNextTaskUnblockTime = portMAX_DELAY;
2280  	}
2281  	else
2282  	{
2283  		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
2284  		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
2285  	}
2286  }
2287  #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2288  	TaskHandle_t xTaskGetCurrentTaskHandle( void )
2289  	{
2290  	TaskHandle_t xReturn;
2291  		xReturn = pxCurrentTCB;
2292  		return xReturn;
2293  	}
2294  #endif &bsol;* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
2295  #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2296  	BaseType_t xTaskGetSchedulerState( void )
2297  	{
2298  	BaseType_t xReturn;
2299  		if( xSchedulerRunning == pdFALSE )
2300  		{
2301  			xReturn = taskSCHEDULER_NOT_STARTED;
2302  		}
2303  		else
2304  		{
2305  			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2306  			{
2307  				xReturn = taskSCHEDULER_RUNNING;
2308  			}
2309  			else
2310  			{
2311  				xReturn = taskSCHEDULER_SUSPENDED;
2312  			}
2313  		}
2314  		return xReturn;
2315  	}
2316  #endif &bsol;* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
2317  #if ( configUSE_MUTEXES == 1 )
2318  	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
2319  	{
2320  	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
2321  	BaseType_t xReturn = pdFALSE;
2322  		if( pxMutexHolder != NULL )
2323  		{
2324  			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
2325  			{
2326  				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
2327  				{
2328  					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2329  				}
2330  				else
2331  				{
2332  					mtCOVERAGE_TEST_MARKER();
2333  				}
2334  				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
2335  				{
2336  					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
2337  					{
2338  						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
2339  					}
2340  					else
2341  					{
2342  						mtCOVERAGE_TEST_MARKER();
2343  					}
2344  					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
2345  					prvReaddTaskToReadyList( pxMutexHolderTCB );
2346  				}
2347  				else
2348  				{
2349  					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
2350  				}
2351  				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
2352  				xReturn = pdTRUE;
2353  			}
2354  			else
2355  			{
2356  				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
2357  				{
2358  					xReturn = pdTRUE;
2359  				}
2360  				else
2361  				{
2362  					mtCOVERAGE_TEST_MARKER();
2363  				}
2364  			}
2365  		}
2366  		else
2367  		{
2368  			mtCOVERAGE_TEST_MARKER();
2369  		}
2370  		return xReturn;
2371  	}
2372  #endif &bsol;* configUSE_MUTEXES */
2373  #if ( configUSE_MUTEXES == 1 )
2374  	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
2375  	{
2376  	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
2377  	BaseType_t xReturn = pdFALSE;
2378  		if( pxMutexHolder != NULL )
2379  		{
2380  			configASSERT( pxTCB == pxCurrentTCB );
2381  			configASSERT( pxTCB->uxMutexesHeld );
2382  			( pxTCB->uxMutexesHeld )--;
2383  			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
2384  			{
2385  				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
2386  				{
2387  					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
2388  					{
2389  						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2390  					}
2391  					else
2392  					{
2393  						mtCOVERAGE_TEST_MARKER();
2394  					}
2395  					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2396  					pxTCB->uxPriority = pxTCB->uxBasePriority;
2397  					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2398  					prvReaddTaskToReadyList( pxTCB );
2399  					xReturn = pdTRUE;
2400  				}
2401  				else
2402  				{
2403  					mtCOVERAGE_TEST_MARKER();
2404  				}
2405  			}
2406  			else
2407  			{
2408  				mtCOVERAGE_TEST_MARKER();
2409  			}
2410  		}
2411  		else
2412  		{
2413  			mtCOVERAGE_TEST_MARKER();
2414  		}
2415  		return xReturn;
2416  	}
2417  #endif &bsol;* configUSE_MUTEXES */
2418  #if ( configUSE_MUTEXES == 1 )
2419  	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
2420  	{
2421  	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
2422  	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
2423  	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
2424  		if( pxMutexHolder != NULL )
2425  		{
2426  			configASSERT( pxTCB->uxMutexesHeld );
2427  			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
2428  			{
2429  				uxPriorityToUse = uxHighestPriorityWaitingTask;
2430  			}
2431  			else
2432  			{
2433  				uxPriorityToUse = pxTCB->uxBasePriority;
2434  			}
2435  			if( pxTCB->uxPriority != uxPriorityToUse )
2436  			{
2437  				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
2438  				{
2439  					configASSERT( pxTCB != pxCurrentTCB );
2440  					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2441  					uxPriorityUsedOnEntry = pxTCB->uxPriority;
2442  					pxTCB->uxPriority = uxPriorityToUse;
2443  					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
2444  					{
2445  						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2446  					}
2447  					else
2448  					{
2449  						mtCOVERAGE_TEST_MARKER();
2450  					}
2451  					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
2452  					{
2453  						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
2454  						{
2455  							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2456  						}
2457  						else
2458  						{
2459  							mtCOVERAGE_TEST_MARKER();
2460  						}
2461  						prvAddTaskToReadyList( pxTCB );
2462  					}
2463  					else
2464  					{
2465  						mtCOVERAGE_TEST_MARKER();
2466  					}
2467  				}
2468  				else
2469  				{
2470  					mtCOVERAGE_TEST_MARKER();
2471  				}
2472  			}
2473  			else
2474  			{
2475  				mtCOVERAGE_TEST_MARKER();
2476  			}
2477  		}
2478  		else
2479  		{
2480  			mtCOVERAGE_TEST_MARKER();
2481  		}
2482  	}
2483  #endif &bsol;* configUSE_MUTEXES */
2484  #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2485  	void vTaskEnterCritical( void )
2486  	{
2487  		portDISABLE_INTERRUPTS();
2488  		if( xSchedulerRunning != pdFALSE )
2489  		{
2490  			( pxCurrentTCB->uxCriticalNesting )++;
2491  			if( pxCurrentTCB->uxCriticalNesting == 1 )
2492  			{
2493  				portASSERT_IF_IN_ISR();
2494  			}
2495  		}
2496  		else
2497  		{
2498  			mtCOVERAGE_TEST_MARKER();
2499  		}
2500  	}
2501  #endif &bsol;* portCRITICAL_NESTING_IN_TCB */
2502  #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2503  	void vTaskExitCritical( void )
2504  	{
2505  		if( xSchedulerRunning != pdFALSE )
2506  		{
2507  			if( pxCurrentTCB->uxCriticalNesting > 0U )
2508  			{
2509  				( pxCurrentTCB->uxCriticalNesting )--;
2510  				if( pxCurrentTCB->uxCriticalNesting == 0U )
2511  				{
2512  					portENABLE_INTERRUPTS();
2513  				}
2514  				else
2515  				{
2516  					mtCOVERAGE_TEST_MARKER();
2517  				}
2518  			}
2519  			else
2520  			{
2521  				mtCOVERAGE_TEST_MARKER();
2522  			}
2523  		}
2524  		else
2525  		{
2526  			mtCOVERAGE_TEST_MARKER();
2527  		}
2528  	}
2529  #endif &bsol;* portCRITICAL_NESTING_IN_TCB */
2530  #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
2531  	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
2532  	{
2533  	size_t x;
2534  		strcpy( pcBuffer, pcTaskName );
2535  		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
2536  		{
2537  			pcBuffer[ x ] = ' ';
2538  		}
2539  		pcBuffer[ x ] = 0x00;
2540  		return &( pcBuffer[ x ] );
2541  	}
2542  #endif &bsol;* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
2543  #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2544  	void vTaskList( char * pcWriteBuffer )
2545  	{
2546  	TaskStatus_t *pxTaskStatusArray;
2547  	volatile UBaseType_t uxArraySize, x;
2548  	char cStatus;
2549  		*pcWriteBuffer = 0x00;
2550  		uxArraySize = uxCurrentNumberOfTasks;
2551  		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
2552  		if( pxTaskStatusArray != NULL )
2553  		{
2554  			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
2555  			for( x = 0; x < uxArraySize; x++ )
2556  			{
2557  				switch( pxTaskStatusArray[ x ].eCurrentState )
2558  				{
2559  					case eRunning:		cStatus = tskRUNNING_CHAR;
2560  										break;
2561  					case eReady:		cStatus = tskREADY_CHAR;
2562  										break;
2563  					case eBlocked:		cStatus = tskBLOCKED_CHAR;
2564  										break;
2565  					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
2566  										break;
2567  					case eDeleted:		cStatus = tskDELETED_CHAR;
2568  										break;
2569  					default:			&bsol;* Should not get here, but it is included
2570  										to prevent static checking errors. */
2571  										cStatus = 0x00;
2572  										break;
2573  				}
2574  				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
2575  				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
2576  				pcWriteBuffer += strlen( pcWriteBuffer );
2577  			}
2578  			vPortFree( pxTaskStatusArray );
2579  		}
2580  		else
2581  		{
2582  			mtCOVERAGE_TEST_MARKER();
2583  		}
2584  	}
2585  #endif &bsol;* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
2586  #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2587  	void vTaskGetRunTimeStats( char *pcWriteBuffer )
2588  	{
2589  	TaskStatus_t *pxTaskStatusArray;
2590  	volatile UBaseType_t uxArraySize, x;
2591  	uint32_t ulTotalTime, ulStatsAsPercentage;
2592  		#if( configUSE_TRACE_FACILITY != 1 )
2593  		{
2594  			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
2595  		}
2596  		#endif
2597  		*pcWriteBuffer = 0x00;
2598  		uxArraySize = uxCurrentNumberOfTasks;
2599  		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
2600  		if( pxTaskStatusArray != NULL )
2601  		{
2602  			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
2603  			ulTotalTime /= 100UL;
2604  			if( ulTotalTime > 0 )
2605  			{
2606  				for( x = 0; x < uxArraySize; x++ )
2607  				{
2608  					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
2609  					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
2610  					if( ulStatsAsPercentage > 0UL )
2611  					{
2612  						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2613  						{
2614  							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
2615  						}
2616  						#else
2617  						{
2618  							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
2619  						}
2620  						#endif
2621  					}
2622  					else
2623  					{
2624  						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2625  						{
2626  							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
2627  						}
2628  						#else
2629  						{
2630  							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
2631  						}
2632  						#endif
2633  					}
2634  					pcWriteBuffer += strlen( pcWriteBuffer );
2635  				}
2636  			}
2637  			else
2638  			{
2639  				mtCOVERAGE_TEST_MARKER();
2640  			}
2641  			vPortFree( pxTaskStatusArray );
2642  		}
2643  		else
2644  		{
2645  			mtCOVERAGE_TEST_MARKER();
2646  		}
2647  	}
2648  #endif &bsol;* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
2649  TickType_t uxTaskResetEventItemValue( void )
2650  {
2651  TickType_t uxReturn;
2652  	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
2653  	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2654  	return uxReturn;
2655  }
2656  #if ( configUSE_MUTEXES == 1 )
2657  	void *pvTaskIncrementMutexHeldCount( void )
2658  	{
2659  		if( pxCurrentTCB != NULL )
2660  		{
2661  			( pxCurrentTCB->uxMutexesHeld )++;
2662  		}
2663  		return pxCurrentTCB;
2664  	}
2665  #endif &bsol;* configUSE_MUTEXES */
2666  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2667  	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
2668  	{
2669  	uint32_t ulReturn;
2670  		taskENTER_CRITICAL();
2671  		{
2672  			if( pxCurrentTCB->ulNotifiedValue == 0UL )
2673  			{
2674  				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
2675  				if( xTicksToWait > ( TickType_t ) 0 )
2676  				{
2677  					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2678  					traceTASK_NOTIFY_TAKE_BLOCK();
2679  					portYIELD_WITHIN_API();
2680  				}
2681  				else
2682  				{
2683  					mtCOVERAGE_TEST_MARKER();
2684  				}
2685  			}
2686  			else
2687  			{
2688  				mtCOVERAGE_TEST_MARKER();
2689  			}
2690  		}
2691  		taskEXIT_CRITICAL();
2692  		taskENTER_CRITICAL();
2693  		{
2694  			traceTASK_NOTIFY_TAKE();
2695  			ulReturn = pxCurrentTCB->ulNotifiedValue;
2696  			if( ulReturn != 0UL )
2697  			{
2698  				if( xClearCountOnExit != pdFALSE )
2699  				{
2700  					pxCurrentTCB->ulNotifiedValue = 0UL;
2701  				}
2702  				else
2703  				{
2704  					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
2705  				}
2706  			}
2707  			else
2708  			{
2709  				mtCOVERAGE_TEST_MARKER();
2710  			}
2711  			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
2712  		}
2713  		taskEXIT_CRITICAL();
2714  		return ulReturn;
2715  	}
2716  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2717  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2718  	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
2719  	{
2720  	BaseType_t xReturn;
2721  		taskENTER_CRITICAL();
2722  		{
2723  			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
2724  			{
2725  				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
2726  				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
2727  				if( xTicksToWait > ( TickType_t ) 0 )
2728  				{
2729  					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2730  					traceTASK_NOTIFY_WAIT_BLOCK();
2731  					portYIELD_WITHIN_API();
2732  				}
2733  				else
2734  				{
2735  					mtCOVERAGE_TEST_MARKER();
2736  				}
2737  			}
2738  			else
2739  			{
2740  				mtCOVERAGE_TEST_MARKER();
2741  			}
2742  		}
2743  		taskEXIT_CRITICAL();
2744  		taskENTER_CRITICAL();
2745  		{
2746  			traceTASK_NOTIFY_WAIT();
2747  			if( pulNotificationValue != NULL )
2748  			{
2749  				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
2750  			}
2751  			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
2752  			{
2753  				xReturn = pdFALSE;
2754  			}
2755  			else
2756  			{
2757  				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
2758  				xReturn = pdTRUE;
2759  			}
2760  			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
2761  		}
2762  		taskEXIT_CRITICAL();
2763  		return xReturn;
2764  	}
2765  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2766  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2767  	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
2768  	{
2769  	TCB_t * pxTCB;
2770  	BaseType_t xReturn = pdPASS;
2771  	uint8_t ucOriginalNotifyState;
2772  		configASSERT( xTaskToNotify );
2773  		pxTCB = ( TCB_t * ) xTaskToNotify;
2774  		taskENTER_CRITICAL();
2775  		{
2776  			if( pulPreviousNotificationValue != NULL )
2777  			{
2778  				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
2779  			}
2780  			ucOriginalNotifyState = pxTCB->ucNotifyState;
2781  			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
2782  			switch( eAction )
2783  			{
2784  				case eSetBits	:
2785  					pxTCB->ulNotifiedValue |= ulValue;
2786  					break;
2787  				case eIncrement	:
2788  					( pxTCB->ulNotifiedValue )++;
2789  					break;
2790  				case eSetValueWithOverwrite	:
2791  					pxTCB->ulNotifiedValue = ulValue;
2792  					break;
2793  				case eSetValueWithoutOverwrite :
2794  					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
2795  					{
2796  						pxTCB->ulNotifiedValue = ulValue;
2797  					}
2798  					else
2799  					{
2800  						xReturn = pdFAIL;
2801  					}
2802  					break;
2803  				case eNoAction:
2804  					break;
2805  			}
2806  			traceTASK_NOTIFY();
2807  			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
2808  			{
2809  				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2810  				prvAddTaskToReadyList( pxTCB );
2811  				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
2812  				#if( configUSE_TICKLESS_IDLE != 0 )
2813  				{
2814  					prvResetNextTaskUnblockTime();
2815  				}
2816  				#endif
2817  				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2818  				{
2819  					taskYIELD_IF_USING_PREEMPTION();
2820  				}
2821  				else
2822  				{
2823  					mtCOVERAGE_TEST_MARKER();
2824  				}
2825  			}
2826  			else
2827  			{
2828  				mtCOVERAGE_TEST_MARKER();
2829  			}
2830  		}
2831  		taskEXIT_CRITICAL();
2832  		return xReturn;
2833  	}
2834  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2835  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2836  	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
2837  	{
2838  	TCB_t * pxTCB;
2839  	uint8_t ucOriginalNotifyState;
2840  	BaseType_t xReturn = pdPASS;
2841  	UBaseType_t uxSavedInterruptStatus;
2842  		configASSERT( xTaskToNotify );
2843  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2844  		pxTCB = ( TCB_t * ) xTaskToNotify;
2845  		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2846  		{
2847  			if( pulPreviousNotificationValue != NULL )
2848  			{
2849  				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
2850  			}
2851  			ucOriginalNotifyState = pxTCB->ucNotifyState;
2852  			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
2853  			switch( eAction )
2854  			{
2855  				case eSetBits	:
2856  					pxTCB->ulNotifiedValue |= ulValue;
2857  					break;
2858  				case eIncrement	:
2859  					( pxTCB->ulNotifiedValue )++;
2860  					break;
2861  				case eSetValueWithOverwrite	:
2862  					pxTCB->ulNotifiedValue = ulValue;
2863  					break;
2864  				case eSetValueWithoutOverwrite :
2865  					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
2866  					{
2867  						pxTCB->ulNotifiedValue = ulValue;
2868  					}
2869  					else
2870  					{
2871  						xReturn = pdFAIL;
2872  					}
2873  					break;
2874  				case eNoAction :
2875  					break;
2876  			}
2877  			traceTASK_NOTIFY_FROM_ISR();
2878  			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
2879  			{
2880  				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
2881  				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2882  				{
2883  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2884  					prvAddTaskToReadyList( pxTCB );
2885  				}
2886  				else
2887  				{
2888  					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
2889  				}
2890  				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2891  				{
2892  					if( pxHigherPriorityTaskWoken != NULL )
2893  					{
2894  						*pxHigherPriorityTaskWoken = pdTRUE;
2895  					}
2896  					else
2897  					{
2898  						xYieldPending = pdTRUE;
2899  					}
2900  				}
2901  				else
2902  				{
2903  					mtCOVERAGE_TEST_MARKER();
2904  				}
2905  			}
2906  		}
2907  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2908  		return xReturn;
2909  	}
2910  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2911  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2912  	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
2913  	{
2914  	TCB_t * pxTCB;
2915  	uint8_t ucOriginalNotifyState;
2916  	UBaseType_t uxSavedInterruptStatus;
2917  		configASSERT( xTaskToNotify );
2918  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2919  		pxTCB = ( TCB_t * ) xTaskToNotify;
2920  		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2921  		{
2922  			ucOriginalNotifyState = pxTCB->ucNotifyState;
2923  			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
2924  			( pxTCB->ulNotifiedValue )++;
2925  			traceTASK_NOTIFY_GIVE_FROM_ISR();
2926  			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
2927  			{
2928  				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
2929  				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2930  				{
2931  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2932  					prvAddTaskToReadyList( pxTCB );
2933  				}
2934  				else
2935  				{
2936  					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
2937  				}
2938  				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2939  				{
2940  					if( pxHigherPriorityTaskWoken != NULL )
2941  					{
2942  						*pxHigherPriorityTaskWoken = pdTRUE;
2943  					}
2944  					else
2945  					{
2946  						xYieldPending = pdTRUE;
2947  					}
2948  				}
2949  				else
2950  				{
2951  					mtCOVERAGE_TEST_MARKER();
2952  				}
2953  			}
2954  		}
2955  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2956  	}
2957  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2958  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2959  	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
2960  	{
2961  	TCB_t *pxTCB;
2962  	BaseType_t xReturn;
2963  		pxTCB = prvGetTCBFromHandle( xTask );
2964  		taskENTER_CRITICAL();
2965  		{
2966  			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
2967  			{
2968  				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
2969  				xReturn = pdPASS;
2970  			}
2971  			else
2972  			{
2973  				xReturn = pdFAIL;
2974  			}
2975  		}
2976  		taskEXIT_CRITICAL();
2977  		return xReturn;
2978  	}
2979  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2980  static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
2981  {
2982  TickType_t xTimeToWake;
2983  const TickType_t xConstTickCount = xTickCount;
2984  	#if( INCLUDE_xTaskAbortDelay == 1 )
2985  	{
2986  		pxCurrentTCB->ucDelayAborted = pdFALSE;
2987  	}
2988  	#endif
2989  	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
2990  	{
2991  		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2992  	}
2993  	else
2994  	{
2995  		mtCOVERAGE_TEST_MARKER();
2996  	}
2997  	#if ( INCLUDE_vTaskSuspend == 1 )
2998  	{
2999  		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
3000  		{
3001  			traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
3002  			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
3003  		}
3004  		else
3005  		{
3006  			xTimeToWake = xConstTickCount + xTicksToWait;
3007  			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
3008  			if( xTimeToWake < xConstTickCount )
3009  			{
3010  				traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
3011  				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
3012  			}
3013  			else
3014  			{
3015  				traceMOVED_TASK_TO_DELAYED_LIST();
3016  				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
3017  				if( xTimeToWake < xNextTaskUnblockTime )
3018  				{
3019  					xNextTaskUnblockTime = xTimeToWake;
3020  				}
3021  				else
3022  				{
3023  					mtCOVERAGE_TEST_MARKER();
3024  				}
3025  			}
3026  		}
3027  	}
3028  	#else &bsol;* INCLUDE_vTaskSuspend */
3029  	{
3030  		xTimeToWake = xConstTickCount + xTicksToWait;
3031  		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
3032  		if( xTimeToWake < xConstTickCount )
3033  		{
3034  			traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
3035  			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
3036  		}
3037  		else
3038  		{
3039  			traceMOVED_TASK_TO_DELAYED_LIST();
3040  			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
3041  			if( xTimeToWake < xNextTaskUnblockTime )
3042  			{
3043  				xNextTaskUnblockTime = xTimeToWake;
3044  			}
3045  			else
3046  			{
3047  				mtCOVERAGE_TEST_MARKER();
3048  			}
3049  		}
3050  		( void ) xCanBlockIndefinitely;
3051  	}
3052  	#endif &bsol;* INCLUDE_vTaskSuspend */
3053  }
3054  #ifdef FREERTOS_MODULE_TEST
3055  	#include "tasks_test_access_functions.h"
3056  #endif
3057  #if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
3058  	#include "freertos_tasks_c_additions.h"
3059  	static void freertos_tasks_c_additions_init( void )
3060  	{
3061  		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
3062  			FREERTOS_TASKS_C_ADDITIONS_INIT();
3063  		#endif
3064  	}
3065  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-tasks.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
4  #include "FreeRTOS.h"
5  #include "task.h"
6  #include "timers.h"
7  #include "stack_macros.h"
8  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE &bsol;*lint !e961 !e750. */
9  #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
10  	#include <stdio.h>
11  #endif &bsol;* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
12  #if( configUSE_PREEMPTION == 0 )
13  	#define taskYIELD_IF_USING_PREEMPTION()
14  #else
15  	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
16  #endif
17  #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
18  #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
19  #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
20  #define tskSTACK_FILL_BYTE	( 0xa5U )
21  #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
22  #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
23  #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
24  #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
25  #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
26  	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
27  #else
28  	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
29  #endif
30  #define tskRUNNING_CHAR		( 'X' )
31  #define tskBLOCKED_CHAR		( 'B' )
32  #define tskREADY_CHAR		( 'R' )
33  #define tskDELETED_CHAR		( 'D' )
34  #define tskSUSPENDED_CHAR	( 'S' )
35  #ifdef portREMOVE_STATIC_QUALIFIER
36  	#define static
37  #endif
38  #ifndef configIDLE_TASK_NAME
39  	#define configIDLE_TASK_NAME "IDLE"
40  #endif
41  #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
42  	#define taskRECORD_READY_PRIORITY( uxPriority )														\
43  	{																									\
44  		if( ( uxPriority ) > uxTopReadyPriority )														\
45  		{																								\
46  			uxTopReadyPriority = ( uxPriority );														\
47  		}																								\
48  	} &bsol;* taskRECORD_READY_PRIORITY */
49  	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
50  	{																									\
51  	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
52  																										\
53  										\
54  		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
55  		{																								\
56  			configASSERT( uxTopPriority );																\
57  			--uxTopPriority;																			\
58  		}																								\
59  																										\
60  											\
61  		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
62  		uxTopReadyPriority = uxTopPriority;																\
63  	} &bsol;* taskSELECT_HIGHEST_PRIORITY_TASK */
64  	#define taskRESET_READY_PRIORITY( uxPriority )
65  	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
66  #else &bsol;* configUSE_PORT_OPTIMISED_TASK_SELECTION */
67  	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
68  	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
69  	{																								\
70  	UBaseType_t uxTopPriority;																		\
71  																									\
72  										\
73  		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
74  		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
75  		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
76  	} &bsol;* taskSELECT_HIGHEST_PRIORITY_TASK() */
77  	#define taskRESET_READY_PRIORITY( uxPriority )														\
78  	{																									\
79  		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
80  		{																								\
81  			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
82  		}																								\
83  	}
84  #endif &bsol;* configUSE_PORT_OPTIMISED_TASK_SELECTION */
85  #define taskSWITCH_DELAYED_LISTS()																	\
86  {																									\
87  	List_t *pxTemp;																					\
88  																									\
89  							\
90  	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
91  																									\
92  	pxTemp = pxDelayedTaskList;																		\
93  	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
94  	pxOverflowDelayedTaskList = pxTemp;																\
95  	xNumOfOverflows++;																				\
96  	prvResetNextTaskUnblockTime();																	\
97  }
98  #define prvAddTaskToReadyList( pxTCB )																\
99  	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
100  	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
101  	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
102  	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
103  #define prvReaddTaskToReadyList( pxTCB )															\
104  	traceREADDED_TASK_TO_READY_STATE( pxTCB );														\
105  	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
106  	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
107  	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
108  #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
109  #if( configUSE_16_BIT_TICKS == 1 )
110  	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
111  #else
112  	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
113  #endif
114  typedef struct tskTaskControlBlock
115  {
116  	volatile StackType_t	*pxTopOfStack;	&bsol;*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
117  	#if ( portUSING_MPU_WRAPPERS == 1 )
118  		xMPU_SETTINGS	xMPUSettings;		&bsol;*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
119  	#endif
120  	ListItem_t			xStateListItem;	&bsol;*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
121  	ListItem_t			xEventListItem;		&bsol;*< Used to reference a task from an event list. */
122  	UBaseType_t			uxPriority;			&bsol;*< The priority of the task.  0 is the lowest priority. */
123  	StackType_t			*pxStack;			&bsol;*< Points to the start of the stack. */
124  	char				pcTaskName[ configMAX_TASK_NAME_LEN ];&bsol;*< Descriptive name given to the task when created.  Facilitates debugging only. */ &bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
125  	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
126  		StackType_t		*pxEndOfStack;		&bsol;*< Points to the highest valid address for the stack. */
127  	#endif
128  	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
129  		UBaseType_t		uxCriticalNesting;	&bsol;*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
130  	#endif
131  	#if ( configUSE_TRACE_FACILITY == 1 )
132  		UBaseType_t		uxTCBNumber;		&bsol;*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
133  		UBaseType_t		uxTaskNumber;		&bsol;*< Stores a number specifically for use by third party trace code. */
134  	#endif
135  	#if ( configUSE_MUTEXES == 1 )
136  		UBaseType_t		uxBasePriority;		&bsol;*< The priority last assigned to the task - used by the priority inheritance mechanism. */
137  		UBaseType_t		uxMutexesHeld;
138  	#endif
139  	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
140  		TaskHookFunction_t pxTaskTag;
141  	#endif
142  	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
143  		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
144  	#endif
145  	#if( configGENERATE_RUN_TIME_STATS == 1 )
146  		uint32_t		ulRunTimeCounter;	&bsol;*< Stores the amount of time the task has spent in the Running state. */
147  	#endif
148  	#if ( configUSE_NEWLIB_REENTRANT == 1 )
149  		struct	_reent xNewLib_reent;
150  	#endif
151  	#if( configUSE_TASK_NOTIFICATIONS == 1 )
152  		volatile uint32_t ulNotifiedValue;
153  		volatile uint8_t ucNotifyState;
154  	#endif
155  	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &bsol;*lint !e731 Macro has been consolidated for readability reasons. */
156  		uint8_t	ucStaticallyAllocated; 		&bsol;*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
157  	#endif
158  	#if( INCLUDE_xTaskAbortDelay == 1 )
159  		uint8_t ucDelayAborted;
160  	#endif
161  } tskTCB;
162  typedef tskTCB TCB_t;
163  PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
164  PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];&bsol;*< Prioritised ready tasks. */
165  PRIVILEGED_DATA static List_t xDelayedTaskList1;						&bsol;*< Delayed tasks. */
166  PRIVILEGED_DATA static List_t xDelayedTaskList2;						&bsol;*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
167  PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				&bsol;*< Points to the delayed task list currently being used. */
168  PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		&bsol;*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
169  PRIVILEGED_DATA static List_t xPendingReadyList;						&bsol;*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
170  #if( INCLUDE_vTaskDelete == 1 )
171  	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				&bsol;*< Tasks that have been deleted - but their memory not yet freed. */
172  	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
173  #endif
174  #if ( INCLUDE_vTaskSuspend == 1 )
175  	PRIVILEGED_DATA static List_t xSuspendedTaskList;					&bsol;*< Tasks that are currently suspended. */
176  #endif
177  PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
178  PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT;
179  PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
180  PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
181  PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
182  PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
183  PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
184  PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
185  PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; &bsol;* Initialised to portMAX_DELAY before the scheduler starts. */
186  PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			&bsol;*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
187  PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
188  #if ( configGENERATE_RUN_TIME_STATS == 1 )
189  	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	&bsol;*< Holds the value of a timer/counter the last time a task was switched in. */
190  	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		&bsol;*< Holds the total amount of execution time as defined by the run time counter clock. */
191  #endif
192  #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
193  	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
194  #endif
195  #if( configUSE_TICK_HOOK > 0 )
196  	extern void vApplicationTickHook( void );
197  #endif
198  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
199  	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );
200  #endif
201  #if ( INCLUDE_vTaskSuspend == 1 )
202  	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
203  #endif &bsol;* INCLUDE_vTaskSuspend */
204  static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
205  static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
206  #if ( INCLUDE_vTaskDelete == 1 )
207  	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
208  #endif
209  static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
210  static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
211  #if ( configUSE_TRACE_FACILITY == 1 )
212  	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
213  #endif
214  #if ( INCLUDE_xTaskGetHandle == 1 )
215  	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
216  #endif
217  #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
218  	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
219  #endif
220  #if ( configUSE_TICKLESS_IDLE != 0 )
221  	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
222  #endif
223  static void prvResetNextTaskUnblockTime( void );
224  #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
225  	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
226  #endif
227  static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
228  									const char * const pcName, 		&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
229  									const uint32_t ulStackDepth,
230  									void * const pvParameters,
231  									UBaseType_t uxPriority,
232  									TaskHandle_t * const pxCreatedTask,
233  									TCB_t *pxNewTCB,
234  									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
235  static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
236  #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
237  	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
238  #endif
239  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
240  	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
241  									const char * const pcName,		&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
242  									const uint32_t ulStackDepth,
243  									void * const pvParameters,
244  									UBaseType_t uxPriority,
245  									StackType_t * const puxStackBuffer,
246  									StaticTask_t * const pxTaskBuffer )
247  	{
248  	TCB_t *pxNewTCB;
249  	TaskHandle_t xReturn;
250  		configASSERT( puxStackBuffer != NULL );
251  		configASSERT( pxTaskBuffer != NULL );
252  		#if( configASSERT_DEFINED == 1 )
253  		{
254  			volatile size_t xSize = sizeof( StaticTask_t );
255  			configASSERT( xSize == sizeof( TCB_t ) );
256  		}
257  		#endif &bsol;* configASSERT_DEFINED */
258  		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
259  		{
260  			pxNewTCB = ( TCB_t * ) pxTaskBuffer; &bsol;*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
261  			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
262  			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &bsol;*lint !e731 Macro has been consolidated for readability reasons. */
263  			{
264  				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
265  			}
266  			#endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
267  			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
268  			prvAddNewTaskToReadyList( pxNewTCB );
269  		}
270  		else
271  		{
272  			xReturn = NULL;
273  		}
274  		return xReturn;
275  	}
276  #endif &bsol;* SUPPORT_STATIC_ALLOCATION */
277  #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
278  	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
279  	{
280  	TCB_t *pxNewTCB;
281  	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
282  		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
283  		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
284  		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
285  		{
286  			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
287  			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
288  			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
289  			{
290  				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
291  			}
292  			#endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
293  			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
294  									pxTaskDefinition->pcName,
295  									( uint32_t ) pxTaskDefinition->usStackDepth,
296  									pxTaskDefinition->pvParameters,
297  									pxTaskDefinition->uxPriority,
298  									pxCreatedTask, pxNewTCB,
299  									pxTaskDefinition->xRegions );
300  			prvAddNewTaskToReadyList( pxNewTCB );
301  			xReturn = pdPASS;
302  		}
303  		return xReturn;
304  	}
305  #endif &bsol;* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
306  #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
307  	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
308  	{
309  	TCB_t *pxNewTCB;
310  	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
311  		configASSERT( pxTaskDefinition->puxStackBuffer );
312  		if( pxTaskDefinition->puxStackBuffer != NULL )
313  		{
314  			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
315  			if( pxNewTCB != NULL )
316  			{
317  				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
318  				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
319  				{
320  					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
321  				}
322  				#endif
323  				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
324  										pxTaskDefinition->pcName,
325  										( uint32_t ) pxTaskDefinition->usStackDepth,
326  										pxTaskDefinition->pvParameters,
327  										pxTaskDefinition->uxPriority,
328  										pxCreatedTask, pxNewTCB,
329  										pxTaskDefinition->xRegions );
330  				prvAddNewTaskToReadyList( pxNewTCB );
331  				xReturn = pdPASS;
332  			}
333  		}
334  		return xReturn;
335  	}
336  #endif &bsol;* portUSING_MPU_WRAPPERS */
337  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
338  	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
339  							const char * const pcName,		&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
340  							const configSTACK_DEPTH_TYPE usStackDepth,
341  							void * const pvParameters,
342  							UBaseType_t uxPriority,
343  							TaskHandle_t * const pxCreatedTask )
344  	{
345  	TCB_t *pxNewTCB;
346  	BaseType_t xReturn;
347  		#if( portSTACK_GROWTH > 0 )
348  		{
349  			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
350  			if( pxNewTCB != NULL )
351  			{
352  				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
353  				if( pxNewTCB->pxStack == NULL )
354  				{
355  					vPortFree( pxNewTCB );
356  					pxNewTCB = NULL;
357  				}
358  			}
359  		}
360  		#else &bsol;* portSTACK_GROWTH */
361  		{
362  		StackType_t *pxStack;
363  			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
364  			if( pxStack != NULL )
365  			{
366  				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some paths. */
367  				if( pxNewTCB != NULL )
368  				{
369  					pxNewTCB->pxStack = pxStack;
370  				}
371  				else
372  				{
373  					vPortFree( pxStack );
374  				}
375  			}
376  			else
377  			{
378  				pxNewTCB = NULL;
379  			}
380  		}
381  		#endif &bsol;* portSTACK_GROWTH */
382  		if( pxNewTCB != NULL )
383  		{
384  			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &bsol;*lint !e731 Macro has been consolidated for readability reasons. */
385  			{
386  				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
387  			}
388  			#endif &bsol;* configSUPPORT_STATIC_ALLOCATION */
389  			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
390  			prvAddNewTaskToReadyList( pxNewTCB );
391  			xReturn = pdPASS;
392  		}
393  		else
394  		{
395  			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
396  		}
397  		return xReturn;
398  	}
399  #endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
400  static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
401  									const char * const pcName,		&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
402  									const uint32_t ulStackDepth,
403  									void * const pvParameters,
404  									UBaseType_t uxPriority,
405  									TaskHandle_t * const pxCreatedTask,
406  									TCB_t *pxNewTCB,
407  									const MemoryRegion_t * const xRegions )
408  {
409  StackType_t *pxTopOfStack;
410  UBaseType_t x;
411  	#if( portUSING_MPU_WRAPPERS == 1 )
412  		BaseType_t xRunPrivileged;
413  		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
414  		{
415  			xRunPrivileged = pdTRUE;
416  		}
417  		else
418  		{
419  			xRunPrivileged = pdFALSE;
420  		}
421  		uxPriority &= ~portPRIVILEGE_BIT;
422  	#endif &bsol;* portUSING_MPU_WRAPPERS == 1 */
423  	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
424  	{
425  		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
426  	}
427  	#endif &bsol;* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
428  	#if( portSTACK_GROWTH < 0 )
429  	{
430  		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
431  		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); &bsol;*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
432  		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
433  		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
434  		{
435  			pxNewTCB->pxEndOfStack = pxTopOfStack;
436  		}
437  		#endif &bsol;* configRECORD_STACK_HIGH_ADDRESS */
438  	}
439  	#else &bsol;* portSTACK_GROWTH */
440  	{
441  		pxTopOfStack = pxNewTCB->pxStack;
442  		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
443  		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
444  	}
445  	#endif &bsol;* portSTACK_GROWTH */
446  	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
447  	{
448  		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
449  		if( pcName[ x ] == 0x00 )
450  		{
451  			break;
452  		}
453  		else
454  		{
455  			mtCOVERAGE_TEST_MARKER();
456  		}
457  	}
458  	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
459  	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
460  	{
461  		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
462  	}
463  	else
464  	{
465  		mtCOVERAGE_TEST_MARKER();
466  	}
467  	pxNewTCB->uxPriority = uxPriority;
468  	#if ( configUSE_MUTEXES == 1 )
469  	{
470  		pxNewTCB->uxBasePriority = uxPriority;
471  		pxNewTCB->uxMutexesHeld = 0;
472  	}
473  	#endif &bsol;* configUSE_MUTEXES */
474  	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
475  	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
476  	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
477  	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
478  	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
479  	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
480  	{
481  		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
482  	}
483  	#endif &bsol;* portCRITICAL_NESTING_IN_TCB */
484  	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
485  	{
486  		pxNewTCB->pxTaskTag = NULL;
487  	}
488  	#endif &bsol;* configUSE_APPLICATION_TASK_TAG */
489  	#if ( configGENERATE_RUN_TIME_STATS == 1 )
490  	{
491  		pxNewTCB->ulRunTimeCounter = 0UL;
492  	}
493  	#endif &bsol;* configGENERATE_RUN_TIME_STATS */
494  	#if ( portUSING_MPU_WRAPPERS == 1 )
495  	{
496  		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
497  	}
498  	#else
499  	{
500  		( void ) xRegions;
501  	}
502  	#endif
503  	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
504  	{
505  		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
506  		{
507  			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
508  		}
509  	}
510  	#endif
511  	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
512  	{
513  		pxNewTCB->ulNotifiedValue = 0;
514  		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
515  	}
516  	#endif
517  	#if ( configUSE_NEWLIB_REENTRANT == 1 )
518  	{
519  		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
520  	}
521  	#endif
522  	#if( INCLUDE_xTaskAbortDelay == 1 )
523  	{
524  		pxNewTCB->ucDelayAborted = pdFALSE;
525  	}
526  	#endif
527  	#if( portUSING_MPU_WRAPPERS == 1 )
528  	{
529  		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
530  	}
531  	#else &bsol;* portUSING_MPU_WRAPPERS */
532  	{
533  		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
534  	}
535  	#endif &bsol;* portUSING_MPU_WRAPPERS */
536  	if( ( void * ) pxCreatedTask != NULL )
537  	{
538  		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
539  	}
540  	else
541  	{
542  		mtCOVERAGE_TEST_MARKER();
543  	}
544  }
545  static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
546  {
547  	taskENTER_CRITICAL();
548  	{
549  		uxCurrentNumberOfTasks++;
550  		if( pxCurrentTCB == NULL )
551  		{
552  			pxCurrentTCB = pxNewTCB;
553  			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
554  			{
555  				prvInitialiseTaskLists();
556  			}
557  			else
558  			{
559  				mtCOVERAGE_TEST_MARKER();
560  			}
561  		}
562  		else
563  		{
564  			if( xSchedulerRunning == pdFALSE )
565  			{
566  				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
567  				{
568  					pxCurrentTCB = pxNewTCB;
569  				}
570  				else
571  				{
572  					mtCOVERAGE_TEST_MARKER();
573  				}
574  			}
575  			else
576  			{
577  				mtCOVERAGE_TEST_MARKER();
578  			}
579  		}
580  		uxTaskNumber++;
581  		#if ( configUSE_TRACE_FACILITY == 1 )
582  		{
583  			pxNewTCB->uxTCBNumber = uxTaskNumber;
584  		}
585  		#endif &bsol;* configUSE_TRACE_FACILITY */
586  		traceTASK_CREATE( pxNewTCB );
587  		prvAddTaskToReadyList( pxNewTCB );
588  		portSETUP_TCB( pxNewTCB );
589  	}
590  	taskEXIT_CRITICAL();
591  	if( xSchedulerRunning != pdFALSE )
592  	{
593  		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
594  		{
595  			taskYIELD_IF_USING_PREEMPTION();
596  		}
597  		else
598  		{
599  			mtCOVERAGE_TEST_MARKER();
600  		}
601  	}
602  	else
603  	{
604  		mtCOVERAGE_TEST_MARKER();
605  	}
606  }
607  #if ( INCLUDE_vTaskDelete == 1 )
608  	void vTaskDelete( TaskHandle_t xTaskToDelete )
609  	{
610  	TCB_t *pxTCB;
611  		taskENTER_CRITICAL();
612  		{
613  			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
614  			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
615  			{
616  				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
617  			}
618  			else
619  			{
620  				mtCOVERAGE_TEST_MARKER();
621  			}
622  			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
623  			{
624  				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
625  			}
626  			else
627  			{
628  				mtCOVERAGE_TEST_MARKER();
629  			}
630  			uxTaskNumber++;
631  			if( pxTCB == pxCurrentTCB )
632  			{
633  				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
634  				++uxDeletedTasksWaitingCleanUp;
635  				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
636  			}
637  			else
638  			{
639  				--uxCurrentNumberOfTasks;
640  				prvDeleteTCB( pxTCB );
641  				prvResetNextTaskUnblockTime();
642  			}
643  			traceTASK_DELETE( pxTCB );
644  		}
645  		taskEXIT_CRITICAL();
646  		if( xSchedulerRunning != pdFALSE )
647  		{
648  			if( pxTCB == pxCurrentTCB )
649  			{
650  				configASSERT( uxSchedulerSuspended == 0 );
651  				portYIELD_WITHIN_API();
652  			}
653  			else
654  			{
655  				mtCOVERAGE_TEST_MARKER();
656  			}
657  		}
658  	}
659  #endif &bsol;* INCLUDE_vTaskDelete */
660  #if ( INCLUDE_vTaskDelayUntil == 1 )
661  	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
662  	{
663  	TickType_t xTimeToWake;
664  	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
665  		configASSERT( pxPreviousWakeTime );
666  		configASSERT( ( xTimeIncrement > 0U ) );
667  		configASSERT( uxSchedulerSuspended == 0 );
668  		vTaskSuspendAll();
669  		{
670  			const TickType_t xConstTickCount = xTickCount;
671  			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
672  			if( xConstTickCount < *pxPreviousWakeTime )
673  			{
674  				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
675  				{
676  					xShouldDelay = pdTRUE;
677  				}
678  				else
679  				{
680  					mtCOVERAGE_TEST_MARKER();
681  				}
682  			}
683  			else
684  			{
685  				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
686  				{
687  					xShouldDelay = pdTRUE;
688  				}
689  				else
690  				{
691  					mtCOVERAGE_TEST_MARKER();
692  				}
693  			}
694  			*pxPreviousWakeTime = xTimeToWake;
695  			if( xShouldDelay != pdFALSE )
696  			{
697  				traceTASK_DELAY_UNTIL( xTimeToWake );
698  				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
699  			}
700  			else
701  			{
702  				mtCOVERAGE_TEST_MARKER();
703  			}
704  		}
705  		xAlreadyYielded = xTaskResumeAll();
706  		if( xAlreadyYielded == pdFALSE )
707  		{
708  			portYIELD_WITHIN_API();
709  		}
710  		else
711  		{
712  			mtCOVERAGE_TEST_MARKER();
713  		}
714  	}
715  #endif &bsol;* INCLUDE_vTaskDelayUntil */
716  #if ( INCLUDE_vTaskDelay == 1 )
717  	void vTaskDelay( const TickType_t xTicksToDelay )
718  	{
719  	BaseType_t xAlreadyYielded = pdFALSE;
720  		if( xTicksToDelay > ( TickType_t ) 0U )
721  		{
722  			configASSERT( uxSchedulerSuspended == 0 );
723  			vTaskSuspendAll();
724  			{
725  				traceTASK_DELAY();
726  				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
727  			}
728  			xAlreadyYielded = xTaskResumeAll();
729  		}
730  		else
731  		{
732  			mtCOVERAGE_TEST_MARKER();
733  		}
734  		if( xAlreadyYielded == pdFALSE )
735  		{
736  			portYIELD_WITHIN_API();
737  		}
738  		else
739  		{
740  			mtCOVERAGE_TEST_MARKER();
741  		}
742  	}
743  #endif &bsol;* INCLUDE_vTaskDelay */
744  #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
745  	eTaskState eTaskGetState( TaskHandle_t xTask )
746  	{
747  	eTaskState eReturn;
748  	List_t *pxStateList;
749  	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
750  		configASSERT( pxTCB );
751  		if( pxTCB == pxCurrentTCB )
752  		{
753  			eReturn = eRunning;
754  		}
755  		else
756  		{
757  			taskENTER_CRITICAL();
758  			{
759  				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
760  			}
761  			taskEXIT_CRITICAL();
762  			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
763  			{
764  				eReturn = eBlocked;
765  			}
766  			#if ( INCLUDE_vTaskSuspend == 1 )
767  				else if( pxStateList == &xSuspendedTaskList )
768  				{
769  					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
770  					{
771  						eReturn = eSuspended;
772  					}
773  					else
774  					{
775  						eReturn = eBlocked;
776  					}
777  				}
778  			#endif
779  			#if ( INCLUDE_vTaskDelete == 1 )
780  				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
781  				{
782  					eReturn = eDeleted;
783  				}
784  			#endif
785  			else &bsol;*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
786  			{
787  				eReturn = eReady;
788  			}
789  		}
790  		return eReturn;
791  	} &bsol;*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
792  #endif &bsol;* INCLUDE_eTaskGetState */
793  #if ( INCLUDE_uxTaskPriorityGet == 1 )
794  	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
795  	{
796  	TCB_t *pxTCB;
797  	UBaseType_t uxReturn;
798  		taskENTER_CRITICAL();
799  		{
800  			pxTCB = prvGetTCBFromHandle( xTask );
801  			uxReturn = pxTCB->uxPriority;
802  		}
803  		taskEXIT_CRITICAL();
804  		return uxReturn;
805  	}
806  #endif &bsol;* INCLUDE_uxTaskPriorityGet */
807  #if ( INCLUDE_uxTaskPriorityGet == 1 )
808  	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
809  	{
810  	TCB_t *pxTCB;
811  	UBaseType_t uxReturn, uxSavedInterruptState;
812  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
813  		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
814  		{
815  			pxTCB = prvGetTCBFromHandle( xTask );
816  			uxReturn = pxTCB->uxPriority;
817  		}
818  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
819  		return uxReturn;
820  	}
821  #endif &bsol;* INCLUDE_uxTaskPriorityGet */
822  #if ( INCLUDE_vTaskPrioritySet == 1 )
823  	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
824  	{
825  	TCB_t *pxTCB;
826  	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
827  	BaseType_t xYieldRequired = pdFALSE;
828  		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
829  		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
830  		{
831  			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
832  		}
833  		else
834  		{
835  			mtCOVERAGE_TEST_MARKER();
836  		}
837  		taskENTER_CRITICAL();
838  		{
839  			pxTCB = prvGetTCBFromHandle( xTask );
840  			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
841  			#if ( configUSE_MUTEXES == 1 )
842  			{
843  				uxCurrentBasePriority = pxTCB->uxBasePriority;
844  			}
845  			#else
846  			{
847  				uxCurrentBasePriority = pxTCB->uxPriority;
848  			}
849  			#endif
850  			if( uxCurrentBasePriority != uxNewPriority )
851  			{
852  				if( uxNewPriority > uxCurrentBasePriority )
853  				{
854  					if( pxTCB != pxCurrentTCB )
855  					{
856  						if( uxNewPriority >= pxCurrentTCB->uxPriority )
857  						{
858  							xYieldRequired = pdTRUE;
859  						}
860  						else
861  						{
862  							mtCOVERAGE_TEST_MARKER();
863  						}
864  					}
865  					else
866  					{
867  					}
868  				}
869  				else if( pxTCB == pxCurrentTCB )
870  				{
871  					xYieldRequired = pdTRUE;
872  				}
873  				else
874  				{
875  				}
876  				uxPriorityUsedOnEntry = pxTCB->uxPriority;
877  				#if ( configUSE_MUTEXES == 1 )
878  				{
879  					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
880  					{
881  						pxTCB->uxPriority = uxNewPriority;
882  					}
883  					else
884  					{
885  						mtCOVERAGE_TEST_MARKER();
886  					}
887  					pxTCB->uxBasePriority = uxNewPriority;
888  				}
889  				#else
890  				{
891  					pxTCB->uxPriority = uxNewPriority;
892  				}
893  				#endif
894  				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
895  				{
896  					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
897  				}
898  				else
899  				{
900  					mtCOVERAGE_TEST_MARKER();
901  				}
902  				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
903  				{
904  					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
905  					{
906  						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
907  					}
908  					else
909  					{
910  						mtCOVERAGE_TEST_MARKER();
911  					}
912  					prvReaddTaskToReadyList( pxTCB );
913  				}
914  				else
915  				{
916  					mtCOVERAGE_TEST_MARKER();
917  				}
918  				if( xYieldRequired != pdFALSE )
919  				{
920  					taskYIELD_IF_USING_PREEMPTION();
921  				}
922  				else
923  				{
924  					mtCOVERAGE_TEST_MARKER();
925  				}
926  				( void ) uxPriorityUsedOnEntry;
927  			}
928  		}
929  		taskEXIT_CRITICAL();
930  	}
931  #endif &bsol;* INCLUDE_vTaskPrioritySet */
932  #if ( INCLUDE_vTaskSuspend == 1 )
933  	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
934  	{
935  	TCB_t *pxTCB;
936  		taskENTER_CRITICAL();
937  		{
938  			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
939  			traceTASK_SUSPEND( pxTCB );
940  			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
941  			{
942  				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
943  			}
944  			else
945  			{
946  				mtCOVERAGE_TEST_MARKER();
947  			}
948  			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
949  			{
950  				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
951  			}
952  			else
953  			{
954  				mtCOVERAGE_TEST_MARKER();
955  			}
956  			traceMOVED_TASK_TO_SUSPENDED_LIST(pxTCB);
957  			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
958  			#if( configUSE_TASK_NOTIFICATIONS == 1 )
959  			{
960  				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
961  				{
962  					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
963  				}
964  			}
965  			#endif
966  		}
967  		taskEXIT_CRITICAL();
968  		if( xSchedulerRunning != pdFALSE )
969  		{
970  			taskENTER_CRITICAL();
971  			{
972  				prvResetNextTaskUnblockTime();
973  			}
974  			taskEXIT_CRITICAL();
975  		}
976  		else
977  		{
978  			mtCOVERAGE_TEST_MARKER();
979  		}
980  		if( pxTCB == pxCurrentTCB )
981  		{
982  			if( xSchedulerRunning != pdFALSE )
983  			{
984  				configASSERT( uxSchedulerSuspended == 0 );
985  				portYIELD_WITHIN_API();
986  			}
987  			else
988  			{
989  				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
990  				{
991  					pxCurrentTCB = NULL;
992  				}
993  				else
994  				{
995  					vTaskSwitchContext();
996  				}
997  			}
998  		}
999  		else
1000  		{
1001  			mtCOVERAGE_TEST_MARKER();
1002  		}
1003  	}
1004  #endif &bsol;* INCLUDE_vTaskSuspend */
1005  #if ( INCLUDE_vTaskSuspend == 1 )
1006  	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1007  	{
1008  	BaseType_t xReturn = pdFALSE;
1009  	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1010  		configASSERT( xTask );
1011  		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1012  		{
1013  			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1014  			{
1015  				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) &bsol;*lint !e961.  The cast is only redundant when NULL is used. */
1016  				{
<span onclick='openModal()' class='match'>1017  					xReturn = pdTRUE;
1018  				}
1019  				else
1020  				{
1021  					mtCOVERAGE_TEST_MARKER();
1022  				}
1023  			}
1024  			else
1025  			{
1026  				mtCOVERAGE_TEST_MARKER();
</span>1027  			}
1028  		}
1029  		else
1030  		{
1031  			mtCOVERAGE_TEST_MARKER();
1032  		}
1033  		return xReturn;
1034  	} &bsol;*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1035  #endif &bsol;* INCLUDE_vTaskSuspend */
1036  #if ( INCLUDE_vTaskSuspend == 1 )
1037  	void vTaskResume( TaskHandle_t xTaskToResume )
1038  	{
1039  	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1040  		configASSERT( xTaskToResume );
1041  		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1042  		{
1043  			taskENTER_CRITICAL();
1044  			{
1045  				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1046  				{
1047  					traceTASK_RESUME( pxTCB );
1048  					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1049  					prvAddTaskToReadyList( pxTCB );
1050  					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1051  					{
1052  						taskYIELD_IF_USING_PREEMPTION();
1053  					}
1054  					else
1055  					{
1056  						mtCOVERAGE_TEST_MARKER();
1057  					}
1058  				}
1059  				else
1060  				{
1061  					mtCOVERAGE_TEST_MARKER();
1062  				}
1063  			}
1064  			taskEXIT_CRITICAL();
1065  		}
1066  		else
1067  		{
1068  			mtCOVERAGE_TEST_MARKER();
1069  		}
1070  	}
1071  #endif &bsol;* INCLUDE_vTaskSuspend */
1072  #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1073  	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1074  	{
1075  	BaseType_t xYieldRequired = pdFALSE;
1076  	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1077  	UBaseType_t uxSavedInterruptStatus;
1078  		configASSERT( xTaskToResume );
1079  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1080  		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1081  		{
1082  			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1083  			{
1084  				traceTASK_RESUME_FROM_ISR( pxTCB );
1085  				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1086  				{
1087  					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1088  					{
1089  						xYieldRequired = pdTRUE;
1090  					}
1091  					else
1092  					{
1093  						mtCOVERAGE_TEST_MARKER();
1094  					}
1095  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1096  					prvAddTaskToReadyList( pxTCB );
1097  				}
1098  				else
1099  				{
1100  					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1101  				}
1102  			}
1103  			else
1104  			{
1105  				mtCOVERAGE_TEST_MARKER();
1106  			}
1107  		}
1108  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1109  		return xYieldRequired;
1110  	}
1111  #endif &bsol;* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1112  void vTaskStartScheduler( void )
1113  {
1114  BaseType_t xReturn;
1115  	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1116  	{
1117  		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1118  		StackType_t *pxIdleTaskStackBuffer = NULL;
1119  		uint32_t ulIdleTaskStackSize;
1120  		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
1121  		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1122  												configIDLE_TASK_NAME,
1123  												ulIdleTaskStackSize,
1124  												( void * ) NULL, &bsol;*lint !e961.  The cast is not redundant for all compilers. */
1125  												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1126  												pxIdleTaskStackBuffer,
1127  												pxIdleTaskTCBBuffer ); &bsol;*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1128  		if( xIdleTaskHandle != NULL )
1129  		{
1130  			xReturn = pdPASS;
1131  		}
1132  		else
1133  		{
1134  			xReturn = pdFAIL;
1135  		}
1136  	}
1137  	#else
1138  	{
1139  		xReturn = xTaskCreate(	prvIdleTask,
1140  								configIDLE_TASK_NAME,
1141  								configMINIMAL_STACK_SIZE,
1142  								( void * ) NULL,
1143  								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1144  								&xIdleTaskHandle ); &bsol;*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1145  	}
1146  	#endif &bsol;* configSUPPORT_STATIC_ALLOCATION */
1147  	#if ( configUSE_TIMERS == 1 )
1148  	{
1149  		if( xReturn == pdPASS )
1150  		{
1151  			xReturn = xTimerCreateTimerTask();
1152  		}
1153  		else
1154  		{
1155  			mtCOVERAGE_TEST_MARKER();
1156  		}
1157  	}
1158  	#endif &bsol;* configUSE_TIMERS */
1159  	if( xReturn == pdPASS )
1160  	{
1161  		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
1162  		{
1163  			freertos_tasks_c_additions_init();
1164  		}
1165  		#endif
1166  		portDISABLE_INTERRUPTS();
1167  		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1168  		{
1169  			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1170  		}
1171  		#endif &bsol;* configUSE_NEWLIB_REENTRANT */
1172  		xNextTaskUnblockTime = portMAX_DELAY;
1173  		xSchedulerRunning = pdTRUE;
1174  		xTickCount = ( TickType_t ) 0U;
1175  		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1176  		if( xPortStartScheduler() != pdFALSE )
1177  		{
1178  		}
1179  		else
1180  		{
1181  		}
1182  	}
1183  	else
1184  	{
1185  		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
1186  	}
1187  	( void ) xIdleTaskHandle;
1188  }
1189  void vTaskEndScheduler( void )
1190  {
1191  	portDISABLE_INTERRUPTS();
1192  	xSchedulerRunning = pdFALSE;
1193  	vPortEndScheduler();
1194  }
1195  void vTaskSuspendAll( void )
1196  {
1197  	++uxSchedulerSuspended;
1198  }
1199  #if ( configUSE_TICKLESS_IDLE != 0 )
1200  	static TickType_t prvGetExpectedIdleTime( void )
1201  	{
1202  	TickType_t xReturn;
1203  	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1204  		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1205  		{
1206  			if( uxTopReadyPriority > tskIDLE_PRIORITY )
1207  			{
1208  				uxHigherPriorityReadyTasks = pdTRUE;
1209  			}
1210  		}
1211  		#else
1212  		{
1213  			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1214  			if( uxTopReadyPriority > uxLeastSignificantBit )
1215  			{
1216  				uxHigherPriorityReadyTasks = pdTRUE;
1217  			}
1218  		}
1219  		#endif
1220  		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1221  		{
1222  			xReturn = 0;
1223  		}
1224  		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1225  		{
1226  			xReturn = 0;
1227  		}
1228  		else if( uxHigherPriorityReadyTasks != pdFALSE )
1229  		{
1230  			xReturn = 0;
1231  		}
1232  		else
1233  		{
1234  			xReturn = xNextTaskUnblockTime - xTickCount;
1235  		}
1236  		return xReturn;
1237  	}
1238  #endif &bsol;* configUSE_TICKLESS_IDLE */
1239  BaseType_t xTaskResumeAll( void )
1240  {
1241  TCB_t *pxTCB = NULL;
1242  BaseType_t xAlreadyYielded = pdFALSE;
1243  	configASSERT( uxSchedulerSuspended );
1244  	taskENTER_CRITICAL();
1245  	{
1246  		--uxSchedulerSuspended;
1247  		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1248  		{
1249  			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
1250  			{
1251  				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
1252  				{
1253  					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
1254  					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1255  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1256  					prvAddTaskToReadyList( pxTCB );
1257  					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1258  					{
1259  						xYieldPending = pdTRUE;
1260  					}
1261  					else
1262  					{
1263  						mtCOVERAGE_TEST_MARKER();
1264  					}
1265  				}
1266  				if( pxTCB != NULL )
1267  				{
1268  					prvResetNextTaskUnblockTime();
1269  				}
1270  				{
1271  					UBaseType_t uxPendedCounts = uxPendedTicks; &bsol;* Non-volatile copy. */
1272  					if( uxPendedCounts > ( UBaseType_t ) 0U )
1273  					{
1274  						do
1275  						{
1276  							if( xTaskIncrementTick() != pdFALSE )
1277  							{
1278  								xYieldPending = pdTRUE;
1279  							}
1280  							else
1281  							{
1282  								mtCOVERAGE_TEST_MARKER();
1283  							}
1284  							--uxPendedCounts;
1285  						} while( uxPendedCounts > ( UBaseType_t ) 0U );
1286  						uxPendedTicks = 0;
1287  					}
1288  					else
1289  					{
1290  						mtCOVERAGE_TEST_MARKER();
1291  					}
1292  				}
1293  				if( xYieldPending != pdFALSE )
1294  				{
1295  					#if( configUSE_PREEMPTION != 0 )
1296  					{
1297  						xAlreadyYielded = pdTRUE;
1298  					}
1299  					#endif
1300  					taskYIELD_IF_USING_PREEMPTION();
1301  				}
1302  				else
1303  				{
1304  					mtCOVERAGE_TEST_MARKER();
1305  				}
1306  			}
1307  		}
1308  		else
1309  		{
1310  			mtCOVERAGE_TEST_MARKER();
1311  		}
1312  	}
1313  	taskEXIT_CRITICAL();
1314  	return xAlreadyYielded;
1315  }
1316  TickType_t xTaskGetTickCount( void )
1317  {
1318  TickType_t xTicks;
1319  	portTICK_TYPE_ENTER_CRITICAL();
1320  	{
1321  		xTicks = xTickCount;
1322  	}
1323  	portTICK_TYPE_EXIT_CRITICAL();
1324  	return xTicks;
1325  }
1326  TickType_t xTaskGetTickCountFromISR( void )
1327  {
1328  TickType_t xReturn;
1329  UBaseType_t uxSavedInterruptStatus;
1330  	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1331  	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
1332  	{
1333  		xReturn = xTickCount;
1334  	}
1335  	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1336  	return xReturn;
1337  }
1338  UBaseType_t uxTaskGetNumberOfTasks( void )
1339  {
1340  	return uxCurrentNumberOfTasks;
1341  }
1342  char *pcTaskGetName( TaskHandle_t xTaskToQuery ) &bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
1343  {
1344  TCB_t *pxTCB;
1345  	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1346  	configASSERT( pxTCB );
1347  	return &( pxTCB->pcTaskName[ 0 ] );
1348  }
1349  #if ( INCLUDE_xTaskGetHandle == 1 )
1350  	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
1351  	{
1352  	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
1353  	UBaseType_t x;
1354  	char cNextChar;
1355  		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
1356  		{
1357  			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
1358  			do
1359  			{
1360  				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
1361  				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
1362  				{
1363  					cNextChar = pxNextTCB->pcTaskName[ x ];
1364  					if( cNextChar != pcNameToQuery[ x ] )
1365  					{
1366  						break;
1367  					}
1368  					else if( cNextChar == 0x00 )
1369  					{
1370  						pxReturn = pxNextTCB;
1371  						break;
1372  					}
1373  					else
1374  					{
1375  						mtCOVERAGE_TEST_MARKER();
1376  					}
1377  				}
1378  				if( pxReturn != NULL )
1379  				{
1380  					break;
1381  				}
1382  			} while( pxNextTCB != pxFirstTCB );
1383  		}
1384  		else
1385  		{
1386  			mtCOVERAGE_TEST_MARKER();
1387  		}
1388  		return pxReturn;
1389  	}
1390  #endif &bsol;* INCLUDE_xTaskGetHandle */
1391  #if ( INCLUDE_xTaskGetHandle == 1 )
1392  	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) &bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
1393  	{
1394  	UBaseType_t uxQueue = configMAX_PRIORITIES;
1395  	TCB_t* pxTCB;
1396  		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
1397  		vTaskSuspendAll();
1398  		{
1399  			do
1400  			{
1401  				uxQueue--;
1402  				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
1403  				if( pxTCB != NULL )
1404  				{
1405  					break;
1406  				}
1407  			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1408  			if( pxTCB == NULL )
1409  			{
1410  				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
1411  			}
1412  			if( pxTCB == NULL )
1413  			{
1414  				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
1415  			}
1416  			#if ( INCLUDE_vTaskSuspend == 1 )
1417  			{
1418  				if( pxTCB == NULL )
1419  				{
1420  					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
1421  				}
1422  			}
1423  			#endif
1424  			#if( INCLUDE_vTaskDelete == 1 )
1425  			{
1426  				if( pxTCB == NULL )
1427  				{
1428  					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
1429  				}
1430  			}
1431  			#endif
1432  		}
1433  		( void ) xTaskResumeAll();
1434  		return ( TaskHandle_t ) pxTCB;
1435  	}
1436  #endif &bsol;* INCLUDE_xTaskGetHandle */
1437  #if ( configUSE_TRACE_FACILITY == 1 )
1438  	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
1439  	{
1440  	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1441  		vTaskSuspendAll();
1442  		{
1443  			if( uxArraySize >= uxCurrentNumberOfTasks )
1444  			{
1445  				do
1446  				{
1447  					uxQueue--;
1448  					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
1449  				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1450  				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
1451  				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
1452  				#if( INCLUDE_vTaskDelete == 1 )
1453  				{
1454  					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
1455  				}
1456  				#endif
1457  				#if ( INCLUDE_vTaskSuspend == 1 )
1458  				{
1459  					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
1460  				}
1461  				#endif
1462  				#if ( configGENERATE_RUN_TIME_STATS == 1)
1463  				{
1464  					if( pulTotalRunTime != NULL )
1465  					{
1466  						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1467  							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1468  						#else
1469  							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1470  						#endif
1471  					}
1472  				}
1473  				#else
1474  				{
1475  					if( pulTotalRunTime != NULL )
1476  					{
1477  						*pulTotalRunTime = 0;
1478  					}
1479  				}
1480  				#endif
1481  			}
1482  			else
1483  			{
1484  				mtCOVERAGE_TEST_MARKER();
1485  			}
1486  		}
1487  		( void ) xTaskResumeAll();
1488  		return uxTask;
1489  	}
1490  #endif &bsol;* configUSE_TRACE_FACILITY */
1491  #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1492  	TaskHandle_t xTaskGetIdleTaskHandle( void )
1493  	{
1494  		configASSERT( ( xIdleTaskHandle != NULL ) );
1495  		return xIdleTaskHandle;
1496  	}
1497  #endif &bsol;* INCLUDE_xTaskGetIdleTaskHandle */
1498  #if ( configUSE_TICKLESS_IDLE != 0 )
1499  	void vTaskStepTick( const TickType_t xTicksToJump )
1500  	{
1501  		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1502  		xTickCount += xTicksToJump;
1503  		traceINCREASE_TICK_COUNT( xTicksToJump );
1504  	}
1505  #endif &bsol;* configUSE_TICKLESS_IDLE */
1506  #if ( INCLUDE_xTaskAbortDelay == 1 )
1507  	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
1508  	{
1509  	TCB_t *pxTCB = ( TCB_t * ) xTask;
1510  	BaseType_t xReturn;
1511  		configASSERT( pxTCB );
1512  		vTaskSuspendAll();
1513  		{
1514  			if( eTaskGetState( xTask ) == eBlocked )
1515  			{
1516  				xReturn = pdPASS;
1517  				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1518  				taskENTER_CRITICAL();
1519  				{
1520  					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1521  					{
1522  						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1523  						pxTCB->ucDelayAborted = pdTRUE;
1524  					}
1525  					else
1526  					{
1527  						mtCOVERAGE_TEST_MARKER();
1528  					}
1529  				}
1530  				taskEXIT_CRITICAL();
1531  				prvAddTaskToReadyList( pxTCB );
1532  				#if (  configUSE_PREEMPTION == 1 )
1533  				{
1534  					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
1535  					{
1536  						xYieldPending = pdTRUE;
1537  					}
1538  					else
1539  					{
1540  						mtCOVERAGE_TEST_MARKER();
1541  					}
1542  				}
1543  				#endif &bsol;* configUSE_PREEMPTION */
1544  			}
1545  			else
1546  			{
1547  				xReturn = pdFAIL;
1548  			}
1549  		}
1550  		( void ) xTaskResumeAll();
1551  		return xReturn;
1552  	}
1553  #endif &bsol;* INCLUDE_xTaskAbortDelay */
1554  BaseType_t xTaskIncrementTick( void )
1555  {
1556  TCB_t * pxTCB;
1557  TickType_t xItemValue;
1558  BaseType_t xSwitchRequired = pdFALSE;
1559  	traceTASK_INCREMENT_TICK( xTickCount );
1560  	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1561  	{
1562  		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
1563  		xTickCount = xConstTickCount;
1564  		if( xConstTickCount == ( TickType_t ) 0U ) &bsol;*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
1565  		{
1566  			taskSWITCH_DELAYED_LISTS();
1567  		}
1568  		else
1569  		{
1570  			mtCOVERAGE_TEST_MARKER();
1571  		}
1572  		if( xConstTickCount >= xNextTaskUnblockTime )
1573  		{
1574  			for( ;; )
1575  			{
1576  				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1577  				{
1578  					xNextTaskUnblockTime = portMAX_DELAY; &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1579  					break;
1580  				}
1581  				else
1582  				{
1583  					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1584  					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
1585  					if( xConstTickCount < xItemValue )
1586  					{
1587  						xNextTaskUnblockTime = xItemValue;
1588  						break;
1589  					}
1590  					else
1591  					{
1592  						mtCOVERAGE_TEST_MARKER();
1593  					}
1594  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1595  					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1596  					{
1597  						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1598  					}
1599  					else
1600  					{
1601  						mtCOVERAGE_TEST_MARKER();
1602  					}
1603  					prvAddTaskToReadyList( pxTCB );
1604  					#if (  configUSE_PREEMPTION == 1 )
1605  					{
1606  						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1607  						{
1608  							xSwitchRequired = pdTRUE;
1609  						}
1610  						else
1611  						{
1612  							mtCOVERAGE_TEST_MARKER();
1613  						}
1614  					}
1615  					#endif &bsol;* configUSE_PREEMPTION */
1616  				}
1617  			}
1618  		}
1619  		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1620  		{
1621  			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
1622  			{
1623  				xSwitchRequired = pdTRUE;
1624  			}
1625  			else
1626  			{
1627  				mtCOVERAGE_TEST_MARKER();
1628  			}
1629  		}
1630  		#endif &bsol;* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1631  		#if ( configUSE_TICK_HOOK == 1 )
1632  		{
1633  			if( uxPendedTicks == ( UBaseType_t ) 0U )
1634  			{
1635  				vApplicationTickHook();
1636  			}
1637  			else
1638  			{
1639  				mtCOVERAGE_TEST_MARKER();
1640  			}
1641  		}
1642  		#endif &bsol;* configUSE_TICK_HOOK */
1643  	}
1644  	else
1645  	{
1646  		++uxPendedTicks;
1647  		#if ( configUSE_TICK_HOOK == 1 )
1648  		{
1649  			vApplicationTickHook();
1650  		}
1651  		#endif
1652  	}
1653  	#if ( configUSE_PREEMPTION == 1 )
1654  	{
1655  		if( xYieldPending != pdFALSE )
1656  		{
1657  			xSwitchRequired = pdTRUE;
1658  		}
1659  		else
1660  		{
1661  			mtCOVERAGE_TEST_MARKER();
1662  		}
1663  	}
1664  	#endif &bsol;* configUSE_PREEMPTION */
1665  	return xSwitchRequired;
1666  }
1667  #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1668  	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
1669  	{
1670  	TCB_t *xTCB;
1671  		if( xTask == NULL )
1672  		{
1673  			xTCB = ( TCB_t * ) pxCurrentTCB;
1674  		}
1675  		else
1676  		{
1677  			xTCB = ( TCB_t * ) xTask;
1678  		}
1679  		taskENTER_CRITICAL();
1680  			xTCB->pxTaskTag = pxHookFunction;
1681  		taskEXIT_CRITICAL();
1682  	}
1683  #endif &bsol;* configUSE_APPLICATION_TASK_TAG */
1684  #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1685  	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
1686  	{
1687  	TCB_t *xTCB;
1688  	TaskHookFunction_t xReturn;
1689  		if( xTask == NULL )
1690  		{
1691  			xTCB = ( TCB_t * ) pxCurrentTCB;
1692  		}
1693  		else
1694  		{
1695  			xTCB = ( TCB_t * ) xTask;
1696  		}
1697  		taskENTER_CRITICAL();
1698  		{
1699  			xReturn = xTCB->pxTaskTag;
1700  		}
1701  		taskEXIT_CRITICAL();
1702  		return xReturn;
1703  	}
1704  #endif &bsol;* configUSE_APPLICATION_TASK_TAG */
1705  #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1706  	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
1707  	{
1708  	TCB_t *xTCB;
1709  	BaseType_t xReturn;
1710  		if( xTask == NULL )
1711  		{
1712  			xTCB = ( TCB_t * ) pxCurrentTCB;
1713  		}
1714  		else
1715  		{
1716  			xTCB = ( TCB_t * ) xTask;
1717  		}
1718  		if( xTCB->pxTaskTag != NULL )
1719  		{
1720  			xReturn = xTCB->pxTaskTag( pvParameter );
1721  		}
1722  		else
1723  		{
1724  			xReturn = pdFAIL;
1725  		}
1726  		return xReturn;
1727  	}
1728  #endif &bsol;* configUSE_APPLICATION_TASK_TAG */
1729  void vTaskSwitchContext( void )
1730  {
1731  	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
1732  	{
1733  		xYieldPending = pdTRUE;
1734  	}
1735  	else
1736  	{
1737  		xYieldPending = pdFALSE;
1738  		traceTASK_SWITCHED_OUT();
1739  		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1740  		{
1741  				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1742  					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1743  				#else
1744  					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1745  				#endif
1746  				if( ulTotalRunTime > ulTaskSwitchedInTime )
1747  				{
1748  					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
1749  				}
1750  				else
1751  				{
1752  					mtCOVERAGE_TEST_MARKER();
1753  				}
1754  				ulTaskSwitchedInTime = ulTotalRunTime;
1755  		}
1756  		#endif &bsol;* configGENERATE_RUN_TIME_STATS */
1757  		taskCHECK_FOR_STACK_OVERFLOW();
1758  		taskSELECT_HIGHEST_PRIORITY_TASK();
1759  		traceTASK_SWITCHED_IN();
1760  		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1761  		{
1762  			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1763  		}
1764  		#endif &bsol;* configUSE_NEWLIB_REENTRANT */
1765  	}
1766  }
1767  void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
1768  {
1769  	configASSERT( pxEventList );
1770  	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1771  	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
1772  }
1773  void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
1774  {
1775  	configASSERT( pxEventList );
1776  	configASSERT( uxSchedulerSuspended != 0 );
1777  	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
1778  	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1779  	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
1780  }
1781  #if( configUSE_TIMERS == 1 )
1782  	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
1783  	{
1784  		configASSERT( pxEventList );
1785  		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1786  		if( xWaitIndefinitely != pdFALSE )
1787  		{
1788  			xTicksToWait = portMAX_DELAY;
1789  		}
1790  		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
1791  		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
1792  	}
1793  #endif &bsol;* configUSE_TIMERS */
1794  BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
1795  {
1796  TCB_t *pxUnblockedTCB;
1797  BaseType_t xReturn;
1798  	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1799  	configASSERT( pxUnblockedTCB );
1800  	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
1801  	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1802  	{
1803  		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
1804  		prvAddTaskToReadyList( pxUnblockedTCB );
1805  	}
1806  	else
1807  	{
1808  		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1809  	}
1810  	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
1811  	{
1812  		xReturn = pdTRUE;
1813  		xYieldPending = pdTRUE;
1814  	}
1815  	else
1816  	{
1817  		xReturn = pdFALSE;
1818  	}
1819  	#if( configUSE_TICKLESS_IDLE != 0 )
1820  	{
1821  		prvResetNextTaskUnblockTime();
1822  	}
1823  	#endif
1824  	return xReturn;
1825  }
1826  void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
1827  {
1828  TCB_t *pxUnblockedTCB;
1829  	configASSERT( uxSchedulerSuspended != pdFALSE );
1830  	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
1831  	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
1832  	configASSERT( pxUnblockedTCB );
1833  	( void ) uxListRemove( pxEventListItem );
1834  	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
1835  	prvAddTaskToReadyList( pxUnblockedTCB );
1836  	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
1837  	{
1838  		xYieldPending = pdTRUE;
1839  	}
1840  }
1841  void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
1842  {
1843  	configASSERT( pxTimeOut );
1844  	taskENTER_CRITICAL();
1845  	{
1846  		pxTimeOut->xOverflowCount = xNumOfOverflows;
1847  		pxTimeOut->xTimeOnEntering = xTickCount;
1848  	}
1849  	taskEXIT_CRITICAL();
1850  }
1851  void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
1852  {
1853  	pxTimeOut->xOverflowCount = xNumOfOverflows;
1854  	pxTimeOut->xTimeOnEntering = xTickCount;
1855  }
1856  BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
1857  {
1858  BaseType_t xReturn;
1859  	configASSERT( pxTimeOut );
1860  	configASSERT( pxTicksToWait );
1861  	taskENTER_CRITICAL();
1862  	{
1863  		const TickType_t xConstTickCount = xTickCount;
1864  		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
1865  		#if( INCLUDE_xTaskAbortDelay == 1 )
1866  			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
1867  			{
1868  				pxCurrentTCB->ucDelayAborted = pdFALSE;
1869  				xReturn = pdTRUE;
1870  			}
1871  			else
1872  		#endif
1873  		#if ( INCLUDE_vTaskSuspend == 1 )
1874  			if( *pxTicksToWait == portMAX_DELAY )
1875  			{
1876  				xReturn = pdFALSE;
1877  			}
1878  			else
1879  		#endif
1880  		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) &bsol;*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
1881  		{
1882  			xReturn = pdTRUE;
1883  		}
1884  		else if( xElapsedTime < *pxTicksToWait ) &bsol;*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
1885  		{
1886  			*pxTicksToWait -= xElapsedTime;
1887  			vTaskInternalSetTimeOutState( pxTimeOut );
1888  			xReturn = pdFALSE;
1889  		}
1890  		else
1891  		{
1892  			*pxTicksToWait = 0;
1893  			xReturn = pdTRUE;
1894  		}
1895  	}
1896  	taskEXIT_CRITICAL();
1897  	return xReturn;
1898  }
1899  void vTaskMissedYield( void )
1900  {
1901  	xYieldPending = pdTRUE;
1902  }
1903  #if ( configUSE_TRACE_FACILITY == 1 )
1904  	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
1905  	{
1906  	UBaseType_t uxReturn;
1907  	TCB_t *pxTCB;
1908  		if( xTask != NULL )
1909  		{
1910  			pxTCB = ( TCB_t * ) xTask;
1911  			uxReturn = pxTCB->uxTaskNumber;
1912  		}
1913  		else
1914  		{
1915  			uxReturn = 0U;
1916  		}
1917  		return uxReturn;
1918  	}
1919  #endif &bsol;* configUSE_TRACE_FACILITY */
1920  #if ( configUSE_TRACE_FACILITY == 1 )
1921  	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
1922  	{
1923  	TCB_t *pxTCB;
1924  		if( xTask != NULL )
1925  		{
1926  			pxTCB = ( TCB_t * ) xTask;
1927  			pxTCB->uxTaskNumber = uxHandle;
1928  		}
1929  	}
1930  #endif &bsol;* configUSE_TRACE_FACILITY */
1931  static portTASK_FUNCTION( prvIdleTask, pvParameters )
1932  {
1933  	( void ) pvParameters;
1934  	portTASK_CALLS_SECURE_FUNCTIONS();
1935  	for( ;; )
1936  	{
1937  		prvCheckTasksWaitingTermination();
1938  		#if ( configUSE_PREEMPTION == 0 )
1939  		{
1940  			taskYIELD();
1941  		}
1942  		#endif &bsol;* configUSE_PREEMPTION */
1943  		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1944  		{
1945  			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
1946  			{
1947  				taskYIELD();
1948  			}
1949  			else
1950  			{
1951  				mtCOVERAGE_TEST_MARKER();
1952  			}
1953  		}
1954  		#endif &bsol;* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
1955  		#if ( configUSE_IDLE_HOOK == 1 )
1956  		{
1957  			extern void vApplicationIdleHook( void );
1958  			vApplicationIdleHook();
1959  		}
1960  		#endif &bsol;* configUSE_IDLE_HOOK */
1961  		#if ( configUSE_TICKLESS_IDLE != 0 )
1962  		{
1963  		TickType_t xExpectedIdleTime;
1964  			xExpectedIdleTime = prvGetExpectedIdleTime();
1965  			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
1966  			{
1967  				vTaskSuspendAll();
1968  				{
1969  					configASSERT( xNextTaskUnblockTime >= xTickCount );
1970  					xExpectedIdleTime = prvGetExpectedIdleTime();
1971  					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
1972  					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
1973  					{
1974  						traceLOW_POWER_IDLE_BEGIN();
1975  						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
1976  						traceLOW_POWER_IDLE_END();
1977  					}
1978  					else
1979  					{
1980  						mtCOVERAGE_TEST_MARKER();
1981  					}
1982  				}
1983  				( void ) xTaskResumeAll();
1984  			}
1985  			else
1986  			{
1987  				mtCOVERAGE_TEST_MARKER();
1988  			}
1989  		}
1990  		#endif &bsol;* configUSE_TICKLESS_IDLE */
1991  	}
1992  }
1993  #if( configUSE_TICKLESS_IDLE != 0 )
1994  	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
1995  	{
1996  	const UBaseType_t uxNonApplicationTasks = 1;
1997  	eSleepModeStatus eReturn = eStandardSleep;
1998  		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
1999  		{
2000  			eReturn = eAbortSleep;
2001  		}
2002  		else if( xYieldPending != pdFALSE )
2003  		{
2004  			eReturn = eAbortSleep;
2005  		}
2006  		else
2007  		{
2008  			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
2009  			{
2010  				eReturn = eNoTasksWaitingTimeout;
2011  			}
2012  			else
2013  			{
2014  				mtCOVERAGE_TEST_MARKER();
2015  			}
2016  		}
2017  		return eReturn;
2018  	}
2019  #endif &bsol;* configUSE_TICKLESS_IDLE */
2020  #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2021  	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
2022  	{
2023  	TCB_t *pxTCB;
2024  		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2025  		{
2026  			pxTCB = prvGetTCBFromHandle( xTaskToSet );
2027  			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
2028  		}
2029  	}
2030  #endif &bsol;* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2031  #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2032  	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
2033  	{
2034  	void *pvReturn = NULL;
2035  	TCB_t *pxTCB;
2036  		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2037  		{
2038  			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2039  			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
2040  		}
2041  		else
2042  		{
2043  			pvReturn = NULL;
2044  		}
2045  		return pvReturn;
2046  	}
2047  #endif &bsol;* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2048  #if ( portUSING_MPU_WRAPPERS == 1 )
2049  	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2050  	{
2051  	TCB_t *pxTCB;
2052  		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2053  		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2054  	}
2055  #endif &bsol;* portUSING_MPU_WRAPPERS */
2056  static void prvInitialiseTaskLists( void )
2057  {
2058  UBaseType_t uxPriority;
2059  	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
2060  	{
2061  		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
2062  	}
2063  	vListInitialise( &xDelayedTaskList1 );
2064  	vListInitialise( &xDelayedTaskList2 );
2065  	vListInitialise( &xPendingReadyList );
2066  	#if ( INCLUDE_vTaskDelete == 1 )
2067  	{
2068  		vListInitialise( &xTasksWaitingTermination );
2069  	}
2070  	#endif &bsol;* INCLUDE_vTaskDelete */
2071  	#if ( INCLUDE_vTaskSuspend == 1 )
2072  	{
2073  		vListInitialise( &xSuspendedTaskList );
2074  	}
2075  	#endif &bsol;* INCLUDE_vTaskSuspend */
2076  	pxDelayedTaskList = &xDelayedTaskList1;
2077  	pxOverflowDelayedTaskList = &xDelayedTaskList2;
2078  }
2079  static void prvCheckTasksWaitingTermination( void )
2080  {
2081  	#if ( INCLUDE_vTaskDelete == 1 )
2082  	{
2083  		TCB_t *pxTCB;
2084  		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
2085  		{
2086  			taskENTER_CRITICAL();
2087  			{
2088  				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
2089  				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2090  				--uxCurrentNumberOfTasks;
2091  				--uxDeletedTasksWaitingCleanUp;
2092  			}
2093  			taskEXIT_CRITICAL();
2094  			prvDeleteTCB( pxTCB );
2095  		}
2096  	}
2097  	#endif &bsol;* INCLUDE_vTaskDelete */
2098  }
2099  #if( configUSE_TRACE_FACILITY == 1 )
2100  	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
2101  	{
2102  	TCB_t *pxTCB;
2103  		pxTCB = prvGetTCBFromHandle( xTask );
2104  		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
2105  		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
2106  		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
2107  		pxTaskStatus->pxStackBase = pxTCB->pxStack;
2108  		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
2109  		#if ( configUSE_MUTEXES == 1 )
2110  		{
2111  			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
2112  		}
2113  		#else
2114  		{
2115  			pxTaskStatus->uxBasePriority = 0;
2116  		}
2117  		#endif
2118  		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2119  		{
2120  			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
2121  		}
2122  		#else
2123  		{
2124  			pxTaskStatus->ulRunTimeCounter = 0;
2125  		}
2126  		#endif
2127  		if( eState != eInvalid )
2128  		{
2129  			if( pxTCB == pxCurrentTCB )
2130  			{
2131  				pxTaskStatus->eCurrentState = eRunning;
2132  			}
2133  			else
2134  			{
2135  				pxTaskStatus->eCurrentState = eState;
2136  				#if ( INCLUDE_vTaskSuspend == 1 )
2137  				{
2138  					if( eState == eSuspended )
2139  					{
2140  						vTaskSuspendAll();
2141  						{
2142  							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2143  							{
2144  								pxTaskStatus->eCurrentState = eBlocked;
2145  							}
2146  						}
2147  						( void ) xTaskResumeAll();
2148  					}
2149  				}
2150  				#endif &bsol;* INCLUDE_vTaskSuspend */
2151  			}
2152  		}
2153  		else
2154  		{
2155  			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
2156  		}
2157  		if( xGetFreeStackSpace != pdFALSE )
2158  		{
2159  			#if ( portSTACK_GROWTH > 0 )
2160  			{
2161  				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
2162  			}
2163  			#else
2164  			{
2165  				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
2166  			}
2167  			#endif
2168  		}
2169  		else
2170  		{
2171  			pxTaskStatus->usStackHighWaterMark = 0;
2172  		}
2173  	}
2174  #endif &bsol;* configUSE_TRACE_FACILITY */
2175  #if ( configUSE_TRACE_FACILITY == 1 )
2176  	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
2177  	{
2178  	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
2179  	UBaseType_t uxTask = 0;
2180  		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2181  		{
2182  			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2183  			do
2184  			{
2185  				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2186  				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
2187  				uxTask++;
2188  			} while( pxNextTCB != pxFirstTCB );
2189  		}
2190  		else
2191  		{
2192  			mtCOVERAGE_TEST_MARKER();
2193  		}
2194  		return uxTask;
2195  	}
2196  #endif &bsol;* configUSE_TRACE_FACILITY */
2197  #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2198  	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
2199  	{
2200  	uint32_t ulCount = 0U;
2201  		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
2202  		{
2203  			pucStackByte -= portSTACK_GROWTH;
2204  			ulCount++;
2205  		}
2206  		ulCount /= ( uint32_t ) sizeof( StackType_t ); &bsol;*lint !e961 Casting is not redundant on smaller architectures. */
2207  		return ( uint16_t ) ulCount;
2208  	}
2209  #endif &bsol;* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
2210  #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2211  	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
2212  	{
2213  	TCB_t *pxTCB;
2214  	uint8_t *pucEndOfStack;
2215  	UBaseType_t uxReturn;
2216  		pxTCB = prvGetTCBFromHandle( xTask );
2217  		#if portSTACK_GROWTH < 0
2218  		{
2219  			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
2220  		}
2221  		#else
2222  		{
2223  			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
2224  		}
2225  		#endif
2226  		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
2227  		return uxReturn;
2228  	}
2229  #endif &bsol;* INCLUDE_uxTaskGetStackHighWaterMark */
2230  #if (INCLUDE_pxTaskGetStackStart == 1)
2231  	uint8_t* pxTaskGetStackStart( TaskHandle_t xTask)
2232  	{
2233  	    TCB_t *pxTCB;
2234  	    UBaseType_t uxReturn;
2235          (void)uxReturn;
2236  		pxTCB = prvGetTCBFromHandle( xTask );
2237  		return ( uint8_t * ) pxTCB->pxStack;
2238  	}
2239  #endif &bsol;* INCLUDE_pxTaskGetStackStart */
2240  #if ( INCLUDE_vTaskDelete == 1 )
2241  	static void prvDeleteTCB( TCB_t *pxTCB )
2242  	{
2243  		portCLEAN_UP_TCB( pxTCB );
2244  		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2245  		{
2246  			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
2247  		}
2248  		#endif &bsol;* configUSE_NEWLIB_REENTRANT */
2249  		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
2250  		{
2251  			vPortFree( pxTCB->pxStack );
2252  			vPortFree( pxTCB );
2253  		}
2254  		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &bsol;*lint !e731 Macro has been consolidated for readability reasons. */
2255  		{
2256  			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
2257  			{
2258  				vPortFree( pxTCB->pxStack );
2259  				vPortFree( pxTCB );
2260  			}
2261  			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
2262  			{
2263  				vPortFree( pxTCB );
2264  			}
2265  			else
2266  			{
2267  				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
2268  				mtCOVERAGE_TEST_MARKER();
2269  			}
2270  		}
2271  		#endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
2272  	}
2273  #endif &bsol;* INCLUDE_vTaskDelete */
2274  static void prvResetNextTaskUnblockTime( void )
2275  {
2276  TCB_t *pxTCB;
2277  	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2278  	{
2279  		xNextTaskUnblockTime = portMAX_DELAY;
2280  	}
2281  	else
2282  	{
2283  		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
2284  		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
2285  	}
2286  }
2287  #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2288  	TaskHandle_t xTaskGetCurrentTaskHandle( void )
2289  	{
2290  	TaskHandle_t xReturn;
2291  		xReturn = pxCurrentTCB;
2292  		return xReturn;
2293  	}
2294  #endif &bsol;* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
2295  #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2296  	BaseType_t xTaskGetSchedulerState( void )
2297  	{
2298  	BaseType_t xReturn;
2299  		if( xSchedulerRunning == pdFALSE )
2300  		{
2301  			xReturn = taskSCHEDULER_NOT_STARTED;
2302  		}
2303  		else
2304  		{
2305  			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2306  			{
2307  				xReturn = taskSCHEDULER_RUNNING;
2308  			}
2309  			else
2310  			{
2311  				xReturn = taskSCHEDULER_SUSPENDED;
2312  			}
2313  		}
2314  		return xReturn;
2315  	}
2316  #endif &bsol;* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
2317  #if ( configUSE_MUTEXES == 1 )
2318  	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
2319  	{
2320  	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
2321  	BaseType_t xReturn = pdFALSE;
2322  		if( pxMutexHolder != NULL )
2323  		{
2324  			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
2325  			{
2326  				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
2327  				{
2328  					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2329  				}
2330  				else
2331  				{
2332  					mtCOVERAGE_TEST_MARKER();
2333  				}
2334  				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
2335  				{
2336  					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
2337  					{
2338  						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
2339  					}
2340  					else
2341  					{
2342  						mtCOVERAGE_TEST_MARKER();
2343  					}
2344  					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
2345  					prvReaddTaskToReadyList( pxMutexHolderTCB );
2346  				}
2347  				else
2348  				{
2349  					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
2350  				}
2351  				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
2352  				xReturn = pdTRUE;
2353  			}
2354  			else
2355  			{
2356  				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
2357  				{
2358  					xReturn = pdTRUE;
2359  				}
2360  				else
2361  				{
2362  					mtCOVERAGE_TEST_MARKER();
2363  				}
2364  			}
2365  		}
2366  		else
2367  		{
2368  			mtCOVERAGE_TEST_MARKER();
2369  		}
2370  		return xReturn;
2371  	}
2372  #endif &bsol;* configUSE_MUTEXES */
2373  #if ( configUSE_MUTEXES == 1 )
2374  	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
2375  	{
2376  	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
2377  	BaseType_t xReturn = pdFALSE;
2378  		if( pxMutexHolder != NULL )
2379  		{
2380  			configASSERT( pxTCB == pxCurrentTCB );
2381  			configASSERT( pxTCB->uxMutexesHeld );
2382  			( pxTCB->uxMutexesHeld )--;
2383  			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
2384  			{
2385  				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
2386  				{
2387  					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
2388  					{
2389  						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2390  					}
2391  					else
2392  					{
2393  						mtCOVERAGE_TEST_MARKER();
2394  					}
2395  					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2396  					pxTCB->uxPriority = pxTCB->uxBasePriority;
2397  					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2398  					prvReaddTaskToReadyList( pxTCB );
2399  					xReturn = pdTRUE;
2400  				}
2401  				else
2402  				{
2403  					mtCOVERAGE_TEST_MARKER();
2404  				}
2405  			}
2406  			else
2407  			{
2408  				mtCOVERAGE_TEST_MARKER();
2409  			}
2410  		}
2411  		else
2412  		{
2413  			mtCOVERAGE_TEST_MARKER();
2414  		}
2415  		return xReturn;
2416  	}
2417  #endif &bsol;* configUSE_MUTEXES */
2418  #if ( configUSE_MUTEXES == 1 )
2419  	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
2420  	{
2421  	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
2422  	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
2423  	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
2424  		if( pxMutexHolder != NULL )
2425  		{
2426  			configASSERT( pxTCB->uxMutexesHeld );
2427  			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
2428  			{
2429  				uxPriorityToUse = uxHighestPriorityWaitingTask;
2430  			}
2431  			else
2432  			{
2433  				uxPriorityToUse = pxTCB->uxBasePriority;
2434  			}
2435  			if( pxTCB->uxPriority != uxPriorityToUse )
2436  			{
2437  				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
2438  				{
2439  					configASSERT( pxTCB != pxCurrentTCB );
2440  					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2441  					uxPriorityUsedOnEntry = pxTCB->uxPriority;
2442  					pxTCB->uxPriority = uxPriorityToUse;
2443  					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
2444  					{
2445  						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2446  					}
2447  					else
2448  					{
2449  						mtCOVERAGE_TEST_MARKER();
2450  					}
2451  					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
2452  					{
2453  						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
2454  						{
2455  							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2456  						}
2457  						else
2458  						{
2459  							mtCOVERAGE_TEST_MARKER();
2460  						}
2461  						prvAddTaskToReadyList( pxTCB );
2462  					}
2463  					else
2464  					{
2465  						mtCOVERAGE_TEST_MARKER();
2466  					}
2467  				}
2468  				else
2469  				{
2470  					mtCOVERAGE_TEST_MARKER();
2471  				}
2472  			}
2473  			else
2474  			{
2475  				mtCOVERAGE_TEST_MARKER();
2476  			}
2477  		}
2478  		else
2479  		{
2480  			mtCOVERAGE_TEST_MARKER();
2481  		}
2482  	}
2483  #endif &bsol;* configUSE_MUTEXES */
2484  #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2485  	void vTaskEnterCritical( void )
2486  	{
2487  		portDISABLE_INTERRUPTS();
2488  		if( xSchedulerRunning != pdFALSE )
2489  		{
2490  			( pxCurrentTCB->uxCriticalNesting )++;
2491  			if( pxCurrentTCB->uxCriticalNesting == 1 )
2492  			{
2493  				portASSERT_IF_IN_ISR();
2494  			}
2495  		}
2496  		else
2497  		{
2498  			mtCOVERAGE_TEST_MARKER();
2499  		}
2500  	}
2501  #endif &bsol;* portCRITICAL_NESTING_IN_TCB */
2502  #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2503  	void vTaskExitCritical( void )
2504  	{
2505  		if( xSchedulerRunning != pdFALSE )
2506  		{
2507  			if( pxCurrentTCB->uxCriticalNesting > 0U )
2508  			{
2509  				( pxCurrentTCB->uxCriticalNesting )--;
2510  				if( pxCurrentTCB->uxCriticalNesting == 0U )
2511  				{
2512  					portENABLE_INTERRUPTS();
2513  				}
2514  				else
2515  				{
2516  					mtCOVERAGE_TEST_MARKER();
2517  				}
2518  			}
2519  			else
2520  			{
2521  				mtCOVERAGE_TEST_MARKER();
2522  			}
2523  		}
2524  		else
2525  		{
2526  			mtCOVERAGE_TEST_MARKER();
2527  		}
2528  	}
2529  #endif &bsol;* portCRITICAL_NESTING_IN_TCB */
2530  #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
2531  	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
2532  	{
2533  	size_t x;
2534  		strcpy( pcBuffer, pcTaskName );
2535  		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
2536  		{
2537  			pcBuffer[ x ] = ' ';
2538  		}
2539  		pcBuffer[ x ] = 0x00;
2540  		return &( pcBuffer[ x ] );
2541  	}
2542  #endif &bsol;* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
2543  #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2544  	void vTaskList( char * pcWriteBuffer )
2545  	{
2546  	TaskStatus_t *pxTaskStatusArray;
2547  	volatile UBaseType_t uxArraySize, x;
2548  	char cStatus;
2549  		*pcWriteBuffer = 0x00;
2550  		uxArraySize = uxCurrentNumberOfTasks;
2551  		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
2552  		if( pxTaskStatusArray != NULL )
2553  		{
2554  			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
2555  			for( x = 0; x < uxArraySize; x++ )
2556  			{
2557  				switch( pxTaskStatusArray[ x ].eCurrentState )
2558  				{
2559  					case eRunning:		cStatus = tskRUNNING_CHAR;
2560  										break;
2561  					case eReady:		cStatus = tskREADY_CHAR;
2562  										break;
2563  					case eBlocked:		cStatus = tskBLOCKED_CHAR;
2564  										break;
2565  					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
2566  										break;
2567  					case eDeleted:		cStatus = tskDELETED_CHAR;
2568  										break;
2569  					default:			&bsol;* Should not get here, but it is included
2570  										to prevent static checking errors. */
2571  										cStatus = 0x00;
2572  										break;
2573  				}
2574  				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
2575  				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
2576  				pcWriteBuffer += strlen( pcWriteBuffer );
2577  			}
2578  			vPortFree( pxTaskStatusArray );
2579  		}
2580  		else
2581  		{
2582  			mtCOVERAGE_TEST_MARKER();
2583  		}
2584  	}
2585  #endif &bsol;* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
2586  #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2587  	void vTaskGetRunTimeStats( char *pcWriteBuffer )
2588  	{
2589  	TaskStatus_t *pxTaskStatusArray;
2590  	volatile UBaseType_t uxArraySize, x;
2591  	uint32_t ulTotalTime, ulStatsAsPercentage;
2592  		#if( configUSE_TRACE_FACILITY != 1 )
2593  		{
2594  			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
2595  		}
2596  		#endif
2597  		*pcWriteBuffer = 0x00;
2598  		uxArraySize = uxCurrentNumberOfTasks;
2599  		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
2600  		if( pxTaskStatusArray != NULL )
2601  		{
2602  			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
2603  			ulTotalTime /= 100UL;
2604  			if( ulTotalTime > 0 )
2605  			{
2606  				for( x = 0; x < uxArraySize; x++ )
2607  				{
2608  					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
2609  					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
2610  					if( ulStatsAsPercentage > 0UL )
2611  					{
2612  						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2613  						{
2614  							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
2615  						}
2616  						#else
2617  						{
2618  							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
2619  						}
2620  						#endif
2621  					}
2622  					else
2623  					{
2624  						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2625  						{
2626  							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
2627  						}
2628  						#else
2629  						{
2630  							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
2631  						}
2632  						#endif
2633  					}
2634  					pcWriteBuffer += strlen( pcWriteBuffer );
2635  				}
2636  			}
2637  			else
2638  			{
2639  				mtCOVERAGE_TEST_MARKER();
2640  			}
2641  			vPortFree( pxTaskStatusArray );
2642  		}
2643  		else
2644  		{
2645  			mtCOVERAGE_TEST_MARKER();
2646  		}
2647  	}
2648  #endif &bsol;* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
2649  TickType_t uxTaskResetEventItemValue( void )
2650  {
2651  TickType_t uxReturn;
2652  	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
2653  	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2654  	return uxReturn;
2655  }
2656  #if ( configUSE_MUTEXES == 1 )
2657  	void *pvTaskIncrementMutexHeldCount( void )
2658  	{
2659  		if( pxCurrentTCB != NULL )
2660  		{
2661  			( pxCurrentTCB->uxMutexesHeld )++;
2662  		}
2663  		return pxCurrentTCB;
2664  	}
2665  #endif &bsol;* configUSE_MUTEXES */
2666  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2667  	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
2668  	{
2669  	uint32_t ulReturn;
2670  		taskENTER_CRITICAL();
2671  		{
2672  			if( pxCurrentTCB->ulNotifiedValue == 0UL )
2673  			{
2674  				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
2675  				if( xTicksToWait > ( TickType_t ) 0 )
2676  				{
2677  					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2678  					traceTASK_NOTIFY_TAKE_BLOCK();
2679  					portYIELD_WITHIN_API();
2680  				}
2681  				else
2682  				{
2683  					mtCOVERAGE_TEST_MARKER();
2684  				}
2685  			}
2686  			else
2687  			{
2688  				mtCOVERAGE_TEST_MARKER();
2689  			}
2690  		}
2691  		taskEXIT_CRITICAL();
2692  		taskENTER_CRITICAL();
2693  		{
2694  			traceTASK_NOTIFY_TAKE();
2695  			ulReturn = pxCurrentTCB->ulNotifiedValue;
2696  			if( ulReturn != 0UL )
2697  			{
2698  				if( xClearCountOnExit != pdFALSE )
2699  				{
2700  					pxCurrentTCB->ulNotifiedValue = 0UL;
2701  				}
2702  				else
2703  				{
2704  					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
2705  				}
2706  			}
2707  			else
2708  			{
2709  				mtCOVERAGE_TEST_MARKER();
2710  			}
2711  			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
2712  		}
2713  		taskEXIT_CRITICAL();
2714  		return ulReturn;
2715  	}
2716  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2717  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2718  	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
2719  	{
2720  	BaseType_t xReturn;
2721  		taskENTER_CRITICAL();
2722  		{
2723  			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
2724  			{
2725  				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
2726  				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
2727  				if( xTicksToWait > ( TickType_t ) 0 )
2728  				{
2729  					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2730  					traceTASK_NOTIFY_WAIT_BLOCK();
2731  					portYIELD_WITHIN_API();
2732  				}
2733  				else
2734  				{
2735  					mtCOVERAGE_TEST_MARKER();
2736  				}
2737  			}
2738  			else
2739  			{
2740  				mtCOVERAGE_TEST_MARKER();
2741  			}
2742  		}
2743  		taskEXIT_CRITICAL();
2744  		taskENTER_CRITICAL();
2745  		{
2746  			traceTASK_NOTIFY_WAIT();
2747  			if( pulNotificationValue != NULL )
2748  			{
2749  				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
2750  			}
2751  			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
2752  			{
2753  				xReturn = pdFALSE;
2754  			}
2755  			else
2756  			{
2757  				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
2758  				xReturn = pdTRUE;
2759  			}
2760  			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
2761  		}
2762  		taskEXIT_CRITICAL();
2763  		return xReturn;
2764  	}
2765  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2766  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2767  	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
2768  	{
2769  	TCB_t * pxTCB;
2770  	BaseType_t xReturn = pdPASS;
2771  	uint8_t ucOriginalNotifyState;
2772  		configASSERT( xTaskToNotify );
2773  		pxTCB = ( TCB_t * ) xTaskToNotify;
2774  		taskENTER_CRITICAL();
2775  		{
2776  			if( pulPreviousNotificationValue != NULL )
2777  			{
2778  				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
2779  			}
2780  			ucOriginalNotifyState = pxTCB->ucNotifyState;
2781  			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
2782  			switch( eAction )
2783  			{
2784  				case eSetBits	:
2785  					pxTCB->ulNotifiedValue |= ulValue;
2786  					break;
2787  				case eIncrement	:
2788  					( pxTCB->ulNotifiedValue )++;
2789  					break;
2790  				case eSetValueWithOverwrite	:
2791  					pxTCB->ulNotifiedValue = ulValue;
2792  					break;
2793  				case eSetValueWithoutOverwrite :
2794  					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
2795  					{
2796  						pxTCB->ulNotifiedValue = ulValue;
2797  					}
2798  					else
2799  					{
2800  						xReturn = pdFAIL;
2801  					}
2802  					break;
2803  				case eNoAction:
2804  					break;
2805  			}
2806  			traceTASK_NOTIFY();
2807  			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
2808  			{
2809  				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2810  				prvAddTaskToReadyList( pxTCB );
2811  				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
2812  				#if( configUSE_TICKLESS_IDLE != 0 )
2813  				{
2814  					prvResetNextTaskUnblockTime();
2815  				}
2816  				#endif
2817  				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2818  				{
2819  					taskYIELD_IF_USING_PREEMPTION();
2820  				}
2821  				else
2822  				{
2823  					mtCOVERAGE_TEST_MARKER();
2824  				}
2825  			}
2826  			else
2827  			{
2828  				mtCOVERAGE_TEST_MARKER();
2829  			}
2830  		}
2831  		taskEXIT_CRITICAL();
2832  		return xReturn;
2833  	}
2834  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2835  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2836  	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
2837  	{
2838  	TCB_t * pxTCB;
2839  	uint8_t ucOriginalNotifyState;
2840  	BaseType_t xReturn = pdPASS;
2841  	UBaseType_t uxSavedInterruptStatus;
2842  		configASSERT( xTaskToNotify );
2843  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2844  		pxTCB = ( TCB_t * ) xTaskToNotify;
2845  		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2846  		{
2847  			if( pulPreviousNotificationValue != NULL )
2848  			{
2849  				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
2850  			}
2851  			ucOriginalNotifyState = pxTCB->ucNotifyState;
2852  			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
2853  			switch( eAction )
2854  			{
2855  				case eSetBits	:
2856  					pxTCB->ulNotifiedValue |= ulValue;
2857  					break;
2858  				case eIncrement	:
2859  					( pxTCB->ulNotifiedValue )++;
2860  					break;
2861  				case eSetValueWithOverwrite	:
2862  					pxTCB->ulNotifiedValue = ulValue;
2863  					break;
2864  				case eSetValueWithoutOverwrite :
2865  					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
2866  					{
2867  						pxTCB->ulNotifiedValue = ulValue;
2868  					}
2869  					else
2870  					{
2871  						xReturn = pdFAIL;
2872  					}
2873  					break;
2874  				case eNoAction :
2875  					break;
2876  			}
2877  			traceTASK_NOTIFY_FROM_ISR();
2878  			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
2879  			{
2880  				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
2881  				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2882  				{
2883  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2884  					prvAddTaskToReadyList( pxTCB );
2885  				}
2886  				else
2887  				{
2888  					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
2889  				}
2890  				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2891  				{
2892  					if( pxHigherPriorityTaskWoken != NULL )
2893  					{
2894  						*pxHigherPriorityTaskWoken = pdTRUE;
2895  					}
2896  					else
2897  					{
2898  						xYieldPending = pdTRUE;
2899  					}
2900  				}
2901  				else
2902  				{
2903  					mtCOVERAGE_TEST_MARKER();
2904  				}
2905  			}
2906  		}
2907  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2908  		return xReturn;
2909  	}
2910  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2911  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2912  	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
2913  	{
2914  	TCB_t * pxTCB;
2915  	uint8_t ucOriginalNotifyState;
2916  	UBaseType_t uxSavedInterruptStatus;
2917  		configASSERT( xTaskToNotify );
2918  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2919  		pxTCB = ( TCB_t * ) xTaskToNotify;
2920  		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2921  		{
2922  			ucOriginalNotifyState = pxTCB->ucNotifyState;
2923  			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
2924  			( pxTCB->ulNotifiedValue )++;
2925  			traceTASK_NOTIFY_GIVE_FROM_ISR();
2926  			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
2927  			{
2928  				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
2929  				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2930  				{
2931  					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2932  					prvAddTaskToReadyList( pxTCB );
2933  				}
2934  				else
2935  				{
2936  					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
2937  				}
2938  				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2939  				{
2940  					if( pxHigherPriorityTaskWoken != NULL )
2941  					{
2942  						*pxHigherPriorityTaskWoken = pdTRUE;
2943  					}
2944  					else
2945  					{
2946  						xYieldPending = pdTRUE;
2947  					}
2948  				}
2949  				else
2950  				{
2951  					mtCOVERAGE_TEST_MARKER();
2952  				}
2953  			}
2954  		}
2955  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2956  	}
2957  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2958  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2959  	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
2960  	{
2961  	TCB_t *pxTCB;
2962  	BaseType_t xReturn;
2963  		pxTCB = prvGetTCBFromHandle( xTask );
2964  		taskENTER_CRITICAL();
2965  		{
2966  			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
2967  			{
2968  				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
2969  				xReturn = pdPASS;
2970  			}
2971  			else
2972  			{
2973  				xReturn = pdFAIL;
2974  			}
2975  		}
2976  		taskEXIT_CRITICAL();
2977  		return xReturn;
2978  	}
2979  #endif &bsol;* configUSE_TASK_NOTIFICATIONS */
2980  static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
2981  {
2982  TickType_t xTimeToWake;
2983  const TickType_t xConstTickCount = xTickCount;
2984  	#if( INCLUDE_xTaskAbortDelay == 1 )
2985  	{
2986  		pxCurrentTCB->ucDelayAborted = pdFALSE;
2987  	}
2988  	#endif
2989  	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
2990  	{
2991  		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2992  	}
2993  	else
2994  	{
2995  		mtCOVERAGE_TEST_MARKER();
2996  	}
2997  	#if ( INCLUDE_vTaskSuspend == 1 )
2998  	{
2999  		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
3000  		{
3001  			traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
3002  			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
3003  		}
3004  		else
3005  		{
3006  			xTimeToWake = xConstTickCount + xTicksToWait;
3007  			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
3008  			if( xTimeToWake < xConstTickCount )
3009  			{
3010  				traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
3011  				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
3012  			}
3013  			else
3014  			{
3015  				traceMOVED_TASK_TO_DELAYED_LIST();
3016  				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
3017  				if( xTimeToWake < xNextTaskUnblockTime )
3018  				{
3019  					xNextTaskUnblockTime = xTimeToWake;
3020  				}
3021  				else
3022  				{
3023  					mtCOVERAGE_TEST_MARKER();
3024  				}
3025  			}
3026  		}
3027  	}
3028  	#else &bsol;* INCLUDE_vTaskSuspend */
3029  	{
3030  		xTimeToWake = xConstTickCount + xTicksToWait;
3031  		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
3032  		if( xTimeToWake < xConstTickCount )
3033  		{
3034  			traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
3035  			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
3036  		}
3037  		else
3038  		{
3039  			traceMOVED_TASK_TO_DELAYED_LIST();
3040  			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
3041  			if( xTimeToWake < xNextTaskUnblockTime )
3042  			{
3043  				xNextTaskUnblockTime = xTimeToWake;
3044  			}
3045  			else
3046  			{
3047  				mtCOVERAGE_TEST_MARKER();
3048  			}
3049  		}
3050  		( void ) xCanBlockIndefinitely;
3051  	}
3052  	#endif &bsol;* INCLUDE_vTaskSuspend */
3053  }
3054  #ifdef FREERTOS_MODULE_TEST
3055  	#include "tasks_test_access_functions.h"
3056  #endif
3057  #if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
3058  	#include "freertos_tasks_c_additions.h"
3059  	static void freertos_tasks_c_additions_init( void )
3060  	{
3061  		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
3062  			FREERTOS_TASKS_C_ADDITIONS_INIT();
3063  		#endif
3064  	}
3065  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-tasks.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-tasks.c</div>
                </div>
                <div class="column column_space"><pre><code>568  					pxCurrentTCB = pxNewTCB;
569  				}
570  				else
571  				{
572  					mtCOVERAGE_TEST_MARKER();
573  				}
574  			}
575  			else
576  			{
577  				mtCOVERAGE_TEST_MARKER();
</pre></code></div>
                <div class="column column_space"><pre><code>1017  					xReturn = pdTRUE;
1018  				}
1019  				else
1020  				{
1021  					mtCOVERAGE_TEST_MARKER();
1022  				}
1023  			}
1024  			else
1025  			{
1026  				mtCOVERAGE_TEST_MARKER();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    