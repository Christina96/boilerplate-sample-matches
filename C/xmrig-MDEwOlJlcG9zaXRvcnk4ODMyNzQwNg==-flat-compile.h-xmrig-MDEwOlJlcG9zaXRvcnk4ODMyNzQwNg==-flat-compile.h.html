
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-compile.h</h3>
            <pre><code>1  #ifndef FMT_COMPILE_H_
2  #define FMT_COMPILE_H_
3  #include <vector>
4  #include "format.h"
5  FMT_BEGIN_NAMESPACE
6  namespace detail {
7  class compiled_string {};
8  template <typename S>
9  struct is_compiled_string : std::is_base_of<compiled_string, S> {};
10  #define FMT_COMPILE(s) FMT_STRING_IMPL(s, fmt::detail::compiled_string)
11  template <typename T, typename... Tail>
12  const T& first(const T& value, const Tail&...) {
13    return value;
14  }
15  template <typename Char> struct format_part {
16    enum class kind { arg_index, arg_name, text, replacement };
17    struct replacement {
18      arg_ref<Char> arg_id;
19      dynamic_format_specs<Char> specs;
20    };
21    kind part_kind;
22    union value {
23      int arg_index;
24      basic_string_view<Char> str;
25      replacement repl;
26      FMT_CONSTEXPR value(int index = 0) : arg_index(index) {}
27      FMT_CONSTEXPR value(basic_string_view<Char> s) : str(s) {}
28      FMT_CONSTEXPR value(replacement r) : repl(r) {}
29    } val;
30    const Char* arg_id_end = nullptr;
31    FMT_CONSTEXPR format_part(kind k = kind::arg_index, value v = {})
32        : part_kind(k), val(v) {}
33    static FMT_CONSTEXPR format_part make_arg_index(int index) {
34      return format_part(kind::arg_index, index);
35    }
36    static FMT_CONSTEXPR format_part make_arg_name(basic_string_view<Char> name) {
37      return format_part(kind::arg_name, name);
38    }
39    static FMT_CONSTEXPR format_part make_text(basic_string_view<Char> text) {
40      return format_part(kind::text, text);
41    }
42    static FMT_CONSTEXPR format_part make_replacement(replacement repl) {
43      return format_part(kind::replacement, repl);
44    }
45  };
46  template <typename Char> struct part_counter {
47    unsigned num_parts = 0;
48    FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
49      if (begin != end) ++num_parts;
50    }
51    FMT_CONSTEXPR int on_arg_id() { return ++num_parts, 0; }
52    FMT_CONSTEXPR int on_arg_id(int) { return ++num_parts, 0; }
53    FMT_CONSTEXPR int on_arg_id(basic_string_view<Char>) {
54      return ++num_parts, 0;
55    }
56    FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}
57    FMT_CONSTEXPR const Char* on_format_specs(int, const Char* begin,
58                                              const Char* end) {
59      unsigned brace_counter = 0;
60      for (; begin != end; ++begin) {
61        if (*begin == '{') {
62          ++brace_counter;
63        } else if (*begin == '}') {
64          if (brace_counter == 0u) break;
65          --brace_counter;
66        }
67      }
68      return begin;
69    }
70    FMT_CONSTEXPR void on_error(const char*) {}
71  };
72  template <typename Char>
73  FMT_CONSTEXPR unsigned count_parts(basic_string_view<Char> format_str) {
74    part_counter<Char> counter;
75    parse_format_string<true>(format_str, counter);
76    return counter.num_parts;
77  }
78  template <typename Char, typename PartHandler>
79  class format_string_compiler : public error_handler {
80   private:
81    using part = format_part<Char>;
82    PartHandler handler_;
83    part part_;
84    basic_string_view<Char> format_str_;
85    basic_format_parse_context<Char> parse_context_;
86   public:
87    FMT_CONSTEXPR format_string_compiler(basic_string_view<Char> format_str,
88                                         PartHandler handler)
89        : handler_(handler),
90          format_str_(format_str),
91          parse_context_(format_str) {}
92    FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
93      if (begin != end)
94        handler_(part::make_text({begin, to_unsigned(end - begin)}));
95    }
96    FMT_CONSTEXPR int on_arg_id() {
97      part_ = part::make_arg_index(parse_context_.next_arg_id());
98      return 0;
99    }
100    FMT_CONSTEXPR int on_arg_id(int id) {
101      parse_context_.check_arg_id(id);
102      part_ = part::make_arg_index(id);
103      return 0;
104    }
105    FMT_CONSTEXPR int on_arg_id(basic_string_view<Char> id) {
106      part_ = part::make_arg_name(id);
107      return 0;
108    }
109    FMT_CONSTEXPR void on_replacement_field(int, const Char* ptr) {
110      part_.arg_id_end = ptr;
111      handler_(part_);
112    }
113    FMT_CONSTEXPR const Char* on_format_specs(int, const Char* begin,
114                                              const Char* end) {
115      auto repl = typename part::replacement();
116      dynamic_specs_handler<basic_format_parse_context<Char>> handler(
117          repl.specs, parse_context_);
118      auto it = parse_format_specs(begin, end, handler);
119      if (*it != '}') on_error("missing '}' in format string");
120      repl.arg_id = part_.part_kind == part::kind::arg_index
121                        ? arg_ref<Char>(part_.val.arg_index)
122                        : arg_ref<Char>(part_.val.str);
123      auto part = part::make_replacement(repl);
124      part.arg_id_end = begin;
125      handler_(part);
126      return it;
127    }
128  };
129  template <bool IS_CONSTEXPR, typename Char, typename PartHandler>
130  FMT_CONSTEXPR void compile_format_string(basic_string_view<Char> format_str,
131                                           PartHandler handler) {
132    parse_format_string<IS_CONSTEXPR>(
133        format_str,
134        format_string_compiler<Char, PartHandler>(format_str, handler));
135  }
136  template <typename OutputIt, typename Context, typename Id>
137  void format_arg(
138      basic_format_parse_context<typename Context::char_type>& parse_ctx,
139      Context& ctx, Id arg_id) {
140    ctx.advance_to(visit_format_arg(
141        arg_formatter<OutputIt, typename Context::char_type>(ctx, &parse_ctx),
142        ctx.arg(arg_id)));
143  }
144  namespace cf {
145  template <typename Context, typename OutputIt, typename CompiledFormat>
146  auto vformat_to(OutputIt out, CompiledFormat& cf,
147                  basic_format_args<Context> args) -> typename Context::iterator {
148    using char_type = typename Context::char_type;
149    basic_format_parse_context<char_type> parse_ctx(
150        to_string_view(cf.format_str_));
151    Context ctx(out, args);
152    const auto& parts = cf.parts();
153    for (auto part_it = std::begin(parts); part_it != std::end(parts);
154         ++part_it) {
155      const auto& part = *part_it;
156      const auto& value = part.val;
157      using format_part_t = format_part<char_type>;
158      switch (part.part_kind) {
159      case format_part_t::kind::text: {
160        const auto text = value.str;
161        auto output = ctx.out();
162        auto&& it = reserve(output, text.size());
163        it = std::copy_n(text.begin(), text.size(), it);
164        ctx.advance_to(output);
165        break;
166      }
167      case format_part_t::kind::arg_index:
168        advance_to(parse_ctx, part.arg_id_end);
<span onclick='openModal()' class='match'>169        detail::format_arg<OutputIt>(parse_ctx, ctx, value.arg_index);
170        break;
171      case format_part_t::kind::arg_name:
172        advance_to(parse_ctx, part.arg_id_end);
</span>173        detail::format_arg<OutputIt>(parse_ctx, ctx, value.str);
174        break;
175      case format_part_t::kind::replacement: {
176        const auto& arg_id_value = value.repl.arg_id.val;
177        const auto arg = value.repl.arg_id.kind == arg_id_kind::index
178                             ? ctx.arg(arg_id_value.index)
179                             : ctx.arg(arg_id_value.name);
180        auto specs = value.repl.specs;
181        handle_dynamic_spec<width_checker>(specs.width, specs.width_ref, ctx);
182        handle_dynamic_spec<precision_checker>(specs.precision,
183                                               specs.precision_ref, ctx);
184        error_handler h;
185        numeric_specs_checker<error_handler> checker(h, arg.type());
186        if (specs.align == align::numeric) checker.require_numeric_argument();
187        if (specs.sign != sign::none) checker.check_sign();
188        if (specs.alt) checker.require_numeric_argument();
189        if (specs.precision >= 0) checker.check_precision();
190        advance_to(parse_ctx, part.arg_id_end);
191        ctx.advance_to(
192            visit_format_arg(arg_formatter<OutputIt, typename Context::char_type>(
193                                 ctx, nullptr, &specs),
194                             arg));
195        break;
196      }
197      }
198    }
199    return ctx.out();
200  }
201  }  
202  struct basic_compiled_format {};
203  template <typename S, typename = void>
204  struct compiled_format_base : basic_compiled_format {
205    using char_type = char_t<S>;
206    using parts_container = std::vector<detail::format_part<char_type>>;
207    parts_container compiled_parts;
208    explicit compiled_format_base(basic_string_view<char_type> format_str) {
209      compile_format_string<false>(format_str,
210                                   [this](const format_part<char_type>& part) {
211                                     compiled_parts.push_back(part);
212                                   });
213    }
214    const parts_container& parts() const { return compiled_parts; }
215  };
216  template <typename Char, unsigned N> struct format_part_array {
217    format_part<Char> data[N] = {};
218    FMT_CONSTEXPR format_part_array() = default;
219  };
220  template <typename Char, unsigned N>
221  FMT_CONSTEXPR format_part_array<Char, N> compile_to_parts(
222      basic_string_view<Char> format_str) {
223    format_part_array<Char, N> parts;
224    unsigned counter = 0;
225    struct {
226      format_part<Char>* parts;
227      unsigned* counter;
228      FMT_CONSTEXPR void operator()(const format_part<Char>& part) {
229        parts[(*counter)++] = part;
230      }
231    } collector{parts.data, &counter};
232    compile_format_string<true>(format_str, collector);
233    if (counter < N) {
234      parts.data[counter] =
235          format_part<Char>::make_text(basic_string_view<Char>());
236    }
237    return parts;
238  }
239  template <typename T> constexpr const T& constexpr_max(const T& a, const T& b) {
240    return (a < b) ? b : a;
241  }
242  template <typename S>
243  struct compiled_format_base<S, enable_if_t<is_compile_string<S>::value>>
244      : basic_compiled_format {
245    using char_type = char_t<S>;
246    FMT_CONSTEXPR explicit compiled_format_base(basic_string_view<char_type>) {}
247  #if FMT_USE_CONSTEXPR
248    static FMT_CONSTEXPR_DECL const unsigned num_format_parts =
249        constexpr_max(count_parts(to_string_view(S())), 1u);
250  #else
251    static const unsigned num_format_parts = 1;
252  #endif
253    using parts_container = format_part<char_type>[num_format_parts];
254    const parts_container& parts() const {
255      static FMT_CONSTEXPR_DECL const auto compiled_parts =
256          compile_to_parts<char_type, num_format_parts>(
257              detail::to_string_view(S()));
258      return compiled_parts.data;
259    }
260  };
261  template <typename S, typename... Args>
262  class compiled_format : private compiled_format_base<S> {
263   public:
264    using typename compiled_format_base<S>::char_type;
265   private:
266    basic_string_view<char_type> format_str_;
267    template <typename Context, typename OutputIt, typename CompiledFormat>
268    friend auto cf::vformat_to(OutputIt out, CompiledFormat& cf,
269                               basic_format_args<Context> args) ->
270        typename Context::iterator;
271   public:
272    compiled_format() = delete;
273    explicit constexpr compiled_format(basic_string_view<char_type> format_str)
274        : compiled_format_base<S>(format_str), format_str_(format_str) {}
275  };
276  #ifdef __cpp_if_constexpr
277  template <typename... Args> struct type_list {};
278  template <int N, typename T, typename... Args>
279  constexpr const auto& get([[maybe_unused]] const T& first,
280                            [[maybe_unused]] const Args&... rest) {
281    static_assert(N < 1 + sizeof...(Args), "index is out of bounds");
282    if constexpr (N == 0)
283      return first;
284    else
285      return get<N - 1>(rest...);
286  }
287  template <int N, typename> struct get_type_impl;
288  template <int N, typename... Args> struct get_type_impl<N, type_list<Args...>> {
289    using type = remove_cvref_t<decltype(get<N>(std::declval<Args>()...))>;
290  };
291  template <int N, typename T>
292  using get_type = typename get_type_impl<N, T>::type;
293  template <typename T> struct is_compiled_format : std::false_type {};
294  template <typename Char> struct text {
295    basic_string_view<Char> data;
296    using char_type = Char;
297    template <typename OutputIt, typename... Args>
298    OutputIt format(OutputIt out, const Args&...) const {
299      return write<Char>(out, data);
300    }
301  };
302  template <typename Char>
303  struct is_compiled_format<text<Char>> : std::true_type {};
304  template <typename Char>
305  constexpr text<Char> make_text(basic_string_view<Char> s, size_t pos,
306                                 size_t size) {
307    return {{&s[pos], size}};
308  }
309  template <typename Char> struct code_unit {
310    Char value;
311    using char_type = Char;
312    template <typename OutputIt, typename... Args>
313    OutputIt format(OutputIt out, const Args&...) const {
314      return write<Char>(out, value);
315    }
316  };
317  template <typename Char>
318  struct is_compiled_format<code_unit<Char>> : std::true_type {};
319  template <typename Char, typename T, int N> struct field {
320    using char_type = Char;
321    template <typename OutputIt, typename... Args>
322    OutputIt format(OutputIt out, const Args&... args) const {
323      const T& arg = get<N>(args...);
324      return write<Char>(out, arg);
325    }
326  };
327  template <typename Char, typename T, int N>
328  struct is_compiled_format<field<Char, T, N>> : std::true_type {};
329  template <typename Char, typename T, int N> struct spec_field {
330    using char_type = Char;
331    mutable formatter<T, Char> fmt;
332    template <typename OutputIt, typename... Args>
333    OutputIt format(OutputIt out, const Args&... args) const {
334      const T& arg = get<N>(args...);
335      const auto& vargs =
336          make_format_args<basic_format_context<OutputIt, Char>>(args...);
337      basic_format_context<OutputIt, Char> ctx(out, vargs);
338      return fmt.format(arg, ctx);
339    }
340  };
341  template <typename Char, typename T, int N>
342  struct is_compiled_format<spec_field<Char, T, N>> : std::true_type {};
343  template <typename L, typename R> struct concat {
344    L lhs;
345    R rhs;
346    using char_type = typename L::char_type;
347    template <typename OutputIt, typename... Args>
348    OutputIt format(OutputIt out, const Args&... args) const {
349      out = lhs.format(out, args...);
350      return rhs.format(out, args...);
351    }
352  };
353  template <typename L, typename R>
354  struct is_compiled_format<concat<L, R>> : std::true_type {};
355  template <typename L, typename R>
356  constexpr concat<L, R> make_concat(L lhs, R rhs) {
357    return {lhs, rhs};
358  }
359  struct unknown_format {};
360  template <typename Char>
361  constexpr size_t parse_text(basic_string_view<Char> str, size_t pos) {
362    for (size_t size = str.size(); pos != size; ++pos) {
363      if (str[pos] == '{' || str[pos] == '}') break;
364    }
365    return pos;
366  }
367  template <typename Args, size_t POS, int ID, typename S>
368  constexpr auto compile_format_string(S format_str);
369  template <typename Args, size_t POS, int ID, typename T, typename S>
370  constexpr auto parse_tail(T head, S format_str) {
371    if constexpr (POS !=
372                  basic_string_view<typename S::char_type>(format_str).size()) {
373      constexpr auto tail = compile_format_string<Args, POS, ID>(format_str);
374      if constexpr (std::is_same<remove_cvref_t<decltype(tail)>,
375                                 unknown_format>())
376        return tail;
377      else
378        return make_concat(head, tail);
379    } else {
380      return head;
381    }
382  }
383  template <typename T, typename Char> struct parse_specs_result {
384    formatter<T, Char> fmt;
385    size_t end;
386    int next_arg_id;
387  };
388  template <typename T, typename Char>
389  constexpr parse_specs_result<T, Char> parse_specs(basic_string_view<Char> str,
390                                                    size_t pos, int arg_id) {
391    str.remove_prefix(pos);
392    auto ctx = basic_format_parse_context<Char>(str, {}, arg_id + 1);
393    auto f = formatter<T, Char>();
394    auto end = f.parse(ctx);
395    return {f, pos + (end - str.data()) + 1, ctx.next_arg_id()};
396  }
397  template <typename Args, size_t POS, int ID, typename S>
398  constexpr auto compile_format_string(S format_str) {
399    using char_type = typename S::char_type;
400    constexpr basic_string_view<char_type> str = format_str;
401    if constexpr (str[POS] == '{') {
402      if (POS + 1 == str.size())
403        throw format_error("unmatched '{' in format string");
404      if constexpr (str[POS + 1] == '{') {
405        return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
406      } else if constexpr (str[POS + 1] == '}') {
407        using type = get_type<ID, Args>;
408        return parse_tail<Args, POS + 2, ID + 1>(field<char_type, type, ID>(),
409                                                 format_str);
410      } else if constexpr (str[POS + 1] == ':') {
411        using type = get_type<ID, Args>;
412        constexpr auto result = parse_specs<type>(str, POS + 2, ID);
413        return parse_tail<Args, result.end, result.next_arg_id>(
414            spec_field<char_type, type, ID>{result.fmt}, format_str);
415      } else {
416        return unknown_format();
417      }
418    } else if constexpr (str[POS] == '}') {
419      if (POS + 1 == str.size())
420        throw format_error("unmatched '}' in format string");
421      return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
422    } else {
423      constexpr auto end = parse_text(str, POS + 1);
424      if constexpr (end - POS > 1) {
425        return parse_tail<Args, end, ID>(make_text(str, POS, end - POS),
426                                         format_str);
427      } else {
428        return parse_tail<Args, end, ID>(code_unit<char_type>{str[POS]},
429                                         format_str);
430      }
431    }
432  }
433  template <typename... Args, typename S,
434            FMT_ENABLE_IF(is_compile_string<S>::value ||
435                          detail::is_compiled_string<S>::value)>
436  constexpr auto compile(S format_str) {
437    constexpr basic_string_view<typename S::char_type> str = format_str;
438    if constexpr (str.size() == 0) {
439      return detail::make_text(str, 0, 0);
440    } else {
441      constexpr auto result =
442          detail::compile_format_string<detail::type_list<Args...>, 0, 0>(
443              format_str);
444      if constexpr (std::is_same<remove_cvref_t<decltype(result)>,
445                                 detail::unknown_format>()) {
446        return detail::compiled_format<S, Args...>(to_string_view(format_str));
447      } else {
448        return result;
449      }
450    }
451  }
452  #else
453  template <typename... Args, typename S,
454            FMT_ENABLE_IF(is_compile_string<S>::value)>
455  constexpr auto compile(S format_str) -> detail::compiled_format<S, Args...> {
456    return detail::compiled_format<S, Args...>(to_string_view(format_str));
457  }
458  #endif  
459  template <typename... Args, typename Char, size_t N>
460  auto compile(const Char (&format_str)[N])
461      -> detail::compiled_format<const Char*, Args...> {
462    return detail::compiled_format<const Char*, Args...>(
463        basic_string_view<Char>(format_str, N - 1));
464  }
465  }  
466  template <typename... Args>
467  FMT_DEPRECATED auto compile(const Args&... args)
468      -> decltype(detail::compile(args...)) {
469    return detail::compile(args...);
470  }
471  #if FMT_USE_CONSTEXPR
472  #  ifdef __cpp_if_constexpr
473  template <typename CompiledFormat, typename... Args,
474            typename Char = typename CompiledFormat::char_type,
475            FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
476  FMT_INLINE std::basic_string<Char> format(const CompiledFormat& cf,
477                                            const Args&... args) {
478    basic_memory_buffer<Char> buffer;
479    cf.format(detail::buffer_appender<Char>(buffer), args...);
480    return to_string(buffer);
481  }
482  template <typename OutputIt, typename CompiledFormat, typename... Args,
483            FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
484  OutputIt format_to(OutputIt out, const CompiledFormat& cf,
485                     const Args&... args) {
486    return cf.format(out, args...);
487  }
488  #  endif  
489  #endif    
490  template <typename CompiledFormat, typename... Args,
491            typename Char = typename CompiledFormat::char_type,
492            FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
493                                          CompiledFormat>::value)>
494  std::basic_string<Char> format(const CompiledFormat& cf, const Args&... args) {
495    basic_memory_buffer<Char> buffer;
496    using context = buffer_context<Char>;
497    detail::cf::vformat_to<context>(detail::buffer_appender<Char>(buffer), cf,
498                                    make_format_args<context>(args...));
499    return to_string(buffer);
500  }
501  template <typename S, typename... Args,
502            FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
503  FMT_INLINE std::basic_string<typename S::char_type> format(const S&,
504                                                             Args&&... args) {
505  #ifdef __cpp_if_constexpr
506    if constexpr (std::is_same<typename S::char_type, char>::value) {
507      constexpr basic_string_view<typename S::char_type> str = S();
508      if (str.size() == 2 && str[0] == '{' && str[1] == '}')
509        return fmt::to_string(detail::first(args...));
510    }
511  #endif
512    constexpr auto compiled = detail::compile<Args...>(S());
513    return format(compiled, std::forward<Args>(args)...);
514  }
515  template <typename OutputIt, typename CompiledFormat, typename... Args,
516            FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
517                                          CompiledFormat>::value)>
518  OutputIt format_to(OutputIt out, const CompiledFormat& cf,
519                     const Args&... args) {
520    using char_type = typename CompiledFormat::char_type;
521    using context = format_context_t<OutputIt, char_type>;
522    return detail::cf::vformat_to<context>(out, cf,
523                                           make_format_args<context>(args...));
524  }
525  template <typename OutputIt, typename S, typename... Args,
526            FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
527  OutputIt format_to(OutputIt out, const S&, const Args&... args) {
528    constexpr auto compiled = detail::compile<Args...>(S());
529    return format_to(out, compiled, args...);
530  }
531  template <
532      typename OutputIt, typename CompiledFormat, typename... Args,
533      FMT_ENABLE_IF(detail::is_output_iterator<OutputIt>::value&& std::is_base_of<
534                    detail::basic_compiled_format, CompiledFormat>::value)>
535  format_to_n_result<OutputIt> format_to_n(OutputIt out, size_t n,
536                                           const CompiledFormat& cf,
537                                           const Args&... args) {
538    auto it =
539        format_to(detail::truncating_iterator<OutputIt>(out, n), cf, args...);
540    return {it.base(), it.count()};
541  }
542  template <typename OutputIt, typename S, typename... Args,
543            FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
544  format_to_n_result<OutputIt> format_to_n(OutputIt out, size_t n, const S&,
545                                           const Args&... args) {
546    constexpr auto compiled = detail::compile<Args...>(S());
547    auto it = format_to(detail::truncating_iterator<OutputIt>(out, n), compiled,
548                        args...);
549    return {it.base(), it.count()};
550  }
551  template <typename CompiledFormat, typename... Args>
552  size_t formatted_size(const CompiledFormat& cf, const Args&... args) {
553    return format_to(detail::counting_iterator(), cf, args...).count();
554  }
555  FMT_END_NAMESPACE
556  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-compile.h</h3>
            <pre><code>1  #ifndef FMT_COMPILE_H_
2  #define FMT_COMPILE_H_
3  #include <vector>
4  #include "format.h"
5  FMT_BEGIN_NAMESPACE
6  namespace detail {
7  class compiled_string {};
8  template <typename S>
9  struct is_compiled_string : std::is_base_of<compiled_string, S> {};
10  #define FMT_COMPILE(s) FMT_STRING_IMPL(s, fmt::detail::compiled_string)
11  template <typename T, typename... Tail>
12  const T& first(const T& value, const Tail&...) {
13    return value;
14  }
15  template <typename Char> struct format_part {
16    enum class kind { arg_index, arg_name, text, replacement };
17    struct replacement {
18      arg_ref<Char> arg_id;
19      dynamic_format_specs<Char> specs;
20    };
21    kind part_kind;
22    union value {
23      int arg_index;
24      basic_string_view<Char> str;
25      replacement repl;
26      FMT_CONSTEXPR value(int index = 0) : arg_index(index) {}
27      FMT_CONSTEXPR value(basic_string_view<Char> s) : str(s) {}
28      FMT_CONSTEXPR value(replacement r) : repl(r) {}
29    } val;
30    const Char* arg_id_end = nullptr;
31    FMT_CONSTEXPR format_part(kind k = kind::arg_index, value v = {})
32        : part_kind(k), val(v) {}
33    static FMT_CONSTEXPR format_part make_arg_index(int index) {
34      return format_part(kind::arg_index, index);
35    }
36    static FMT_CONSTEXPR format_part make_arg_name(basic_string_view<Char> name) {
37      return format_part(kind::arg_name, name);
38    }
39    static FMT_CONSTEXPR format_part make_text(basic_string_view<Char> text) {
40      return format_part(kind::text, text);
41    }
42    static FMT_CONSTEXPR format_part make_replacement(replacement repl) {
43      return format_part(kind::replacement, repl);
44    }
45  };
46  template <typename Char> struct part_counter {
47    unsigned num_parts = 0;
48    FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
49      if (begin != end) ++num_parts;
50    }
51    FMT_CONSTEXPR int on_arg_id() { return ++num_parts, 0; }
52    FMT_CONSTEXPR int on_arg_id(int) { return ++num_parts, 0; }
53    FMT_CONSTEXPR int on_arg_id(basic_string_view<Char>) {
54      return ++num_parts, 0;
55    }
56    FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}
57    FMT_CONSTEXPR const Char* on_format_specs(int, const Char* begin,
58                                              const Char* end) {
59      unsigned brace_counter = 0;
60      for (; begin != end; ++begin) {
61        if (*begin == '{') {
62          ++brace_counter;
63        } else if (*begin == '}') {
64          if (brace_counter == 0u) break;
65          --brace_counter;
66        }
67      }
68      return begin;
69    }
70    FMT_CONSTEXPR void on_error(const char*) {}
71  };
72  template <typename Char>
73  FMT_CONSTEXPR unsigned count_parts(basic_string_view<Char> format_str) {
74    part_counter<Char> counter;
75    parse_format_string<true>(format_str, counter);
76    return counter.num_parts;
77  }
78  template <typename Char, typename PartHandler>
79  class format_string_compiler : public error_handler {
80   private:
81    using part = format_part<Char>;
82    PartHandler handler_;
83    part part_;
84    basic_string_view<Char> format_str_;
85    basic_format_parse_context<Char> parse_context_;
86   public:
87    FMT_CONSTEXPR format_string_compiler(basic_string_view<Char> format_str,
88                                         PartHandler handler)
89        : handler_(handler),
90          format_str_(format_str),
91          parse_context_(format_str) {}
92    FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
93      if (begin != end)
94        handler_(part::make_text({begin, to_unsigned(end - begin)}));
95    }
96    FMT_CONSTEXPR int on_arg_id() {
97      part_ = part::make_arg_index(parse_context_.next_arg_id());
98      return 0;
99    }
100    FMT_CONSTEXPR int on_arg_id(int id) {
101      parse_context_.check_arg_id(id);
102      part_ = part::make_arg_index(id);
103      return 0;
104    }
105    FMT_CONSTEXPR int on_arg_id(basic_string_view<Char> id) {
106      part_ = part::make_arg_name(id);
107      return 0;
108    }
109    FMT_CONSTEXPR void on_replacement_field(int, const Char* ptr) {
110      part_.arg_id_end = ptr;
111      handler_(part_);
112    }
113    FMT_CONSTEXPR const Char* on_format_specs(int, const Char* begin,
114                                              const Char* end) {
115      auto repl = typename part::replacement();
116      dynamic_specs_handler<basic_format_parse_context<Char>> handler(
117          repl.specs, parse_context_);
118      auto it = parse_format_specs(begin, end, handler);
119      if (*it != '}') on_error("missing '}' in format string");
120      repl.arg_id = part_.part_kind == part::kind::arg_index
121                        ? arg_ref<Char>(part_.val.arg_index)
122                        : arg_ref<Char>(part_.val.str);
123      auto part = part::make_replacement(repl);
124      part.arg_id_end = begin;
125      handler_(part);
126      return it;
127    }
128  };
129  template <bool IS_CONSTEXPR, typename Char, typename PartHandler>
130  FMT_CONSTEXPR void compile_format_string(basic_string_view<Char> format_str,
131                                           PartHandler handler) {
132    parse_format_string<IS_CONSTEXPR>(
133        format_str,
134        format_string_compiler<Char, PartHandler>(format_str, handler));
135  }
136  template <typename OutputIt, typename Context, typename Id>
137  void format_arg(
138      basic_format_parse_context<typename Context::char_type>& parse_ctx,
139      Context& ctx, Id arg_id) {
140    ctx.advance_to(visit_format_arg(
141        arg_formatter<OutputIt, typename Context::char_type>(ctx, &parse_ctx),
142        ctx.arg(arg_id)));
143  }
144  namespace cf {
145  template <typename Context, typename OutputIt, typename CompiledFormat>
146  auto vformat_to(OutputIt out, CompiledFormat& cf,
147                  basic_format_args<Context> args) -> typename Context::iterator {
148    using char_type = typename Context::char_type;
149    basic_format_parse_context<char_type> parse_ctx(
150        to_string_view(cf.format_str_));
151    Context ctx(out, args);
152    const auto& parts = cf.parts();
153    for (auto part_it = std::begin(parts); part_it != std::end(parts);
154         ++part_it) {
155      const auto& part = *part_it;
156      const auto& value = part.val;
157      using format_part_t = format_part<char_type>;
158      switch (part.part_kind) {
159      case format_part_t::kind::text: {
160        const auto text = value.str;
161        auto output = ctx.out();
162        auto&& it = reserve(output, text.size());
163        it = std::copy_n(text.begin(), text.size(), it);
164        ctx.advance_to(output);
165        break;
166      }
167      case format_part_t::kind::arg_index:
168        advance_to(parse_ctx, part.arg_id_end);
169        detail::format_arg<OutputIt>(parse_ctx, ctx, value.arg_index);
170        break;
171      case format_part_t::kind::arg_name:
172        advance_to(parse_ctx, part.arg_id_end);
<span onclick='openModal()' class='match'>173        detail::format_arg<OutputIt>(parse_ctx, ctx, value.str);
174        break;
175      case format_part_t::kind::replacement: {
</span>176        const auto& arg_id_value = value.repl.arg_id.val;
177        const auto arg = value.repl.arg_id.kind == arg_id_kind::index
178                             ? ctx.arg(arg_id_value.index)
179                             : ctx.arg(arg_id_value.name);
180        auto specs = value.repl.specs;
181        handle_dynamic_spec<width_checker>(specs.width, specs.width_ref, ctx);
182        handle_dynamic_spec<precision_checker>(specs.precision,
183                                               specs.precision_ref, ctx);
184        error_handler h;
185        numeric_specs_checker<error_handler> checker(h, arg.type());
186        if (specs.align == align::numeric) checker.require_numeric_argument();
187        if (specs.sign != sign::none) checker.check_sign();
188        if (specs.alt) checker.require_numeric_argument();
189        if (specs.precision >= 0) checker.check_precision();
190        advance_to(parse_ctx, part.arg_id_end);
191        ctx.advance_to(
192            visit_format_arg(arg_formatter<OutputIt, typename Context::char_type>(
193                                 ctx, nullptr, &specs),
194                             arg));
195        break;
196      }
197      }
198    }
199    return ctx.out();
200  }
201  }  
202  struct basic_compiled_format {};
203  template <typename S, typename = void>
204  struct compiled_format_base : basic_compiled_format {
205    using char_type = char_t<S>;
206    using parts_container = std::vector<detail::format_part<char_type>>;
207    parts_container compiled_parts;
208    explicit compiled_format_base(basic_string_view<char_type> format_str) {
209      compile_format_string<false>(format_str,
210                                   [this](const format_part<char_type>& part) {
211                                     compiled_parts.push_back(part);
212                                   });
213    }
214    const parts_container& parts() const { return compiled_parts; }
215  };
216  template <typename Char, unsigned N> struct format_part_array {
217    format_part<Char> data[N] = {};
218    FMT_CONSTEXPR format_part_array() = default;
219  };
220  template <typename Char, unsigned N>
221  FMT_CONSTEXPR format_part_array<Char, N> compile_to_parts(
222      basic_string_view<Char> format_str) {
223    format_part_array<Char, N> parts;
224    unsigned counter = 0;
225    struct {
226      format_part<Char>* parts;
227      unsigned* counter;
228      FMT_CONSTEXPR void operator()(const format_part<Char>& part) {
229        parts[(*counter)++] = part;
230      }
231    } collector{parts.data, &counter};
232    compile_format_string<true>(format_str, collector);
233    if (counter < N) {
234      parts.data[counter] =
235          format_part<Char>::make_text(basic_string_view<Char>());
236    }
237    return parts;
238  }
239  template <typename T> constexpr const T& constexpr_max(const T& a, const T& b) {
240    return (a < b) ? b : a;
241  }
242  template <typename S>
243  struct compiled_format_base<S, enable_if_t<is_compile_string<S>::value>>
244      : basic_compiled_format {
245    using char_type = char_t<S>;
246    FMT_CONSTEXPR explicit compiled_format_base(basic_string_view<char_type>) {}
247  #if FMT_USE_CONSTEXPR
248    static FMT_CONSTEXPR_DECL const unsigned num_format_parts =
249        constexpr_max(count_parts(to_string_view(S())), 1u);
250  #else
251    static const unsigned num_format_parts = 1;
252  #endif
253    using parts_container = format_part<char_type>[num_format_parts];
254    const parts_container& parts() const {
255      static FMT_CONSTEXPR_DECL const auto compiled_parts =
256          compile_to_parts<char_type, num_format_parts>(
257              detail::to_string_view(S()));
258      return compiled_parts.data;
259    }
260  };
261  template <typename S, typename... Args>
262  class compiled_format : private compiled_format_base<S> {
263   public:
264    using typename compiled_format_base<S>::char_type;
265   private:
266    basic_string_view<char_type> format_str_;
267    template <typename Context, typename OutputIt, typename CompiledFormat>
268    friend auto cf::vformat_to(OutputIt out, CompiledFormat& cf,
269                               basic_format_args<Context> args) ->
270        typename Context::iterator;
271   public:
272    compiled_format() = delete;
273    explicit constexpr compiled_format(basic_string_view<char_type> format_str)
274        : compiled_format_base<S>(format_str), format_str_(format_str) {}
275  };
276  #ifdef __cpp_if_constexpr
277  template <typename... Args> struct type_list {};
278  template <int N, typename T, typename... Args>
279  constexpr const auto& get([[maybe_unused]] const T& first,
280                            [[maybe_unused]] const Args&... rest) {
281    static_assert(N < 1 + sizeof...(Args), "index is out of bounds");
282    if constexpr (N == 0)
283      return first;
284    else
285      return get<N - 1>(rest...);
286  }
287  template <int N, typename> struct get_type_impl;
288  template <int N, typename... Args> struct get_type_impl<N, type_list<Args...>> {
289    using type = remove_cvref_t<decltype(get<N>(std::declval<Args>()...))>;
290  };
291  template <int N, typename T>
292  using get_type = typename get_type_impl<N, T>::type;
293  template <typename T> struct is_compiled_format : std::false_type {};
294  template <typename Char> struct text {
295    basic_string_view<Char> data;
296    using char_type = Char;
297    template <typename OutputIt, typename... Args>
298    OutputIt format(OutputIt out, const Args&...) const {
299      return write<Char>(out, data);
300    }
301  };
302  template <typename Char>
303  struct is_compiled_format<text<Char>> : std::true_type {};
304  template <typename Char>
305  constexpr text<Char> make_text(basic_string_view<Char> s, size_t pos,
306                                 size_t size) {
307    return {{&s[pos], size}};
308  }
309  template <typename Char> struct code_unit {
310    Char value;
311    using char_type = Char;
312    template <typename OutputIt, typename... Args>
313    OutputIt format(OutputIt out, const Args&...) const {
314      return write<Char>(out, value);
315    }
316  };
317  template <typename Char>
318  struct is_compiled_format<code_unit<Char>> : std::true_type {};
319  template <typename Char, typename T, int N> struct field {
320    using char_type = Char;
321    template <typename OutputIt, typename... Args>
322    OutputIt format(OutputIt out, const Args&... args) const {
323      const T& arg = get<N>(args...);
324      return write<Char>(out, arg);
325    }
326  };
327  template <typename Char, typename T, int N>
328  struct is_compiled_format<field<Char, T, N>> : std::true_type {};
329  template <typename Char, typename T, int N> struct spec_field {
330    using char_type = Char;
331    mutable formatter<T, Char> fmt;
332    template <typename OutputIt, typename... Args>
333    OutputIt format(OutputIt out, const Args&... args) const {
334      const T& arg = get<N>(args...);
335      const auto& vargs =
336          make_format_args<basic_format_context<OutputIt, Char>>(args...);
337      basic_format_context<OutputIt, Char> ctx(out, vargs);
338      return fmt.format(arg, ctx);
339    }
340  };
341  template <typename Char, typename T, int N>
342  struct is_compiled_format<spec_field<Char, T, N>> : std::true_type {};
343  template <typename L, typename R> struct concat {
344    L lhs;
345    R rhs;
346    using char_type = typename L::char_type;
347    template <typename OutputIt, typename... Args>
348    OutputIt format(OutputIt out, const Args&... args) const {
349      out = lhs.format(out, args...);
350      return rhs.format(out, args...);
351    }
352  };
353  template <typename L, typename R>
354  struct is_compiled_format<concat<L, R>> : std::true_type {};
355  template <typename L, typename R>
356  constexpr concat<L, R> make_concat(L lhs, R rhs) {
357    return {lhs, rhs};
358  }
359  struct unknown_format {};
360  template <typename Char>
361  constexpr size_t parse_text(basic_string_view<Char> str, size_t pos) {
362    for (size_t size = str.size(); pos != size; ++pos) {
363      if (str[pos] == '{' || str[pos] == '}') break;
364    }
365    return pos;
366  }
367  template <typename Args, size_t POS, int ID, typename S>
368  constexpr auto compile_format_string(S format_str);
369  template <typename Args, size_t POS, int ID, typename T, typename S>
370  constexpr auto parse_tail(T head, S format_str) {
371    if constexpr (POS !=
372                  basic_string_view<typename S::char_type>(format_str).size()) {
373      constexpr auto tail = compile_format_string<Args, POS, ID>(format_str);
374      if constexpr (std::is_same<remove_cvref_t<decltype(tail)>,
375                                 unknown_format>())
376        return tail;
377      else
378        return make_concat(head, tail);
379    } else {
380      return head;
381    }
382  }
383  template <typename T, typename Char> struct parse_specs_result {
384    formatter<T, Char> fmt;
385    size_t end;
386    int next_arg_id;
387  };
388  template <typename T, typename Char>
389  constexpr parse_specs_result<T, Char> parse_specs(basic_string_view<Char> str,
390                                                    size_t pos, int arg_id) {
391    str.remove_prefix(pos);
392    auto ctx = basic_format_parse_context<Char>(str, {}, arg_id + 1);
393    auto f = formatter<T, Char>();
394    auto end = f.parse(ctx);
395    return {f, pos + (end - str.data()) + 1, ctx.next_arg_id()};
396  }
397  template <typename Args, size_t POS, int ID, typename S>
398  constexpr auto compile_format_string(S format_str) {
399    using char_type = typename S::char_type;
400    constexpr basic_string_view<char_type> str = format_str;
401    if constexpr (str[POS] == '{') {
402      if (POS + 1 == str.size())
403        throw format_error("unmatched '{' in format string");
404      if constexpr (str[POS + 1] == '{') {
405        return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
406      } else if constexpr (str[POS + 1] == '}') {
407        using type = get_type<ID, Args>;
408        return parse_tail<Args, POS + 2, ID + 1>(field<char_type, type, ID>(),
409                                                 format_str);
410      } else if constexpr (str[POS + 1] == ':') {
411        using type = get_type<ID, Args>;
412        constexpr auto result = parse_specs<type>(str, POS + 2, ID);
413        return parse_tail<Args, result.end, result.next_arg_id>(
414            spec_field<char_type, type, ID>{result.fmt}, format_str);
415      } else {
416        return unknown_format();
417      }
418    } else if constexpr (str[POS] == '}') {
419      if (POS + 1 == str.size())
420        throw format_error("unmatched '}' in format string");
421      return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
422    } else {
423      constexpr auto end = parse_text(str, POS + 1);
424      if constexpr (end - POS > 1) {
425        return parse_tail<Args, end, ID>(make_text(str, POS, end - POS),
426                                         format_str);
427      } else {
428        return parse_tail<Args, end, ID>(code_unit<char_type>{str[POS]},
429                                         format_str);
430      }
431    }
432  }
433  template <typename... Args, typename S,
434            FMT_ENABLE_IF(is_compile_string<S>::value ||
435                          detail::is_compiled_string<S>::value)>
436  constexpr auto compile(S format_str) {
437    constexpr basic_string_view<typename S::char_type> str = format_str;
438    if constexpr (str.size() == 0) {
439      return detail::make_text(str, 0, 0);
440    } else {
441      constexpr auto result =
442          detail::compile_format_string<detail::type_list<Args...>, 0, 0>(
443              format_str);
444      if constexpr (std::is_same<remove_cvref_t<decltype(result)>,
445                                 detail::unknown_format>()) {
446        return detail::compiled_format<S, Args...>(to_string_view(format_str));
447      } else {
448        return result;
449      }
450    }
451  }
452  #else
453  template <typename... Args, typename S,
454            FMT_ENABLE_IF(is_compile_string<S>::value)>
455  constexpr auto compile(S format_str) -> detail::compiled_format<S, Args...> {
456    return detail::compiled_format<S, Args...>(to_string_view(format_str));
457  }
458  #endif  
459  template <typename... Args, typename Char, size_t N>
460  auto compile(const Char (&format_str)[N])
461      -> detail::compiled_format<const Char*, Args...> {
462    return detail::compiled_format<const Char*, Args...>(
463        basic_string_view<Char>(format_str, N - 1));
464  }
465  }  
466  template <typename... Args>
467  FMT_DEPRECATED auto compile(const Args&... args)
468      -> decltype(detail::compile(args...)) {
469    return detail::compile(args...);
470  }
471  #if FMT_USE_CONSTEXPR
472  #  ifdef __cpp_if_constexpr
473  template <typename CompiledFormat, typename... Args,
474            typename Char = typename CompiledFormat::char_type,
475            FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
476  FMT_INLINE std::basic_string<Char> format(const CompiledFormat& cf,
477                                            const Args&... args) {
478    basic_memory_buffer<Char> buffer;
479    cf.format(detail::buffer_appender<Char>(buffer), args...);
480    return to_string(buffer);
481  }
482  template <typename OutputIt, typename CompiledFormat, typename... Args,
483            FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
484  OutputIt format_to(OutputIt out, const CompiledFormat& cf,
485                     const Args&... args) {
486    return cf.format(out, args...);
487  }
488  #  endif  
489  #endif    
490  template <typename CompiledFormat, typename... Args,
491            typename Char = typename CompiledFormat::char_type,
492            FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
493                                          CompiledFormat>::value)>
494  std::basic_string<Char> format(const CompiledFormat& cf, const Args&... args) {
495    basic_memory_buffer<Char> buffer;
496    using context = buffer_context<Char>;
497    detail::cf::vformat_to<context>(detail::buffer_appender<Char>(buffer), cf,
498                                    make_format_args<context>(args...));
499    return to_string(buffer);
500  }
501  template <typename S, typename... Args,
502            FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
503  FMT_INLINE std::basic_string<typename S::char_type> format(const S&,
504                                                             Args&&... args) {
505  #ifdef __cpp_if_constexpr
506    if constexpr (std::is_same<typename S::char_type, char>::value) {
507      constexpr basic_string_view<typename S::char_type> str = S();
508      if (str.size() == 2 && str[0] == '{' && str[1] == '}')
509        return fmt::to_string(detail::first(args...));
510    }
511  #endif
512    constexpr auto compiled = detail::compile<Args...>(S());
513    return format(compiled, std::forward<Args>(args)...);
514  }
515  template <typename OutputIt, typename CompiledFormat, typename... Args,
516            FMT_ENABLE_IF(std::is_base_of<detail::basic_compiled_format,
517                                          CompiledFormat>::value)>
518  OutputIt format_to(OutputIt out, const CompiledFormat& cf,
519                     const Args&... args) {
520    using char_type = typename CompiledFormat::char_type;
521    using context = format_context_t<OutputIt, char_type>;
522    return detail::cf::vformat_to<context>(out, cf,
523                                           make_format_args<context>(args...));
524  }
525  template <typename OutputIt, typename S, typename... Args,
526            FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
527  OutputIt format_to(OutputIt out, const S&, const Args&... args) {
528    constexpr auto compiled = detail::compile<Args...>(S());
529    return format_to(out, compiled, args...);
530  }
531  template <
532      typename OutputIt, typename CompiledFormat, typename... Args,
533      FMT_ENABLE_IF(detail::is_output_iterator<OutputIt>::value&& std::is_base_of<
534                    detail::basic_compiled_format, CompiledFormat>::value)>
535  format_to_n_result<OutputIt> format_to_n(OutputIt out, size_t n,
536                                           const CompiledFormat& cf,
537                                           const Args&... args) {
538    auto it =
539        format_to(detail::truncating_iterator<OutputIt>(out, n), cf, args...);
540    return {it.base(), it.count()};
541  }
542  template <typename OutputIt, typename S, typename... Args,
543            FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
544  format_to_n_result<OutputIt> format_to_n(OutputIt out, size_t n, const S&,
545                                           const Args&... args) {
546    constexpr auto compiled = detail::compile<Args...>(S());
547    auto it = format_to(detail::truncating_iterator<OutputIt>(out, n), compiled,
548                        args...);
549    return {it.base(), it.count()};
550  }
551  template <typename CompiledFormat, typename... Args>
552  size_t formatted_size(const CompiledFormat& cf, const Args&... args) {
553    return format_to(detail::counting_iterator(), cf, args...).count();
554  }
555  FMT_END_NAMESPACE
556  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-compile.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-compile.h</div>
                </div>
                <div class="column column_space"><pre><code>169        detail::format_arg<OutputIt>(parse_ctx, ctx, value.arg_index);
170        break;
171      case format_part_t::kind::arg_name:
172        advance_to(parse_ctx, part.arg_id_end);
</pre></code></div>
                <div class="column column_space"><pre><code>173        detail::format_arg<OutputIt>(parse_ctx, ctx, value.str);
174        break;
175      case format_part_t::kind::replacement: {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    