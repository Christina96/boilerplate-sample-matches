
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 63, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-aof.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/win32_types.h&quot;
3  #include &quot;Win32_Interop/Win32_Error.h&quot;
4  #endif
5  #include &quot;server.h&quot;
6  #include &quot;bio.h&quot;
7  #include &quot;rio.h&quot;
8  #include &lt;signal.h&gt;
9  #include &lt;fcntl.h&gt;
10  #include &lt;sys/stat.h&gt;
11  #include &lt;sys/types.h&gt;
12  #ifndef _WIN32
13  #include &lt;sys/time.h&gt;
14  #include &lt;sys/resource.h&gt;
15  #include &lt;sys/wait.h&gt;
16  #include &lt;sys/param.h&gt;
17  #else
18  #include &quot;Win32_Interop/Win32_QFork.h&quot;
19  #include &lt;direct.h&gt;
20  #define MAXPATHLEN 1024
21  #endif
22  void aofUpdateCurrentSize(void);
23  void aofClosePipes(void);
24  #define AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    &amp;bsol;* 10 MB per block */
25  typedef struct aofrwblock {
26      PORT_ULONG used, free;
27      char buf[AOF_RW_BUF_BLOCK_SIZE];
28  } aofrwblock;
29  void aofRewriteBufferReset(void) {
30      if (server.aof_rewrite_buf_blocks)
31          listRelease(server.aof_rewrite_buf_blocks);
32      server.aof_rewrite_buf_blocks = listCreate();
33      listSetFreeMethod(server.aof_rewrite_buf_blocks,zfree);
34  }
35  PORT_ULONG aofRewriteBufferSize(void) {
36      listNode *ln;
37      listIter li;
38      PORT_ULONG size = 0;
39      listRewind(server.aof_rewrite_buf_blocks,&amp;li);
40      while((ln = listNext(&amp;li))) {
41          aofrwblock *block = listNodeValue(ln);
42          size += block-&gt;used;
43      }
44      return size;
45  }
46  void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {
47      listNode *ln;
48      aofrwblock *block;
49      ssize_t nwritten;
50      UNUSED(el);
51      UNUSED(fd);
52      UNUSED(privdata);
53      UNUSED(mask);
54      while(1) {
55          ln = listFirst(server.aof_rewrite_buf_blocks);
56          block = ln ? ln-&gt;value : NULL;
57          if (server.aof_stop_sending_diff || !block) {
58  #ifndef _WIN32
59              aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,
60                                AE_WRITABLE);
61  #endif
62              return;
63          }
64          if (block-&gt;used &gt; 0) {
65              nwritten = write(server.aof_pipe_write_data_to_child,
66                               block-&gt;buf,block-&gt;used);
67              if (nwritten &lt;= 0) return;
68              memmove(block-&gt;buf,block-&gt;buf+nwritten,block-&gt;used-nwritten);
69              block-&gt;used -= nwritten;
70              block-&gt;free += nwritten;
71          }
72          if (block-&gt;used == 0) listDelNode(server.aof_rewrite_buf_blocks,ln);
73      }
74  }
75  void aofRewriteBufferAppend(unsigned char *s, PORT_ULONG len) {
76      listNode *ln = listLast(server.aof_rewrite_buf_blocks);
77      aofrwblock *block = ln ? ln-&gt;value : NULL;
78      while(len) {
79          if (block) {
80              PORT_ULONG thislen = (block-&gt;free &lt; len) ? block-&gt;free : len;
81              if (thislen) {  &amp;bsol;* The current block is not already full. */
82                  memcpy(block-&gt;buf+block-&gt;used, s, thislen);
83                  block-&gt;used += thislen;
84                  block-&gt;free -= thislen;
85                  s += thislen;
86                  len -= thislen;
87              }
88          }
89          if (len) { &amp;bsol;* First block to allocate, or need another block. */
90              int numblocks;
91              block = zmalloc(sizeof(*block));
92  #ifdef _WIN32
93              if (block) {
94  #endif
95                  block-&gt;free = AOF_RW_BUF_BLOCK_SIZE;
96                  block-&gt;used = 0;
97  #ifdef _WIN32
98              }
99  #endif
100              listAddNodeTail(server.aof_rewrite_buf_blocks,block);
101              numblocks = (int) listLength(server.aof_rewrite_buf_blocks);         WIN_PORT_FIX &amp;bsol;* cast (int) */
102              if (((numblocks+1) % 10) == 0) {
103                  int level = ((numblocks+1) % 100) == 0 ? LL_WARNING :
104                                                           LL_NOTICE;
105                  serverLog(level,&quot;Background AOF buffer size: %Iu MB&quot;, WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
106                      aofRewriteBufferSize()/(1024*1024));
107              }
108          }
109      }
110  #ifndef _WIN32
111      if (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == 0) {
112          aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
113              AE_WRITABLE, aofChildWriteDiffData, NULL);
114      }
115  #endif
116  }
117  ssize_t aofRewriteBufferWrite(int fd) {
118      listNode *ln;
119      listIter li;
120      ssize_t count = 0;
121      listRewind(server.aof_rewrite_buf_blocks,&amp;li);
122      while((ln = listNext(&amp;li))) {
123          aofrwblock *block = listNodeValue(ln);
124          ssize_t nwritten;
125          if (block-&gt;used) {
126              nwritten = write(fd,block-&gt;buf,block-&gt;used);
127              if (nwritten != (ssize_t)block-&gt;used) {
128                  if (nwritten == 0) errno = EIO;
129                  return -1;
130              }
131              count += nwritten;
132          }
133      }
134      return count;
135  }
136  int aofFsyncInProgress(void) {
137      return bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
138  }
139  void aof_background_fsync(int fd) {
140      bioCreateBackgroundJob(BIO_AOF_FSYNC,(void*)(PORT_LONG)fd,NULL,NULL);
141  }
142  static void killAppendOnlyChild(void) {
143      POSIX_ONLY(int statloc;)
144      if (server.aof_child_pid == -1) return;
145      serverLog(LL_NOTICE,&quot;Killing running AOF rewrite child: %Id&quot;, WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
146          (PORT_LONG) server.aof_child_pid);
147  #ifdef _WIN32
148          AbortForkOperation();
149  #else
150      if (kill(server.aof_child_pid,SIGUSR1) != -1) {
151          while(wait3(&amp;statloc,0,NULL) != server.aof_child_pid);
152      }
153  #endif
154      aofRewriteBufferReset();
155      aofRemoveTempFile(server.aof_child_pid);
156      server.aof_child_pid = -1;
157      server.aof_rewrite_time_start = -1;
158      aofClosePipes();
159  }
160  void stopAppendOnly(void) {
161      serverAssert(server.aof_state != AOF_OFF);
162      flushAppendOnlyFile(1);
163      redis_fsync(server.aof_fd);
164      close(server.aof_fd);
165      server.aof_fd = -1;
166      server.aof_selected_db = -1;
167      server.aof_state = AOF_OFF;
168      killAppendOnlyChild();
169  }
170  int startAppendOnly(void) {
171      char cwd[MAXPATHLEN]; &amp;bsol;* Current working dir path for error messages. */
172      int newfd;
173      newfd = open(server.aof_filename,O_WRONLY|O_APPEND|O_CREAT WIN32_ONLY(|_O_BINARY), IF_WIN32(_S_IREAD|_S_IWRITE, 0644));
174      serverAssert(server.aof_state == AOF_OFF);
175      if (newfd == -1) {
176          char *cwdp = IF_WIN32(_getcwd, getcwd)(cwd, MAXPATHLEN);
177          serverLog(LL_WARNING,
178              &quot;Redis needs to enable the AOF but can&#x27;t open the &quot;
179              &quot;append only file %s (in server root dir %s): %s&quot;,
180              server.aof_filename,
181              cwdp ? cwdp : &quot;unknown&quot;,
182              IF_WIN32(wsa_strerror(errno), strerror(errno)));
183          return C_ERR;
184      }
185      if (server.rdb_child_pid != -1) {
186          server.aof_rewrite_scheduled = 1;
187          serverLog(LL_WARNING,&quot;AOF was enabled but there is already a child process saving an RDB file on disk. An AOF background was scheduled to start when possible.&quot;);
188      } else {
189          if (server.aof_child_pid != -1) {
190              serverLog(LL_WARNING,&quot;AOF was enabled but there is already an AOF rewriting in background. Stopping background AOF and starting a rewrite now.&quot;);
191              killAppendOnlyChild();
192          }
193          if (rewriteAppendOnlyFileBackground() == C_ERR) {
194              close(newfd);
195              serverLog(LL_WARNING,&quot;Redis needs to enable the AOF but can&#x27;t trigger a background AOF rewrite operation. Check the above logs for more info about the error.&quot;);
196              return C_ERR;
197          }
198      }
199      server.aof_state = AOF_WAIT_REWRITE;
200      server.aof_last_fsync = server.unixtime;
201      server.aof_fd = newfd;
202      return C_OK;
203  }
204  ssize_t aofWrite(int fd, const char *buf, size_t len) {
205      ssize_t nwritten = 0, totwritten = 0;
206      while(len) {
207          nwritten = write(fd, buf, len);
208          if (nwritten &lt; 0) {
209              if (errno == EINTR) {
210                  continue;
211              }
212              return totwritten ? totwritten : -1;
213          }
214          len -= nwritten;
215          buf += nwritten;
216          totwritten += nwritten;
217      }
218      return totwritten;
219  }
220  #define AOF_WRITE_LOG_ERROR_RATE 30 &amp;bsol;* Seconds between errors logging. */
221  void flushAppendOnlyFile(int force) {
222      ssize_t nwritten;
223      int sync_in_progress = 0;
224      mstime_t latency;
225      if (sdslen(server.aof_buf) == 0) {
226          if (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;
227              server.aof_fsync_offset != server.aof_current_size &amp;&amp;
228              server.unixtime &gt; server.aof_last_fsync &amp;&amp;
229              !(sync_in_progress = aofFsyncInProgress())) {
230              goto try_fsync;
231          } else {
232              return;
233          }
234      }
235      if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
236          sync_in_progress = aofFsyncInProgress();
237      if (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) {
238          if (sync_in_progress) {
239              if (server.aof_flush_postponed_start == 0) {
240                  server.aof_flush_postponed_start = server.unixtime;
241                  return;
242              } else if (server.unixtime - server.aof_flush_postponed_start &lt; 2) {
243                  return;
244              }
245              server.aof_delayed_fsync++;
246              serverLog(LL_NOTICE,&quot;Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.&quot;);
247          }
248      }
249      latencyStartMonitor(latency);
250      nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));
251      latencyEndMonitor(latency);
252      if (sync_in_progress) {
253          latencyAddSampleIfNeeded(&quot;aof-write-pending-fsync&quot;,latency);
254      } else if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) {
255          latencyAddSampleIfNeeded(&quot;aof-write-active-child&quot;,latency);
256      } else {
257          latencyAddSampleIfNeeded(&quot;aof-write-alone&quot;,latency);
258      }
259      latencyAddSampleIfNeeded(&quot;aof-write&quot;,latency);
260      server.aof_flush_postponed_start = 0;
261      if (nwritten != (ssize_t)sdslen(server.aof_buf)) {
262          static time_t last_write_error_log = 0;
263          int can_log = 0;
264          if ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) {
265              can_log = 1;
266              last_write_error_log = server.unixtime;
267          }
268          if (nwritten == -1) {
269              if (can_log) {
270                  serverLog(LL_WARNING,&quot;Error writing to the AOF file: %s&quot;,
271                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
272                  server.aof_last_write_errno = errno;
273              }
274          } else {
275              if (can_log) {
276                  serverLog(LL_WARNING,&quot;Short write while writing to &quot;
277                                         &quot;the AOF file: (nwritten=%lld, &quot;
278                                         &quot;expected=%lld)&quot;,
279                                         (PORT_LONGLONG)nwritten,
280                                         (PORT_LONGLONG)sdslen(server.aof_buf));
281              }
282              if (ftruncate(server.aof_fd, server.aof_current_size) == -1) {
283                  if (can_log) {
284                      serverLog(LL_WARNING, &quot;Could not remove short write &quot;
285                               &quot;from the append-only file.  Redis may refuse &quot;
286                               &quot;to load the AOF the next time it starts.  &quot;
287                               &quot;ftruncate: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
288                  }
289              } else {
290                  nwritten = -1;
291              }
292              server.aof_last_write_errno = ENOSPC;
293          }
294          if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
295              serverLog(LL_WARNING,&quot;Can&#x27;t recover from AOF write error when the AOF fsync policy is &#x27;always&#x27;. Exiting...&quot;);
296              exit(1);
297          } else {
298              server.aof_last_write_status = C_ERR;
299              if (nwritten &gt; 0) {
300                  server.aof_current_size += nwritten;
301                  sdsrange(server.aof_buf,(int)nwritten,-1);                      WIN_PORT_FIX &amp;bsol;* cast (int) */
302              }
303              return; &amp;bsol;* We&#x27;ll try again on the next call... */
304          }
305      } else {
306          if (server.aof_last_write_status == C_ERR) {
307              serverLog(LL_WARNING,
308                  &quot;AOF write error looks solved, Redis can write again.&quot;);
309              server.aof_last_write_status = C_OK;
310          }
311      }
312      server.aof_current_size += nwritten;
313      if ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; 4000) {
314          sdsclear(server.aof_buf);
315      } else {
316          sdsfree(server.aof_buf);
317          server.aof_buf = sdsempty();
318      }
319  try_fsync:
320      if (server.aof_no_fsync_on_rewrite &amp;&amp;
321          (server.aof_child_pid != -1 || server.rdb_child_pid != -1))
322              return;
323      if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
324          latencyStartMonitor(latency);
325          redis_fsync(server.aof_fd); &amp;bsol;* Let&#x27;s try to get this data on the disk */
326          latencyEndMonitor(latency);
327          latencyAddSampleIfNeeded(&quot;aof-fsync-always&quot;,latency);
328          server.aof_fsync_offset = server.aof_current_size;
329          server.aof_last_fsync = server.unixtime;
330      } else if ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;
331                  server.unixtime &gt; server.aof_last_fsync)) {
332          if (!sync_in_progress) {
333              aof_background_fsync(server.aof_fd);
334              server.aof_fsync_offset = server.aof_current_size;
335          }
336          server.aof_last_fsync = server.unixtime;
337      }
338  }
339  sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
340      char buf[32];
341      int len, j;
342      robj *o;
343      buf[0] = &#x27;*&#x27;;
344      len = 1+ll2string(buf+1,sizeof(buf)-1,argc);
345      buf[len++] = &#x27;\r&#x27;;
346      buf[len++] = &#x27;\n&#x27;;
347      dst = sdscatlen(dst,buf,len);
348      for (j = 0; j &lt; argc; j++) {
349          o = getDecodedObject(argv[j]);
350          buf[0] = &#x27;$&#x27;;
351          len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o-&gt;ptr));
352          buf[len++] = &#x27;\r&#x27;;
353          buf[len++] = &#x27;\n&#x27;;
354          dst = sdscatlen(dst,buf,len);
355          dst = sdscatlen(dst,o-&gt;ptr,sdslen(o-&gt;ptr));
356          dst = sdscatlen(dst,&quot;\r\n&quot;,2);
357          decrRefCount(o);
358      }
359      return dst;
360  }
361  sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {
362      PORT_LONGLONG when;
363      robj *argv[3];
364      seconds = getDecodedObject(seconds);
365      when = strtoll(seconds-&gt;ptr,NULL,10);
366      if (cmd-&gt;proc == expireCommand || cmd-&gt;proc == setexCommand ||
367          cmd-&gt;proc == expireatCommand)
368      {
369          when *= 1000;
370      }
371      if (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||
372          cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand)
373      {
374          when += mstime();
375      }
376      decrRefCount(seconds);
377      argv[0] = createStringObject(&quot;PEXPIREAT&quot;,9);
378      argv[1] = key;
379      argv[2] = createStringObjectFromLongLong(when);
380      buf = catAppendOnlyGenericCommand(buf, 3, argv);
381      decrRefCount(argv[0]);
382      decrRefCount(argv[2]);
383      return buf;
384  }
385  void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
386      sds buf = sdsempty();
387      robj *tmpargv[3];
388      if (dictid != server.aof_selected_db) {
389          char seldb[64];
390          snprintf(seldb,sizeof(seldb),&quot;%d&quot;,dictid);
391          WIN32_ONLY(seldb[sizeof(seldb)-1] = 0;) &amp;bsol;*get rid of C6053 warning*/
392          buf = sdscatprintf(buf,&quot;*2\r\n$6\r\nSELECT\r\n$%Iu\r\n%s\r\n&quot;, WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
393              (PORT_ULONG)strlen(seldb),seldb);
394          server.aof_selected_db = dictid;
395      }
396      if (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||
397          cmd-&gt;proc == expireatCommand) {
398          buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
399      } else if (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) {
400          tmpargv[0] = createStringObject(&quot;SET&quot;,3);
401          tmpargv[1] = argv[1];
402          tmpargv[2] = argv[3];
403          buf = catAppendOnlyGenericCommand(buf,3,tmpargv);
404          decrRefCount(tmpargv[0]);
405          buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
406      } else if (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; 3) {
407          int i;
408          robj *exarg = NULL, *pxarg = NULL;
409          buf = catAppendOnlyGenericCommand(buf,3,argv);
410          for (i = 3; i &lt; argc; i ++) {
411              if (!strcasecmp(argv[i]-&gt;ptr, &quot;ex&quot;)) exarg = argv[i+1];
412              if (!strcasecmp(argv[i]-&gt;ptr, &quot;px&quot;)) pxarg = argv[i+1];
413          }
414          serverAssert(!(exarg &amp;&amp; pxarg));
415          if (exarg)
416              buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[1],
417                                                 exarg);
418          if (pxarg)
419              buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[1],
420                                                 pxarg);
421      } else {
422          buf = catAppendOnlyGenericCommand(buf,argc,argv);
423      }
424      if (server.aof_state == AOF_ON)
425          server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));
426      if (server.aof_child_pid != -1)
427          aofRewriteBufferAppend((unsigned char*)buf,(PORT_ULONG)sdslen(buf));    WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONG) */
428      sdsfree(buf);
429  }
430  struct client *createFakeClient(void) {
431      struct client *c = zmalloc(sizeof(*c));
432      selectDb(c,0);
433      c-&gt;fd = -1;
434      c-&gt;name = NULL;
435      c-&gt;querybuf = sdsempty();
436      c-&gt;querybuf_peak = 0;
437      c-&gt;argc = 0;
438      c-&gt;argv = NULL;
439      c-&gt;bufpos = 0;
440      c-&gt;flags = 0;
441      c-&gt;btype = BLOCKED_NONE;
442      c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;
443      c-&gt;reply = listCreate();
444      c-&gt;reply_bytes = 0;
445      c-&gt;obuf_soft_limit_reached_time = 0;
446      c-&gt;watched_keys = listCreate();
447      c-&gt;peerid = NULL;
448      listSetFreeMethod(c-&gt;reply,freeClientReplyValue);
449      listSetDupMethod(c-&gt;reply,dupClientReplyValue);
450      initClientMultiState(c);
451      return c;
452  }
453  void freeFakeClientArgv(struct client *c) {
454      int j;
455      for (j = 0; j &lt; c-&gt;argc; j++)
456          decrRefCount(c-&gt;argv[j]);
457      zfree(c-&gt;argv);
458  }
459  void freeFakeClient(struct client *c) {
460      sdsfree(c-&gt;querybuf);
461      listRelease(c-&gt;reply);
462      listRelease(c-&gt;watched_keys);
463      freeClientMultiState(c);
464      zfree(c);
465  }
466  int loadAppendOnlyFile(char *filename) {
467      struct client *fakeClient;
468      FILE *fp = fopen(filename, IF_WIN32(&quot;rb&quot;, &quot;r&quot;));
469      struct redis_stat sb;
470      int old_aof_state = server.aof_state;
471      PORT_LONG loops = 0;
472      off_t valid_up_to = 0; &amp;bsol;* Offset of latest well-formed command loaded. */
473      off_t valid_before_multi = 0; &amp;bsol;* Offset before MULTI command loaded. */
474      if (fp == NULL) {
475          serverLog(LL_WARNING,&quot;Fatal error: can&#x27;t open the append log file for reading: %s&quot;,strerror(errno));
476          exit(1);
477      }
478      if (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != -1 &amp;&amp; sb.st_size == 0) {
479          server.aof_current_size = 0;
480          server.aof_fsync_offset = server.aof_current_size;
481          fclose(fp);
482          return C_ERR;
483      }
484      server.aof_state = AOF_OFF;
485      fakeClient = createFakeClient();
486      startLoading(fp);
487      char sig[5]; &amp;bsol;* &quot;REDIS&quot; */
488      if (fread(sig,1,5,fp) != 5 || memcmp(sig,&quot;REDIS&quot;,5) != 0) {
489          if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
490      } else {
491          rio rdb;
492          serverLog(LL_NOTICE,&quot;Reading RDB preamble from AOF file...&quot;);
493          if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
494          rioInitWithFile(&amp;rdb,fp);
495          if (rdbLoadRio(&amp;rdb,NULL,1) != C_OK) {
496              serverLog(LL_WARNING,&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;);
497              goto readerr;
498          } else {
499              serverLog(LL_NOTICE,&quot;Reading the remaining AOF tail...&quot;);
500          }
501      }
502      while(1) {
503          int argc, j;
504          PORT_ULONG len;
505          robj **argv;
506          char buf[128];
507          sds argsds;
508          struct redisCommand *cmd;
509          if (!(loops++ % 1000)) {
510              loadingProgress((off_t) ftello(fp));                                 WIN_PORT_FIX &amp;bsol;* cast (off_t) */
511              processEventsWhileBlocked();
512          }
513          if (fgets(buf,sizeof(buf),fp) == NULL) {
514              if (feof(fp))
515                  break;
516              else
517                  goto readerr;
518          }
519          if (buf[0] != &#x27;*&#x27;) goto fmterr;
520          if (buf[1] == &#x27;\0&#x27;) goto readerr;
521          argc = atoi(buf+1);
522          if (argc &lt; 1) goto fmterr;
523          argv = zmalloc(sizeof(robj*)*argc);
524          fakeClient-&gt;argc = argc;
525          fakeClient-&gt;argv = argv;
526          for (j = 0; j &lt; argc; j++) {
527              char *readres = fgets(buf,sizeof(buf),fp);
528              if (readres == NULL || buf[0] != &#x27;$&#x27;) {
529                  fakeClient-&gt;argc = j; &amp;bsol;* Free up to j-1. */
530                  freeFakeClientArgv(fakeClient);
531                  if (readres == NULL)
532                      goto readerr;
533                  else
534                      goto fmterr;
535              }
536              len = strtol(buf+1,NULL,10);
537              argsds = sdsnewlen(SDS_NOINIT,len);
538              if (len &amp;&amp; fread(argsds,len,1,fp) == 0) {
539                  sdsfree(argsds);
540                  fakeClient-&gt;argc = j; &amp;bsol;* Free up to j-1. */
541                  freeFakeClientArgv(fakeClient);
542                  goto readerr;
543              }
544              argv[j] = createObject(OBJ_STRING,argsds);
545              if (fread(buf,2,1,fp) == 0) {
546                  fakeClient-&gt;argc = j+1; &amp;bsol;* Free up to j. */
547                  freeFakeClientArgv(fakeClient);
548                  goto readerr;
549              }
550          }
551          cmd = lookupCommand(argv[0]-&gt;ptr);
552          if (!cmd) {
553              serverLog(LL_WARNING,
554                  &quot;Unknown command &#x27;%s&#x27; reading the append only file&quot;,
555                  (char*)argv[0]-&gt;ptr);
556              exit(1);
557          }
558          if (cmd == server.multiCommand) valid_before_multi = valid_up_to;
559          fakeClient-&gt;cmd = cmd;
560          if (fakeClient-&gt;flags &amp; CLIENT_MULTI &amp;&amp;
561              fakeClient-&gt;cmd-&gt;proc != execCommand)
562          {
563              queueMultiCommand(fakeClient);
564          } else {
565              cmd-&gt;proc(fakeClient);
566          }
567          serverAssert(fakeClient-&gt;bufpos == 0 &amp;&amp;
568                       listLength(fakeClient-&gt;reply) == 0);
569          serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == 0);
570          freeFakeClientArgv(fakeClient);
571          fakeClient-&gt;cmd = NULL;
572          if (server.aof_load_truncated) valid_up_to = ftello(fp);
573      }
574      if (fakeClient-&gt;flags &amp; CLIENT_MULTI) {
575          serverLog(LL_WARNING,
576              &quot;Revert incomplete MULTI/EXEC transaction in AOF file&quot;);
577          valid_up_to = valid_before_multi;
578          goto uxeof;
579      }
580  loaded_ok: &amp;bsol;* DB loaded, cleanup and return C_OK to the caller. */
581      fclose(fp);
582      freeFakeClient(fakeClient);
583      server.aof_state = old_aof_state;
584      stopLoading();
585      aofUpdateCurrentSize();
586      server.aof_rewrite_base_size = server.aof_current_size;
587      server.aof_fsync_offset = server.aof_current_size;
588      return C_OK;
589  readerr: &amp;bsol;* Read error. If feof(fp) is true, fall through to unexpected EOF. */
590      if (!feof(fp)) {
591          if (fakeClient) freeFakeClient(fakeClient); &amp;bsol;* avoid valgrind warning */
592          serverLog(LL_WARNING,&quot;Unrecoverable error reading the append only file: %s&quot;, strerror(errno));
593          exit(1);
594      }
595  uxeof: &amp;bsol;* Unexpected AOF end of file. */
596      if (server.aof_load_truncated) {
597          serverLog(LL_WARNING,&quot;!!! Warning: short read while loading the AOF file !!!&quot;);
598          serverLog(LL_WARNING,&quot;!!! Truncating the AOF at offset %llu !!!&quot;,
599              (PORT_ULONGLONG) valid_up_to);
600          if (valid_up_to == -1 || truncate(filename,valid_up_to) == -1) {
601              if (valid_up_to == -1) {
602                  serverLog(LL_WARNING,&quot;Last valid command offset is invalid&quot;);
603              } else {
604                  serverLog(LL_WARNING,&quot;Error truncating the AOF file: %s&quot;,
605                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
606              }
607          } else {
608              if (server.aof_fd != -1 &amp;&amp; lseek(server.aof_fd,0,SEEK_END) == -1) {
609                  serverLog(LL_WARNING,&quot;Can&#x27;t seek the end of the AOF file: %s&quot;,
610                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
611              } else {
612                  serverLog(LL_WARNING,
613                      &quot;AOF loaded anyway because aof-load-truncated is enabled&quot;);
614                  goto loaded_ok;
615              }
616          }
617      }
618      if (fakeClient) freeFakeClient(fakeClient); &amp;bsol;* avoid valgrind warning */
619      serverLog(LL_WARNING,&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &#x27;aof-load-truncated&#x27; configuration option to yes and restart the server.&quot;);
620      exit(1);
621  fmterr: &amp;bsol;* Format error. */
622      if (fakeClient) freeFakeClient(fakeClient); &amp;bsol;* avoid valgrind warning */
623      serverLog(LL_WARNING,&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;);
624      exit(1);
625  }
626  int rioWriteBulkObject(rio *r, robj *obj) {
627      if (obj-&gt;encoding == OBJ_ENCODING_INT) {
628          return (int)rioWriteBulkLongLong(r,(PORT_LONG)obj-&gt;ptr);               WIN_PORT_FIX &amp;bsol;* cast (int) */
629      } else if (sdsEncodedObject(obj)) {
630          return (int)rioWriteBulkString(r,obj-&gt;ptr,sdslen(obj-&gt;ptr));           WIN_PORT_FIX &amp;bsol;* cast (int) */
631      } else {
632          serverPanic(&quot;Unknown string encoding&quot;);
633      }
634  }
635  int rewriteListObject(rio *r, robj *key, robj *o) {
636      PORT_LONGLONG count = 0, items = listTypeLength(o);
637      if (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) {
638          quicklist *list = o-&gt;ptr;
639          quicklistIter *li = quicklistGetIterator(list, AL_START_HEAD);
640          quicklistEntry entry;
641          while (quicklistNext(li,&amp;entry)) {
642              if (count == 0) {
643                  PORT_LONGLONG cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ?  WIN_PORT_FIX &amp;bsol;* int -&gt; PORT_LONGLONG */
644                      AOF_REWRITE_ITEMS_PER_CMD : items;
645                  if (rioWriteBulkCount(r,&#x27;*&#x27;,2+cmd_items) == 0) return 0;
646                  if (rioWriteBulkString(r,&quot;RPUSH&quot;,5) == 0) return 0;
647                  if (rioWriteBulkObject(r,key) == 0) return 0;
648              }
649              if (entry.value) {
650                  if (rioWriteBulkString(r,(char*)entry.value,entry.sz) == 0) return 0;
651              } else {
652                  if (rioWriteBulkLongLong(r,entry.longval) == 0) return 0;
653              }
654              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
655              items--;
656          }
657          quicklistReleaseIterator(li);
658      } else {
659          serverPanic(&quot;Unknown list encoding&quot;);
660      }
661      return 1;
662  }
663  int rewriteSetObject(rio *r, robj *key, robj *o) {
664      PORT_LONGLONG count = 0, items = setTypeSize(o);
665      if (o-&gt;encoding == OBJ_ENCODING_INTSET) {
666          int ii = 0;
667          int64_t llval;
668          while(intsetGet(o-&gt;ptr,ii++,&amp;llval)) {
669              if (count == 0) {
670                  int cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ?
671                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &amp;bsol;* cast (int) */
672                  if (rioWriteBulkCount(r,&#x27;*&#x27;,(PORT_LONG)2+cmd_items) == 0) return 0;  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONG) */
673                  if (rioWriteBulkString(r,&quot;SADD&quot;,4) == 0) return 0;
674                  if (rioWriteBulkObject(r,key) == 0) return 0;
675              }
676              if (rioWriteBulkLongLong(r,llval) == 0) return 0;
677              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
678              items--;
679          }
680      } else if (o-&gt;encoding == OBJ_ENCODING_HT) {
681          dictIterator *di = dictGetIterator(o-&gt;ptr);
682          dictEntry *de;
683          while((de = dictNext(di)) != NULL) {
684              sds ele = dictGetKey(de);
685              if (count == 0) {
686                  int cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ?
687                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &amp;bsol;* cast (int) */
688                  if (rioWriteBulkCount(r,&#x27;*&#x27;,(PORT_LONG)2+cmd_items) == 0) return 0;  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONG) */
689                  if (rioWriteBulkString(r,&quot;SADD&quot;,4) == 0) return 0;
690                  if (rioWriteBulkObject(r,key) == 0) return 0;
691              }
692              if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
693              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
694              items--;
695          }
696          dictReleaseIterator(di);
697      } else {
698          serverPanic(&quot;Unknown set encoding&quot;);
699      }
700      return 1;
701  }
702  int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
703      PORT_LONGLONG count = 0, items = zsetLength(o);
704      if (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
705          unsigned char *zl = o-&gt;ptr;
706          unsigned char *eptr, *sptr;
707          unsigned char *vstr;
708          unsigned int vlen;
709          PORT_LONGLONG vll;
710          double score;
<span onclick='openModal()' class='match'>711          eptr = ziplistIndex(zl,0);
712          serverAssert(eptr != NULL);
713          sptr = ziplistNext(zl,eptr);
714          serverAssert(sptr != NULL);
715          while (eptr != NULL) {
716              serverAssert(ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vll));
717              score = zzlGetScore(sptr);
718              if (count == 0) {
</span>719                  int cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ?
720                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &amp;bsol;* cast (int) */
721                  if (rioWriteBulkCount(r,&#x27;*&#x27;,2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONG) */
722                  if (rioWriteBulkString(r,&quot;ZADD&quot;,4) == 0) return 0;
723                  if (rioWriteBulkObject(r,key) == 0) return 0;
724              }
725              if (rioWriteBulkDouble(r,score) == 0) return 0;
726              if (vstr != NULL) {
727                  if (rioWriteBulkString(r,(char*)vstr,vlen) == 0) return 0;
728              } else {
729                  if (rioWriteBulkLongLong(r,vll) == 0) return 0;
730              }
731              zzlNext(zl,&amp;eptr,&amp;sptr);
732              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
733              items--;
734          }
735      } else if (o-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
736          zset *zs = o-&gt;ptr;
737          dictIterator *di = dictGetIterator(zs-&gt;dict);
738          dictEntry *de;
739          while((de = dictNext(di)) != NULL) {
740              sds ele = dictGetKey(de);
741              double *score = dictGetVal(de);
742              if (count == 0) {
743                  int cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ?
744                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &amp;bsol;* cast (int) */
745                  if (rioWriteBulkCount(r,&#x27;*&#x27;,2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONG) */
746                  if (rioWriteBulkString(r,&quot;ZADD&quot;,4) == 0) return 0;
747                  if (rioWriteBulkObject(r,key) == 0) return 0;
748              }
749              if (rioWriteBulkDouble(r,*score) == 0) return 0;
750              if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
751              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
752              items--;
753          }
754          dictReleaseIterator(di);
755      } else {
756          serverPanic(&quot;Unknown sorted zset encoding&quot;);
757      }
758      return 1;
759  }
760  static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {
761      if (hi-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
762          unsigned char *vstr = NULL;
763          unsigned int vlen = UINT_MAX;
764          PORT_LONGLONG vll = LLONG_MAX;
765          hashTypeCurrentFromZiplist(hi, what, &amp;vstr, &amp;vlen, &amp;vll);
766          if (vstr)
767              return (int)rioWriteBulkString(r, (char*)vstr, vlen);       WIN_PORT_FIX &amp;bsol;* cast (int) */
768          else
769              return (int)rioWriteBulkLongLong(r, vll);                   WIN_PORT_FIX &amp;bsol;* cast (int) */
770      } else if (hi-&gt;encoding == OBJ_ENCODING_HT) {
771          sds value = hashTypeCurrentFromHashTable(hi, what);
772          return (int)rioWriteBulkString(r, value, sdslen(value));        WIN_PORT_FIX &amp;bsol;* cast (int) */
773      }
774      serverPanic(&quot;Unknown hash encoding&quot;);
775      return 0;
776  }
777  int rewriteHashObject(rio *r, robj *key, robj *o) {
778      hashTypeIterator *hi;
779      PORT_LONGLONG count = 0, items = hashTypeLength(o);
780      hi = hashTypeInitIterator(o);
781      while (hashTypeNext(hi) != C_ERR) {
782          if (count == 0) {
783              int cmd_items = (int) ((items &gt; AOF_REWRITE_ITEMS_PER_CMD) ? WIN_PORT_FIX &amp;bsol;* cast (int) */
784                  AOF_REWRITE_ITEMS_PER_CMD : items);
785              if (rioWriteBulkCount(r,&#x27;*&#x27;,2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONG) */
786              if (rioWriteBulkString(r,&quot;HMSET&quot;,5) == 0) return 0;
787              if (rioWriteBulkObject(r,key) == 0) return 0;
788          }
789          if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) return 0;
790          if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) return 0;
791          if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
792          items--;
793      }
794      hashTypeReleaseIterator(hi);
795      return 1;
796  }
797  int rioWriteBulkStreamID(rio *r,streamID *id) {
798      int retval;
799      sds replyid = sdscatfmt(sdsempty(),&quot;%U-%U&quot;,id-&gt;ms,id-&gt;seq);
800      retval = rioWriteBulkString(r,replyid,sdslen(replyid));
801      sdsfree(replyid);
802      return retval;
803  }
804  int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer, unsigned char *rawid, streamNACK *nack) {
805      streamID id;
806      streamDecodeID(rawid,&amp;id);
807      if (rioWriteBulkCount(r,&#x27;*&#x27;,12) == 0) return 0;
808      if (rioWriteBulkString(r,&quot;XCLAIM&quot;,6) == 0) return 0;
809      if (rioWriteBulkObject(r,key) == 0) return 0;
810      if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
811      if (rioWriteBulkString(r,consumer-&gt;name,sdslen(consumer-&gt;name)) == 0) return 0;
812      if (rioWriteBulkString(r,&quot;0&quot;,1) == 0) return 0;
813      if (rioWriteBulkStreamID(r,&amp;id) == 0) return 0;
814      if (rioWriteBulkString(r,&quot;TIME&quot;,4) == 0) return 0;
815      if (rioWriteBulkLongLong(r,nack-&gt;delivery_time) == 0) return 0;
816      if (rioWriteBulkString(r,&quot;RETRYCOUNT&quot;,10) == 0) return 0;
817      if (rioWriteBulkLongLong(r,nack-&gt;delivery_count) == 0) return 0;
818      if (rioWriteBulkString(r,&quot;JUSTID&quot;,6) == 0) return 0;
819      if (rioWriteBulkString(r,&quot;FORCE&quot;,5) == 0) return 0;
820      return 1;
821  }
822  int rewriteStreamObject(rio *r, robj *key, robj *o) {
823      stream *s = o-&gt;ptr;
824      streamIterator si;
825      streamIteratorStart(&amp;si,s,NULL,NULL,0);
826      streamID id;
827      int64_t numfields;
828      if (s-&gt;length) {
829          while(streamIteratorGetID(&amp;si,&amp;id,&amp;numfields)) {
830              if (rioWriteBulkCount(r,&#x27;*&#x27;,3+numfields*2) == 0) return 0;
831              if (rioWriteBulkString(r,&quot;XADD&quot;,4) == 0) return 0;
832              if (rioWriteBulkObject(r,key) == 0) return 0;
833              if (rioWriteBulkStreamID(r,&amp;id) == 0) return 0;
834              while(numfields--) {
835                  unsigned char *field, *value;
836                  int64_t field_len, value_len;
837                  streamIteratorGetField(&amp;si,&amp;field,&amp;value,&amp;field_len,&amp;value_len);
838                  if (rioWriteBulkString(r,(char*)field,field_len) == 0) return 0;
839                  if (rioWriteBulkString(r,(char*)value,value_len) == 0) return 0;
840              }
841          }
842      } else {
843          if (rioWriteBulkCount(r,&#x27;*&#x27;,7) == 0) return 0;
844          if (rioWriteBulkString(r,&quot;XADD&quot;,4) == 0) return 0;
845          if (rioWriteBulkObject(r,key) == 0) return 0;
846          if (rioWriteBulkString(r,&quot;MAXLEN&quot;,6) == 0) return 0;
847          if (rioWriteBulkString(r,&quot;0&quot;,1) == 0) return 0;
848          if (rioWriteBulkStreamID(r,&amp;s-&gt;last_id) == 0) return 0;
849          if (rioWriteBulkString(r,&quot;x&quot;,1) == 0) return 0;
850          if (rioWriteBulkString(r,&quot;y&quot;,1) == 0) return 0;
851      }
852      if (rioWriteBulkCount(r,&#x27;*&#x27;,3) == 0) return 0;
853      if (rioWriteBulkString(r,&quot;XSETID&quot;,6) == 0) return 0;
854      if (rioWriteBulkObject(r,key) == 0) return 0;
855      if (rioWriteBulkStreamID(r,&amp;s-&gt;last_id) == 0) return 0;
856      if (s-&gt;cgroups) {
857          raxIterator ri;
858          raxStart(&amp;ri,s-&gt;cgroups);
859          raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
860          while(raxNext(&amp;ri)) {
861              streamCG *group = ri.data;
862              if (rioWriteBulkCount(r,&#x27;*&#x27;,5) == 0) return 0;
863              if (rioWriteBulkString(r,&quot;XGROUP&quot;,6) == 0) return 0;
864              if (rioWriteBulkString(r,&quot;CREATE&quot;,6) == 0) return 0;
865              if (rioWriteBulkObject(r,key) == 0) return 0;
866              if (rioWriteBulkString(r,(char*)ri.key,ri.key_len) == 0) return 0;
867              if (rioWriteBulkStreamID(r,&amp;group-&gt;last_id) == 0) return 0;
868              raxIterator ri_cons;
869              raxStart(&amp;ri_cons,group-&gt;consumers);
870              raxSeek(&amp;ri_cons,&quot;^&quot;,NULL,0);
871              while(raxNext(&amp;ri_cons)) {
872                  streamConsumer *consumer = ri_cons.data;
873                  raxIterator ri_pel;
874                  raxStart(&amp;ri_pel,consumer-&gt;pel);
875                  raxSeek(&amp;ri_pel,&quot;^&quot;,NULL,0);
876                  while(raxNext(&amp;ri_pel)) {
877                      streamNACK *nack = ri_pel.data;
878                      if (rioWriteStreamPendingEntry(r,key,(char*)ri.key,
879                                                     ri.key_len,consumer,
880                                                     ri_pel.key,nack) == 0)
881                      {
882                          return 0;
883                      }
884                  }
885                  raxStop(&amp;ri_pel);
886              }
887              raxStop(&amp;ri_cons);
888          }
889          raxStop(&amp;ri);
890      }
891      streamIteratorStop(&amp;si);
892      return 1;
893  }
894  int rewriteModuleObject(rio *r, robj *key, robj *o) {
895      RedisModuleIO io;
896      moduleValue *mv = o-&gt;ptr;
897      moduleType *mt = mv-&gt;type;
898      moduleInitIOContext(io,mt,r,key);
899      mt-&gt;aof_rewrite(&amp;io,key,mv-&gt;value);
900      if (io.ctx) {
901          moduleFreeContext(io.ctx);
902          zfree(io.ctx);
903      }
904      return io.error ? 0 : 1;
905  }
906  ssize_t aofReadDiffFromParent(void) {
907  #ifndef _WIN32
908      char buf[65536]; &amp;bsol;* Default pipe buffer size on most Linux systems. */
909  #else
910      char* buf = zmalloc(65536); 
911  #endif
912      ssize_t nread, total = 0;
913      while ((nread =
914              read(server.aof_pipe_read_data_from_parent,buf,IF_WIN32(65536,sizeof(buf)))) &gt; 0) {
915          server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);
916          total += nread;
917      }
918  #ifdef _WIN32
919      zfree(buf);
920  #endif
921      return total;
922  }
923  int rewriteAppendOnlyFileRio(rio *aof) {
924      dictIterator *di = NULL;
925      dictEntry *de;
926      size_t processed = 0;
927      int j;
928      for (j = 0; j &lt; server.dbnum; j++) {
929          char selectcmd[] = &quot;*2\r\n$6\r\nSELECT\r\n&quot;;
930          redisDb *db = server.db+j;
931          dict *d = db-&gt;dict;
932          if (dictSize(d) == 0) continue;
933          di = dictGetSafeIterator(d);
934          if (rioWrite(aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
935          if (rioWriteBulkLongLong(aof,j) == 0) goto werr;
936          while((de = dictNext(di)) != NULL) {
937              sds keystr;
938              robj key, *o;
939              PORT_LONGLONG expiretime;
940              keystr = dictGetKey(de);
941              o = dictGetVal(de);
942              initStaticStringObject(key,keystr);
943              expiretime = getExpire(db,&amp;key);
944              if (o-&gt;type == OBJ_STRING) {
945                  char cmd[]=&quot;*3\r\n$3\r\nSET\r\n&quot;;
946                  if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
947                  if (rioWriteBulkObject(aof,&amp;key) == 0) goto werr;
948                  if (rioWriteBulkObject(aof,o) == 0) goto werr;
949              } else if (o-&gt;type == OBJ_LIST) {
950                  if (rewriteListObject(aof,&amp;key,o) == 0) goto werr;
951              } else if (o-&gt;type == OBJ_SET) {
952                  if (rewriteSetObject(aof,&amp;key,o) == 0) goto werr;
953              } else if (o-&gt;type == OBJ_ZSET) {
954                  if (rewriteSortedSetObject(aof,&amp;key,o) == 0) goto werr;
955              } else if (o-&gt;type == OBJ_HASH) {
956                  if (rewriteHashObject(aof,&amp;key,o) == 0) goto werr;
957              } else if (o-&gt;type == OBJ_STREAM) {
958                  if (rewriteStreamObject(aof,&amp;key,o) == 0) goto werr;
959              } else if (o-&gt;type == OBJ_MODULE) {
960                  if (rewriteModuleObject(aof,&amp;key,o) == 0) goto werr;
961              } else {
962                  serverPanic(&quot;Unknown object type&quot;);
963              }
964              if (expiretime != -1) {
965                  char cmd[]=&quot;*3\r\n$9\r\nPEXPIREAT\r\n&quot;;
966                  if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
967                  if (rioWriteBulkObject(aof,&amp;key) == 0) goto werr;
968                  if (rioWriteBulkLongLong(aof,expiretime) == 0) goto werr;
969              }
970              if (aof-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES) {
971                  processed = aof-&gt;processed_bytes;
972                  aofReadDiffFromParent();
973              }
974          }
975          dictReleaseIterator(di);
976          di = NULL;
977      }
978      return C_OK;
979  werr:
980      if (di) dictReleaseIterator(di);
981      return C_ERR;
982  }
983  int rewriteAppendOnlyFile(char *filename) {
984      rio aof;
985      FILE *fp;
986      char tmpfile[256];
987      char byte;
988      snprintf(tmpfile,256,&quot;temp-rewriteaof-%d.aof&quot;, (int) getpid());
989      fp = fopen(tmpfile, IF_WIN32(&quot;wb&quot;, &quot;w&quot;));
990      if (!fp) {
991          serverLog(LL_WARNING, &quot;Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
992          return C_ERR;
993      }
994      server.aof_child_diff = sdsempty();
995      rioInitWithFile(&amp;aof,fp);
996      if (server.aof_rewrite_incremental_fsync)
997          rioSetAutoSync(&amp;aof,REDIS_AUTOSYNC_BYTES);
998      if (server.aof_use_rdb_preamble) {
999          int error;
1000          if (rdbSaveRio(&amp;aof,&amp;error,RDB_SAVE_AOF_PREAMBLE,NULL) == C_ERR) {
1001              errno = error;
1002              goto werr;
1003          }
1004      } else {
1005          if (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) goto werr;
1006      }
1007      if (fflush(fp) == EOF) goto werr;
1008      if (fsync(fileno(fp)) == -1) goto werr;
1009      int nodata = 0;
1010      mstime_t start = mstime();
1011      while(mstime()-start &lt; 1000 &amp;&amp; nodata &lt; 20) {
1012          if (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, 1) &lt;= 0)
1013          {
1014              nodata++;
1015              continue;
1016          }
1017          nodata = 0; &amp;bsol;* Start counting from zero, we stop on N *contiguous*
1018                         timeouts. */
1019          aofReadDiffFromParent();
1020      }
1021      if (write(server.aof_pipe_write_ack_to_parent,&quot;!&quot;,1) != 1) goto werr;
1022  #ifndef _WIN32
1023      if (anetNonBlock(NULL,server.aof_pipe_read_ack_from_parent) != ANET_OK)
1024          goto werr;
1025  #endif
1026      if (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,1,5000) != 1 ||
1027          byte != &#x27;!&#x27;) goto werr;
1028      serverLog(LL_NOTICE,&quot;Parent agreed to stop sending diffs. Finalizing AOF...&quot;);
1029      aofReadDiffFromParent();
1030      serverLog(LL_NOTICE,
1031          &quot;Concatenating %.2f MB of AOF diff received from parent.&quot;,
1032          (double) (sdslen(server.aof_child_diff) / (1024*1024)));  WIN_PORT_FIX
1033      if (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == 0)
1034          goto werr;
1035      if (fflush(fp) == EOF) goto werr;
1036      if (fsync(fileno(fp)) == -1) goto werr;
1037      if (fclose(fp) == EOF) goto werr;
1038      if (rename(tmpfile,filename) == -1) {
1039          serverLog(LL_WARNING,&quot;Error moving temp append only file on the final destination: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1040          unlink(tmpfile);
1041          return C_ERR;
1042      }
1043      serverLog(LL_NOTICE,&quot;SYNC append only file rewrite performed&quot;);
1044      return C_OK;
1045  werr:
1046      serverLog(LL_WARNING,&quot;Write error writing append only file on disk: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1047      fclose(fp);
1048      unlink(tmpfile);
1049      return C_ERR;
1050  }
1051  void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
1052      char byte;
1053      UNUSED(el);
1054      UNUSED(privdata);
1055      UNUSED(mask);
1056      if (read(fd,&amp;byte,1) == 1 &amp;&amp; byte == &#x27;!&#x27;) {
1057          serverLog(LL_NOTICE,&quot;AOF rewrite child asks to stop sending diffs.&quot;);
1058          server.aof_stop_sending_diff = 1;
1059          if (write(server.aof_pipe_write_ack_to_child,&quot;!&quot;,1) != 1) {
1060              serverLog(LL_WARNING,&quot;Can&#x27;t send ACK to AOF child: %s&quot;,
1061                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1062          }
1063      }
1064  #ifndef _WIN32
1065      aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
1066  #endif
1067  }
1068  int aofCreatePipes(void) {
1069      int fds[6] = {-1, -1, -1, -1, -1, -1};
1070      int j;
1071      if (pipe(fds) == -1) goto error; &amp;bsol;* parent -&gt; children data. */
1072      if (pipe(fds+2) == -1) goto error; &amp;bsol;* children -&gt; parent ack. */
1073      if (pipe(fds+4) == -1) goto error; &amp;bsol;* parent -&gt; children ack. */
1074  #ifndef WIN32
1075      if (anetNonBlock(NULL,fds[0]) != ANET_OK) goto error;
1076      if (anetNonBlock(NULL,fds[1]) != ANET_OK) goto error;
1077      if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) == AE_ERR) goto error;
1078  #else
1079      if (FDAPI_PipeSetNonBlock(fds[0], 1) != 0) goto error;
1080      if (FDAPI_PipeSetNonBlock(fds[1], 1) != 0) goto error;
1081      if (FDAPI_PipeSetNonBlock(fds[2], 1) != 0) goto error;
1082  #endif
1083      server.aof_pipe_write_data_to_child = fds[1];
1084      server.aof_pipe_read_data_from_parent = fds[0];
1085      server.aof_pipe_write_ack_to_parent = fds[3];
1086      server.aof_pipe_read_ack_from_child = fds[2];
1087      server.aof_pipe_write_ack_to_child = fds[5];
1088      server.aof_pipe_read_ack_from_parent = fds[4];
1089      server.aof_stop_sending_diff = 0;
1090      return C_OK;
1091  error:
1092      serverLog(LL_WARNING,&quot;Error opening /setting AOF rewrite IPC pipes: %s&quot;,
1093          IF_WIN32(wsa_strerror(errno), strerror(errno)));
1094      for (j = 0; j &lt; 6; j++) if(fds[j] != -1) close(fds[j]);
1095      return C_ERR;
1096  }
1097  void aofClosePipes(void) {
1098      aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
1099      aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,AE_WRITABLE);
1100      close(server.aof_pipe_write_data_to_child);
1101      close(server.aof_pipe_read_data_from_parent);
1102      close(server.aof_pipe_write_ack_to_parent);
1103      close(server.aof_pipe_read_ack_from_child);
1104      close(server.aof_pipe_write_ack_to_child);
1105      close(server.aof_pipe_read_ack_from_parent);
1106  }
1107  int rewriteAppendOnlyFileBackground(void) {
1108      pid_t childpid;
1109      PORT_LONGLONG start;
1110      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
1111      if (aofCreatePipes() != C_OK) return C_ERR;
1112      openChildInfoPipe();
1113      start = ustime();
1114  #ifndef _WIN32
1115      if ((childpid = fork()) == 0) {
1116  #endif
1117          char tmpfile[256];
1118  #ifndef _WIN32
1119          closeListeningSockets(0);
1120          redisSetProcTitle(&quot;redis-aof-rewrite&quot;);
1121  #endif
1122          snprintf(tmpfile,256,&quot;temp-rewriteaof-bg-%d.aof&quot;, (int) getpid());
1123  #ifdef _WIN32
1124          childpid = BeginForkOperation_Aof(server.aof_pipe_write_ack_to_parent,
1125              server.aof_pipe_read_ack_from_parent,
1126              server.aof_pipe_read_data_from_parent,
1127              tmpfile,
1128              &amp;server,
1129              sizeof(server),
1130              dictGetHashFunctionSeed(),
1131              modules);
1132  #else
1133          if (rewriteAppendOnlyFile(tmpfile) == C_OK) {
1134              size_t private_dirty = zmalloc_get_private_dirty(-1);
1135              if (private_dirty) {
1136                  serverLog(LL_NOTICE,
1137                      &quot;AOF rewrite: %Iu MB of memory used by copy-on-write&quot;, WIN_PORT_FIX &amp;bsol;* %zu -&gt; %Iu */
1138                      private_dirty/(1024*1024));
1139              }
1140              server.child_info_data.cow_size = private_dirty;
1141              sendChildInfo(CHILD_INFO_TYPE_AOF);
1142              exitFromChild(0);
1143          } else {
1144              exitFromChild(1);
1145          }
1146      } else {
1147  #endif
1148          server.stat_fork_time = ustime()-start;
1149  #ifdef _WIN32
1150          if (server.stat_fork_time == 0) {
1151              server.stat_fork_time = 100000; 
1152          }
1153  #endif
1154          server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &amp;bsol;* GB per second. */  WIN_PORT_FIX
1155          latencyAddSampleIfNeeded(&quot;fork&quot;,server.stat_fork_time/1000);
1156          if (childpid == -1) {
1157              closeChildInfoPipe();
1158              serverLog(LL_WARNING,
1159                  &quot;Can&#x27;t rewrite append only file in background: fork: %s&quot;,
1160                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1161              aofClosePipes();
1162              return C_ERR;
1163          }
1164          serverLog(LL_NOTICE,
1165              &quot;Background append only file rewriting started by pid %d&quot;,childpid);
1166          server.aof_rewrite_scheduled = 0;
1167          server.aof_rewrite_time_start = time(NULL);
1168          server.aof_child_pid = childpid;
1169          updateDictResizePolicy();
1170          server.aof_selected_db = -1;
1171          replicationScriptCacheFlush();
1172          return C_OK;
1173  #ifndef _WIN32
1174      }
1175  #endif
1176      return C_OK; &amp;bsol;* unreached */
1177  }
1178  void bgrewriteaofCommand(client *c) {
1179      if (server.aof_child_pid != -1) {
1180          addReplyError(c,&quot;Background append only file rewriting already in progress&quot;);
1181      } else if (server.rdb_child_pid != -1) {
1182          server.aof_rewrite_scheduled = 1;
1183          addReplyStatus(c,&quot;Background append only file rewriting scheduled&quot;);
1184      } else if (rewriteAppendOnlyFileBackground() == C_OK) {
1185          addReplyStatus(c,&quot;Background append only file rewriting started&quot;);
1186      } else {
1187          addReply(c,shared.err);
1188      }
1189  }
1190  void aofRemoveTempFile(pid_t childpid) {
1191      char tmpfile[256];
1192      snprintf(tmpfile,256,&quot;temp-rewriteaof-bg-%d.aof&quot;, (int) childpid);
1193      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &amp;bsol;*get rid of C6053 warning*/
1194      unlink(tmpfile);
1195  }
1196  void aofUpdateCurrentSize(void) {
1197      struct redis_stat sb;
1198      mstime_t latency;
1199  #ifdef _WIN32
1200      if (server.aof_fd == -1) {
1201          serverLog(LL_NOTICE, &quot;Unable to check the AOF length: %s&quot;, &quot;appendfd is -1&quot;);
1202          return;
1203      }
1204  #endif
1205      latencyStartMonitor(latency);
1206      if (redis_fstat(server.aof_fd,&amp;sb) == -1) {
1207          serverLog(LL_WARNING,&quot;Unable to obtain the AOF file length. stat: %s&quot;,
1208              IF_WIN32(wsa_strerror(errno), strerror(errno)));
1209      } else {
1210          server.aof_current_size = sb.st_size;
1211      }
1212      latencyEndMonitor(latency);
1213      latencyAddSampleIfNeeded(&quot;aof-fstat&quot;,latency);
1214  }
1215  void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
1216      if (!bysignal &amp;&amp; exitcode == 0) {
1217          int newfd, oldfd;
1218          char tmpfile[256];
1219          PORT_LONGLONG now = ustime();
1220          mstime_t latency;
1221          serverLog(LL_NOTICE,
1222              &quot;Background AOF rewrite terminated with success&quot;);
1223          latencyStartMonitor(latency);
1224  #ifdef _WIN32
1225          snprintf(tmpfile,256,&quot;temp-rewriteaof-bg-%d.aof&quot;,
1226              getpid());
1227          newfd = open(tmpfile,O_WRONLY|O_APPEND|O_CREAT|_O_BINARY,_S_IREAD|_S_IWRITE);
1228  #else
1229          snprintf(tmpfile,256,&quot;temp-rewriteaof-bg-%d.aof&quot;,
1230              (int)server.aof_child_pid);
1231          newfd = open(tmpfile,O_WRONLY|O_APPEND);
1232  #endif
1233          if (newfd == -1) {
1234              serverLog(LL_WARNING,
1235                  &quot;Unable to open the temporary AOF produced by the child: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1236              goto cleanup;
1237          }
1238          if (aofRewriteBufferWrite(newfd) == -1) {
1239              serverLog(LL_WARNING,
1240                  &quot;Error trying to flush the parent diff to the rewritten AOF: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1241              close(newfd);
1242              goto cleanup;
1243          }
1244          latencyEndMonitor(latency);
1245          latencyAddSampleIfNeeded(&quot;aof-rewrite-diff-write&quot;,latency);
1246          serverLog(LL_NOTICE,
1247              &quot;Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)&quot;, (double) (aofRewriteBufferSize() / (1024*1024)));  WIN_PORT_FIX
1248  #ifdef _WIN32
1249          oldfd = -1; &amp;bsol;* We&#x27;ll set this to the current AOF filedes later. */
1250          char tmpfile_win_old[256];
1251          snprintf(tmpfile_win_old, 256, &quot;temp-rewriteaof-old-%d.aof&quot;,
1252              (int) server.aof_child_pid);
1253          if (server.aof_fd != -1) {
1254              close(server.aof_fd);
1255              if (rename(server.aof_filename, tmpfile_win_old) == -1) {
1256                  serverLog(LL_WARNING,
1257                      &quot;Error trying to rename the existing AOF to old tempfile: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1258                  unlink(tmpfile_win_old);
1259                  goto cleanup;
1260              }
1261          }
1262          latencyStartMonitor(latency);
1263          close(newfd);
1264          if (rename(tmpfile, server.aof_filename) == -1) {
1265              serverLog(LL_WARNING,
1266                  &quot;Error trying to rename the temporary AOF file %s into %s: %s&quot;,
1267                  tmpfile,
1268                  server.aof_filename,
1269                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1270              if (server.aof_fd != -1) {
1271                  if (rename(tmpfile_win_old, server.aof_filename) == -1) {
1272                      serverLog(LL_WARNING,
1273                          &quot;Error trying to rename the old tempfile %s into the existing AOF file %s: %s&quot;,
1274                          tmpfile,
1275                          server.aof_filename,
1276                          IF_WIN32(wsa_strerror(errno), strerror(errno)));
1277                      serverLog(LL_WARNING,
1278                          &quot;Error trying to rename the existing AOF from old tempfile: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1279                  }
1280              }
1281              goto cleanup;
1282          }
1283          newfd = open(server.aof_filename, O_WRONLY | O_APPEND | _O_BINARY, 0);
1284          if (newfd == -1) {
1285              serverLog(LL_WARNING, &quot;Not able to reopen the temporary AOF file after rename&quot;);
1286              goto cleanup;
1287          }
1288          if (server.aof_fd != -1) {
1289              server.aof_fd = open(
1290                  tmpfile_win_old,
1291                  O_WRONLY | O_APPEND | O_CREAT | _O_BINARY | _O_TEMPORARY,     
1292                  0644);
1293          }
1294  #else
1295          if (server.aof_fd == -1) {
1296              oldfd = open(server.aof_filename,O_RDONLY|O_NONBLOCK);
1297          } else {
1298              oldfd = -1; &amp;bsol;* We&#x27;ll set this to the current AOF filedes later. */
1299          }
1300          latencyStartMonitor(latency);
1301          if (rename(tmpfile,server.aof_filename) == -1) {
1302              serverLog(LL_WARNING,
1303                  &quot;Error trying to rename the temporary AOF file %s into %s: %s&quot;,
1304                  tmpfile,
1305                  server.aof_filename,
1306                  strerror(errno));
1307              close(newfd);
1308              if (oldfd != -1) close(oldfd);
1309              goto cleanup;
1310          }
1311  #endif
1312          latencyEndMonitor(latency);
1313          latencyAddSampleIfNeeded(&quot;aof-rename&quot;,latency);
1314          if (server.aof_fd == -1) {
1315              close(newfd);
1316          } else {
1317              oldfd = server.aof_fd;
1318              server.aof_fd = newfd;
1319              if (server.aof_fsync == AOF_FSYNC_ALWAYS)
1320                  redis_fsync(newfd);
1321              else if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
1322                  aof_background_fsync(newfd);
1323              server.aof_selected_db = -1; &amp;bsol;* Make sure SELECT is re-issued */
1324              aofUpdateCurrentSize();
1325              server.aof_rewrite_base_size = server.aof_current_size;
1326              server.aof_fsync_offset = server.aof_current_size;
1327              sdsfree(server.aof_buf);
1328              server.aof_buf = sdsempty();
1329          }
1330          server.aof_lastbgrewrite_status = C_OK;
1331          serverLog(LL_NOTICE, &quot;Background AOF rewrite finished successfully&quot;);
1332          if (server.aof_state == AOF_WAIT_REWRITE)
1333              server.aof_state = AOF_ON;
1334          if (oldfd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);
1335          serverLog(LL_VERBOSE,
1336              &quot;Background AOF rewrite signal handler took %lldus&quot;, ustime()-now);
1337      } else if (!bysignal &amp;&amp; exitcode != 0) {
1338          server.aof_lastbgrewrite_status = C_ERR;
1339          serverLog(LL_WARNING,
1340              &quot;Background AOF rewrite terminated with error&quot;);
1341      } else {
1342          if (bysignal != SIGUSR1)
1343              server.aof_lastbgrewrite_status = C_ERR;
1344          serverLog(LL_WARNING,
1345              &quot;Background AOF rewrite terminated by signal %d&quot;, bysignal);
1346      }
1347  cleanup:
1348      aofClosePipes();
1349      aofRewriteBufferReset();
1350      aofRemoveTempFile(IF_WIN32(getpid(), server.aof_child_pid));
1351      server.aof_child_pid = -1;
1352      server.aof_rewrite_time_last = time(NULL)-server.aof_rewrite_time_start;
1353      server.aof_rewrite_time_start = -1;
1354      if (server.aof_state == AOF_WAIT_REWRITE)
1355          server.aof_rewrite_scheduled = 1;
1356  }
1357  #ifdef _WIN32
1358  void aofProcessDiffRewriteEvents(aeEventLoop* eventLoop)
1359  {
1360      if (server.aof_child_pid != -1 &amp;&amp; server.aof_pipe_read_ack_from_child != -1) {
1361          if (server.aof_stop_sending_diff == 0) {
1362              aofChildWriteDiffData(eventLoop,server.aof_pipe_write_data_to_child,NULL,0);
1363          }
1364          if (server.aof_stop_sending_diff == 0) {
1365              aofChildPipeReadable(eventLoop,server.aof_pipe_read_ack_from_child,NULL,0);
1366          }
1367      }
1368  }
1369  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-debug.c</h3>
            <pre><code>1  #include &quot;server.h&quot;
2  #include &quot;sha1.h&quot;   &amp;bsol;* SHA1 is used for DEBUG DIGEST */
3  #include &quot;crc64.h&quot;
4  #ifndef _WIN32
5  #include &lt;arpa/inet.h&gt;
6  #include &lt;dlfcn.h&gt;
7  #else
8  #include &quot;Win32_Interop/Win32_Portability.h&quot;
9  #include &quot;Win32_Interop/dlfcn.h&quot;
10  #endif
11  #include &lt;signal.h&gt;
12  #ifdef HAVE_BACKTRACE
13  #include &lt;execinfo.h&gt;
14  #ifndef __OpenBSD__
15  #include &lt;ucontext.h&gt;
16  #else
17  typedef ucontext_t sigcontext_t;
18  #endif
19  #include &lt;fcntl.h&gt;
20  #include &quot;bio.h&quot;
21  #include &lt;unistd.h&gt;
22  #endif &amp;bsol;* HAVE_BACKTRACE */
23  #ifdef __CYGWIN__
24  #ifndef SA_ONSTACK
25  #define SA_ONSTACK 0x08000000
26  #endif
27  #endif
28  void xorDigest(unsigned char *digest, void *ptr, size_t len) {
29      SHA1_CTX ctx;
30      unsigned char hash[20], *s = ptr;
31      int j;
32      SHA1Init(&amp;ctx);
33      SHA1Update(&amp;ctx,s,(u_int32_t)len);                                          WIN_PORT_FIX &amp;bsol;* cast (u_int32_t) */
34      SHA1Final(hash,&amp;ctx);
35      for (j = 0; j &lt; 20; j++)
36          digest[j] ^= hash[j];
37  }
38  void xorStringObjectDigest(unsigned char *digest, robj *o) {
39      o = getDecodedObject(o);
40      xorDigest(digest,o-&gt;ptr,sdslen(o-&gt;ptr));
41      decrRefCount(o);
42  }
43  void mixDigest(unsigned char *digest, void *ptr, size_t len) {
44      SHA1_CTX ctx;
45      char *s = ptr;
46      xorDigest(digest,s,len);
47      SHA1Init(&amp;ctx);
48      SHA1Update(&amp;ctx,digest,20);
49      SHA1Final(digest,&amp;ctx);
50  }
51  void mixStringObjectDigest(unsigned char *digest, robj *o) {
52      o = getDecodedObject(o);
53      mixDigest(digest,o-&gt;ptr,sdslen(o-&gt;ptr));
54      decrRefCount(o);
55  }
56  void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o) {
57      uint32_t aux = htonl(o-&gt;type);
58      mixDigest(digest,&amp;aux,sizeof(aux));
59      PORT_LONGLONG expiretime = getExpire(db,keyobj);
60      char buf[128];
61      if (o-&gt;type == OBJ_STRING) {
62          mixStringObjectDigest(digest,o);
63      } else if (o-&gt;type == OBJ_LIST) {
64          listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);
65          listTypeEntry entry;
66          while(listTypeNext(li,&amp;entry)) {
67              robj *eleobj = listTypeGet(&amp;entry);
68              mixStringObjectDigest(digest,eleobj);
69              decrRefCount(eleobj);
70          }
71          listTypeReleaseIterator(li);
72      } else if (o-&gt;type == OBJ_SET) {
73          setTypeIterator *si = setTypeInitIterator(o);
74          sds sdsele;
75          while((sdsele = setTypeNextObject(si)) != NULL) {
76              xorDigest(digest,sdsele,sdslen(sdsele));
77              sdsfree(sdsele);
78          }
79          setTypeReleaseIterator(si);
80      } else if (o-&gt;type == OBJ_ZSET) {
81          unsigned char eledigest[20];
82          if (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
83              unsigned char *zl = o-&gt;ptr;
84              unsigned char *eptr, *sptr;
85              unsigned char *vstr;
86              unsigned int vlen;
87              PORT_LONGLONG vll;
88              double score;
<span onclick='openModal()' class='match'>89              eptr = ziplistIndex(zl,0);
90              serverAssert(eptr != NULL);
91              sptr = ziplistNext(zl,eptr);
92              serverAssert(sptr != NULL);
93              while (eptr != NULL) {
94                  serverAssert(ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vll));
95                  score = zzlGetScore(sptr);
96                  memset(eledigest,0,20);
</span>97                  if (vstr != NULL) {
98                      mixDigest(eledigest,vstr,vlen);
99                  } else {
100                      ll2string(buf,sizeof(buf),vll);
101                      mixDigest(eledigest,buf,strlen(buf));
102                  }
103                  snprintf(buf,sizeof(buf),&quot;%.17g&quot;,score);
104                  mixDigest(eledigest,buf,strlen(buf));
105                  xorDigest(digest,eledigest,20);
106                  zzlNext(zl,&amp;eptr,&amp;sptr);
107              }
108          } else if (o-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
109              zset *zs = o-&gt;ptr;
110              dictIterator *di = dictGetIterator(zs-&gt;dict);
111              dictEntry *de;
112              while((de = dictNext(di)) != NULL) {
113                  sds sdsele = dictGetKey(de);
114                  double *score = dictGetVal(de);
115                  snprintf(buf,sizeof(buf),&quot;%.17g&quot;,*score);
116                  memset(eledigest,0,20);
117                  mixDigest(eledigest,sdsele,sdslen(sdsele));
118                  mixDigest(eledigest,buf,strlen(buf));
119                  xorDigest(digest,eledigest,20);
120              }
121              dictReleaseIterator(di);
122          } else {
123              serverPanic(&quot;Unknown sorted set encoding&quot;);
124          }
125      } else if (o-&gt;type == OBJ_HASH) {
126          hashTypeIterator *hi = hashTypeInitIterator(o);
127          while (hashTypeNext(hi) != C_ERR) {
128              unsigned char eledigest[20];
129              sds sdsele;
130              memset(eledigest,0,20);
131              sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
132              mixDigest(eledigest,sdsele,sdslen(sdsele));
133              sdsfree(sdsele);
134              sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
135              mixDigest(eledigest,sdsele,sdslen(sdsele));
136              sdsfree(sdsele);
137              xorDigest(digest,eledigest,20);
138          }
139          hashTypeReleaseIterator(hi);
140      } else if (o-&gt;type == OBJ_STREAM) {
141          streamIterator si;
142          streamIteratorStart(&amp;si,o-&gt;ptr,NULL,NULL,0);
143          streamID id;
144          int64_t numfields;
145          while(streamIteratorGetID(&amp;si,&amp;id,&amp;numfields)) {
146              sds itemid = sdscatfmt(sdsempty(),&quot;%U.%U&quot;,id.ms,id.seq);
147              mixDigest(digest,itemid,sdslen(itemid));
148              sdsfree(itemid);
149              while(numfields--) {
150                  unsigned char *field, *value;
151                  int64_t field_len, value_len;
152                  streamIteratorGetField(&amp;si,&amp;field,&amp;value,
153                                             &amp;field_len,&amp;value_len);
154                  mixDigest(digest,field,field_len);
155                  mixDigest(digest,value,value_len);
156              }
157          }
158          streamIteratorStop(&amp;si);
159      } else if (o-&gt;type == OBJ_MODULE) {
160          RedisModuleDigest md;
161          moduleValue *mv = o-&gt;ptr;
162          moduleType *mt = mv-&gt;type;
163          moduleInitDigestContext(md);
164          if (mt-&gt;digest) {
165              mt-&gt;digest(&amp;md,mv-&gt;value);
166              xorDigest(digest,md.x,sizeof(md.x));
167          }
168      } else {
169          serverPanic(&quot;Unknown object type&quot;);
170      }
171      if (expiretime != -1) xorDigest(digest,&quot;!!expire!!&quot;,10);
172  }
173  void computeDatasetDigest(unsigned char *final) {
174      unsigned char digest[20];
175      dictIterator *di = NULL;
176      dictEntry *de;
177      int j;
178      uint32_t aux;
179      memset(final,0,20); &amp;bsol;* Start with a clean result */
180      for (j = 0; j &lt; server.dbnum; j++) {
181          redisDb *db = server.db+j;
182          if (dictSize(db-&gt;dict) == 0) continue;
183          di = dictGetSafeIterator(db-&gt;dict);
184          aux = htonl(j);
185          mixDigest(final,&amp;aux,sizeof(aux));
186          while((de = dictNext(di)) != NULL) {
187              sds key;
188              robj *keyobj, *o;
189              memset(digest,0,20); &amp;bsol;* This key-val digest */
190              key = dictGetKey(de);
191              keyobj = createStringObject(key,sdslen(key));
192              mixDigest(digest,key,sdslen(key));
193              o = dictGetVal(de);
194              xorObjectDigest(db,keyobj,digest,o);
195              xorDigest(final,digest,20);
196              decrRefCount(keyobj);
197          }
198          dictReleaseIterator(di);
199      }
200  }
201  void debugCommand(client *c) {
202      if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;help&quot;)) {
203          const char *help[] = {
204  &quot;ASSERT -- Crash by assertion failed.&quot;,
205  &quot;CHANGE-REPL-ID -- Change the replication IDs of the instance. Dangerous, should be used only for testing the replication subsystem.&quot;,
206  &quot;CRASH-AND-RECOVER &lt;milliseconds&gt; -- Hard crash and restart after &lt;milliseconds&gt; delay.&quot;,
207  &quot;DIGEST -- Output a hex signature representing the current DB content.&quot;,
208  &quot;DIGEST-VALUE &lt;key-1&gt; ... &lt;key-N&gt;-- Output a hex signature of the values of all the specified keys.&quot;,
209  &quot;ERROR &lt;string&gt; -- Return a Redis protocol error with &lt;string&gt; as message. Useful for clients unit tests to simulate Redis errors.&quot;,
210  &quot;LOG &lt;message&gt; -- write message to the server log.&quot;,
211  &quot;HTSTATS &lt;dbid&gt; -- Return hash table statistics of the specified Redis database.&quot;,
212  &quot;HTSTATS-KEY &lt;key&gt; -- Like htstats but for the hash table stored as key&#x27;s value.&quot;,
213  &quot;LOADAOF -- Flush the AOF buffers on disk and reload the AOF in memory.&quot;,
214  &quot;LUA-ALWAYS-REPLICATE-COMMANDS &lt;0|1&gt; -- Setting it to 1 makes Lua replication defaulting to replicating single commands, without the script having to enable effects replication.&quot;,
215  &quot;OBJECT &lt;key&gt; -- Show low level info about key and associated value.&quot;,
216  &quot;PANIC -- Crash the server simulating a panic.&quot;,
217  &quot;POPULATE &lt;count&gt; [prefix] [size] -- Create &lt;count&gt; string keys named key:&lt;num&gt;. If a prefix is specified is used instead of the &#x27;key&#x27; prefix.&quot;,
218  &quot;RELOAD -- Save the RDB on disk and reload it back in memory.&quot;,
219  &quot;RESTART -- Graceful restart: save config, db, restart.&quot;,
220  &quot;SDSLEN &lt;key&gt; -- Show low level SDS string info representing key and value.&quot;,
221  &quot;SEGFAULT -- Crash the server with sigsegv.&quot;,
222  &quot;SET-ACTIVE-EXPIRE &lt;0|1&gt; -- Setting it to 0 disables expiring keys in background when they are not accessed (otherwise the Redis behavior). Setting it to 1 reenables back the default.&quot;,
223  &quot;SLEEP &lt;seconds&gt; -- Stop the server for &lt;seconds&gt;. Decimals allowed.&quot;,
224  &quot;STRUCTSIZE -- Return the size of different Redis core C structures.&quot;,
225  &quot;ZIPLIST &lt;key&gt; -- Show low level info about the ziplist encoding.&quot;,
226  &quot;STRINGMATCH-TEST -- Run a fuzz tester against the stringmatchlen() function.&quot;,
227  NULL
228          };
229          addReplyHelp(c, help);
230      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;segfault&quot;)) {
231          *((char*)-1) = &#x27;x&#x27;;
232      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;panic&quot;)) {
233          serverPanic(&quot;DEBUG PANIC called at Unix time %Id&quot;, time(NULL));                           WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
234      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;restart&quot;) ||
235                 !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;crash-and-recover&quot;))
236      {
237          PORT_LONGLONG delay = 0;
238          if (c-&gt;argc &gt;= 3) {
239              if (getLongLongFromObjectOrReply(c, c-&gt;argv[2], &amp;delay, NULL)
240                  != C_OK) return;
241              if (delay &lt; 0) delay = 0;
242          }
243          int flags = !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;restart&quot;) ?
244              (RESTART_SERVER_GRACEFULLY|RESTART_SERVER_CONFIG_REWRITE) :
245               RESTART_SERVER_NONE;
246          restartServer(flags,delay);
247          addReplyError(c,&quot;failed to restart the server. Check server logs.&quot;);
248      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;oom&quot;)) {
249          void *ptr = zmalloc(PORT_ULONG_MAX); &amp;bsol;* Should trigger an out of memory. */
250          zfree(ptr);
251          addReply(c,shared.ok);
252      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;assert&quot;)) {
253          serverAssertWithInfo(c,c-&gt;argv[0],1 == 2);
254      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;log&quot;) &amp;&amp; c-&gt;argc == 3) {
255          serverLog(LL_WARNING, &quot;DEBUG LOG: %s&quot;, (char*)c-&gt;argv[2]-&gt;ptr);
256          addReply(c,shared.ok);
257      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;reload&quot;)) {
258          rdbSaveInfo rsi, *rsiptr;
259          rsiptr = rdbPopulateSaveInfo(&amp;rsi);
260          if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {
261              addReply(c,shared.err);
262              return;
263          }
264          emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
265          protectClient(c);
266          int ret = rdbLoad(server.rdb_filename,NULL);
267          unprotectClient(c);
268          if (ret != C_OK) {
269              addReplyError(c,&quot;Error trying to load the RDB dump&quot;);
270              return;
271          }
272          serverLog(LL_WARNING,&quot;DB reloaded by DEBUG RELOAD&quot;);
273          addReply(c,shared.ok);
274      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;loadaof&quot;)) {
275          if (server.aof_state != AOF_OFF) flushAppendOnlyFile(1);
276          emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
277          protectClient(c);
278          int ret = loadAppendOnlyFile(server.aof_filename);
279          unprotectClient(c);
280          if (ret != C_OK) {
281              addReply(c,shared.err);
282              return;
283          }
284          server.dirty = 0; &amp;bsol;* Prevent AOF / replication */
285          serverLog(LL_WARNING,&quot;Append Only File loaded by DEBUG LOADAOF&quot;);
286          addReply(c,shared.ok);
287      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;object&quot;) &amp;&amp; c-&gt;argc == 3) {
288          dictEntry *de;
289          robj *val;
290          char *strenc;
291          if ((de = dictFind(c-&gt;db-&gt;dict,c-&gt;argv[2]-&gt;ptr)) == NULL) {
292              addReply(c,shared.nokeyerr);
293              return;
294          }
295          val = dictGetVal(de);
296          strenc = strEncoding(val-&gt;encoding);
297          char extra[138] = {0};
298          if (val-&gt;encoding == OBJ_ENCODING_QUICKLIST) {
299              char *nextra = extra;
300              int remaining = sizeof(extra);
301              quicklist *ql = val-&gt;ptr;
302              int used = snprintf(nextra, remaining, &quot; ql_nodes:%Iu&quot;, ql-&gt;len);		WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
303              nextra += used;
304              remaining -= used;
305              double avg = (double)ql-&gt;count/ql-&gt;len;
306              used = snprintf(nextra, remaining, &quot; ql_avg_node:%.2f&quot;, avg);
307              nextra += used;
308              remaining -= used;
309              used = snprintf(nextra, remaining, &quot; ql_ziplist_max:%d&quot;, ql-&gt;fill);
310              nextra += used;
311              remaining -= used;
312              int compressed = ql-&gt;compress != 0;
313              used = snprintf(nextra, remaining, &quot; ql_compressed:%d&quot;, compressed);
314              nextra += used;
315              remaining -= used;
316              PORT_ULONG sz = 0;
317              for (quicklistNode *node = ql-&gt;head; node; node = node-&gt;next) {
318                  sz += node-&gt;sz;
319              }
320              used = snprintf(nextra, remaining, &quot; ql_uncompressed_size:%Iu&quot;, sz);        WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
321              nextra += used;
322              remaining -= used;
323          }
324          addReplyStatusFormat(c,
325              &quot;Value at:%p refcount:%d &quot;
326              &quot;encoding:%s serializedlength:%Iu &quot;                                 WIN_PORT_FIX &amp;bsol;* %zu -&gt; %Iu */
327              &quot;lru:%d lru_seconds_idle:%llu%s&quot;,
328              (void*)val, val-&gt;refcount,
329              strenc, (PORT_LONGLONG) rdbSavedObjectLen(val),
330              val-&gt;lru, estimateObjectIdleTime(val)/1000, extra);
331      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;sdslen&quot;) &amp;&amp; c-&gt;argc == 3) {
332          dictEntry *de;
333          robj *val;
334          sds key;
335          if ((de = dictFind(c-&gt;db-&gt;dict,c-&gt;argv[2]-&gt;ptr)) == NULL) {
336              addReply(c,shared.nokeyerr);
337              return;
338          }
339          val = dictGetVal(de);
340          key = dictGetKey(de);
341          if (val-&gt;type != OBJ_STRING || !sdsEncodedObject(val)) {
342              addReplyError(c,&quot;Not an sds encoded string.&quot;);
343          } else {
344              addReplyStatusFormat(c,
345                  &quot;key_sds_len:%lld, key_sds_avail:%lld, key_zmalloc: %lld, &quot;
346                  &quot;val_sds_len:%lld, val_sds_avail:%lld, val_zmalloc: %lld&quot;,
347                  (PORT_LONGLONG) sdslen(key),
348                  (PORT_LONGLONG) sdsavail(key),
349                  (PORT_LONGLONG) sdsZmallocSize(key),
350                  (PORT_LONGLONG) sdslen(val-&gt;ptr),
351                  (PORT_LONGLONG) sdsavail(val-&gt;ptr),
352                  (PORT_LONGLONG) getStringObjectSdsUsedMemory(val));
353          }
354      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;ziplist&quot;) &amp;&amp; c-&gt;argc == 3) {
355          robj *o;
356          if ((o = objectCommandLookupOrReply(c,c-&gt;argv[2],shared.nokeyerr))
357                  == NULL) return;
358          if (o-&gt;encoding != OBJ_ENCODING_ZIPLIST) {
359              addReplyError(c,&quot;Not an sds encoded string.&quot;);
360          } else {
361              ziplistRepr(o-&gt;ptr);
362              addReplyStatus(c,&quot;Ziplist structure printed on stdout&quot;);
363          }
364      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;populate&quot;) &amp;&amp;
365                 c-&gt;argc &gt;= 3 &amp;&amp; c-&gt;argc &lt;= 5) {
366          PORT_LONG keys, j;
367          robj *key, *val;
368          char buf[128];
369          if (getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;keys, NULL) != C_OK)
370              return;
371          dictExpand(c-&gt;db-&gt;dict,keys);
372          for (j = 0; j &lt; keys; j++) {
373              PORT_LONG valsize = 0;
374              snprintf(buf,sizeof(buf),&quot;%s:%Iu&quot;,                                  WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
375                  (c-&gt;argc == 3) ? &quot;key&quot; : (char*)c-&gt;argv[3]-&gt;ptr, j);
376              key = createStringObject(buf,strlen(buf));
377              if (c-&gt;argc == 5)
378                  if (getLongFromObjectOrReply(c, c-&gt;argv[4], &amp;valsize, NULL) != C_OK)
379                      return;
380              if (lookupKeyWrite(c-&gt;db,key) != NULL) {
381                  decrRefCount(key);
382                  continue;
383              }
384              snprintf(buf,sizeof(buf),&quot;value:%Iu&quot;,j);                            WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
385              if (valsize==0)
386                  val = createStringObject(buf,strlen(buf));
387              else {
388                  int buflen = strlen(buf);
389                  val = createStringObject(NULL,valsize);
390                  memcpy(val-&gt;ptr, buf, valsize&lt;=buflen? valsize: buflen);
391              }
392              dbAdd(c-&gt;db,key,val);
393              signalModifiedKey(c-&gt;db,key);
394              decrRefCount(key);
395          }
396          addReply(c,shared.ok);
397      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;digest&quot;) &amp;&amp; c-&gt;argc == 2) {
398          unsigned char digest[20];
399          sds d = sdsempty();
400          computeDatasetDigest(digest);
401          for (int i = 0; i &lt; 20; i++) d = sdscatprintf(d, &quot;%02x&quot;,digest[i]);
402          addReplyStatus(c,d);
403          sdsfree(d);
404      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;digest-value&quot;) &amp;&amp; c-&gt;argc &gt;= 2) {
405          addReplyMultiBulkLen(c,c-&gt;argc-2);
406          for (int j = 2; j &lt; c-&gt;argc; j++) {
407              unsigned char digest[20];
408              memset(digest,0,20); &amp;bsol;* Start with a clean result */
409              robj *o = lookupKeyReadWithFlags(c-&gt;db,c-&gt;argv[j],LOOKUP_NOTOUCH);
410              if (o) xorObjectDigest(c-&gt;db,c-&gt;argv[j],digest,o);
411              sds d = sdsempty();
412              for (int i = 0; i &lt; 20; i++) d = sdscatprintf(d, &quot;%02x&quot;,digest[i]);
413              addReplyStatus(c,d);
414              sdsfree(d);
415          }
416      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;sleep&quot;) &amp;&amp; c-&gt;argc == 3) {
417          double dtime = strtod(c-&gt;argv[2]-&gt;ptr,NULL);
418          PORT_LONGLONG utime = (PORT_LONGLONG)(dtime*1000000);                   WIN_PORT_FIX &amp;bsol;* cast (PORT_LONGLONG) */
419  #ifdef _WIN32
420          usleep(utime);
421  #else
422          struct timespec tv;
423          tv.tv_sec = utime / 1000000;
424          tv.tv_nsec = (utime % 1000000) * 1000;
425          nanosleep(&amp;tv, NULL);
426  #endif
427          addReply(c,shared.ok);
428      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;set-active-expire&quot;) &amp;&amp;
429                 c-&gt;argc == 3)
430      {
431          server.active_expire_enabled = atoi(c-&gt;argv[2]-&gt;ptr);
432          addReply(c,shared.ok);
433      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;lua-always-replicate-commands&quot;) &amp;&amp;
434                 c-&gt;argc == 3)
435      {
436          server.lua_always_replicate_commands = atoi(c-&gt;argv[2]-&gt;ptr);
437          addReply(c,shared.ok);
438      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;error&quot;) &amp;&amp; c-&gt;argc == 3) {
439          sds errstr = sdsnewlen(&quot;-&quot;,1);
440          errstr = sdscatsds(errstr,c-&gt;argv[2]-&gt;ptr);
441          errstr = sdsmapchars(errstr,&quot;\n\r&quot;,&quot;  &quot;,2); &amp;bsol;* no newlines in errors. */
442          errstr = sdscatlen(errstr,&quot;\r\n&quot;,2);
443          addReplySds(c,errstr);
444      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;structsize&quot;) &amp;&amp; c-&gt;argc == 2) {
445          sds sizes = sdsempty();
446          sizes = sdscatprintf(sizes,&quot;bits:%d &quot;,(sizeof(void*) == 8)?64:32);
447          sizes = sdscatprintf(sizes,&quot;robj:%d &quot;,(int)sizeof(robj));
448          sizes = sdscatprintf(sizes,&quot;dictentry:%d &quot;,(int)sizeof(dictEntry));
449          sizes = sdscatprintf(sizes,&quot;sdshdr5:%d &quot;,(int)sizeof(struct sdshdr5));
450          sizes = sdscatprintf(sizes,&quot;sdshdr8:%d &quot;,(int)sizeof(struct sdshdr8));
451          sizes = sdscatprintf(sizes,&quot;sdshdr16:%d &quot;,(int)sizeof(struct sdshdr16));
452          sizes = sdscatprintf(sizes,&quot;sdshdr32:%d &quot;,(int)sizeof(struct sdshdr32));
453          sizes = sdscatprintf(sizes,&quot;sdshdr64:%d &quot;,(int)sizeof(struct sdshdr64));
454          addReplyBulkSds(c,sizes);
455      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;htstats&quot;) &amp;&amp; c-&gt;argc == 3) {
456          PORT_LONG dbid;
457          sds stats = sdsempty();
458          char buf[4096];
459          if (getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;dbid, NULL) != C_OK)
460              return;
461          if (dbid &lt; 0 || dbid &gt;= server.dbnum) {
462              addReplyError(c,&quot;Out of range database&quot;);
463              return;
464          }
465          stats = sdscatprintf(stats,&quot;[Dictionary HT]\n&quot;);
466          dictGetStats(buf,sizeof(buf),server.db[dbid].dict);
467          stats = sdscat(stats,buf);
468          stats = sdscatprintf(stats,&quot;[Expires HT]\n&quot;);
469          dictGetStats(buf,sizeof(buf),server.db[dbid].expires);
470          stats = sdscat(stats,buf);
471          addReplyBulkSds(c,stats);
472      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;htstats-key&quot;) &amp;&amp; c-&gt;argc == 3) {
473          robj *o;
474          dict *ht = NULL;
475          if ((o = objectCommandLookupOrReply(c,c-&gt;argv[2],shared.nokeyerr))
476                  == NULL) return;
477          switch (o-&gt;encoding) {
478          case OBJ_ENCODING_SKIPLIST:
479              {
480                  zset *zs = o-&gt;ptr;
481                  ht = zs-&gt;dict;
482              }
483              break;
484          case OBJ_ENCODING_HT:
485              ht = o-&gt;ptr;
486              break;
487          }
488          if (ht == NULL) {
489              addReplyError(c,&quot;The value stored at the specified key is not &quot;
490                              &quot;represented using an hash table&quot;);
491          } else {
492              char buf[4096];
493              dictGetStats(buf,sizeof(buf),ht);
494              addReplyBulkCString(c,buf);
495          }
496      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;change-repl-id&quot;) &amp;&amp; c-&gt;argc == 2) {
497          serverLog(LL_WARNING,&quot;Changing replication IDs after receiving DEBUG change-repl-id&quot;);
498          changeReplicationId();
499          clearReplicationId2();
500          addReply(c,shared.ok);
501      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;stringmatch-test&quot;) &amp;&amp; c-&gt;argc == 2)
502      {
503          stringmatchlen_fuzz_test();
504          addReplyStatus(c,&quot;Apparently Redis did not crash: test passed&quot;);
505      } else {
506          addReplySubcommandSyntaxError(c);
507          return;
508      }
509  }
510  void _serverAssert(const char *estr, const char *file, int line) {
511      bugReportStart();
512      serverLog(LL_WARNING,&quot;=== ASSERTION FAILED ===&quot;);
513      serverLog(LL_WARNING,&quot;==&gt; %s:%d &#x27;%s&#x27; is not true&quot;,file,line,estr);
514  #ifdef HAVE_BACKTRACE
515      server.assert_failed = estr;
516      server.assert_file = file;
517      server.assert_line = line;
518      serverLog(LL_WARNING,&quot;(forcing SIGSEGV to print the bug report.)&quot;);
519  #endif
520      *((char*)-1) = &#x27;x&#x27;;
521  }
522  void _serverAssertPrintClientInfo(const client *c) {
523      int j;
524      bugReportStart();
525      serverLog(LL_WARNING,&quot;=== ASSERTION FAILED CLIENT CONTEXT ===&quot;);
526      serverLog(LL_WARNING,&quot;client-&gt;flags = %d&quot;, c-&gt;flags);
527      serverLog(LL_WARNING,&quot;client-&gt;fd = %d&quot;, c-&gt;fd);
528      serverLog(LL_WARNING,&quot;client-&gt;argc = %d&quot;, c-&gt;argc);
529      for (j=0; j &lt; c-&gt;argc; j++) {
530          char buf[128];
531          char *arg;
532          if (c-&gt;argv[j]-&gt;type == OBJ_STRING &amp;&amp; sdsEncodedObject(c-&gt;argv[j])) {
533              arg = (char*) c-&gt;argv[j]-&gt;ptr;
534          } else {
535              snprintf(buf,sizeof(buf),&quot;Object type: %u, encoding: %u&quot;,
536                  c-&gt;argv[j]-&gt;type, c-&gt;argv[j]-&gt;encoding);
537              arg = buf;
538          }
539          serverLog(LL_WARNING,&quot;client-&gt;argv[%d] = \&quot;%s\&quot; (refcount: %d)&quot;,
540              j, arg, c-&gt;argv[j]-&gt;refcount);
541      }
542  }
543  void serverLogObjectDebugInfo(const robj *o) {
544      serverLog(LL_WARNING,&quot;Object type: %d&quot;, o-&gt;type);
545      serverLog(LL_WARNING,&quot;Object encoding: %d&quot;, o-&gt;encoding);
546      serverLog(LL_WARNING,&quot;Object refcount: %d&quot;, o-&gt;refcount);
547      if (o-&gt;type == OBJ_STRING &amp;&amp; sdsEncodedObject(o)) {
548          serverLog(LL_WARNING,&quot;Object raw string len: %Iu&quot;, sdslen(o-&gt;ptr));   WIN_PORT_FIX &amp;bsol;* %zu -&gt; %Iu */
549          if (sdslen(o-&gt;ptr) &lt; 4096) {
550              sds repr = sdscatrepr(sdsempty(),o-&gt;ptr,sdslen(o-&gt;ptr));
551              serverLog(LL_WARNING,&quot;Object raw string content: %s&quot;, repr);
552              sdsfree(repr);
553          }
554      } else if (o-&gt;type == OBJ_LIST) {
555          serverLog(LL_WARNING,&quot;List length: %d&quot;, (int) listTypeLength(o));
556      } else if (o-&gt;type == OBJ_SET) {
557          serverLog(LL_WARNING,&quot;Set size: %d&quot;, (int) setTypeSize(o));
558      } else if (o-&gt;type == OBJ_HASH) {
559          serverLog(LL_WARNING,&quot;Hash size: %d&quot;, (int) hashTypeLength(o));
560      } else if (o-&gt;type == OBJ_ZSET) {
561          serverLog(LL_WARNING,&quot;Sorted set size: %d&quot;, (int) zsetLength(o));
562          if (o-&gt;encoding == OBJ_ENCODING_SKIPLIST)
563              serverLog(LL_WARNING,&quot;Skiplist level: %d&quot;, (int) ((const zset*)o-&gt;ptr)-&gt;zsl-&gt;level);
564      }
565  }
566  void _serverAssertPrintObject(const robj *o) {
567      bugReportStart();
568      serverLog(LL_WARNING,&quot;=== ASSERTION FAILED OBJECT CONTEXT ===&quot;);
569      serverLogObjectDebugInfo(o);
570  }
571  void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {
572      if (c) _serverAssertPrintClientInfo(c);
573      if (o) _serverAssertPrintObject(o);
574      _serverAssert(estr,file,line);
575  }
576  void _serverPanic(const char *file, int line, const char *msg, ...) {
577      va_list ap;
578      va_start(ap,msg);
579      char fmtmsg[256];
580      vsnprintf(fmtmsg,sizeof(fmtmsg),msg,ap);
581      va_end(ap);
582      bugReportStart();
583      serverLog(LL_WARNING,&quot;------------------------------------------------&quot;);
584  #ifdef _WIN32
585      serverLog(LL_WARNING, &quot;Fatal Error: %s #%s:%d&quot;, fmtmsg, file, line);
586  #else
587      serverLog(LL_WARNING,&quot;!!! Software Failure. Press left mouse button to continue&quot;);
588      serverLog(LL_WARNING,&quot;Guru Meditation: %s #%s:%d&quot;,fmtmsg,file,line);
589  #endif
590  #ifdef HAVE_BACKTRACE
591      serverLog(LL_WARNING,&quot;(forcing SIGSEGV in order to print the stack trace)&quot;);
592  #endif
593      serverLog(LL_WARNING,&quot;------------------------------------------------&quot;);
594      *((char*)-1) = &#x27;x&#x27;;
595  }
596  void bugReportStart(void) {
597      if (server.bug_report_start == 0) {
598          serverLogRaw(LL_WARNING|LL_RAW,
599          &quot;\n\n=== REDIS BUG REPORT START: Cut &amp; paste starting from here ===\n&quot;);
600          server.bug_report_start = 1;
601          WIN32_ONLY(serverLog(LL_WARNING|LL_RAW, &quot;Redis version: %s\n&quot;, REDIS_VERSION);)
602      }
603  }
604  #ifdef HAVE_BACKTRACE
605  static void *getMcontextEip(ucontext_t *uc) {
606  #if defined(__APPLE__) &amp;&amp; !defined(MAC_OS_X_VERSION_10_6)
607      #if defined(__x86_64__)
608      return (void*) uc-&gt;uc_mcontext-&gt;__ss.__rip;
609      #elif defined(__i386__)
610      return (void*) uc-&gt;uc_mcontext-&gt;__ss.__eip;
611      #else
612      return (void*) uc-&gt;uc_mcontext-&gt;__ss.__srr0;
613      #endif
614  #elif defined(__APPLE__) &amp;&amp; defined(MAC_OS_X_VERSION_10_6)
615      #if defined(_STRUCT_X86_THREAD_STATE64) &amp;&amp; !defined(__i386__)
616      return (void*) uc-&gt;uc_mcontext-&gt;__ss.__rip;
617      #else
618      return (void*) uc-&gt;uc_mcontext-&gt;__ss.__eip;
619      #endif
620  #elif defined(__linux__)
621      #if defined(__i386__)
622      return (void*) uc-&gt;uc_mcontext.gregs[14]; &amp;bsol;* Linux 32 */
623      #elif defined(__X86_64__) || defined(__x86_64__)
624      return (void*) uc-&gt;uc_mcontext.gregs[16]; &amp;bsol;* Linux 64 */
625      #elif defined(__ia64__) &amp;bsol;* Linux IA64 */
626      return (void*) uc-&gt;uc_mcontext.sc_ip;
627      #elif defined(__arm__) &amp;bsol;* Linux ARM */
628      return (void*) uc-&gt;uc_mcontext.arm_pc;
629      #elif defined(__aarch64__) &amp;bsol;* Linux AArch64 */
630      return (void*) uc-&gt;uc_mcontext.pc;
631      #endif
632  #elif defined(__FreeBSD__)
633      #if defined(__i386__)
634      return (void*) uc-&gt;uc_mcontext.mc_eip;
635      #elif defined(__x86_64__)
636      return (void*) uc-&gt;uc_mcontext.mc_rip;
637      #endif
638  #elif defined(__OpenBSD__)
639      #if defined(__i386__)
640      return (void*) uc-&gt;sc_eip;
641      #elif defined(__x86_64__)
642      return (void*) uc-&gt;sc_rip;
643      #endif
644  #elif defined(__DragonFly__)
645      return (void*) uc-&gt;uc_mcontext.mc_rip;
646  #else
647      return NULL;
648  #endif
649  }
650  void logStackContent(void **sp) {
651      int i;
652      for (i = 15; i &gt;= 0; i--) {
653          PORT_ULONG addr = (PORT_ULONG) sp+i;
654          PORT_ULONG val = (PORT_ULONG) sp[i];
655          if (sizeof(PORT_LONG) == 4)
656              serverLog(LL_WARNING, &quot;(%08lx) -&gt; %08lx&quot;, addr, val);
657          else
658              serverLog(LL_WARNING, &quot;(%016lx) -&gt; %016lx&quot;, addr, val);
659      }
660  }
661  void logRegisters(ucontext_t *uc) {
662      serverLog(LL_WARNING|LL_RAW, &quot;\n------ REGISTERS ------\n&quot;);
663  #if defined(__APPLE__) &amp;&amp; defined(MAC_OS_X_VERSION_10_6)
664      #if defined(_STRUCT_X86_THREAD_STATE64) &amp;&amp; !defined(__i386__)
665      serverLog(LL_WARNING,
666      &quot;\n&quot;
667      &quot;RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n&quot;
668      &quot;RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n&quot;
669      &quot;R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n&quot;
670      &quot;R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n&quot;
671      &quot;RIP:%016lx EFL:%016lx\nCS :%016lx FS:%016lx  GS:%016lx&quot;,
672          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rax,
673          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rbx,
674          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rcx,
675          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rdx,
676          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rdi,
677          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rsi,
678          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rbp,
679          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rsp,
680          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__r8,
681          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__r9,
682          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__r10,
683          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__r11,
684          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__r12,
685          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__r13,
686          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__r14,
687          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__r15,
688          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rip,
689          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__rflags,
690          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__cs,
691          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__fs,
692          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__gs
693      );
694      logStackContent((void**)uc-&gt;uc_mcontext-&gt;__ss.__rsp);
695      #else
696      serverLog(LL_WARNING,
697      &quot;\n&quot;
698      &quot;EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n&quot;
699      &quot;EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n&quot;
700      &quot;SS:%08lx  EFL:%08lx EIP:%08lx CS :%08lx\n&quot;
701      &quot;DS:%08lx  ES:%08lx  FS :%08lx GS :%08lx&quot;,
702          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__eax,
703          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__ebx,
704          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__ecx,
705          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__edx,
706          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__edi,
707          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__esi,
708          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__ebp,
709          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__esp,
710          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__ss,
711          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__eflags,
712          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__eip,
713          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__cs,
714          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__ds,
715          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__es,
716          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__fs,
717          (PORT_ULONG) uc-&gt;uc_mcontext-&gt;__ss.__gs
718      );
719      logStackContent((void**)uc-&gt;uc_mcontext-&gt;__ss.__esp);
720      #endif
721  #elif defined(__linux__)
722      #if defined(__i386__)
723      serverLog(LL_WARNING,
724      &quot;\n&quot;
725      &quot;EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n&quot;
726      &quot;EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n&quot;
727      &quot;SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\n&quot;
728      &quot;DS :%08lx ES :%08lx FS :%08lx GS:%08lx&quot;,
729          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[11],
730          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[8],
731          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[10],
732          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[9],
733          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[4],
734          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[5],
735          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[6],
736          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[7],
737          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[18],
738          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[17],
739          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[14],
740          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[15],
741          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[3],
742          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[2],
743          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[1],
744          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[0]
745      );
746      logStackContent((void**)uc-&gt;uc_mcontext.gregs[7]);
747      #elif defined(__X86_64__) || defined(__x86_64__)
748      serverLog(LL_WARNING,
749      &quot;\n&quot;
750      &quot;RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n&quot;
751      &quot;RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n&quot;
752      &quot;R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n&quot;
753      &quot;R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n&quot;
754      &quot;RIP:%016lx EFL:%016lx\nCSGSFS:%016lx&quot;,
755          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[13],
756          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[11],
757          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[14],
758          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[12],
759          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[8],
760          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[9],
761          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[10],
762          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[15],
763          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[0],
764          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[1],
765          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[2],
766          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[3],
767          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[4],
768          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[5],
769          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[6],
770          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[7],
771          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[16],
772          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[17],
773          (PORT_ULONG) uc-&gt;uc_mcontext.gregs[18]
774      );
775      logStackContent((void**)uc-&gt;uc_mcontext.gregs[15]);
776      #endif
777  #elif defined(__FreeBSD__)
778      #if defined(__x86_64__)
779      serverLog(LL_WARNING,
780      &quot;\n&quot;
781      &quot;RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n&quot;
782      &quot;RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n&quot;
783      &quot;R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n&quot;
784      &quot;R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n&quot;
785      &quot;RIP:%016lx EFL:%016lx\nCSGSFS:%016lx&quot;,
786          (unsigned long) uc-&gt;uc_mcontext.mc_rax,
787          (unsigned long) uc-&gt;uc_mcontext.mc_rbx,
788          (unsigned long) uc-&gt;uc_mcontext.mc_rcx,
789          (unsigned long) uc-&gt;uc_mcontext.mc_rdx,
790          (unsigned long) uc-&gt;uc_mcontext.mc_rdi,
791          (unsigned long) uc-&gt;uc_mcontext.mc_rsi,
792          (unsigned long) uc-&gt;uc_mcontext.mc_rbp,
793          (unsigned long) uc-&gt;uc_mcontext.mc_rsp,
794          (unsigned long) uc-&gt;uc_mcontext.mc_r8,
795          (unsigned long) uc-&gt;uc_mcontext.mc_r9,
796          (unsigned long) uc-&gt;uc_mcontext.mc_r10,
797          (unsigned long) uc-&gt;uc_mcontext.mc_r11,
798          (unsigned long) uc-&gt;uc_mcontext.mc_r12,
799          (unsigned long) uc-&gt;uc_mcontext.mc_r13,
800          (unsigned long) uc-&gt;uc_mcontext.mc_r14,
801          (unsigned long) uc-&gt;uc_mcontext.mc_r15,
802          (unsigned long) uc-&gt;uc_mcontext.mc_rip,
803          (unsigned long) uc-&gt;uc_mcontext.mc_rflags,
804          (unsigned long) uc-&gt;uc_mcontext.mc_cs
805      );
806      logStackContent((void**)uc-&gt;uc_mcontext.mc_rsp);
807      #elif defined(__i386__)
808      serverLog(LL_WARNING,
809      &quot;\n&quot;
810      &quot;EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n&quot;
811      &quot;EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n&quot;
812      &quot;SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\n&quot;
813      &quot;DS :%08lx ES :%08lx FS :%08lx GS:%08lx&quot;,
814          (unsigned long) uc-&gt;uc_mcontext.mc_eax,
815          (unsigned long) uc-&gt;uc_mcontext.mc_ebx,
816          (unsigned long) uc-&gt;uc_mcontext.mc_ebx,
817          (unsigned long) uc-&gt;uc_mcontext.mc_edx,
818          (unsigned long) uc-&gt;uc_mcontext.mc_edi,
819          (unsigned long) uc-&gt;uc_mcontext.mc_esi,
820          (unsigned long) uc-&gt;uc_mcontext.mc_ebp,
821          (unsigned long) uc-&gt;uc_mcontext.mc_esp,
822          (unsigned long) uc-&gt;uc_mcontext.mc_ss,
823          (unsigned long) uc-&gt;uc_mcontext.mc_eflags,
824          (unsigned long) uc-&gt;uc_mcontext.mc_eip,
825          (unsigned long) uc-&gt;uc_mcontext.mc_cs,
826          (unsigned long) uc-&gt;uc_mcontext.mc_es,
827          (unsigned long) uc-&gt;uc_mcontext.mc_fs,
828          (unsigned long) uc-&gt;uc_mcontext.mc_gs
829      );
830      logStackContent((void**)uc-&gt;uc_mcontext.mc_esp);
831      #endif
832  #elif defined(__OpenBSD__)
833      #if defined(__x86_64__)
834      serverLog(LL_WARNING,
835      &quot;\n&quot;
836      &quot;RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n&quot;
837      &quot;RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n&quot;
838      &quot;R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n&quot;
839      &quot;R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n&quot;
840      &quot;RIP:%016lx EFL:%016lx\nCSGSFS:%016lx&quot;,
841          (unsigned long) uc-&gt;sc_rax,
842          (unsigned long) uc-&gt;sc_rbx,
843          (unsigned long) uc-&gt;sc_rcx,
844          (unsigned long) uc-&gt;sc_rdx,
845          (unsigned long) uc-&gt;sc_rdi,
846          (unsigned long) uc-&gt;sc_rsi,
847          (unsigned long) uc-&gt;sc_rbp,
848          (unsigned long) uc-&gt;sc_rsp,
849          (unsigned long) uc-&gt;sc_r8,
850          (unsigned long) uc-&gt;sc_r9,
851          (unsigned long) uc-&gt;sc_r10,
852          (unsigned long) uc-&gt;sc_r11,
853          (unsigned long) uc-&gt;sc_r12,
854          (unsigned long) uc-&gt;sc_r13,
855          (unsigned long) uc-&gt;sc_r14,
856          (unsigned long) uc-&gt;sc_r15,
857          (unsigned long) uc-&gt;sc_rip,
858          (unsigned long) uc-&gt;sc_rflags,
859          (unsigned long) uc-&gt;sc_cs
860      );
861      logStackContent((void**)uc-&gt;sc_rsp);
862      #elif defined(__i386__)
863      serverLog(LL_WARNING,
864      &quot;\n&quot;
865      &quot;EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n&quot;
866      &quot;EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n&quot;
867      &quot;SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\n&quot;
868      &quot;DS :%08lx ES :%08lx FS :%08lx GS:%08lx&quot;,
869          (unsigned long) uc-&gt;sc_eax,
870          (unsigned long) uc-&gt;sc_ebx,
871          (unsigned long) uc-&gt;sc_ebx,
872          (unsigned long) uc-&gt;sc_edx,
873          (unsigned long) uc-&gt;sc_edi,
874          (unsigned long) uc-&gt;sc_esi,
875          (unsigned long) uc-&gt;sc_ebp,
876          (unsigned long) uc-&gt;sc_esp,
877          (unsigned long) uc-&gt;sc_ss,
878          (unsigned long) uc-&gt;sc_eflags,
879          (unsigned long) uc-&gt;sc_eip,
880          (unsigned long) uc-&gt;sc_cs,
881          (unsigned long) uc-&gt;sc_es,
882          (unsigned long) uc-&gt;sc_fs,
883          (unsigned long) uc-&gt;sc_gs
884      );
885      logStackContent((void**)uc-&gt;sc_esp);
886      #endif
887  #elif defined(__DragonFly__)
888      serverLog(LL_WARNING,
889      &quot;\n&quot;
890      &quot;RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n&quot;
891      &quot;RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n&quot;
892      &quot;R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n&quot;
893      &quot;R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n&quot;
894      &quot;RIP:%016lx EFL:%016lx\nCSGSFS:%016lx&quot;,
895          (unsigned long) uc-&gt;uc_mcontext.mc_rax,
896          (unsigned long) uc-&gt;uc_mcontext.mc_rbx,
897          (unsigned long) uc-&gt;uc_mcontext.mc_rcx,
898          (unsigned long) uc-&gt;uc_mcontext.mc_rdx,
899          (unsigned long) uc-&gt;uc_mcontext.mc_rdi,
900          (unsigned long) uc-&gt;uc_mcontext.mc_rsi,
901          (unsigned long) uc-&gt;uc_mcontext.mc_rbp,
902          (unsigned long) uc-&gt;uc_mcontext.mc_rsp,
903          (unsigned long) uc-&gt;uc_mcontext.mc_r8,
904          (unsigned long) uc-&gt;uc_mcontext.mc_r9,
905          (unsigned long) uc-&gt;uc_mcontext.mc_r10,
906          (unsigned long) uc-&gt;uc_mcontext.mc_r11,
907          (unsigned long) uc-&gt;uc_mcontext.mc_r12,
908          (unsigned long) uc-&gt;uc_mcontext.mc_r13,
909          (unsigned long) uc-&gt;uc_mcontext.mc_r14,
910          (unsigned long) uc-&gt;uc_mcontext.mc_r15,
911          (unsigned long) uc-&gt;uc_mcontext.mc_rip,
912          (unsigned long) uc-&gt;uc_mcontext.mc_rflags,
913          (unsigned long) uc-&gt;uc_mcontext.mc_cs
914      );
915      logStackContent((void**)uc-&gt;uc_mcontext.mc_rsp);
916  #else
917      serverLog(LL_WARNING,
918          &quot;  Dumping of registers not supported for this OS/arch&quot;);
919  #endif
920  }
921  int openDirectLogFiledes(void) {
922      int log_to_stdout = server.logfile[0] == &#x27;\0&#x27;;
923      int fd = log_to_stdout ?
924          STDOUT_FILENO :
925          open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
926      return fd;
927  }
928  void closeDirectLogFiledes(int fd) {
929      int log_to_stdout = server.logfile[0] == &#x27;\0&#x27;;
930      if (!log_to_stdout) close(fd);
931  }
932  void logStackTrace(ucontext_t *uc) {
933      void *trace[101];
934      int trace_size = 0, fd = openDirectLogFiledes();
935      if (fd == -1) return; &amp;bsol;* If we can&#x27;t log there is anything to do. */
936      trace_size = backtrace(trace+1, 100);
937      if (getMcontextEip(uc) != NULL) {
938          char *msg1 = &quot;EIP:\n&quot;;
939          char *msg2 = &quot;\nBacktrace:\n&quot;;
940          if (write(fd,msg1,strlen(msg1)) == -1) {&amp;bsol;* Avoid warning. */};
941          trace[0] = getMcontextEip(uc);
942          backtrace_symbols_fd(trace, 1, fd);
943          if (write(fd,msg2,strlen(msg2)) == -1) {&amp;bsol;* Avoid warning. */};
944      }
945      backtrace_symbols_fd(trace+1, trace_size, fd);
946      closeDirectLogFiledes(fd);
947  }
948  void logCurrentClient(void) {
949      if (server.current_client == NULL) return;
950      client *cc = server.current_client;
951      sds client;
952      int j;
953      serverLogRaw(LL_WARNING|LL_RAW, &quot;\n------ CURRENT CLIENT INFO ------\n&quot;);
954      client = catClientInfoString(sdsempty(),cc);
955      serverLog(LL_WARNING|LL_RAW,&quot;%s\n&quot;, client);
956      sdsfree(client);
957      for (j = 0; j &lt; cc-&gt;argc; j++) {
958          robj *decoded;
959          decoded = getDecodedObject(cc-&gt;argv[j]);
960          serverLog(LL_WARNING|LL_RAW,&quot;argv[%d]: &#x27;%s&#x27;\n&quot;, j,
961              (char*)decoded-&gt;ptr);
962          decrRefCount(decoded);
963      }
964      if (cc-&gt;argc &gt;= 1) {
965          robj *val, *key;
966          dictEntry *de;
967          key = getDecodedObject(cc-&gt;argv[1]);
968          de = dictFind(cc-&gt;db-&gt;dict, key-&gt;ptr);
969          if (de) {
970              val = dictGetVal(de);
971              serverLog(LL_WARNING,&quot;key &#x27;%s&#x27; found in DB containing the following object:&quot;, (char*)key-&gt;ptr);
972              serverLogObjectDebugInfo(val);
973          }
974          decrRefCount(key);
975      }
976  }
977  #if defined(HAVE_PROC_MAPS)
978  #define MEMTEST_MAX_REGIONS 128
979  int memtest_test_linux_anonymous_maps(void) {
980      FILE *fp;
981      char line[1024];
982      char logbuf[1024];
983      size_t start_addr, end_addr, size;
984      size_t start_vect[MEMTEST_MAX_REGIONS];
985      size_t size_vect[MEMTEST_MAX_REGIONS];
986      int regions = 0, j;
987      int fd = openDirectLogFiledes();
988      if (!fd) return 0;
989      fp = fopen(&quot;/proc/self/maps&quot;,&quot;r&quot;);
990      if (!fp) return 0;
991      while(fgets(line,sizeof(line),fp) != NULL) {
992          char *start, *end, *p = line;
993          start = p;
994          p = strchr(p,&#x27;-&#x27;);
995          if (!p) continue;
996          *p++ = &#x27;\0&#x27;;
997          end = p;
998          p = strchr(p,&#x27; &#x27;);
999          if (!p) continue;
1000          *p++ = &#x27;\0&#x27;;
1001          if (strstr(p,&quot;stack&quot;) ||
1002              strstr(p,&quot;vdso&quot;) ||
1003              strstr(p,&quot;vsyscall&quot;)) continue;
1004          if (!strstr(p,&quot;00:00&quot;)) continue;
1005          if (!strstr(p,&quot;rw&quot;)) continue;
1006          start_addr = strtoul(start,NULL,16);
1007          end_addr = strtoul(end,NULL,16);
1008          size = end_addr-start_addr;
1009          start_vect[regions] = start_addr;
1010          size_vect[regions] = size;
1011          snprintf(logbuf,sizeof(logbuf),
1012              &quot;*** Preparing to test memory region %lx (%lu bytes)\n&quot;,
1013                  (PORT_ULONG) start_vect[regions],
1014                  (PORT_ULONG) size_vect[regions]);
1015          if (write(fd,logbuf,strlen(logbuf)) == -1) { &amp;bsol;* Nothing to do. */ }
1016          regions++;
1017      }
1018      int errors = 0;
1019      for (j = 0; j &lt; regions; j++) {
1020          if (write(fd,&quot;.&quot;,1) == -1) { &amp;bsol;* Nothing to do. */ }
1021          errors += memtest_preserving_test((void*)start_vect[j],size_vect[j],1);
1022          if (write(fd, errors ? &quot;E&quot; : &quot;O&quot;,1) == -1) { &amp;bsol;* Nothing to do. */ }
1023      }
1024      if (write(fd,&quot;\n&quot;,1) == -1) { &amp;bsol;* Nothing to do. */ }
1025      fclose(fp);
1026      closeDirectLogFiledes(fd);
1027      return errors;
1028  }
1029  #endif
1030  void dumpX86Calls(void *addr, size_t len) {
1031      size_t j;
1032      unsigned char *p = addr;
1033      Dl_info info;
1034      PORT_ULONG ht[256] = {0};
1035      if (len &lt; 5) return;
1036      for (j = 0; j &lt; len-4; j++) {
1037          if (p[j] != 0xE8) continue; &amp;bsol;* Not an E8 CALL opcode. */
1038          PORT_ULONG target = (PORT_ULONG)addr+j+5;
1039          target += *((int32_t*)(p+j+1));
1040          if (dladdr((void*)target, &amp;info) != 0 &amp;&amp; info.dli_sname != NULL) {
1041              if (ht[target&amp;0xff] != target) {
1042                  printf(&quot;Function at 0x%lx is %s\n&quot;,target,info.dli_sname);
1043                  ht[target&amp;0xff] = target;
1044              }
1045              j += 4; &amp;bsol;* Skip the 32 bit immediate. */
1046          }
1047      }
1048  }
1049  void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
1050      ucontext_t *uc = (ucontext_t*) secret;
1051      void *eip = getMcontextEip(uc);
1052      sds infostring, clients;
1053      struct sigaction act;
1054      UNUSED(info);
1055      bugReportStart();
1056      serverLog(LL_WARNING,
1057          &quot;Redis %s crashed by signal: %d&quot;, REDIS_VERSION, sig);
1058      if (eip != NULL) {
1059          serverLog(LL_WARNING,
1060          &quot;Crashed running the instruction at: %p&quot;, eip);
1061      }
1062      if (sig == SIGSEGV || sig == SIGBUS) {
1063          serverLog(LL_WARNING,
1064          &quot;Accessing address: %p&quot;, (void*)info-&gt;si_addr);
1065      }
1066      serverLog(LL_WARNING,
1067          &quot;Failed assertion: %s (%s:%d)&quot;, server.assert_failed,
1068                          server.assert_file, server.assert_line);
1069      serverLogRaw(LL_WARNING|LL_RAW, &quot;\n------ STACK TRACE ------\n&quot;);
1070      logStackTrace(uc);
1071      serverLogRaw(LL_WARNING|LL_RAW, &quot;\n------ INFO OUTPUT ------\n&quot;);
1072      infostring = genRedisInfoString(&quot;all&quot;);
1073      serverLogRaw(LL_WARNING|LL_RAW, infostring);
1074      serverLogRaw(LL_WARNING|LL_RAW, &quot;\n------ CLIENT LIST OUTPUT ------\n&quot;);
1075      clients = getAllClientsInfoString(-1);
1076      serverLogRaw(LL_WARNING|LL_RAW, clients);
1077      sdsfree(infostring);
1078      sdsfree(clients);
1079      logCurrentClient();
1080      logRegisters(uc);
1081  #if defined(HAVE_PROC_MAPS)
1082      serverLogRaw(LL_WARNING|LL_RAW, &quot;\n------ FAST MEMORY TEST ------\n&quot;);
1083      bioKillThreads();
1084      if (memtest_test_linux_anonymous_maps()) {
1085          serverLogRaw(LL_WARNING|LL_RAW,
1086              &quot;!!! MEMORY ERROR DETECTED! Check your memory ASAP !!!\n&quot;);
1087      } else {
1088          serverLogRaw(LL_WARNING|LL_RAW,
1089              &quot;Fast memory test PASSED, however your memory can still be broken. Please run a memory test for several hours if possible.\n&quot;);
1090      }
1091  #endif
1092      if (eip != NULL) {
1093          Dl_info info;
1094          if (dladdr(eip, &amp;info) != 0) {
1095              serverLog(LL_WARNING|LL_RAW,
1096                  &quot;\n------ DUMPING CODE AROUND EIP ------\n&quot;
1097                  &quot;Symbol: %s (base: %p)\n&quot;
1098                  &quot;Module: %s (base %p)\n&quot;
1099                  &quot;$ xxd -r -p /tmp/dump.hex /tmp/dump.bin\n&quot;
1100                  &quot;$ objdump --adjust-vma=%p -D -b binary -m i386:x86-64 /tmp/dump.bin\n&quot;
1101                  &quot;------\n&quot;,
1102                  info.dli_sname, info.dli_saddr, info.dli_fname, info.dli_fbase,
1103                  info.dli_saddr);
1104              size_t len = (PORT_LONG)eip - (PORT_LONG)info.dli_saddr;
1105              PORT_ULONG sz = sysconf(_SC_PAGESIZE);
1106              if (len &lt; 1&lt;&lt;13) { &amp;bsol;* we don&#x27;t have functions over 8k (verified) */
1107                  PORT_ULONG next = ((PORT_ULONG)eip + sz) &amp; ~(sz-1);
1108                  PORT_ULONG end = (PORT_ULONG)eip + 128;
1109                  if (end &gt; next) end = next;
1110                  len = end - (PORT_ULONG)info.dli_saddr;
1111                  serverLogHexDump(LL_WARNING, &quot;dump of function&quot;,
1112                      info.dli_saddr ,len);
1113                  dumpX86Calls(info.dli_saddr,len);
1114              }
1115          }
1116      }
1117      serverLogRaw(LL_WARNING|LL_RAW,
1118  &quot;\n=== REDIS BUG REPORT END. Make sure to include from START to END. ===\n\n&quot;
1119  &quot;       Please report the crash by opening an issue on github:\n\n&quot;
1120  &quot;           https:&amp;bsol;&amp;bsol;github.com/tporadowski/redis/issues\n\n&quot;
1121  &quot;  Suspect RAM error? Use redis-server --test-memory to verify it.\n\n&quot;
1122  );
1123      if (server.daemonize &amp;&amp; server.supervised == 0) unlink(server.pidfile);
1124      sigemptyset (&amp;act.sa_mask);
1125      act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
1126      act.sa_handler = SIG_DFL;
1127      sigaction (sig, &amp;act, NULL);
1128      kill(getpid(),sig);
1129  }
1130  #endif &amp;bsol;* HAVE_BACKTRACE */
1131  void serverLogHexDump(int level, char *descr, void *value, size_t len) {
1132      char buf[65], *b;
1133      unsigned char *v = value;
1134      char charset[] = &quot;0123456789abcdef&quot;;
1135      serverLog(level,&quot;%s (hexdump of %Iu bytes):&quot;, descr, len);         WIN_PORT_FIX &amp;bsol;* %zu -&gt; %Iu */
1136      b = buf;
1137      while(len) {
1138          b[0] = charset[(*v)&gt;&gt;4];
1139          b[1] = charset[(*v)&amp;0xf];
1140          b[2] = &#x27;\0&#x27;;
1141          b += 2;
1142          len--;
1143          v++;
1144          if (b-buf == 64 || len == 0) {
1145              serverLogRaw(level|LL_RAW,buf);
1146              b = buf;
1147          }
1148      }
1149      serverLogRaw(level|LL_RAW,&quot;\n&quot;);
1150  }
1151  #ifdef _WIN32
1152  void watchdogScheduleSignal(int period) {
1153      UNUSED(period);
1154  }
1155  void enableWatchdog(int period) {
1156      UNUSED(period);
1157  }
1158  void disableWatchdog(void) {
1159  }
1160  #else
1161  #include &lt;sys/time.h&gt;
1162  void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {
1163  #ifdef HAVE_BACKTRACE
1164      ucontext_t *uc = (ucontext_t*) secret;
1165  #else
1166      (void)secret;
1167  #endif
1168      UNUSED(info);
1169      UNUSED(sig);
1170      serverLogFromHandler(LL_WARNING,&quot;\n--- WATCHDOG TIMER EXPIRED ---&quot;);
1171  #ifdef HAVE_BACKTRACE
1172      logStackTrace(uc);
1173  #else
1174      serverLogFromHandler(LL_WARNING,&quot;Sorry: no support for backtrace().&quot;);
1175  #endif
1176      serverLogFromHandler(LL_WARNING,&quot;--------\n&quot;);
1177  }
1178  void watchdogScheduleSignal(int period) {
1179      struct itimerval it;
1180      it.it_value.tv_sec = period/1000;
1181      it.it_value.tv_usec = (period%1000)*1000;
1182      it.it_interval.tv_sec = 0;
1183      it.it_interval.tv_usec = 0;
1184      setitimer(ITIMER_REAL, &amp;it, NULL);
1185  }
1186  void enableWatchdog(int period) {
1187      int min_period;
1188      if (server.watchdog_period == 0) {
1189          struct sigaction act;
1190          sigemptyset(&amp;act.sa_mask);
1191          act.sa_flags = SA_ONSTACK | SA_SIGINFO;
1192          act.sa_sigaction = watchdogSignalHandler;
1193          sigaction(SIGALRM, &amp;act, NULL);
1194      }
1195      min_period = (1000/server.hz)*2;
1196      if (period &lt; min_period) period = min_period;
1197      watchdogScheduleSignal(period); &amp;bsol;* Adjust the current timer. */
1198      server.watchdog_period = period;
1199  }
1200  void disableWatchdog(void) {
1201      struct sigaction act;
1202      if (server.watchdog_period == 0) return; &amp;bsol;* Already disabled. */
1203      watchdogScheduleSignal(0); &amp;bsol;* Stop the current timer. */
1204      sigemptyset(&amp;act.sa_mask);
1205      act.sa_flags = 0;
1206      act.sa_handler = SIG_IGN;
1207      sigaction(SIGALRM, &amp;act, NULL);
1208      server.watchdog_period = 0;
1209  }
1210  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-aof.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-debug.c</div>
                </div>
                <div class="column column_space"><pre><code>711          eptr = ziplistIndex(zl,0);
712          serverAssert(eptr != NULL);
713          sptr = ziplistNext(zl,eptr);
714          serverAssert(sptr != NULL);
715          while (eptr != NULL) {
716              serverAssert(ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vll));
717              score = zzlGetScore(sptr);
718              if (count == 0) {
</pre></code></div>
                <div class="column column_space"><pre><code>89              eptr = ziplistIndex(zl,0);
90              serverAssert(eptr != NULL);
91              sptr = ziplistNext(zl,eptr);
92              serverAssert(sptr != NULL);
93              while (eptr != NULL) {
94                  serverAssert(ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vll));
95                  score = zzlGetScore(sptr);
96                  memset(eledigest,0,20);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    