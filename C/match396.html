<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omfile-hardened.c &amp; imfile.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omfile-hardened.c &amp; imfile.c
      </h3>
<h1 align="center">
        14.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omfile-hardened.c (21.816639%)<th>imfile.c (10.558751%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(243-284)<td><a href="#" name="0">(305-346)</a><td align="center"><font color="#ff0000">79</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1335-1346)<td><a href="#" name="1">(1989-2002)</a><td align="center"><font color="#600000">30</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1304-1332)<td><a href="#" name="2">(1913-1939)</a><td align="center"><font color="#430000">21</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(953-960)<td><a href="#" name="3">(2109-2117)</a><td align="center"><font color="#430000">21</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1159-1176)<td><a href="#" name="4">(1724-1741)</a><td align="center"><font color="#400000">20</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1381-1387)<td><a href="#" name="5">(1943-1949)</a><td align="center"><font color="#3a0000">18</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(1544-1558)<td><a href="#" name="6">(2043-2064)</a><td align="center"><font color="#300000">15</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(915-929)<td><a href="#" name="7">(2071-2088)</a><td align="center"><font color="#2d0000">14</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1610-1633)<td><a href="#" name="8">(2932-2960)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(929-942)<td><a href="#" name="9">(2094-2107)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(220-237)<td><a href="#" name="10">(246-268)</a><td align="center"><font color="#290000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omfile-hardened.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include "glbl.h"
4 #include &lt;stdio.h&gt;
5 #include &lt;stdarg.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;time.h&gt;
9 #include &lt;assert.h&gt;
10 #include &lt;errno.h&gt;
11 #include &lt;ctype.h&gt;
12 #include &lt;libgen.h&gt;
13 #include &lt;unistd.h&gt;
14 #include &lt;sys/file.h&gt;
15 #include &lt;fcntl.h&gt;
16 #include &lt;sys/statvfs.h&gt;
17 #ifdef HAVE_ATOMIC_BUILTINS
18 #	include &lt;pthread.h&gt;
19 #endif
20 #include "conf.h"
21 #include "syslogd-types.h"
22 #include "srUtils.h"
23 #include "template.h"
24 #include "outchannel.h"
25 #include "omfile.h"
26 #include "cfsysline.h"
27 #include "module-template.h"
28 #include "errmsg.h"
29 #include "stream.h"
30 #include "unicode-helper.h"
31 #include "atomic.h"
32 #include "statsobj.h"
33 #include "sigprov.h"
34 #include "cryprov.h"
35 #include "parserif.h"
36 #include "janitor.h"
37 #include "rsconf.h"
38 MODULE_TYPE_OUTPUT
39 MODULE_TYPE_NOKEEP
40 MODULE_CNFNAME("omfile")
41 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
42 DEF_OMOD_STATIC_DATA
43 DEFobjCurrIf(glbl)
44 DEFobjCurrIf(strm)
45 DEFobjCurrIf(statsobj)
46 #if HAVE_ATOMIC_BUILTINS64
47 static uint64 clockFileAccess = 0;
48 #else
49 static unsigned clockFileAccess = 0;
50 #endif
51 #ifndef HAVE_ATOMIC_BUILTINS
52 static pthread_mutex_t mutClock;
53 #endif
54 static uint64
55 getClockFileAccess(void)
56 {
57 #if HAVE_ATOMIC_BUILTINS64
58 	return ATOMIC_INC_AND_FETCH_uint64(&amp;clockFileAccess, &amp;mutClock);
59 #else
60 	return ATOMIC_INC_AND_FETCH_unsigned(&amp;clockFileAccess, &amp;mutClock);
61 #endif
62 }
63 struct s_dynaFileCacheEntry {
64 	uchar *pName;			strm_t	*pStrm;			void	*sigprovFileData;		uint64	clkTickAccessed;	short nInactive;	};
65 typedef struct s_dynaFileCacheEntry dynaFileCacheEntry;
66 #define IOBUF_DFLT_SIZE 4096	#define FLUSH_INTRVL_DFLT 1 	#define USE_ASYNCWRITER_DFLT 0 	#define FLUSHONTX_DFLT 1 	
67 typedef struct _instanceData {
68 	pthread_mutex_t mutWrite; 	uchar	*fname;		uchar 	*tplName;		strm_t	*pStrm;			short nInactive;		char	bDynamicName;		int	fCreateMode;		int	fDirCreateMode;		int	bCreateDirs;		int	bSyncFile;		uint8_t iNumTpls;		uid_t	fileUID;		uid_t	dirUID;
69 	gid_t	fileGID;
70 	gid_t	dirGID;
71 	dynaFileCacheEntry **dynCache;
72 	off_t	iSizeLimit;			uchar	*pszSizeLimitCmd;		int 	iZipLevel;			uint	iIOBufSize;			int	iFlushInterval;			short	iCloseTimeout;			sbool	bFlushOnTXEnd;			sbool	bUseAsyncWriter;		sbool	bVeryRobustZip;
73 	statsobj_t *stats;			STATSCOUNTER_DEF(ctrRequests, mutCtrRequests);
74 	STATSCOUNTER_DEF(ctrLevel0, mutCtrLevel0);
75 	STATSCOUNTER_DEF(ctrEvict, mutCtrEvict);
76 	STATSCOUNTER_DEF(ctrMiss, mutCtrMiss);
77 	STATSCOUNTER_DEF(ctrMax, mutCtrMax);
78 	STATSCOUNTER_DEF(ctrCloseTimeouts, mutCtrCloseTimeouts);
79 	char janitorID[128];		} instanceData;
80 typedef struct wrkrInstanceData {
81 	instanceData *pData;
82 } wrkrInstanceData_t;
83 typedef struct configSettings_s {
84 	uint iDynaFileCacheSize; 	int fCreateMode; 	int fDirCreateMode; 	int	bFailOnChown;		uid_t	fileUID;		uid_t	fileGID;		uid_t	dirUID;			uid_t	dirGID;			int	bCreateDirs;	int	bEnableSync;	int	iZipLevel;		sbool	bFlushOnTXEnd;	int64	iIOBufSize;		int	iFlushInterval; 		int	bUseAsyncWriter;		EMPTY_STRUCT
85 } configSettings_t;
86 <a name="10"></a>static configSettings_t cs;
87 uchar	*pszFileDfltTplName; 
88 <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>struct modConfData_s {
89 	rsconf_t *pConf;		uchar 	*tplName;		int fCreateMode; 	int fDirCreateMode; 	uid_t fileUID;		uid_t dirUID;
90 	gid_t fileGID;
91 	gid_t dirGID;
92 	int bDynafileDoNotSuspend;
93 };
94 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
95 static struct cnfparamdescr modpdescr[] = {</b></font>
96 	{ "template", eCmdHdlrGetWord, 0 },
97 	{ "dircreatemode", eCmdHdlrFileCreateMode, 0 },
98 <a name="0"></a>	{ "filecreatemode", eCmdHdlrFileCreateMode, 0 },
99 	{ "dirowner", eCmdHdlrUID, 0 },
100 	{ "dirownernum", eCmdHdlrInt, 0 },
101 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "dirgroup", eCmdHdlrGID, 0 },
102 	{ "dirgroupnum", eCmdHdlrInt, 0 },
103 	{ "fileowner", eCmdHdlrUID, 0 },
104 	{ "fileownernum", eCmdHdlrInt, 0 },
105 	{ "filegroup", eCmdHdlrGID, 0 },
106 	{ "dynafile.donotsuspend", eCmdHdlrBinary, 0 },
107 	{ "filegroupnum", eCmdHdlrInt, 0 },
108 };
109 static struct cnfparamblk modpblk =
110 	{ CNFPARAMBLK_VERSION,
111 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
112 	  modpdescr
113 	};
114 static struct cnfparamdescr actpdescr[] = {
115 	{ "dynafilecachesize", eCmdHdlrInt, 0 }, 	{ "ziplevel", eCmdHdlrInt, 0 }, 	{ "flushinterval", eCmdHdlrInt, 0 }, 	{ "asyncwriting", eCmdHdlrBinary, 0 }, 	{ "veryrobustzip", eCmdHdlrBinary, 0 },
116 	{ "flushontxend", eCmdHdlrBinary, 0 }, 	{ "iobuffersize", eCmdHdlrSize, 0 }, 	{ "dirowner", eCmdHdlrUID, 0 }, 	{ "dirownernum", eCmdHdlrInt, 0 }, 	{ "dirgroup", eCmdHdlrGID, 0 }, 	{ "dirgroupnum", eCmdHdlrInt, 0 }, 	{ "fileowner", eCmdHdlrUID, 0 }, 	{ "fileownernum", eCmdHdlrInt, 0 }, 	{ "filegroup", eCmdHdlrGID, 0 }, 	{ "filegroupnum", eCmdHdlrInt, 0 }, 	{ "dircreatemode", eCmdHdlrFileCreateMode, 0 }, 	{ "filecreatemode", eCmdHdlrFileCreateMode, 0 }, 	{ "failonchownfailure", eCmdHdlrBinary, 0 }, 	{ "createdirs", eCmdHdlrBinary, 0 }, 	{ "sync", eCmdHdlrBinary, 0 }, 	{ "file", eCmdHdlrString, 0 },     	{ "dynafile", eCmdHdlrString, 0 }, 	{ "sig.provider", eCmdHdlrGetWord, 0 },
117 	{ "cry.provider", eCmdHdlrGetWord, 0 },
118 	{ "closetimeout", eCmdHdlrPositiveInt, 0 },
119 	{ "template", eCmdHdlrGetWord, 0 }</b></font>
120 };
121 static struct cnfparamblk actpblk =
122 	{ CNFPARAMBLK_VERSION,
123 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
124 	  actpdescr
125 	};
126 static uchar*
127 getDfltTpl(void)
128 {
129 	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
130 		return loadModConf-&gt;tplName;
131 	else if(pszFileDfltTplName == NULL)
132 		return (uchar*)"RSYSLOG_FileFormat";
133 	else
134 		return pszFileDfltTplName;
135 }
136 BEGINinitConfVars		CODESTARTinitConfVars
137 	pszFileDfltTplName = NULL; 	iRet = resetConfigVariables(NULL, NULL); ENDinitConfVars
138 BEGINisCompatibleWithFeature
139 CODESTARTisCompatibleWithFeature
140 	if(eFeat == sFEATURERepeatedMsgReduction)
141 		iRet = RS_RET_OK;
142 ENDisCompatibleWithFeature
143 BEGINdbgPrintInstInfo
144 CODESTARTdbgPrintInstInfo
145 	if(pData-&gt;bDynamicName) {
146 		dbgprintf("[dynamic]\n");
147 	} else { 		dbgprintf("%s%s\n", pData-&gt;fname,
148 			  (pData-&gt;pStrm == NULL) ? " (closed)" : "");
149 	}
150 	dbgprintf("\ttemplate='%s'\n", pData-&gt;fname);
151 	dbgprintf("\tuse async writer=%d\n", pData-&gt;bUseAsyncWriter);
152 	dbgprintf("\tflush on TX end=%d\n", pData-&gt;bFlushOnTXEnd);
153 	dbgprintf("\tflush interval=%d\n", pData-&gt;iFlushInterval);
154 	dbgprintf("\tfile cache size=%d\n", pData-&gt;iDynaFileCacheSize);
155 	dbgprintf("\tcreate directories: %s\n", pData-&gt;bCreateDirs ? "on" : "off");
156 	dbgprintf("\tvery robust zip: %s\n", pData-&gt;bCreateDirs ? "on" : "off");
157 	dbgprintf("\tfile owner %d, group %d\n", (int) pData-&gt;fileUID, (int) pData-&gt;fileGID);
158 	dbgprintf("\tdirectory owner %d, group %d\n", (int) pData-&gt;dirUID, (int) pData-&gt;dirGID);
159 	dbgprintf("\tdir create mode 0%3.3o, file create mode 0%3.3o\n",
160 		  pData-&gt;fDirCreateMode, pData-&gt;fCreateMode);
161 	dbgprintf("\tfail if owner/group can not be set: %s\n", pData-&gt;bFailOnChown ? "yes" : "no");
162 ENDdbgPrintInstInfo
163 static rsRetVal
164 setLegacyDfltTpl(void __attribute__((unused)) *pVal, uchar* newVal)
165 {
166 	DEFiRet;
167 	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL) {
168 		free(newVal);
169 		parser_errmsg("omfile: default template already set via module "
170 			"global parameter - can no longer be changed");
171 		ABORT_FINALIZE(RS_RET_ERR);
172 	}
173 	free(pszFileDfltTplName);
174 	pszFileDfltTplName = newVal;
175 finalize_it:
176 	RETiRet;
177 }
178 static rsRetVal setDynaFileCacheSize(void __attribute__((unused)) *pVal, int iNewVal)
179 {
180 	DEFiRet;
181 	if(iNewVal &lt; 1) {
182 		errno = 0;
183 		parser_errmsg(
184 		         "DynaFileCacheSize must be greater 0 (%d given), changed to 1.", iNewVal);
185 		iRet = RS_RET_VAL_OUT_OF_RANGE;
186 		iNewVal = 1;
187 	} else if(iNewVal &gt; 1000) {
188 		errno = 0;
189 		parser_errmsg(
190 		         "DynaFileCacheSize maximum is 1,000 (%d given), changed to 1,000.", iNewVal);
191 		iRet = RS_RET_VAL_OUT_OF_RANGE;
192 		iNewVal = 1000;
193 	}
194 	cs.iDynaFileCacheSize = iNewVal;
195 	DBGPRINTF("DynaFileCacheSize changed to %d.\n", iNewVal);
196 	RETiRet;
197 }
198 static rsRetVal cflineParseOutchannel(instanceData *pData, uchar* p, omodStringRequest_t *pOMSR,
199 	int iEntry, int iTplOpts)
200 {
201 	DEFiRet;
202 	size_t i;
203 	struct outchannel *pOch;
204 	char szBuf[128];	
205 	++p; 	i = 0;
206 	while(*p &amp;&amp; *p != ';' &amp;&amp; *p != ' ' &amp;&amp;
207 	      i &lt; (sizeof(szBuf) - 1) ) {
208 	      szBuf[i++] = *p++;
209 	}
210 	szBuf[i] = '\0';
211 	pOch = ochFind(szBuf, i);
212 	if(pOch == NULL) {
213 		parser_errmsg(
214 			 "outchannel '%s' not found - ignoring action line",
215 			 szBuf);
216 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
217 	}
218 	if(pOch-&gt;pszFileTemplate == NULL) {
219 		parser_errmsg(
220 			 "outchannel '%s' has no file name template - ignoring action line",
221 			 szBuf);
222 		ABORT_FINALIZE(RS_RET_ERR);
223 	}
224 	pData-&gt;fname = ustrdup(pOch-&gt;pszFileTemplate);
225 	pData-&gt;iSizeLimit = pOch-&gt;uSizeLimit;
226 	pData-&gt;pszSizeLimitCmd = pOch-&gt;cmdOnSizeLimit;
227 	iRet = cflineParseTemplateName(&amp;p, pOMSR, iEntry, iTplOpts, getDfltTpl());
228 finalize_it:
229 	RETiRet;
230 }
231 static rsRetVal
232 dynaFileDelCacheEntry(instanceData *__restrict__ const pData, const int iEntry, const int bFreeEntry)
233 {
234 	dynaFileCacheEntry **pCache = pData-&gt;dynCache;
235 	DEFiRet;
236 	assert(pCache != NULL);
237 	if(pCache[iEntry] == NULL)
238 		FINALIZE;
239 	DBGPRINTF("Removing entry %d for file '%s' from dynaCache.\n", iEntry,
240 		pCache[iEntry]-&gt;pName == NULL ? UCHAR_CONSTANT("[OPEN FAILED]") : pCache[iEntry]-&gt;pName);
241 	if(pCache[iEntry]-&gt;pName != NULL) {
242 		free(pCache[iEntry]-&gt;pName);
243 		pCache[iEntry]-&gt;pName = NULL;
244 	}
245 	if(pCache[iEntry]-&gt;pStrm != NULL) {
246 		strm.Destruct(&amp;pCache[iEntry]-&gt;pStrm);
247 		if(pData-&gt;useSigprov) {
248 			pData-&gt;sigprov.OnFileClose(pCache[iEntry]-&gt;sigprovFileData);
249 			pCache[iEntry]-&gt;sigprovFileData = NULL;
250 		}
251 	}
252 	if(bFreeEntry) {
253 		free(pCache[iEntry]);
254 		pCache[iEntry] = NULL;
255 	}
256 finalize_it:
257 	RETiRet;
258 }
259 static void
260 dynaFileFreeCacheEntries(instanceData *__restrict__ const pData)
261 {
262 	register uint i;
263 	assert(pData != NULL);
264 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
265 		dynaFileDelCacheEntry(pData, i, 1);
266 	}
267 	pData-&gt;iCurrElt = -1; }
268 static void dynaFileFreeCache(instanceData *__restrict__ const pData)
269 {
270 	assert(pData != NULL);
271 	dynaFileFreeCacheEntries(pData);
272 	if(pData-&gt;dynCache != NULL)
273 		free(pData-&gt;dynCache);
274 }
275 static rsRetVal
276 closeFile(instanceData *__restrict__ const pData)
277 {
278 	DEFiRet;
279 	if(pData-&gt;useSigprov) {
280 		pData-&gt;sigprov.OnFileClose(pData-&gt;sigprovFileData);
281 		pData-&gt;sigprovFileData = NULL;
282 	}
283 	strm.Destruct(&amp;pData-&gt;pStrm);
284 	RETiRet;
285 }
286 static rsRetVal
287 sigprovPrepare(instanceData *__restrict__ const pData, uchar *__restrict__ const fn)
288 {
289 	DEFiRet;
290 	pData-&gt;sigprov.OnFileOpen(pData-&gt;sigprovData, fn, &amp;pData-&gt;sigprovFileData);
291 	RETiRet;
292 }
293 static rsRetVal
294 prepareFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
295 {
296 	int fd;
297 	char errStr[1024]; 	DEFiRet;
298 	pData-&gt;pStrm = NULL;
299 	if(access((char*)newFileName, F_OK) != 0) {
300 		if(pData-&gt;bCreateDirs) {
301 			if(makeFileParentDirs(newFileName, ustrlen(newFileName),
302 			     pData-&gt;fDirCreateMode, pData-&gt;dirUID,
303 			     pData-&gt;dirGID, pData-&gt;bFailOnChown) != 0) {
304 				rs_strerror_r(errno, errStr, sizeof(errStr));
305 				parser_errmsg( "omfile: creating parent "
306 					"directories for file  '%s' failed: %s",
307 					newFileName, errStr);
308 			     	ABORT_FINALIZE(RS_RET_ERR); 			}
309 		}
310 		fd = open((char*) newFileName, O_WRONLY|O_APPEND|O_CREAT|O_NOCTTY|O_CLOEXEC,
311 				pData-&gt;fCreateMode);
312 		if(fd != -1) {
313 			if(pData-&gt;fileUID != (uid_t)-1 || pData-&gt;fileGID != (gid_t) -1) {
314 				if(fchown(fd, pData-&gt;fileUID, pData-&gt;fileGID) != 0) {
315 					rs_strerror_r(errno, errStr, sizeof(errStr));
316 					parser_errmsg(
317 						"omfile: chown for file '%s' failed: %s",
318 						newFileName, errStr);
319 					if(pData-&gt;bFailOnChown) {
320 						close(fd);
321 						ABORT_FINALIZE(RS_RET_ERR); 					}
322 				}
323 			}
324 			close(fd); 		}
325 		else {
326 			ABORT_FINALIZE(RS_RET_ERR);
327 		}
328 	}
329 	uchar szNameBuf[MAXFNAME+1];
330 	uchar szDirName[MAXFNAME+1];
331 	uchar szBaseName[MAXFNAME+1];
332 	ustrncpy(szNameBuf, newFileName, MAXFNAME);
333 	szNameBuf[MAXFNAME] = '\0';
334 	ustrncpy(szDirName, (uchar*)dirname((char*)szNameBuf), MAXFNAME);
335 	szDirName[MAXFNAME] = '\0';
336 	ustrncpy(szNameBuf, newFileName, MAXFNAME);
337 	szNameBuf[MAXFNAME] = '\0';
338 	ustrncpy(szBaseName, (uchar*)basename((char*)szNameBuf), MAXFNAME);
339 	szBaseName[MAXFNAME] = '\0';
340 	CHKiRet(strm.Construct(&amp;pData-&gt;pStrm));
341 	CHKiRet(strm.SetFName(pData-&gt;pStrm, szBaseName, ustrlen(szBaseName)));
342 	CHKiRet(strm.SetDir(pData-&gt;pStrm, szDirName, ustrlen(szDirName)));
343 	CHKiRet(strm.SetiZipLevel(pData-&gt;pStrm, pData-&gt;iZipLevel));
344 	CHKiRet(strm.SetbVeryReliableZip(pData-&gt;pStrm, pData-&gt;bVeryRobustZip));
345 	CHKiRet(strm.SetsIOBufSize(pData-&gt;pStrm, (size_t) pData-&gt;iIOBufSize));
346 	CHKiRet(strm.SettOperationsMode(pData-&gt;pStrm, STREAMMODE_WRITE_APPEND));
347 	CHKiRet(strm.SettOpenMode(pData-&gt;pStrm, cs.fCreateMode));
348 	CHKiRet(strm.SetbSync(pData-&gt;pStrm, pData-&gt;bSyncFile));
349 	CHKiRet(strm.SetsType(pData-&gt;pStrm, STREAMTYPE_FILE_SINGLE));
350 	CHKiRet(strm.SetiSizeLimit(pData-&gt;pStrm, pData-&gt;iSizeLimit));
351 	if(pData-&gt;useCryprov) {
352 		CHKiRet(strm.Setcryprov(pData-&gt;pStrm, &amp;pData-&gt;cryprov));
353 		CHKiRet(strm.SetcryprovData(pData-&gt;pStrm, pData-&gt;cryprovData));
354 	}
355 	if(pData-&gt;bUseAsyncWriter)
356 		CHKiRet(strm.SetiFlushInterval(pData-&gt;pStrm, pData-&gt;iFlushInterval));
357 	if(pData-&gt;pszSizeLimitCmd != NULL)
358 		CHKiRet(strm.SetpszSizeLimitCmd(pData-&gt;pStrm, ustrdup(pData-&gt;pszSizeLimitCmd)));
359 	CHKiRet(strm.ConstructFinalize(pData-&gt;pStrm));
360 	if(pData-&gt;useSigprov)
361 		sigprovPrepare(pData, szNameBuf);
362 finalize_it:
363 	if(iRet != RS_RET_OK) {
364 		if(pData-&gt;pStrm != NULL) {
365 			closeFile(pData);
366 		}
367 	}
368 	RETiRet;
369 }
370 static rsRetVal
371 fsCheck(instanceData *__restrict__ const pData, const uchar *__restrict__ const fileName)
372 {
373 	DEFiRet;
374 	struct statvfs stat;
375 	char *pathcopy;
376 	const char *path;
377 	pathcopy = strdup((char*)fileName);
378 	path = dirname(pathcopy);
379 	if (statvfs(path, &amp;stat) != 0) {
380 		iRet = RS_RET_FILE_NO_STAT;
381 		LogError(0, iRet, "could not stat %s", path);
382 		FINALIZE;
383 	}
384 	if (stat.f_bsize * stat.f_bavail &lt;
385 		pData-&gt;iIOBufSize * pData-&gt;iDynaFileCacheSize + (uint)(glbl.GetMaxLine(runModConf-&gt;pConf)))
386 		{
387 			iRet = RS_RET_FS_ERR;
388 			LogError(0, iRet, "too few available blocks in %s", path);
389 			FINALIZE;
390 		}
391 	if (stat.f_favail &lt; 2 &amp;&amp; stat.f_files &gt; 0)
392 		{
393 			iRet = RS_RET_FS_ERR;
394 			LogError(0, iRet, "too few available inodes in %s", path);
395 			FINALIZE;
396 		}
397 	if (stat.f_flag == ST_RDONLY)
398 		{
399 			iRet = RS_RET_FS_ERR;
400 			LogError(0, iRet, "file-system is read-only in %s", path);
401 			FINALIZE;
402 		}
403 	iRet = RS_RET_OK;
404 finalize_it:
405 	if (pathcopy != NULL)
406 		free(pathcopy);
407 	RETiRet;
408 }
409 static rsRetVal
410 prepareDynFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
411 {
412 	uint64 ctOldest; 	int iOldest;
413 	uint i;
414 	int iFirstFree;
415 	rsRetVal localRet;
416 	dynaFileCacheEntry **pCache;
417 	DEFiRet;
418 	assert(pData != NULL);
419 	assert(newFileName != NULL);
420 	pCache = pData-&gt;dynCache;
421 	if(   (pData-&gt;iCurrElt != -1)
422 	   &amp;&amp; !ustrcmp(newFileName, pCache[pData-&gt;iCurrElt]-&gt;pName)) {
423 		CHKiRet(fsCheck(pData, newFileName));
424 		pCache[pData-&gt;iCurrElt]-&gt;clkTickAccessed = getClockFileAccess();
425 		STATSCOUNTER_INC(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
426 		FINALIZE;
427 	}
428 	pData-&gt;iCurrElt = -1;		iFirstFree = -1; 	iOldest = 0; 	ctOldest = getClockFileAccess(); 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
429 		if(pCache[i] == NULL || pCache[i]-&gt;pName == NULL) {
430 			if(iFirstFree == -1)
431 				iFirstFree = i;
432 		} else { 			if(!ustrcmp(newFileName, pCache[i]-&gt;pName)) {
433 				CHKiRet(fsCheck(pData, newFileName));
434 				pData-&gt;pStrm = pCache[i]-&gt;pStrm;
435 				if(pData-&gt;useSigprov)
436 					pData-&gt;sigprovFileData = pCache[i]-&gt;sigprovFileData;
437 				pData-&gt;iCurrElt = i;
438 				pCache[i]-&gt;clkTickAccessed = getClockFileAccess(); 				FINALIZE;
439 			}
440 			if(pCache[i]-&gt;clkTickAccessed &lt; ctOldest) {
441 				ctOldest = pCache[i]-&gt;clkTickAccessed;
442 				iOldest = i;
443 				}
444 		}
445 	}
446 	STATSCOUNTER_INC(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);
447 	pData-&gt;pStrm = NULL, pData-&gt;sigprovFileData = NULL;
448 	if(iFirstFree == -1 &amp;&amp; (pData-&gt;iCurrCacheSize &lt; pData-&gt;iDynaFileCacheSize)) {
449 		iFirstFree = pData-&gt;iCurrCacheSize++;
450 		STATSCOUNTER_SETMAX_NOMUT(pData-&gt;ctrMax, (unsigned) pData-&gt;iCurrCacheSize);
451 	}
452 	if(iFirstFree == -1) {
453 		dynaFileDelCacheEntry(pData, iOldest, 0);
454 		STATSCOUNTER_INC(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
455 		iFirstFree = iOldest; 	} else {
456 		CHKmalloc(pCache[iFirstFree] = (dynaFileCacheEntry*) calloc(1, sizeof(dynaFileCacheEntry)));
457 	}
458 	localRet = prepareFile(pData, newFileName); 
459 	if(localRet != RS_RET_OK) {
460 		parser_errmsg("Could not open dynamic file '%s' [state %d]", newFileName, localRet);
461 		ABORT_FINALIZE(localRet);
462 	}
463 	localRet = fsCheck(pData, newFileName);
464 	if(localRet != RS_RET_OK) {
465 		parser_errmsg("Invalid file-system condition for dynamic file '%s' [state %d]", newFileName, localRet);
466 		ABORT_FINALIZE(localRet);
467 	}
468 	if((pCache[iFirstFree]-&gt;pName = ustrdup(newFileName)) == NULL) {
469 		closeFile(pData); 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
470 	}
471 	pCache[iFirstFree]-&gt;pStrm = pData-&gt;pStrm;
472 	if(pData-&gt;useSigprov)
473 		pCache[iFirstFree]-&gt;sigprovFileData = pData-&gt;sigprovFileData;
474 	pCache[iFirstFree]-&gt;clkTickAccessed = getClockFileAccess();
475 	pData-&gt;iCurrElt = iFirstFree;
476 	DBGPRINTF("Added new entry %d for file cache, file '%s'.\n", iFirstFree, newFileName);
477 finalize_it:
478 	if(iRet == RS_RET_OK)
479 		pCache[pData-&gt;iCurrElt]-&gt;nInactive = 0;
480 	RETiRet;
481 }
482 static  rsRetVal
483 doWrite(instanceData *__restrict__ const pData, uchar *__restrict__ const pszBuf, const int lenBuf)
484 {
485 	DEFiRet;
486 	assert(pData != NULL);
487 	assert(pszBuf != NULL);
488 	DBGPRINTF("omfile: write to stream, pData-&gt;pStrm %p, lenBuf %d, strt data %.128s\n",
489 		  pData-&gt;pStrm, lenBuf, pszBuf);
490 	if(pData-&gt;pStrm != NULL){
491 		CHKiRet(strm.Write(pData-&gt;pStrm, pszBuf, lenBuf));
492 		if(pData-&gt;useSigprov) {
493 			CHKiRet(pData-&gt;sigprov.OnRecordWrite(pData-&gt;sigprovFileData, pszBuf, lenBuf));
494 		}
495 	}
496 finalize_it:
497 	RETiRet;
498 }
499 static rsRetVal
500 writeFile(instanceData *__restrict__ const pData,
501 	  const actWrkrIParams_t *__restrict__ const pParam,
502 	  const int iMsg)
503 {
504 	DEFiRet;
505 	STATSCOUNTER_INC(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
506 	if(pData-&gt;bDynamicName) {
507 		DBGPRINTF("omfile: file to log to: %s\n",
508 			  actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param);
509 		CHKiRet(prepareDynFile(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param));
510 	} else { 		if(pData-&gt;pStrm == NULL) {
511 			CHKiRet(prepareFile(pData, pData-&gt;fname));
512 			if(pData-&gt;pStrm == NULL) {
513 				parser_errmsg(
514 					"Could not open output file '%s'", pData-&gt;fname);
515 			}
516 			CHKiRet(fsCheck(pData, pData-&gt;fname));
517 		}
518 		pData-&gt;nInactive = 0;
519 	}
520 	iRet = doWrite(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).param,
521 		actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).lenStr);
522 finalize_it:
523 	RETiRet;
524 }
525 BEGINbeginCnfLoad
526 <a name="7"></a>CODESTARTbeginCnfLoad
527 	loadModConf = pModConf;
528 	pModConf-&gt;pConf = pConf;
529 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pModConf-&gt;tplName = NULL;
530 	pModConf-&gt;fCreateMode = 0644;
531 	pModConf-&gt;fDirCreateMode = 0700;
532 	pModConf-&gt;fileUID = -1;
533 	pModConf-&gt;dirUID = -1;
534 	pModConf-&gt;fileGID = -1;
535 	pModConf-&gt;dirGID = -1;
536 	pModConf-&gt;bDynafileDoNotSuspend = 1;
537 ENDbeginCnfLoad
538 BEGINsetModCnf
539 <a name="9"></a>	struct cnfparamvals *pvals = NULL;
540 	int i;
541 CODESTARTsetModCnf
542 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);</b></font><font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>
543 	if(pvals == NULL) {
544 		parser_errmsg("error processing module "
545 				"config parameters [module(...)]");
546 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
547 	}
548 	if(Debug) {
549 		dbgprintf("module (global) param blk for omfile:\n");
550 		cnfparamsPrint(&amp;modpblk, pvals);
551 	}
552 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
553 		if(!pvals[i].bUsed) {</b></font>
554 			continue;
555 		}
556 		if(!strcmp(modpblk.descr[i].name, "template")) {
557 			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
558 			if(pszFileDfltTplName != NULL) {
559 				parser_errmsg("omfile: warning: default template was already "
560 <a name="3"></a>					"set via legacy directive - may lead to inconsistent "
561 					"results.");
562 			}
563 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(modpblk.descr[i].name, "dircreatemode")) {
564 			loadModConf-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
565 		} else if(!strcmp(modpblk.descr[i].name, "filecreatemode")) {
566 			loadModConf-&gt;fCreateMode = (int) pvals[i].val.d.n;
567 		} else if(!strcmp(modpblk.descr[i].name, "dirowner")) {
568 			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;
569 		} else if(!strcmp(modpblk.descr[i].name, "dirownernum")) {
570 			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;</b></font>
571 		} else if(!strcmp(modpblk.descr[i].name, "dirgroup")) {
572 			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
573 		} else if(!strcmp(modpblk.descr[i].name, "dirgroupnum")) {
574 			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
575 		} else if(!strcmp(modpblk.descr[i].name, "fileowner")) {
576 			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
577 		} else if(!strcmp(modpblk.descr[i].name, "fileownernum")) {
578 			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
579 		} else if(!strcmp(modpblk.descr[i].name, "filegroup")) {
580 			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
581 		} else if(!strcmp(modpblk.descr[i].name, "filegroupnum")) {
582 			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
583 		} else if(!strcmp(modpblk.descr[i].name, "dynafile.donotsuspend")) {
584 			loadModConf-&gt;bDynafileDoNotSuspend = (int) pvals[i].val.d.n;
585 		} else {
586 			dbgprintf("omfile: program error, non-handled "
587 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
588 		}
589 	}
590 finalize_it:
591 	if(pvals != NULL)
592 		cnfparamvalsDestruct(pvals, &amp;modpblk);
593 ENDsetModCnf
594 static void
595 janitorChkDynaFiles(instanceData *__restrict__ const pData)
596 {
597 	uint i;
598 	dynaFileCacheEntry **pCache = pData-&gt;dynCache;
599 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
600 		if(pCache[i] == NULL)
601 			continue;
602 		DBGPRINTF("omfile janitor: checking dynafile %d:%s, inactive since %d\n", i,
603 			pCache[i]-&gt;pName == NULL ? UCHAR_CONSTANT("[OPEN FAILED]") : pCache[i]-&gt;pName,
604 			(int) pCache[i]-&gt;nInactive);
605 		if(pCache[i]-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
606 			STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
607 			dynaFileDelCacheEntry(pData, i, 1);
608 			if(pData-&gt;iCurrElt &gt;= 0) {
609 				if((uint)(pData-&gt;iCurrElt) == i)
610 				pData-&gt;iCurrElt = -1; 			}
611 		} else {
612 			pCache[i]-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
613 		}
614 	}
615 }
616 static void
617 janitorCB(void *pUsr)
618 {
619 	instanceData *__restrict__ const pData = (instanceData *) pUsr;
620 	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
621 	if(pData-&gt;bDynamicName) {
622 		janitorChkDynaFiles(pData);
623 	} else {
624 		if(pData-&gt;pStrm != NULL) {
625 			DBGPRINTF("omfile janitor: checking file %s, inactive since %d\n",
626 				pData-&gt;fname, pData-&gt;nInactive);
627 			if(pData-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
628 				STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
629 				closeFile(pData);
630 			} else {
631 				pData-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
632 			}
633 		}
634 	}
635 	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
636 }
637 BEGINendCnfLoad
638 CODESTARTendCnfLoad
639 	loadModConf = NULL; 	free(pszFileDfltTplName);
640 	pszFileDfltTplName = NULL;
641 ENDendCnfLoad
642 BEGINcheckCnf
643 CODESTARTcheckCnf
644 ENDcheckCnf
645 BEGINactivateCnf
646 CODESTARTactivateCnf
647 	runModConf = pModConf;
648 ENDactivateCnf
649 BEGINfreeCnf
650 CODESTARTfreeCnf
651 	free(pModConf-&gt;tplName);
652 ENDfreeCnf
653 BEGINcreateInstance
654 CODESTARTcreateInstance
655 	pData-&gt;pStrm = NULL;
656 	pthread_mutex_init(&amp;pData-&gt;mutWrite, NULL);
657 ENDcreateInstance
658 BEGINcreateWrkrInstance
659 CODESTARTcreateWrkrInstance
660 ENDcreateWrkrInstance
661 BEGINfreeInstance
662 CODESTARTfreeInstance
663 	free(pData-&gt;tplName);
664 	free(pData-&gt;fname);
665 	if(pData-&gt;iCloseTimeout &gt; 0)
666 		janitorDelEtry(pData-&gt;janitorID);
667 	if(pData-&gt;bDynamicName) {
668 		dynaFileFreeCache(pData);
669 	} else if(pData-&gt;pStrm != NULL)
670 		closeFile(pData);
671 	if(pData-&gt;stats != NULL)
672 		statsobj.Destruct(&amp;(pData-&gt;stats));
673 	if(pData-&gt;useSigprov) {
674 		pData-&gt;sigprov.Destruct(&amp;pData-&gt;sigprovData);
675 		obj.ReleaseObj(__FILE__, pData-&gt;sigprovNameFull+2, pData-&gt;sigprovNameFull,
676 			       (void*) &amp;pData-&gt;sigprov);
677 		free(pData-&gt;sigprovName);
678 		free(pData-&gt;sigprovNameFull);
679 	}
680 	if(pData-&gt;useCryprov) {
681 		pData-&gt;cryprov.Destruct(&amp;pData-&gt;cryprovData);
682 		obj.ReleaseObj(__FILE__, pData-&gt;cryprovNameFull+2, pData-&gt;cryprovNameFull,
683 			       (void*) &amp;pData-&gt;cryprov);
684 		free(pData-&gt;cryprovName);
685 		free(pData-&gt;cryprovNameFull);
686 	}
687 	pthread_mutex_destroy(&amp;pData-&gt;mutWrite);
688 ENDfreeInstance
689 BEGINfreeWrkrInstance
690 CODESTARTfreeWrkrInstance
691 ENDfreeWrkrInstance
692 BEGINtryResume
693 CODESTARTtryResume
694 ENDtryResume
695 BEGINbeginTransaction
696 CODESTARTbeginTransaction
697 ENDbeginTransaction
698 BEGINcommitTransaction
699 	instanceData *__restrict__ const pData = pWrkrData-&gt;pData;
700 	unsigned i;
701 CODESTARTcommitTransaction
702 	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
703 	for(i = 0 ; i &lt; nParams ; ++i) {
704 		CHKiRet(writeFile(pData, pParams, i));
705 	}
706 	if(pData-&gt;bFlushOnTXEnd &amp;&amp; pData-&gt;pStrm != NULL) {
707 		CHKiRet(strm.Flush(pData-&gt;pStrm));
708 	}
709 finalize_it:
710 	if (iRet != RS_RET_OK) {
711 		if (runModConf-&gt;bDynafileDoNotSuspend == 0 || !(pData-&gt;bDynamicName)) {
712 			LogError(0, iRet, "suspending action");
713 			iRet = RS_RET_SUSPENDED;
714 		}
715 		else {
716 			LogError(0, iRet, "discarding message");
717 		}
718 	}
719 	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
720 ENDcommitTransaction
721 static void
722 setInstParamDefaults(instanceData *__restrict__ const pData)
723 {
724 	pData-&gt;fname = NULL;
725 	pData-&gt;tplName = NULL;
726 <a name="4"></a>	pData-&gt;fileUID = loadModConf-&gt;fileUID;
727 	pData-&gt;fileGID = loadModConf-&gt;fileGID;
728 	pData-&gt;dirUID = loadModConf-&gt;dirUID;
729 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pData-&gt;dirGID = loadModConf-&gt;dirGID;
730 	pData-&gt;bFailOnChown = 1;
731 	pData-&gt;iDynaFileCacheSize = 10;
732 	pData-&gt;fCreateMode = loadModConf-&gt;fCreateMode;
733 	pData-&gt;fDirCreateMode = loadModConf-&gt;fDirCreateMode;
734 	pData-&gt;bCreateDirs = 1;
735 	pData-&gt;bSyncFile = 0;
736 	pData-&gt;iZipLevel = 0;
737 	pData-&gt;bVeryRobustZip = 0;
738 	pData-&gt;bFlushOnTXEnd = FLUSHONTX_DFLT;
739 	pData-&gt;iIOBufSize = IOBUF_DFLT_SIZE;
740 	pData-&gt;iFlushInterval = FLUSH_INTRVL_DFLT;
741 	pData-&gt;bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
742 	pData-&gt;sigprovName = NULL;
743 	pData-&gt;cryprovName = NULL;
744 	pData-&gt;useSigprov = 0;
745 	pData-&gt;useCryprov = 0;
746 	pData-&gt;iCloseTimeout = -1;</b></font>
747 }
748 static rsRetVal
749 setupInstStatsCtrs(instanceData *__restrict__ const pData)
750 {
751 	uchar ctrName[512];
752 	DEFiRet;
753 	if(!pData-&gt;bDynamicName) {
754 		FINALIZE;
755 	}
756 	snprintf((char*)ctrName, sizeof(ctrName), "dynafile cache %s", pData-&gt;fname);
757 	ctrName[sizeof(ctrName)-1] = '\0'; 	CHKiRet(statsobj.Construct(&amp;(pData-&gt;stats)));
758 	CHKiRet(statsobj.SetName(pData-&gt;stats, ctrName));
759 	CHKiRet(statsobj.SetOrigin(pData-&gt;stats, (uchar*)"omfile"));
760 	STATSCOUNTER_INIT(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
761 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("requests"),
762 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrRequests)));
763 	STATSCOUNTER_INIT(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
764 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("level0"),
765 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrLevel0)));
766 	STATSCOUNTER_INIT(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);
767 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("missed"),
768 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMiss)));
769 	STATSCOUNTER_INIT(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
770 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("evicted"),
771 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrEvict)));
772 	STATSCOUNTER_INIT(pData-&gt;ctrMax, pData-&gt;mutCtrMax);
773 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("maxused"),
774 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMax)));
775 	STATSCOUNTER_INIT(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
776 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("closetimeouts"),
777 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrCloseTimeouts)));
778 	CHKiRet(statsobj.ConstructFinalize(pData-&gt;stats));
779 finalize_it:
780 	RETiRet;
781 }
782 static void
783 initSigprov(instanceData *__restrict__ const pData, struct nvlst *lst)
784 {
785 	uchar szDrvrName[1024];
786 	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), "lmsig_%s", pData-&gt;sigprovName)
787 		== sizeof(szDrvrName)) {
788 		parser_errmsg("omfile: signature provider "
789 				"name is too long: '%s' - signatures disabled",
790 				pData-&gt;sigprovName);
791 		goto done;
792 	}
793 	pData-&gt;sigprovNameFull = ustrdup(szDrvrName);
794 	pData-&gt;sigprov.ifVersion = sigprovCURR_IF_VERSION;
795 	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;sigprov)
796 		!= RS_RET_OK) {
797 		parser_errmsg("omfile: could not load "
798 				"signature provider '%s' - signatures disabled",
799 				szDrvrName);
800 		goto done;
801 	}
802 	if(pData-&gt;sigprov.Construct(&amp;pData-&gt;sigprovData) != RS_RET_OK) {
803 		parser_errmsg("omfile: error constructing "
804 				"signature provider %s dataset - signatures disabled",
805 				szDrvrName);
806 		goto done;
807 	}
808 	pData-&gt;sigprov.SetCnfParam(pData-&gt;sigprovData, lst);
809 	dbgprintf("loaded signature provider %s, data instance at %p\n",
810 		  szDrvrName, pData-&gt;sigprovData);
811 	pData-&gt;useSigprov = 1;
812 done:	return;
813 }
814 static rsRetVal
815 initCryprov(instanceData *__restrict__ const pData, struct nvlst *lst)
816 {
817 	uchar szDrvrName[1024];
818 	DEFiRet;
819 	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), "lmcry_%s", pData-&gt;cryprovName)
820 		== sizeof(szDrvrName)) {
821 		parser_errmsg("omfile: crypto provider "
822 				"name is too long: '%s' - encryption disabled",
823 				pData-&gt;cryprovName);
824 		ABORT_FINALIZE(RS_RET_ERR);
825 	}
826 	pData-&gt;cryprovNameFull = ustrdup(szDrvrName);
827 	pData-&gt;cryprov.ifVersion = cryprovCURR_IF_VERSION;
828 	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;cryprov)
829 		!= RS_RET_OK) {
830 		parser_errmsg("omfile: could not load "
831 				"crypto provider '%s' - encryption disabled",
832 				szDrvrName);
833 		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
834 	}
835 	if(pData-&gt;cryprov.Construct(&amp;pData-&gt;cryprovData) != RS_RET_OK) {
836 		parser_errmsg("omfile: error constructing "
837 				"crypto provider %s dataset - encryption disabled",
838 				szDrvrName);
839 		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
840 	}
841 	CHKiRet(pData-&gt;cryprov.SetCnfParam(pData-&gt;cryprovData, lst, CRYPROV_PARAMTYPE_REGULAR));
842 	dbgprintf("loaded crypto provider %s, data instance at %p\n",
843 		  szDrvrName, pData-&gt;cryprovData);
844 <a name="2"></a>	pData-&gt;useCryprov = 1;
845 finalize_it:
846 	RETiRet;
847 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
848 BEGINnewActInst
849 	struct cnfparamvals *pvals;
850 	uchar *tplToUse;
851 	int i;
852 CODESTARTnewActInst
853 	DBGPRINTF("newActInst (omfile)\n");
854 	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
855 	if(pvals == NULL) {
856 		parser_errmsg("omfile: either the \"file\" or "
857 				"\"dynafile\" parameter must be given");
858 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
859 	}
860 	if(Debug) {
861 		dbgprintf("action param blk in omfile:\n");
862 		cnfparamsPrint(&amp;actpblk, pvals);
863 	}
864 	CHKiRet(createInstance(&amp;pData));
865 	setInstParamDefaults(pData);
866 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
867 		if(!pvals[i].bUsed)
868 			continue;
869 		if(!strcmp(actpblk.descr[i].name, "dynafilecachesize")) {
870 <a name="1"></a>			pData-&gt;iDynaFileCacheSize = (uint) pvals[i].val.d.n;</b></font>
871 		} else if(!strcmp(actpblk.descr[i].name, "ziplevel")) {
872 			pData-&gt;iZipLevel = (int) pvals[i].val.d.n;
873 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "flushinterval")) {
874 			pData-&gt;iFlushInterval = pvals[i].val.d.n;
875 		} else if(!strcmp(actpblk.descr[i].name, "veryrobustzip")) {
876 			pData-&gt;bVeryRobustZip = pvals[i].val.d.n;
877 		} else if(!strcmp(actpblk.descr[i].name, "asyncwriting")) {
878 			pData-&gt;bUseAsyncWriter = pvals[i].val.d.n;
879 		} else if(!strcmp(actpblk.descr[i].name, "flushontxend")) {
880 			pData-&gt;bFlushOnTXEnd = pvals[i].val.d.n;
881 		} else if(!strcmp(actpblk.descr[i].name, "iobuffersize")) {
882 			pData-&gt;iIOBufSize = (uint) pvals[i].val.d.n;
883 		} else if(!strcmp(actpblk.descr[i].name, "dirowner")) {
884 			pData-&gt;dirUID = (int) pvals[i].val.d.n;</b></font>
885 		} else if(!strcmp(actpblk.descr[i].name, "dirownernum")) {
886 			pData-&gt;dirUID = (int) pvals[i].val.d.n;
887 		} else if(!strcmp(actpblk.descr[i].name, "dirgroup")) {
888 			pData-&gt;dirGID = (int) pvals[i].val.d.n;
889 		} else if(!strcmp(actpblk.descr[i].name, "dirgroupnum")) {
890 			pData-&gt;dirGID = (int) pvals[i].val.d.n;
891 		} else if(!strcmp(actpblk.descr[i].name, "fileowner")) {
892 			pData-&gt;fileUID = (int) pvals[i].val.d.n;
893 		} else if(!strcmp(actpblk.descr[i].name, "fileownernum")) {
894 			pData-&gt;fileUID = (int) pvals[i].val.d.n;
895 		} else if(!strcmp(actpblk.descr[i].name, "filegroup")) {
896 			pData-&gt;fileGID = (int) pvals[i].val.d.n;
897 		} else if(!strcmp(actpblk.descr[i].name, "filegroupnum")) {
898 			pData-&gt;fileGID = (int) pvals[i].val.d.n;
899 		} else if(!strcmp(actpblk.descr[i].name, "dircreatemode")) {
900 			pData-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
901 		} else if(!strcmp(actpblk.descr[i].name, "filecreatemode")) {
902 			pData-&gt;fCreateMode = (int) pvals[i].val.d.n;
903 		} else if(!strcmp(actpblk.descr[i].name, "failonchownfailure")) {
904 			pData-&gt;bFailOnChown = (int) pvals[i].val.d.n;
905 		} else if(!strcmp(actpblk.descr[i].name, "sync")) {
906 			pData-&gt;bSyncFile = (int) pvals[i].val.d.n;
907 		} else if(!strcmp(actpblk.descr[i].name, "createdirs")) {
908 			pData-&gt;bCreateDirs = (int) pvals[i].val.d.n;
909 		} else if(!strcmp(actpblk.descr[i].name, "file")) {
910 			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
911 			CODE_STD_STRING_REQUESTnewActInst(1)
912 			pData-&gt;bDynamicName = 0;
913 		} else if(!strcmp(actpblk.descr[i].name, "dynafile")) {
914 			if(pData-&gt;fname != NULL) {
915 				parser_errmsg("omfile: both \"file\" and \"dynafile\" set, will use dynafile");
916 <a name="5"></a>			}
917 			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
918 			CODE_STD_STRING_REQUESTnewActInst(2)
919 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			pData-&gt;bDynamicName = 1;
920 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
921 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
922 		} else if(!strcmp(actpblk.descr[i].name, "sig.provider")) {
923 			pData-&gt;sigprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
924 		} else if(!strcmp(actpblk.descr[i].name, "cry.provider")) {
925 			pData-&gt;cryprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
926 		} else if(!strcmp(actpblk.descr[i].name, "closetimeout")) {
927 			pData-&gt;iCloseTimeout = (int) pvals[i].val.d.n;
928 		} else {
929 			dbgprintf("omfile: program error, non-handled "
930 			  "param '%s'\n", actpblk.descr[i].name);
931 		}
932 	}
933 	if(pData-&gt;fname == NULL) {
934 		parser_errmsg("omfile: either the \"file\" or "
935 				"\"dynafile\" parameter must be given");
936 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
937 	}
938 	if(pData-&gt;sigprovName != NULL) {
939 		initSigprov(pData, lst);
940 	}
941 	if(pData-&gt;cryprovName != NULL) {
942 		CHKiRet(initCryprov(pData, lst));
943 	}
944 	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? getDfltTpl() : pData-&gt;tplName);
945 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
946 	pData-&gt;iNumTpls = 1;
947 	if(pData-&gt;bDynamicName) {
948 		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
949 		pData-&gt;iNumTpls = 2;
950 		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
951 				calloc(pData-&gt;iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
952 		pData-&gt;iCurrElt = -1;		  	}
953 	setupInstStatsCtrs(pData);
954 	if(pData-&gt;iCloseTimeout == -1) { 		pData-&gt;iCloseTimeout = (pData-&gt;bDynamicName) ? 10 : 0;
955 	}
956 	snprintf(pData-&gt;janitorID, sizeof(pData-&gt;janitorID), "omfile:%sfile:%s:%p",
957 		(pData-&gt;bDynamicName) ? "dyna" : "", pData-&gt;fname, pData);
958 	pData-&gt;janitorID[sizeof(pData-&gt;janitorID)-1] = '\0'; 
959 	if(pData-&gt;iCloseTimeout &gt; 0)
960 		janitorAddEtry(janitorCB, pData-&gt;janitorID, pData);
961 CODE_STD_FINALIZERnewActInst
962 	cnfparamvalsDestruct(pvals, &amp;actpblk);
963 ENDnewActInst
964 BEGINparseSelectorAct
965 	uchar fname[MAXFNAME];
966 CODESTARTparseSelectorAct
967 	if(!strncmp((char*) p, ":omfile:", sizeof(":omfile:") - 1)) {
968 		p += sizeof(":omfile:") - 1;
969 	}
970 	if(!(*p == '$' || *p == '?' || *p == '/' || *p == '.' || *p == '-'))
971 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
972 	CHKiRet(createInstance(&amp;pData));
973 	if(*p == '-') {
974 		pData-&gt;bSyncFile = 0;
975 		p++;
976 	} else {
977 		pData-&gt;bSyncFile = cs.bEnableSync;
978 	}
979 	pData-&gt;iSizeLimit = 0; 
980 	switch(*p) {
981 	case '$':
982 		CODE_STD_STRING_REQUESTparseSelectorAct(1)
983 		pData-&gt;iNumTpls = 1;
984 		CHKiRet(cflineParseOutchannel(pData, p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS));
985 		pData-&gt;bDynamicName = 0;
986 		break;
987 		CODE_STD_STRING_REQUESTparseSelectorAct(2)
988 		pData-&gt;iNumTpls = 2;
989 		++p; 		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
990 		pData-&gt;fname = ustrdup(fname);
991 		pData-&gt;bDynamicName = 1;
992 		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
993 		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
994 				calloc(cs.iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
995 		break;
996 	case '/':
997 	case '.':
998 		CODE_STD_STRING_REQUESTparseSelectorAct(1)
999 		pData-&gt;iNumTpls = 1;
1000 		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
1001 		pData-&gt;fname = ustrdup(fname);
1002 		pData-&gt;bDynamicName = 0;
1003 		break;
1004 	default:
1005 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
1006 	}
1007 	pData-&gt;iDynaFileCacheSize = cs.iDynaFileCacheSize;
1008 	pData-&gt;fCreateMode = cs.fCreateMode;
1009 	pData-&gt;fDirCreateMode = cs.fDirCreateMode;
1010 	pData-&gt;bCreateDirs = cs.bCreateDirs;
1011 	pData-&gt;bFailOnChown = cs.bFailOnChown;
1012 	pData-&gt;fileUID = cs.fileUID;
1013 	pData-&gt;fileGID = cs.fileGID;
1014 	pData-&gt;dirUID = cs.dirUID;
1015 	pData-&gt;dirGID = cs.dirGID;
1016 	pData-&gt;iZipLevel = cs.iZipLevel;
1017 	pData-&gt;bFlushOnTXEnd = cs.bFlushOnTXEnd;
1018 	pData-&gt;iIOBufSize = (uint) cs.iIOBufSize;
1019 	pData-&gt;iFlushInterval = cs.iFlushInterval;
1020 	pData-&gt;bUseAsyncWriter = cs.bUseAsyncWriter;
1021 	pData-&gt;bVeryRobustZip = 0;		pData-&gt;iCloseTimeout = 0;		setupInstStatsCtrs(pData);
1022 CODE_STD_FINALIZERparseSelectorAct
1023 ENDparseSelectorAct
1024 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
1025 <a name="6"></a>{
1026 	cs.fileUID = -1;
1027 	cs.fileGID = -1;
1028 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	cs.dirUID = -1;
1029 	cs.dirGID = -1;
1030 	cs.bFailOnChown = 1;
1031 	cs.iDynaFileCacheSize = 10;
1032 	cs.fCreateMode = 0644;
1033 	cs.fDirCreateMode = 0700;
1034 	cs.bCreateDirs = 1;
1035 	cs.bEnableSync = 0;
1036 	cs.iZipLevel = 0;
1037 	cs.bFlushOnTXEnd = FLUSHONTX_DFLT;
1038 	cs.iIOBufSize = IOBUF_DFLT_SIZE;
1039 	cs.iFlushInterval = FLUSH_INTRVL_DFLT;
1040 	cs.bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
1041 	free(pszFileDfltTplName);
1042 	pszFileDfltTplName = NULL;</b></font>
1043 	return RS_RET_OK;
1044 }
1045 BEGINdoHUP
1046 CODESTARTdoHUP
1047 	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
1048 	if(pData-&gt;bDynamicName) {
1049 		dynaFileFreeCacheEntries(pData);
1050 	} else {
1051 		if(pData-&gt;pStrm != NULL) {
1052 			closeFile(pData);
1053 		}
1054 	}
1055 	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
1056 ENDdoHUP
1057 BEGINmodExit
1058 CODESTARTmodExit
1059 	objRelease(glbl, CORE_COMPONENT);
1060 	objRelease(strm, CORE_COMPONENT);
1061 	objRelease(statsobj, CORE_COMPONENT);
1062 	DESTROY_ATOMIC_HELPER_MUT(mutClock);
1063 ENDmodExit
1064 BEGINqueryEtryPt
1065 CODESTARTqueryEtryPt
1066 CODEqueryEtryPt_STD_OMODTX_QUERIES
1067 CODEqueryEtryPt_STD_OMOD8_QUERIES
1068 CODEqueryEtryPt_STD_CONF2_QUERIES
1069 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
1070 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1071 CODEqueryEtryPt_doHUP
1072 ENDqueryEtryPt
1073 BEGINmodInit(File)
1074 CODESTARTmodInit
1075 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1076 INITLegCnfVars
1077 	CHKiRet(objUse(strm, CORE_COMPONENT));
1078 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1079 	INIT_ATOMIC_HELPER_MUT(mutClock);
1080 <a name="8"></a>	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
1081 	DBGPRINTF("omfile: %susing transactional output interface.\n", bCoreSupportsBatching ? "" : "not ");
1082 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dynafilecachesize", 0, eCmdHdlrInt, setDynaFileCacheSize,
1083 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		NULL, STD_LOADABLE_MODULE_ID));
1084 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileziplevel", 0, eCmdHdlrInt, NULL, &amp;cs.iZipLevel,
1085 		STD_LOADABLE_MODULE_ID));
1086 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileflushinterval", 0, eCmdHdlrInt, NULL, &amp;cs.iFlushInterval,
1087 		STD_LOADABLE_MODULE_ID));
1088 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileasyncwriting", 0, eCmdHdlrBinary, NULL, &amp;cs.bUseAsyncWriter,
1089 		STD_LOADABLE_MODULE_ID));
1090 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileflushontxend", 0, eCmdHdlrBinary, NULL, &amp;cs.bFlushOnTXEnd,
1091 		STD_LOADABLE_MODULE_ID));
1092 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileiobuffersize", 0, eCmdHdlrSize, NULL, &amp;cs.iIOBufSize,
1093 		STD_LOADABLE_MODULE_ID));
1094 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirowner", 0, eCmdHdlrUID, NULL, &amp;cs.dirUID,
1095 		STD_LOADABLE_MODULE_ID));
1096 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirownernum", 0, eCmdHdlrInt, NULL, &amp;cs.dirUID,
1097 		STD_LOADABLE_MODULE_ID));
1098 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirgroup", 0, eCmdHdlrGID, NULL, &amp;cs.dirGID,
1099 		STD_LOADABLE_MODULE_ID));
1100 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirgroupnum", 0, eCmdHdlrInt, NULL, &amp;cs.dirGID,
1101 		STD_LOADABLE_MODULE_ID));
1102 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"fileowner", 0, eCmdHdlrUID, NULL, &amp;cs.fileUID,
1103 		STD_LOADABLE_MODULE_ID));
1104 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"fileownernum", 0, eCmdHdlrInt, NULL, &amp;cs.fileUID,
1105 		STD_LOADABLE_MODULE_ID));
1106 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filegroup", 0, eCmdHdlrGID, NULL, &amp;cs.fileGID,</b></font>
1107 		STD_LOADABLE_MODULE_ID));
1108 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filegroupnum", 0, eCmdHdlrInt, NULL, &amp;cs.fileGID,
1109 		STD_LOADABLE_MODULE_ID));
1110 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dircreatemode", 0, eCmdHdlrFileCreateMode, NULL,
1111 		&amp;cs.fDirCreateMode, STD_LOADABLE_MODULE_ID));
1112 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filecreatemode", 0, eCmdHdlrFileCreateMode, NULL,
1113 		&amp;cs.fCreateMode, STD_LOADABLE_MODULE_ID));
1114 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"createdirs", 0, eCmdHdlrBinary, NULL, &amp;cs.bCreateDirs,
1115 		STD_LOADABLE_MODULE_ID));
1116 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"failonchownfailure", 0, eCmdHdlrBinary, NULL, &amp;cs.bFailOnChown,
1117 		STD_LOADABLE_MODULE_ID));
1118 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileforcechown", 0, eCmdHdlrGoneAway, NULL, NULL,
1119 		STD_LOADABLE_MODULE_ID));
1120 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionfileenablesync", 0, eCmdHdlrBinary, NULL, &amp;cs.bEnableSync,
1121 		STD_LOADABLE_MODULE_ID));
1122 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionfiledefaulttemplate", 0, eCmdHdlrGetWord, setLegacyDfltTpl,
1123 		NULL, STD_LOADABLE_MODULE_ID));
1124 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
1125 		NULL, STD_LOADABLE_MODULE_ID));
1126 	CHKiRet(objUse(glbl, CORE_COMPONENT));
1127 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imfile.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;fcntl.h&gt;
8 #include &lt;pthread.h&gt;
9 #include &lt;sys/types.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;time.h&gt;
12 #include &lt;glob.h&gt;
13 #include &lt;poll.h&gt;
14 #include &lt;json.h&gt;
15 #include &lt;fnmatch.h&gt;
16 #ifdef HAVE_SYS_INOTIFY_H
17 #include &lt;sys/inotify.h&gt;
18 #include &lt;linux/types.h&gt;
19 #endif
20 #ifdef HAVE_SYS_STAT_H
21 #	include &lt;sys/stat.h&gt;
22 #endif
23 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
24 #include &lt;port.h&gt;
25 #include &lt;sys/port.h&gt;
26 #endif
27 #include "rsyslog.h"		#include "dirty.h"
28 #include "cfsysline.h"		#include "module-template.h"	#include "srUtils.h"		#include "msg.h"
29 #include "stream.h"
30 #include "errmsg.h"
31 #include "glbl.h"
32 #include "unicode-helper.h"
33 #include "prop.h"
34 #include "stringbuf.h"
35 #include "ruleset.h"
36 #include "ratelimit.h"
37 #include "srUtils.h"
38 #include "parserif.h"
39 #include "datetime.h"
40 #include &lt;regex.h&gt;
41 #ifndef O_LARGEFILE
42 #  define O_LARGEFILE 0
43 #endif
44 #ifndef HAVE_LSEEK64
45 #  define lseek64(fd, offset, whence) lseek(fd, offset, whence)
46 #endif
47 MODULE_TYPE_INPUT
48 MODULE_TYPE_NOKEEP
49 MODULE_CNFNAME("imfile")
50 #define FILE_ID_HASH_SIZE 20	#define FILE_ID_SIZE	512	
51 DEF_IMOD_STATIC_DATA	DEFobjCurrIf(glbl)
52 DEFobjCurrIf(strm)
53 DEFobjCurrIf(prop)
54 DEFobjCurrIf(ruleset)
55 DEFobjCurrIf(datetime)
56 extern int rs_siphash(const uint8_t *in, const size_t inlen, const uint8_t *k,
57 	uint8_t *out, const size_t outlen); 
58 static int bLegacyCnfModGlobalsPermitted;
59 #define NUM_MULTISUB 1024 #define DFLT_PollInterval 10
60 #define INIT_WDMAP_TAB_SIZE 1 #define ADD_METADATA_UNSPECIFIED -1
61 #define ULTRA_DEBUG 0
62 #ifndef GLOB_BRACE
63 	#define GLOB_BRACE 0
64 #endif
65 typedef struct per_minute_rate_limit_s per_minute_rate_limit_t;
66 struct per_minute_rate_limit_s {
67 	uint64_t maxBytesPerMinute;
68 	uint32_t maxLinesPerMinute;
69 	uint64_t bytesThisMinute; 	uint32_t linesThisMinute; 	time_t rateLimitingMinute; };
70 static struct configSettings_s {
71 	uchar *pszFileName;
72 	uchar *pszFileTag;
73 	uchar *pszStateFile;
74 	uchar *pszBindRuleset;
75 	int iPollInterval;
76 	int iPersistStateInterval;		int bPersistStateAfterSubmission;	int iFacility; 	int iSeverity;  	int readMode;  	int64 maxLinesAtOnce;		uint64_t maxBytesPerMinute; 	uint64_t maxLinesPerMinute; 	uint32_t trimLineOverBytes;  } cs;
77 struct instanceConf_s {
78 	uchar *pszFileName;
79 	uchar *pszFileName_forOldStateFile; 	uchar *pszDirName;
80 	uchar *pszFileBaseName;
81 	uchar *pszTag;
82 	size_t lenTag;
83 	uchar *pszStateFile;
84 	uchar *pszBindRuleset;
85 	int nMultiSub;
86 	per_minute_rate_limit_t perMinuteRateLimits;
87 	int iPersistStateInterval;
88 	int bPersistStateAfterSubmission;
89 	int iFacility;
90 	int iSeverity;
91 	int readTimeout;
92 	unsigned delay_perMsg;
93 	sbool bRMStateOnDel;
94 	uint8_t readMode;
95 	uchar *startRegex;
96 	uchar *endRegex;
97 	regex_t start_preg;		regex_t end_preg;		sbool discardTruncatedMsg;
98 	sbool msgDiscardingError;
99 	sbool escapeLF;
100 	sbool reopenOnTruncate;
101 	sbool addCeeTag;
102 	sbool addMetadata;
103 	sbool freshStartTail;
104 	sbool fileNotFoundError;
105 	int maxLinesAtOnce;
106 	uint32_t trimLineOverBytes;
107 	uint32_t ignoreOlderThan;
108 	int msgFlag;
109 	uchar *escapeLFString;
110 	ruleset_t *pBindRuleset;		struct instanceConf_s *next;
111 };
112 typedef struct fs_edge_s fs_edge_t;
113 typedef struct fs_node_s fs_node_t;
114 typedef struct act_obj_s act_obj_t;
115 struct act_obj_s {
116 	act_obj_t *prev;
117 	act_obj_t *next;
118 	fs_edge_t *edge;		char *name;			char *basename;			char *source_name;		int wd;
119 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
120 	struct fileinfo *pfinf;
121 	sbool bPortAssociated;
122 	int is_deleted;	#endif
123 	ratelimit_t *ratelimiter;
124 	multi_submit_t multiSub;
125 	int is_symlink;
126 };
127 struct fs_edge_s {
128 	fs_node_t *parent;		fs_node_t *node;		fs_edge_t *next;
129 	uchar *name;
130 	uchar *path;
131 	act_obj_t *active;
132 	int is_file;
133 	int ninst;			instanceConf_t **instarr;
134 };
135 struct fs_node_s {
136 	fs_edge_t *edges;		fs_node_t *root;	};
137 static rsRetVal persistStrmState(act_obj_t *);
138 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
139 static rsRetVal ATTR_NONNULL(1) pollFile(act_obj_t *act);
140 static int ATTR_NONNULL() getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path);
141 static void ATTR_NONNULL() act_obj_unlink(act_obj_t *act);
142 static uchar * ATTR_NONNULL(1, 2) getStateFileName(const act_obj_t *, uchar *, const size_t);
143 static int ATTR_NONNULL() getFullStateFileName(const uchar *const, const char *const,
144 	uchar *const pszout, const size_t ilenout);
145 #define OPMODE_POLLING 0
146 #define OPMODE_INOTIFY 1
147 <a name="10"></a>#define OPMODE_FEN 2
148 <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>struct modConfData_s {
149 	rsconf_t *pConf;		int iPollInterval;		int readTimeout;
150 	int timeoutGranularity;			instanceConf_t *root, *tail;
151 	fs_node_t *conf_tree;
152 	uint8_t opMode;
153 	sbool configSetViaV2Method;
154 	uchar *stateFileDirectory;
155 	sbool sortFiles;
156 };
157 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static modConfData_t *currModConf = NULL;
158 #ifdef HAVE_INOTIFY_INIT
159 struct wd_map_s {
160 	int wd;			act_obj_t *act; };
161 typedef struct wd_map_s wd_map_t;
162 static wd_map_t *wdmap = NULL;
163 static int nWdmap;
164 static int allocMaxWdmap;
165 static int ino_fd;	#endif 
166 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
167 struct fileinfo {
168 	struct file_obj fobj;
169 	int events;
170 	int port;
171 };
172 #endif 
173 static prop_t *pInputName = NULL;
174 <a name="0"></a>
175 static struct cnfparamdescr modpdescr[] = {
176 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "pollinginterval", eCmdHdlrPositiveInt, 0 },
177 	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
178 	{ "timeoutgranularity", eCmdHdlrPositiveInt, 0 },
179 	{ "sortfiles", eCmdHdlrBinary, 0 },
180 	{ "statefile.directory", eCmdHdlrString, 0 },
181 	{ "normalizepath", eCmdHdlrBinary, 0 },
182 	{ "mode", eCmdHdlrGetWord, 0 }
183 };
184 static struct cnfparamblk modpblk =
185 	{ CNFPARAMBLK_VERSION,
186 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
187 	  modpdescr
188 	};
189 static struct cnfparamdescr inppdescr[] = {
190 	{ "file", eCmdHdlrString, CNFPARAM_REQUIRED },
191 	{ "tag", eCmdHdlrString, CNFPARAM_REQUIRED },
192 	{ "severity", eCmdHdlrSeverity, 0 },
193 	{ "facility", eCmdHdlrFacility, 0 },
194 	{ "ruleset", eCmdHdlrString, 0 },
195 	{ "readmode", eCmdHdlrInt, 0 },
196 	{ "startmsg.regex", eCmdHdlrString, 0 },
197 	{ "endmsg.regex", eCmdHdlrString, 0 },
198 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
199 	{ "msgdiscardingerror", eCmdHdlrBinary, 0 },
200 	{ "escapelf", eCmdHdlrBinary, 0 },
201 	{ "escapelf.replacement", eCmdHdlrString, 0 },
202 	{ "reopenontruncate", eCmdHdlrBinary, 0 },
203 	{ "maxlinesatonce", eCmdHdlrInt, 0 },
204 	{ "trimlineoverbytes", eCmdHdlrInt, 0 },
205 	{ "maxsubmitatonce", eCmdHdlrInt, 0 },
206 	{ "removestateondelete", eCmdHdlrBinary, 0 },
207 	{ "persiststateinterval", eCmdHdlrInt, 0 },
208 	{ "persiststateaftersubmission", eCmdHdlrBinary, 0 },
209 	{ "deletestateonfiledelete", eCmdHdlrBinary, 0 },
210 	{ "delay.message", eCmdHdlrNonNegInt, 0 },
211 	{ "addmetadata", eCmdHdlrBinary, 0 },
212 	{ "addceetag", eCmdHdlrBinary, 0 },
213 	{ "statefile", eCmdHdlrString, CNFPARAM_DEPRECATED },
214 	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
215 	{ "freshstarttail", eCmdHdlrBinary, 0},</b></font>
216 	{ "filenotfounderror", eCmdHdlrBinary, 0},
217 	{ "needparse", eCmdHdlrBinary, 0},
218 	{ "ignoreolderthan", eCmdHdlrInt, 0},
219 	{ "maxbytesperminute", eCmdHdlrInt, 0},
220 	{ "maxlinesperminute", eCmdHdlrInt, 0}
221 };
222 static struct cnfparamblk inppblk =
223 	{ CNFPARAMBLK_VERSION,
224 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
225 	  inppdescr
226 	};
227 #include "im-helper.h" 
228 #define ENABLE_V1_STATE_FILE_FORMAT_SUPPORT 1
229 #ifdef ENABLE_V1_STATE_FILE_FORMAT_SUPPORT
230 static uchar * ATTR_NONNULL(1, 2)
231 OLD_getStateFileName(const instanceConf_t *const inst,
232 	 uchar *const __restrict__ buf,
233 	 const size_t lenbuf)
234 {
235 	DBGPRINTF("OLD_getStateFileName trying '%s'\n", inst-&gt;pszFileName_forOldStateFile);
236 	snprintf((char*)buf, lenbuf - 1, "imfile-state:%s", inst-&gt;pszFileName_forOldStateFile);
237 	buf[lenbuf-1] = '\0'; 	uchar *p = buf;
238 	for( ; *p ; ++p) {
239 		if(*p == '/')
240 			*p = '-';
241 	}
242 	return buf;
243 }
244 static const uchar *
245 getStateFileDir(void)
246 {
247 	const uchar *wrkdir;
248 	assert(currModConf != NULL);
249 	if(currModConf-&gt;stateFileDirectory == NULL) {
250 		wrkdir = glblGetWorkDirRaw(currModConf-&gt;pConf);
251 	} else {
252 		wrkdir = currModConf-&gt;stateFileDirectory;
253 	}
254 	return(wrkdir);
255 }
256 static rsRetVal ATTR_NONNULL(1)
257 OLD_openFileWithStateFile(act_obj_t *const act)
258 {
259 	DEFiRet;
260 	strm_t *psSF = NULL;
261 	uchar pszSFNam[MAXFNAME];
262 	size_t lenSFNam;
263 	struct stat stat_buf;
264 	uchar statefile[MAXFNAME];
265 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
266 	uchar *const statefn = OLD_getStateFileName(inst, statefile, sizeof(statefile));
267 	DBGPRINTF("OLD_openFileWithStateFile: trying to open state for '%s', state file '%s'\n",
268 		  act-&gt;name, statefn);
269 	lenSFNam = getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
270 	if(stat((char*) pszSFNam, &amp;stat_buf) == -1) {
271 		if(errno == ENOENT) {
272 			DBGPRINTF("OLD_openFileWithStateFile: NO state file (%s) exists for '%s'\n",
273 				pszSFNam, act-&gt;name);
274 			ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
275 		} else {
276 			char errStr[1024];
277 			rs_strerror_r(errno, errStr, sizeof(errStr));
278 			DBGPRINTF("OLD_openFileWithStateFile: error trying to access state "
279 				"file for '%s':%s\n", act-&gt;name, errStr);
280 			ABORT_FINALIZE(RS_RET_IO_ERROR);
281 		}
282 	}
283 	DBGPRINTF("old state file found - instantiating from it\n");
284 	CHKiRet(strm.Construct(&amp;psSF));
285 	CHKiRet(strm.SettOperationsMode(psSF, STREAMMODE_READ));
286 	CHKiRet(strm.SetsType(psSF, STREAMTYPE_FILE_SINGLE));
287 	CHKiRet(strm.SetFName(psSF, pszSFNam, lenSFNam));
288 	CHKiRet(strm.SetFileNotFoundError(psSF, inst-&gt;fileNotFoundError));
289 	CHKiRet(strm.ConstructFinalize(psSF));
290 	CHKiRet(obj.Deserialize(&amp;act-&gt;pStrm, (uchar*) "strm", psSF, NULL, act));
291 	free(act-&gt;pStrm-&gt;pszFName);
292 	CHKmalloc(act-&gt;pStrm-&gt;pszFName = ustrdup(act-&gt;name));
293 	strm.CheckFileChange(act-&gt;pStrm);
294 	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
295 	persistStrmState(act);
296 	unlink((char*)pszSFNam);
297 finalize_it:
298 	if(psSF != NULL)
299 		strm.Destruct(&amp;psSF);
300 	RETiRet;
301 }
302 #endif 
303 #if 0 static const char * ATTR_NONNULL()
304 gen_full_name(const char *const dirname, const char *const name)
305 {
306 	const size_t len_full_name = strlen(dirname) + 1 + strlen(name) + 1;
307 	char *const full_name = malloc(len_full_name);
308 	if(full_name == NULL)
309 		return NULL;
310 	snprintf(full_name, len_full_name, "%s/%s", dirname, name);
311 	return full_name;
312 }
313 #endif
314 #ifdef HAVE_INOTIFY_INIT
315 #if ULTRA_DEBUG == 1
316 static void
317 dbg_wdmapPrint(const char *msg)
318 {
319 	int i;
320 	DBGPRINTF("%s\n", msg);
321 	for(i = 0 ; i &lt; nWdmap ; ++i)
322 		DBGPRINTF("wdmap[%d]: wd: %d, act %p, name: %s\n",
323 			i, wdmap[i].wd, wdmap[i].act, wdmap[i].act-&gt;name);
324 }
325 #endif
326 static rsRetVal
327 wdmapInit(void)
328 {
329 	DEFiRet;
330 	free(wdmap);
331 	CHKmalloc(wdmap = malloc(sizeof(wd_map_t) * INIT_WDMAP_TAB_SIZE));
332 	allocMaxWdmap = INIT_WDMAP_TAB_SIZE;
333 	nWdmap = 0;
334 finalize_it:
335 	RETiRet;
336 }
337 static rsRetVal
338 wdmapAdd(int wd, act_obj_t *const act)
339 {
340 	wd_map_t *newmap;
341 	int newmapsize;
342 	int i;
343 	DEFiRet;
344 	for(i = nWdmap-1 ; i &gt;= 0 &amp;&amp; wdmap[i].wd &gt; wd ; --i)
345 		; 		if(i &gt;= 0 &amp;&amp; wdmap[i].wd == wd) {
346 		LogError(0, RS_RET_INTERNAL_ERROR, "imfile: wd %d already in wdmap!", wd);
347 		ABORT_FINALIZE(RS_RET_FILE_ALREADY_IN_TABLE);
348 	}
349 	++i;
350 	if(nWdmap == allocMaxWdmap) {
351 		newmapsize = 2 * allocMaxWdmap;
352 		CHKmalloc(newmap = realloc(wdmap, sizeof(wd_map_t) * newmapsize));
353 		wdmap = newmap;
354 		allocMaxWdmap = newmapsize;
355 	}
356 	if(i &lt; nWdmap) {
357 		memmove(wdmap + i + 1, wdmap + i, sizeof(wd_map_t) * (nWdmap - i));
358 	}
359 	wdmap[i].wd = wd;
360 	wdmap[i].act = act;
361 	++nWdmap;
362 	DBGPRINTF("add wdmap[%d]: wd %d, act obj %p, path %s\n", i, wd, act, act-&gt;name);
363 finalize_it:
364 	RETiRet;
365 }
366 static int
367 in_setupWatch(act_obj_t *const act, const int is_file)
368 {
369 	int wd = -1;
370 	if(runModConf-&gt;opMode != OPMODE_INOTIFY)
371 		goto done;
372 	wd = inotify_add_watch(ino_fd, act-&gt;name,
373 		(is_file) ? IN_MODIFY|IN_DONT_FOLLOW : IN_CREATE|IN_DELETE|IN_MOVED_FROM|IN_MOVED_TO);
374 	if(wd &lt; 0) {
375 		if (errno == EACCES) { 			DBGPRINTF("imfile: permission denied when adding watch for '%s'\n", act-&gt;name);
376 		} else {
377 			LogError(errno, RS_RET_IO_ERROR, "imfile: cannot watch object '%s'", act-&gt;name);
378 		}
379 		goto done;
380 	}
381 	wdmapAdd(wd, act);
382 	DBGPRINTF("in_setupWatch: watch %d added for %s(object %p)\n", wd, act-&gt;name, act);
383 done:	return wd;
384 }
385 static int
386 wdmap_cmp(const void *k, const void *a)
387 {
388 	int key = *((int*) k);
389 	wd_map_t *etry = (wd_map_t*) a;
390 	if(key &lt; etry-&gt;wd)
391 		return -1;
392 	else if(key &gt; etry-&gt;wd)
393 		return 1;
394 	else
395 		return 0;
396 }
397 static wd_map_t *
398 wdmapLookup(int wd)
399 {
400 	return bsearch(&amp;wd, wdmap, nWdmap, sizeof(wd_map_t), wdmap_cmp);
401 }
402 static rsRetVal
403 wdmapDel(const int wd)
404 {
405 	int i;
406 	DEFiRet;
407 	for(i = 0 ; i &lt; nWdmap &amp;&amp; wdmap[i].wd &lt; wd ; ++i)
408 		; 		if(i == nWdmap ||  wdmap[i].wd != wd) {
409 		DBGPRINTF("wd %d shall be deleted but not in wdmap!\n", wd);
410 		FINALIZE;
411 	}
412 	if(i &lt; nWdmap-1) {
413 		memmove(wdmap + i, wdmap + i + 1, sizeof(wd_map_t) * (nWdmap - i - 1));
414 	}
415 	--nWdmap;
416 	DBGPRINTF("wd %d deleted, was idx %d\n", wd, i);
417 finalize_it:
418 	RETiRet;
419 }
420 #endif 
421 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
422 static void ATTR_NONNULL()
423 fen_setupWatch(act_obj_t *const act)
424 {
425 	DBGPRINTF("fen_setupWatch: enter, opMode %d\n", runModConf-&gt;opMode);
426 	if(runModConf-&gt;opMode != OPMODE_FEN)
427 		goto done;
428 	DBGPRINTF("fen_setupWatch: %s\n", act-&gt;name);
429 	if(act-&gt;pfinf == NULL) {
430 		act-&gt;pfinf = malloc(sizeof(struct fileinfo));
431 		if (act-&gt;pfinf == NULL) {
432 			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
433 				"for fileinfo failed ");
434 			goto done;
435 		}
436 		if ((act-&gt;pfinf-&gt;fobj.fo_name = strdup(act-&gt;name)) == NULL) {
437 			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
438 				"for strdup failed ");
439 			free(act-&gt;pfinf);
440 			act-&gt;pfinf = NULL;
441 			goto done;
442 		}
443 		act-&gt;pfinf-&gt;events = FILE_MODIFIED;
444 		act-&gt;pfinf-&gt;port = glport;
445 		act-&gt;bPortAssociated = 0;
446 	}
447 	DBGPRINTF("fen_setupWatch: bPortAssociated %d\n", act-&gt;bPortAssociated);
448 	if(act-&gt;bPortAssociated) {
449 		goto done;
450 	}
451 	struct stat fileInfo;
452 	const int r = stat(act-&gt;name, &amp;fileInfo);
453 	if(r == -1) { 		DBGPRINTF("fen_setupWatch: file gone away, no watch: '%s'\n", act-&gt;name);
454 		goto done;
455 	}
456 	act-&gt;pfinf-&gt;fobj.fo_atime = fileInfo.st_atim;
457 	act-&gt;pfinf-&gt;fobj.fo_mtime = fileInfo.st_mtim;
458 	act-&gt;pfinf-&gt;fobj.fo_ctime = fileInfo.st_ctim;
459 	if(port_associate(glport, PORT_SOURCE_FILE, (uintptr_t)&amp;(act-&gt;pfinf-&gt;fobj),
460 				act-&gt;pfinf-&gt;events, (void *)act) == -1) {
461 		LogError(errno, RS_RET_SYS_ERR, "fen_setupWatch: Failed to associate port for file "
462 			": %s\n", act-&gt;pfinf-&gt;fobj.fo_name);
463 		goto done;
464 	} else {
465 		DBGPRINTF("fen_setupWatch: associated port for file %s\n", act-&gt;name);
466 		act-&gt;bPortAssociated = 1;
467 	}
468 	DBGPRINTF("in_setupWatch: fen association added for %s\n", act-&gt;name);
469 done:	return;
470 }
471 #else
472 static void ATTR_NONNULL()
473 fen_setupWatch(act_obj_t *const act __attribute__((unused)))
474 {
475 	DBGPRINTF("fen_setupWatch: DUMMY CALLED - not on Solaris?\n");
476 }
477 #endif 
478 static void
479 fs_node_print(const fs_node_t *const node, const int level)
480 {
481 	fs_edge_t *chld;
482 	act_obj_t *act;
483 	dbgprintf("node print[%2.2d]: %p edges:\n", level, node);
484 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
485 		dbgprintf("node print[%2.2d]:     child %p '%s' isFile %d, path: '%s'\n",
486 			level, chld-&gt;node, chld-&gt;name, chld-&gt;is_file, chld-&gt;path);
487 		for(int i = 0 ; i &lt; chld-&gt;ninst ; ++i) {
488 			dbgprintf("\tinst: %p\n", chld-&gt;instarr[i]);
489 		}
490 		for(act = chld-&gt;active ; act != NULL ; act = act-&gt;next) {
491 			dbgprintf("\tact : %p\n", act);
492 			dbgprintf("\tact : %p: name '%s', wd: %d\n",
493 				act, act-&gt;name, act-&gt;wd);
494 		}
495 	}
496 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
497 		fs_node_print(chld-&gt;node, level+1);
498 	}
499 }
500 static sbool
501 isIgnoreOlderFile(const instanceConf_t *const inst, const char *const name)
502 {
503 	if (inst-&gt;ignoreOlderThan)
504 	{
505 		struct stat stat_buf;
506 		time_t tt;
507 		datetime.GetTime(&amp;tt);
508 		if (stat((char *)name, &amp;stat_buf) == 0 &amp;&amp; difftime(tt, stat_buf.st_mtime) &gt; inst-&gt;ignoreOlderThan) {
509 			return 1;
510 		}
511 	}
512 	return 0;
513 }
514 static rsRetVal ATTR_NONNULL(1,2)
515 act_obj_add(fs_edge_t *const edge, const char *const name, const int is_file,
516 	const ino_t ino, const int is_symlink, const char *const source)
517 {
518 	act_obj_t *act = NULL;
519 	char basename[MAXFNAME];
520 	DEFiRet;
521 	int fd = -1;
522 	DBGPRINTF("act_obj_add: edge %p, name '%s' (source '%s')\n", edge, name, source? source : "---");
523 	if (isIgnoreOlderFile(edge-&gt;instarr[0], name)) {
524 		ABORT_FINALIZE(RS_RET_ERR);
525 	}
526 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
527 		if(!strcmp(act-&gt;name, name)) {
528 			if (!source || !act-&gt;source_name || !strcmp(act-&gt;source_name, source)) {
529 				DBGPRINTF("active object '%s' already exists in '%s' - no need to add\n",
530 					name, edge-&gt;path);
531 				FINALIZE;
532 			}
533 		}
534 	}
535 	DBGPRINTF("need to add new active object '%s' in '%s' - checking if accessible\n", name, edge-&gt;path);
536 	fd = open(name, O_RDONLY | O_CLOEXEC);
537 	if(fd &lt; 0) {
538 		if (is_file) {
539 			LogError(errno, RS_RET_ERR, "imfile: error accessing file '%s'", name);
540 		} else { 			DBGPRINTF("imfile: error accessing directory '%s'", name);
541 		}
542 		ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
543 	}
544 	DBGPRINTF("add new active object '%s' in '%s'\n", name, edge-&gt;path);
545 	CHKmalloc(act = calloc(sizeof(act_obj_t), 1));
546 	CHKmalloc(act-&gt;name = strdup(name));
547 	if (-1 == getBasename((uchar*)basename, (uchar*)name)) {
548 		CHKmalloc(act-&gt;basename = strdup(name)); 	} else {
549 		CHKmalloc(act-&gt;basename = strdup(basename));
550 	}
551 	act-&gt;edge = edge;
552 	act-&gt;ino = ino;
553 	act-&gt;fd = fd;
554 	act-&gt;file_id[0] = '\0';
555 	act-&gt;file_id_prev[0] = '\0';
556 	act-&gt;is_symlink = is_symlink;
557 	act-&gt;ratelimiter = NULL;
558 	if (source) { 		CHKmalloc(act-&gt;source_name = strdup(source));
559 	} else {
560 		act-&gt;source_name = NULL;
561 	}
562 	#ifdef HAVE_INOTIFY_INIT
563 	act-&gt;wd = in_setupWatch(act, is_file);
564 	#endif
565 	fen_setupWatch(act);
566 	if(is_file &amp;&amp; !is_symlink) {
567 		const instanceConf_t *const inst = edge-&gt;instarr[0];		CHKiRet(ratelimitNew(&amp;act-&gt;ratelimiter, "imfile", name));
568 		CHKmalloc(act-&gt;multiSub.ppMsgs = malloc(inst-&gt;nMultiSub * sizeof(smsg_t *)));
569 		act-&gt;multiSub.maxElem = inst-&gt;nMultiSub;
570 		act-&gt;multiSub.nElem = 0;
571 		pollFile(act);
572 	}
573 	if(edge-&gt;active != NULL) {
574 		edge-&gt;active-&gt;prev = act;
575 	}
576 	act-&gt;next = edge-&gt;active;
577 	edge-&gt;active = act;
578 finalize_it:
579 	if(iRet != RS_RET_OK) {
580 		if(act != NULL) {
581 			if (act-&gt;ratelimiter != NULL)
582 				ratelimitDestruct(act-&gt;ratelimiter);
583 			free(act-&gt;name);
584 			free(act);
585 		}
586 		if(fd != -1) {
587 			close(fd);
588 		}
589 	}
590 	RETiRet;
591 }
592 static void
593 detect_updates(fs_edge_t *const edge)
594 {
595 	act_obj_t *act;
596 	struct stat fileInfo;
597 	int restart = 0;
598 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
599 		DBGPRINTF("detect_updates checking active obj '%s'\n", act-&gt;name);
600 		const int r = lstat(act-&gt;name, &amp;fileInfo);
601 		if(r == -1) { 			DBGPRINTF("object gone away, unlinking: '%s'\n", act-&gt;name);
602 			act_obj_unlink(act);
603 			restart = 1;
604 			break;
605 		} else if(fileInfo.st_ino != act-&gt;ino) {
606 			DBGPRINTF("file '%s' inode changed from %llu to %llu, unlinking from "
607 				"internal lists\n", act-&gt;name, (long long unsigned) act-&gt;ino,
608 				(long long unsigned) fileInfo.st_ino);
609 			if(act-&gt;pStrm != NULL) {
610 				strmSet_checkRotation(act-&gt;pStrm, STRM_ROTATION_DO_NOT_CHECK);
611 			}
612 			act_obj_unlink(act);
613 			restart = 1;
614 			break;
615 		}
616 	}
617 	if (restart) {
618 		detect_updates(edge);
619 	}
620 }
621 static void ATTR_NONNULL()
622 poll_active_files(fs_edge_t *const edge)
623 {
624 	if(   runModConf-&gt;opMode != OPMODE_POLLING
625 	   || !edge-&gt;is_file
626 	   || glbl.GetGlobalInputTermState() != 0) {
627 		return;
628 	}
629 	act_obj_t *act;
630 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
631 		fen_setupWatch(act);
632 		DBGPRINTF("poll_active_files: polling '%s'\n", act-&gt;name);
633 		pollFile(act);
634 	}
635 }
636 static rsRetVal ATTR_NONNULL()
637 process_symlink(fs_edge_t *const chld, const char *symlink)
638 {
639 	DEFiRet;
640 	char *target;
641 	CHKmalloc(target = realpath(symlink, NULL));
642 	struct stat fileInfo;
643 	if(lstat(target, &amp;fileInfo) != 0) {
644 		LogError(errno, RS_RET_ERR,	"imfile: process_symlink: cannot stat file '%s' - ignored", target);
645 		FINALIZE;
646 	}
647 	const int is_file = (S_ISREG(fileInfo.st_mode));
648 	DBGPRINTF("process_symlink:  found '%s', File: %d (config file: %d), symlink: %d\n",
649 		target, is_file, chld-&gt;is_file, 0);
650 	if (act_obj_add(chld, target, is_file, fileInfo.st_ino, 0, symlink) == RS_RET_OK) {
651 		uint idx = ustrlen(chld-&gt;active-&gt;name) - ustrlen(chld-&gt;active-&gt;basename);
652 		if (idx) { 			char parent[MAXFNAME];
653 			idx--; 			memcpy(parent, chld-&gt;active-&gt;name, idx);
654 			parent[idx] = '\0';
655 			if(lstat(parent, &amp;fileInfo) != 0) {
656 				LogError(errno, RS_RET_ERR,
657 					"imfile: process_symlink: cannot stat directory '%s' - ignored", parent);
658 				FINALIZE;
659 			}
660 			if (chld-&gt;parent-&gt;root-&gt;edges) {
661 				DBGPRINTF("process_symlink: adding parent '%s' of target '%s'\n", parent, target);
662 				act_obj_add(chld-&gt;parent-&gt;root-&gt;edges, parent, 0, fileInfo.st_ino, 0, NULL);
663 			}
664 		}
665 	}
666 finalize_it:
667 	free(target);
668 	RETiRet;
669 }
670 static void ATTR_NONNULL()
671 poll_tree(fs_edge_t *const chld)
672 {
673 	struct stat fileInfo;
674 	glob_t files;
675 	int need_globfree = 0;
676 	int issymlink;
677 	DBGPRINTF("poll_tree: chld %p, name '%s', path: %s\n", chld, chld-&gt;name, chld-&gt;path);
678 	detect_updates(chld);
679 	const int ret = glob((char*)chld-&gt;path, runModConf-&gt;sortFiles|GLOB_BRACE, NULL, &amp;files);
680 	need_globfree = 1;
681 	DBGPRINTF("poll_tree: glob returned %d\n", ret);
682 	if(ret == 0) {
683 		DBGPRINTF("poll_tree: processing %d files\n", (int) files.gl_pathc);
684 		for(unsigned i = 0 ; i &lt; files.gl_pathc ; i++) {
685 			if(glbl.GetGlobalInputTermState() != 0) {
686 				goto done;
687 			}
688 			char *const file = files.gl_pathv[i];
689 			if(lstat(file, &amp;fileInfo) != 0) {
690 				LogError(errno, RS_RET_ERR,
691 					"imfile: poll_tree cannot stat file '%s' - ignored", file);
692 				continue;
693 			}
694 			if (S_ISLNK(fileInfo.st_mode)) {
695 				rsRetVal slink_ret = process_symlink(chld, file);
696 				if (slink_ret != RS_RET_OK) {
697 					continue;
698 				}
699 				issymlink = 1;
700 			} else {
701 				issymlink = 0;
702 			}
703 			const int is_file = (S_ISREG(fileInfo.st_mode) || issymlink);
704 			DBGPRINTF("poll_tree:  found '%s', File: %d (config file: %d), symlink: %d\n",
705 				file, is_file, chld-&gt;is_file, issymlink);
706 			if(!is_file &amp;&amp; S_ISREG(fileInfo.st_mode)) {
707 				LogMsg(0, RS_RET_ERR, LOG_WARNING,
708 					"imfile: '%s' is neither a regular file, symlink, nor a "
709 					"directory - ignored", file);
710 				continue;
711 			}
712 			if(!issymlink &amp;&amp; (chld-&gt;is_file != is_file)) {
713 				LogMsg(0, RS_RET_ERR, LOG_WARNING,
714 					"imfile: '%s' is %s but %s expected - ignored",
715 					file, (is_file) ? "FILE" : "DIRECTORY",
716 					(chld-&gt;is_file) ? "FILE" : "DIRECTORY");
717 				continue;
718 			}
719 			act_obj_add(chld, file, is_file, fileInfo.st_ino, issymlink, NULL);
720 		}
721 	}
722 	poll_active_files(chld);
723 done:
724 	if(need_globfree) {
725 		globfree(&amp;files);
726 	}
727 	return;
728 }
729 #ifdef HAVE_INOTIFY_INIT static void ATTR_NONNULL()
730 poll_timeouts(fs_edge_t *const edge)
731 {
732 	if(edge-&gt;is_file) {
733 		act_obj_t *act;
734 		for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
735 			if(act-&gt;pStrm &amp;&amp; strmReadMultiLine_isTimedOut(act-&gt;pStrm)) {
736 				DBGPRINTF("timeout occurred on %s\n", act-&gt;name);
737 				pollFile(act);
738 			}
739 		}
740 	}
741 }
742 #endif
743 static void
744 act_obj_destroy(act_obj_t *const act, const int is_deleted)
745 {
746 	uchar *statefn;
747 	uchar statefile[MAXFNAME];
748 	uchar toDel[MAXFNAME];
749 	if(act == NULL)
750 		return;
751 	DBGPRINTF("act_obj_destroy: act %p '%s' (source '%s'), wd %d, pStrm %p, is_deleted %d, in_move %d\n",
752 		act, act-&gt;name, act-&gt;source_name? act-&gt;source_name : "---", act-&gt;wd, act-&gt;pStrm, is_deleted,
753 		act-&gt;in_move);
754 	if(act-&gt;is_symlink &amp;&amp; is_deleted) {
755 		act_obj_t *target_act;
756 		for(target_act = act-&gt;edge-&gt;active ; target_act != NULL ; target_act = target_act-&gt;next) {
757 			if(target_act-&gt;source_name &amp;&amp; !strcmp(target_act-&gt;source_name, act-&gt;name)) {
758 				DBGPRINTF("act_obj_destroy: unlinking slink target %s of %s "
759 						"symlink\n", target_act-&gt;name, act-&gt;name);
760 				act_obj_unlink(target_act);
761 				break;
762 			}
763 		}
764 	}
765 	if(act-&gt;pStrm != NULL) {
766 		const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];		pollFile(act); 		if(inst-&gt;bRMStateOnDel) {
767 			statefn = getStateFileName(act, statefile, sizeof(statefile));
768 			getFullStateFileName(statefn, act-&gt;file_id, toDel, sizeof(toDel)); 			statefn = toDel;
769 		}
770 		persistStrmState(act);
771 		strm.Destruct(&amp;act-&gt;pStrm);
772 		if(is_deleted &amp;&amp; !act-&gt;in_move &amp;&amp; inst-&gt;bRMStateOnDel) {
773 			DBGPRINTF("act_obj_destroy: deleting state file %s\n", statefn);
774 			unlink((char*)statefn);
775 		}
776 	}
777 	if(act-&gt;ratelimiter != NULL) {
778 		ratelimitDestruct(act-&gt;ratelimiter);
779 	}
780 	#ifdef HAVE_INOTIFY_INIT
781 	if(act-&gt;wd != -1) {
782 		inotify_rm_watch(ino_fd, act-&gt;wd);
783 		wdmapDel(act-&gt;wd);
784 	}
785 	#endif
786 	if(act-&gt;fd &gt;= 0) {
787 		close(act-&gt;fd);
788 	}
789 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
790 	if(act-&gt;pfinf != NULL) {
791 		free(act-&gt;pfinf-&gt;fobj.fo_name);
792 		free(act-&gt;pfinf);
793 	}
794 	#endif
795 	free(act-&gt;basename);
796 	free(act-&gt;source_name);
797 	free(act-&gt;multiSub.ppMsgs);
798 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
799 		act-&gt;is_deleted = 1;
800 	#else
801 		free(act-&gt;name);
802 		free(act);
803 	#endif
804 }
805 static void
806 act_obj_destroy_all(act_obj_t *act)
807 {
808 	if(act == NULL)
809 		return;
810 	DBGPRINTF("act_obj_destroy_all: act %p '%s', wd %d, pStrm %p\n", act, act-&gt;name, act-&gt;wd, act-&gt;pStrm);
811 	while(act != NULL) {
812 		act_obj_t *const toDel = act;
813 		act = act-&gt;next;
814 		act_obj_destroy(toDel, 0);
815 	}
816 }
817 #if 0
818 static void
819 chk_active(const act_obj_t *act, const act_obj_t *const deleted)
820 {
821 	while(act != NULL) {
822 		DBGPRINTF("chk_active %p vs %p\n", act, deleted);
823 		if(act-&gt;prev == deleted)
824 			DBGPRINTF("chk_active %p prev points to %p\n", act, deleted);
825 		if(act-&gt;next == deleted)
826 			DBGPRINTF("chk_active %p next points to %p\n", act, deleted);
827 		act = act-&gt;next;
828 		DBGPRINTF("chk_active next %p\n", act);
829 	}
830 }
831 #endif
832 static void ATTR_NONNULL()
833 act_obj_unlink(act_obj_t *act)
834 {
835 	DBGPRINTF("act_obj_unlink %p: %s, pStrm %p\n", act, act-&gt;name, act-&gt;pStrm);
836 	if(act-&gt;prev == NULL) {
837 		act-&gt;edge-&gt;active = act-&gt;next;
838 	} else {
839 		act-&gt;prev-&gt;next = act-&gt;next;
840 	}
841 	if(act-&gt;next != NULL) {
842 		act-&gt;next-&gt;prev = act-&gt;prev;
843 	}
844 	act_obj_destroy(act, 1);
845 	act = NULL;
846 }
847 static void
848 fs_node_destroy(fs_node_t *const node)
849 {
850 	fs_edge_t *edge;
851 	DBGPRINTF("node destroy: %p edges:\n", node);
852 	for(edge = node-&gt;edges ; edge != NULL ; ) {
853 		fs_node_destroy(edge-&gt;node);
854 		fs_edge_t *const toDel = edge;
855 		edge = edge-&gt;next;
856 		act_obj_destroy_all(toDel-&gt;active);
857 		free(toDel-&gt;name);
858 		free(toDel-&gt;path);
859 		free(toDel-&gt;instarr);
860 		free(toDel);
861 	}
862 	free(node);
863 }
864 static void ATTR_NONNULL(1, 2)
865 fs_node_walk(fs_node_t *const node,
866 	void (*f_usr)(fs_edge_t*const))
867 {
868 	DBGPRINTF("node walk: %p edges:\n", node);
869 	fs_edge_t *edge;
870 	for(edge = node-&gt;edges ; edge != NULL ; edge = edge-&gt;next) {
871 		DBGPRINTF("node walk: child %p '%s'\n", edge-&gt;node, edge-&gt;name);
872 		f_usr(edge);
873 		fs_node_walk(edge-&gt;node, f_usr);
874 	}
875 }
876 static rsRetVal
877 fs_node_add(fs_node_t *const node,
878 	fs_node_t *const source,
879 	const uchar *const toFind,
880 	const size_t pathIdx,
881 	instanceConf_t *const inst)
882 {
883 	DEFiRet;
884 	fs_edge_t *newchld = NULL;
885 	int i;
886 	DBGPRINTF("fs_node_add(%p, '%s') enter, idx %zd\n",
887 		node, toFind+pathIdx, pathIdx);
888 	assert(toFind[0] != '\0');
889 	for(i = pathIdx ; (toFind[i] != '\0') &amp;&amp; (toFind[i] != '/') ; ++i)
890 	const int isFile = (toFind[i] == '\0') ? 1 : 0;
891 	uchar ourPath[PATH_MAX];
892 	if(i == 0) {
893 		ourPath[0] = '/';
894 		ourPath[1] = '\0';
895 	} else {
896 		memcpy(ourPath, toFind, i);
897 		ourPath[i] = '\0';
898 	}
899 	const size_t nextPathIdx = i+1;
900 	const size_t len = i - pathIdx;
901 	uchar name[PATH_MAX];
902 	memcpy(name, toFind+pathIdx, len);
903 	name[len] = '\0';
904 	DBGPRINTF("fs_node_add: name '%s'\n", name);
905 	node-&gt;root = source;
906 	fs_edge_t *chld;
907 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
908 		if(!ustrcmp(chld-&gt;name, name)) {
909 			DBGPRINTF("fs_node_add(%p, '%s') found '%s'\n", chld-&gt;node, toFind, name);
910 			instanceConf_t **instarr_new = realloc(chld-&gt;instarr,
911 							sizeof(instanceConf_t*) * (chld-&gt;ninst+1));
912 			CHKmalloc(instarr_new);
913 			chld-&gt;instarr = instarr_new;
914 			chld-&gt;ninst++;
915 			chld-&gt;instarr[chld-&gt;ninst-1] = inst;
916 			if(!isFile) {
917 				CHKiRet(fs_node_add(chld-&gt;node, node, toFind, nextPathIdx, inst));
918 			}
919 			FINALIZE;
920 		}
921 	}
922 	DBGPRINTF("fs_node_add(%p, '%s') did not find '%s' - adding it\n",
923 		node, toFind, name);
924 	CHKmalloc(newchld = calloc(sizeof(fs_edge_t), 1));
925 	CHKmalloc(newchld-&gt;name = ustrdup(name));
926 	CHKmalloc(newchld-&gt;node = calloc(sizeof(fs_node_t), 1));
927 	CHKmalloc(newchld-&gt;path = ustrdup(ourPath));
928 	CHKmalloc(newchld-&gt;instarr = calloc(sizeof(instanceConf_t*), 1));
929 	newchld-&gt;instarr[0] = inst;
930 	newchld-&gt;is_file = isFile;
931 	newchld-&gt;ninst = 1;
932 	newchld-&gt;parent = node;
933 	DBGPRINTF("fs_node_add(%p, '%s') returns %p\n", node, toFind, newchld-&gt;node);
934 	if(!isFile) {
935 		CHKiRet(fs_node_add(newchld-&gt;node, node, toFind, nextPathIdx, inst));
936 	}
937 	newchld-&gt;next = node-&gt;edges;
938 	node-&gt;edges = newchld;
939 finalize_it:
940 	if(iRet != RS_RET_OK) {
941 		if(newchld != NULL) {
942 		free(newchld-&gt;name);
943 		free(newchld-&gt;node);
944 		free(newchld-&gt;path);
945 		free(newchld-&gt;instarr);
946 		free(newchld);
947 		}
948 	}
949 	RETiRet;
950 }
951 static int ATTR_NONNULL()
952 getFullStateFileName(const uchar *const pszstatefile,
953 	const char *const file_id,
954 	uchar *const pszout,
955 	const size_t ilenout)
956 {
957 	int lenout;
958 	const uchar* pszstatedir;
959 	pszstatedir = getStateFileDir();
960 	lenout = snprintf((char*)pszout, ilenout, "%s/%s%s%s",
961 		(char*) (pszstatedir == NULL ? "." : (char*) pszstatedir), (char*)pszstatefile,
962 		(*file_id == '\0') ? "" : ":", file_id);
963 	return lenout;
964 }
965 #if defined(__clang__)
966 #pragma GCC diagnostic ignored "-Wunknown-attributes"
967 #endif
968 static void __attribute__((nonnull(1,3)))
969 #if defined(__clang__)
970 __attribute__((no_sanitize("unsigned-integer-overflow")))
971 #endif
972 get_file_id_hash(const char *data, size_t lendata,
973 	char *const hash_str, const size_t len_hash_str)
974 {
975 	assert(len_hash_str &gt;= 17); 
976 	size_t i;
977 	uint8_t out[8], k[16];
978 	for (i = 0; i &lt; 16; ++i)
979 		k[i] = i;
980 	memset(out, 0, sizeof(out));
981 	rs_siphash((const uint8_t *)data, lendata, k, out, 8);
982 	for(i = 0 ; i &lt; 8 ; ++i) {
983 		if(2 * i+1 &gt;= len_hash_str)
984 			break;
985 		snprintf(hash_str+(2*i), 3, "%2.2x", out[i]);
986 	}
987 }
988 static void ATTR_NONNULL(1)
989 getFileID(act_obj_t *const act)
990 {
991 	char tmp_id[FILE_ID_HASH_SIZE];
992 	strncpy(tmp_id, (const char*)act-&gt;file_id, FILE_ID_HASH_SIZE);
993 	act-&gt;file_id[0] = '\0';
994 	assert(act-&gt;fd &gt;= 0); 	char filedata[FILE_ID_SIZE];
995 	lseek(act-&gt;fd, 0, SEEK_SET); 	const int r = read(act-&gt;fd, filedata, FILE_ID_SIZE);
996 	if(r == FILE_ID_SIZE) {
997 		get_file_id_hash(filedata, sizeof(filedata), act-&gt;file_id, sizeof(act-&gt;file_id));
998 	} else {
999 		DBGPRINTF("getFileID partial or error read, ret %d\n", r);
1000 	}
1001 	if (strncmp(tmp_id, act-&gt;file_id, FILE_ID_HASH_SIZE)) {		strncpy(act-&gt;file_id_prev, tmp_id, FILE_ID_HASH_SIZE);
1002 	}
1003 	DBGPRINTF("getFileID for '%s', file_id_hash '%s'\n", act-&gt;name, act-&gt;file_id);
1004 }
1005 static uchar * ATTR_NONNULL(1, 2)
1006 getStateFileName(const act_obj_t *const act,
1007 	 	 uchar *const __restrict__ buf,
1008 		 const size_t lenbuf)
1009 {
1010 	DBGPRINTF("getStateFileName for '%s'\n", act-&gt;name);
1011 	snprintf((char*)buf, lenbuf - 1, "imfile-state:%lld", (long long) act-&gt;ino);
1012 	DBGPRINTF("getStateFileName:  state file name now is %s\n", buf);
1013 	return buf;
1014 }
1015 static rsRetVal
1016 checkPerMinuteRateLimits(per_minute_rate_limit_t *per_minute_rate_limits,
1017 			     const size_t msgLen)
1018 {
1019 	DEFiRet;
1020 	time_t current_minute = time(NULL)/60;
1021 	if(per_minute_rate_limits-&gt;maxBytesPerMinute) {
1022 		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
1023 			per_minute_rate_limits-&gt;bytesThisMinute += msgLen;
1024 			if (per_minute_rate_limits-&gt;bytesThisMinute &gt; per_minute_rate_limits-&gt;maxBytesPerMinute) {
1025 				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
1026 			}
1027 		} else {
1028 			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
1029 			per_minute_rate_limits-&gt;bytesThisMinute = msgLen; 		}
1030 	}
1031 	if(per_minute_rate_limits-&gt;maxLinesPerMinute) {
1032 		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
1033 			per_minute_rate_limits-&gt;linesThisMinute++;
1034 			if (per_minute_rate_limits-&gt;linesThisMinute &gt; per_minute_rate_limits-&gt;maxLinesPerMinute) {
1035 				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
1036 			}
1037 		} else {
1038 			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
1039 			per_minute_rate_limits-&gt;linesThisMinute = 1; 		}
1040 	}
1041 finalize_it:
1042 	RETiRet;
1043 }
1044 #define MAX_OFFSET_REPRESENTATION_NUM_BYTES 20
1045 static rsRetVal ATTR_NONNULL(1,2)
1046 enqLine(act_obj_t *const act,
1047 	cstr_t *const __restrict__ cstrLine,
1048 	const int64 strtOffs)
1049 {
1050 	DEFiRet;
1051 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];	smsg_t *pMsg;
1052 	uchar file_offset[MAX_OFFSET_REPRESENTATION_NUM_BYTES+1];
1053 	const uchar *metadata_names[2] = {(uchar *)"filename",(uchar *)"fileoffset"} ;
1054 	const uchar *metadata_values[2] ;
1055 	const size_t msgLen = cstrLen(cstrLine);
1056 	if(msgLen == 0) {
1057 		FINALIZE;
1058 	}
1059 	CHKiRet(msgConstruct(&amp;pMsg));
1060 	MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY);
1061 	MsgSetInputName(pMsg, pInputName);
1062 	if(inst-&gt;addCeeTag) {
1063 		size_t ceeMsgSize = msgLen + CONST_LEN_CEE_COOKIE + 1;
1064 		char *ceeMsg;
1065 		CHKmalloc(ceeMsg = malloc(ceeMsgSize));
1066 		strcpy(ceeMsg, CONST_CEE_COOKIE);
1067 		strcat(ceeMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine));
1068 		MsgSetRawMsg(pMsg, ceeMsg, ceeMsgSize);
1069 		free(ceeMsg);
1070 	} else {
1071 		MsgSetRawMsg(pMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine), msgLen);
1072 	}
1073 	MsgSetMSGoffs(pMsg, 0);		MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
1074 	MsgSetTAG(pMsg, inst-&gt;pszTag, inst-&gt;lenTag);
1075 	msgSetPRI(pMsg, inst-&gt;iFacility | inst-&gt;iSeverity);
1076 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
1077 	if(inst-&gt;addMetadata) {
1078 		if (act-&gt;source_name) {
1079 			metadata_values[0] = (const uchar*)act-&gt;source_name;
1080 		} else {
1081 			metadata_values[0] = (const uchar*)act-&gt;name;
1082 		}
1083 		snprintf((char *)file_offset, MAX_OFFSET_REPRESENTATION_NUM_BYTES+1, "%lld", strtOffs);
1084 		metadata_values[1] = file_offset;
1085 		msgAddMultiMetadata(pMsg, metadata_names, metadata_values, 2);
1086 	}
1087 	if(inst-&gt;perMinuteRateLimits.maxBytesPerMinute || inst-&gt;perMinuteRateLimits.maxLinesPerMinute) {
1088 		CHKiRet(checkPerMinuteRateLimits((per_minute_rate_limit_t *)&amp;inst-&gt;perMinuteRateLimits, msgLen));
1089 	}
1090 	if(inst-&gt;delay_perMsg) {
1091 		srSleep(inst-&gt;delay_perMsg % 1000000, inst-&gt;delay_perMsg / 1000000);
1092 	}
1093 	pMsg-&gt;msgFlags = pMsg-&gt;msgFlags | inst-&gt;msgFlag;
1094 	ratelimitAddMsg(act-&gt;ratelimiter, &amp;act-&gt;multiSub, pMsg);
1095 finalize_it:
1096 	RETiRet;
1097 }
1098 static rsRetVal ATTR_NONNULL(1)
1099 openFileWithStateFile(act_obj_t *const act)
1100 {
1101 	DEFiRet;
1102 	uchar pszSFNam[MAXFNAME];
1103 	uchar statefile[MAXFNAME];
1104 	int fd = -1;
1105 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1106 	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
1107 	getFileID(act);
1108 	getFullStateFileName(statefn, act-&gt;file_id, pszSFNam, sizeof(pszSFNam));
1109 	DBGPRINTF("trying to open state for '%s', state file '%s'\n", act-&gt;name, pszSFNam);
1110 	fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
1111 	if(fd &lt; 0) {
1112 		if(errno == ENOENT) {
1113 			if(act-&gt;file_id[0] != '\0') {
1114 				DBGPRINTF("state file %s for %s does not exist - trying to see if "
1115 					"inode-only file exists\n", pszSFNam, act-&gt;name);
1116 				getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
1117 				fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
1118 				if(fd &gt;= 0) {
1119 					dbgprintf("found inode-only state file, will be renamed at next persist\n");
1120 				}
1121 			}
1122 			if(fd &lt; 0) {
1123 				DBGPRINTF("state file %s for %s does not exist - trying to see if "
1124 					"old-style file exists\n", pszSFNam, act-&gt;name);
1125 				CHKiRet(OLD_openFileWithStateFile(act));
1126 				FINALIZE;
1127 			}
1128 		} else {
1129 			LogError(errno, RS_RET_IO_ERROR,
1130 				"imfile error trying to access state file for '%s'",
1131 			        act-&gt;name);
1132 			ABORT_FINALIZE(RS_RET_IO_ERROR);
1133 		}
1134 	}
1135 	DBGPRINTF("opened state file %s for %s\n", pszSFNam, act-&gt;name);
1136 	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
1137 	struct json_object *jval;
1138 	struct json_object *json = fjson_object_from_fd(fd);
1139 	if(json == NULL) {
1140 		LogError(0, RS_RET_ERR, "imfile: error reading state file for '%s'", act-&gt;name);
1141 	}
1142 	fjson_object_object_get_ex(json, "prev_was_nl", &amp;jval);
1143 	act-&gt;pStrm-&gt;bPrevWasNL = fjson_object_get_int(jval);
1144 	fjson_object_object_get_ex(json, "curr_offs", &amp;jval);
1145 	act-&gt;pStrm-&gt;iCurrOffs = fjson_object_get_int64(jval);
1146 	fjson_object_object_get_ex(json, "strt_offs", &amp;jval);
1147 	act-&gt;pStrm-&gt;strtOffs = fjson_object_get_int64(jval);
1148 	fjson_object_object_get_ex(json, "prev_line_segment", &amp;jval);
1149 	const uchar *const prev_line_segment = (const uchar*)fjson_object_get_string(jval);
1150 	if(jval != NULL) {
1151 		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevLineSegment, prev_line_segment));
1152 		cstrFinalize(act-&gt;pStrm-&gt;prevLineSegment);
1153 		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevLineSegment);
1154 		DBGPRINTF("prev_line_segment present in state file 2, is: %s\n", ret);
1155 	}
1156 	fjson_object_object_get_ex(json, "prev_msg_segment", &amp;jval);
1157 	const uchar *const prev_msg_segment = (const uchar*)fjson_object_get_string(jval);
1158 	if(jval != NULL) {
1159 		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevMsgSegment, prev_msg_segment));
1160 		cstrFinalize(act-&gt;pStrm-&gt;prevMsgSegment);
1161 		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevMsgSegment);
1162 		DBGPRINTF("prev_msg_segment present in state file 2, is: %s\n", ret);
1163 	}
1164 	fjson_object_put(json);
1165 	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
1166 	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
1167 	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
1168 	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
1169 	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
1170 	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
1171 finalize_it:
1172 	if(fd &gt;= 0) {
1173 		close(fd);
1174 	}
1175 	RETiRet;
1176 }
1177 static rsRetVal
1178 openFileWithoutStateFile(act_obj_t *const act)
1179 {
1180 	DEFiRet;
1181 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1182 	DBGPRINTF("clean startup withOUT state file for '%s'\n", act-&gt;name);
1183 	if(act-&gt;pStrm != NULL)
1184 		strm.Destruct(&amp;act-&gt;pStrm);
1185 	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
1186 	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
1187 	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
1188 	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
1189 	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
1190 	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
1191 	if(inst-&gt;freshStartTail) {
1192 		const int fd = open(act-&gt;name, O_RDONLY | O_CLOEXEC);
1193 		if(fd &gt;= 0) {
1194 			act-&gt;pStrm-&gt;iCurrOffs = lseek64(fd, 0, SEEK_END);
1195 			close(fd);
1196 			if(act-&gt;pStrm-&gt;iCurrOffs &lt; 0) {
1197 				act-&gt;pStrm-&gt;iCurrOffs = 0;
1198 				LogError(errno, RS_RET_ERR, "imfile: could not query current "
1199 					"file size for %s - 'freshStartTail' option will "
1200 					"be ignored, starting at begin of file", inst-&gt;pszFileName);
1201 			}
1202 			CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
1203 		}
1204 	}
1205 finalize_it:
1206 	RETiRet;
1207 }
1208 static rsRetVal
1209 openFile(act_obj_t *const act)
1210 {
1211 	DEFiRet;
1212 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1213 	CHKiRet_Hdlr(openFileWithStateFile(act)) {
1214 		CHKiRet(openFileWithoutStateFile(act));
1215 	}
1216 	DBGPRINTF("breopenOnTruncate %d for '%s'\n", inst-&gt;reopenOnTruncate, act-&gt;name);
1217 	CHKiRet(strm.SetbReopenOnTruncate(act-&gt;pStrm, inst-&gt;reopenOnTruncate));
1218 	strmSetReadTimeout(act-&gt;pStrm, inst-&gt;readTimeout);
1219 finalize_it:
1220 	RETiRet;
1221 }
1222 static void pollFileCancelCleanup(void *pArg)
1223 {
1224 	cstr_t **ppCStr = (cstr_t**) pArg;
1225 	if(*ppCStr != NULL)
1226 		rsCStrDestruct(ppCStr);
1227 }
1228 static rsRetVal ATTR_NONNULL()
1229 pollFileReal(act_obj_t *act, cstr_t **pCStr)
1230 {
1231 	int64 strtOffs;
1232 	DEFiRet;
1233 	int64_t startOffs = 0;
1234 	int nProcessed = 0;
1235 	regex_t *start_preg = NULL, *end_preg = NULL;
1236 	DBGPRINTF("pollFileReal enter, act %p, pStrm %p, name '%s'\n", act, act-&gt;pStrm, act-&gt;name);
1237 	DBGPRINTF("pollFileReal enter, edge %p\n", act-&gt;edge);
1238 	DBGPRINTF("pollFileReal enter, edge-&gt;instarr %p\n", act-&gt;edge-&gt;instarr);
1239 	instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1240 	if(act-&gt;pStrm == NULL) {
1241 		CHKiRet(openFile(act)); 	}
1242 	start_preg = (inst-&gt;startRegex == NULL) ? NULL : &amp;inst-&gt;start_preg;
1243 	end_preg = (inst-&gt;endRegex == NULL) ? NULL : &amp;inst-&gt;end_preg;
1244 	startOffs = act-&gt;pStrm-&gt;iCurrOffs;
1245 	while(glbl.GetGlobalInputTermState() == 0) {
1246 		if(inst-&gt;maxLinesAtOnce != 0 &amp;&amp; nProcessed &gt;= inst-&gt;maxLinesAtOnce)
1247 			break;
1248 		if((start_preg == NULL) &amp;&amp; (end_preg == NULL)) {
1249 			CHKiRet(strm.ReadLine(act-&gt;pStrm, pCStr, inst-&gt;readMode, inst-&gt;escapeLF, inst-&gt;escapeLFString,
1250 				inst-&gt;trimLineOverBytes, &amp;strtOffs));
1251 		} else {
1252 			CHKiRet(strmReadMultiLine(act-&gt;pStrm, pCStr, start_preg, end_preg,
1253 				inst-&gt;escapeLF, inst-&gt;escapeLFString, inst-&gt;discardTruncatedMsg,
1254 				inst-&gt;msgDiscardingError, &amp;strtOffs));
1255 		}
1256 		++nProcessed;
1257 		if(startOffs &lt; FILE_ID_SIZE &amp;&amp; act-&gt;pStrm-&gt;iCurrOffs &gt;= FILE_ID_SIZE) {
1258 			dbgprintf("initiating state file write as sufficient data is now present; file=%s\n",
1259 				act-&gt;name);
1260 			persistStrmState(act);
1261 			startOffs = act-&gt;pStrm-&gt;iCurrOffs; 		}
1262 		runModConf-&gt;bHadFileData = 1; 		CHKiRet(enqLine(act, *pCStr, strtOffs)); 		rsCStrDestruct(pCStr); 		if(inst-&gt;iPersistStateInterval &gt; 0 &amp;&amp; ++act-&gt;nRecords &gt;= inst-&gt;iPersistStateInterval) {
1263 			persistStrmState(act);
1264 			act-&gt;nRecords = 0;
1265 		}
1266 	}
1267 finalize_it:
1268 	multiSubmitFlush(&amp;act-&gt;multiSub);
1269 	if(inst-&gt;bPersistStateAfterSubmission) {
1270 		persistStrmState(act);
1271 	}
1272 	if(*pCStr != NULL) {
1273 		rsCStrDestruct(pCStr);
1274 	}
1275 	RETiRet;
1276 }
1277 static rsRetVal ATTR_NONNULL(1)
1278 pollFile(act_obj_t *const act)
1279 {
1280 	cstr_t *pCStr = NULL;
1281 	DEFiRet;
1282 	if (act-&gt;is_symlink) {
1283 		FINALIZE;    	}
1284 	pthread_cleanup_push(pollFileCancelCleanup, &amp;pCStr);
1285 	iRet = pollFileReal(act, &amp;pCStr);
1286 	pthread_cleanup_pop(0);
1287 finalize_it: RETiRet;
1288 }
1289 static rsRetVal ATTR_NONNULL(1)
1290 createInstance(instanceConf_t **const pinst)
1291 {
1292 	instanceConf_t *inst;
1293 	DEFiRet;
1294 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
1295 	inst-&gt;next = NULL;
1296 	inst-&gt;pBindRuleset = NULL;
1297 	inst-&gt;pszBindRuleset = NULL;
1298 <a name="4"></a>	inst-&gt;pszFileName = NULL;
1299 	inst-&gt;pszTag = NULL;
1300 	inst-&gt;pszStateFile = NULL;
1301 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	inst-&gt;nMultiSub = NUM_MULTISUB;
1302 	inst-&gt;iSeverity = 5;
1303 	inst-&gt;iFacility = 128;
1304 	inst-&gt;maxLinesAtOnce = 0;
1305 	inst-&gt;trimLineOverBytes = 0;
1306 	inst-&gt;iPersistStateInterval = 0;
1307 	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = 0;
1308 	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = 0;
1309 	inst-&gt;perMinuteRateLimits.rateLimitingMinute = 0;
1310 	inst-&gt;perMinuteRateLimits.linesThisMinute = 0;
1311 	inst-&gt;perMinuteRateLimits.bytesThisMinute = 0;
1312 	inst-&gt;bPersistStateAfterSubmission = 0;
1313 	inst-&gt;readMode = 0;
1314 	inst-&gt;startRegex = NULL;
1315 	inst-&gt;endRegex = NULL;
1316 	inst-&gt;discardTruncatedMsg = 0;
1317 	inst-&gt;msgDiscardingError = 1;
1318 	inst-&gt;bRMStateOnDel = 1;</b></font>
1319 	inst-&gt;escapeLF = 1;
1320 	inst-&gt;escapeLFString = NULL;
1321 	inst-&gt;reopenOnTruncate = 0;
1322 	inst-&gt;addMetadata = ADD_METADATA_UNSPECIFIED;
1323 	inst-&gt;addCeeTag = 0;
1324 	inst-&gt;freshStartTail = 0;
1325 	inst-&gt;fileNotFoundError = 1;
1326 	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
1327 	inst-&gt;delay_perMsg = 0;
1328 	inst-&gt;msgFlag = 0;
1329 	inst-&gt;ignoreOlderThan = 0;
1330 	if(loadModConf-&gt;tail == NULL) {
1331 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
1332 	} else {
1333 		loadModConf-&gt;tail-&gt;next = inst;
1334 		loadModConf-&gt;tail = inst;
1335 	}
1336 	*pinst = inst;
1337 finalize_it:
1338 	RETiRet;
1339 }
1340 static int ATTR_NONNULL()
1341 getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path)
1342 {
1343 	int i;
1344 	int found = 0;
1345 	const int lenName = ustrlen(path);
1346 	for(i = lenName ; i &gt;= 0 ; --i) {
1347 		if(path[i] == '/') {
1348 			found = 1;
1349 			if(i == lenName)
1350 				basen[0] = '\0';
1351 			else {
1352 				memcpy(basen, path+i+1, lenName-i);
1353 			}
1354 			break;
1355 		}
1356 	}
1357 	if (found == 1)
1358 		return i;
1359 	else {
1360 		return -1;
1361 	}
1362 }
1363 static rsRetVal ATTR_NONNULL()
1364 checkInstance(instanceConf_t *const inst)
1365 {
1366 	uchar curr_wd[MAXFNAME];
1367 	DEFiRet;
1368 	if(inst-&gt;pszFileName == NULL)
1369 		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
1370 	CHKmalloc(inst-&gt;pszFileName_forOldStateFile = ustrdup(inst-&gt;pszFileName));
1371 	if(loadModConf-&gt;normalizePath) {
1372 		if(inst-&gt;pszFileName[0] == '.' &amp;&amp; inst-&gt;pszFileName[1] == '/') {
1373 			DBGPRINTF("imfile: removing heading './' from name '%s'\n", inst-&gt;pszFileName);
1374 			memmove(inst-&gt;pszFileName, inst-&gt;pszFileName+2, ustrlen(inst-&gt;pszFileName) - 1);
1375 		}
1376 		if(inst-&gt;pszFileName[0] != '/') {
1377 			if(getcwd((char*)curr_wd, MAXFNAME) == NULL || curr_wd[0] != '/') {
1378 				LogError(errno, RS_RET_ERR, "imfile: error querying current working "
1379 					"directory - can not continue with %s", inst-&gt;pszFileName);
1380 				ABORT_FINALIZE(RS_RET_ERR);
1381 			}
1382 			const size_t len_curr_wd = ustrlen(curr_wd);
1383 			if(len_curr_wd + ustrlen(inst-&gt;pszFileName) + 1 &gt;= MAXFNAME) {
1384 				LogError(0, RS_RET_ERR, "imfile: length of configured file and current "
1385 					"working directory exceeds permitted size - ignoring %s",
1386 					inst-&gt;pszFileName);
1387 				ABORT_FINALIZE(RS_RET_ERR);
1388 			}
1389 			curr_wd[len_curr_wd] = '/';
1390 			strcpy((char*)curr_wd+len_curr_wd+1, (char*)inst-&gt;pszFileName);
1391 			free(inst-&gt;pszFileName);
1392 			CHKmalloc(inst-&gt;pszFileName = ustrdup(curr_wd));
1393 		}
1394 	}
1395 	dbgprintf("imfile: adding file monitor for '%s'\n", inst-&gt;pszFileName);
1396 	if(inst-&gt;pszTag != NULL) {
1397 		inst-&gt;lenTag = ustrlen(inst-&gt;pszTag);
1398 	}
1399 finalize_it:
1400 	RETiRet;
1401 }
1402 static rsRetVal
1403 addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
1404 {
1405 	instanceConf_t *inst;
1406 	DEFiRet;
1407 	if(cs.pszFileName == NULL) {
1408 		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no file name given, file monitor can "
1409 					"not be created");
1410 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1411 	}
1412 	if(cs.pszFileTag == NULL) {
1413 		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no tag value given, file monitor can "
1414 					"not be created");
1415 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1416 	}
1417 	CHKiRet(createInstance(&amp;inst));
1418 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
1419 		inst-&gt;pszBindRuleset = NULL;
1420 	} else {
1421 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
1422 	}
1423 	CHKmalloc(inst-&gt;pszFileName = ustrdup((char*) cs.pszFileName));
1424 	CHKmalloc(inst-&gt;pszTag = ustrdup((char*) cs.pszFileTag));
1425 	if(cs.pszStateFile == NULL) {
1426 		inst-&gt;pszStateFile = NULL;
1427 	} else {
1428 		CHKmalloc(inst-&gt;pszStateFile = ustrdup(cs.pszStateFile));
1429 	}
1430 	inst-&gt;iSeverity = cs.iSeverity;
1431 	inst-&gt;iFacility = cs.iFacility;
1432 	if(cs.maxLinesAtOnce) {
1433 		if(loadModConf-&gt;opMode == OPMODE_INOTIFY) {
1434 			LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1435 				"parameter \"maxLinesAtOnce\" not "
1436 				"permited in inotify mode - ignored");
1437 		} else {
1438 			inst-&gt;maxLinesAtOnce = cs.maxLinesAtOnce;
1439 		}
1440 	}
1441 	inst-&gt;trimLineOverBytes = cs.trimLineOverBytes;
1442 	inst-&gt;ignoreOlderThan = 0;
1443 	inst-&gt;iPersistStateInterval = cs.iPersistStateInterval;
1444 	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = cs.maxBytesPerMinute;
1445 	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = cs.maxLinesPerMinute;
1446 	inst-&gt;bPersistStateAfterSubmission = 0;
1447 	inst-&gt;readMode = cs.readMode;
1448 	inst-&gt;escapeLF = 0;
1449 	inst-&gt;escapeLFString = NULL;
1450 	inst-&gt;reopenOnTruncate = 0;
1451 	inst-&gt;addMetadata = 0;
1452 	inst-&gt;addCeeTag = 0;
1453 	inst-&gt;bRMStateOnDel = 0;
1454 	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
1455 	inst-&gt;msgFlag = 0;
1456 	CHKiRet(checkInstance(inst));
1457 	cs.iPersistStateInterval = 0;
1458 	resetConfigVariables(NULL, NULL); 
1459 <a name="2"></a>finalize_it:
1460 	free(pNewVal); 	RETiRet;
1461 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1462 BEGINnewInpInst
1463 	struct cnfparamvals *pvals;
1464 	instanceConf_t *inst;
1465 	int i;
1466 CODESTARTnewInpInst
1467 	DBGPRINTF("newInpInst (imfile)\n");
1468 	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
1469 	if(pvals == NULL) {
1470 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1471 	}
1472 	if(Debug) {
1473 		DBGPRINTF("input param blk in imfile:\n");
1474 		cnfparamsPrint(&amp;inppblk, pvals);
1475 	}
1476 	CHKiRet(createInstance(&amp;inst));
1477 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
1478 		if(!pvals[i].bUsed)
1479 			continue;
1480 		if(!strcmp(inppblk.descr[i].name, "file")) {
1481 			inst-&gt;pszFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1482 <a name="5"></a>		} else if(!strcmp(inppblk.descr[i].name, "statefile")) {
1483 			inst-&gt;pszStateFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1484 		} else if(!strcmp(inppblk.descr[i].name, "removestateondelete")) {
1485 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			inst-&gt;bRMStateOnDel = (uint8_t) pvals[i].val.d.n; 		} else if(!strcmp(inppblk.descr[i].name, "tag")) {
1486 			inst-&gt;pszTag = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1487 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
1488 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1489 		} else if(!strcmp(inppblk.descr[i].name, "severity")) {
1490 			inst-&gt;iSeverity = pvals[i].val.d.n;</b></font>
1491 		} else if(!strcmp(inppblk.descr[i].name, "facility")) {
1492 			inst-&gt;iFacility = pvals[i].val.d.n;
1493 		} else if(!strcmp(inppblk.descr[i].name, "readmode")) {
1494 			inst-&gt;readMode = (sbool) pvals[i].val.d.n;
1495 		} else if(!strcmp(inppblk.descr[i].name, "startmsg.regex")) {
1496 			inst-&gt;startRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1497 		} else if(!strcmp(inppblk.descr[i].name, "endmsg.regex")) {
1498 			inst-&gt;endRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1499 		} else if(!strcmp(inppblk.descr[i].name, "discardtruncatedmsg")) {
1500 			inst-&gt;discardTruncatedMsg = (sbool) pvals[i].val.d.n;
1501 		} else if(!strcmp(inppblk.descr[i].name, "msgdiscardingerror")) {
1502 			inst-&gt;msgDiscardingError = (sbool) pvals[i].val.d.n;
1503 		} else if(!strcmp(inppblk.descr[i].name, "deletestateonfiledelete")) {
1504 			inst-&gt;bRMStateOnDel = (sbool) pvals[i].val.d.n; 		} else if(!strcmp(inppblk.descr[i].name, "addmetadata")) {
1505 			inst-&gt;addMetadata = (sbool) pvals[i].val.d.n;
1506 		} else if(!strcmp(inppblk.descr[i].name, "delay.message")) {
1507 			inst-&gt;delay_perMsg = (unsigned) pvals[i].val.d.n;
1508 		} else if (!strcmp(inppblk.descr[i].name, "addceetag")) {
1509 			inst-&gt;addCeeTag = (sbool) pvals[i].val.d.n;
1510 		} else if(!strcmp(inppblk.descr[i].name, "freshstarttail")) {
1511 			inst-&gt;freshStartTail = (sbool) pvals[i].val.d.n;
1512 		} else if(!strcmp(inppblk.descr[i].name, "filenotfounderror")) {
1513 			inst-&gt;fileNotFoundError = (sbool) pvals[i].val.d.n;
1514 		} else if(!strcmp(inppblk.descr[i].name, "escapelf")) {
1515 			inst-&gt;escapeLF = (sbool) pvals[i].val.d.n;
1516 		} else if(!strcmp(inppblk.descr[i].name, "escapelf.replacement")) {
1517 			inst-&gt;escapeLFString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1518 		} else if(!strcmp(inppblk.descr[i].name, "reopenontruncate")) {
1519 			inst-&gt;reopenOnTruncate = (sbool) pvals[i].val.d.n;
1520 		} else if(!strcmp(inppblk.descr[i].name, "maxlinesatonce")) {
1521 			if(   loadModConf-&gt;opMode == OPMODE_INOTIFY
1522 			   &amp;&amp; pvals[i].val.d.n &gt; 0) {
1523 				LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1524 					"parameter \"maxLinesAtOnce\" not "
1525 					"permited in inotify mode - ignored");
1526 <a name="1"></a>			} else {
1527 				inst-&gt;maxLinesAtOnce = pvals[i].val.d.n;
1528 			}
1529 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "trimlineoverbytes")) {
1530 			inst-&gt;trimLineOverBytes = pvals[i].val.d.n;
1531 		} else if(!strcmp(inppblk.descr[i].name, "ignoreolderthan")) {
1532 			inst-&gt;ignoreOlderThan = pvals[i].val.d.n;
1533 		} else if(!strcmp(inppblk.descr[i].name, "persiststateinterval")) {
1534 			inst-&gt;iPersistStateInterval = pvals[i].val.d.n;
1535 		} else if(!strcmp(inppblk.descr[i].name, "maxbytesperminute")) {
1536 			DBGPRINTF("imfile: enabling maxbytesperminute ratelimiting\n");
1537 			inst-&gt;perMinuteRateLimits.maxBytesPerMinute = pvals[i].val.d.n;
1538 		} else if(!strcmp(inppblk.descr[i].name, "maxlinesperminute")) {
1539 			DBGPRINTF("imfile: enabling maxlinesperminute ratelimiting\n");
1540 			inst-&gt;perMinuteRateLimits.maxLinesPerMinute = pvals[i].val.d.n;
1541 		} else if(!strcmp(inppblk.descr[i].name, "persiststateaftersubmission")) {
1542 			inst-&gt;bPersistStateAfterSubmission = pvals[i].val.d.n;</b></font>
1543 		} else if(!strcmp(inppblk.descr[i].name, "maxsubmitatonce")) {
1544 			inst-&gt;nMultiSub = pvals[i].val.d.n;
1545 		} else if(!strcmp(inppblk.descr[i].name, "readtimeout")) {
1546 			inst-&gt;readTimeout = pvals[i].val.d.n;
1547 		} else if(!strcmp(inppblk.descr[i].name, "needparse")) {
1548 			inst-&gt;msgFlag = pvals[i].val.d.n ? NEEDS_PARSING : 0;
1549 		} else {
1550 			DBGPRINTF("program error, non-handled "
1551 			  "param '%s'\n", inppblk.descr[i].name);
1552 		}
1553 	}
1554 	i = (inst-&gt;readMode &gt; 0) ? 1 : 0;
1555 	i = (NULL != inst-&gt;startRegex) ? (i+1) : i;
1556 	i = (NULL != inst-&gt;endRegex) ? (i+1) : i;
1557 	if(i &gt; 1) {
1558 		LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1559 			"only one of readMode or startmsg.regex or endmsg.regex can be set "
1560 			"at the same time");
1561 			ABORT_FINALIZE(RS_RET_PARAM_NOT_PERMITTED);
1562 	}
1563 	if(inst-&gt;startRegex != NULL) {
1564 		const int errcode = regcomp(&amp;inst-&gt;start_preg, (char*)inst-&gt;startRegex, REG_EXTENDED);
1565 		if(errcode != 0) {
1566 			char errbuff[512];
1567 			regerror(errcode, &amp;inst-&gt;start_preg, errbuff, sizeof(errbuff));
1568 			parser_errmsg("imfile: error in startmsg.regex expansion: %s", errbuff);
1569 			ABORT_FINALIZE(RS_RET_ERR);
1570 		}
1571 	}
1572 	if(inst-&gt;endRegex != NULL) {
1573 		const int errcode = regcomp(&amp;inst-&gt;end_preg, (char*)inst-&gt;endRegex, REG_EXTENDED);
1574 		if(errcode != 0) {
1575 			char errbuff[512];
1576 			regerror(errcode, &amp;inst-&gt;end_preg, errbuff, sizeof(errbuff));
1577 			parser_errmsg("imfile: error in endmsg.regex expansion: %s", errbuff);
1578 			ABORT_FINALIZE(RS_RET_ERR);
1579 <a name="6"></a>		}
1580 	}
1581 	if(inst-&gt;readTimeout != 0)
1582 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		loadModConf-&gt;haveReadTimeouts = 1;
1583 	iRet = checkInstance(inst);
1584 finalize_it:
1585 CODE_STD_FINALIZERnewInpInst
1586 	cnfparamvalsDestruct(pvals, &amp;inppblk);
1587 ENDnewInpInst
1588 BEGINbeginCnfLoad
1589 CODESTARTbeginCnfLoad
1590 	loadModConf = pModConf;
1591 	currModConf = pModConf;
1592 	pModConf-&gt;pConf = pConf;
1593 	loadModConf-&gt;opMode = OPMODE_POLLING;
1594 	loadModConf-&gt;iPollInterval = DFLT_PollInterval;
1595 	loadModConf-&gt;configSetViaV2Method = 0;
1596 	loadModConf-&gt;readTimeout = 0; 	loadModConf-&gt;timeoutGranularity = 1000; 	loadModConf-&gt;haveReadTimeouts = 0; 	loadModConf-&gt;normalizePath = 1;
1597 	loadModConf-&gt;sortFiles = GLOB_NOSORT;
1598 	loadModConf-&gt;stateFileDirectory = NULL;</b></font>
1599 	loadModConf-&gt;conf_tree = calloc(sizeof(fs_node_t), 1);
1600 	loadModConf-&gt;conf_tree-&gt;edges = NULL;
1601 	bLegacyCnfModGlobalsPermitted = 1;
1602 <a name="7"></a>		cs.pszFileName = NULL;
1603 	cs.pszFileTag = NULL;
1604 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	cs.pszStateFile = NULL;
1605 	cs.iPollInterval = DFLT_PollInterval;
1606 	cs.iPersistStateInterval = 0;
1607 	cs.iFacility = 128;
1608 	cs.iSeverity = 5;
1609 	cs.readMode = 0;
1610 	cs.maxLinesAtOnce = 10240;
1611 	cs.trimLineOverBytes = 0;
1612 ENDbeginCnfLoad
1613 BEGINsetModCnf
1614 	struct cnfparamvals *pvals = NULL;
1615 	int i;
1616 CODESTARTsetModCnf
1617 	#if defined(HAVE_PORT_SOURCE_FILE)
1618 		loadModConf-&gt;opMode = OPMODE_FEN;</b></font>
1619 	#elif defined(HAVE_INOTIFY_INIT)
1620 		loadModConf-&gt;opMode = OPMODE_INOTIFY;
1621 <a name="9"></a>	#else
1622 		loadModConf-&gt;opMode = OPMODE_POLLING;
1623 	#endif
1624 <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
1625 	if(pvals == NULL) {
1626 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imfile: error processing module "
1627 				"config parameters [module(...)]");
1628 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1629 	}
1630 	if(Debug) {
1631 		DBGPRINTF("module (global) param blk for imfile:\n");
1632 		cnfparamsPrint(&amp;modpblk, pvals);
1633 	}
1634 <a name="3"></a>	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
1635 		if(!pvals[i].bUsed)</b></font>
1636 			continue;
1637 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		if(!strcmp(modpblk.descr[i].name, "pollinginterval")) {
1638 			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
1639 		} else if(!strcmp(modpblk.descr[i].name, "readtimeout")) {
1640 			loadModConf-&gt;readTimeout = (int) pvals[i].val.d.n;
1641 		} else if(!strcmp(modpblk.descr[i].name, "timeoutgranularity")) {
1642 			loadModConf-&gt;timeoutGranularity = (int) pvals[i].val.d.n * 1000;
1643 		} else if(!strcmp(modpblk.descr[i].name, "sortfiles")) {
1644 			loadModConf-&gt;sortFiles = ((sbool) pvals[i].val.d.n) ? 0 : GLOB_NOSORT;</b></font>
1645 		} else if(!strcmp(modpblk.descr[i].name, "statefile.directory")) {
1646 			loadModConf-&gt;stateFileDirectory = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1647 		} else if(!strcmp(modpblk.descr[i].name, "normalizepath")) {
1648 			loadModConf-&gt;normalizePath = (sbool) pvals[i].val.d.n;
1649 		} else if(!strcmp(modpblk.descr[i].name, "mode")) {
1650 			if(!es_strconstcmp(pvals[i].val.d.estr, "polling"))
1651 				loadModConf-&gt;opMode = OPMODE_POLLING;
1652 			else if(!es_strconstcmp(pvals[i].val.d.estr, "inotify")) {
1653 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 				loadModConf-&gt;opMode = OPMODE_FEN;
1654 				DBGPRINTF("inotify mode configured, but only FEN "
1655 					"is available on OS SOLARIS. Switching to FEN "
1656 					"Mode automatically\n");
1657 #else
1658 				#if defined(HAVE_INOTIFY_INIT)
1659 					loadModConf-&gt;opMode = OPMODE_INOTIFY;
1660 				#else
1661 					loadModConf-&gt;opMode = OPMODE_POLLING;
1662 				#endif
1663 #endif
1664 			} else if(!es_strconstcmp(pvals[i].val.d.estr, "fen"))
1665 				loadModConf-&gt;opMode = OPMODE_FEN;
1666 			else {
1667 				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
1668 				LogError(0, RS_RET_PARAM_ERROR, "imfile: unknown "
1669 					"mode '%s'", cstr);
1670 				free(cstr);
1671 			}
1672 		} else {
1673 			DBGPRINTF("program error, non-handled "
1674 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
1675 		}
1676 	}
1677 	bLegacyCnfModGlobalsPermitted = 0;
1678 	loadModConf-&gt;configSetViaV2Method = 1;
1679 finalize_it:
1680 	if(pvals != NULL)
1681 		cnfparamvalsDestruct(pvals, &amp;modpblk);
1682 ENDsetModCnf
1683 BEGINendCnfLoad
1684 CODESTARTendCnfLoad
1685 	if(!loadModConf-&gt;configSetViaV2Method) {
1686 		loadModConf-&gt;iPollInterval = cs.iPollInterval;
1687 	}
1688 	DBGPRINTF("opmode is %d, polling interval is %d\n",
1689 		  loadModConf-&gt;opMode,
1690 		  loadModConf-&gt;iPollInterval);
1691 	loadModConf = NULL; 	free(cs.pszFileName);
1692 	free(cs.pszFileTag);
1693 	free(cs.pszStateFile);
1694 ENDendCnfLoad
1695 BEGINcheckCnf
1696 	instanceConf_t *inst;
1697 CODESTARTcheckCnf
1698 	if(getStateFileDir() == NULL) {
1699 		LogError(0, RS_RET_NO_WRKDIR_SET,
1700 			"imfile: no working or state file directory set, imfile will create "
1701 			"state files in the current working directory (probably "
1702 			"the root dir). Use global(workDirectory=\"/some/path\") "
1703 			"to set the working directory");
1704 	}
1705 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1706 		std_checkRuleset(pModConf, inst);
1707 	}
1708 	if(pModConf-&gt;root == NULL) {
1709 		LogError(0, RS_RET_NO_LISTNERS,
1710 				"imfile: no files configured to be monitored - "
1711 				"no input will be gathered");
1712 		iRet = RS_RET_NO_LISTNERS;
1713 	}
1714 ENDcheckCnf
1715 BEGINactivateCnf
1716 	instanceConf_t *inst;
1717 CODESTARTactivateCnf
1718 	runModConf = pModConf;
1719 	currModConf = pModConf;
1720 	if(runModConf-&gt;root == NULL) {
1721 		LogError(0, NO_ERRCODE, "imfile: no file monitors configured, "
1722 				"input not activated.\n");
1723 		ABORT_FINALIZE(RS_RET_NO_RUN);
1724 	}
1725 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1726 		if(!containsGlobWildcard((char*)inst-&gt;pszFileName)) {
1727 			if(access((char*)inst-&gt;pszFileName, R_OK) != 0) {
1728 				LogError(errno, RS_RET_ERR,
1729 					"imfile: on startup file '%s' does not exist "
1730 					"but is configured in static file monitor - this "
1731 					"may indicate a misconfiguration. If the file "
1732 					"appears at a later time, it will automatically "
1733 					"be processed. Reason", inst-&gt;pszFileName);
1734 			}
1735 		}
1736 		fs_node_add(runModConf-&gt;conf_tree, NULL, inst-&gt;pszFileName, 0, inst);
1737 	}
1738 	if(Debug) {
1739 		fs_node_print(runModConf-&gt;conf_tree, 0);
1740 	}
1741 finalize_it:
1742 ENDactivateCnf
1743 BEGINfreeCnf
1744 	instanceConf_t *inst, *del;
1745 CODESTARTfreeCnf
1746 	fs_node_destroy(pModConf-&gt;conf_tree);
1747 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
1748 		free(inst-&gt;pszBindRuleset);
1749 		free(inst-&gt;pszFileName);
1750 		free(inst-&gt;pszTag);
1751 		free(inst-&gt;pszStateFile);
1752 		free(inst-&gt;pszFileName_forOldStateFile);
1753 		if(inst-&gt;startRegex != NULL) {
1754 			regfree(&amp;inst-&gt;start_preg);
1755 			free(inst-&gt;startRegex);
1756 		}
1757 		if(inst-&gt;endRegex != NULL) {
1758 			regfree(&amp;inst-&gt;end_preg);
1759 			free(inst-&gt;endRegex);
1760 		}
1761 		del = inst;
1762 		inst = inst-&gt;next;
1763 		free(del);
1764 	}
1765 ENDfreeCnf
1766 static void
1767 do_initial_poll_run(void)
1768 {
1769 	fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
1770 	for(instanceConf_t *inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1771 		inst-&gt;freshStartTail = 0;
1772 	}
1773 }
1774 static rsRetVal
1775 doPolling(void)
1776 {
1777 	DEFiRet;
1778 	do_initial_poll_run();
1779 	while(glbl.GetGlobalInputTermState() == 0) {
1780 		DBGPRINTF("doPolling: new poll run\n");
1781 		do {
1782 			runModConf-&gt;bHadFileData = 0;
1783 			fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
1784 			DBGPRINTF("doPolling: end poll walk, hadData %d\n", runModConf-&gt;bHadFileData);
1785 		} while(runModConf-&gt;bHadFileData); 
1786 		DBGPRINTF("doPolling: poll going to sleep\n");
1787 		if(glbl.GetGlobalInputTermState() == 0)
1788 			srSleep(runModConf-&gt;iPollInterval, 10);
1789 	}
1790 	RETiRet;
1791 }
1792 #if defined(HAVE_INOTIFY_INIT)
1793 static void ATTR_NONNULL(1)
1794 in_dbg_showEv(const struct inotify_event *ev)
1795 {
1796 	if(!Debug)
1797 		return;
1798 	if(ev-&gt;mask &amp; IN_IGNORED) {
1799 		dbgprintf("INOTIFY event: watch was REMOVED\n");
1800 	}
1801 	if(ev-&gt;mask &amp; IN_MODIFY) {
1802 		dbgprintf("INOTIFY event: watch was MODIFID\n");
1803 	}
1804 	if(ev-&gt;mask &amp; IN_ACCESS) {
1805 		dbgprintf("INOTIFY event: watch IN_ACCESS\n");
1806 	}
1807 	if(ev-&gt;mask &amp; IN_ATTRIB) {
1808 		dbgprintf("INOTIFY event: watch IN_ATTRIB\n");
1809 	}
1810 	if(ev-&gt;mask &amp; IN_CLOSE_WRITE) {
1811 		dbgprintf("INOTIFY event: watch IN_CLOSE_WRITE\n");
1812 	}
1813 	if(ev-&gt;mask &amp; IN_CLOSE_NOWRITE) {
1814 		dbgprintf("INOTIFY event: watch IN_CLOSE_NOWRITE\n");
1815 	}
1816 	if(ev-&gt;mask &amp; IN_CREATE) {
1817 		dbgprintf("INOTIFY event: file was CREATED: %s\n", ev-&gt;name);
1818 	}
1819 	if(ev-&gt;mask &amp; IN_DELETE) {
1820 		dbgprintf("INOTIFY event: watch IN_DELETE\n");
1821 	}
1822 	if(ev-&gt;mask &amp; IN_DELETE_SELF) {
1823 		dbgprintf("INOTIFY event: watch IN_DELETE_SELF\n");
1824 	}
1825 	if(ev-&gt;mask &amp; IN_MOVE_SELF) {
1826 		dbgprintf("INOTIFY event: watch IN_MOVE_SELF\n");
1827 	}
1828 	if(ev-&gt;mask &amp; IN_MOVED_FROM) {
1829 		dbgprintf("INOTIFY event: watch IN_MOVED_FROM, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
1830 	}
1831 	if(ev-&gt;mask &amp; IN_MOVED_TO) {
1832 		dbgprintf("INOTIFY event: watch IN_MOVED_TO, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
1833 	}
1834 	if(ev-&gt;mask &amp; IN_OPEN) {
1835 		dbgprintf("INOTIFY event: watch IN_OPEN\n");
1836 	}
1837 	if(ev-&gt;mask &amp; IN_ISDIR) {
1838 		dbgprintf("INOTIFY event: watch IN_ISDIR\n");
1839 	}
1840 }
1841 static void ATTR_NONNULL(1, 2)
1842 in_handleFileEvent(struct inotify_event *ev, const wd_map_t *const etry)
1843 {
1844 	if(ev-&gt;mask &amp; IN_MODIFY) {
1845 		DBGPRINTF("fs_node_notify_file_update: act-&gt;name '%s'\n", etry-&gt;act-&gt;name);
1846 		pollFile(etry-&gt;act);
1847 	} else {
1848 		DBGPRINTF("got non-expected inotify event:\n");
1849 		in_dbg_showEv(ev);
1850 	}
1851 }
1852 static void
1853 flag_in_move(fs_edge_t *const edge, const char *name_moved)
1854 {
1855 	act_obj_t *act;
1856 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
1857 		DBGPRINTF("checking active object %s\n", act-&gt;basename);
1858 		if(!strcmp(act-&gt;basename, name_moved)){
1859 			DBGPRINTF("found file\n");
1860 			act-&gt;in_move = 1;
1861 			break;
1862 		} else {
1863 			DBGPRINTF("name check fails, '%s' != '%s'\n", act-&gt;basename, name_moved);
1864 		}
1865 	}
1866 	if (!act &amp;&amp; edge-&gt;next) {
1867 		flag_in_move(edge-&gt;next, name_moved);
1868 	}
1869 }
1870 static void ATTR_NONNULL(1)
1871 in_processEvent(struct inotify_event *ev)
1872 {
1873 	if(ev-&gt;mask &amp; IN_IGNORED) {
1874 		DBGPRINTF("imfile: got IN_IGNORED event\n");
1875 		goto done;
1876 	}
1877 	DBGPRINTF("in_processEvent process Event %x for %s\n", ev-&gt;mask, ev-&gt;name);
1878 	const wd_map_t *const etry =  wdmapLookup(ev-&gt;wd);
1879 	if(etry == NULL) {
1880 		LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING, "imfile: internal error? "
1881 			"inotify provided watch descriptor %d which we could not find "
1882 			"in our tables - ignored", ev-&gt;wd);
1883 		goto done;
1884 	}
1885 	DBGPRINTF("in_processEvent process Event %x is_file %d, act-&gt;name '%s'\n",
1886 		ev-&gt;mask, etry-&gt;act-&gt;edge-&gt;is_file, etry-&gt;act-&gt;name);
1887 	if((ev-&gt;mask &amp; IN_MOVED_FROM)) {
1888 		flag_in_move(etry-&gt;act-&gt;edge-&gt;node-&gt;edges, ev-&gt;name);
1889 	}
1890 	if(ev-&gt;mask &amp; (IN_MOVED_FROM | IN_MOVED_TO))  {
1891 		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
1892 	} else if(etry-&gt;act-&gt;edge-&gt;is_file &amp;&amp; !(etry-&gt;act-&gt;is_symlink)) {
1893 		in_handleFileEvent(ev, etry); 	} else {
1894 		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
1895 	}
1896 done:	return;
1897 }
1898 static rsRetVal
1899 do_inotify(void)
1900 {
1901 	char iobuf[8192];
1902 	int rd;
1903 	int currev;
1904 	static int last_timeout = 0;
1905 	struct pollfd pollfd;
1906 	DEFiRet;
1907 	CHKiRet(wdmapInit());
1908 	ino_fd = inotify_init1(IN_NONBLOCK);
1909 	if(ino_fd &lt; 0) {
1910 		LogError(errno, RS_RET_INOTIFY_INIT_FAILED, "imfile: Init inotify "
1911 			"instance failed ");
1912 		return RS_RET_INOTIFY_INIT_FAILED;
1913 	}
1914 	DBGPRINTF("inotify fd %d\n", ino_fd);
1915 	do_initial_poll_run();
1916 	while(glbl.GetGlobalInputTermState() == 0) {
1917 		int r;
1918 		pollfd.fd = ino_fd;
1919 		pollfd.events = POLLIN;
1920 		if (runModConf-&gt;haveReadTimeouts)
1921 			r = poll(&amp;pollfd, 1, runModConf-&gt;timeoutGranularity);
1922 		else
1923 			r = poll(&amp;pollfd, 1, -1);
1924 		if (r  == -1 &amp;&amp; errno == EINTR) {
1925 			DBGPRINTF("do_inotify interrupted while polling on ino_fd\n");
1926 			continue;
1927 		}
1928 		if(r == 0) {
1929 			DBGPRINTF("readTimeouts are configured, checking if some apply\n");
1930 			if (runModConf-&gt;haveReadTimeouts) {
1931 				fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
1932 				last_timeout = time(NULL);
1933 			}
1934 			continue;
1935 		} else if (r == -1) {
1936 			LogError(errno, RS_RET_INTERNAL_ERROR,
1937 					"%s:%d: unexpected error during poll timeout wait",
1938 					__FILE__, __LINE__);
1939 			continue;
1940 		} else if(r != 1) {
1941 			LogError(errno, RS_RET_INTERNAL_ERROR,
1942 					"%s:%d: ERROR: poll returned more fds (%d) than given to it (1)",
1943 					__FILE__, __LINE__, r);
1944 			continue;
1945 		}
1946 		else {
1947 			if(runModConf-&gt;haveReadTimeouts) {
1948 				int now = time(NULL);
1949 				if(last_timeout + (runModConf-&gt;timeoutGranularity / 1000) &gt; now) {
1950 					fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
1951 					last_timeout = time(NULL);
1952 				}
1953 			}
1954 			rd = read(ino_fd, iobuf, sizeof(iobuf));
1955 			if(rd == -1 &amp;&amp; errno == EINTR) {
1956 				DBGPRINTF("EINTR received during inotify, restarting poll\n");
1957 				continue;
1958 			}
1959 			if (rd == -1 &amp;&amp; errno == EWOULDBLOCK) {
1960 				continue;
1961 			}
1962 			if(rd &lt; 0) {
1963 				LogError(errno, RS_RET_IO_ERROR, "imfile: error during inotify - ignored");
1964 				continue;
1965 			}
1966 			currev = 0;
1967 			while(currev &lt; rd) {
1968 				union {
1969 					char *buf;
1970 					struct inotify_event *ev;
1971 				} savecast;
1972 				savecast.buf = iobuf+currev;
1973 				in_dbg_showEv(savecast.ev);
1974 				in_processEvent(savecast.ev);
1975 				currev += sizeof(struct inotify_event) + savecast.ev-&gt;len;
1976 			}
1977 		}
1978 	}
1979 finalize_it:
1980 	close(ino_fd);
1981 	RETiRet;
1982 }
1983 #else static rsRetVal
1984 do_inotify(void)
1985 {
1986 	LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: mode set to inotify, but the "
1987 			"platform does not support inotify");
1988 	return RS_RET_NOT_IMPLEMENTED;
1989 }
1990 #endif 
1991 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) static void
1992 fen_printevent(int event)
1993 {
1994 	if (event &amp; FILE_ACCESS) {
1995 		DBGPRINTF(" FILE_ACCESS");
1996 	}
1997 	if (event &amp; FILE_MODIFIED) {
1998 		DBGPRINTF(" FILE_MODIFIED");
1999 	}
2000 	if (event &amp; FILE_ATTRIB) {
2001 		DBGPRINTF(" FILE_ATTRIB");
2002 	}
2003 	if (event &amp; FILE_DELETE) {
2004 		DBGPRINTF(" FILE_DELETE");
2005 	}
2006 	if (event &amp; FILE_RENAME_TO) {
2007 		DBGPRINTF(" FILE_RENAME_TO");
2008 	}
2009 	if (event &amp; FILE_RENAME_FROM) {
2010 		DBGPRINTF(" FILE_RENAME_FROM");
2011 	}
2012 	if (event &amp; UNMOUNTED) {
2013 		DBGPRINTF(" UNMOUNTED");
2014 	}
2015 	if (event &amp; MOUNTEDOVER) {
2016 		DBGPRINTF(" MOUNTEDOVER");
2017 	}
2018 }
2019 static rsRetVal
2020 do_fen(void)
2021 {
2022 	port_event_t portEvent;
2023 	struct timespec timeout;
2024 	DEFiRet;
2025 	timeout.tv_sec = 300;
2026 	timeout.tv_nsec = 0;
2027 	if((glport = port_create()) == -1) {
2028 		LogError(errno, RS_RET_FEN_INIT_FAILED, "do_fen INIT Port failed ");
2029 		return RS_RET_FEN_INIT_FAILED;
2030 	}
2031 	do_initial_poll_run();
2032 	DBGPRINTF("do_fen ENTER monitoring loop \n");
2033 	while(glbl.GetGlobalInputTermState() == 0) {
2034 		DBGPRINTF("do_fen loop begin... \n");
2035 		while (!port_get(glport, &amp;portEvent, &amp;timeout)) { 			DBGPRINTF("do_fen: received port event with ");
2036 			fen_printevent((int) portEvent.portev_events);
2037 			DBGPRINTF("\n");
2038 			if(portEvent.portev_source != PORT_SOURCE_FILE) {
2039 				LogError(errno, RS_RET_SYS_ERR, "do_fen: Event from unexpected source "
2040 					": %d\n", portEvent.portev_source);
2041 				continue;
2042 			}
2043 			act_obj_t *const act = (act_obj_t*) portEvent.portev_user;
2044 			DBGPRINTF("do_fen event received: deleted %d, is_file %d, name '%s' foname '%s'\n",
2045 				act-&gt;is_deleted, act-&gt;edge-&gt;is_file, act-&gt;name,
2046 				((struct file_obj*)portEvent.portev_object)-&gt;fo_name);
2047 			if(act-&gt;is_deleted) {
2048 				free(act-&gt;name);
2049 				free(act);
2050 				continue;
2051 			}
2052 			act-&gt;bPortAssociated = 0;
2053 			fen_setupWatch(act);
2054 			if(act-&gt;edge-&gt;is_file) {
2055 				pollFile(act);
2056 			} else {
2057 				fs_node_walk(act-&gt;edge-&gt;node, poll_tree);
2058 			}
2059 		}
2060 	}
2061 	close(glport);
2062 	RETiRet;
2063 }
2064 #else static rsRetVal
2065 do_fen(void)
2066 {
2067 	LogError(0, RS_RET_NOT_IMPLEMENTED, "do_fen: mode set to fen, but the "
2068 			"platform does not support fen");
2069 	return RS_RET_NOT_IMPLEMENTED;
2070 }
2071 #endif 
2072 BEGINrunInput
2073 CODESTARTrunInput
2074 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 	if(runModConf-&gt;opMode == OPMODE_INOTIFY) {
2075 		DBGPRINTF("auto-adjusting 'inotify' mode to 'fen' on Solaris\n");
2076 		runModConf-&gt;opMode = OPMODE_FEN;
2077 	}
2078 	#endif
2079 	DBGPRINTF("working in %s mode\n",
2080 		 (runModConf-&gt;opMode == OPMODE_POLLING) ? "polling" :
2081 			((runModConf-&gt;opMode == OPMODE_INOTIFY) ?"inotify" : "fen"));
2082 	if(runModConf-&gt;opMode == OPMODE_POLLING)
2083 		iRet = doPolling();
2084 	else if(runModConf-&gt;opMode == OPMODE_INOTIFY)
2085 		iRet = do_inotify();
2086 	else if(runModConf-&gt;opMode == OPMODE_FEN)
2087 		iRet = do_fen();
2088 	else {
2089 		LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: unknown mode %d set",
2090 			runModConf-&gt;opMode);
2091 		return RS_RET_NOT_IMPLEMENTED;
2092 	}
2093 	DBGPRINTF("terminating upon request of rsyslog core\n");
2094 ENDrunInput
2095 BEGINwillRun
2096 CODESTARTwillRun
2097 	CHKiRet(prop.Construct(&amp;pInputName));
2098 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imfile"), sizeof("imfile") - 1));
2099 	CHKiRet(prop.ConstructFinalize(pInputName));
2100 finalize_it:
2101 ENDwillRun
2102 static rsRetVal ATTR_NONNULL()
2103 atomicWriteStateFile(const char *fn, const char *content)
2104 {
2105 	DEFiRet;
2106 	const int fd = open(fn, O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_TRUNC, 0600);
2107 	if(fd &lt; 0) {
2108 		LogError(errno, RS_RET_IO_ERROR, "imfile: cannot open state file '%s' for "
2109 			"persisting file state - some data will probably be duplicated "
2110 			"on next startup", fn);
2111 		ABORT_FINALIZE(RS_RET_IO_ERROR);
2112 	}
2113 	const size_t toWrite = strlen(content);
2114 	const ssize_t w = write(fd, content, toWrite);
2115 	if(w != (ssize_t) toWrite) {
2116 		LogError(errno, RS_RET_IO_ERROR, "imfile: partial write to state file '%s' "
2117 			"this may cause trouble in the future. We will try to delete the "
2118 			"state file, as this provides most consistent state", fn);
2119 		unlink(fn);
2120 		ABORT_FINALIZE(RS_RET_IO_ERROR);
2121 	}
2122 finalize_it:
2123 	if(fd &gt;= 0) {
2124 		close(fd);
2125 	}
2126 	RETiRet;
2127 }
2128 static void
2129 removeOldStatefile(const uchar *statefn, const char *hashToDelete)
2130 {
2131 	int ret;
2132 	uchar statefname[MAXFNAME];
2133 	getFullStateFileName(statefn, hashToDelete, statefname, sizeof(statefname));
2134 	DBGPRINTF("removing old state file: '%s'\n", statefname);
2135 	ret = unlink((const char*)statefname);
2136 	if(ret != 0) {
2137 		if (errno != ENOENT) {
2138 			LogError(errno, RS_RET_IO_ERROR,
2139 				"imfile error trying to delete old state file: '%s' - ignoring this "
2140 				"error, usually this means a file no longer file is left over, but "
2141 				"this may also cause some real trouble. Still the best we can do ",
2142 				statefname);
2143 		} else {
2144 			DBGPRINTF("trying to delete no longer valid statefile '%s' which no "
2145 					  "longer exists (probably already deleted)\n", statefname);
2146 		}
2147 	}
2148 }
2149 static rsRetVal ATTR_NONNULL()
2150 persistStrmState(act_obj_t *const act)
2151 {
2152 	DEFiRet;
2153 	uchar statefile[MAXFNAME];
2154 	uchar statefname[MAXFNAME];
2155 	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
2156 	getFileID(act);
2157 	getFullStateFileName(statefn, act-&gt;file_id, statefname, sizeof(statefname));
2158 	DBGPRINTF("persisting state for '%s', state file '%s'\n", act-&gt;name, statefname);
2159 	struct json_object *jval = NULL;
2160 	struct json_object *json = NULL;
2161 	CHKmalloc(json = json_object_new_object());
2162 	jval = json_object_new_string((char*) act-&gt;name);
2163 	json_object_object_add(json, "filename", jval);
2164 	jval = json_object_new_int(strmGetPrevWasNL(act-&gt;pStrm));
2165 	json_object_object_add(json, "prev_was_nl", jval);
2166 	jval = json_object_new_int64(act-&gt;pStrm-&gt;iCurrOffs);
2167 	json_object_object_add(json, "curr_offs", jval);
2168 	jval = json_object_new_int64(act-&gt;pStrm-&gt;strtOffs);
2169 	json_object_object_add(json, "strt_offs", jval);
2170 	const uchar *const prevLineSegment = strmGetPrevLineSegment(act-&gt;pStrm);
2171 	if(prevLineSegment != NULL) {
2172 		jval = json_object_new_string((const char*) prevLineSegment);
2173 		json_object_object_add(json, "prev_line_segment", jval);
2174 	}
2175 	const uchar *const prevMsgSegment = strmGetPrevMsgSegment(act-&gt;pStrm);
2176 	if(prevMsgSegment != NULL) {
2177 		jval = json_object_new_string((const char*) prevMsgSegment);
2178 		json_object_object_add(json, "prev_msg_segment", jval);
2179 	}
2180 	const char *jstr =  json_object_to_json_string_ext(json, JSON_C_TO_STRING_SPACED);
2181 	CHKiRet(atomicWriteStateFile((const char*)statefname, jstr));
2182 	json_object_put(json);
2183 	if (strncmp((const char *)act-&gt;file_id_prev, (const char *)act-&gt;file_id, FILE_ID_HASH_SIZE)) {
2184 		removeOldStatefile(statefn, act-&gt;file_id_prev);
2185 	}
2186 finalize_it:
2187 	if(iRet != RS_RET_OK) {
2188 		LogError(0, iRet, "imfile: could not persist state "
2189 				"file %s - data may be repeated on next "
2190 				"startup. Is WorkDirectory set?",
2191 				statefname);
2192 	}
2193 	RETiRet;
2194 }
2195 BEGINafterRun
2196 CODESTARTafterRun
2197 	if(pInputName != NULL)
2198 		prop.Destruct(&amp;pInputName);
2199 ENDafterRun
2200 BEGINisCompatibleWithFeature
2201 CODESTARTisCompatibleWithFeature
2202 	if(eFeat == sFEATURENonCancelInputTermination)
2203 		iRet = RS_RET_OK;
2204 ENDisCompatibleWithFeature
2205 BEGINmodExit
2206 CODESTARTmodExit
2207 	objRelease(strm, CORE_COMPONENT);
2208 	objRelease(glbl, CORE_COMPONENT);
2209 	objRelease(prop, CORE_COMPONENT);
2210 	objRelease(ruleset, CORE_COMPONENT);
2211 	objRelease(datetime, CORE_COMPONENT);
2212 	#ifdef HAVE_INOTIFY_INIT
2213 	free(wdmap);
2214 	#endif
2215 ENDmodExit
2216 BEGINqueryEtryPt
2217 CODESTARTqueryEtryPt
2218 CODEqueryEtryPt_STD_IMOD_QUERIES
2219 CODEqueryEtryPt_STD_CONF2_QUERIES
2220 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
2221 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
2222 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
2223 ENDqueryEtryPt
2224 static rsRetVal
2225 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
2226 {
2227 	DEFiRet;
2228 	free(cs.pszFileName);
2229 	cs.pszFileName = NULL;
2230 	free(cs.pszFileTag);
2231 	cs.pszFileTag = NULL;
2232 	free(cs.pszStateFile);
2233 	cs.pszStateFile = NULL;
2234 	cs.iPollInterval = DFLT_PollInterval;
2235 	cs.iFacility = 128; 	cs.iSeverity = 5;  	cs.readMode = 0;
2236 	cs.maxLinesAtOnce = 10240;
2237 	cs.trimLineOverBytes = 0;
2238 	RETiRet;
2239 }
2240 static inline void
2241 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
2242 {
2243 	LogError(0, NO_ERRCODE, "imfile: ruleset '%s' for %s not found - "
2244 			"using default ruleset instead", inst-&gt;pszBindRuleset,
2245 			inst-&gt;pszFileName);
2246 }
2247 BEGINmodInit()
2248 CODESTARTmodInit
2249 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
2250 	CHKiRet(objUse(glbl, CORE_COMPONENT));
2251 	CHKiRet(objUse(strm, CORE_COMPONENT));
2252 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
2253 	CHKiRet(objUse(prop, CORE_COMPONENT));
2254 	CHKiRet(objUse(datetime, CORE_COMPONENT));
2255 <a name="8"></a>
2256 	DBGPRINTF("version %s initializing\n", VERSION);
2257 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilename", 0, eCmdHdlrGetWord,
2258 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	  	NULL, &amp;cs.pszFileName, STD_LOADABLE_MODULE_ID));
2259 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletag", 0, eCmdHdlrGetWord,
2260 	  	NULL, &amp;cs.pszFileTag, STD_LOADABLE_MODULE_ID));
2261 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilestatefile", 0, eCmdHdlrGetWord,
2262 	  	NULL, &amp;cs.pszStateFile, STD_LOADABLE_MODULE_ID));
2263 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfileseverity", 0, eCmdHdlrSeverity,
2264 	  	NULL, &amp;cs.iSeverity, STD_LOADABLE_MODULE_ID));
2265 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilefacility", 0, eCmdHdlrFacility,
2266 	  	NULL, &amp;cs.iFacility, STD_LOADABLE_MODULE_ID));
2267 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilereadmode", 0, eCmdHdlrInt,
2268 	  	NULL, &amp;cs.readMode, STD_LOADABLE_MODULE_ID));
2269 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilemaxlinesatonce", 0, eCmdHdlrSize,
2270 	  	NULL, &amp;cs.maxLinesAtOnce, STD_LOADABLE_MODULE_ID));
2271 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletrimlineoverbytes", 0, eCmdHdlrSize,
2272 	  	NULL, &amp;cs.trimLineOverBytes, STD_LOADABLE_MODULE_ID));
2273 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilepersiststateinterval", 0, eCmdHdlrInt,
2274 	  	NULL, &amp;cs.iPersistStateInterval, STD_LOADABLE_MODULE_ID));
2275 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilebindruleset", 0, eCmdHdlrGetWord,
2276 		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
2277 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputrunfilemonitor", 0, eCmdHdlrGetWord,
2278 		addInstance, NULL, STD_LOADABLE_MODULE_ID));
2279 	CHKiRet(regCfSysLineHdlr2((uchar *)"inputfilepollinterval", 0, eCmdHdlrInt,
2280 	  	NULL, &amp;cs.iPollInterval, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
2281 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
2282 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));</b></font>
2283 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
