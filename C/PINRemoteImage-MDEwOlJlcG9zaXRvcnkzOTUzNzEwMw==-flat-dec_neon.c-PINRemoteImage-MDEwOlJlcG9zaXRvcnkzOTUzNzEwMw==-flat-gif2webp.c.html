
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_neon.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_NEON)
3  #include "src/dsp/neon.h"
4  #include "src/dec/vp8i_dec.h"
5  #if !defined(WORK_AROUND_GCC)
6  static WEBP_INLINE uint8x8x4_t Load4x8_NEON(const uint8_t* const src,
7                                              int stride) {
8    const uint8x8_t zero = vdup_n_u8(0);
9    uint8x8x4_t out;
10    INIT_VECTOR4(out, zero, zero, zero, zero);
11    out = vld4_lane_u8(src + 0 * stride, out, 0);
12    out = vld4_lane_u8(src + 1 * stride, out, 1);
13    out = vld4_lane_u8(src + 2 * stride, out, 2);
14    out = vld4_lane_u8(src + 3 * stride, out, 3);
15    out = vld4_lane_u8(src + 4 * stride, out, 4);
16    out = vld4_lane_u8(src + 5 * stride, out, 5);
17    out = vld4_lane_u8(src + 6 * stride, out, 6);
18    out = vld4_lane_u8(src + 7 * stride, out, 7);
19    return out;
20  }
21  static WEBP_INLINE void Load4x16_NEON(const uint8_t* const src, int stride,
22                                        uint8x16_t* const p1,
23                                        uint8x16_t* const p0,
24                                        uint8x16_t* const q0,
25                                        uint8x16_t* const q1) {
26    const uint8x8x4_t row0 = Load4x8_NEON(src - 2 + 0 * stride, stride);
27    const uint8x8x4_t row8 = Load4x8_NEON(src - 2 + 8 * stride, stride);
28    *p1 = vcombine_u8(row0.val[0], row8.val[0]);
29    *p0 = vcombine_u8(row0.val[1], row8.val[1]);
30    *q0 = vcombine_u8(row0.val[2], row8.val[2]);
31    *q1 = vcombine_u8(row0.val[3], row8.val[3]);
32  }
33  #else  
34  #define LOADQ_LANE_32b(VALUE, LANE) do {                             \
35    (VALUE) = vld1q_lane_u32((const uint32_t*)src, (VALUE), (LANE));   \
36    src += stride;                                                     \
37  } while (0)
38  static WEBP_INLINE void Load4x16_NEON(const uint8_t* src, int stride,
39                                        uint8x16_t* const p1,
40                                        uint8x16_t* const p0,
41                                        uint8x16_t* const q0,
42                                        uint8x16_t* const q1) {
43    const uint32x4_t zero = vdupq_n_u32(0);
44    uint32x4x4_t in;
45    INIT_VECTOR4(in, zero, zero, zero, zero);
46    src -= 2;
47    LOADQ_LANE_32b(in.val[0], 0);
48    LOADQ_LANE_32b(in.val[1], 0);
49    LOADQ_LANE_32b(in.val[2], 0);
50    LOADQ_LANE_32b(in.val[3], 0);
51    LOADQ_LANE_32b(in.val[0], 1);
52    LOADQ_LANE_32b(in.val[1], 1);
53    LOADQ_LANE_32b(in.val[2], 1);
54    LOADQ_LANE_32b(in.val[3], 1);
55    LOADQ_LANE_32b(in.val[0], 2);
56    LOADQ_LANE_32b(in.val[1], 2);
57    LOADQ_LANE_32b(in.val[2], 2);
58    LOADQ_LANE_32b(in.val[3], 2);
59    LOADQ_LANE_32b(in.val[0], 3);
60    LOADQ_LANE_32b(in.val[1], 3);
61    LOADQ_LANE_32b(in.val[2], 3);
62    LOADQ_LANE_32b(in.val[3], 3);
63    {
64      const uint8x16x2_t row01 = vtrnq_u8(vreinterpretq_u8_u32(in.val[0]),
65                                          vreinterpretq_u8_u32(in.val[1]));
66      const uint8x16x2_t row23 = vtrnq_u8(vreinterpretq_u8_u32(in.val[2]),
67                                          vreinterpretq_u8_u32(in.val[3]));
68      const uint16x8x2_t row02 = vtrnq_u16(vreinterpretq_u16_u8(row01.val[0]),
69                                           vreinterpretq_u16_u8(row23.val[0]));
70      const uint16x8x2_t row13 = vtrnq_u16(vreinterpretq_u16_u8(row01.val[1]),
71                                           vreinterpretq_u16_u8(row23.val[1]));
72      *p1 = vreinterpretq_u8_u16(row02.val[0]);
73      *p0 = vreinterpretq_u8_u16(row13.val[0]);
74      *q0 = vreinterpretq_u8_u16(row02.val[1]);
75      *q1 = vreinterpretq_u8_u16(row13.val[1]);
76    }
77  }
78  #undef LOADQ_LANE_32b
79  #endif  
80  static WEBP_INLINE void Load8x16_NEON(
81      const uint8_t* const src, int stride,
82      uint8x16_t* const p3, uint8x16_t* const p2, uint8x16_t* const p1,
83      uint8x16_t* const p0, uint8x16_t* const q0, uint8x16_t* const q1,
84      uint8x16_t* const q2, uint8x16_t* const q3) {
85    Load4x16_NEON(src - 2, stride, p3, p2, p1, p0);
86    Load4x16_NEON(src + 2, stride, q0, q1, q2, q3);
87  }
88  static WEBP_INLINE void Load16x4_NEON(const uint8_t* const src, int stride,
89                                        uint8x16_t* const p1,
90                                        uint8x16_t* const p0,
91                                        uint8x16_t* const q0,
92                                        uint8x16_t* const q1) {
93    *p1 = vld1q_u8(src - 2 * stride);
94    *p0 = vld1q_u8(src - 1 * stride);
95    *q0 = vld1q_u8(src + 0 * stride);
96    *q1 = vld1q_u8(src + 1 * stride);
97  }
98  static WEBP_INLINE void Load16x8_NEON(
99      const uint8_t* const src, int stride,
100      uint8x16_t* const p3, uint8x16_t* const p2, uint8x16_t* const p1,
101      uint8x16_t* const p0, uint8x16_t* const q0, uint8x16_t* const q1,
102      uint8x16_t* const q2, uint8x16_t* const q3) {
103    Load16x4_NEON(src - 2  * stride, stride, p3, p2, p1, p0);
104    Load16x4_NEON(src + 2  * stride, stride, q0, q1, q2, q3);
105  }
106  static WEBP_INLINE void Load8x8x2_NEON(
107      const uint8_t* const u, const uint8_t* const v, int stride,
108      uint8x16_t* const p3, uint8x16_t* const p2, uint8x16_t* const p1,
109      uint8x16_t* const p0, uint8x16_t* const q0, uint8x16_t* const q1,
110      uint8x16_t* const q2, uint8x16_t* const q3) {
111    *p3 = vcombine_u8(vld1_u8(u - 4 * stride), vld1_u8(v - 4 * stride));
112    *p2 = vcombine_u8(vld1_u8(u - 3 * stride), vld1_u8(v - 3 * stride));
113    *p1 = vcombine_u8(vld1_u8(u - 2 * stride), vld1_u8(v - 2 * stride));
114    *p0 = vcombine_u8(vld1_u8(u - 1 * stride), vld1_u8(v - 1 * stride));
115    *q0 = vcombine_u8(vld1_u8(u + 0 * stride), vld1_u8(v + 0 * stride));
116    *q1 = vcombine_u8(vld1_u8(u + 1 * stride), vld1_u8(v + 1 * stride));
117    *q2 = vcombine_u8(vld1_u8(u + 2 * stride), vld1_u8(v + 2 * stride));
118    *q3 = vcombine_u8(vld1_u8(u + 3 * stride), vld1_u8(v + 3 * stride));
119  }
120  #if !defined(WORK_AROUND_GCC)
121  #define LOAD_UV_8(ROW) \
122    vcombine_u8(vld1_u8(u - 4 + (ROW) * stride), vld1_u8(v - 4 + (ROW) * stride))
123  static WEBP_INLINE void Load8x8x2T_NEON(
124      const uint8_t* const u, const uint8_t* const v, int stride,
125      uint8x16_t* const p3, uint8x16_t* const p2, uint8x16_t* const p1,
126      uint8x16_t* const p0, uint8x16_t* const q0, uint8x16_t* const q1,
127      uint8x16_t* const q2, uint8x16_t* const q3) {
128    const uint8x16_t row0 = LOAD_UV_8(0);
129    const uint8x16_t row1 = LOAD_UV_8(1);
130    const uint8x16_t row2 = LOAD_UV_8(2);
131    const uint8x16_t row3 = LOAD_UV_8(3);
132    const uint8x16_t row4 = LOAD_UV_8(4);
133    const uint8x16_t row5 = LOAD_UV_8(5);
134    const uint8x16_t row6 = LOAD_UV_8(6);
135    const uint8x16_t row7 = LOAD_UV_8(7);
136    const uint8x16x2_t row01 = vtrnq_u8(row0, row1);  
137    const uint8x16x2_t row23 = vtrnq_u8(row2, row3);  
138    const uint8x16x2_t row45 = vtrnq_u8(row4, row5);  
139    const uint8x16x2_t row67 = vtrnq_u8(row6, row7);  
140    const uint16x8x2_t row02 = vtrnq_u16(vreinterpretq_u16_u8(row01.val[0]),
141                                         vreinterpretq_u16_u8(row23.val[0]));
142    const uint16x8x2_t row13 = vtrnq_u16(vreinterpretq_u16_u8(row01.val[1]),
143                                         vreinterpretq_u16_u8(row23.val[1]));
144    const uint16x8x2_t row46 = vtrnq_u16(vreinterpretq_u16_u8(row45.val[0]),
145                                         vreinterpretq_u16_u8(row67.val[0]));
146    const uint16x8x2_t row57 = vtrnq_u16(vreinterpretq_u16_u8(row45.val[1]),
147                                         vreinterpretq_u16_u8(row67.val[1]));
148    const uint32x4x2_t row04 = vtrnq_u32(vreinterpretq_u32_u16(row02.val[0]),
149                                         vreinterpretq_u32_u16(row46.val[0]));
150    const uint32x4x2_t row26 = vtrnq_u32(vreinterpretq_u32_u16(row02.val[1]),
151                                         vreinterpretq_u32_u16(row46.val[1]));
152    const uint32x4x2_t row15 = vtrnq_u32(vreinterpretq_u32_u16(row13.val[0]),
153                                         vreinterpretq_u32_u16(row57.val[0]));
154    const uint32x4x2_t row37 = vtrnq_u32(vreinterpretq_u32_u16(row13.val[1]),
155                                         vreinterpretq_u32_u16(row57.val[1]));
156    *p3 = vreinterpretq_u8_u32(row04.val[0]);
157    *p2 = vreinterpretq_u8_u32(row15.val[0]);
158    *p1 = vreinterpretq_u8_u32(row26.val[0]);
159    *p0 = vreinterpretq_u8_u32(row37.val[0]);
160    *q0 = vreinterpretq_u8_u32(row04.val[1]);
161    *q1 = vreinterpretq_u8_u32(row15.val[1]);
162    *q2 = vreinterpretq_u8_u32(row26.val[1]);
163    *q3 = vreinterpretq_u8_u32(row37.val[1]);
164  }
165  #undef LOAD_UV_8
166  #endif  
167  static WEBP_INLINE void Store2x8_NEON(const uint8x8x2_t v,
168                                        uint8_t* const dst, int stride) {
169    vst2_lane_u8(dst + 0 * stride, v, 0);
170    vst2_lane_u8(dst + 1 * stride, v, 1);
171    vst2_lane_u8(dst + 2 * stride, v, 2);
172    vst2_lane_u8(dst + 3 * stride, v, 3);
173    vst2_lane_u8(dst + 4 * stride, v, 4);
174    vst2_lane_u8(dst + 5 * stride, v, 5);
175    vst2_lane_u8(dst + 6 * stride, v, 6);
176    vst2_lane_u8(dst + 7 * stride, v, 7);
177  }
178  static WEBP_INLINE void Store2x16_NEON(const uint8x16_t p0, const uint8x16_t q0,
179                                         uint8_t* const dst, int stride) {
180    uint8x8x2_t lo, hi;
181    lo.val[0] = vget_low_u8(p0);
182    lo.val[1] = vget_low_u8(q0);
183    hi.val[0] = vget_high_u8(p0);
184    hi.val[1] = vget_high_u8(q0);
185    Store2x8_NEON(lo, dst - 1 + 0 * stride, stride);
186    Store2x8_NEON(hi, dst - 1 + 8 * stride, stride);
187  }
188  #if !defined(WORK_AROUND_GCC)
189  static WEBP_INLINE void Store4x8_NEON(const uint8x8x4_t v,
190                                        uint8_t* const dst, int stride) {
191    vst4_lane_u8(dst + 0 * stride, v, 0);
192    vst4_lane_u8(dst + 1 * stride, v, 1);
193    vst4_lane_u8(dst + 2 * stride, v, 2);
194    vst4_lane_u8(dst + 3 * stride, v, 3);
195    vst4_lane_u8(dst + 4 * stride, v, 4);
196    vst4_lane_u8(dst + 5 * stride, v, 5);
197    vst4_lane_u8(dst + 6 * stride, v, 6);
198    vst4_lane_u8(dst + 7 * stride, v, 7);
199  }
200  static WEBP_INLINE void Store4x16_NEON(const uint8x16_t p1, const uint8x16_t p0,
201                                         const uint8x16_t q0, const uint8x16_t q1,
202                                         uint8_t* const dst, int stride) {
203    uint8x8x4_t lo, hi;
204    INIT_VECTOR4(lo,
205                 vget_low_u8(p1), vget_low_u8(p0),
206                 vget_low_u8(q0), vget_low_u8(q1));
207    INIT_VECTOR4(hi,
208                 vget_high_u8(p1), vget_high_u8(p0),
209                 vget_high_u8(q0), vget_high_u8(q1));
210    Store4x8_NEON(lo, dst - 2 + 0 * stride, stride);
211    Store4x8_NEON(hi, dst - 2 + 8 * stride, stride);
212  }
213  #endif  
214  static WEBP_INLINE void Store16x2_NEON(const uint8x16_t p0, const uint8x16_t q0,
215                                         uint8_t* const dst, int stride) {
216    vst1q_u8(dst - stride, p0);
217    vst1q_u8(dst, q0);
218  }
219  static WEBP_INLINE void Store16x4_NEON(const uint8x16_t p1, const uint8x16_t p0,
220                                         const uint8x16_t q0, const uint8x16_t q1,
221                                         uint8_t* const dst, int stride) {
222    Store16x2_NEON(p1, p0, dst - stride, stride);
223    Store16x2_NEON(q0, q1, dst + stride, stride);
224  }
225  static WEBP_INLINE void Store8x2x2_NEON(const uint8x16_t p0,
226                                          const uint8x16_t q0,
227                                          uint8_t* const u, uint8_t* const v,
228                                          int stride) {
229    vst1_u8(u - stride, vget_low_u8(p0));
230    vst1_u8(u,          vget_low_u8(q0));
231    vst1_u8(v - stride, vget_high_u8(p0));
232    vst1_u8(v,          vget_high_u8(q0));
233  }
234  static WEBP_INLINE void Store8x4x2_NEON(const uint8x16_t p1,
235                                          const uint8x16_t p0,
236                                          const uint8x16_t q0,
237                                          const uint8x16_t q1,
238                                          uint8_t* const u, uint8_t* const v,
239                                          int stride) {
240    Store8x2x2_NEON(p1, p0, u - stride, v - stride, stride);
241    Store8x2x2_NEON(q0, q1, u + stride, v + stride, stride);
242  }
243  #if !defined(WORK_AROUND_GCC)
244  #define STORE6_LANE(DST, VAL0, VAL1, LANE) do {   \
245    vst3_lane_u8((DST) - 3, (VAL0), (LANE));        \
246    vst3_lane_u8((DST) + 0, (VAL1), (LANE));        \
247    (DST) += stride;                                \
248  } while (0)
249  static WEBP_INLINE void Store6x8x2_NEON(
250      const uint8x16_t p2, const uint8x16_t p1, const uint8x16_t p0,
251      const uint8x16_t q0, const uint8x16_t q1, const uint8x16_t q2,
252      uint8_t* u, uint8_t* v, int stride) {
253    uint8x8x3_t u0, u1, v0, v1;
254    INIT_VECTOR3(u0, vget_low_u8(p2), vget_low_u8(p1), vget_low_u8(p0));
255    INIT_VECTOR3(u1, vget_low_u8(q0), vget_low_u8(q1), vget_low_u8(q2));
256    INIT_VECTOR3(v0, vget_high_u8(p2), vget_high_u8(p1), vget_high_u8(p0));
257    INIT_VECTOR3(v1, vget_high_u8(q0), vget_high_u8(q1), vget_high_u8(q2));
258    STORE6_LANE(u, u0, u1, 0);
259    STORE6_LANE(u, u0, u1, 1);
260    STORE6_LANE(u, u0, u1, 2);
261    STORE6_LANE(u, u0, u1, 3);
262    STORE6_LANE(u, u0, u1, 4);
263    STORE6_LANE(u, u0, u1, 5);
264    STORE6_LANE(u, u0, u1, 6);
265    STORE6_LANE(u, u0, u1, 7);
266    STORE6_LANE(v, v0, v1, 0);
267    STORE6_LANE(v, v0, v1, 1);
268    STORE6_LANE(v, v0, v1, 2);
269    STORE6_LANE(v, v0, v1, 3);
270    STORE6_LANE(v, v0, v1, 4);
271    STORE6_LANE(v, v0, v1, 5);
272    STORE6_LANE(v, v0, v1, 6);
273    STORE6_LANE(v, v0, v1, 7);
274  }
275  #undef STORE6_LANE
276  static WEBP_INLINE void Store4x8x2_NEON(const uint8x16_t p1,
277                                          const uint8x16_t p0,
278                                          const uint8x16_t q0,
279                                          const uint8x16_t q1,
280                                          uint8_t* const u, uint8_t* const v,
281                                          int stride) {
282    uint8x8x4_t u0, v0;
283    INIT_VECTOR4(u0,
284                 vget_low_u8(p1), vget_low_u8(p0),
285                 vget_low_u8(q0), vget_low_u8(q1));
286    INIT_VECTOR4(v0,
287                 vget_high_u8(p1), vget_high_u8(p0),
288                 vget_high_u8(q0), vget_high_u8(q1));
289    vst4_lane_u8(u - 2 + 0 * stride, u0, 0);
290    vst4_lane_u8(u - 2 + 1 * stride, u0, 1);
291    vst4_lane_u8(u - 2 + 2 * stride, u0, 2);
292    vst4_lane_u8(u - 2 + 3 * stride, u0, 3);
293    vst4_lane_u8(u - 2 + 4 * stride, u0, 4);
294    vst4_lane_u8(u - 2 + 5 * stride, u0, 5);
295    vst4_lane_u8(u - 2 + 6 * stride, u0, 6);
296    vst4_lane_u8(u - 2 + 7 * stride, u0, 7);
297    vst4_lane_u8(v - 2 + 0 * stride, v0, 0);
298    vst4_lane_u8(v - 2 + 1 * stride, v0, 1);
299    vst4_lane_u8(v - 2 + 2 * stride, v0, 2);
300    vst4_lane_u8(v - 2 + 3 * stride, v0, 3);
301    vst4_lane_u8(v - 2 + 4 * stride, v0, 4);
302    vst4_lane_u8(v - 2 + 5 * stride, v0, 5);
303    vst4_lane_u8(v - 2 + 6 * stride, v0, 6);
304    vst4_lane_u8(v - 2 + 7 * stride, v0, 7);
305  }
306  #endif  
307  static WEBP_INLINE int16x8_t ConvertU8ToS16_NEON(uint8x8_t v) {
308    return vreinterpretq_s16_u16(vmovl_u8(v));
309  }
310  static WEBP_INLINE void SaturateAndStore4x4_NEON(uint8_t* const dst,
311                                                   const int16x8_t dst01,
312                                                   const int16x8_t dst23) {
313    const uint8x8_t dst01_u8 = vqmovun_s16(dst01);
314    const uint8x8_t dst23_u8 = vqmovun_s16(dst23);
315    vst1_lane_u32((uint32_t*)(dst + 0 * BPS), vreinterpret_u32_u8(dst01_u8), 0);
316    vst1_lane_u32((uint32_t*)(dst + 1 * BPS), vreinterpret_u32_u8(dst01_u8), 1);
317    vst1_lane_u32((uint32_t*)(dst + 2 * BPS), vreinterpret_u32_u8(dst23_u8), 0);
318    vst1_lane_u32((uint32_t*)(dst + 3 * BPS), vreinterpret_u32_u8(dst23_u8), 1);
319  }
320  static WEBP_INLINE void Add4x4_NEON(const int16x8_t row01,
321                                      const int16x8_t row23,
322                                      uint8_t* const dst) {
323    uint32x2_t dst01 = vdup_n_u32(0);
324    uint32x2_t dst23 = vdup_n_u32(0);
325    dst01 = vld1_lane_u32((uint32_t*)(dst + 0 * BPS), dst01, 0);
326    dst23 = vld1_lane_u32((uint32_t*)(dst + 2 * BPS), dst23, 0);
327    dst01 = vld1_lane_u32((uint32_t*)(dst + 1 * BPS), dst01, 1);
328    dst23 = vld1_lane_u32((uint32_t*)(dst + 3 * BPS), dst23, 1);
329    {
330      const int16x8_t dst01_s16 = ConvertU8ToS16_NEON(vreinterpret_u8_u32(dst01));
331      const int16x8_t dst23_s16 = ConvertU8ToS16_NEON(vreinterpret_u8_u32(dst23));
332      const int16x8_t out01 = vrsraq_n_s16(dst01_s16, row01, 3);
333      const int16x8_t out23 = vrsraq_n_s16(dst23_s16, row23, 3);
334      SaturateAndStore4x4_NEON(dst, out01, out23);
335    }
336  }
337  static uint8x16_t NeedsFilter_NEON(const uint8x16_t p1, const uint8x16_t p0,
338                                     const uint8x16_t q0, const uint8x16_t q1,
339                                     int thresh) {
340    const uint8x16_t thresh_v = vdupq_n_u8((uint8_t)thresh);
341    const uint8x16_t a_p0_q0 = vabdq_u8(p0, q0);               
342    const uint8x16_t a_p1_q1 = vabdq_u8(p1, q1);               
343    const uint8x16_t a_p0_q0_2 = vqaddq_u8(a_p0_q0, a_p0_q0);  
344    const uint8x16_t a_p1_q1_2 = vshrq_n_u8(a_p1_q1, 1);       
345    const uint8x16_t sum = vqaddq_u8(a_p0_q0_2, a_p1_q1_2);
346    const uint8x16_t mask = vcgeq_u8(thresh_v, sum);
347    return mask;
348  }
349  static int8x16_t FlipSign_NEON(const uint8x16_t v) {
350    const uint8x16_t sign_bit = vdupq_n_u8(0x80);
351    return vreinterpretq_s8_u8(veorq_u8(v, sign_bit));
352  }
353  static uint8x16_t FlipSignBack_NEON(const int8x16_t v) {
354    const int8x16_t sign_bit = vdupq_n_s8(0x80);
355    return vreinterpretq_u8_s8(veorq_s8(v, sign_bit));
356  }
357  static int8x16_t GetBaseDelta_NEON(const int8x16_t p1, const int8x16_t p0,
358                                     const int8x16_t q0, const int8x16_t q1) {
359    const int8x16_t q0_p0 = vqsubq_s8(q0, p0);      
360    const int8x16_t p1_q1 = vqsubq_s8(p1, q1);      
361    const int8x16_t s1 = vqaddq_s8(p1_q1, q0_p0);   
362    const int8x16_t s2 = vqaddq_s8(q0_p0, s1);      
363    const int8x16_t s3 = vqaddq_s8(q0_p0, s2);      
364    return s3;
365  }
366  static int8x16_t GetBaseDelta0_NEON(const int8x16_t p0, const int8x16_t q0) {
367    const int8x16_t q0_p0 = vqsubq_s8(q0, p0);      
368    const int8x16_t s1 = vqaddq_s8(q0_p0, q0_p0);   
369    const int8x16_t s2 = vqaddq_s8(q0_p0, s1);      
370    return s2;
371  }
372  static void ApplyFilter2NoFlip_NEON(const int8x16_t p0s, const int8x16_t q0s,
373                                      const int8x16_t delta,
374                                      int8x16_t* const op0,
375                                      int8x16_t* const oq0) {
376    const int8x16_t kCst3 = vdupq_n_s8(0x03);
377    const int8x16_t kCst4 = vdupq_n_s8(0x04);
378    const int8x16_t delta_p3 = vqaddq_s8(delta, kCst3);
379    const int8x16_t delta_p4 = vqaddq_s8(delta, kCst4);
380    const int8x16_t delta3 = vshrq_n_s8(delta_p3, 3);
381    const int8x16_t delta4 = vshrq_n_s8(delta_p4, 3);
382    *op0 = vqaddq_s8(p0s, delta3);
383    *oq0 = vqsubq_s8(q0s, delta4);
384  }
385  #if defined(WEBP_USE_INTRINSICS)
386  static void ApplyFilter2_NEON(const int8x16_t p0s, const int8x16_t q0s,
387                                const int8x16_t delta,
388                                uint8x16_t* const op0, uint8x16_t* const oq0) {
389    const int8x16_t kCst3 = vdupq_n_s8(0x03);
390    const int8x16_t kCst4 = vdupq_n_s8(0x04);
391    const int8x16_t delta_p3 = vqaddq_s8(delta, kCst3);
392    const int8x16_t delta_p4 = vqaddq_s8(delta, kCst4);
393    const int8x16_t delta3 = vshrq_n_s8(delta_p3, 3);
394    const int8x16_t delta4 = vshrq_n_s8(delta_p4, 3);
395    const int8x16_t sp0 = vqaddq_s8(p0s, delta3);
396    const int8x16_t sq0 = vqsubq_s8(q0s, delta4);
397    *op0 = FlipSignBack_NEON(sp0);
398    *oq0 = FlipSignBack_NEON(sq0);
399  }
400  static void DoFilter2_NEON(const uint8x16_t p1, const uint8x16_t p0,
401                             const uint8x16_t q0, const uint8x16_t q1,
402                             const uint8x16_t mask,
403                             uint8x16_t* const op0, uint8x16_t* const oq0) {
404    const int8x16_t p1s = FlipSign_NEON(p1);
405    const int8x16_t p0s = FlipSign_NEON(p0);
406    const int8x16_t q0s = FlipSign_NEON(q0);
407    const int8x16_t q1s = FlipSign_NEON(q1);
408    const int8x16_t delta0 = GetBaseDelta_NEON(p1s, p0s, q0s, q1s);
409    const int8x16_t delta1 = vandq_s8(delta0, vreinterpretq_s8_u8(mask));
410    ApplyFilter2_NEON(p0s, q0s, delta1, op0, oq0);
411  }
412  static void SimpleVFilter16_NEON(uint8_t* p, int stride, int thresh) {
413    uint8x16_t p1, p0, q0, q1, op0, oq0;
414    Load16x4_NEON(p, stride, &p1, &p0, &q0, &q1);
415    {
416      const uint8x16_t mask = NeedsFilter_NEON(p1, p0, q0, q1, thresh);
417      DoFilter2_NEON(p1, p0, q0, q1, mask, &op0, &oq0);
418    }
419    Store16x2_NEON(op0, oq0, p, stride);
420  }
421  static void SimpleHFilter16_NEON(uint8_t* p, int stride, int thresh) {
422    uint8x16_t p1, p0, q0, q1, oq0, op0;
423    Load4x16_NEON(p, stride, &p1, &p0, &q0, &q1);
424    {
425      const uint8x16_t mask = NeedsFilter_NEON(p1, p0, q0, q1, thresh);
426      DoFilter2_NEON(p1, p0, q0, q1, mask, &op0, &oq0);
427    }
428    Store2x16_NEON(op0, oq0, p, stride);
429  }
430  #else
431  #define LOAD8x4(c1, c2, c3, c4, b1, b2, stride)                                \
432    "vld4.8 {" #c1 "[0]," #c2 "[0]," #c3 "[0]," #c4 "[0]}," #b1 "," #stride "\n" \
433    "vld4.8 {" #c1 "[1]," #c2 "[1]," #c3 "[1]," #c4 "[1]}," #b2 "," #stride "\n" \
434    "vld4.8 {" #c1 "[2]," #c2 "[2]," #c3 "[2]," #c4 "[2]}," #b1 "," #stride "\n" \
435    "vld4.8 {" #c1 "[3]," #c2 "[3]," #c3 "[3]," #c4 "[3]}," #b2 "," #stride "\n" \
436    "vld4.8 {" #c1 "[4]," #c2 "[4]," #c3 "[4]," #c4 "[4]}," #b1 "," #stride "\n" \
437    "vld4.8 {" #c1 "[5]," #c2 "[5]," #c3 "[5]," #c4 "[5]}," #b2 "," #stride "\n" \
438    "vld4.8 {" #c1 "[6]," #c2 "[6]," #c3 "[6]," #c4 "[6]}," #b1 "," #stride "\n" \
439    "vld4.8 {" #c1 "[7]," #c2 "[7]," #c3 "[7]," #c4 "[7]}," #b2 "," #stride "\n"
440  #define STORE8x2(c1, c2, p, stride)                                            \
441    "vst2.8   {" #c1 "[0], " #c2 "[0]}," #p "," #stride " \n"                    \
442    "vst2.8   {" #c1 "[1], " #c2 "[1]}," #p "," #stride " \n"                    \
443    "vst2.8   {" #c1 "[2], " #c2 "[2]}," #p "," #stride " \n"                    \
444    "vst2.8   {" #c1 "[3], " #c2 "[3]}," #p "," #stride " \n"                    \
445    "vst2.8   {" #c1 "[4], " #c2 "[4]}," #p "," #stride " \n"                    \
446    "vst2.8   {" #c1 "[5], " #c2 "[5]}," #p "," #stride " \n"                    \
447    "vst2.8   {" #c1 "[6], " #c2 "[6]}," #p "," #stride " \n"                    \
448    "vst2.8   {" #c1 "[7], " #c2 "[7]}," #p "," #stride " \n"
449  #define QRegs "q0", "q1", "q2", "q3",                                          \
450                "q8", "q9", "q10", "q11", "q12", "q13", "q14", "q15"
451  #define FLIP_SIGN_BIT2(a, b, s)                                                \
452    "veor     " #a "," #a "," #s "               \n"                             \
453    "veor     " #b "," #b "," #s "               \n"                             \
454  
455  #define FLIP_SIGN_BIT4(a, b, c, d, s)                                          \
456    FLIP_SIGN_BIT2(a, b, s)                                                      \
457    FLIP_SIGN_BIT2(c, d, s)                                                      \
458  
459  #define NEEDS_FILTER(p1, p0, q0, q1, thresh, mask)                             \
460    "vabd.u8    q15," #p0 "," #q0 "         \n"  &bsol;* abs(p0 - q0) */              \
461    "vabd.u8    q14," #p1 "," #q1 "         \n"  &bsol;* abs(p1 - q1) */              \
462    "vqadd.u8   q15, q15, q15               \n"  &bsol;* abs(p0 - q0) * 2 */          \
463    "vshr.u8    q14, q14, #1                \n"  &bsol;* abs(p1 - q1) / 2 */          \
464    "vqadd.u8   q15, q15, q14     \n"  &bsol;* abs(p0 - q0) * 2 + abs(p1 - q1) / 2 */ \
465    "vdup.8     q14, " #thresh "            \n"                                  \
466    "vcge.u8   " #mask ", q14, q15          \n"  &bsol;* mask <= thresh */
467  #define GET_BASE_DELTA(p1, p0, q0, q1, o)                                      \
468    "vqsub.s8   q15," #q0 "," #p0 "         \n"  &bsol;* (q0 - p0) */                 \
469    "vqsub.s8  " #o "," #p1 "," #q1 "       \n"  &bsol;* (p1 - q1) */                 \
470    "vqadd.s8  " #o "," #o ", q15           \n"  &bsol;* (p1 - q1) + 1 * (p0 - q0) */ \
471    "vqadd.s8  " #o "," #o ", q15           \n"  &bsol;* (p1 - q1) + 2 * (p0 - q0) */ \
472    "vqadd.s8  " #o "," #o ", q15           \n"  &bsol;* (p1 - q1) + 3 * (p0 - q0) */
473  #define DO_SIMPLE_FILTER(p0, q0, fl)                                           \
474    "vmov.i8    q15, #0x03                  \n"                                  \
475    "vqadd.s8   q15, q15, " #fl "           \n"  &bsol;* filter1 = filter + 3 */      \
476    "vshr.s8    q15, q15, #3                \n"  &bsol;* filter1 >> 3 */              \
477    "vqadd.s8  " #p0 "," #p0 ", q15         \n"  &bsol;* p0 += filter1 */             \
478                                                                                 \
479    "vmov.i8    q15, #0x04                  \n"                                  \
480    "vqadd.s8   q15, q15, " #fl "           \n"  &bsol;* filter1 = filter + 4 */      \
481    "vshr.s8    q15, q15, #3                \n"  &bsol;* filter2 >> 3 */              \
482    "vqsub.s8  " #q0 "," #q0 ", q15         \n"  &bsol;* q0 -= filter2 */
483  #define DO_FILTER2(p1, p0, q0, q1, thresh)                                     \
484    NEEDS_FILTER(p1, p0, q0, q1, thresh, q9)     &bsol;* filter mask in q9 */         \
485    "vmov.i8    q10, #0x80                  \n"  &bsol;* sign bit */                  \
486    FLIP_SIGN_BIT4(p1, p0, q0, q1, q10)          &bsol;* convert to signed value */   \
487    GET_BASE_DELTA(p1, p0, q0, q1, q11)          &bsol;* get filter level  */         \
488    "vand       q9, q9, q11                 \n"  &bsol;* apply filter mask */         \
489    DO_SIMPLE_FILTER(p0, q0, q9)                 &bsol;* apply filter */              \
490    FLIP_SIGN_BIT2(p0, q0, q10)
491  static void SimpleVFilter16_NEON(uint8_t* p, int stride, int thresh) {
492    __asm__ volatile (
493      "sub        %[p], %[p], %[stride], lsl #1  \n"  
494      "vld1.u8    {q1}, [%[p]], %[stride]        \n"  
495      "vld1.u8    {q2}, [%[p]], %[stride]        \n"  
496      "vld1.u8    {q3}, [%[p]], %[stride]        \n"  
497      "vld1.u8    {q12}, [%[p]]                  \n"  
498      DO_FILTER2(q1, q2, q3, q12, %[thresh])
499      "sub        %[p], %[p], %[stride], lsl #1  \n"  
500      "vst1.u8    {q2}, [%[p]], %[stride]        \n"  
501      "vst1.u8    {q3}, [%[p]]                   \n"  
502      : [p] "+r"(p)
503      : [stride] "r"(stride), [thresh] "r"(thresh)
504      : "memory", QRegs
505    );
506  }
507  static void SimpleHFilter16_NEON(uint8_t* p, int stride, int thresh) {
508    __asm__ volatile (
509      "sub        r4, %[p], #2                   \n"  
510      "lsl        r6, %[stride], #1              \n"  
511      "add        r5, r4, %[stride]              \n"  
512      LOAD8x4(d2, d3, d4, d5, [r4], [r5], r6)
513      LOAD8x4(d24, d25, d26, d27, [r4], [r5], r6)
514      "vswp       d3, d24                        \n"  
515      "vswp       d5, d26                        \n"  
516      "vswp       q2, q12                        \n"  
517      DO_FILTER2(q1, q2, q12, q13, %[thresh])
518      "sub        %[p], %[p], #1                 \n"  
519      "vswp        d5, d24                       \n"
520      STORE8x2(d4, d5, [%[p]], %[stride])
521      STORE8x2(d24, d25, [%[p]], %[stride])
522      : [p] "+r"(p)
523      : [stride] "r"(stride), [thresh] "r"(thresh)
524      : "memory", "r4", "r5", "r6", QRegs
525    );
526  }
527  #undef LOAD8x4
528  #undef STORE8x2
529  #endif    
530  static void SimpleVFilter16i_NEON(uint8_t* p, int stride, int thresh) {
531    uint32_t k;
532    for (k = 3; k != 0; --k) {
533      p += 4 * stride;
534      SimpleVFilter16_NEON(p, stride, thresh);
535    }
536  }
537  static void SimpleHFilter16i_NEON(uint8_t* p, int stride, int thresh) {
538    uint32_t k;
539    for (k = 3; k != 0; --k) {
540      p += 4;
541      SimpleHFilter16_NEON(p, stride, thresh);
542    }
543  }
544  static uint8x16_t NeedsHev_NEON(const uint8x16_t p1, const uint8x16_t p0,
545                                  const uint8x16_t q0, const uint8x16_t q1,
546                                  int hev_thresh) {
547    const uint8x16_t hev_thresh_v = vdupq_n_u8((uint8_t)hev_thresh);
548    const uint8x16_t a_p1_p0 = vabdq_u8(p1, p0);  
549    const uint8x16_t a_q1_q0 = vabdq_u8(q1, q0);  
550    const uint8x16_t a_max = vmaxq_u8(a_p1_p0, a_q1_q0);
551    const uint8x16_t mask = vcgtq_u8(a_max, hev_thresh_v);
552    return mask;
553  }
554  static uint8x16_t NeedsFilter2_NEON(const uint8x16_t p3, const uint8x16_t p2,
555                                      const uint8x16_t p1, const uint8x16_t p0,
556                                      const uint8x16_t q0, const uint8x16_t q1,
557                                      const uint8x16_t q2, const uint8x16_t q3,
558                                      int ithresh, int thresh) {
559    const uint8x16_t ithresh_v = vdupq_n_u8((uint8_t)ithresh);
560    const uint8x16_t a_p3_p2 = vabdq_u8(p3, p2);  
561    const uint8x16_t a_p2_p1 = vabdq_u8(p2, p1);  
562    const uint8x16_t a_p1_p0 = vabdq_u8(p1, p0);  
563    const uint8x16_t a_q3_q2 = vabdq_u8(q3, q2);  
564    const uint8x16_t a_q2_q1 = vabdq_u8(q2, q1);  
565    const uint8x16_t a_q1_q0 = vabdq_u8(q1, q0);  
566    const uint8x16_t max1 = vmaxq_u8(a_p3_p2, a_p2_p1);
567    const uint8x16_t max2 = vmaxq_u8(a_p1_p0, a_q3_q2);
568    const uint8x16_t max3 = vmaxq_u8(a_q2_q1, a_q1_q0);
569    const uint8x16_t max12 = vmaxq_u8(max1, max2);
570    const uint8x16_t max123 = vmaxq_u8(max12, max3);
571    const uint8x16_t mask2 = vcgeq_u8(ithresh_v, max123);
572    const uint8x16_t mask1 = NeedsFilter_NEON(p1, p0, q0, q1, thresh);
573    const uint8x16_t mask = vandq_u8(mask1, mask2);
574    return mask;
575  }
576  static void ApplyFilter4_NEON(
577      const int8x16_t p1, const int8x16_t p0,
578      const int8x16_t q0, const int8x16_t q1,
579      const int8x16_t delta0,
580      uint8x16_t* const op1, uint8x16_t* const op0,
581      uint8x16_t* const oq0, uint8x16_t* const oq1) {
582    const int8x16_t kCst3 = vdupq_n_s8(0x03);
583    const int8x16_t kCst4 = vdupq_n_s8(0x04);
584    const int8x16_t delta1 = vqaddq_s8(delta0, kCst4);
585    const int8x16_t delta2 = vqaddq_s8(delta0, kCst3);
586    const int8x16_t a1 = vshrq_n_s8(delta1, 3);
587    const int8x16_t a2 = vshrq_n_s8(delta2, 3);
588    const int8x16_t a3 = vrshrq_n_s8(a1, 1);   
589    *op0 = FlipSignBack_NEON(vqaddq_s8(p0, a2));  
590    *oq0 = FlipSignBack_NEON(vqsubq_s8(q0, a1));  
591    *op1 = FlipSignBack_NEON(vqaddq_s8(p1, a3));  
592    *oq1 = FlipSignBack_NEON(vqsubq_s8(q1, a3));  
593  }
594  static void DoFilter4_NEON(
595      const uint8x16_t p1, const uint8x16_t p0,
596      const uint8x16_t q0, const uint8x16_t q1,
597      const uint8x16_t mask, const uint8x16_t hev_mask,
598      uint8x16_t* const op1, uint8x16_t* const op0,
599      uint8x16_t* const oq0, uint8x16_t* const oq1) {
600    const int8x16_t p1s = FlipSign_NEON(p1);
601    int8x16_t p0s = FlipSign_NEON(p0);
602    int8x16_t q0s = FlipSign_NEON(q0);
603    const int8x16_t q1s = FlipSign_NEON(q1);
604    const uint8x16_t simple_lf_mask = vandq_u8(mask, hev_mask);
605    {
606      const int8x16_t delta = GetBaseDelta_NEON(p1s, p0s, q0s, q1s);
607      const int8x16_t simple_lf_delta =
608          vandq_s8(delta, vreinterpretq_s8_u8(simple_lf_mask));
609      ApplyFilter2NoFlip_NEON(p0s, q0s, simple_lf_delta, &p0s, &q0s);
610    }
611    {
612      const int8x16_t delta0 = GetBaseDelta0_NEON(p0s, q0s);
613      const uint8x16_t complex_lf_mask = veorq_u8(simple_lf_mask, mask);
614      const int8x16_t complex_lf_delta =
615          vandq_s8(delta0, vreinterpretq_s8_u8(complex_lf_mask));
616      ApplyFilter4_NEON(p1s, p0s, q0s, q1s, complex_lf_delta, op1, op0, oq0, oq1);
617    }
618  }
619  static void ApplyFilter6_NEON(
620      const int8x16_t p2, const int8x16_t p1, const int8x16_t p0,
621      const int8x16_t q0, const int8x16_t q1, const int8x16_t q2,
622      const int8x16_t delta,
623      uint8x16_t* const op2, uint8x16_t* const op1, uint8x16_t* const op0,
624      uint8x16_t* const oq0, uint8x16_t* const oq1, uint8x16_t* const oq2) {
625    const int8x8_t delta_lo = vget_low_s8(delta);
626    const int8x8_t delta_hi = vget_high_s8(delta);
627    const int8x8_t kCst9 = vdup_n_s8(9);
628    const int16x8_t kCstm1 = vdupq_n_s16(-1);
629    const int8x8_t kCst18 = vdup_n_s8(18);
630    const int16x8_t S_lo = vmlal_s8(kCstm1, kCst9, delta_lo);  
631    const int16x8_t S_hi = vmlal_s8(kCstm1, kCst9, delta_hi);
632    const int16x8_t Z_lo = vmlal_s8(S_lo, kCst18, delta_lo);   
633    const int16x8_t Z_hi = vmlal_s8(S_hi, kCst18, delta_hi);
634    const int8x8_t a3_lo = vqrshrn_n_s16(S_lo, 7);   
635    const int8x8_t a3_hi = vqrshrn_n_s16(S_hi, 7);
636    const int8x8_t a2_lo = vqrshrn_n_s16(S_lo, 6);   
637    const int8x8_t a2_hi = vqrshrn_n_s16(S_hi, 6);
638    const int8x8_t a1_lo = vqrshrn_n_s16(Z_lo, 7);   
639    const int8x8_t a1_hi = vqrshrn_n_s16(Z_hi, 7);
640    const int8x16_t a1 = vcombine_s8(a1_lo, a1_hi);
641    const int8x16_t a2 = vcombine_s8(a2_lo, a2_hi);
642    const int8x16_t a3 = vcombine_s8(a3_lo, a3_hi);
643    *op0 = FlipSignBack_NEON(vqaddq_s8(p0, a1));  
644    *oq0 = FlipSignBack_NEON(vqsubq_s8(q0, a1));  
645    *oq1 = FlipSignBack_NEON(vqsubq_s8(q1, a2));  
646    *op1 = FlipSignBack_NEON(vqaddq_s8(p1, a2));  
647    *oq2 = FlipSignBack_NEON(vqsubq_s8(q2, a3));  
648    *op2 = FlipSignBack_NEON(vqaddq_s8(p2, a3));  
649  }
650  static void DoFilter6_NEON(
651      const uint8x16_t p2, const uint8x16_t p1, const uint8x16_t p0,
652      const uint8x16_t q0, const uint8x16_t q1, const uint8x16_t q2,
653      const uint8x16_t mask, const uint8x16_t hev_mask,
654      uint8x16_t* const op2, uint8x16_t* const op1, uint8x16_t* const op0,
655      uint8x16_t* const oq0, uint8x16_t* const oq1, uint8x16_t* const oq2) {
656    const int8x16_t p2s = FlipSign_NEON(p2);
657    const int8x16_t p1s = FlipSign_NEON(p1);
658    int8x16_t p0s = FlipSign_NEON(p0);
659    int8x16_t q0s = FlipSign_NEON(q0);
660    const int8x16_t q1s = FlipSign_NEON(q1);
661    const int8x16_t q2s = FlipSign_NEON(q2);
662    const uint8x16_t simple_lf_mask = vandq_u8(mask, hev_mask);
663    const int8x16_t delta0 = GetBaseDelta_NEON(p1s, p0s, q0s, q1s);
664    {
665      const int8x16_t simple_lf_delta =
666          vandq_s8(delta0, vreinterpretq_s8_u8(simple_lf_mask));
667      ApplyFilter2NoFlip_NEON(p0s, q0s, simple_lf_delta, &p0s, &q0s);
668    }
669    {
670      const uint8x16_t complex_lf_mask = veorq_u8(simple_lf_mask, mask);
671      const int8x16_t complex_lf_delta =
672          vandq_s8(delta0, vreinterpretq_s8_u8(complex_lf_mask));
673      ApplyFilter6_NEON(p2s, p1s, p0s, q0s, q1s, q2s, complex_lf_delta,
674                        op2, op1, op0, oq0, oq1, oq2);
675    }
676  }
677  static void VFilter16_NEON(uint8_t* p, int stride,
678                             int thresh, int ithresh, int hev_thresh) {
679    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
680    Load16x8_NEON(p, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
681    {
682      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
683                                                ithresh, thresh);
684      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
685      uint8x16_t op2, op1, op0, oq0, oq1, oq2;
686      DoFilter6_NEON(p2, p1, p0, q0, q1, q2, mask, hev_mask,
687                     &op2, &op1, &op0, &oq0, &oq1, &oq2);
688      Store16x2_NEON(op2, op1, p - 2 * stride, stride);
689      Store16x2_NEON(op0, oq0, p + 0 * stride, stride);
690      Store16x2_NEON(oq1, oq2, p + 2 * stride, stride);
691    }
692  }
693  static void HFilter16_NEON(uint8_t* p, int stride,
694                             int thresh, int ithresh, int hev_thresh) {
695    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
696    Load8x16_NEON(p, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
697    {
698      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
699                                                ithresh, thresh);
700      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
701      uint8x16_t op2, op1, op0, oq0, oq1, oq2;
702      DoFilter6_NEON(p2, p1, p0, q0, q1, q2, mask, hev_mask,
703                     &op2, &op1, &op0, &oq0, &oq1, &oq2);
704      Store2x16_NEON(op2, op1, p - 2, stride);
705      Store2x16_NEON(op0, oq0, p + 0, stride);
706      Store2x16_NEON(oq1, oq2, p + 2, stride);
707    }
708  }
709  static void VFilter16i_NEON(uint8_t* p, int stride,
710                              int thresh, int ithresh, int hev_thresh) {
711    uint32_t k;
712    uint8x16_t p3, p2, p1, p0;
713    Load16x4_NEON(p + 2  * stride, stride, &p3, &p2, &p1, &p0);
714    for (k = 3; k != 0; --k) {
715      uint8x16_t q0, q1, q2, q3;
716      p += 4 * stride;
717      Load16x4_NEON(p + 2  * stride, stride, &q0, &q1, &q2, &q3);
718      {
719        const uint8x16_t mask =
720            NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3, ithresh, thresh);
721        const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
722        DoFilter4_NEON(p1, p0, q0, q1, mask, hev_mask, &p1, &p0, &p3, &p2);
723        Store16x4_NEON(p1, p0, p3, p2, p, stride);
724        p1 = q2;
725        p0 = q3;
726      }
727    }
728  }
729  #if !defined(WORK_AROUND_GCC)
730  static void HFilter16i_NEON(uint8_t* p, int stride,
731                              int thresh, int ithresh, int hev_thresh) {
732    uint32_t k;
733    uint8x16_t p3, p2, p1, p0;
734    Load4x16_NEON(p + 2, stride, &p3, &p2, &p1, &p0);
735    for (k = 3; k != 0; --k) {
736      uint8x16_t q0, q1, q2, q3;
737      p += 4;
738      Load4x16_NEON(p + 2, stride, &q0, &q1, &q2, &q3);
739      {
740        const uint8x16_t mask =
741            NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3, ithresh, thresh);
742        const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
743        DoFilter4_NEON(p1, p0, q0, q1, mask, hev_mask, &p1, &p0, &p3, &p2);
744        Store4x16_NEON(p1, p0, p3, p2, p, stride);
745        p1 = q2;
746        p0 = q3;
747      }
748    }
749  }
750  #endif  
751  static void VFilter8_NEON(uint8_t* u, uint8_t* v, int stride,
752                            int thresh, int ithresh, int hev_thresh) {
753    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
754    Load8x8x2_NEON(u, v, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
755    {
756      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
757                                                ithresh, thresh);
758      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
759      uint8x16_t op2, op1, op0, oq0, oq1, oq2;
760      DoFilter6_NEON(p2, p1, p0, q0, q1, q2, mask, hev_mask,
761                     &op2, &op1, &op0, &oq0, &oq1, &oq2);
762      Store8x2x2_NEON(op2, op1, u - 2 * stride, v - 2 * stride, stride);
763      Store8x2x2_NEON(op0, oq0, u + 0 * stride, v + 0 * stride, stride);
764      Store8x2x2_NEON(oq1, oq2, u + 2 * stride, v + 2 * stride, stride);
765    }
766  }
767  static void VFilter8i_NEON(uint8_t* u, uint8_t* v, int stride,
768                             int thresh, int ithresh, int hev_thresh) {
769    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
770    u += 4 * stride;
771    v += 4 * stride;
772    Load8x8x2_NEON(u, v, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
773    {
774      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
775                                                ithresh, thresh);
776      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
777      uint8x16_t op1, op0, oq0, oq1;
778      DoFilter4_NEON(p1, p0, q0, q1, mask, hev_mask, &op1, &op0, &oq0, &oq1);
779      Store8x4x2_NEON(op1, op0, oq0, oq1, u, v, stride);
780    }
781  }
782  #if !defined(WORK_AROUND_GCC)
783  static void HFilter8_NEON(uint8_t* u, uint8_t* v, int stride,
784                            int thresh, int ithresh, int hev_thresh) {
785    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
786    Load8x8x2T_NEON(u, v, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
787    {
788      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
789                                                ithresh, thresh);
790      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
791      uint8x16_t op2, op1, op0, oq0, oq1, oq2;
792      DoFilter6_NEON(p2, p1, p0, q0, q1, q2, mask, hev_mask,
793                     &op2, &op1, &op0, &oq0, &oq1, &oq2);
794      Store6x8x2_NEON(op2, op1, op0, oq0, oq1, oq2, u, v, stride);
795    }
796  }
797  static void HFilter8i_NEON(uint8_t* u, uint8_t* v, int stride,
798                             int thresh, int ithresh, int hev_thresh) {
799    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
800    u += 4;
801    v += 4;
802    Load8x8x2T_NEON(u, v, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
803    {
804      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
805                                                ithresh, thresh);
806      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
807      uint8x16_t op1, op0, oq0, oq1;
808      DoFilter4_NEON(p1, p0, q0, q1, mask, hev_mask, &op1, &op0, &oq0, &oq1);
809      Store4x8x2_NEON(op1, op0, oq0, oq1, u, v, stride);
810    }
811  }
812  #endif  
813  static const int16_t kC1 = 20091;
814  static const int16_t kC2 = 17734;  
815  #if defined(WEBP_USE_INTRINSICS)
816  static WEBP_INLINE void Transpose8x2_NEON(const int16x8_t in0,
817                                            const int16x8_t in1,
818                                            int16x8x2_t* const out) {
819    const int16x8x2_t tmp0 = vzipq_s16(in0, in1);   
820    *out = vzipq_s16(tmp0.val[0], tmp0.val[1]);
821  }
822  static WEBP_INLINE void TransformPass_NEON(int16x8x2_t* const rows) {
823    const int16x8_t B1 =
824        vcombine_s16(vget_high_s16(rows->val[0]), vget_high_s16(rows->val[1]));
825    const int16x8_t C0 = vsraq_n_s16(B1, vqdmulhq_n_s16(B1, kC1), 1);
826    const int16x8_t C1 = vqdmulhq_n_s16(B1, kC2);
827    const int16x4_t a = vqadd_s16(vget_low_s16(rows->val[0]),
828                                  vget_low_s16(rows->val[1]));   
829    const int16x4_t b = vqsub_s16(vget_low_s16(rows->val[0]),
830                                  vget_low_s16(rows->val[1]));   
831    const int16x4_t c = vqsub_s16(vget_low_s16(C1), vget_high_s16(C0));
832    const int16x4_t d = vqadd_s16(vget_low_s16(C0), vget_high_s16(C1));
833    const int16x8_t D0 = vcombine_s16(a, b);      
834    const int16x8_t D1 = vcombine_s16(d, c);      
835    const int16x8_t E0 = vqaddq_s16(D0, D1);      
836    const int16x8_t E_tmp = vqsubq_s16(D0, D1);   
837    const int16x8_t E1 = vcombine_s16(vget_high_s16(E_tmp), vget_low_s16(E_tmp));
838    Transpose8x2_NEON(E0, E1, rows);
839  }
840  static void TransformOne_NEON(const int16_t* in, uint8_t* dst) {
841    int16x8x2_t rows;
842    INIT_VECTOR2(rows, vld1q_s16(in + 0), vld1q_s16(in + 8));
843    TransformPass_NEON(&rows);
844    TransformPass_NEON(&rows);
845    Add4x4_NEON(rows.val[0], rows.val[1], dst);
846  }
847  #else
848  static void TransformOne_NEON(const int16_t* in, uint8_t* dst) {
849    const int kBPS = BPS;
850    const int16_t constants[4] = { kC1, kC2, 0, 0 };
851    __asm__ volatile (
852      "vld1.16         {q1, q2}, [%[in]]           \n"
853      "vld1.16         {d0}, [%[constants]]        \n"
854      "vswp            d3, d4                      \n"
855      "vqdmulh.s16     q8, q2, d0[0]               \n"
856      "vqdmulh.s16     q9, q2, d0[1]               \n"
857      "vqadd.s16       d22, d2, d3                 \n"
858      "vqsub.s16       d23, d2, d3                 \n"
859      "vshr.s16        q8, q8, #1                  \n"
860      "vqadd.s16       q8, q2, q8                  \n"
861      "vqsub.s16       d20, d18, d17               \n"
862      "vqadd.s16       d21, d19, d16               \n"
863      "vqadd.s16       d2, d22, d21                \n"
864      "vqadd.s16       d3, d23, d20                \n"
865      "vqsub.s16       d4, d23, d20                \n"
866      "vqsub.s16       d5, d22, d21                \n"
867      "vzip.16         q1, q2                      \n"
868      "vzip.16         q1, q2                      \n"
869      "vswp            d3, d4                      \n"
870      "vqdmulh.s16     q8, q2, d0[0]               \n"
871      "vqdmulh.s16     q9, q2, d0[1]               \n"
872      "vqadd.s16       d22, d2, d3                 \n"
873      "vqsub.s16       d23, d2, d3                 \n"
874      "vshr.s16        q8, q8, #1                  \n"
875      "vqadd.s16       q8, q2, q8                  \n"
876      "vqsub.s16       d20, d18, d17               \n"
877      "vqadd.s16       d21, d19, d16               \n"
878      "vqadd.s16       d2, d22, d21                \n"
879      "vqadd.s16       d3, d23, d20                \n"
880      "vqsub.s16       d4, d23, d20                \n"
881      "vqsub.s16       d5, d22, d21                \n"
882      "vld1.32         d6[0], [%[dst]], %[kBPS]    \n"
883      "vld1.32         d6[1], [%[dst]], %[kBPS]    \n"
884      "vld1.32         d7[0], [%[dst]], %[kBPS]    \n"
885      "vld1.32         d7[1], [%[dst]], %[kBPS]    \n"
886      "sub         %[dst], %[dst], %[kBPS], lsl #2 \n"
887      "vrshr.s16       d2, d2, #3                  \n"
888      "vrshr.s16       d3, d3, #3                  \n"
889      "vrshr.s16       d4, d4, #3                  \n"
890      "vrshr.s16       d5, d5, #3                  \n"
891      "vzip.16         q1, q2                      \n"
892      "vzip.16         q1, q2                      \n"
893      "vmovl.u8        q8, d6                      \n"
894      "vmovl.u8        q9, d7                      \n"
895      "vqadd.s16       q1, q1, q8                  \n"
896      "vqadd.s16       q2, q2, q9                  \n"
897      "vqmovun.s16     d0, q1                      \n"
898      "vqmovun.s16     d1, q2                      \n"
899      "vst1.32         d0[0], [%[dst]], %[kBPS]    \n"
900      "vst1.32         d0[1], [%[dst]], %[kBPS]    \n"
901      "vst1.32         d1[0], [%[dst]], %[kBPS]    \n"
902      "vst1.32         d1[1], [%[dst]]             \n"
903      : [in] "+r"(in), [dst] "+r"(dst)  &bsol;* modified registers */
904      : [kBPS] "r"(kBPS), [constants] "r"(constants)  &bsol;* constants */
905      : "memory", "q0", "q1", "q2", "q8", "q9", "q10", "q11"  &bsol;* clobbered */
906    );
907  }
908  #endif    
909  static void TransformTwo_NEON(const int16_t* in, uint8_t* dst, int do_two) {
910    TransformOne_NEON(in, dst);
911    if (do_two) {
912      TransformOne_NEON(in + 16, dst + 4);
913    }
914  }
915  static void TransformDC_NEON(const int16_t* in, uint8_t* dst) {
916    const int16x8_t DC = vdupq_n_s16(in[0]);
917    Add4x4_NEON(DC, DC, dst);
918  }
919  #define STORE_WHT(dst, col, rows) do {                  \
920    *dst = vgetq_lane_s32(rows.val[0], col); (dst) += 16; \
921    *dst = vgetq_lane_s32(rows.val[1], col); (dst) += 16; \
922    *dst = vgetq_lane_s32(rows.val[2], col); (dst) += 16; \
923    *dst = vgetq_lane_s32(rows.val[3], col); (dst) += 16; \
924  } while (0)
925  static void TransformWHT_NEON(const int16_t* in, int16_t* out) {
926    int32x4x4_t tmp;
927    {
928      const int16x4_t in00_03 = vld1_s16(in + 0);
929      const int16x4_t in04_07 = vld1_s16(in + 4);
930      const int16x4_t in08_11 = vld1_s16(in + 8);
931      const int16x4_t in12_15 = vld1_s16(in + 12);
932      const int32x4_t a0 = vaddl_s16(in00_03, in12_15);  
933      const int32x4_t a1 = vaddl_s16(in04_07, in08_11);  
934      const int32x4_t a2 = vsubl_s16(in04_07, in08_11);  
935      const int32x4_t a3 = vsubl_s16(in00_03, in12_15);  
936      tmp.val[0] = vaddq_s32(a0, a1);
937      tmp.val[1] = vaddq_s32(a3, a2);
938      tmp.val[2] = vsubq_s32(a0, a1);
939      tmp.val[3] = vsubq_s32(a3, a2);
940      tmp = Transpose4x4_NEON(tmp);
941    }
942    {
943      const int32x4_t kCst3 = vdupq_n_s32(3);
944      const int32x4_t dc = vaddq_s32(tmp.val[0], kCst3);  
945      const int32x4_t a0 = vaddq_s32(dc, tmp.val[3]);
946      const int32x4_t a1 = vaddq_s32(tmp.val[1], tmp.val[2]);
947      const int32x4_t a2 = vsubq_s32(tmp.val[1], tmp.val[2]);
948      const int32x4_t a3 = vsubq_s32(dc, tmp.val[3]);
949      tmp.val[0] = vaddq_s32(a0, a1);
950      tmp.val[1] = vaddq_s32(a3, a2);
951      tmp.val[2] = vsubq_s32(a0, a1);
952      tmp.val[3] = vsubq_s32(a3, a2);
953      tmp.val[0] = vshrq_n_s32(tmp.val[0], 3);
954      tmp.val[1] = vshrq_n_s32(tmp.val[1], 3);
955      tmp.val[2] = vshrq_n_s32(tmp.val[2], 3);
956      tmp.val[3] = vshrq_n_s32(tmp.val[3], 3);
957      STORE_WHT(out, 0, tmp);
958      STORE_WHT(out, 1, tmp);
959      STORE_WHT(out, 2, tmp);
960      STORE_WHT(out, 3, tmp);
961    }
962  }
963  #undef STORE_WHT
964  #define MUL(a, b) (((a) * (b)) >> 16)
965  static void TransformAC3_NEON(const int16_t* in, uint8_t* dst) {
966    static const int kC1_full = 20091 + (1 << 16);
967    static const int kC2_full = 35468;
968    const int16x4_t A = vld1_dup_s16(in);
969    const int16x4_t c4 = vdup_n_s16(MUL(in[4], kC2_full));
970    const int16x4_t d4 = vdup_n_s16(MUL(in[4], kC1_full));
971    const int c1 = MUL(in[1], kC2_full);
972    const int d1 = MUL(in[1], kC1_full);
973    const uint64_t cd = (uint64_t)( d1 & 0xffff) <<  0 |
974                        (uint64_t)( c1 & 0xffff) << 16 |
975                        (uint64_t)(-c1 & 0xffff) << 32 |
976                        (uint64_t)(-d1 & 0xffff) << 48;
977    const int16x4_t CD = vcreate_s16(cd);
978    const int16x4_t B = vqadd_s16(A, CD);
979    const int16x8_t m0_m1 = vcombine_s16(vqadd_s16(B, d4), vqadd_s16(B, c4));
980    const int16x8_t m2_m3 = vcombine_s16(vqsub_s16(B, c4), vqsub_s16(B, d4));
981    Add4x4_NEON(m0_m1, m2_m3, dst);
982  }
983  #undef MUL
984  static void DC4_NEON(uint8_t* dst) {    
985    const uint8x8_t A = vld1_u8(dst - BPS);  
986    const uint16x4_t p0 = vpaddl_u8(A);  
987    const uint16x4_t p1 = vpadd_u16(p0, p0);
988    const uint16x8_t L0 = vmovl_u8(vld1_u8(dst + 0 * BPS - 1));
989    const uint16x8_t L1 = vmovl_u8(vld1_u8(dst + 1 * BPS - 1));
990    const uint16x8_t L2 = vmovl_u8(vld1_u8(dst + 2 * BPS - 1));
991    const uint16x8_t L3 = vmovl_u8(vld1_u8(dst + 3 * BPS - 1));
992    const uint16x8_t s0 = vaddq_u16(L0, L1);
993    const uint16x8_t s1 = vaddq_u16(L2, L3);
994    const uint16x8_t s01 = vaddq_u16(s0, s1);
995    const uint16x8_t sum = vaddq_u16(s01, vcombine_u16(p1, p1));
996    const uint8x8_t dc0 = vrshrn_n_u16(sum, 3);  
997    const uint8x8_t dc = vdup_lane_u8(dc0, 0);
998    int i;
999    for (i = 0; i < 4; ++i) {
1000      vst1_lane_u32((uint32_t*)(dst + i * BPS), vreinterpret_u32_u8(dc), 0);
1001    }
1002  }
1003  static WEBP_INLINE void TrueMotion_NEON(uint8_t* dst, int size) {
1004    const uint8x8_t TL = vld1_dup_u8(dst - BPS - 1);  
1005    const uint8x8_t T = vld1_u8(dst - BPS);  
1006    const int16x8_t d = vreinterpretq_s16_u16(vsubl_u8(T, TL));  
1007    int y;
1008    for (y = 0; y < size; y += 4) {
1009      const int16x8_t L0 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 0 * BPS - 1));
1010      const int16x8_t L1 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 1 * BPS - 1));
1011      const int16x8_t L2 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 2 * BPS - 1));
1012      const int16x8_t L3 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 3 * BPS - 1));
1013      const int16x8_t r0 = vaddq_s16(L0, d);  
1014      const int16x8_t r1 = vaddq_s16(L1, d);
1015      const int16x8_t r2 = vaddq_s16(L2, d);
1016      const int16x8_t r3 = vaddq_s16(L3, d);
1017      const uint32x2_t r0_u32 = vreinterpret_u32_u8(vqmovun_s16(r0));
1018      const uint32x2_t r1_u32 = vreinterpret_u32_u8(vqmovun_s16(r1));
1019      const uint32x2_t r2_u32 = vreinterpret_u32_u8(vqmovun_s16(r2));
1020      const uint32x2_t r3_u32 = vreinterpret_u32_u8(vqmovun_s16(r3));
1021      if (size == 4) {
1022        vst1_lane_u32((uint32_t*)(dst + 0 * BPS), r0_u32, 0);
1023        vst1_lane_u32((uint32_t*)(dst + 1 * BPS), r1_u32, 0);
1024        vst1_lane_u32((uint32_t*)(dst + 2 * BPS), r2_u32, 0);
1025        vst1_lane_u32((uint32_t*)(dst + 3 * BPS), r3_u32, 0);
1026      } else {
1027        vst1_u32((uint32_t*)(dst + 0 * BPS), r0_u32);
1028        vst1_u32((uint32_t*)(dst + 1 * BPS), r1_u32);
1029        vst1_u32((uint32_t*)(dst + 2 * BPS), r2_u32);
1030        vst1_u32((uint32_t*)(dst + 3 * BPS), r3_u32);
1031      }
1032      dst += 4 * BPS;
1033    }
1034  }
1035  static void TM4_NEON(uint8_t* dst) { TrueMotion_NEON(dst, 4); }
1036  static void VE4_NEON(uint8_t* dst) {    
1037    const uint64x1_t A0 = vreinterpret_u64_u8(vld1_u8(dst - BPS - 1));  
1038    const uint64x1_t A1 = vshr_n_u64(A0, 8);
1039    const uint64x1_t A2 = vshr_n_u64(A0, 16);
1040    const uint8x8_t ABCDEFGH = vreinterpret_u8_u64(A0);
1041    const uint8x8_t BCDEFGH0 = vreinterpret_u8_u64(A1);
1042    const uint8x8_t CDEFGH00 = vreinterpret_u8_u64(A2);
1043    const uint8x8_t b = vhadd_u8(ABCDEFGH, CDEFGH00);
1044    const uint8x8_t avg = vrhadd_u8(b, BCDEFGH0);
1045    int i;
1046    for (i = 0; i < 4; ++i) {
1047      vst1_lane_u32((uint32_t*)(dst + i * BPS), vreinterpret_u32_u8(avg), 0);
1048    }
1049  }
1050  static void RD4_NEON(uint8_t* dst) {   
1051    const uint8x8_t XABCD_u8 = vld1_u8(dst - BPS - 1);
1052    const uint64x1_t XABCD = vreinterpret_u64_u8(XABCD_u8);
1053    const uint64x1_t ____XABC = vshl_n_u64(XABCD, 32);
1054    const uint32_t I = dst[-1 + 0 * BPS];
1055    const uint32_t J = dst[-1 + 1 * BPS];
1056    const uint32_t K = dst[-1 + 2 * BPS];
1057    const uint32_t L = dst[-1 + 3 * BPS];
1058    const uint64x1_t LKJI____ =
1059        vcreate_u64((uint64_t)L | (K << 8) | (J << 16) | (I << 24));
1060    const uint64x1_t LKJIXABC = vorr_u64(LKJI____, ____XABC);
1061    const uint8x8_t KJIXABC_ = vreinterpret_u8_u64(vshr_n_u64(LKJIXABC, 8));
1062    const uint8x8_t JIXABC__ = vreinterpret_u8_u64(vshr_n_u64(LKJIXABC, 16));
1063    const uint8_t D = vget_lane_u8(XABCD_u8, 4);
1064    const uint8x8_t JIXABCD_ = vset_lane_u8(D, JIXABC__, 6);
1065    const uint8x8_t LKJIXABC_u8 = vreinterpret_u8_u64(LKJIXABC);
1066    const uint8x8_t avg1 = vhadd_u8(JIXABCD_, LKJIXABC_u8);
1067    const uint8x8_t avg2 = vrhadd_u8(avg1, KJIXABC_);
1068    const uint64x1_t avg2_u64 = vreinterpret_u64_u8(avg2);
1069    const uint32x2_t r3 = vreinterpret_u32_u8(avg2);
1070    const uint32x2_t r2 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 8));
1071    const uint32x2_t r1 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 16));
1072    const uint32x2_t r0 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 24));
1073    vst1_lane_u32((uint32_t*)(dst + 0 * BPS), r0, 0);
1074    vst1_lane_u32((uint32_t*)(dst + 1 * BPS), r1, 0);
1075    vst1_lane_u32((uint32_t*)(dst + 2 * BPS), r2, 0);
1076    vst1_lane_u32((uint32_t*)(dst + 3 * BPS), r3, 0);
1077  }
1078  static void LD4_NEON(uint8_t* dst) {    
1079    const uint8x8_t ABCDEFGH = vld1_u8(dst - BPS + 0);
1080    const uint8x8_t BCDEFGH0 = vld1_u8(dst - BPS + 1);
1081    const uint8x8_t CDEFGH00 = vld1_u8(dst - BPS + 2);
1082    const uint8x8_t CDEFGHH0 = vset_lane_u8(dst[-BPS + 7], CDEFGH00, 6);
1083    const uint8x8_t avg1 = vhadd_u8(ABCDEFGH, CDEFGHH0);
1084    const uint8x8_t avg2 = vrhadd_u8(avg1, BCDEFGH0);
1085    const uint64x1_t avg2_u64 = vreinterpret_u64_u8(avg2);
1086    const uint32x2_t r0 = vreinterpret_u32_u8(avg2);
1087    const uint32x2_t r1 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 8));
1088    const uint32x2_t r2 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 16));
1089    const uint32x2_t r3 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 24));
1090    vst1_lane_u32((uint32_t*)(dst + 0 * BPS), r0, 0);
1091    vst1_lane_u32((uint32_t*)(dst + 1 * BPS), r1, 0);
1092    vst1_lane_u32((uint32_t*)(dst + 2 * BPS), r2, 0);
1093    vst1_lane_u32((uint32_t*)(dst + 3 * BPS), r3, 0);
1094  }
1095  static void VE8uv_NEON(uint8_t* dst) {    
1096    const uint8x8_t top = vld1_u8(dst - BPS);
1097    int j;
1098    for (j = 0; j < 8; ++j) {
1099      vst1_u8(dst + j * BPS, top);
1100    }
1101  }
1102  static void HE8uv_NEON(uint8_t* dst) {    
1103    int j;
1104    for (j = 0; j < 8; ++j) {
1105      const uint8x8_t left = vld1_dup_u8(dst - 1);
1106      vst1_u8(dst, left);
1107      dst += BPS;
1108    }
1109  }
1110  static WEBP_INLINE void DC8_NEON(uint8_t* dst, int do_top, int do_left) {
1111    uint16x8_t sum_top;
1112    uint16x8_t sum_left;
1113    uint8x8_t dc0;
1114    if (do_top) {
1115      const uint8x8_t A = vld1_u8(dst - BPS);  
1116  #if defined(__aarch64__)
1117      const uint16x8_t B = vmovl_u8(A);
1118      const uint16_t p2 = vaddvq_u16(B);
1119      sum_top = vdupq_n_u16(p2);
1120  #else
1121      const uint16x4_t p0 = vpaddl_u8(A);  
1122      const uint16x4_t p1 = vpadd_u16(p0, p0);
1123      const uint16x4_t p2 = vpadd_u16(p1, p1);
1124      sum_top = vcombine_u16(p2, p2);
1125  #endif
1126    }
1127    if (do_left) {
1128      const uint16x8_t L0 = vmovl_u8(vld1_u8(dst + 0 * BPS - 1));
1129      const uint16x8_t L1 = vmovl_u8(vld1_u8(dst + 1 * BPS - 1));
1130      const uint16x8_t L2 = vmovl_u8(vld1_u8(dst + 2 * BPS - 1));
1131      const uint16x8_t L3 = vmovl_u8(vld1_u8(dst + 3 * BPS - 1));
1132      const uint16x8_t L4 = vmovl_u8(vld1_u8(dst + 4 * BPS - 1));
1133      const uint16x8_t L5 = vmovl_u8(vld1_u8(dst + 5 * BPS - 1));
1134      const uint16x8_t L6 = vmovl_u8(vld1_u8(dst + 6 * BPS - 1));
1135      const uint16x8_t L7 = vmovl_u8(vld1_u8(dst + 7 * BPS - 1));
1136      const uint16x8_t s0 = vaddq_u16(L0, L1);
1137      const uint16x8_t s1 = vaddq_u16(L2, L3);
1138      const uint16x8_t s2 = vaddq_u16(L4, L5);
1139      const uint16x8_t s3 = vaddq_u16(L6, L7);
1140      const uint16x8_t s01 = vaddq_u16(s0, s1);
1141      const uint16x8_t s23 = vaddq_u16(s2, s3);
1142      sum_left = vaddq_u16(s01, s23);
1143    }
1144    if (do_top && do_left) {
1145      const uint16x8_t sum = vaddq_u16(sum_left, sum_top);
1146      dc0 = vrshrn_n_u16(sum, 4);
1147    } else if (do_top) {
1148      dc0 = vrshrn_n_u16(sum_top, 3);
1149    } else if (do_left) {
1150      dc0 = vrshrn_n_u16(sum_left, 3);
1151    } else {
1152      dc0 = vdup_n_u8(0x80);
1153    }
1154    {
1155      const uint8x8_t dc = vdup_lane_u8(dc0, 0);
1156      int i;
1157      for (i = 0; i < 8; ++i) {
1158        vst1_u32((uint32_t*)(dst + i * BPS), vreinterpret_u32_u8(dc));
1159      }
1160    }
1161  }
1162  static void DC8uv_NEON(uint8_t* dst) { DC8_NEON(dst, 1, 1); }
1163  static void DC8uvNoTop_NEON(uint8_t* dst) { DC8_NEON(dst, 0, 1); }
1164  static void DC8uvNoLeft_NEON(uint8_t* dst) { DC8_NEON(dst, 1, 0); }
1165  static void DC8uvNoTopLeft_NEON(uint8_t* dst) { DC8_NEON(dst, 0, 0); }
1166  static void TM8uv_NEON(uint8_t* dst) { TrueMotion_NEON(dst, 8); }
1167  static void VE16_NEON(uint8_t* dst) {     
1168    const uint8x16_t top = vld1q_u8(dst - BPS);
1169    int j;
1170    for (j = 0; j < 16; ++j) {
1171      vst1q_u8(dst + j * BPS, top);
1172    }
1173  }
1174  static void HE16_NEON(uint8_t* dst) {     
1175    int j;
1176    for (j = 0; j < 16; ++j) {
1177      const uint8x16_t left = vld1q_dup_u8(dst - 1);
1178      vst1q_u8(dst, left);
1179      dst += BPS;
1180    }
1181  }
1182  static WEBP_INLINE void DC16_NEON(uint8_t* dst, int do_top, int do_left) {
1183    uint16x8_t sum_top;
1184    uint16x8_t sum_left;
1185    uint8x8_t dc0;
1186    if (do_top) {
1187      const uint8x16_t A = vld1q_u8(dst - BPS);  
1188      const uint16x8_t p0 = vpaddlq_u8(A);  
1189      const uint16x4_t p1 = vadd_u16(vget_low_u16(p0), vget_high_u16(p0));
1190      const uint16x4_t p2 = vpadd_u16(p1, p1);
1191      const uint16x4_t p3 = vpadd_u16(p2, p2);
<span onclick='openModal()' class='match'>1192      sum_top = vcombine_u16(p3, p3);
1193    }
1194    if (do_left) {
1195      int i;
</span>1196      sum_left = vdupq_n_u16(0);
1197      for (i = 0; i < 16; i += 8) {
1198        const uint16x8_t L0 = vmovl_u8(vld1_u8(dst + (i + 0) * BPS - 1));
1199        const uint16x8_t L1 = vmovl_u8(vld1_u8(dst + (i + 1) * BPS - 1));
1200        const uint16x8_t L2 = vmovl_u8(vld1_u8(dst + (i + 2) * BPS - 1));
1201        const uint16x8_t L3 = vmovl_u8(vld1_u8(dst + (i + 3) * BPS - 1));
1202        const uint16x8_t L4 = vmovl_u8(vld1_u8(dst + (i + 4) * BPS - 1));
1203        const uint16x8_t L5 = vmovl_u8(vld1_u8(dst + (i + 5) * BPS - 1));
1204        const uint16x8_t L6 = vmovl_u8(vld1_u8(dst + (i + 6) * BPS - 1));
1205        const uint16x8_t L7 = vmovl_u8(vld1_u8(dst + (i + 7) * BPS - 1));
1206        const uint16x8_t s0 = vaddq_u16(L0, L1);
1207        const uint16x8_t s1 = vaddq_u16(L2, L3);
1208        const uint16x8_t s2 = vaddq_u16(L4, L5);
1209        const uint16x8_t s3 = vaddq_u16(L6, L7);
1210        const uint16x8_t s01 = vaddq_u16(s0, s1);
1211        const uint16x8_t s23 = vaddq_u16(s2, s3);
1212        const uint16x8_t sum = vaddq_u16(s01, s23);
1213        sum_left = vaddq_u16(sum_left, sum);
1214      }
1215    }
1216    if (do_top && do_left) {
1217      const uint16x8_t sum = vaddq_u16(sum_left, sum_top);
1218      dc0 = vrshrn_n_u16(sum, 5);
1219    } else if (do_top) {
1220      dc0 = vrshrn_n_u16(sum_top, 4);
1221    } else if (do_left) {
1222      dc0 = vrshrn_n_u16(sum_left, 4);
1223    } else {
1224      dc0 = vdup_n_u8(0x80);
1225    }
1226    {
1227      const uint8x16_t dc = vdupq_lane_u8(dc0, 0);
1228      int i;
1229      for (i = 0; i < 16; ++i) {
1230        vst1q_u8(dst + i * BPS, dc);
1231      }
1232    }
1233  }
1234  static void DC16TopLeft_NEON(uint8_t* dst) { DC16_NEON(dst, 1, 1); }
1235  static void DC16NoTop_NEON(uint8_t* dst) { DC16_NEON(dst, 0, 1); }
1236  static void DC16NoLeft_NEON(uint8_t* dst) { DC16_NEON(dst, 1, 0); }
1237  static void DC16NoTopLeft_NEON(uint8_t* dst) { DC16_NEON(dst, 0, 0); }
1238  static void TM16_NEON(uint8_t* dst) {
1239    const uint8x8_t TL = vld1_dup_u8(dst - BPS - 1);  
1240    const uint8x16_t T = vld1q_u8(dst - BPS);  
1241    const int16x8_t d_lo = vreinterpretq_s16_u16(vsubl_u8(vget_low_u8(T), TL));
1242    const int16x8_t d_hi = vreinterpretq_s16_u16(vsubl_u8(vget_high_u8(T), TL));
1243    int y;
1244    for (y = 0; y < 16; y += 4) {
1245      const int16x8_t L0 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 0 * BPS - 1));
1246      const int16x8_t L1 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 1 * BPS - 1));
1247      const int16x8_t L2 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 2 * BPS - 1));
1248      const int16x8_t L3 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 3 * BPS - 1));
1249      const int16x8_t r0_lo = vaddq_s16(L0, d_lo);  
1250      const int16x8_t r1_lo = vaddq_s16(L1, d_lo);
1251      const int16x8_t r2_lo = vaddq_s16(L2, d_lo);
1252      const int16x8_t r3_lo = vaddq_s16(L3, d_lo);
1253      const int16x8_t r0_hi = vaddq_s16(L0, d_hi);
1254      const int16x8_t r1_hi = vaddq_s16(L1, d_hi);
1255      const int16x8_t r2_hi = vaddq_s16(L2, d_hi);
1256      const int16x8_t r3_hi = vaddq_s16(L3, d_hi);
1257      const uint8x16_t row0 = vcombine_u8(vqmovun_s16(r0_lo), vqmovun_s16(r0_hi));
1258      const uint8x16_t row1 = vcombine_u8(vqmovun_s16(r1_lo), vqmovun_s16(r1_hi));
1259      const uint8x16_t row2 = vcombine_u8(vqmovun_s16(r2_lo), vqmovun_s16(r2_hi));
1260      const uint8x16_t row3 = vcombine_u8(vqmovun_s16(r3_lo), vqmovun_s16(r3_hi));
1261      vst1q_u8(dst + 0 * BPS, row0);
1262      vst1q_u8(dst + 1 * BPS, row1);
1263      vst1q_u8(dst + 2 * BPS, row2);
1264      vst1q_u8(dst + 3 * BPS, row3);
1265      dst += 4 * BPS;
1266    }
1267  }
1268  extern void VP8DspInitNEON(void);
1269  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitNEON(void) {
1270    VP8Transform = TransformTwo_NEON;
1271    VP8TransformAC3 = TransformAC3_NEON;
1272    VP8TransformDC = TransformDC_NEON;
1273    VP8TransformWHT = TransformWHT_NEON;
1274    VP8VFilter16 = VFilter16_NEON;
1275    VP8VFilter16i = VFilter16i_NEON;
1276    VP8HFilter16 = HFilter16_NEON;
1277  #if !defined(WORK_AROUND_GCC)
1278    VP8HFilter16i = HFilter16i_NEON;
1279  #endif
1280    VP8VFilter8 = VFilter8_NEON;
1281    VP8VFilter8i = VFilter8i_NEON;
1282  #if !defined(WORK_AROUND_GCC)
1283    VP8HFilter8 = HFilter8_NEON;
1284    VP8HFilter8i = HFilter8i_NEON;
1285  #endif
1286    VP8SimpleVFilter16 = SimpleVFilter16_NEON;
1287    VP8SimpleHFilter16 = SimpleHFilter16_NEON;
1288    VP8SimpleVFilter16i = SimpleVFilter16i_NEON;
1289    VP8SimpleHFilter16i = SimpleHFilter16i_NEON;
1290    VP8PredLuma4[0] = DC4_NEON;
1291    VP8PredLuma4[1] = TM4_NEON;
1292    VP8PredLuma4[2] = VE4_NEON;
1293    VP8PredLuma4[4] = RD4_NEON;
1294    VP8PredLuma4[6] = LD4_NEON;
1295    VP8PredLuma16[0] = DC16TopLeft_NEON;
1296    VP8PredLuma16[1] = TM16_NEON;
1297    VP8PredLuma16[2] = VE16_NEON;
1298    VP8PredLuma16[3] = HE16_NEON;
1299    VP8PredLuma16[4] = DC16NoTop_NEON;
1300    VP8PredLuma16[5] = DC16NoLeft_NEON;
1301    VP8PredLuma16[6] = DC16NoTopLeft_NEON;
1302    VP8PredChroma8[0] = DC8uv_NEON;
1303    VP8PredChroma8[1] = TM8uv_NEON;
1304    VP8PredChroma8[2] = VE8uv_NEON;
1305    VP8PredChroma8[3] = HE8uv_NEON;
1306    VP8PredChroma8[4] = DC8uvNoTop_NEON;
1307    VP8PredChroma8[5] = DC8uvNoLeft_NEON;
1308    VP8PredChroma8[6] = DC8uvNoTopLeft_NEON;
1309  }
1310  #else  
1311  WEBP_DSP_INIT_STUB(VP8DspInitNEON)
1312  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-gif2webp.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #ifdef HAVE_CONFIG_H
6  #include "webp/config.h"
7  #endif
8  #ifdef WEBP_HAVE_GIF
9  #if defined(HAVE_UNISTD_H) && HAVE_UNISTD_H
10  #include <unistd.h>
11  #endif
12  #include <gif_lib.h>
13  #include "webp/encode.h"
14  #include "webp/mux.h"
15  #include "../examples/example_util.h"
16  #include "../imageio/imageio_util.h"
17  #include "./gifdec.h"
18  #include "./unicode.h"
19  #include "./unicode_gif.h"
20  #if !defined(STDIN_FILENO)
21  #define STDIN_FILENO 0
22  #endif
23  static int transparent_index = GIF_INDEX_INVALID;  
24  static const char* const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
25    "WEBP_MUX_NOT_FOUND", "WEBP_MUX_INVALID_ARGUMENT", "WEBP_MUX_BAD_DATA",
26    "WEBP_MUX_MEMORY_ERROR", "WEBP_MUX_NOT_ENOUGH_DATA"
27  };
28  static const char* ErrorString(WebPMuxError err) {
29    assert(err <= WEBP_MUX_NOT_FOUND && err >= WEBP_MUX_NOT_ENOUGH_DATA);
30    return kErrorMessages[-err];
31  }
32  enum {
33    METADATA_ICC  = (1 << 0),
34    METADATA_XMP  = (1 << 1),
35    METADATA_ALL  = METADATA_ICC | METADATA_XMP
36  };
37  static void Help(void) {
38    printf("Usage:\n");
39    printf(" gif2webp [options] gif_file -o webp_file\n");
40    printf("Options:\n");
41    printf("  -h / -help ............. this help\n");
42    printf("  -lossy ................. encode image using lossy compression\n");
43    printf("  -mixed ................. for each frame in the image, pick lossy\n"
44           "                           or lossless compression heuristically\n");
45    printf("  -q <float> ............. quality factor (0:small..100:big)\n");
46    printf("  -m <int> ............... compression method (0=fast, 6=slowest)\n");
47    printf("  -min_size .............. minimize output size (default:off)\n"
48           "                           lossless compression by default; can be\n"
49           "                           combined with -q, -m, -lossy or -mixed\n"
50           "                           options\n");
51    printf("  -kmin <int> ............ min distance between key frames\n");
52    printf("  -kmax <int> ............ max distance between key frames\n");
53    printf("  -f <int> ............... filter strength (0=off..100)\n");
54    printf("  -metadata <string> ..... comma separated list of metadata to\n");
55    printf("                           ");
56    printf("copy from the input to the output if present\n");
57    printf("                           ");
58    printf("Valid values: all, none, icc, xmp (default)\n");
59    printf("  -loop_compatibility .... use compatibility mode for Chrome\n");
60    printf("                           version prior to M62 (inclusive)\n");
61    printf("  -mt .................... use multi-threading if available\n");
62    printf("\n");
63    printf("  -version ............... print version number and exit\n");
64    printf("  -v ..................... verbose\n");
65    printf("  -quiet ................. don't print anything\n");
66    printf("\n");
67  }
68  int main(int argc, const char* argv[]) {
69    int verbose = 0;
70    int gif_error = GIF_ERROR;
71    WebPMuxError err = WEBP_MUX_OK;
72    int ok = 0;
73    const W_CHAR* in_file = NULL, *out_file = NULL;
74    GifFileType* gif = NULL;
75    int frame_duration = 0;
76    int frame_timestamp = 0;
77    GIFDisposeMethod orig_dispose = GIF_DISPOSE_NONE;
78    WebPPicture frame;                
79    WebPPicture curr_canvas;          
80    WebPPicture prev_canvas;          
81    WebPAnimEncoder* enc = NULL;
82    WebPAnimEncoderOptions enc_options;
83    WebPConfig config;
84    int frame_number = 0;     
85    int done;
86    int c;
87    int quiet = 0;
88    WebPData webp_data;
89    int keep_metadata = METADATA_XMP;  
90    WebPData icc_data;
91    int stored_icc = 0;         
92    WebPData xmp_data;
93    int stored_xmp = 0;         
94    int loop_count = 0;         
95    int stored_loop_count = 0;  
96    int loop_compatibility = 0;
97    WebPMux* mux = NULL;
98    int default_kmin = 1;  
99    int default_kmax = 1;
100    INIT_WARGV(argc, argv);
101    if (!WebPConfigInit(&config) || !WebPAnimEncoderOptionsInit(&enc_options) ||
102        !WebPPictureInit(&frame) || !WebPPictureInit(&curr_canvas) ||
103        !WebPPictureInit(&prev_canvas)) {
104      fprintf(stderr, "Error! Version mismatch!\n");
105      FREE_WARGV_AND_RETURN(-1);
106    }
107    config.lossless = 1;  
108    WebPDataInit(&webp_data);
109    WebPDataInit(&icc_data);
110    WebPDataInit(&xmp_data);
111    if (argc == 1) {
112      Help();
113      FREE_WARGV_AND_RETURN(0);
114    }
115    for (c = 1; c < argc; ++c) {
116      int parse_error = 0;
117      if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
118        Help();
119        FREE_WARGV_AND_RETURN(0);
120      } else if (!strcmp(argv[c], "-o") && c < argc - 1) {
121        out_file = GET_WARGV(argv, ++c);
122      } else if (!strcmp(argv[c], "-lossy")) {
123        config.lossless = 0;
124      } else if (!strcmp(argv[c], "-mixed")) {
125        enc_options.allow_mixed = 1;
126        config.lossless = 0;
127      } else if (!strcmp(argv[c], "-loop_compatibility")) {
128        loop_compatibility = 1;
129      } else if (!strcmp(argv[c], "-q") && c < argc - 1) {
130        config.quality = ExUtilGetFloat(argv[++c], &parse_error);
131      } else if (!strcmp(argv[c], "-m") && c < argc - 1) {
132        config.method = ExUtilGetInt(argv[++c], 0, &parse_error);
133      } else if (!strcmp(argv[c], "-min_size")) {
134        enc_options.minimize_size = 1;
135      } else if (!strcmp(argv[c], "-kmax") && c < argc - 1) {
136        enc_options.kmax = ExUtilGetInt(argv[++c], 0, &parse_error);
137        default_kmax = 0;
138      } else if (!strcmp(argv[c], "-kmin") && c < argc - 1) {
139        enc_options.kmin = ExUtilGetInt(argv[++c], 0, &parse_error);
140        default_kmin = 0;
141      } else if (!strcmp(argv[c], "-f") && c < argc - 1) {
142        config.filter_strength = ExUtilGetInt(argv[++c], 0, &parse_error);
143      } else if (!strcmp(argv[c], "-metadata") && c < argc - 1) {
144        static const struct {
145          const char* option;
146          int flag;
147        } kTokens[] = {
148          { "all",  METADATA_ALL },
149          { "none", 0 },
150          { "icc",  METADATA_ICC },
151          { "xmp",  METADATA_XMP },
152        };
153        const size_t kNumTokens = sizeof(kTokens) / sizeof(*kTokens);
154        const char* start = argv[++c];
155        const char* const end = start + strlen(start);
156        keep_metadata = 0;
157        while (start < end) {
158          size_t i;
159          const char* token = strchr(start, ',');
160          if (token == NULL) token = end;
161          for (i = 0; i < kNumTokens; ++i) {
162            if ((size_t)(token - start) == strlen(kTokens[i].option) &&
163                !strncmp(start, kTokens[i].option, strlen(kTokens[i].option))) {
164              if (kTokens[i].flag != 0) {
165                keep_metadata |= kTokens[i].flag;
166              } else {
167                keep_metadata = 0;
168              }
169              break;
170            }
171          }
172          if (i == kNumTokens) {
173            fprintf(stderr, "Error! Unknown metadata type '%.*s'\n",
174                    (int)(token - start), start);
175            Help();
176            FREE_WARGV_AND_RETURN(-1);
177          }
178          start = token + 1;
179        }
180      } else if (!strcmp(argv[c], "-mt")) {
181        ++config.thread_level;
182      } else if (!strcmp(argv[c], "-version")) {
183        const int enc_version = WebPGetEncoderVersion();
184        const int mux_version = WebPGetMuxVersion();
185        printf("WebP Encoder version: %d.%d.%d\nWebP Mux version: %d.%d.%d\n",
186               (enc_version >> 16) & 0xff, (enc_version >> 8) & 0xff,
187               enc_version & 0xff, (mux_version >> 16) & 0xff,
188               (mux_version >> 8) & 0xff, mux_version & 0xff);
189        FREE_WARGV_AND_RETURN(0);
190      } else if (!strcmp(argv[c], "-quiet")) {
191        quiet = 1;
192        enc_options.verbose = 0;
193      } else if (!strcmp(argv[c], "-v")) {
194        verbose = 1;
195        enc_options.verbose = 1;
196      } else if (!strcmp(argv[c], "--")) {
197        if (c < argc - 1) in_file = GET_WARGV(argv, ++c);
198        break;
199      } else if (argv[c][0] == '-') {
200        fprintf(stderr, "Error! Unknown option '%s'\n", argv[c]);
201        Help();
202        FREE_WARGV_AND_RETURN(-1);
203      } else {
<span onclick='openModal()' class='match'>204        in_file = GET_WARGV(argv, c);
205      }
206      if (parse_error) {
207        Help();
</span>208        FREE_WARGV_AND_RETURN(-1);
209      }
210    }
211    if (default_kmin) {
212      enc_options.kmin = config.lossless ? 9 : 3;
213    }
214    if (default_kmax) {
215      enc_options.kmax = config.lossless ? 17 : 5;
216    }
217    if (!WebPValidateConfig(&config)) {
218      fprintf(stderr, "Error! Invalid configuration.\n");
219      goto End;
220    }
221    if (in_file == NULL) {
222      fprintf(stderr, "No input file specified!\n");
223      Help();
224      goto End;
225    }
226    gif = DGifOpenFileUnicode(in_file, &gif_error);
227    if (gif == NULL) goto End;
228    done = 0;
229    do {
230      GifRecordType type;
231      if (DGifGetRecordType(gif, &type) == GIF_ERROR) goto End;
232      switch (type) {
233        case IMAGE_DESC_RECORD_TYPE: {
234          GIFFrameRect gif_rect;
235          GifImageDesc* const image_desc = &gif->Image;
236          if (!DGifGetImageDesc(gif)) goto End;
237          if (frame_number == 0) {
238            if (verbose) {
239              printf("Canvas screen: %d x %d\n", gif->SWidth, gif->SHeight);
240            }
241            if (gif->SWidth == 0 || gif->SHeight == 0) {
242              image_desc->Left = 0;
243              image_desc->Top = 0;
244              gif->SWidth = image_desc->Width;
245              gif->SHeight = image_desc->Height;
246              if (gif->SWidth <= 0 || gif->SHeight <= 0) {
247                goto End;
248              }
249              if (verbose) {
250                printf("Fixed canvas screen dimension to: %d x %d\n",
251                       gif->SWidth, gif->SHeight);
252              }
253            }
254            frame.width = gif->SWidth;
255            frame.height = gif->SHeight;
256            frame.use_argb = 1;
257            if (!WebPPictureAlloc(&frame)) goto End;
258            GIFClearPic(&frame, NULL);
259            WebPPictureCopy(&frame, &curr_canvas);
260            WebPPictureCopy(&frame, &prev_canvas);
261            GIFGetBackgroundColor(gif->SColorMap, gif->SBackGroundColor,
262                                  transparent_index,
263                                  &enc_options.anim_params.bgcolor);
264            enc = WebPAnimEncoderNew(curr_canvas.width, curr_canvas.height,
265                                     &enc_options);
266            if (enc == NULL) {
267              fprintf(stderr,
268                      "Error! Could not create encoder object. Possibly due to "
269                      "a memory error.\n");
270              goto End;
271            }
272          }
273          if (image_desc->Width == 0 || image_desc->Height == 0) {
274            image_desc->Width = gif->SWidth;
275            image_desc->Height = gif->SHeight;
276          }
277          if (!GIFReadFrame(gif, transparent_index, &gif_rect, &frame)) {
278            goto End;
279          }
280          GIFBlendFrames(&frame, &gif_rect, &curr_canvas);
281          if (!WebPAnimEncoderAdd(enc, &curr_canvas, frame_timestamp, &config)) {
282            fprintf(stderr, "Error while adding frame #%d: %s\n", frame_number,
283                    WebPAnimEncoderGetError(enc));
284            goto End;
285          } else {
286            ++frame_number;
287          }
288          GIFDisposeFrame(orig_dispose, &gif_rect, &prev_canvas, &curr_canvas);
289          GIFCopyPixels(&curr_canvas, &prev_canvas);
290          if (frame_duration <= 10) {
291            frame_duration = 100;
292          }
293          frame_timestamp += frame_duration;
294          orig_dispose = GIF_DISPOSE_NONE;
295          frame_duration = 0;
296          transparent_index = GIF_INDEX_INVALID;
297          break;
298        }
299        case EXTENSION_RECORD_TYPE: {
300          int extension;
301          GifByteType* data = NULL;
302          if (DGifGetExtension(gif, &extension, &data) == GIF_ERROR) {
303            goto End;
304          }
305          if (data == NULL) continue;
306          switch (extension) {
307            case COMMENT_EXT_FUNC_CODE: {
308              break;  
309            }
310            case GRAPHICS_EXT_FUNC_CODE: {
311              if (!GIFReadGraphicsExtension(data, &frame_duration, &orig_dispose,
312                                            &transparent_index)) {
313                goto End;
314              }
315              break;
316            }
317            case PLAINTEXT_EXT_FUNC_CODE: {
318              break;
319            }
320            case APPLICATION_EXT_FUNC_CODE: {
321              if (data[0] != 11) break;    
322              if (!memcmp(data + 1, "NETSCAPE2.0", 11) ||
323                  !memcmp(data + 1, "ANIMEXTS1.0", 11)) {
324                if (!GIFReadLoopCount(gif, &data, &loop_count)) {
325                  goto End;
326                }
327                if (verbose) {
328                  fprintf(stderr, "Loop count: %d\n", loop_count);
329                }
330                stored_loop_count = loop_compatibility ? (loop_count != 0) : 1;
331              } else {  
332                const int is_xmp = (keep_metadata & METADATA_XMP) &&
333                                   !stored_xmp &&
334                                   !memcmp(data + 1, "XMP DataXMP", 11);
335                const int is_icc = (keep_metadata & METADATA_ICC) &&
336                                   !stored_icc &&
337                                   !memcmp(data + 1, "ICCRGBG1012", 11);
338                if (is_xmp || is_icc) {
339                  if (!GIFReadMetadata(gif, &data,
340                                       is_xmp ? &xmp_data : &icc_data)) {
341                    goto End;
342                  }
343                  if (is_icc) {
344                    stored_icc = 1;
345                  } else if (is_xmp) {
346                    stored_xmp = 1;
347                  }
348                }
349              }
350              break;
351            }
352            default: {
353              break;  
354            }
355          }
356          while (data != NULL) {
357            if (DGifGetExtensionNext(gif, &data) == GIF_ERROR) goto End;
358          }
359          break;
360        }
361        case TERMINATE_RECORD_TYPE: {
362          done = 1;
363          break;
364        }
365        default: {
366          if (verbose) {
367            fprintf(stderr, "Skipping over unknown record type %d\n", type);
368          }
369          break;
370        }
371      }
372    } while (!done);
373    if (!WebPAnimEncoderAdd(enc, NULL, frame_timestamp, NULL)) {
374      fprintf(stderr, "Error flushing WebP muxer.\n");
375      fprintf(stderr, "%s\n", WebPAnimEncoderGetError(enc));
376    }
377    if (!WebPAnimEncoderAssemble(enc, &webp_data)) {
378      fprintf(stderr, "%s\n", WebPAnimEncoderGetError(enc));
379      goto End;
380    }
381    if (!loop_compatibility) {
382      if (!stored_loop_count) {
383        if (frame_number > 1) {
384          stored_loop_count = 1;
385          loop_count = 1;
386        }
387      } else if (loop_count > 0 && loop_count < 65535) {
388        loop_count += 1;
389      }
390    }
391    if (loop_count == 0) stored_loop_count = 0;
392    if (stored_loop_count || stored_icc || stored_xmp) {
393      mux = WebPMuxCreate(&webp_data, 1);
394      if (mux == NULL) {
395        fprintf(stderr, "ERROR: Could not re-mux to add loop count/metadata.\n");
396        goto End;
397      }
398      WebPDataClear(&webp_data);
399      if (stored_loop_count) {  
400        WebPMuxAnimParams new_params;
401        err = WebPMuxGetAnimationParams(mux, &new_params);
402        if (err != WEBP_MUX_OK) {
403          fprintf(stderr, "ERROR (%s): Could not fetch loop count.\n",
404                  ErrorString(err));
405          goto End;
406        }
407        new_params.loop_count = loop_count;
408        err = WebPMuxSetAnimationParams(mux, &new_params);
409        if (err != WEBP_MUX_OK) {
410          fprintf(stderr, "ERROR (%s): Could not update loop count.\n",
411                  ErrorString(err));
412          goto End;
413        }
414      }
415      if (stored_icc) {   
416        err = WebPMuxSetChunk(mux, "ICCP", &icc_data, 1);
417        if (verbose) {
418          fprintf(stderr, "ICC size: %d\n", (int)icc_data.size);
419        }
420        if (err != WEBP_MUX_OK) {
421          fprintf(stderr, "ERROR (%s): Could not set ICC chunk.\n",
422                  ErrorString(err));
423          goto End;
424        }
425      }
426      if (stored_xmp) {   
427        err = WebPMuxSetChunk(mux, "XMP ", &xmp_data, 1);
428        if (verbose) {
429          fprintf(stderr, "XMP size: %d\n", (int)xmp_data.size);
430        }
431        if (err != WEBP_MUX_OK) {
432          fprintf(stderr, "ERROR (%s): Could not set XMP chunk.\n",
433                  ErrorString(err));
434          goto End;
435        }
436      }
437      err = WebPMuxAssemble(mux, &webp_data);
438      if (err != WEBP_MUX_OK) {
439        fprintf(stderr, "ERROR (%s): Could not assemble when re-muxing to add "
440                "loop count/metadata.\n", ErrorString(err));
441        goto End;
442      }
443    }
444    if (out_file != NULL) {
445      if (!ImgIoUtilWriteFile((const char*)out_file, webp_data.bytes,
446                              webp_data.size)) {
447        WFPRINTF(stderr, "Error writing output file: %s\n", out_file);
448        goto End;
449      }
450      if (!quiet) {
451        if (!WSTRCMP(out_file, "-")) {
452          fprintf(stderr, "Saved %d bytes to STDIO\n",
453                  (int)webp_data.size);
454        } else {
455          WFPRINTF(stderr, "Saved output file (%d bytes): %s\n",
456                   (int)webp_data.size, out_file);
457        }
458      }
459    } else {
460      if (!quiet) {
461        fprintf(stderr, "Nothing written; use -o flag to save the result "
462                        "(%d bytes).\n", (int)webp_data.size);
463      }
464    }
465    ok = 1;
466    gif_error = GIF_OK;
467   End:
468    WebPDataClear(&icc_data);
469    WebPDataClear(&xmp_data);
470    WebPMuxDelete(mux);
471    WebPDataClear(&webp_data);
472    WebPPictureFree(&frame);
473    WebPPictureFree(&curr_canvas);
474    WebPPictureFree(&prev_canvas);
475    WebPAnimEncoderDelete(enc);
476    if (gif_error != GIF_OK) {
477      GIFDisplayError(gif, gif_error);
478    }
479    if (gif != NULL) {
480  #if LOCAL_GIF_PREREQ(5,1)
481      DGifCloseFile(gif, &gif_error);
482  #else
483      DGifCloseFile(gif);
484  #endif
485    }
486    FREE_WARGV_AND_RETURN(!ok);
487  }
488  #else  
489  int main(int argc, const char* argv[]) {
490    fprintf(stderr, "GIF support not enabled in %s.\n", argv[0]);
491    (void)argc;
492    return 0;
493  }
494  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_neon.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-gif2webp.c</div>
                </div>
                <div class="column column_space"><pre><code>1192      sum_top = vcombine_u16(p3, p3);
1193    }
1194    if (do_left) {
1195      int i;
</pre></code></div>
                <div class="column column_space"><pre><code>204        in_file = GET_WARGV(argv, c);
205      }
206      if (parse_error) {
207        Help();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    