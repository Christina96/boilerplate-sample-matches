
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.707275803722504%, Tokens: 8</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8i_enc.h</h3>
            <pre><code>1  #ifndef WEBP_ENC_VP8I_ENC_H_
2  #define WEBP_ENC_VP8I_ENC_H_
3  #include <string.h>     
4  #include "src/dec/common_dec.h"
5  #include "src/dsp/dsp.h"
6  #include "src/utils/bit_writer_utils.h"
7  #include "src/utils/thread_utils.h"
8  #include "src/utils/utils.h"
9  #include "src/webp/encode.h"
10  #ifdef __cplusplus
11  extern "C" {
12  #endif
13  #define ENC_MAJ_VERSION 1
14  #define ENC_MIN_VERSION 1
15  #define ENC_REV_VERSION 0
16  enum { MAX_LF_LEVELS = 64,       
17         MAX_VARIABLE_LEVEL = 67,  
18         MAX_LEVEL = 2047          
19       };
20  typedef enum {   
21    RD_OPT_NONE        = 0,  
22    RD_OPT_BASIC       = 1,  
23    RD_OPT_TRELLIS     = 2,  
24    RD_OPT_TRELLIS_ALL = 3   
25  } VP8RDLevel;
26  #define YUV_SIZE_ENC (BPS * 16)
27  #define PRED_SIZE_ENC (32 * BPS + 16 * BPS + 8 * BPS)   
28  #define Y_OFF_ENC    (0)
29  #define U_OFF_ENC    (16)
30  #define V_OFF_ENC    (16 + 8)
31  extern const uint16_t VP8Scan[16];
32  extern const uint16_t VP8UVModeOffsets[4];
33  extern const uint16_t VP8I16ModeOffsets[4];
34  extern const uint16_t VP8I4ModeOffsets[NUM_BMODES];
35  #define I16DC16 (0 * 16 * BPS)
36  #define I16TM16 (I16DC16 + 16)
37  #define I16VE16 (1 * 16 * BPS)
38  #define I16HE16 (I16VE16 + 16)
39  #define C8DC8 (2 * 16 * BPS)
40  #define C8TM8 (C8DC8 + 1 * 16)
41  #define C8VE8 (2 * 16 * BPS + 8 * BPS)
42  #define C8HE8 (C8VE8 + 1 * 16)
43  #define I4DC4 (3 * 16 * BPS +  0)
44  #define I4TM4 (I4DC4 +  4)
45  #define I4VE4 (I4DC4 +  8)
46  #define I4HE4 (I4DC4 + 12)
47  #define I4RD4 (I4DC4 + 16)
48  #define I4VR4 (I4DC4 + 20)
49  #define I4LD4 (I4DC4 + 24)
50  #define I4VL4 (I4DC4 + 28)
51  #define I4HD4 (3 * 16 * BPS + 4 * BPS)
52  #define I4HU4 (I4HD4 + 4)
53  #define I4TMP (I4HD4 + 8)
54  typedef int64_t score_t;     
55  #define MAX_COST ((score_t)0x7fffffffffffffLL)
56  #define QFIX 17
57  #define BIAS(b)  ((b) << (QFIX - 8))
58  static WEBP_INLINE int QUANTDIV(uint32_t n, uint32_t iQ, uint32_t B) {
59    return (int)((n * iQ + B) >> QFIX);
60  }
61  #define ERROR_DIFFUSION_QUALITY 98
62  typedef uint32_t proba_t;   
63  typedef uint8_t ProbaArray[NUM_CTX][NUM_PROBAS];
64  typedef proba_t StatsArray[NUM_CTX][NUM_PROBAS];
65  typedef uint16_t CostArray[NUM_CTX][MAX_VARIABLE_LEVEL + 1];
66  typedef const uint16_t* (*CostArrayPtr)[NUM_CTX];   
67  typedef const uint16_t* CostArrayMap[16][NUM_CTX];
68  typedef double LFStats[NUM_MB_SEGMENTS][MAX_LF_LEVELS];  
69  typedef struct VP8Encoder VP8Encoder;
70  typedef struct {
71    int num_segments_;      
72    int update_map_;        
73    int size_;              
74  } VP8EncSegmentHeader;
75  typedef struct {
76    uint8_t segments_[3];     
77    uint8_t skip_proba_;      
78    ProbaArray coeffs_[NUM_TYPES][NUM_BANDS];      
79    StatsArray stats_[NUM_TYPES][NUM_BANDS];       
80    CostArray level_cost_[NUM_TYPES][NUM_BANDS];   
81    CostArrayMap remapped_costs_[NUM_TYPES];       
82    int dirty_;               
83    int use_skip_proba_;      
84    int nb_skip_;             
85  } VP8EncProba;
86  typedef struct {
87    int simple_;             
88    int level_;              
89    int sharpness_;          
90    int i4x4_lf_delta_;      
91  } VP8EncFilterHeader;
92  typedef struct {
<span onclick='openModal()' class='match'>93    unsigned int type_:2;     
94    unsigned int uv_mode_:2;
95    unsigned int skip_:1;
96    unsigned int segment_:2;
97    uint8_t alpha_;      
98  } VP8MBInfo;
</span>99  typedef struct VP8Matrix {
100    uint16_t q_[16];        
101    uint16_t iq_[16];       
102    uint32_t bias_[16];     
103    uint32_t zthresh_[16];  
104    uint16_t sharpen_[16];  
105  } VP8Matrix;
106  typedef struct {
107    VP8Matrix y1_, y2_, uv_;  
108    int alpha_;      
109    int beta_;       
110    int quant_;      
111    int fstrength_;  
112    int max_edge_;   
113    int min_disto_;  
114    int lambda_i16_, lambda_i4_, lambda_uv_;
115    int lambda_mode_, lambda_trellis_, tlambda_;
116    int lambda_trellis_i16_, lambda_trellis_i4_, lambda_trellis_uv_;
117    score_t i4_penalty_;   
118  } VP8SegmentInfo;
119  typedef int8_t DError[2 &bsol;* u/v */][2 &bsol;* top or left */];
120  typedef struct {
121    score_t D, SD;              
122    score_t H, R, score;        
123    int16_t y_dc_levels[16];    
124    int16_t y_ac_levels[16][16];
125    int16_t uv_levels[4 + 4][16];
126    int mode_i16;               
127    uint8_t modes_i4[16];       
128    int mode_uv;                
129    uint32_t nz;                
130    int8_t derr[2][3];          
131  } VP8ModeScore;
132  typedef struct {
133    int x_, y_;                      
134    uint8_t*      yuv_in_;           
135    uint8_t*      yuv_out_;          
136    uint8_t*      yuv_out2_;         
137    uint8_t*      yuv_p_;            
138    VP8Encoder*   enc_;              
139    VP8MBInfo*    mb_;               
140    VP8BitWriter* bw_;               
141    uint8_t*      preds_;            
142    uint32_t*     nz_;               
143    uint8_t       i4_boundary_[37];  
144    uint8_t*      i4_top_;           
145    int           i4_;               
146    int           top_nz_[9];        
147    int           left_nz_[9];       
148    uint64_t      bit_count_[4][3];  
149    uint64_t      luma_bits_;        
150    uint64_t      uv_bits_;          
151    LFStats*      lf_stats_;         
152    int           do_trellis_;       
153    int           count_down_;       
154    int           count_down0_;      
155    int           percent0_;         
156    DError        left_derr_;        
157    DError*       top_derr_;         
158    uint8_t* y_left_;    
159    uint8_t* u_left_;    
160    uint8_t* v_left_;    
161    uint8_t* y_top_;     
162    uint8_t* uv_top_;    
163    uint8_t yuv_left_mem_[17 + 16 + 16 + 8 + WEBP_ALIGN_CST];
164    uint8_t yuv_mem_[3 * YUV_SIZE_ENC + PRED_SIZE_ENC + WEBP_ALIGN_CST];
165  } VP8EncIterator;
166  void VP8IteratorInit(VP8Encoder* const enc, VP8EncIterator* const it);
167  void VP8IteratorReset(VP8EncIterator* const it);
168  void VP8IteratorSetRow(VP8EncIterator* const it, int y);
169  void VP8IteratorSetCountDown(VP8EncIterator* const it, int count_down);
170  int VP8IteratorIsDone(const VP8EncIterator* const it);
171  void VP8IteratorImport(VP8EncIterator* const it, uint8_t* const tmp_32);
172  void VP8IteratorExport(const VP8EncIterator* const it);
173  int VP8IteratorNext(VP8EncIterator* const it);
174  void VP8IteratorSaveBoundary(VP8EncIterator* const it);
175  int VP8IteratorProgress(const VP8EncIterator* const it,
176                          int final_delta_percent);
177  void VP8IteratorStartI4(VP8EncIterator* const it);
178  int VP8IteratorRotateI4(VP8EncIterator* const it,
179                          const uint8_t* const yuv_out);
180  void VP8IteratorNzToBytes(VP8EncIterator* const it);
181  void VP8IteratorBytesToNz(VP8EncIterator* const it);
182  void VP8SetIntra16Mode(const VP8EncIterator* const it, int mode);
183  void VP8SetIntra4Mode(const VP8EncIterator* const it, const uint8_t* modes);
184  void VP8SetIntraUVMode(const VP8EncIterator* const it, int mode);
185  void VP8SetSkip(const VP8EncIterator* const it, int skip);
186  void VP8SetSegment(const VP8EncIterator* const it, int segment);
187  typedef struct VP8Tokens VP8Tokens;  
188  typedef struct {
189  #if !defined(DISABLE_TOKEN_BUFFER)
190    VP8Tokens* pages_;        
191    VP8Tokens** last_page_;   
192    uint16_t* tokens_;        
193    int left_;                
194    int page_size_;           
195  #endif
196    int error_;         
197  } VP8TBuffer;
198  void VP8TBufferInit(VP8TBuffer* const b, int page_size);
199  void VP8TBufferClear(VP8TBuffer* const b);   
200  #if !defined(DISABLE_TOKEN_BUFFER)
201  int VP8EmitTokens(VP8TBuffer* const b, VP8BitWriter* const bw,
202                    const uint8_t* const probas, int final_pass);
203  int VP8RecordCoeffTokens(int ctx, const struct VP8Residual* const res,
204                           VP8TBuffer* const tokens);
205  size_t VP8EstimateTokenSize(VP8TBuffer* const b, const uint8_t* const probas);
206  #endif  
207  struct VP8Encoder {
208    const WebPConfig* config_;    
209    WebPPicture* pic_;            
210    VP8EncFilterHeader   filter_hdr_;     
211    VP8EncSegmentHeader  segment_hdr_;    
212    int profile_;                      
213    int mb_w_, mb_h_;
214    int preds_w_;   
215    int num_parts_;
216    VP8BitWriter bw_;                         
217    VP8BitWriter parts_[MAX_NUM_PARTITIONS];  
218    VP8TBuffer tokens_;                       
219    int percent_;                             
220    int has_alpha_;
221    uint8_t* alpha_data_;       
222    uint32_t alpha_data_size_;
223    WebPWorker alpha_worker_;
224    VP8SegmentInfo dqm_[NUM_MB_SEGMENTS];
225    int base_quant_;                 
226    int alpha_;                      
227    int uv_alpha_;                   
228    int dq_y1_dc_;
229    int dq_y2_dc_, dq_y2_ac_;
230    int dq_uv_dc_, dq_uv_ac_;
231    VP8EncProba proba_;
232    uint64_t    sse_[4];      
233    uint64_t    sse_count_;   
234    int         coded_size_;
235    int         residual_bytes_[3][4];
236    int         block_count_[3];
237    int method_;               
238    VP8RDLevel rd_opt_level_;  
239    int max_i4_header_bits_;   
240    int mb_header_limit_;      
241    int thread_level_;         
242    int do_search_;            
243    int use_tokens_;           
244    VP8MBInfo* mb_info_;   
245    uint8_t*   preds_;     
246    uint32_t*  nz_;        
247    uint8_t*   y_top_;     
248    uint8_t*   uv_top_;    
249    LFStats*   lf_stats_;  
250    DError*    top_derr_;  
251  };
252  extern const uint8_t VP8CoeffsProba0[NUM_TYPES][NUM_BANDS][NUM_CTX][NUM_PROBAS];
253  extern const uint8_t
254      VP8CoeffsUpdateProba[NUM_TYPES][NUM_BANDS][NUM_CTX][NUM_PROBAS];
255  void VP8DefaultProbas(VP8Encoder* const enc);
256  void VP8WriteProbas(VP8BitWriter* const bw, const VP8EncProba* const probas);
257  void VP8CodeIntraModes(VP8Encoder* const enc);
258  int VP8EncWrite(VP8Encoder* const enc);
259  void VP8EncFreeBitWriters(VP8Encoder* const enc);
260  extern const uint8_t VP8Cat3[];
261  extern const uint8_t VP8Cat4[];
262  extern const uint8_t VP8Cat5[];
263  extern const uint8_t VP8Cat6[];
264  void VP8MakeLuma16Preds(const VP8EncIterator* const it);
265  void VP8MakeChroma8Preds(const VP8EncIterator* const it);
266  void VP8MakeIntra4Preds(const VP8EncIterator* const it);
267  int VP8GetCostLuma16(VP8EncIterator* const it, const VP8ModeScore* const rd);
268  int VP8GetCostLuma4(VP8EncIterator* const it, const int16_t levels[16]);
269  int VP8GetCostUV(VP8EncIterator* const it, const VP8ModeScore* const rd);
270  int VP8EncLoop(VP8Encoder* const enc);
271  int VP8EncTokenLoop(VP8Encoder* const enc);
272  int WebPEncodingSetError(const WebPPicture* const pic, WebPEncodingError error);
273  int WebPReportProgress(const WebPPicture* const pic,
274                         int percent, int* const percent_store);
275  int VP8EncAnalyze(VP8Encoder* const enc);
276  void VP8SetSegmentParams(VP8Encoder* const enc, float quality);
277  int VP8Decimate(VP8EncIterator* const it, VP8ModeScore* const rd,
278                  VP8RDLevel rd_opt);
279  void VP8EncInitAlpha(VP8Encoder* const enc);    
280  int VP8EncStartAlpha(VP8Encoder* const enc);    
281  int VP8EncFinishAlpha(VP8Encoder* const enc);   
282  int VP8EncDeleteAlpha(VP8Encoder* const enc);   
283  void VP8InitFilter(VP8EncIterator* const it);
284  void VP8StoreFilterStats(VP8EncIterator* const it);
285  void VP8AdjustFilterStrength(VP8EncIterator* const it);
286  int VP8FilterStrengthFromDelta(int sharpness, int delta);
287  void WebPPictureResetBuffers(WebPPicture* const picture);
288  int WebPPictureAllocARGB(WebPPicture* const picture, int width, int height);
289  int WebPPictureAllocYUVA(WebPPicture* const picture, int width, int height);
290  void WebPCleanupTransparentAreaLossless(WebPPicture* const pic);
291  #ifdef __cplusplus
292  }    
293  #endif
294  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_CCM_MODE
3  int ccm_test(void)
4  {
5  #ifndef LTC_TEST
6     return CRYPT_NOP;
7  #else
8     static const struct {
9         unsigned char key[16];
10         unsigned char nonce[16];
11         int           noncelen;
12         unsigned char header[64];
13         int           headerlen;
14         unsigned char pt[64];
<span onclick='openModal()' class='match'>15         int           ptlen;
16         unsigned char ct[64];
17         unsigned char tag[16];
18         unsigned long taglen;
19     } tests[] = {
</span>20  {
21     { 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
22       0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF },
23     { 0x00, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0xA0,
24       0xA1, 0xA2, 0xA3, 0xA4, 0xA5 },
25     13,
26     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 },
27     8,
28     { 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
29       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
30       0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E },
31     23,
32     { 0x58, 0x8C, 0x97, 0x9A, 0x61, 0xC6, 0x63, 0xD2,
33       0xF0, 0x66, 0xD0, 0xC2, 0xC0, 0xF9, 0x89, 0x80,
34       0x6D, 0x5F, 0x6B, 0x61, 0xDA, 0xC3, 0x84 },
35     { 0x17, 0xe8, 0xd1, 0x2c, 0xfd, 0xf9, 0x26, 0xe0 },
36     8
37  },
38  {
39     { 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
40       0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF },
41     { 0x00, 0x00, 0x00, 0x06, 0x05, 0x04, 0x03, 0xA0,
42       0xA1, 0xA2, 0xA3, 0xA4, 0xA5 },
43     13,
44     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
45       0x08, 0x09, 0x0A, 0x0B },
46     12,
47     { 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13,
48       0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B,
49       0x1C, 0x1D, 0x1E },
50     19,
51     { 0xA2, 0x8C, 0x68, 0x65, 0x93, 0x9A, 0x9A, 0x79,
52       0xFA, 0xAA, 0x5C, 0x4C, 0x2A, 0x9D, 0x4A, 0x91,
53       0xCD, 0xAC, 0x8C },
54     { 0x96, 0xC8, 0x61, 0xB9, 0xC9, 0xE6, 0x1E, 0xF1 },
55     8
56  },
57  {
58     { 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
59       0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f },
60     { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16  },
61     7,
62     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 },
63     8,
64     { 0x20, 0x21, 0x22, 0x23 },
65     4,
66     { 0x71, 0x62, 0x01, 0x5b },
67     { 0x4d, 0xac, 0x25, 0x5d },
68     4
69  },
70  {
71     { 0xc9, 0x7c, 0x1f, 0x67, 0xce, 0x37, 0x11, 0x85,
72       0x51, 0x4a, 0x8a, 0x19, 0xf2, 0xbd, 0xd5, 0x2f },
73     { 0x00, 0x50, 0x30, 0xf1, 0x84, 0x44, 0x08, 0xb5,
74       0x03, 0x97, 0x76, 0xe7, 0x0c },
75     13,
76     { 0x08, 0x40, 0x0f, 0xd2, 0xe1, 0x28, 0xa5, 0x7c,
77       0x50, 0x30, 0xf1, 0x84, 0x44, 0x08, 0xab, 0xae,
78       0xa5, 0xb8, 0xfc, 0xba, 0x00, 0x00 },
79     22,
80     { 0xf8, 0xba, 0x1a, 0x55, 0xd0, 0x2f, 0x85, 0xae,
81       0x96, 0x7b, 0xb6, 0x2f, 0xb6, 0xcd, 0xa8, 0xeb,
82       0x7e, 0x78, 0xa0, 0x50 },
83     20,
84     { 0xf3, 0xd0, 0xa2, 0xfe, 0x9a, 0x3d, 0xbf, 0x23,
85       0x42, 0xa6, 0x43, 0xe4, 0x32, 0x46, 0xe8, 0x0c,
86       0x3c, 0x04, 0xd0, 0x19 },
87     { 0x78, 0x45, 0xce, 0x0b, 0x16, 0xf9, 0x76, 0x23 },
88     8
89  },
90  };
91     unsigned long taglen, x, y;
92     unsigned char buf[64], buf2[64], tag[16], tag2[16], tag3[16], zero[64];
93     int           err, idx;
94     symmetric_key skey;
95     ccm_state ccm;
96     zeromem(zero, 64);
97     idx = find_cipher("aes");
98     if (idx == -1) {
99        idx = find_cipher("rijndael");
100        if (idx == -1) {
101           return CRYPT_NOP;
102        }
103     }
104     for (x = 0; x < (sizeof(tests)/sizeof(tests[0])); x++) {
105        for (y = 0; y < 2; y++) {
106           taglen = tests[x].taglen;
107           if (y == 0) {
108              if ((err = cipher_descriptor[idx].setup(tests[x].key, 16, 0, &skey)) != CRYPT_OK) {
109                 return err;
110              }
111              if ((err = ccm_memory(idx,
112                                    tests[x].key, 16,
113                                    &skey,
114                                    tests[x].nonce, tests[x].noncelen,
115                                    tests[x].header, tests[x].headerlen,
116                                    (unsigned char*)tests[x].pt, tests[x].ptlen,
117                                    buf,
118                                    tag, &taglen, 0)) != CRYPT_OK) {
119                 return err;
120              }
121              if ((err = ccm_memory(idx,
122                                    tests[x].key, 16,
123                                    &skey,
124                                    tests[x].nonce, tests[x].noncelen,
125                                    tests[x].header, tests[x].headerlen,
126                                    (unsigned char*)tests[x].pt, tests[x].ptlen,
127                                    buf,
128                                    tag, &taglen, 0)) != CRYPT_OK) {
129                 return err;
130              }
131           } else {
132              if ((err = ccm_init(&ccm, idx, tests[x].key, 16, tests[x].ptlen, tests[x].taglen, tests[x].headerlen)) != CRYPT_OK) {
133                 return err;
134              }
135              if ((err = ccm_add_nonce(&ccm, tests[x].nonce, tests[x].noncelen)) != CRYPT_OK) {
136                 return err;
137              }
138              if ((err = ccm_add_aad(&ccm, tests[x].header, tests[x].headerlen)) != CRYPT_OK) {
139                 return err;
140              }
141              if ((err = ccm_process(&ccm, (unsigned char*)tests[x].pt, tests[x].ptlen, buf, CCM_ENCRYPT)) != CRYPT_OK) {
142                 return err;
143              }
144              if ((err = ccm_done(&ccm, tag, &taglen)) != CRYPT_OK) {
145                 return err;
146              }
147           }
148           if (compare_testvector(buf, tests[x].ptlen, tests[x].ct, tests[x].ptlen, "CCM encrypt data", x)) {
149              return CRYPT_FAIL_TESTVECTOR;
150           }
151           if (compare_testvector(tag, taglen, tests[x].tag, tests[x].taglen, "CCM encrypt tag", x)) {
152              return CRYPT_FAIL_TESTVECTOR;
153           }
154           if (y == 0) {
155              XMEMCPY(tag3, tests[x].tag, tests[x].taglen);
156              taglen = tests[x].taglen;
157              if ((err = ccm_memory(idx,
158                                    tests[x].key, 16,
159                                    NULL,
160                                    tests[x].nonce, tests[x].noncelen,
161                                    tests[x].header, tests[x].headerlen,
162                                    buf2, tests[x].ptlen,
163                                    buf,
164                                    tag3, &taglen, 1   )) != CRYPT_OK) {
165                 return err;
166              }
167           } else {
168              if ((err = ccm_init(&ccm, idx, tests[x].key, 16, tests[x].ptlen, tests[x].taglen, tests[x].headerlen)) != CRYPT_OK) {
169                 return err;
170              }
171              if ((err = ccm_add_nonce(&ccm, tests[x].nonce, tests[x].noncelen)) != CRYPT_OK) {
172                 return err;
173              }
174              if ((err = ccm_add_aad(&ccm, tests[x].header, tests[x].headerlen)) != CRYPT_OK) {
175                 return err;
176              }
177              if ((err = ccm_process(&ccm, buf2, tests[x].ptlen, buf, CCM_DECRYPT)) != CRYPT_OK) {
178                 return err;
179              }
180              if ((err = ccm_done(&ccm, tag2, &taglen)) != CRYPT_OK) {
181                 return err;
182              }
183           }
184           if (compare_testvector(buf2, tests[x].ptlen, tests[x].pt, tests[x].ptlen, "CCM decrypt data", x)) {
185              return CRYPT_FAIL_TESTVECTOR;
186           }
187           if (y == 0) {
188              XMEMCPY(tag3, tests[x].tag, tests[x].taglen);
189              tag3[0] ^= 0xff; &bsol;* set the tag to the wrong value */
190              taglen = tests[x].taglen;
191              if ((err = ccm_memory(idx,
192                                    tests[x].key, 16,
193                                    NULL,
194                                    tests[x].nonce, tests[x].noncelen,
195                                    tests[x].header, tests[x].headerlen,
196                                    buf2, tests[x].ptlen,
197                                    buf,
198                                    tag3, &taglen, 1   )) != CRYPT_ERROR) {
199                 return CRYPT_FAIL_TESTVECTOR;
200              }
201              if (compare_testvector(buf2, tests[x].ptlen, zero, tests[x].ptlen, "CCM decrypt wrong tag", x)) {
202                 return CRYPT_FAIL_TESTVECTOR;
203              }
204           } else {
205              if (compare_testvector(tag2, taglen, tests[x].tag, tests[x].taglen, "CCM decrypt tag", x)) {
206                 return CRYPT_FAIL_TESTVECTOR;
207              }
208           }
209           if (y == 0) {
210              cipher_descriptor[idx].done(&skey);
211           }
212        }
213     }
214     {
215        unsigned char key[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };
216        unsigned char iv[]  = { 0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51 };
217        unsigned char valid_tag[]   = { 0x23,0x1a,0x2d,0x8f };
218        unsigned char invalid_tag[] = { 0x23,0x1a,0x2d,0x8f,0x6a };
219        unsigned char msg[] = { 0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f };
220        unsigned char ct[]  = { 0xd3,0xda,0xb1,0xee,0x49,0x4c,0xc2,0x29,0x09,0x9d,0x6c,0xac,0x7d,0xf1,0x4a,0xdd };
221        unsigned char pt[20] = { 0 };
222        taglen = sizeof(valid_tag);
223        err = ccm_memory(idx, key, sizeof(key), NULL, iv, sizeof(iv), NULL, 0,
224                         pt, sizeof(ct), ct, valid_tag, &taglen, CCM_DECRYPT);
225        if ((err != CRYPT_OK) || (XMEMCMP(msg, pt, sizeof(msg)) != 0)) {
226           return CRYPT_FAIL_TESTVECTOR;
227        }
228        taglen = sizeof(invalid_tag);
229        err = ccm_memory(idx, key, sizeof(key), NULL, iv, sizeof(iv), NULL, 0,
230                         pt, sizeof(ct), ct, invalid_tag, &taglen, CCM_DECRYPT);
231        if (err == CRYPT_OK) {
232           return CRYPT_FAIL_TESTVECTOR; &bsol;* should fail */
233        }
234     }
235     return CRYPT_OK;
236  #endif
237  }
238  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8i_enc.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_test.c</div>
                <div class="column column_space"><pre><code>93    unsigned int type_:2;     
94    unsigned int uv_mode_:2;
95    unsigned int skip_:1;
96    unsigned int segment_:2;
97    uint8_t alpha_;      
98  } VP8MBInfo;
</pre></code></div>
                <div class="column column_space"><pre><code>15         int           ptlen;
16         unsigned char ct[64];
17         unsigned char tag[16];
18         unsigned long taglen;
19     } tests[] = {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    