<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for dummy_1.c & mmcount.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for dummy_1.c & mmcount.c
      </h3>
      <h1 align="center">
        10.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>dummy_1.c (56.0%)<TH>mmcount.c (5.882353%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match805-0.html#0',2,'match805-1.html#0',3)" NAME="0">(54-66)<TD><A HREF="javascript:ZweiFrames('match805-0.html#0',2,'match805-1.html#0',3)" NAME="0">(64-74)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>dummy_1.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* a dummy module to be loaded if we cannot build this module, but
 * configure required it to be &quot;optional&quot;.
 *
 * Copyright 2020 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;pthread.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parserif.h&quot;

#define MODULE_NAME(x) #x

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(MODULE_NAME(MODNAME))


DEF_OMOD_STATIC_DATA

<A NAME="0"></A>/* config variables */
typedef struct _instanceData {
	char *dummy;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match805-1.html#0',3,'match805-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

struct modConfData_s {
};

/* modConf ptr to use for the current load process */
static modConfData_t *loadModConf = NULL;
/* modConf ptr to use for the current exec process */
static modConfData_t *runModConf  = NULL;</B></FONT>




BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


BEGINsetModCnf
CODESTARTsetModCnf
	(void) lst;
	parser_errmsg(&quot;%s is an optional module which could not be built on your platform &quot;
		&quot;please remove it from the configuration or upgrade your platform&quot;, MODULE_NAME(MODNAME));
ENDsetModCnf


BEGINnewActInst
CODESTARTnewActInst
	(void) pData;
	(void) ppModData;
	parser_errmsg(&quot;%s is an optional module which could not be built on your platform &quot;
		&quot;please remove it from the configuration or upgrade your platform&quot;, MODULE_NAME(MODNAME));
ENDnewActInst


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


BEGINdoAction_NoStrings
CODESTARTdoAction
	(void) pMsgData;
ENDdoAction


NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	/* we only support the current interface specification */
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	dbgprintf(&quot;dummy module compiled with rsyslog version %s.\n&quot;, VERSION);
ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmcount.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmcount.c
 * count messages by priority or json property of given app-name.
 *
 * Copyright 2013 Red Hat Inc.
 * Copyright 2014 Rainer Gerhards
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;json.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;hashtable.h&quot;


#define JSON_COUNT_NAME &quot;!mmcount&quot;
#define SEVERITY_COUNT 8

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;mmcount&quot;)


DEF_OMOD_STATIC_DATA

/* config variables */

typedef struct _instanceData {
	char *pszAppName;
	int severity[SEVERITY_COUNT];
	char *pszKey;
	char *pszValue;
<A NAME="0"></A>	int valueCounter;
	struct hashtable *ht;
	pthread_mutex_t mut;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match805-0.html#0',2,'match805-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */</B></FONT>


/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;appname&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;key&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;value&quot;, eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
	pthread_mutex_init(&amp;pData-&gt;mut, NULL);
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance

static inline void
setInstParamDefaults(instanceData *pData)
{
	int i;

	pData-&gt;pszAppName = NULL;
	for (i = 0; i &lt; SEVERITY_COUNT; i++)
	        pData-&gt;severity[i] = 0;
	pData-&gt;pszKey = NULL;
	pData-&gt;pszValue = NULL;
	pData-&gt;valueCounter = 0;
	pData-&gt;ht = NULL;
}

static unsigned int
hash_from_key_fn(void *k)
{
	return *(unsigned int *)k;
}

static int
key_equals_fn(void *k1, void *k2)
{
	return (*(unsigned int *)k1 == *(unsigned int *)k2);
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF(&quot;newActInst (mmcount)\n&quot;);
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;appname&quot;)) {
			pData-&gt;pszAppName = es_str2cstr(pvals[i].val.d.estr, NULL);
			continue;
		}
		if(!strcmp(actpblk.descr[i].name, &quot;key&quot;)) {
			pData-&gt;pszKey = es_str2cstr(pvals[i].val.d.estr, NULL);
			continue;
		}
		if(!strcmp(actpblk.descr[i].name, &quot;value&quot;)) {
			pData-&gt;pszValue = es_str2cstr(pvals[i].val.d.estr, NULL);
			continue;
		}
		dbgprintf(&quot;mmcount: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
	}

	if(pData-&gt;pszAppName == NULL) {
		dbgprintf(&quot;mmcount: action requires a appname&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(pData-&gt;pszKey != NULL &amp;&amp; pData-&gt;pszValue == NULL) {
		if(NULL == (pData-&gt;ht = create_hashtable(100, hash_from_key_fn, key_equals_fn, NULL))) {
			DBGPRINTF(&quot;mmcount: error creating hash table!\n&quot;);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume

static int *
getCounter(struct hashtable *ht, const char *str) {
	unsigned int key;
	int *pCounter;
	unsigned int *pKey;

	/* we dont store str as key, instead we store hash of the str
	   as key to reduce memory usage */
	key = hash_from_string((char*)str);
	pCounter = hashtable_search(ht, &amp;key);
	if(pCounter) {
		return pCounter;
	}

	/* counter is not found for the str, so add new entry and
	   return the counter */
	if(NULL == (pKey = (unsigned int*)malloc(sizeof(unsigned int)))) {
		DBGPRINTF(&quot;mmcount: memory allocation for key failed\n&quot;);
		return NULL;
	}
	*pKey = key;

	if(NULL == (pCounter = (int*)malloc(sizeof(int)))) {
		DBGPRINTF(&quot;mmcount: memory allocation for value failed\n&quot;);
		free(pKey);
		return NULL;
	}
	*pCounter = 0;

	if(!hashtable_insert(ht, pKey, pCounter)) {
		DBGPRINTF(&quot;mmcount: inserting element into hashtable failed\n&quot;);
		free(pKey);
		free(pCounter);
		return NULL;
	}
	return pCounter;
}

BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	char *appname;
	struct json_object *json = NULL;
	struct json_object *keyjson = NULL;
	const char *pszValue;
	int *pCounter;
	instanceData *const pData = pWrkrData-&gt;pData;
CODESTARTdoAction
	appname = getAPPNAME(pMsg, LOCK_MUTEX);

	pthread_mutex_lock(&amp;pData-&gt;mut);
	if(0 != strcmp(appname, pData-&gt;pszAppName)) {
		/* we are not working for this appname. nothing to do */
		ABORT_FINALIZE(RS_RET_OK);
	}

	if(!pData-&gt;pszKey) {
		/* no key given for count, so we count severity */
		if(pMsg-&gt;iSeverity &lt; SEVERITY_COUNT) {
			pData-&gt;severity[pMsg-&gt;iSeverity]++;
			json = json_object_new_int(pData-&gt;severity[pMsg-&gt;iSeverity]);
		}
		ABORT_FINALIZE(RS_RET_OK);
	}

	/* key is given, so get the property json */
	msgPropDescr_t pProp;
	msgPropDescrFill(&amp;pProp, (uchar*)pData-&gt;pszKey, strlen(pData-&gt;pszKey));
	rsRetVal localRet = msgGetJSONPropJSON(pMsg, &amp;pProp, &amp;keyjson);
	msgPropDescrDestruct(&amp;pProp);
	if(localRet != RS_RET_OK) {
		/* key not found in the message. nothing to do */
		ABORT_FINALIZE(RS_RET_OK);
	}

	/* key found, so get the value */
	pszValue = (char*)json_object_get_string(keyjson);
	if(pszValue == NULL) { /* json null object returns NULL! */
		pszValue = &quot;&quot;;
	}

	if(pData-&gt;pszValue) {
		/* value also given for count */
		if(!strcmp(pszValue, pData-&gt;pszValue)) {
			/* count for (value and key and appname) matched */
			pData-&gt;valueCounter++;
			json = json_object_new_int(pData-&gt;valueCounter);
		}
		ABORT_FINALIZE(RS_RET_OK);
	}

	/* value is not given, so we count for each value of given key */
	pCounter = getCounter(pData-&gt;ht, pszValue);
	if(pCounter) {
		(*pCounter)++;
		json = json_object_new_int(*pCounter);
	}
finalize_it:
	pthread_mutex_unlock(&amp;pData-&gt;mut);

	if(json) {
		msgAddJSON(pMsg, (uchar *)JSON_COUNT_NAME, json, 0, 0);
	}
ENDdoAction


NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt



BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF(&quot;mmcount: module compiled with rsyslog version %s.\n&quot;, VERSION);
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
