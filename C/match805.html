<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for dummy_1.c &amp; mmcount.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for dummy_1.c &amp; mmcount.c
      </h3>
<h1 align="center">
        10.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>dummy_1.c (56.0%)<th>mmcount.c (5.882353%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(54-66)<td><a href="#" name="0">(64-74)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>dummy_1.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include &lt;pthread.h&gt;
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "parserif.h"
20 #define MODULE_NAME(x) #x
21 MODULE_TYPE_OUTPUT
22 MODULE_TYPE_NOKEEP
23 MODULE_CNFNAME(MODULE_NAME(MODNAME))
24 DEF_OMOD_STATIC_DATA
25 <a name="0"></a>typedef struct _instanceData {
26 	char *dummy;
27 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>} instanceData;
28 typedef struct wrkrInstanceData {
29 	instanceData *pData;
30 } wrkrInstanceData_t;
31 struct modConfData_s {
32 };
33 static modConfData_t *loadModConf = NULL;
34 static modConfData_t *runModConf  = NULL;</b></font>
35 BEGINbeginCnfLoad
36 CODESTARTbeginCnfLoad
37 	loadModConf = pModConf;
38 ENDbeginCnfLoad
39 BEGINendCnfLoad
40 CODESTARTendCnfLoad
41 ENDendCnfLoad
42 BEGINcheckCnf
43 CODESTARTcheckCnf
44 ENDcheckCnf
45 BEGINactivateCnf
46 CODESTARTactivateCnf
47 	runModConf = pModConf;
48 ENDactivateCnf
49 BEGINfreeCnf
50 CODESTARTfreeCnf
51 ENDfreeCnf
52 BEGINcreateWrkrInstance
53 CODESTARTcreateWrkrInstance
54 ENDcreateWrkrInstance
55 BEGINisCompatibleWithFeature
56 CODESTARTisCompatibleWithFeature
57 ENDisCompatibleWithFeature
58 BEGINfreeInstance
59 CODESTARTfreeInstance
60 ENDfreeInstance
61 BEGINfreeWrkrInstance
62 CODESTARTfreeWrkrInstance
63 ENDfreeWrkrInstance
64 BEGINsetModCnf
65 CODESTARTsetModCnf
66 	(void) lst;
67 	parser_errmsg("%s is an optional module which could not be built on your platform "
68 		"please remove it from the configuration or upgrade your platform", MODULE_NAME(MODNAME));
69 ENDsetModCnf
70 BEGINnewActInst
71 CODESTARTnewActInst
72 	(void) pData;
73 	(void) ppModData;
74 	parser_errmsg("%s is an optional module which could not be built on your platform "
75 		"please remove it from the configuration or upgrade your platform", MODULE_NAME(MODNAME));
76 ENDnewActInst
77 BEGINdbgPrintInstInfo
78 CODESTARTdbgPrintInstInfo
79 ENDdbgPrintInstInfo
80 BEGINtryResume
81 CODESTARTtryResume
82 ENDtryResume
83 BEGINdoAction_NoStrings
84 CODESTARTdoAction
85 	(void) pMsgData;
86 ENDdoAction
87 NO_LEGACY_CONF_parseSelectorAct
88 BEGINmodExit
89 CODESTARTmodExit
90 ENDmodExit
91 BEGINqueryEtryPt
92 CODESTARTqueryEtryPt
93 CODEqueryEtryPt_STD_OMOD_QUERIES
94 CODEqueryEtryPt_STD_OMOD8_QUERIES
95 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
96 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
97 CODEqueryEtryPt_STD_CONF2_QUERIES
98 ENDqueryEtryPt
99 BEGINmodInit()
100 CODESTARTmodInit
101 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
102 CODEmodInit_QueryRegCFSLineHdlr
103 	dbgprintf("dummy module compiled with rsyslog version %s.\n", VERSION);
104 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmcount.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include &lt;json.h&gt;
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "hashtable.h"
20 #define JSON_COUNT_NAME "!mmcount"
21 #define SEVERITY_COUNT 8
22 MODULE_TYPE_OUTPUT
23 MODULE_TYPE_NOKEEP
24 MODULE_CNFNAME("mmcount")
25 DEF_OMOD_STATIC_DATA
26 typedef struct _instanceData {
27 	char *pszAppName;
28 	int severity[SEVERITY_COUNT];
29 	char *pszKey;
30 	char *pszValue;
31 <a name="0"></a>	int valueCounter;
32 	struct hashtable *ht;
33 	pthread_mutex_t mut;
34 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>} instanceData;
35 typedef struct wrkrInstanceData {
36 	instanceData *pData;
37 } wrkrInstanceData_t;
38 struct modConfData_s {
39 	rsconf_t *pConf;	};
40 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
41 static struct cnfparamdescr actpdescr[] = {
42 	{ "appname", eCmdHdlrGetWord, 0 },
43 	{ "key", eCmdHdlrGetWord, 0 },
44 	{ "value", eCmdHdlrGetWord, 0 },
45 };
46 static struct cnfparamblk actpblk =
47 	{ CNFPARAMBLK_VERSION,
48 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
49 	  actpdescr
50 	};
51 BEGINbeginCnfLoad
52 CODESTARTbeginCnfLoad
53 	loadModConf = pModConf;
54 	pModConf-&gt;pConf = pConf;
55 ENDbeginCnfLoad
56 BEGINendCnfLoad
57 CODESTARTendCnfLoad
58 ENDendCnfLoad
59 BEGINcheckCnf
60 CODESTARTcheckCnf
61 ENDcheckCnf
62 BEGINactivateCnf
63 CODESTARTactivateCnf
64 	runModConf = pModConf;
65 ENDactivateCnf
66 BEGINfreeCnf
67 CODESTARTfreeCnf
68 ENDfreeCnf
69 BEGINcreateInstance
70 CODESTARTcreateInstance
71 	pthread_mutex_init(&amp;pData-&gt;mut, NULL);
72 ENDcreateInstance
73 BEGINcreateWrkrInstance
74 CODESTARTcreateWrkrInstance
75 ENDcreateWrkrInstance
76 BEGINisCompatibleWithFeature
77 CODESTARTisCompatibleWithFeature
78 ENDisCompatibleWithFeature
79 BEGINfreeInstance
80 CODESTARTfreeInstance
81 ENDfreeInstance
82 BEGINfreeWrkrInstance
83 CODESTARTfreeWrkrInstance
84 ENDfreeWrkrInstance
85 static inline void
86 setInstParamDefaults(instanceData *pData)
87 {
88 	int i;
89 	pData-&gt;pszAppName = NULL;
90 	for (i = 0; i &lt; SEVERITY_COUNT; i++)
91 	        pData-&gt;severity[i] = 0;
92 	pData-&gt;pszKey = NULL;
93 	pData-&gt;pszValue = NULL;
94 	pData-&gt;valueCounter = 0;
95 	pData-&gt;ht = NULL;
96 }
97 static unsigned int
98 hash_from_key_fn(void *k)
99 {
100 	return *(unsigned int *)k;
101 }
102 static int
103 key_equals_fn(void *k1, void *k2)
104 {
105 	return (*(unsigned int *)k1 == *(unsigned int *)k2);
106 }
107 BEGINnewActInst
108 	struct cnfparamvals *pvals;
109 	int i;
110 CODESTARTnewActInst
111 	DBGPRINTF("newActInst (mmcount)\n");
112 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
113 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
114 	}
115 	CODE_STD_STRING_REQUESTnewActInst(1)
116 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
117 	CHKiRet(createInstance(&amp;pData));
118 	setInstParamDefaults(pData);
119 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
120 		if(!pvals[i].bUsed)
121 			continue;
122 		if(!strcmp(actpblk.descr[i].name, "appname")) {
123 			pData-&gt;pszAppName = es_str2cstr(pvals[i].val.d.estr, NULL);
124 			continue;
125 		}
126 		if(!strcmp(actpblk.descr[i].name, "key")) {
127 			pData-&gt;pszKey = es_str2cstr(pvals[i].val.d.estr, NULL);
128 			continue;
129 		}
130 		if(!strcmp(actpblk.descr[i].name, "value")) {
131 			pData-&gt;pszValue = es_str2cstr(pvals[i].val.d.estr, NULL);
132 			continue;
133 		}
134 		dbgprintf("mmcount: program error, non-handled "
135 			  "param '%s'\n", actpblk.descr[i].name);
136 	}
137 	if(pData-&gt;pszAppName == NULL) {
138 		dbgprintf("mmcount: action requires a appname");
139 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
140 	}
141 	if(pData-&gt;pszKey != NULL &amp;&amp; pData-&gt;pszValue == NULL) {
142 		if(NULL == (pData-&gt;ht = create_hashtable(100, hash_from_key_fn, key_equals_fn, NULL))) {
143 			DBGPRINTF("mmcount: error creating hash table!\n");
144 			ABORT_FINALIZE(RS_RET_ERR);
145 		}
146 	}
147 CODE_STD_FINALIZERnewActInst
148 	cnfparamvalsDestruct(pvals, &amp;actpblk);
149 ENDnewActInst
150 BEGINdbgPrintInstInfo
151 CODESTARTdbgPrintInstInfo
152 ENDdbgPrintInstInfo
153 BEGINtryResume
154 CODESTARTtryResume
155 ENDtryResume
156 static int *
157 getCounter(struct hashtable *ht, const char *str) {
158 	unsigned int key;
159 	int *pCounter;
160 	unsigned int *pKey;
161 	key = hash_from_string((char*)str);
162 	pCounter = hashtable_search(ht, &amp;key);
163 	if(pCounter) {
164 		return pCounter;
165 	}
166 	if(NULL == (pKey = (unsigned int*)malloc(sizeof(unsigned int)))) {
167 		DBGPRINTF("mmcount: memory allocation for key failed\n");
168 		return NULL;
169 	}
170 	*pKey = key;
171 	if(NULL == (pCounter = (int*)malloc(sizeof(int)))) {
172 		DBGPRINTF("mmcount: memory allocation for value failed\n");
173 		free(pKey);
174 		return NULL;
175 	}
176 	*pCounter = 0;
177 	if(!hashtable_insert(ht, pKey, pCounter)) {
178 		DBGPRINTF("mmcount: inserting element into hashtable failed\n");
179 		free(pKey);
180 		free(pCounter);
181 		return NULL;
182 	}
183 	return pCounter;
184 }
185 BEGINdoAction_NoStrings
186 	smsg_t **ppMsg = (smsg_t **) pMsgData;
187 	smsg_t *pMsg = ppMsg[0];
188 	char *appname;
189 	struct json_object *json = NULL;
190 	struct json_object *keyjson = NULL;
191 	const char *pszValue;
192 	int *pCounter;
193 	instanceData *const pData = pWrkrData-&gt;pData;
194 CODESTARTdoAction
195 	appname = getAPPNAME(pMsg, LOCK_MUTEX);
196 	pthread_mutex_lock(&amp;pData-&gt;mut);
197 	if(0 != strcmp(appname, pData-&gt;pszAppName)) {
198 		ABORT_FINALIZE(RS_RET_OK);
199 	}
200 	if(!pData-&gt;pszKey) {
201 		if(pMsg-&gt;iSeverity &lt; SEVERITY_COUNT) {
202 			pData-&gt;severity[pMsg-&gt;iSeverity]++;
203 			json = json_object_new_int(pData-&gt;severity[pMsg-&gt;iSeverity]);
204 		}
205 		ABORT_FINALIZE(RS_RET_OK);
206 	}
207 	msgPropDescr_t pProp;
208 	msgPropDescrFill(&amp;pProp, (uchar*)pData-&gt;pszKey, strlen(pData-&gt;pszKey));
209 	rsRetVal localRet = msgGetJSONPropJSON(pMsg, &amp;pProp, &amp;keyjson);
210 	msgPropDescrDestruct(&amp;pProp);
211 	if(localRet != RS_RET_OK) {
212 		ABORT_FINALIZE(RS_RET_OK);
213 	}
214 	pszValue = (char*)json_object_get_string(keyjson);
215 	if(pszValue == NULL) { 		pszValue = "";
216 	}
217 	if(pData-&gt;pszValue) {
218 		if(!strcmp(pszValue, pData-&gt;pszValue)) {
219 			pData-&gt;valueCounter++;
220 			json = json_object_new_int(pData-&gt;valueCounter);
221 		}
222 		ABORT_FINALIZE(RS_RET_OK);
223 	}
224 	pCounter = getCounter(pData-&gt;ht, pszValue);
225 	if(pCounter) {
226 		(*pCounter)++;
227 		json = json_object_new_int(*pCounter);
228 	}
229 finalize_it:
230 	pthread_mutex_unlock(&amp;pData-&gt;mut);
231 	if(json) {
232 		msgAddJSON(pMsg, (uchar *)JSON_COUNT_NAME, json, 0, 0);
233 	}
234 ENDdoAction
235 NO_LEGACY_CONF_parseSelectorAct
236 BEGINmodExit
237 CODESTARTmodExit
238 ENDmodExit
239 BEGINqueryEtryPt
240 CODESTARTqueryEtryPt
241 CODEqueryEtryPt_STD_OMOD_QUERIES
242 CODEqueryEtryPt_STD_OMOD8_QUERIES
243 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
244 CODEqueryEtryPt_STD_CONF2_QUERIES
245 ENDqueryEtryPt
246 BEGINmodInit()
247 CODESTARTmodInit
248 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
249 	DBGPRINTF("mmcount: module compiled with rsyslog version %s.\n", VERSION);
250 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
