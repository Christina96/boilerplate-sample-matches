<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for dummy_1.c &amp; mmcount.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for dummy_1.c &amp; mmcount.c
      </h3>
<h1 align="center">
        10.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>dummy_1.c (56.0%)<th>mmcount.c (5.882353%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(54-66)<td><a href="#" name="0">(64-74)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>dummy_1.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* a dummy module to be loaded if we cannot build this module, but
 * configure required it to be "optional".
 *
 * Copyright 2020 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;pthread.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "parserif.h"

#define MODULE_NAME(x) #x

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(MODULE_NAME(MODNAME))


DEF_OMOD_STATIC_DATA

<a name="0"></a>/* config variables */
typedef struct _instanceData {
	char *dummy;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

struct modConfData_s {
};

/* modConf ptr to use for the current load process */
static modConfData_t *loadModConf = NULL;
/* modConf ptr to use for the current exec process */
static modConfData_t *runModConf  = NULL;</b></font>




BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


BEGINsetModCnf
CODESTARTsetModCnf
	(void) lst;
	parser_errmsg("%s is an optional module which could not be built on your platform "
		"please remove it from the configuration or upgrade your platform", MODULE_NAME(MODNAME));
ENDsetModCnf


BEGINnewActInst
CODESTARTnewActInst
	(void) pData;
	(void) ppModData;
	parser_errmsg("%s is an optional module which could not be built on your platform "
		"please remove it from the configuration or upgrade your platform", MODULE_NAME(MODNAME));
ENDnewActInst


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


BEGINdoAction_NoStrings
CODESTARTdoAction
	(void) pMsgData;
ENDdoAction


NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	/* we only support the current interface specification */
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	dbgprintf("dummy module compiled with rsyslog version %s.\n", VERSION);
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmcount.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* mmcount.c
 * count messages by priority or json property of given app-name.
 *
 * Copyright 2013 Red Hat Inc.
 * Copyright 2014 Rainer Gerhards
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;json.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "hashtable.h"


#define JSON_COUNT_NAME "!mmcount"
#define SEVERITY_COUNT 8

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmcount")


DEF_OMOD_STATIC_DATA

/* config variables */

typedef struct _instanceData {
	char *pszAppName;
	int severity[SEVERITY_COUNT];
	char *pszKey;
	char *pszValue;
<a name="0"></a>	int valueCounter;
	struct hashtable *ht;
	pthread_mutex_t mut;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */</b></font>


/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ "appname", eCmdHdlrGetWord, 0 },
	{ "key", eCmdHdlrGetWord, 0 },
	{ "value", eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
	pthread_mutex_init(&amp;pData-&gt;mut, NULL);
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance

static inline void
setInstParamDefaults(instanceData *pData)
{
	int i;

	pData-&gt;pszAppName = NULL;
	for (i = 0; i &lt; SEVERITY_COUNT; i++)
	        pData-&gt;severity[i] = 0;
	pData-&gt;pszKey = NULL;
	pData-&gt;pszValue = NULL;
	pData-&gt;valueCounter = 0;
	pData-&gt;ht = NULL;
}

static unsigned int
hash_from_key_fn(void *k)
{
	return *(unsigned int *)k;
}

static int
key_equals_fn(void *k1, void *k2)
{
	return (*(unsigned int *)k1 == *(unsigned int *)k2);
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF("newActInst (mmcount)\n");
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "appname")) {
			pData-&gt;pszAppName = es_str2cstr(pvals[i].val.d.estr, NULL);
			continue;
		}
		if(!strcmp(actpblk.descr[i].name, "key")) {
			pData-&gt;pszKey = es_str2cstr(pvals[i].val.d.estr, NULL);
			continue;
		}
		if(!strcmp(actpblk.descr[i].name, "value")) {
			pData-&gt;pszValue = es_str2cstr(pvals[i].val.d.estr, NULL);
			continue;
		}
		dbgprintf("mmcount: program error, non-handled "
			  "param '%s'\n", actpblk.descr[i].name);
	}

	if(pData-&gt;pszAppName == NULL) {
		dbgprintf("mmcount: action requires a appname");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(pData-&gt;pszKey != NULL &amp;&amp; pData-&gt;pszValue == NULL) {
		if(NULL == (pData-&gt;ht = create_hashtable(100, hash_from_key_fn, key_equals_fn, NULL))) {
			DBGPRINTF("mmcount: error creating hash table!\n");
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume

static int *
getCounter(struct hashtable *ht, const char *str) {
	unsigned int key;
	int *pCounter;
	unsigned int *pKey;

	/* we dont store str as key, instead we store hash of the str
	   as key to reduce memory usage */
	key = hash_from_string((char*)str);
	pCounter = hashtable_search(ht, &amp;key);
	if(pCounter) {
		return pCounter;
	}

	/* counter is not found for the str, so add new entry and
	   return the counter */
	if(NULL == (pKey = (unsigned int*)malloc(sizeof(unsigned int)))) {
		DBGPRINTF("mmcount: memory allocation for key failed\n");
		return NULL;
	}
	*pKey = key;

	if(NULL == (pCounter = (int*)malloc(sizeof(int)))) {
		DBGPRINTF("mmcount: memory allocation for value failed\n");
		free(pKey);
		return NULL;
	}
	*pCounter = 0;

	if(!hashtable_insert(ht, pKey, pCounter)) {
		DBGPRINTF("mmcount: inserting element into hashtable failed\n");
		free(pKey);
		free(pCounter);
		return NULL;
	}
	return pCounter;
}

BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	char *appname;
	struct json_object *json = NULL;
	struct json_object *keyjson = NULL;
	const char *pszValue;
	int *pCounter;
	instanceData *const pData = pWrkrData-&gt;pData;
CODESTARTdoAction
	appname = getAPPNAME(pMsg, LOCK_MUTEX);

	pthread_mutex_lock(&amp;pData-&gt;mut);
	if(0 != strcmp(appname, pData-&gt;pszAppName)) {
		/* we are not working for this appname. nothing to do */
		ABORT_FINALIZE(RS_RET_OK);
	}

	if(!pData-&gt;pszKey) {
		/* no key given for count, so we count severity */
		if(pMsg-&gt;iSeverity &lt; SEVERITY_COUNT) {
			pData-&gt;severity[pMsg-&gt;iSeverity]++;
			json = json_object_new_int(pData-&gt;severity[pMsg-&gt;iSeverity]);
		}
		ABORT_FINALIZE(RS_RET_OK);
	}

	/* key is given, so get the property json */
	msgPropDescr_t pProp;
	msgPropDescrFill(&amp;pProp, (uchar*)pData-&gt;pszKey, strlen(pData-&gt;pszKey));
	rsRetVal localRet = msgGetJSONPropJSON(pMsg, &amp;pProp, &amp;keyjson);
	msgPropDescrDestruct(&amp;pProp);
	if(localRet != RS_RET_OK) {
		/* key not found in the message. nothing to do */
		ABORT_FINALIZE(RS_RET_OK);
	}

	/* key found, so get the value */
	pszValue = (char*)json_object_get_string(keyjson);
	if(pszValue == NULL) { /* json null object returns NULL! */
		pszValue = "";
	}

	if(pData-&gt;pszValue) {
		/* value also given for count */
		if(!strcmp(pszValue, pData-&gt;pszValue)) {
			/* count for (value and key and appname) matched */
			pData-&gt;valueCounter++;
			json = json_object_new_int(pData-&gt;valueCounter);
		}
		ABORT_FINALIZE(RS_RET_OK);
	}

	/* value is not given, so we count for each value of given key */
	pCounter = getCounter(pData-&gt;ht, pszValue);
	if(pCounter) {
		(*pCounter)++;
		json = json_object_new_int(*pCounter);
	}
finalize_it:
	pthread_mutex_unlock(&amp;pData-&gt;mut);

	if(json) {
		msgAddJSON(pMsg, (uchar *)JSON_COUNT_NAME, json, 0, 0);
	}
ENDdoAction


NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt



BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF("mmcount: module compiled with rsyslog version %s.\n", VERSION);
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
