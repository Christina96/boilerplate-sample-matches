
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-rank-geq2.c</h3>
            <pre><code>1  #include "mpi-rdft.h"
2  typedef struct {
3       solver super;
4       int preserve_input; &bsol;* preserve input even if DESTROY_INPUT was passed */
5  } S;
6  typedef struct {
7       plan_mpi_rdft super;
8       plan *cld1, *cld2;
9       int preserve_input;
10  } P;
11  static void apply(const plan *ego_, R *I, R *O)
12  {
13       const P *ego = (const P *) ego_;
14       plan_rdft *cld1, *cld2;
15       cld1 = (plan_rdft *) ego->cld1;
16       if (ego->preserve_input) {
17  	  cld1->apply(ego->cld1, I, O);
18  	  I = O;
19       }
20       else
21  	  cld1->apply(ego->cld1, I, I);
22       cld2 = (plan_rdft *) ego->cld2;
23       cld2->apply(ego->cld2, I, O);
24  }
25  static int applicable(const S *ego, const problem *p_,
26  		      const planner *plnr)
27  {
28       const problem_mpi_rdft *p = (const problem_mpi_rdft *) p_;
29       return (1
30  	     && p->sz->rnk > 1
31  	     && p->flags == 0 &bsol;* TRANSPOSED/SCRAMBLED_IN/OUT not supported */
32  	     && (!ego->preserve_input || (!NO_DESTROY_INPUTP(plnr)
33  					  && p->I != p->O))
34  	     && XM(is_local_after)(1, p->sz, IB)
35  	     && XM(is_local_after)(1, p->sz, OB)
36  	     && (!NO_SLOWP(plnr) &bsol;* slow if rdft-serial is applicable */
37  		 || !XM(rdft_serial_applicable)(p))
38  	  );
39  }
40  static void awake(plan *ego_, enum wakefulness wakefulness)
41  {
42       P *ego = (P *) ego_;
43       X(plan_awake)(ego->cld1, wakefulness);
44       X(plan_awake)(ego->cld2, wakefulness);
45  }
46  static void destroy(plan *ego_)
47  {
48       P *ego = (P *) ego_;
49       X(plan_destroy_internal)(ego->cld2);
50       X(plan_destroy_internal)(ego->cld1);
51  }
52  static void print(const plan *ego_, printer *p)
53  {
54       const P *ego = (const P *) ego_;
55       p->print(p, "(mpi-rdft-rank-geq2%s%(%p%)%(%p%))", 
56  	      ego->preserve_input==2 ?"/p":"", ego->cld1, ego->cld2);
57  }
58  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
59  {
60       const S *ego = (const S *) ego_;
61       const problem_mpi_rdft *p;
62       P *pln;
63       plan *cld1 = 0, *cld2 = 0;
64       R *I, *O, *I2;
65       tensor *sz;
66       dtensor *sz2;
67       int i, my_pe, n_pes;
68       INT nrest;
69       static const plan_adt padt = {
70            XM(rdft_solve), awake, print, destroy
71       };
72       UNUSED(ego);
73       if (!applicable(ego, p_, plnr))
74            return (plan *) 0;
75       p = (const problem_mpi_rdft *) p_;
76       I2 = I = p->I;
77       O = p->O;
78       if (ego->preserve_input || NO_DESTROY_INPUTP(plnr)) 
79  	  I = O; 
80       MPI_Comm_rank(p->comm, &my_pe);
81       MPI_Comm_size(p->comm, &n_pes);
82       sz = X(mktensor)(p->sz->rnk - 1); &bsol;* tensor of last rnk-1 dimensions */
<span onclick='openModal()' class='match'>83       i = p->sz->rnk - 2; A(i >= 0);
84       sz->dims[i].n = p->sz->dims[i+1].n;
</span>85       sz->dims[i].is = sz->dims[i].os = p->vn;
86       for (--i; i >= 0; --i) {
87  	  sz->dims[i].n = p->sz->dims[i+1].n;
88  	  sz->dims[i].is = sz->dims[i].os = sz->dims[i+1].n * sz->dims[i+1].is;
89       }
90       nrest = X(tensor_sz)(sz);
91       {
92            INT is = sz->dims[0].n * sz->dims[0].is;
93            INT b = XM(block)(p->sz->dims[0].n, p->sz->dims[0].b[IB], my_pe);
94  	  cld1 = X(mkplan_d)(plnr,
95                               X(mkproblem_rdft_d)(sz,
96  						 X(mktensor_2d)(b, is, is,
97  								p->vn, 1, 1),
98  						 I2, I, p->kind + 1));
99  	  if (XM(any_true)(!cld1, p->comm)) goto nada;
100       }
101       sz2 = XM(mkdtensor)(1); &bsol;* tensor for first (distributed) dimension */
102       sz2->dims[0] = p->sz->dims[0];
103       cld2 = X(mkplan_d)(plnr, XM(mkproblem_rdft_d)(sz2, nrest * p->vn,
104  						   I, O,
105  						   p->comm, p->kind,
106  						   RANK1_BIGVEC_ONLY));
107       if (XM(any_true)(!cld2, p->comm)) goto nada;
108       pln = MKPLAN_MPI_RDFT(P, &padt, apply);
109       pln->cld1 = cld1;
110       pln->cld2 = cld2;
111       pln->preserve_input = ego->preserve_input ? 2 : NO_DESTROY_INPUTP(plnr);
112       X(ops_add)(&cld1->ops, &cld2->ops, &pln->super.super.ops);
113       return &(pln->super.super);
114   nada:
115       X(plan_destroy_internal)(cld2);
116       X(plan_destroy_internal)(cld1);
117       return (plan *) 0;
118  }
119  static solver *mksolver(int preserve_input)
120  {
121       static const solver_adt sadt = { PROBLEM_MPI_RDFT, mkplan, 0 };
122       S *slv = MKSOLVER(S, &sadt);
123       slv->preserve_input = preserve_input;
124       return &(slv->super);
125  }
126  void XM(rdft_rank_geq2_register)(planner *p)
127  {
128       int preserve_input;
129       for (preserve_input = 0; preserve_input <= 1; ++preserve_input)
130  	  REGISTER_SOLVER(p, mksolver(preserve_input));
131  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-rank-geq2-transposed.c</h3>
            <pre><code>1  #include "mpi-dft.h"
2  #include "mpi-transpose.h"
3  #include "dft/dft.h"
4  typedef struct {
5       solver super;
6       int preserve_input; &bsol;* preserve input even if DESTROY_INPUT was passed */
7  } S;
8  typedef struct {
9       plan_mpi_dft super;
10       plan *cld1, *cldt, *cld2;
11       INT roff, ioff;
12       int preserve_input;
13  } P;
14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       plan_dft *cld1, *cld2;
18       plan_rdft *cldt;
19       INT roff = ego->roff, ioff = ego->ioff;
20       cld1 = (plan_dft *) ego->cld1;
21       if (ego->preserve_input) {
22  	  cld1->apply(ego->cld1, I+roff, I+ioff, O+roff, O+ioff);
23  	  I = O;
24       }
25       else
26  	  cld1->apply(ego->cld1, I+roff, I+ioff, I+roff, I+ioff);
27       cldt = (plan_rdft *) ego->cldt;
28       cldt->apply(ego->cldt, I, O);
29       cld2 = (plan_dft *) ego->cld2;
30       cld2->apply(ego->cld2, O+roff, O+ioff, O+roff, O+ioff);
31  }
32  static int applicable(const S *ego, const problem *p_,
33  		      const planner *plnr)
34  {
35       const problem_mpi_dft *p = (const problem_mpi_dft *) p_;
36       return (1
37  	     && p->sz->rnk > 1
38  	     && p->flags == TRANSPOSED_OUT
39  	     && (!ego->preserve_input || (!NO_DESTROY_INPUTP(plnr)
40  					  && p->I != p->O))
41  	     && XM(is_local_after)(1, p->sz, IB)
42  	     && XM(is_local_after)(2, p->sz, OB)
43  	     && XM(num_blocks)(p->sz->dims[0].n, p->sz->dims[0].b[OB]) == 1
44  	     && (!NO_SLOWP(plnr) &bsol;* slow if dft-serial is applicable */
45  		 || !XM(dft_serial_applicable)(p))
46  	  );
47  }
48  static void awake(plan *ego_, enum wakefulness wakefulness)
49  {
50       P *ego = (P *) ego_;
51       X(plan_awake)(ego->cld1, wakefulness);
52       X(plan_awake)(ego->cldt, wakefulness);
53       X(plan_awake)(ego->cld2, wakefulness);
54  }
55  static void destroy(plan *ego_)
56  {
57       P *ego = (P *) ego_;
58       X(plan_destroy_internal)(ego->cld2);
59       X(plan_destroy_internal)(ego->cldt);
60       X(plan_destroy_internal)(ego->cld1);
61  }
62  static void print(const plan *ego_, printer *p)
63  {
64       const P *ego = (const P *) ego_;
65       p->print(p, "(mpi-dft-rank-geq2-transposed%s%(%p%)%(%p%)%(%p%))", 
66  	      ego->preserve_input==2 ?"/p":"",
67  	      ego->cld1, ego->cldt, ego->cld2);
68  }
69  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
70  {
71       const S *ego = (const S *) ego_;
72       const problem_mpi_dft *p;
73       P *pln;
74       plan *cld1 = 0, *cldt = 0, *cld2 = 0;
75       R *ri, *ii, *ro, *io, *I, *O;
76       tensor *sz;
77       int i, my_pe, n_pes;
78       INT nrest;
79       static const plan_adt padt = {
80            XM(dft_solve), awake, print, destroy
81       };
82       UNUSED(ego);
83       if (!applicable(ego, p_, plnr))
84            return (plan *) 0;
85       p = (const problem_mpi_dft *) p_;
86       X(extract_reim)(p->sign, I = p->I, &ri, &ii);
87       X(extract_reim)(p->sign, O = p->O, &ro, &io);
88       if (ego->preserve_input || NO_DESTROY_INPUTP(plnr)) 
89  	  I = O; 
90       else { 
91  	  ro = ri;
92  	  io = ii;
93       }
94       MPI_Comm_rank(p->comm, &my_pe);
95       MPI_Comm_size(p->comm, &n_pes);
96       sz = X(mktensor)(p->sz->rnk - 1); &bsol;* tensor of last rnk-1 dimensions */
<span onclick='openModal()' class='match'>97       i = p->sz->rnk - 2; A(i >= 0);
98       sz->dims[i].n = p->sz->dims[i+1].n;
</span>99       sz->dims[i].is = sz->dims[i].os = 2 * p->vn;
100       for (--i; i >= 0; --i) {
101  	  sz->dims[i].n = p->sz->dims[i+1].n;
102  	  sz->dims[i].is = sz->dims[i].os = sz->dims[i+1].n * sz->dims[i+1].is;
103       }
104       nrest = 1; for (i = 1; i < sz->rnk; ++i) nrest *= sz->dims[i].n;
105       {
106            INT is = sz->dims[0].n * sz->dims[0].is;
107            INT b = XM(block)(p->sz->dims[0].n, p->sz->dims[0].b[IB], my_pe);
108  	  cld1 = X(mkplan_d)(plnr,
109                               X(mkproblem_dft_d)(sz,
110                                                  X(mktensor_2d)(b, is, is,
111                                                                 p->vn, 2, 2),
112                                                  ri, ii, ro, io));
113  	  if (XM(any_true)(!cld1, p->comm)) goto nada;
114       }
115       nrest *= p->vn;
116       cldt = X(mkplan_d)(plnr,
117  			XM(mkproblem_transpose)(
118  			     p->sz->dims[0].n, p->sz->dims[1].n, nrest * 2,
119  			     I, O,
120  			     p->sz->dims[0].b[IB], p->sz->dims[1].b[OB], 
121  			     p->comm, 0));
122       if (XM(any_true)(!cldt, p->comm)) goto nada;
123       X(extract_reim)(p->sign, O, &ro, &io);
124       {
125  	  INT is = p->sz->dims[0].n * nrest * 2;
126  	  INT b = XM(block)(p->sz->dims[1].n, p->sz->dims[1].b[OB], my_pe);
127  	  cld2 = X(mkplan_d)(plnr,
128  			     X(mkproblem_dft_d)(X(mktensor_1d)(
129  						     p->sz->dims[0].n,
130  						     nrest * 2, nrest * 2),
131  						X(mktensor_2d)(b, is, is,
132  							       nrest, 2, 2),
133  						ro, io, ro, io));
134  	  if (XM(any_true)(!cld2, p->comm)) goto nada;
135       }
136       pln = MKPLAN_MPI_DFT(P, &padt, apply);
137       pln->cld1 = cld1;
138       pln->cldt = cldt;
139       pln->cld2 = cld2;
140       pln->preserve_input = ego->preserve_input ? 2 : NO_DESTROY_INPUTP(plnr);
141       pln->roff = ri - p->I;
142       pln->ioff = ii - p->I;
143       X(ops_add)(&cld1->ops, &cld2->ops, &pln->super.super.ops);
144       X(ops_add2)(&cldt->ops, &pln->super.super.ops);
145       return &(pln->super.super);
146   nada:
147       X(plan_destroy_internal)(cld2);
148       X(plan_destroy_internal)(cldt);
149       X(plan_destroy_internal)(cld1);
150       return (plan *) 0;
151  }
152  static solver *mksolver(int preserve_input)
153  {
154       static const solver_adt sadt = { PROBLEM_MPI_DFT, mkplan, 0 };
155       S *slv = MKSOLVER(S, &sadt);
156       slv->preserve_input = preserve_input;
157       return &(slv->super);
158  }
159  void XM(dft_rank_geq2_transposed_register)(planner *p)
160  {
161       int preserve_input;
162       for (preserve_input = 0; preserve_input <= 1; ++preserve_input)
163  	  REGISTER_SOLVER(p, mksolver(preserve_input));
164  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-rank-geq2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-rank-geq2-transposed.c</div>
                </div>
                <div class="column column_space"><pre><code>83       i = p->sz->rnk - 2; A(i >= 0);
84       sz->dims[i].n = p->sz->dims[i+1].n;
</pre></code></div>
                <div class="column column_space"><pre><code>97       i = p->sz->rnk - 2; A(i >= 0);
98       sz->dims[i].n = p->sz->dims[i+1].n;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    