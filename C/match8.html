<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for lofreq_vcfset.c &amp; lofreq_viterbi.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lofreq_vcfset.c &amp; lofreq_viterbi.c
      </h3>
<h1 align="center">
        10.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lofreq_vcfset.c (11.007026%)<th>lofreq_viterbi.c (10.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(156-178)<td><a href="#" name="0">(385-402)</a><td align="center"><font color="#ff0000">30</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(183-202)<td><a href="#" name="1">(412-427)</a><td align="center"><font color="#900000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lofreq_vcfset.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- c-file-style: "k&amp;r"; indent-tabs-mode: nil; -*- */
/*********************************************************************
* The MIT License (MIT)
* 
* Copyright (c) 2013,2014 Genome Institute of Singapore
* 
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation files
* (the "Software"), to deal in the Software without restriction,
* including without limitation the rights to use, copy, modify, merge,
* publish, distribute, sublicense, and/or sell copies of the Software,
* and to permit persons to whom the Software is furnished to do so,
* subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
* BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
************************************************************************/



#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;getopt.h&gt;
#include &lt;stdlib.h&gt;

#include "htslib/kstring.h"
#include "htslib/tbx.h"

/* lofreq includes */
#include "lofreq_vcfset.h"
#include "vcf.h"
#include "log.h"
#include "utils.h"



#if 1
#define MYNAME "lofreq vcfset"
#else
#define MYNAME PACKAGE
#endif


typedef enum {
     SETOP_UNKNOWN,
     SETOP_INTERSECT,
     SETOP_COMPLEMENT, 
     SETOP_CONCAT
} vcfset_op_t;

typedef struct {
     vcf_file_t vcf_in1;
     vcf_file_t vcf_in2;
     vcf_file_t vcf_out;
     vcfset_op_t vcf_setop;
     int only_passed; /* if 1, ignore any filtered variant */
     int only_pos; /* 0: allele aware. if 1, ignore ref and alt base during comparisons.  */
     int only_snvs;
     int only_indels;
} vcfset_conf_t;



static void
usage(const vcfset_conf_t* vcfset_conf)
{
     fprintf(stderr, "%s: Perform set operations on two vcf files\n\n", MYNAME);
     fprintf(stderr, "Usage: %s [options] -a op -1 1.vcf -2 2.vcf \n", MYNAME);

     fprintf(stderr,"Options:\n");
     fprintf(stderr, "  -1 | --vcf1 FILE      1st VCF input file (bgzip supported)\n");
     fprintf(stderr, "  -2 | --vcf2 FILE      2nd VCF input file (mandatory - except for concat - and needs to be tabix indexed)\n");
     fprintf(stderr, "  -o | --vcfout         VCF output file (default: - for stdout; gzip supported).\n");
     fprintf(stderr, "  -a | --action         Set operation to perform: intersect, complement or concat.\n"
             "                        - intersect = vcf1 AND vcf2.\n"
             "                        - complement = vcf1 \\ vcf2.\n"
             "                        - concat = vcf1 + vcf2 ... vcfn (output as in file order, i.e. output not necessarily sorted!)\n");
     fprintf(stderr, "  -I | --add-info STR   Add info field, e.g. 'SOMATIC'\n");
     fprintf(stderr, "       --count-only     Don't print bases, just numbers\n");
     fprintf(stderr, "       --only-pos       Disable allele-awareness by using position only (ignoring bases) as key for storing and comparison\n");
     fprintf(stderr, "       --only-passed    Ignore variants marked as filtered\n");
     fprintf(stderr, "       --only-snvs      Ignore anything but SNVs in both input files\n");
     fprintf(stderr, "       --only-indels    Ignore anything but indels in both input files\n");
     fprintf(stderr, "       --verbose        Be verbose\n");
     fprintf(stderr, "       --debug          Enable debugging\n");

     fprintf(stderr, "\nNote, vcf1 is always fully parsed, whereas indexing is used for vcf2.\n");
     fprintf(stderr, "Therefore, use the bigger file as vcf2 to speed things up.\n");
     fprintf(stderr, "Header/meta-data for the output file is taken from vcf1\n");
}
/* usage() */




int 
main_vcfset(int argc, char *argv[])
{
     vcfset_conf_t vcfset_conf;
     char *vcf_header = NULL;
     int rc = 0;
     char *vcf_in1, *vcf_in2, *vcf_out;
     long int num_vars_vcf1;
     long int num_vars_vcf1_ign, num_vars_out;
     static int only_passed = 0;
     static int only_pos = 0;
     static int only_snvs = 0;
     static int only_indels = 0;
     static int count_only = 0;
     tbx_t *vcf2_tbx = NULL; /* index for second vcf file */
     htsFile *vcf2_hts = NULL;
     char *add_info_field = NULL;
     int vcf_concat_findex = 0;
     vcf_in1 = vcf_in2 = vcf_out = NULL;
     num_vars_vcf1 = 0;
     num_vars_vcf1_ign = num_vars_out = 0;

     /* default vcfset options */
     memset(&amp;vcfset_conf, 0, sizeof(vcfset_conf_t));
     /* vcfset_conf.vcf_in1 = NULL; */
     /* vcfset_conf.vcf_in2 = NULL; */
     /* vcfset_conf.vcf_out = stdout;*/


    /* keep in sync with long_opts_str and usage 
     *
     * getopt is a pain in the whole when it comes to syncing of long
     * and short args and usage. check out gopt, libcfu...
     */
    while (1) {
         int c;
         static struct option long_opts[] = {
              /* see usage sync */
              {"help", no_argument, NULL, 'h'},
              {"verbose", no_argument, &amp;verbose, 1},
              {"debug", no_argument, &amp;debug, 1},
              {"only-passed", no_argument, &amp;only_passed, 1},
              {"only-pos", no_argument, &amp;only_pos, 1},
              {"only-indels", no_argument, &amp;only_indels, 1},
<a name="0"></a>              {"only-snvs", no_argument, &amp;only_snvs, 1},
              {"count-only", no_argument, &amp;count_only, 1},

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>              {"vcf1", required_argument, NULL, '1'},
              {"vcf2", required_argument, NULL, '2'},
              {"vcfout", required_argument, NULL, 'o'},
              {"action", required_argument, NULL, 'a'},
              {"add-info", required_argument, NULL, 'I'},

              {0, 0, 0, 0} /* sentinel */
         };

         /* keep in sync with long_opts and usage */
         static const char *long_opts_str = "h1:2:o:a:I:";

         /* getopt_long stores the option index here. */
         int long_opts_index = 0;
         c = getopt_long(argc-1, argv+1, /* skipping 'lofreq', just leaving 'command', i.e. call */
                         long_opts_str, long_opts, &amp; long_opts_index);
         if (c == -1) {
              break;
         }

         switch (c) {
         /* keep in sync with long_opts etc */
         case 'h': </b></font>
              usage(&amp; vcfset_conf); 
<a name="1"></a>              free(vcf_in1); free(vcf_in2); free(vcf_out);
              return 0;

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>         case '1': 
              vcf_in1 = strdup(optarg);
              break;

         case '2': 
              vcf_in2 = strdup(optarg);
              break;

         case 'o':
              if (0 != strcmp(optarg, "-")) {
                   if (file_exists(optarg)) {
                        LOG_FATAL("Cowardly refusing to overwrite file '%s'. Exiting...\n", optarg);
                        free(vcf_in1); free(vcf_in2);
                        return 1;
                   }
              }
              vcf_out = strdup(optarg);
              break;

         case 'a': </b></font>
              if (0 == strcmp(optarg, "intersect")) {
                   vcfset_conf.vcf_setop = SETOP_INTERSECT;

              } else if (0 == strcmp(optarg, "complement")) {
                   vcfset_conf.vcf_setop = SETOP_COMPLEMENT;

              } else if (0 == strcmp(optarg, "concat")) {
                   vcfset_conf.vcf_setop = SETOP_CONCAT;

              } else {
                   LOG_FATAL("Unknown action '%s'. Exiting...\n", optarg);
                   free(vcf_in1); free(vcf_in2); free(vcf_out);
                   return 1;
              }
              break;

         case 'I': 
              add_info_field = strdup(optarg);
              break;

         case '?': 
              LOG_FATAL("%s\n", "unrecognized arguments found. Exiting...\n"); 
              free(vcf_in1); free(vcf_in2); free(vcf_out);
              return 1;

         default:
              break;
         }
    }

    vcfset_conf.only_passed = only_passed;
    vcfset_conf.only_pos = only_pos;
    vcfset_conf.only_snvs = only_snvs;
    vcfset_conf.only_indels = only_indels;

    if (vcfset_conf.only_indels &amp;&amp; vcfset_conf.only_snvs) {
         LOG_FATAL("%s\n", "Can't take only indels *and* only snvs into account");
         return 1;
    }

    if (0 != argc - optind - 1) {
         if (vcfset_conf.vcf_setop == SETOP_CONCAT) {
              vcf_concat_findex = optind;
         } else {
              LOG_FATAL("%s\n", "Unrecognized arguments found\n");
              return 1;
         }
    } else {
         if (vcfset_conf.vcf_setop == SETOP_CONCAT) {
              LOG_FATAL("%s\n", "No extra files for concat given\n");
              return 1;
         }
    }
#if 0
    int i; for (i=optind+1; i&lt;argc; i++) {
         LOG_FIXME("argv[%d]=%s\n", i, argv[i]);
    }
#endif

    if (argc == 2) {
        fprintf(stderr, "\n");
        usage(&amp; vcfset_conf);
        free(vcf_in1); free(vcf_in2); free(vcf_out);
        return 1;
    }

    if (vcfset_conf.vcf_setop == SETOP_UNKNOWN) {
         LOG_FATAL("%s\n", "No set operation specified");
         usage(&amp; vcfset_conf);
         free(vcf_in1); free(vcf_in2); free(vcf_out);
         return 1;
    }

    if  (vcf_in1 == NULL || (vcf_in2 == NULL &amp;&amp; vcfset_conf.vcf_setop != SETOP_CONCAT)) {
         LOG_FATAL("%s\n\n", "At least one vcf input file not specified");
         usage(&amp; vcfset_conf);
         free(vcf_in1); free(vcf_in2); free(vcf_out);
         return 1;
    }
    if (vcf_in2 != NULL &amp;&amp; vcfset_conf.vcf_setop == SETOP_CONCAT) {
         LOG_FATAL("%s\n\n", "For concat just use the -1 option followed by all other vcf files instead of using -2");
         usage(&amp; vcfset_conf);
         free(vcf_in1); free(vcf_in2); free(vcf_out);
         return 1;         
    }

    if (vcf_file_open(&amp; vcfset_conf.vcf_in1, vcf_in1, 
                      HAS_GZIP_EXT(vcf_in1), 'r')) {
         LOG_ERROR("Couldn't open %s\n", vcf_in1);
         free(vcf_in1); free(vcf_in2); free(vcf_out);
         return 1;
    }

    if (vcf_in2) {
         vcf2_hts = hts_open(vcf_in2, "r");
         if (!vcf2_hts) {
              LOG_FATAL("Couldn't load %s\n", vcf_in2);
              return 1;
         }
         vcf2_tbx = tbx_index_load(vcf_in2);
         if (!vcf2_tbx) {
              LOG_FATAL("Couldn't load tabix index for %s\n", vcf_in2);
              return 1;
         }
    }

    /* vcf_out default if not set: stdout==- */
    if (! vcf_out) {
         vcf_out = malloc(2 * sizeof(char));
         strcpy(vcf_out, "-");
    }

    if (! count_only) {
         if (vcf_file_open(&amp; vcfset_conf.vcf_out, vcf_out, 
                           HAS_GZIP_EXT(vcf_out), 'w')) {
              LOG_ERROR("Couldn't open %s\n", vcf_out);
              free(vcf_in1); free(vcf_in2); free(vcf_out);
              return 1;
         }
    }

    /* use meta-data/header of vcf_in1 for output
     */
    LOG_DEBUG("Getting header from %s\n", vcf_in1);
    if (0 !=  vcf_parse_header(&amp;vcf_header, &amp; vcfset_conf.vcf_in1)) {
         LOG_WARN("%s\n", "vcf_parse_header() failed");
         if (vcf_file_seek(&amp; vcfset_conf.vcf_in1, 0, SEEK_SET)) {
              LOG_FATAL("%s\n", "Couldn't rewind file to parse variants"
                        " after header parsing failed");
              return -1;
         }
    } else {
         if (! count_only) {
              /* vcf_write_header would write *default* header */
              vcf_write_header(&amp; vcfset_conf.vcf_out, vcf_header);
         }
         free(vcf_header);
    }

    
    /* parse first vcf file
     */
    LOG_DEBUG("Starting to parse variants from %s\n", vcf_in1);
    while (1) {
         var_t *var1 = NULL;
         int rc;
         int is_indel;
         kstring_t var2_kstr = {0, 0, 0};
         hts_itr_t *var2_itr = NULL;
         char regbuf[1024];
         int var2_match = 0;

         vcf_new_var(&amp;var1);
         rc = vcf_parse_var(&amp; vcfset_conf.vcf_in1, var1);
         if (rc) {
              free(var1);
              
              if (vcfset_conf.vcf_setop != SETOP_CONCAT) {
                   break;
              } else {
                   vcf_concat_findex++;
                   if (vcf_concat_findex==argc) {
                        break;
                   }
                   /* set vcf1 up anew and simply continue as if nothing happened 
                    */
                   vcf_file_close(&amp; vcfset_conf.vcf_in1);
                   free(vcf_in1);

                   vcf_in1 = strdup(argv[vcf_concat_findex]);
                   LOG_DEBUG("updated vcf_in1 = %s\n", vcf_in1);
                   if (vcf_file_open(&amp; vcfset_conf.vcf_in1, vcf_in1, 
                                     HAS_GZIP_EXT(vcf_in1), 'r')) {
                        LOG_ERROR("Couldn't open %s\n", vcf_in1);
                        free(vcf_in1); free(vcf_in2); free(vcf_out);
                        return 1;
                   }
                   if (0 != vcf_skip_header(&amp; vcfset_conf.vcf_in1)) {
                        LOG_WARN("skip header failed for %s\n", vcf_in1);
                   }
                   continue;
              }
         }

         is_indel = vcf_var_is_indel(var1);
         if (vcfset_conf.only_snvs &amp;&amp; is_indel) {
              free(var1);
              continue;
         } else if (vcfset_conf.only_indels &amp;&amp; ! is_indel) {
              free(var1);
              continue;
         }

         if (! vcfset_conf.only_pos &amp;&amp; NULL != strchr(var1-&gt;alt, ',')) {
              LOG_FATAL("%s\n", "No support for multi-allelic SNVs in vcf1");
              return -1;
         }
         if (vcfset_conf.only_passed &amp;&amp; ! VCF_VAR_PASSES(var1)) {
#ifdef TRACE
              LOG_DEBUG("Skipping non-passing var1 %s:%d\n", var1-&gt;chrom, var1-&gt;pos);
#endif
              num_vars_vcf1_ign += 1;
              vcf_free_var(&amp; var1);
              continue;
         }
         if (add_info_field) {
              vcf_var_add_to_info(var1, add_info_field);
         }
         num_vars_vcf1 += 1;
#ifdef TRACE
         LOG_DEBUG("Got passing var1 %s:%d\n", var1-&gt;chrom, var1-&gt;pos);
#endif

         if (vcfset_conf.vcf_setop == SETOP_CONCAT) {
              num_vars_out += 1;
              if (! count_only) {
                   vcf_write_var(&amp; vcfset_conf.vcf_out, var1);
              }
              vcf_free_var(&amp; var1);
              /* skip comparison against vcf2 */
              continue;
         }

         /* use index access to vcf2 */
         snprintf(regbuf, 1024, "%s:%ld-%ld", var1-&gt;chrom, var1-&gt;pos+1, var1-&gt;pos+1);
         var2_itr = tbx_itr_querys(vcf2_tbx, regbuf);
         if (! var2_itr) {
              var2_match = 0;
         } else {
              var2_match = 0;
              while (tbx_itr_next(vcf2_hts, vcf2_tbx, var2_itr, &amp;var2_kstr) &gt;= 0) {
                   var_t *var2 = NULL;
                   int var2_is_indel = 0;

                   vcf_new_var(&amp;var2);
                   rc = vcf_parse_var_from_line(var2_kstr.s, var2);
                   /* LOG_FIXME("%d:%s&gt;%s looking at var2 %d:%s&gt;%s (reg %s)\n", 
                             var1-&gt;pos+1, var1-&gt;ref, var1-&gt;alt,
                             var2-&gt;pos+1, var2-&gt;ref, var2-&gt;alt, regbuf); */
                   if (rc) {
                        LOG_FATAL("%s\n", "Error while parsing variant returned from tabix");
                        return -1;
                   }

                   var2_is_indel = vcf_var_is_indel(var2);

                   /* iterator returns anything overlapping with that 
                    * position, i.e. this also includes up/downstream
                    * indels, so make sure actual position matches */
                   if (var1-&gt;pos != var2-&gt;pos) {
                        var2_match = 0;

                   } else if (vcfset_conf.only_passed &amp;&amp; ! VCF_VAR_PASSES(var2)) {
                        var2_match = 0;

                   } else if (vcfset_conf.only_snvs &amp;&amp; var2_is_indel) {
                        var2_match = 0;

                   } else if (vcfset_conf.only_indels &amp;&amp; ! var2_is_indel) {
                        var2_match = 0;

                   } else if (vcfset_conf.only_pos) {
#ifdef TRACE
                        LOG_DEBUG("Pos match for var2 %s:%d\n", var2-&gt;chrom, var2-&gt;pos);
#endif
                        var2_match = 1;

                   } else {
                        if (0==strcmp(var1-&gt;ref, var2-&gt;ref) &amp;&amp; 0==strcmp(var1-&gt;alt, var2-&gt;alt)) {
#ifdef TRACE
                             LOG_DEBUG("Full match for var2 %s:%d\n", var2-&gt;chrom, var2-&gt;pos);
#endif
                             var2_match = 1;/* FIXME: check type as well i.e. snv vs indel */                             
                        }
                   }
                   vcf_free_var(&amp;var2);
                   if (var2_match) {
                        break;/* no need to continue */
                   }
              }
         }

         if (vcfset_conf.vcf_setop == SETOP_COMPLEMENT) {
              /* relative complement : elements in A but not B */
              if (!var2_match) {
                   num_vars_out += 1;
                   if (! count_only) {
                        vcf_write_var(&amp; vcfset_conf.vcf_out, var1);
                   }
              }
         } else if (vcfset_conf.vcf_setop == SETOP_INTERSECT) {
              if (var2_match) {
                   num_vars_out += 1;
                   if (! count_only) {
                        vcf_write_var(&amp; vcfset_conf.vcf_out, var1);
                   }
              }

         } else {
              LOG_FATAL("Internal error: unsupported vcf_setop %d\n", vcfset_conf.vcf_setop);
              return 1;
         }

         vcf_free_var(&amp; var1);
         tbx_itr_destroy(var2_itr);
    }/* while (1) */

    vcf_file_close(&amp; vcfset_conf.vcf_in1);
    if (vcf_in2) {
         hts_close(vcf2_hts);
         tbx_destroy(vcf2_tbx);
    }
    LOG_VERBOSE("Parsed %d variants from 1st vcf file (ignoring %d non-passed of those)\n", 
                num_vars_vcf1 + num_vars_vcf1_ign, num_vars_vcf1_ign);
    LOG_VERBOSE("Wrote %d variants to output\n", 
                num_vars_out);
    if (! count_only) {
         vcf_file_close(&amp; vcfset_conf.vcf_out);
    }

    if (0==rc) {
         if (count_only) {
              printf("%ld\n", num_vars_out);
         }

         LOG_VERBOSE("%s\n", "Successful exit.");
    }

    free(vcf_in1);
    free(vcf_in2);
    free(vcf_out);


    return rc;
}
/* main_vcfset */

</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lofreq_viterbi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- c-file-style: "k&amp;r"; indent-tabs-mode: nil; -*- */
/*********************************************************************
* The MIT License (MIT)
* 
* Copyright (c) 2013,2014 Genome Institute of Singapore
* 
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation files
* (the "Software"), to deal in the Software without restriction,
* including without limitation the rights to use, copy, modify, merge,
* publish, distribute, sublicense, and/or sell copies of the Software,
* and to permit persons to whom the Software is furnished to do so,
* subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
* BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
************************************************************************/


#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;getopt.h&gt;
#include &lt;stdlib.h&gt;

#include "htslib/faidx.h"
#include "htslib/sam.h"
#include "viterbi.h"
#include "log.h"
#include "lofreq_viterbi.h"
#include "utils.h"

#define SANGERQUAL_TO_PHRED(c) ((int)(c)-33)

/* FIXME: implement auto clipping of Q2 tails */

#define RWIN 10

typedef struct {
     samFile *in;
     samFile *out;
     bam_hdr_t *header;
     faidx_t *fai;
     uint32_t tid;
     char *ref;
     int reflen;
} tmpstruct_t;

static void replace_cigar(bam1_t *b, int n, uint32_t *cigar)
{
    if (n != b-&gt;core.n_cigar) {
        int o = b-&gt;core.l_qname + b-&gt;core.n_cigar * 4;
        if (b-&gt;l_data + (n - b-&gt;core.n_cigar) * 4 &gt; b-&gt;m_data) {
            b-&gt;m_data = b-&gt;l_data + (n - b-&gt;core.n_cigar) * 4;
            kroundup32(b-&gt;m_data);
            b-&gt;data = (uint8_t*)realloc(b-&gt;data, b-&gt;m_data);
        }
        memmove(b-&gt;data + b-&gt;core.l_qname + n * 4, b-&gt;data + o, b-&gt;l_data - o);
        memcpy(b-&gt;data + b-&gt;core.l_qname, cigar, n * 4);
        b-&gt;l_data += (n - b-&gt;core.n_cigar) * 4;
        b-&gt;core.n_cigar = n;
    } else memcpy(b-&gt;data + b-&gt;core.l_qname, cigar, n * 4);
}


/* function checks if alignment is made of all Q2s
 * if not, returns remaining values so that median 
 *  can be calculated
 */
int check_Q2(char *bqual, int *num){
    int is_all_Q2 = 1;
    int i, pom = 0;
    int l = strlen(bqual);
    *num = 0;
    for (i=0; i&lt;l; i++){
            if (SANGERQUAL_TO_PHRED(bqual[i]) != 2){
                    pom++;
                    is_all_Q2 = 0;
            }
    }       
    *num = pom;
    return is_all_Q2;
}

void remain(char *bqual, int *remaining){
     int pom = 0;
     int i, q;
     int l = strlen(bqual);
     for (i=0; i&lt;l; i++){
          q = SANGERQUAL_TO_PHRED(bqual[i]);
          if (q != 2){
               remaining[pom] = q;
               pom++;
          }
     }   
}

static int fetch_func(bam1_t *b, void *data, int del_flag, int q2def, int reclip)
{
     /* see
      https://github.com/lh3/bwa/blob/426e54740ca2b9b08e013f28560d01a570a0ab15/ksw.c
      for optimizations and speedups
     */
     tmpstruct_t *tmp = (tmpstruct_t*)data;
     bam1_core_t *c = &amp;b-&gt;core;
     uint8_t *seq = bam_get_seq(b);
     uint32_t *cigar = bam_get_cigar(b);
     int reflen;
    
     if (del_flag) {
          uint8_t *old_nm;
          uint8_t *old_mc;
          uint8_t *old_md;
          uint8_t *old_as;

          /* once you bam_aux_del b will change and all pointers to it, so don't use bam_aux_get again too early */
          
          old_nm = bam_aux_get(b, "NM");          
          if (old_nm) {          
               bam_aux_del(b, old_nm);
          }

          old_mc = bam_aux_get(b, "MC");          
          if (old_mc) {          
                bam_aux_del(b, old_mc);          
          }

          old_md = bam_aux_get(b, "MD");          
          if (old_md) {          
               bam_aux_del(b, old_md);
          }
          
          old_as = bam_aux_get(b, "AS");                    
          if (old_as) {
               bam_aux_del(b, old_as);
          }
     }

     if (c-&gt;flag &amp; BAM_FUNMAP) {
          sam_write1(tmp-&gt;out, tmp-&gt;header, b);
          return 0;
     }

     /* fetch reference sequence if incorrect tid */
     if (tmp-&gt;tid != c-&gt;tid) {
          if (tmp-&gt;ref) free(tmp-&gt;ref);
          if ((tmp-&gt;ref = 
               fai_fetch(tmp-&gt;fai, tmp-&gt;header-&gt;target_name[c-&gt;tid], &amp;reflen)) == 0) {
               fprintf(stderr, "failed to find reference sequence %s\n", 
                                tmp-&gt;header-&gt;target_name[c-&gt;tid]);
          }
          strtoupper(tmp-&gt;ref);/* safeguard */
          tmp-&gt;tid = c-&gt;tid;
          tmp-&gt;reflen = reflen;
     }
     int i;

     // remove soft clipped bases
     char query[c-&gt;l_qseq+1];
     char bqual[c-&gt;l_qseq+1];

     int x = c-&gt;pos; // coordinate on reference
     int y = 0; // coordinate on query
     int z = 0; // coordinate on query w/o softclip

     int indels = 0;

     // parse cigar string
     for (i = 0; i &lt; c-&gt;n_cigar; ++i) {
          int j, oplen = cigar[i] &gt;&gt; 4, op = cigar[i]&amp;0xf;
          if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {
               for (j = 0; j &lt; oplen; j++) {
                    query[z] = seq_nt16_str[bam_seqi(seq, y)];
                    bqual[z] = (char)bam_get_qual(b)[y]+33;
                    x++;
                    y++;
                    z++;
               }
          } else if (op == BAM_CHARD_CLIP) {
               /* in theory we should do nothing here but hard clipping info gets lost here FIXME
                */               
               sam_write1(tmp-&gt;out, tmp-&gt;header, b);
               return 1;
          } else if (op == BAM_CDEL) {
               x += oplen;
               indels += 1;
          } else if (op == BAM_CINS) {
               for (j = 0; j &lt; oplen; j++) {
                    query[z] = seq_nt16_str[bam_seqi(seq, y)];
                    bqual[z] = (char)bam_get_qual(b)[y]+33;
                    y++;
                    z++;
               }
               indels += 1;
          } else if (op == BAM_CSOFT_CLIP) {
               for (j = 0; j &lt; oplen; j++) {
                    y++;
               }
          } else {
               LOG_WARN("Unknown cigar op %d. Not touching read %s\n", op, bam_get_qname(b));
               sam_write1(tmp-&gt;out, tmp-&gt;header, b);
               return 1;
          }
     }
     query[z] = bqual[z] = '\0';

     if (indels == 0) {
          sam_write1(tmp-&gt;out, tmp-&gt;header, b);
          return 0;
     }
    int len_remaining = 0;
    if (check_Q2(bqual, &amp;len_remaining)) {
		if (reclip){
			// check if first op or last op is I and replace with S
			 int curr_oplen_check = cigar[0] &gt;&gt; 4;
			 int curr_op_check = cigar[0]&amp;0xf;
			 if (curr_op_check == BAM_CINS){
				curr_op_check = BAM_CSOFT_CLIP;
				cigar[0] = curr_oplen_check &lt;&lt;4 | curr_op_check;
			}
			 curr_oplen_check = cigar[c-&gt;n_cigar-1] &gt;&gt; 4;
			 curr_op_check = cigar[c-&gt;n_cigar-1]&amp;0xf;

			 if (curr_op_check == BAM_CINS){
				curr_op_check = BAM_CSOFT_CLIP;
				cigar[c-&gt;n_cigar-1] = curr_oplen_check &lt;&lt;4 | curr_op_check;
			}
			
			replace_cigar(b,c-&gt;n_cigar,cigar);
		}
        sam_write1(tmp-&gt;out, tmp-&gt;header, b);
        return 0;
    }
    int remaining[len_remaining+1];
    remain(bqual, remaining);
    remaining[len_remaining] = '\0';
    if (q2def &lt; 0) {
        q2def = int_median(remaining, len_remaining);
    }
    
     /* get reference with RWIN padding */
     char ref[c-&gt;l_qseq+1+indels+RWIN*2];
     int lower = c-&gt;pos - RWIN;
     lower = lower &lt; 0? 0: lower;
     int upper = x + RWIN;
     upper = upper &gt; tmp-&gt;reflen? tmp-&gt;reflen: upper;
     for (z = 0, i = lower; i &lt; upper; z++, i++) {
          ref[z] = tmp-&gt;ref[i];
     }
     ref[z] = '\0';

     /* run viterbi */
     char *aln = malloc(sizeof(char)*(2*(c-&gt;l_qseq)));
     int shift = viterbi(ref, query, bqual, aln, q2def);

     /* convert to cigar */
     uint32_t *realn_cigar = 0;
     int realn_n_cigar = 0;
     
     /* check if soft-clipped in the front */
     int curr_oplen = cigar[0] &gt;&gt; 4; 
     int curr_op = cigar[0]&amp;0xf;
     if (curr_op == BAM_CSOFT_CLIP) {
          realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
          realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
          realn_n_cigar += 1;
     }
     
     /* get cigar of the realigned query */
     curr_op = aln[0] == 'M' ? 0 : (aln[0] == 'I'? 1 : 2);
     curr_oplen = 1;
     for (i = 1; i &lt; strlen(aln); i++) {
          int this_op = aln[i] == 'M' ? 0 : (aln[i] == 'I' ? 1 : 2);
          if (this_op != curr_op) {
               realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
               realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
               realn_n_cigar += 1;
               curr_op = this_op;
               curr_oplen = 1;
          } else {
               curr_oplen += 1;
          }
     }
     realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
     realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
     realn_n_cigar += 1; 
    
     /* check if soft-clipped in the back */
     curr_oplen = cigar[c-&gt;n_cigar-1] &gt;&gt; 4; 
     curr_op = cigar[c-&gt;n_cigar-1]&amp;0xf;
     if (curr_op == BAM_CSOFT_CLIP) {
          realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
          realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
          realn_n_cigar += 1;
     }

#if 0
     int j;
     for (j = 0; j &lt; realn_n_cigar; j++) {
          curr_oplen = realn_cigar[j] &gt;&gt; 4;
          curr_op = realn_cigar[j]&amp;0xf;
          fprintf(stderr, "op:%d oplen:%d\n", curr_op, curr_oplen);
     }
#endif

     /* check if read was shifted */
     if (shift-(c-&gt;pos-lower) != 0) {
          LOG_VERBOSE("Read %s with shift of %d at original pos %s:%d\n", 
                      bam_get_qname(b), shift-(c-&gt;pos-lower),
                      tmp-&gt;header-&gt;target_name[c-&gt;tid], c-&gt;pos);
          c-&gt;pos = c-&gt;pos + (shift - (c-&gt;pos - lower));
     }
     
	 if (reclip){
		 // check if first op or last op is I and replace with S
		 int curr_oplen_reclip = realn_cigar[0] &gt;&gt; 4;
		 int curr_op_reclip = realn_cigar[0]&amp;0xf;

		 if (curr_op_reclip == BAM_CINS){
			curr_op_reclip = BAM_CSOFT_CLIP;
			realn_cigar[0] = curr_oplen_reclip &lt;&lt;4 | curr_op_reclip;
		}
		 curr_oplen_reclip = realn_cigar[realn_n_cigar-1] &gt;&gt; 4;
		 curr_op_reclip = realn_cigar[realn_n_cigar-1]&amp;0xf;

		 if (curr_op_reclip == BAM_CINS){
			curr_op_reclip = BAM_CSOFT_CLIP;
			realn_cigar[realn_n_cigar-1] = curr_oplen_reclip &lt;&lt;4 | curr_op_reclip;
		}
	}
     replace_cigar(b, realn_n_cigar, realn_cigar);
     sam_write1(tmp-&gt;out, tmp-&gt;header, b);
     free(aln);
     free(realn_cigar);
     return 0;
}

static void usage()
{
     fprintf(stderr, "Usage: lofreq viterbi [options] in.bam\n");
     fprintf(stderr, "Options:\n");
     fprintf(stderr, "     -f | --ref FILE     Indexed reference fasta file [null]\n");
     fprintf(stderr, "     -k | --keepflags    Don't delete flags MC, MD, NM and A, which are all prone to change during realignment.\n");
     fprintf(stderr, "     -q | --defqual INT  Assume INT as quality for all bases with BQ2. Default (=-1) is to use median quality of bases in read.\n");
/* experimental. keep enabled but don't tell user about it */
#if 0
     fprintf(stderr, "     -r | --reclip       Reclip insertions and/or deletions on the beginning and end of read to soft clip\n");
     fprintf(stderr, "                         FILE HAS TO BE PREVIOUSLY UNCLIPPED!!!\n");
#endif
     fprintf(stderr, "     -o | --out FILE     Output BAM file [- = stdout = default]\n");
     fprintf(stderr, "          --verbose      Be verbose\n");
     fprintf(stderr, "\n");
     fprintf(stderr, "NOTE: Output BAM file will (likely) be unsorted (use samtools sort, e.g. lofreq viterbi ... | samtools sort -')\n");
}


int main_viterbi(int argc, char *argv[])
{
     tmpstruct_t tmp = {0};
     static int del_flag = 1;
     static int q2default = -1;
	 static int reclip = 0;
     char *bam_out = NULL;
     bam1_t *b = NULL;
 
     if (argc == 2) {
          usage();
          return 1;
     }

     while (1) {
          int c;
<a name="0"></a>
          static struct option long_options[] = {
               {"ref", required_argument, NULL, 'f'},
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>               {"verbose", no_argument, &amp;verbose, 1},
               {"keepflags", no_argument, NULL, 'k'},
			   {"reclip",	no_argument, NULL, 'r'},
               {"out", required_argument, NULL, 'o'},
               {"defqual", required_argument, NULL, 'q'},
               {0,0,0,0}
          };
          
          static const char *long_opts_str = "rkf:q:o:";
          int long_option_index = 0;

          c = getopt_long(argc-1, argv+1, long_opts_str, long_options, &amp;long_option_index);

          if (c == -1) {
               break;
          }
          switch (c){
          case 'f':</b></font>
               if (! file_exists(optarg)) {
                    LOG_FATAL("Reference fasta file %s does not exist. Exiting...\n", optarg);
                    return 1;
               }
               tmp.fai = fai_load(optarg);	
               break;
<a name="1"></a>          case 'k':
               del_flag = 0;
               break;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          case 'q':
               q2default = atoi(optarg);
               break;
		  case 'r':
				reclip = 1;
				break;
          case 'o':
               if (0 != strcmp(optarg, "-")) {
                    if (file_exists(optarg)) {
                         LOG_FATAL("Cowardly refusing to overwrite file '%s'. Exiting...\n", optarg);
                         return 1;
                    }
               }
               bam_out = strdup(optarg);
               break;
          case '?':</b></font>
               LOG_FATAL("%s\n", "Unrecognized arguments found. Exiting\n");
               usage();
               break;
          default:
               break;
          }
     }


     if (! tmp.fai) {
          LOG_FATAL("%s\n", "Couldn't load reference fasta file\n");
          usage();
          return 1;
     }

     /* get bam file */
     if (1 != argc-optind-1){
          LOG_FATAL("%s\n", "Need exactly one BAM file as last argument\n");
          return 1;
     }
     if ((tmp.in = sam_open((argv+optind+1)[0], "rb")) == 0){
          LOG_FATAL("Failed to open BAM file %s. Exiting...\n", (argv+optind+1)[0]);
          return 1;
     }
     if ((tmp.header = sam_hdr_read(tmp.in)) == 0) {
          LOG_FATAL("Failed to read headers from BAM file %s. Exiting...\n", (argv+optind+1)[0]);
          return 1;
     }

     if (!bam_out || bam_out[0] == '-') {
          tmp.out = sam_open("-", "wb");
     } else {
          tmp.out = sam_open(bam_out, "wb");
     }
     sam_hdr_write(tmp.out, tmp.header);
     
     b = bam_init1();
     tmp.tid = -1;
     tmp.ref = 0;
     while (sam_read1(tmp.in, tmp.header, b) &gt;= 0){
          fetch_func(b, &amp;tmp, del_flag, q2default, reclip);
     }
     bam_destroy1(b);
     bam_hdr_destroy(tmp.header);
     sam_close(tmp.in);
     sam_close(tmp.out);
     if (tmp.ref)
          free(tmp.ref);
     fai_destroy(tmp.fai);
     free(bam_out);

     LOG_VERBOSE("%s\n", "NOTE: Output BAM file will be unsorted (use samtools sort, e.g. samtools sort -')");

     return 0;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
