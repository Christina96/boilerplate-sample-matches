<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for lofreq_vcfset.c & lofreq_viterbi.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for lofreq_vcfset.c & lofreq_viterbi.c
      </h3>
      <h1 align="center">
        10.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>lofreq_vcfset.c (11.007026%)<TH>lofreq_viterbi.c (10.0%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match8-0.html#0',2,'match8-1.html#0',3)" NAME="0">(156-178)<TD><A HREF="javascript:ZweiFrames('match8-0.html#0',2,'match8-1.html#0',3)" NAME="0">(385-402)</A><TD ALIGN=center><FONT COLOR="#ff0000">30</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match8-0.html#1',2,'match8-1.html#1',3)" NAME="1">(183-202)<TD><A HREF="javascript:ZweiFrames('match8-0.html#1',2,'match8-1.html#1',3)" NAME="1">(412-427)</A><TD ALIGN=center><FONT COLOR="#900000">17</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lofreq_vcfset.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- c-file-style: &quot;k&amp;r&quot;; indent-tabs-mode: nil; -*- */
/*********************************************************************
* The MIT License (MIT)
* 
* Copyright (c) 2013,2014 Genome Institute of Singapore
* 
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation files
* (the &quot;Software&quot;), to deal in the Software without restriction,
* including without limitation the rights to use, copy, modify, merge,
* publish, distribute, sublicense, and/or sell copies of the Software,
* and to permit persons to whom the Software is furnished to do so,
* subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
* BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
************************************************************************/



#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;getopt.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;htslib/kstring.h&quot;
#include &quot;htslib/tbx.h&quot;

/* lofreq includes */
#include &quot;lofreq_vcfset.h&quot;
#include &quot;vcf.h&quot;
#include &quot;log.h&quot;
#include &quot;utils.h&quot;



#if 1
#define MYNAME &quot;lofreq vcfset&quot;
#else
#define MYNAME PACKAGE
#endif


typedef enum {
     SETOP_UNKNOWN,
     SETOP_INTERSECT,
     SETOP_COMPLEMENT, 
     SETOP_CONCAT
} vcfset_op_t;

typedef struct {
     vcf_file_t vcf_in1;
     vcf_file_t vcf_in2;
     vcf_file_t vcf_out;
     vcfset_op_t vcf_setop;
     int only_passed; /* if 1, ignore any filtered variant */
     int only_pos; /* 0: allele aware. if 1, ignore ref and alt base during comparisons.  */
     int only_snvs;
     int only_indels;
} vcfset_conf_t;



static void
usage(const vcfset_conf_t* vcfset_conf)
{
     fprintf(stderr, &quot;%s: Perform set operations on two vcf files\n\n&quot;, MYNAME);
     fprintf(stderr, &quot;Usage: %s [options] -a op -1 1.vcf -2 2.vcf \n&quot;, MYNAME);

     fprintf(stderr,&quot;Options:\n&quot;);
     fprintf(stderr, &quot;  -1 | --vcf1 FILE      1st VCF input file (bgzip supported)\n&quot;);
     fprintf(stderr, &quot;  -2 | --vcf2 FILE      2nd VCF input file (mandatory - except for concat - and needs to be tabix indexed)\n&quot;);
     fprintf(stderr, &quot;  -o | --vcfout         VCF output file (default: - for stdout; gzip supported).\n&quot;);
     fprintf(stderr, &quot;  -a | --action         Set operation to perform: intersect, complement or concat.\n&quot;
             &quot;                        - intersect = vcf1 AND vcf2.\n&quot;
             &quot;                        - complement = vcf1 \\ vcf2.\n&quot;
             &quot;                        - concat = vcf1 + vcf2 ... vcfn (output as in file order, i.e. output not necessarily sorted!)\n&quot;);
     fprintf(stderr, &quot;  -I | --add-info STR   Add info field, e.g. 'SOMATIC'\n&quot;);
     fprintf(stderr, &quot;       --count-only     Don't print bases, just numbers\n&quot;);
     fprintf(stderr, &quot;       --only-pos       Disable allele-awareness by using position only (ignoring bases) as key for storing and comparison\n&quot;);
     fprintf(stderr, &quot;       --only-passed    Ignore variants marked as filtered\n&quot;);
     fprintf(stderr, &quot;       --only-snvs      Ignore anything but SNVs in both input files\n&quot;);
     fprintf(stderr, &quot;       --only-indels    Ignore anything but indels in both input files\n&quot;);
     fprintf(stderr, &quot;       --verbose        Be verbose\n&quot;);
     fprintf(stderr, &quot;       --debug          Enable debugging\n&quot;);

     fprintf(stderr, &quot;\nNote, vcf1 is always fully parsed, whereas indexing is used for vcf2.\n&quot;);
     fprintf(stderr, &quot;Therefore, use the bigger file as vcf2 to speed things up.\n&quot;);
     fprintf(stderr, &quot;Header/meta-data for the output file is taken from vcf1\n&quot;);
}
/* usage() */




int 
main_vcfset(int argc, char *argv[])
{
     vcfset_conf_t vcfset_conf;
     char *vcf_header = NULL;
     int rc = 0;
     char *vcf_in1, *vcf_in2, *vcf_out;
     long int num_vars_vcf1;
     long int num_vars_vcf1_ign, num_vars_out;
     static int only_passed = 0;
     static int only_pos = 0;
     static int only_snvs = 0;
     static int only_indels = 0;
     static int count_only = 0;
     tbx_t *vcf2_tbx = NULL; /* index for second vcf file */
     htsFile *vcf2_hts = NULL;
     char *add_info_field = NULL;
     int vcf_concat_findex = 0;
     vcf_in1 = vcf_in2 = vcf_out = NULL;
     num_vars_vcf1 = 0;
     num_vars_vcf1_ign = num_vars_out = 0;

     /* default vcfset options */
     memset(&amp;vcfset_conf, 0, sizeof(vcfset_conf_t));
     /* vcfset_conf.vcf_in1 = NULL; */
     /* vcfset_conf.vcf_in2 = NULL; */
     /* vcfset_conf.vcf_out = stdout;*/


    /* keep in sync with long_opts_str and usage 
     *
     * getopt is a pain in the whole when it comes to syncing of long
     * and short args and usage. check out gopt, libcfu...
     */
    while (1) {
         int c;
         static struct option long_opts[] = {
              /* see usage sync */
              {&quot;help&quot;, no_argument, NULL, 'h'},
              {&quot;verbose&quot;, no_argument, &amp;verbose, 1},
              {&quot;debug&quot;, no_argument, &amp;debug, 1},
              {&quot;only-passed&quot;, no_argument, &amp;only_passed, 1},
              {&quot;only-pos&quot;, no_argument, &amp;only_pos, 1},
              {&quot;only-indels&quot;, no_argument, &amp;only_indels, 1},
<A NAME="0"></A>              {&quot;only-snvs&quot;, no_argument, &amp;only_snvs, 1},
              {&quot;count-only&quot;, no_argument, &amp;count_only, 1},

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match8-1.html#0',3,'match8-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>              {&quot;vcf1&quot;, required_argument, NULL, '1'},
              {&quot;vcf2&quot;, required_argument, NULL, '2'},
              {&quot;vcfout&quot;, required_argument, NULL, 'o'},
              {&quot;action&quot;, required_argument, NULL, 'a'},
              {&quot;add-info&quot;, required_argument, NULL, 'I'},

              {0, 0, 0, 0} /* sentinel */
         };

         /* keep in sync with long_opts and usage */
         static const char *long_opts_str = &quot;h1:2:o:a:I:&quot;;

         /* getopt_long stores the option index here. */
         int long_opts_index = 0;
         c = getopt_long(argc-1, argv+1, /* skipping 'lofreq', just leaving 'command', i.e. call */
                         long_opts_str, long_opts, &amp; long_opts_index);
         if (c == -1) {
              break;
         }

         switch (c) {
         /* keep in sync with long_opts etc */
         case 'h': </B></FONT>
              usage(&amp; vcfset_conf); 
<A NAME="1"></A>              free(vcf_in1); free(vcf_in2); free(vcf_out);
              return 0;

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match8-1.html#1',3,'match8-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>         case '1': 
              vcf_in1 = strdup(optarg);
              break;

         case '2': 
              vcf_in2 = strdup(optarg);
              break;

         case 'o':
              if (0 != strcmp(optarg, &quot;-&quot;)) {
                   if (file_exists(optarg)) {
                        LOG_FATAL(&quot;Cowardly refusing to overwrite file '%s'. Exiting...\n&quot;, optarg);
                        free(vcf_in1); free(vcf_in2);
                        return 1;
                   }
              }
              vcf_out = strdup(optarg);
              break;

         case 'a': </B></FONT>
              if (0 == strcmp(optarg, &quot;intersect&quot;)) {
                   vcfset_conf.vcf_setop = SETOP_INTERSECT;

              } else if (0 == strcmp(optarg, &quot;complement&quot;)) {
                   vcfset_conf.vcf_setop = SETOP_COMPLEMENT;

              } else if (0 == strcmp(optarg, &quot;concat&quot;)) {
                   vcfset_conf.vcf_setop = SETOP_CONCAT;

              } else {
                   LOG_FATAL(&quot;Unknown action '%s'. Exiting...\n&quot;, optarg);
                   free(vcf_in1); free(vcf_in2); free(vcf_out);
                   return 1;
              }
              break;

         case 'I': 
              add_info_field = strdup(optarg);
              break;

         case '?': 
              LOG_FATAL(&quot;%s\n&quot;, &quot;unrecognized arguments found. Exiting...\n&quot;); 
              free(vcf_in1); free(vcf_in2); free(vcf_out);
              return 1;

         default:
              break;
         }
    }

    vcfset_conf.only_passed = only_passed;
    vcfset_conf.only_pos = only_pos;
    vcfset_conf.only_snvs = only_snvs;
    vcfset_conf.only_indels = only_indels;

    if (vcfset_conf.only_indels &amp;&amp; vcfset_conf.only_snvs) {
         LOG_FATAL(&quot;%s\n&quot;, &quot;Can't take only indels *and* only snvs into account&quot;);
         return 1;
    }

    if (0 != argc - optind - 1) {
         if (vcfset_conf.vcf_setop == SETOP_CONCAT) {
              vcf_concat_findex = optind;
         } else {
              LOG_FATAL(&quot;%s\n&quot;, &quot;Unrecognized arguments found\n&quot;);
              return 1;
         }
    } else {
         if (vcfset_conf.vcf_setop == SETOP_CONCAT) {
              LOG_FATAL(&quot;%s\n&quot;, &quot;No extra files for concat given\n&quot;);
              return 1;
         }
    }
#if 0
    int i; for (i=optind+1; i&lt;argc; i++) {
         LOG_FIXME(&quot;argv[%d]=%s\n&quot;, i, argv[i]);
    }
#endif

    if (argc == 2) {
        fprintf(stderr, &quot;\n&quot;);
        usage(&amp; vcfset_conf);
        free(vcf_in1); free(vcf_in2); free(vcf_out);
        return 1;
    }

    if (vcfset_conf.vcf_setop == SETOP_UNKNOWN) {
         LOG_FATAL(&quot;%s\n&quot;, &quot;No set operation specified&quot;);
         usage(&amp; vcfset_conf);
         free(vcf_in1); free(vcf_in2); free(vcf_out);
         return 1;
    }

    if  (vcf_in1 == NULL || (vcf_in2 == NULL &amp;&amp; vcfset_conf.vcf_setop != SETOP_CONCAT)) {
         LOG_FATAL(&quot;%s\n\n&quot;, &quot;At least one vcf input file not specified&quot;);
         usage(&amp; vcfset_conf);
         free(vcf_in1); free(vcf_in2); free(vcf_out);
         return 1;
    }
    if (vcf_in2 != NULL &amp;&amp; vcfset_conf.vcf_setop == SETOP_CONCAT) {
         LOG_FATAL(&quot;%s\n\n&quot;, &quot;For concat just use the -1 option followed by all other vcf files instead of using -2&quot;);
         usage(&amp; vcfset_conf);
         free(vcf_in1); free(vcf_in2); free(vcf_out);
         return 1;         
    }

    if (vcf_file_open(&amp; vcfset_conf.vcf_in1, vcf_in1, 
                      HAS_GZIP_EXT(vcf_in1), 'r')) {
         LOG_ERROR(&quot;Couldn't open %s\n&quot;, vcf_in1);
         free(vcf_in1); free(vcf_in2); free(vcf_out);
         return 1;
    }

    if (vcf_in2) {
         vcf2_hts = hts_open(vcf_in2, &quot;r&quot;);
         if (!vcf2_hts) {
              LOG_FATAL(&quot;Couldn't load %s\n&quot;, vcf_in2);
              return 1;
         }
         vcf2_tbx = tbx_index_load(vcf_in2);
         if (!vcf2_tbx) {
              LOG_FATAL(&quot;Couldn't load tabix index for %s\n&quot;, vcf_in2);
              return 1;
         }
    }

    /* vcf_out default if not set: stdout==- */
    if (! vcf_out) {
         vcf_out = malloc(2 * sizeof(char));
         strcpy(vcf_out, &quot;-&quot;);
    }

    if (! count_only) {
         if (vcf_file_open(&amp; vcfset_conf.vcf_out, vcf_out, 
                           HAS_GZIP_EXT(vcf_out), 'w')) {
              LOG_ERROR(&quot;Couldn't open %s\n&quot;, vcf_out);
              free(vcf_in1); free(vcf_in2); free(vcf_out);
              return 1;
         }
    }

    /* use meta-data/header of vcf_in1 for output
     */
    LOG_DEBUG(&quot;Getting header from %s\n&quot;, vcf_in1);
    if (0 !=  vcf_parse_header(&amp;vcf_header, &amp; vcfset_conf.vcf_in1)) {
         LOG_WARN(&quot;%s\n&quot;, &quot;vcf_parse_header() failed&quot;);
         if (vcf_file_seek(&amp; vcfset_conf.vcf_in1, 0, SEEK_SET)) {
              LOG_FATAL(&quot;%s\n&quot;, &quot;Couldn't rewind file to parse variants&quot;
                        &quot; after header parsing failed&quot;);
              return -1;
         }
    } else {
         if (! count_only) {
              /* vcf_write_header would write *default* header */
              vcf_write_header(&amp; vcfset_conf.vcf_out, vcf_header);
         }
         free(vcf_header);
    }

    
    /* parse first vcf file
     */
    LOG_DEBUG(&quot;Starting to parse variants from %s\n&quot;, vcf_in1);
    while (1) {
         var_t *var1 = NULL;
         int rc;
         int is_indel;
         kstring_t var2_kstr = {0, 0, 0};
         hts_itr_t *var2_itr = NULL;
         char regbuf[1024];
         int var2_match = 0;

         vcf_new_var(&amp;var1);
         rc = vcf_parse_var(&amp; vcfset_conf.vcf_in1, var1);
         if (rc) {
              free(var1);
              
              if (vcfset_conf.vcf_setop != SETOP_CONCAT) {
                   break;
              } else {
                   vcf_concat_findex++;
                   if (vcf_concat_findex==argc) {
                        break;
                   }
                   /* set vcf1 up anew and simply continue as if nothing happened 
                    */
                   vcf_file_close(&amp; vcfset_conf.vcf_in1);
                   free(vcf_in1);

                   vcf_in1 = strdup(argv[vcf_concat_findex]);
                   LOG_DEBUG(&quot;updated vcf_in1 = %s\n&quot;, vcf_in1);
                   if (vcf_file_open(&amp; vcfset_conf.vcf_in1, vcf_in1, 
                                     HAS_GZIP_EXT(vcf_in1), 'r')) {
                        LOG_ERROR(&quot;Couldn't open %s\n&quot;, vcf_in1);
                        free(vcf_in1); free(vcf_in2); free(vcf_out);
                        return 1;
                   }
                   if (0 != vcf_skip_header(&amp; vcfset_conf.vcf_in1)) {
                        LOG_WARN(&quot;skip header failed for %s\n&quot;, vcf_in1);
                   }
                   continue;
              }
         }

         is_indel = vcf_var_is_indel(var1);
         if (vcfset_conf.only_snvs &amp;&amp; is_indel) {
              free(var1);
              continue;
         } else if (vcfset_conf.only_indels &amp;&amp; ! is_indel) {
              free(var1);
              continue;
         }

         if (! vcfset_conf.only_pos &amp;&amp; NULL != strchr(var1-&gt;alt, ',')) {
              LOG_FATAL(&quot;%s\n&quot;, &quot;No support for multi-allelic SNVs in vcf1&quot;);
              return -1;
         }
         if (vcfset_conf.only_passed &amp;&amp; ! VCF_VAR_PASSES(var1)) {
#ifdef TRACE
              LOG_DEBUG(&quot;Skipping non-passing var1 %s:%d\n&quot;, var1-&gt;chrom, var1-&gt;pos);
#endif
              num_vars_vcf1_ign += 1;
              vcf_free_var(&amp; var1);
              continue;
         }
         if (add_info_field) {
              vcf_var_add_to_info(var1, add_info_field);
         }
         num_vars_vcf1 += 1;
#ifdef TRACE
         LOG_DEBUG(&quot;Got passing var1 %s:%d\n&quot;, var1-&gt;chrom, var1-&gt;pos);
#endif

         if (vcfset_conf.vcf_setop == SETOP_CONCAT) {
              num_vars_out += 1;
              if (! count_only) {
                   vcf_write_var(&amp; vcfset_conf.vcf_out, var1);
              }
              vcf_free_var(&amp; var1);
              /* skip comparison against vcf2 */
              continue;
         }

         /* use index access to vcf2 */
         snprintf(regbuf, 1024, &quot;%s:%ld-%ld&quot;, var1-&gt;chrom, var1-&gt;pos+1, var1-&gt;pos+1);
         var2_itr = tbx_itr_querys(vcf2_tbx, regbuf);
         if (! var2_itr) {
              var2_match = 0;
         } else {
              var2_match = 0;
              while (tbx_itr_next(vcf2_hts, vcf2_tbx, var2_itr, &amp;var2_kstr) &gt;= 0) {
                   var_t *var2 = NULL;
                   int var2_is_indel = 0;

                   vcf_new_var(&amp;var2);
                   rc = vcf_parse_var_from_line(var2_kstr.s, var2);
                   /* LOG_FIXME(&quot;%d:%s&gt;%s looking at var2 %d:%s&gt;%s (reg %s)\n&quot;, 
                             var1-&gt;pos+1, var1-&gt;ref, var1-&gt;alt,
                             var2-&gt;pos+1, var2-&gt;ref, var2-&gt;alt, regbuf); */
                   if (rc) {
                        LOG_FATAL(&quot;%s\n&quot;, &quot;Error while parsing variant returned from tabix&quot;);
                        return -1;
                   }

                   var2_is_indel = vcf_var_is_indel(var2);

                   /* iterator returns anything overlapping with that 
                    * position, i.e. this also includes up/downstream
                    * indels, so make sure actual position matches */
                   if (var1-&gt;pos != var2-&gt;pos) {
                        var2_match = 0;

                   } else if (vcfset_conf.only_passed &amp;&amp; ! VCF_VAR_PASSES(var2)) {
                        var2_match = 0;

                   } else if (vcfset_conf.only_snvs &amp;&amp; var2_is_indel) {
                        var2_match = 0;

                   } else if (vcfset_conf.only_indels &amp;&amp; ! var2_is_indel) {
                        var2_match = 0;

                   } else if (vcfset_conf.only_pos) {
#ifdef TRACE
                        LOG_DEBUG(&quot;Pos match for var2 %s:%d\n&quot;, var2-&gt;chrom, var2-&gt;pos);
#endif
                        var2_match = 1;

                   } else {
                        if (0==strcmp(var1-&gt;ref, var2-&gt;ref) &amp;&amp; 0==strcmp(var1-&gt;alt, var2-&gt;alt)) {
#ifdef TRACE
                             LOG_DEBUG(&quot;Full match for var2 %s:%d\n&quot;, var2-&gt;chrom, var2-&gt;pos);
#endif
                             var2_match = 1;/* FIXME: check type as well i.e. snv vs indel */                             
                        }
                   }
                   vcf_free_var(&amp;var2);
                   if (var2_match) {
                        break;/* no need to continue */
                   }
              }
         }

         if (vcfset_conf.vcf_setop == SETOP_COMPLEMENT) {
              /* relative complement : elements in A but not B */
              if (!var2_match) {
                   num_vars_out += 1;
                   if (! count_only) {
                        vcf_write_var(&amp; vcfset_conf.vcf_out, var1);
                   }
              }
         } else if (vcfset_conf.vcf_setop == SETOP_INTERSECT) {
              if (var2_match) {
                   num_vars_out += 1;
                   if (! count_only) {
                        vcf_write_var(&amp; vcfset_conf.vcf_out, var1);
                   }
              }

         } else {
              LOG_FATAL(&quot;Internal error: unsupported vcf_setop %d\n&quot;, vcfset_conf.vcf_setop);
              return 1;
         }

         vcf_free_var(&amp; var1);
         tbx_itr_destroy(var2_itr);
    }/* while (1) */

    vcf_file_close(&amp; vcfset_conf.vcf_in1);
    if (vcf_in2) {
         hts_close(vcf2_hts);
         tbx_destroy(vcf2_tbx);
    }
    LOG_VERBOSE(&quot;Parsed %d variants from 1st vcf file (ignoring %d non-passed of those)\n&quot;, 
                num_vars_vcf1 + num_vars_vcf1_ign, num_vars_vcf1_ign);
    LOG_VERBOSE(&quot;Wrote %d variants to output\n&quot;, 
                num_vars_out);
    if (! count_only) {
         vcf_file_close(&amp; vcfset_conf.vcf_out);
    }

    if (0==rc) {
         if (count_only) {
              printf(&quot;%ld\n&quot;, num_vars_out);
         }

         LOG_VERBOSE(&quot;%s\n&quot;, &quot;Successful exit.&quot;);
    }

    free(vcf_in1);
    free(vcf_in2);
    free(vcf_out);


    return rc;
}
/* main_vcfset */

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lofreq_viterbi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- c-file-style: &quot;k&amp;r&quot;; indent-tabs-mode: nil; -*- */
/*********************************************************************
* The MIT License (MIT)
* 
* Copyright (c) 2013,2014 Genome Institute of Singapore
* 
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation files
* (the &quot;Software&quot;), to deal in the Software without restriction,
* including without limitation the rights to use, copy, modify, merge,
* publish, distribute, sublicense, and/or sell copies of the Software,
* and to permit persons to whom the Software is furnished to do so,
* subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
* BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
************************************************************************/


#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;getopt.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;htslib/faidx.h&quot;
#include &quot;htslib/sam.h&quot;
#include &quot;viterbi.h&quot;
#include &quot;log.h&quot;
#include &quot;lofreq_viterbi.h&quot;
#include &quot;utils.h&quot;

#define SANGERQUAL_TO_PHRED(c) ((int)(c)-33)

/* FIXME: implement auto clipping of Q2 tails */

#define RWIN 10

typedef struct {
     samFile *in;
     samFile *out;
     bam_hdr_t *header;
     faidx_t *fai;
     uint32_t tid;
     char *ref;
     int reflen;
} tmpstruct_t;

static void replace_cigar(bam1_t *b, int n, uint32_t *cigar)
{
    if (n != b-&gt;core.n_cigar) {
        int o = b-&gt;core.l_qname + b-&gt;core.n_cigar * 4;
        if (b-&gt;l_data + (n - b-&gt;core.n_cigar) * 4 &gt; b-&gt;m_data) {
            b-&gt;m_data = b-&gt;l_data + (n - b-&gt;core.n_cigar) * 4;
            kroundup32(b-&gt;m_data);
            b-&gt;data = (uint8_t*)realloc(b-&gt;data, b-&gt;m_data);
        }
        memmove(b-&gt;data + b-&gt;core.l_qname + n * 4, b-&gt;data + o, b-&gt;l_data - o);
        memcpy(b-&gt;data + b-&gt;core.l_qname, cigar, n * 4);
        b-&gt;l_data += (n - b-&gt;core.n_cigar) * 4;
        b-&gt;core.n_cigar = n;
    } else memcpy(b-&gt;data + b-&gt;core.l_qname, cigar, n * 4);
}


/* function checks if alignment is made of all Q2s
 * if not, returns remaining values so that median 
 *  can be calculated
 */
int check_Q2(char *bqual, int *num){
    int is_all_Q2 = 1;
    int i, pom = 0;
    int l = strlen(bqual);
    *num = 0;
    for (i=0; i&lt;l; i++){
            if (SANGERQUAL_TO_PHRED(bqual[i]) != 2){
                    pom++;
                    is_all_Q2 = 0;
            }
    }       
    *num = pom;
    return is_all_Q2;
}

void remain(char *bqual, int *remaining){
     int pom = 0;
     int i, q;
     int l = strlen(bqual);
     for (i=0; i&lt;l; i++){
          q = SANGERQUAL_TO_PHRED(bqual[i]);
          if (q != 2){
               remaining[pom] = q;
               pom++;
          }
     }   
}

static int fetch_func(bam1_t *b, void *data, int del_flag, int q2def, int reclip)
{
     /* see
      https://github.com/lh3/bwa/blob/426e54740ca2b9b08e013f28560d01a570a0ab15/ksw.c
      for optimizations and speedups
     */
     tmpstruct_t *tmp = (tmpstruct_t*)data;
     bam1_core_t *c = &amp;b-&gt;core;
     uint8_t *seq = bam_get_seq(b);
     uint32_t *cigar = bam_get_cigar(b);
     int reflen;
    
     if (del_flag) {
          uint8_t *old_nm;
          uint8_t *old_mc;
          uint8_t *old_md;
          uint8_t *old_as;

          /* once you bam_aux_del b will change and all pointers to it, so don't use bam_aux_get again too early */
          
          old_nm = bam_aux_get(b, &quot;NM&quot;);          
          if (old_nm) {          
               bam_aux_del(b, old_nm);
          }

          old_mc = bam_aux_get(b, &quot;MC&quot;);          
          if (old_mc) {          
                bam_aux_del(b, old_mc);          
          }

          old_md = bam_aux_get(b, &quot;MD&quot;);          
          if (old_md) {          
               bam_aux_del(b, old_md);
          }
          
          old_as = bam_aux_get(b, &quot;AS&quot;);                    
          if (old_as) {
               bam_aux_del(b, old_as);
          }
     }

     if (c-&gt;flag &amp; BAM_FUNMAP) {
          sam_write1(tmp-&gt;out, tmp-&gt;header, b);
          return 0;
     }

     /* fetch reference sequence if incorrect tid */
     if (tmp-&gt;tid != c-&gt;tid) {
          if (tmp-&gt;ref) free(tmp-&gt;ref);
          if ((tmp-&gt;ref = 
               fai_fetch(tmp-&gt;fai, tmp-&gt;header-&gt;target_name[c-&gt;tid], &amp;reflen)) == 0) {
               fprintf(stderr, &quot;failed to find reference sequence %s\n&quot;, 
                                tmp-&gt;header-&gt;target_name[c-&gt;tid]);
          }
          strtoupper(tmp-&gt;ref);/* safeguard */
          tmp-&gt;tid = c-&gt;tid;
          tmp-&gt;reflen = reflen;
     }
     int i;

     // remove soft clipped bases
     char query[c-&gt;l_qseq+1];
     char bqual[c-&gt;l_qseq+1];

     int x = c-&gt;pos; // coordinate on reference
     int y = 0; // coordinate on query
     int z = 0; // coordinate on query w/o softclip

     int indels = 0;

     // parse cigar string
     for (i = 0; i &lt; c-&gt;n_cigar; ++i) {
          int j, oplen = cigar[i] &gt;&gt; 4, op = cigar[i]&amp;0xf;
          if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {
               for (j = 0; j &lt; oplen; j++) {
                    query[z] = seq_nt16_str[bam_seqi(seq, y)];
                    bqual[z] = (char)bam_get_qual(b)[y]+33;
                    x++;
                    y++;
                    z++;
               }
          } else if (op == BAM_CHARD_CLIP) {
               /* in theory we should do nothing here but hard clipping info gets lost here FIXME
                */               
               sam_write1(tmp-&gt;out, tmp-&gt;header, b);
               return 1;
          } else if (op == BAM_CDEL) {
               x += oplen;
               indels += 1;
          } else if (op == BAM_CINS) {
               for (j = 0; j &lt; oplen; j++) {
                    query[z] = seq_nt16_str[bam_seqi(seq, y)];
                    bqual[z] = (char)bam_get_qual(b)[y]+33;
                    y++;
                    z++;
               }
               indels += 1;
          } else if (op == BAM_CSOFT_CLIP) {
               for (j = 0; j &lt; oplen; j++) {
                    y++;
               }
          } else {
               LOG_WARN(&quot;Unknown cigar op %d. Not touching read %s\n&quot;, op, bam_get_qname(b));
               sam_write1(tmp-&gt;out, tmp-&gt;header, b);
               return 1;
          }
     }
     query[z] = bqual[z] = '\0';

     if (indels == 0) {
          sam_write1(tmp-&gt;out, tmp-&gt;header, b);
          return 0;
     }
    int len_remaining = 0;
    if (check_Q2(bqual, &amp;len_remaining)) {
		if (reclip){
			// check if first op or last op is I and replace with S
			 int curr_oplen_check = cigar[0] &gt;&gt; 4;
			 int curr_op_check = cigar[0]&amp;0xf;
			 if (curr_op_check == BAM_CINS){
				curr_op_check = BAM_CSOFT_CLIP;
				cigar[0] = curr_oplen_check &lt;&lt;4 | curr_op_check;
			}
			 curr_oplen_check = cigar[c-&gt;n_cigar-1] &gt;&gt; 4;
			 curr_op_check = cigar[c-&gt;n_cigar-1]&amp;0xf;

			 if (curr_op_check == BAM_CINS){
				curr_op_check = BAM_CSOFT_CLIP;
				cigar[c-&gt;n_cigar-1] = curr_oplen_check &lt;&lt;4 | curr_op_check;
			}
			
			replace_cigar(b,c-&gt;n_cigar,cigar);
		}
        sam_write1(tmp-&gt;out, tmp-&gt;header, b);
        return 0;
    }
    int remaining[len_remaining+1];
    remain(bqual, remaining);
    remaining[len_remaining] = '\0';
    if (q2def &lt; 0) {
        q2def = int_median(remaining, len_remaining);
    }
    
     /* get reference with RWIN padding */
     char ref[c-&gt;l_qseq+1+indels+RWIN*2];
     int lower = c-&gt;pos - RWIN;
     lower = lower &lt; 0? 0: lower;
     int upper = x + RWIN;
     upper = upper &gt; tmp-&gt;reflen? tmp-&gt;reflen: upper;
     for (z = 0, i = lower; i &lt; upper; z++, i++) {
          ref[z] = tmp-&gt;ref[i];
     }
     ref[z] = '\0';

     /* run viterbi */
     char *aln = malloc(sizeof(char)*(2*(c-&gt;l_qseq)));
     int shift = viterbi(ref, query, bqual, aln, q2def);

     /* convert to cigar */
     uint32_t *realn_cigar = 0;
     int realn_n_cigar = 0;
     
     /* check if soft-clipped in the front */
     int curr_oplen = cigar[0] &gt;&gt; 4; 
     int curr_op = cigar[0]&amp;0xf;
     if (curr_op == BAM_CSOFT_CLIP) {
          realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
          realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
          realn_n_cigar += 1;
     }
     
     /* get cigar of the realigned query */
     curr_op = aln[0] == 'M' ? 0 : (aln[0] == 'I'? 1 : 2);
     curr_oplen = 1;
     for (i = 1; i &lt; strlen(aln); i++) {
          int this_op = aln[i] == 'M' ? 0 : (aln[i] == 'I' ? 1 : 2);
          if (this_op != curr_op) {
               realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
               realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
               realn_n_cigar += 1;
               curr_op = this_op;
               curr_oplen = 1;
          } else {
               curr_oplen += 1;
          }
     }
     realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
     realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
     realn_n_cigar += 1; 
    
     /* check if soft-clipped in the back */
     curr_oplen = cigar[c-&gt;n_cigar-1] &gt;&gt; 4; 
     curr_op = cigar[c-&gt;n_cigar-1]&amp;0xf;
     if (curr_op == BAM_CSOFT_CLIP) {
          realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
          realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
          realn_n_cigar += 1;
     }

#if 0
     int j;
     for (j = 0; j &lt; realn_n_cigar; j++) {
          curr_oplen = realn_cigar[j] &gt;&gt; 4;
          curr_op = realn_cigar[j]&amp;0xf;
          fprintf(stderr, &quot;op:%d oplen:%d\n&quot;, curr_op, curr_oplen);
     }
#endif

     /* check if read was shifted */
     if (shift-(c-&gt;pos-lower) != 0) {
          LOG_VERBOSE(&quot;Read %s with shift of %d at original pos %s:%d\n&quot;, 
                      bam_get_qname(b), shift-(c-&gt;pos-lower),
                      tmp-&gt;header-&gt;target_name[c-&gt;tid], c-&gt;pos);
          c-&gt;pos = c-&gt;pos + (shift - (c-&gt;pos - lower));
     }
     
	 if (reclip){
		 // check if first op or last op is I and replace with S
		 int curr_oplen_reclip = realn_cigar[0] &gt;&gt; 4;
		 int curr_op_reclip = realn_cigar[0]&amp;0xf;

		 if (curr_op_reclip == BAM_CINS){
			curr_op_reclip = BAM_CSOFT_CLIP;
			realn_cigar[0] = curr_oplen_reclip &lt;&lt;4 | curr_op_reclip;
		}
		 curr_oplen_reclip = realn_cigar[realn_n_cigar-1] &gt;&gt; 4;
		 curr_op_reclip = realn_cigar[realn_n_cigar-1]&amp;0xf;

		 if (curr_op_reclip == BAM_CINS){
			curr_op_reclip = BAM_CSOFT_CLIP;
			realn_cigar[realn_n_cigar-1] = curr_oplen_reclip &lt;&lt;4 | curr_op_reclip;
		}
	}
     replace_cigar(b, realn_n_cigar, realn_cigar);
     sam_write1(tmp-&gt;out, tmp-&gt;header, b);
     free(aln);
     free(realn_cigar);
     return 0;
}

static void usage()
{
     fprintf(stderr, &quot;Usage: lofreq viterbi [options] in.bam\n&quot;);
     fprintf(stderr, &quot;Options:\n&quot;);
     fprintf(stderr, &quot;     -f | --ref FILE     Indexed reference fasta file [null]\n&quot;);
     fprintf(stderr, &quot;     -k | --keepflags    Don't delete flags MC, MD, NM and A, which are all prone to change during realignment.\n&quot;);
     fprintf(stderr, &quot;     -q | --defqual INT  Assume INT as quality for all bases with BQ2. Default (=-1) is to use median quality of bases in read.\n&quot;);
/* experimental. keep enabled but don't tell user about it */
#if 0
     fprintf(stderr, &quot;     -r | --reclip       Reclip insertions and/or deletions on the beginning and end of read to soft clip\n&quot;);
     fprintf(stderr, &quot;                         FILE HAS TO BE PREVIOUSLY UNCLIPPED!!!\n&quot;);
#endif
     fprintf(stderr, &quot;     -o | --out FILE     Output BAM file [- = stdout = default]\n&quot;);
     fprintf(stderr, &quot;          --verbose      Be verbose\n&quot;);
     fprintf(stderr, &quot;\n&quot;);
     fprintf(stderr, &quot;NOTE: Output BAM file will (likely) be unsorted (use samtools sort, e.g. lofreq viterbi ... | samtools sort -')\n&quot;);
}


int main_viterbi(int argc, char *argv[])
{
     tmpstruct_t tmp = {0};
     static int del_flag = 1;
     static int q2default = -1;
	 static int reclip = 0;
     char *bam_out = NULL;
     bam1_t *b = NULL;
 
     if (argc == 2) {
          usage();
          return 1;
     }

     while (1) {
          int c;
<A NAME="0"></A>
          static struct option long_options[] = {
               {&quot;ref&quot;, required_argument, NULL, 'f'},
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match8-0.html#0',2,'match8-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>               {&quot;verbose&quot;, no_argument, &amp;verbose, 1},
               {&quot;keepflags&quot;, no_argument, NULL, 'k'},
			   {&quot;reclip&quot;,	no_argument, NULL, 'r'},
               {&quot;out&quot;, required_argument, NULL, 'o'},
               {&quot;defqual&quot;, required_argument, NULL, 'q'},
               {0,0,0,0}
          };
          
          static const char *long_opts_str = &quot;rkf:q:o:&quot;;
          int long_option_index = 0;

          c = getopt_long(argc-1, argv+1, long_opts_str, long_options, &amp;long_option_index);

          if (c == -1) {
               break;
          }
          switch (c){
          case 'f':</B></FONT>
               if (! file_exists(optarg)) {
                    LOG_FATAL(&quot;Reference fasta file %s does not exist. Exiting...\n&quot;, optarg);
                    return 1;
               }
               tmp.fai = fai_load(optarg);	
               break;
<A NAME="1"></A>          case 'k':
               del_flag = 0;
               break;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match8-0.html#1',2,'match8-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>          case 'q':
               q2default = atoi(optarg);
               break;
		  case 'r':
				reclip = 1;
				break;
          case 'o':
               if (0 != strcmp(optarg, &quot;-&quot;)) {
                    if (file_exists(optarg)) {
                         LOG_FATAL(&quot;Cowardly refusing to overwrite file '%s'. Exiting...\n&quot;, optarg);
                         return 1;
                    }
               }
               bam_out = strdup(optarg);
               break;
          case '?':</B></FONT>
               LOG_FATAL(&quot;%s\n&quot;, &quot;Unrecognized arguments found. Exiting\n&quot;);
               usage();
               break;
          default:
               break;
          }
     }


     if (! tmp.fai) {
          LOG_FATAL(&quot;%s\n&quot;, &quot;Couldn't load reference fasta file\n&quot;);
          usage();
          return 1;
     }

     /* get bam file */
     if (1 != argc-optind-1){
          LOG_FATAL(&quot;%s\n&quot;, &quot;Need exactly one BAM file as last argument\n&quot;);
          return 1;
     }
     if ((tmp.in = sam_open((argv+optind+1)[0], &quot;rb&quot;)) == 0){
          LOG_FATAL(&quot;Failed to open BAM file %s. Exiting...\n&quot;, (argv+optind+1)[0]);
          return 1;
     }
     if ((tmp.header = sam_hdr_read(tmp.in)) == 0) {
          LOG_FATAL(&quot;Failed to read headers from BAM file %s. Exiting...\n&quot;, (argv+optind+1)[0]);
          return 1;
     }

     if (!bam_out || bam_out[0] == '-') {
          tmp.out = sam_open(&quot;-&quot;, &quot;wb&quot;);
     } else {
          tmp.out = sam_open(bam_out, &quot;wb&quot;);
     }
     sam_hdr_write(tmp.out, tmp.header);
     
     b = bam_init1();
     tmp.tid = -1;
     tmp.ref = 0;
     while (sam_read1(tmp.in, tmp.header, b) &gt;= 0){
          fetch_func(b, &amp;tmp, del_flag, q2default, reclip);
     }
     bam_destroy1(b);
     bam_hdr_destroy(tmp.header);
     sam_close(tmp.in);
     sam_close(tmp.out);
     if (tmp.ref)
          free(tmp.ref);
     fai_destroy(tmp.fai);
     free(bam_out);

     LOG_VERBOSE(&quot;%s\n&quot;, &quot;NOTE: Output BAM file will be unsorted (use samtools sort, e.g. samtools sort -')&quot;);

     return 0;
}
</PRE>
</div>
  </div>
</body>
</html>
