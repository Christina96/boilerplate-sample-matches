<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lofreq_vcfset.c &amp; lofreq_viterbi.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lofreq_vcfset.c &amp; lofreq_viterbi.c
      </h3>
<h1 align="center">
        10.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lofreq_vcfset.c (11.007026%)<th>lofreq_viterbi.c (10.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(156-178)<td><a href="#" name="0">(385-402)</a><td align="center"><font color="#ff0000">30</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(183-202)<td><a href="#" name="1">(412-427)</a><td align="center"><font color="#900000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lofreq_vcfset.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;stdio.h&gt;
2 #include &lt;string.h&gt;
3 #include &lt;errno.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;stdarg.h&gt;
6 #include &lt;getopt.h&gt;
7 #include &lt;stdlib.h&gt;
8 #include "htslib/kstring.h"
9 #include "htslib/tbx.h"
10 #include "lofreq_vcfset.h"
11 #include "vcf.h"
12 #include "log.h"
13 #include "utils.h"
14 #if 1
15 #define MYNAME "lofreq vcfset"
16 #else
17 #define MYNAME PACKAGE
18 #endif
19 typedef enum {
20      SETOP_UNKNOWN,
21      SETOP_INTERSECT,
22      SETOP_COMPLEMENT, 
23      SETOP_CONCAT
24 } vcfset_op_t;
25 typedef struct {
26      vcf_file_t vcf_in1;
27      vcf_file_t vcf_in2;
28      vcf_file_t vcf_out;
29      vcfset_op_t vcf_setop;
30      int only_passed;      int only_pos;      int only_snvs;
31      int only_indels;
32 } vcfset_conf_t;
33 static void
34 usage(const vcfset_conf_t* vcfset_conf)
35 {
36      fprintf(stderr, "%s: Perform set operations on two vcf files\n\n", MYNAME);
37      fprintf(stderr, "Usage: %s [options] -a op -1 1.vcf -2 2.vcf \n", MYNAME);
38      fprintf(stderr,"Options:\n");
39      fprintf(stderr, "  -1 | --vcf1 FILE      1st VCF input file (bgzip supported)\n");
40      fprintf(stderr, "  -2 | --vcf2 FILE      2nd VCF input file (mandatory - except for concat - and needs to be tabix indexed)\n");
41      fprintf(stderr, "  -o | --vcfout         VCF output file (default: - for stdout; gzip supported).\n");
42      fprintf(stderr, "  -a | --action         Set operation to perform: intersect, complement or concat.\n"
43              "                        - intersect = vcf1 AND vcf2.\n"
44              "                        - complement = vcf1 \\ vcf2.\n"
45              "                        - concat = vcf1 + vcf2 ... vcfn (output as in file order, i.e. output not necessarily sorted!)\n");
46      fprintf(stderr, "  -I | --add-info STR   Add info field, e.g. 'SOMATIC'\n");
47      fprintf(stderr, "       --count-only     Don't print bases, just numbers\n");
48      fprintf(stderr, "       --only-pos       Disable allele-awareness by using position only (ignoring bases) as key for storing and comparison\n");
49      fprintf(stderr, "       --only-passed    Ignore variants marked as filtered\n");
50      fprintf(stderr, "       --only-snvs      Ignore anything but SNVs in both input files\n");
51      fprintf(stderr, "       --only-indels    Ignore anything but indels in both input files\n");
52      fprintf(stderr, "       --verbose        Be verbose\n");
53      fprintf(stderr, "       --debug          Enable debugging\n");
54      fprintf(stderr, "\nNote, vcf1 is always fully parsed, whereas indexing is used for vcf2.\n");
55      fprintf(stderr, "Therefore, use the bigger file as vcf2 to speed things up.\n");
56      fprintf(stderr, "Header/meta-data for the output file is taken from vcf1\n");
57 }
58 int 
59 main_vcfset(int argc, char *argv[])
60 {
61      vcfset_conf_t vcfset_conf;
62      char *vcf_header = NULL;
63      int rc = 0;
64      char *vcf_in1, *vcf_in2, *vcf_out;
65      long int num_vars_vcf1;
66      long int num_vars_vcf1_ign, num_vars_out;
67      static int only_passed = 0;
68      static int only_pos = 0;
69      static int only_snvs = 0;
70      static int only_indels = 0;
71      static int count_only = 0;
72      tbx_t *vcf2_tbx = NULL;      htsFile *vcf2_hts = NULL;
73      char *add_info_field = NULL;
74      int vcf_concat_findex = 0;
75      vcf_in1 = vcf_in2 = vcf_out = NULL;
76      num_vars_vcf1 = 0;
77      num_vars_vcf1_ign = num_vars_out = 0;
78      memset(&amp;vcfset_conf, 0, sizeof(vcfset_conf_t));
79     while (1) {
80          int c;
81          static struct option long_opts[] = {
82               {"help", no_argument, NULL, 'h'},
83               {"verbose", no_argument, &amp;verbose, 1},
84               {"debug", no_argument, &amp;debug, 1},
85               {"only-passed", no_argument, &amp;only_passed, 1},
86               {"only-pos", no_argument, &amp;only_pos, 1},
87               {"only-indels", no_argument, &amp;only_indels, 1},
88 <a name="0"></a>              {"only-snvs", no_argument, &amp;only_snvs, 1},
89               {"count-only", no_argument, &amp;count_only, 1},
90 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>              {"vcf1", required_argument, NULL, '1'},
91               {"vcf2", required_argument, NULL, '2'},
92               {"vcfout", required_argument, NULL, 'o'},
93               {"action", required_argument, NULL, 'a'},
94               {"add-info", required_argument, NULL, 'I'},
95               {0, 0, 0, 0}          };
96          static const char *long_opts_str = "h1:2:o:a:I:";
97          int long_opts_index = 0;
98          c = getopt_long(argc-1, argv+1,                          long_opts_str, long_opts, &amp; long_opts_index);
99          if (c == -1) {
100               break;
101          }
102          switch (c) {
103          case 'h': </b></font>
104               usage(&amp; vcfset_conf); 
105 <a name="1"></a>              free(vcf_in1); free(vcf_in2); free(vcf_out);
106               return 0;
107 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>         case '1': 
108               vcf_in1 = strdup(optarg);
109               break;
110          case '2': 
111               vcf_in2 = strdup(optarg);
112               break;
113          case 'o':
114               if (0 != strcmp(optarg, "-")) {
115                    if (file_exists(optarg)) {
116                         LOG_FATAL("Cowardly refusing to overwrite file '%s'. Exiting...\n", optarg);
117                         free(vcf_in1); free(vcf_in2);
118                         return 1;
119                    }
120               }
121               vcf_out = strdup(optarg);
122               break;
123          case 'a': </b></font>
124               if (0 == strcmp(optarg, "intersect")) {
125                    vcfset_conf.vcf_setop = SETOP_INTERSECT;
126               } else if (0 == strcmp(optarg, "complement")) {
127                    vcfset_conf.vcf_setop = SETOP_COMPLEMENT;
128               } else if (0 == strcmp(optarg, "concat")) {
129                    vcfset_conf.vcf_setop = SETOP_CONCAT;
130               } else {
131                    LOG_FATAL("Unknown action '%s'. Exiting...\n", optarg);
132                    free(vcf_in1); free(vcf_in2); free(vcf_out);
133                    return 1;
134               }
135               break;
136          case 'I': 
137               add_info_field = strdup(optarg);
138               break;
139          case '?': 
140               LOG_FATAL("%s\n", "unrecognized arguments found. Exiting...\n"); 
141               free(vcf_in1); free(vcf_in2); free(vcf_out);
142               return 1;
143          default:
144               break;
145          }
146     }
147     vcfset_conf.only_passed = only_passed;
148     vcfset_conf.only_pos = only_pos;
149     vcfset_conf.only_snvs = only_snvs;
150     vcfset_conf.only_indels = only_indels;
151     if (vcfset_conf.only_indels &amp;&amp; vcfset_conf.only_snvs) {
152          LOG_FATAL("%s\n", "Can't take only indels *and* only snvs into account");
153          return 1;
154     }
155     if (0 != argc - optind - 1) {
156          if (vcfset_conf.vcf_setop == SETOP_CONCAT) {
157               vcf_concat_findex = optind;
158          } else {
159               LOG_FATAL("%s\n", "Unrecognized arguments found\n");
160               return 1;
161          }
162     } else {
163          if (vcfset_conf.vcf_setop == SETOP_CONCAT) {
164               LOG_FATAL("%s\n", "No extra files for concat given\n");
165               return 1;
166          }
167     }
168 #if 0
169     int i; for (i=optind+1; i&lt;argc; i++) {
170          LOG_FIXME("argv[%d]=%s\n", i, argv[i]);
171     }
172 #endif
173     if (argc == 2) {
174         fprintf(stderr, "\n");
175         usage(&amp; vcfset_conf);
176         free(vcf_in1); free(vcf_in2); free(vcf_out);
177         return 1;
178     }
179     if (vcfset_conf.vcf_setop == SETOP_UNKNOWN) {
180          LOG_FATAL("%s\n", "No set operation specified");
181          usage(&amp; vcfset_conf);
182          free(vcf_in1); free(vcf_in2); free(vcf_out);
183          return 1;
184     }
185     if  (vcf_in1 == NULL || (vcf_in2 == NULL &amp;&amp; vcfset_conf.vcf_setop != SETOP_CONCAT)) {
186          LOG_FATAL("%s\n\n", "At least one vcf input file not specified");
187          usage(&amp; vcfset_conf);
188          free(vcf_in1); free(vcf_in2); free(vcf_out);
189          return 1;
190     }
191     if (vcf_in2 != NULL &amp;&amp; vcfset_conf.vcf_setop == SETOP_CONCAT) {
192          LOG_FATAL("%s\n\n", "For concat just use the -1 option followed by all other vcf files instead of using -2");
193          usage(&amp; vcfset_conf);
194          free(vcf_in1); free(vcf_in2); free(vcf_out);
195          return 1;         
196     }
197     if (vcf_file_open(&amp; vcfset_conf.vcf_in1, vcf_in1, 
198                       HAS_GZIP_EXT(vcf_in1), 'r')) {
199          LOG_ERROR("Couldn't open %s\n", vcf_in1);
200          free(vcf_in1); free(vcf_in2); free(vcf_out);
201          return 1;
202     }
203     if (vcf_in2) {
204          vcf2_hts = hts_open(vcf_in2, "r");
205          if (!vcf2_hts) {
206               LOG_FATAL("Couldn't load %s\n", vcf_in2);
207               return 1;
208          }
209          vcf2_tbx = tbx_index_load(vcf_in2);
210          if (!vcf2_tbx) {
211               LOG_FATAL("Couldn't load tabix index for %s\n", vcf_in2);
212               return 1;
213          }
214     }
215     if (! vcf_out) {
216          vcf_out = malloc(2 * sizeof(char));
217          strcpy(vcf_out, "-");
218     }
219     if (! count_only) {
220          if (vcf_file_open(&amp; vcfset_conf.vcf_out, vcf_out, 
221                            HAS_GZIP_EXT(vcf_out), 'w')) {
222               LOG_ERROR("Couldn't open %s\n", vcf_out);
223               free(vcf_in1); free(vcf_in2); free(vcf_out);
224               return 1;
225          }
226     }
227     LOG_DEBUG("Getting header from %s\n", vcf_in1);
228     if (0 !=  vcf_parse_header(&amp;vcf_header, &amp; vcfset_conf.vcf_in1)) {
229          LOG_WARN("%s\n", "vcf_parse_header() failed");
230          if (vcf_file_seek(&amp; vcfset_conf.vcf_in1, 0, SEEK_SET)) {
231               LOG_FATAL("%s\n", "Couldn't rewind file to parse variants"
232                         " after header parsing failed");
233               return -1;
234          }
235     } else {
236          if (! count_only) {
237               vcf_write_header(&amp; vcfset_conf.vcf_out, vcf_header);
238          }
239          free(vcf_header);
240     }
241     LOG_DEBUG("Starting to parse variants from %s\n", vcf_in1);
242     while (1) {
243          var_t *var1 = NULL;
244          int rc;
245          int is_indel;
246          kstring_t var2_kstr = {0, 0, 0};
247          hts_itr_t *var2_itr = NULL;
248          char regbuf[1024];
249          int var2_match = 0;
250          vcf_new_var(&amp;var1);
251          rc = vcf_parse_var(&amp; vcfset_conf.vcf_in1, var1);
252          if (rc) {
253               free(var1);
254               if (vcfset_conf.vcf_setop != SETOP_CONCAT) {
255                    break;
256               } else {
257                    vcf_concat_findex++;
258                    if (vcf_concat_findex==argc) {
259                         break;
260                    }
261                    vcf_file_close(&amp; vcfset_conf.vcf_in1);
262                    free(vcf_in1);
263                    vcf_in1 = strdup(argv[vcf_concat_findex]);
264                    LOG_DEBUG("updated vcf_in1 = %s\n", vcf_in1);
265                    if (vcf_file_open(&amp; vcfset_conf.vcf_in1, vcf_in1, 
266                                      HAS_GZIP_EXT(vcf_in1), 'r')) {
267                         LOG_ERROR("Couldn't open %s\n", vcf_in1);
268                         free(vcf_in1); free(vcf_in2); free(vcf_out);
269                         return 1;
270                    }
271                    if (0 != vcf_skip_header(&amp; vcfset_conf.vcf_in1)) {
272                         LOG_WARN("skip header failed for %s\n", vcf_in1);
273                    }
274                    continue;
275               }
276          }
277          is_indel = vcf_var_is_indel(var1);
278          if (vcfset_conf.only_snvs &amp;&amp; is_indel) {
279               free(var1);
280               continue;
281          } else if (vcfset_conf.only_indels &amp;&amp; ! is_indel) {
282               free(var1);
283               continue;
284          }
285          if (! vcfset_conf.only_pos &amp;&amp; NULL != strchr(var1-&gt;alt, ',')) {
286               LOG_FATAL("%s\n", "No support for multi-allelic SNVs in vcf1");
287               return -1;
288          }
289          if (vcfset_conf.only_passed &amp;&amp; ! VCF_VAR_PASSES(var1)) {
290 #ifdef TRACE
291               LOG_DEBUG("Skipping non-passing var1 %s:%d\n", var1-&gt;chrom, var1-&gt;pos);
292 #endif
293               num_vars_vcf1_ign += 1;
294               vcf_free_var(&amp; var1);
295               continue;
296          }
297          if (add_info_field) {
298               vcf_var_add_to_info(var1, add_info_field);
299          }
300          num_vars_vcf1 += 1;
301 #ifdef TRACE
302          LOG_DEBUG("Got passing var1 %s:%d\n", var1-&gt;chrom, var1-&gt;pos);
303 #endif
304          if (vcfset_conf.vcf_setop == SETOP_CONCAT) {
305               num_vars_out += 1;
306               if (! count_only) {
307                    vcf_write_var(&amp; vcfset_conf.vcf_out, var1);
308               }
309               vcf_free_var(&amp; var1);
310               continue;
311          }
312          snprintf(regbuf, 1024, "%s:%ld-%ld", var1-&gt;chrom, var1-&gt;pos+1, var1-&gt;pos+1);
313          var2_itr = tbx_itr_querys(vcf2_tbx, regbuf);
314          if (! var2_itr) {
315               var2_match = 0;
316          } else {
317               var2_match = 0;
318               while (tbx_itr_next(vcf2_hts, vcf2_tbx, var2_itr, &amp;var2_kstr) &gt;= 0) {
319                    var_t *var2 = NULL;
320                    int var2_is_indel = 0;
321                    vcf_new_var(&amp;var2);
322                    rc = vcf_parse_var_from_line(var2_kstr.s, var2);
323                    if (rc) {
324                         LOG_FATAL("%s\n", "Error while parsing variant returned from tabix");
325                         return -1;
326                    }
327                    var2_is_indel = vcf_var_is_indel(var2);
328                    if (var1-&gt;pos != var2-&gt;pos) {
329                         var2_match = 0;
330                    } else if (vcfset_conf.only_passed &amp;&amp; ! VCF_VAR_PASSES(var2)) {
331                         var2_match = 0;
332                    } else if (vcfset_conf.only_snvs &amp;&amp; var2_is_indel) {
333                         var2_match = 0;
334                    } else if (vcfset_conf.only_indels &amp;&amp; ! var2_is_indel) {
335                         var2_match = 0;
336                    } else if (vcfset_conf.only_pos) {
337 #ifdef TRACE
338                         LOG_DEBUG("Pos match for var2 %s:%d\n", var2-&gt;chrom, var2-&gt;pos);
339 #endif
340                         var2_match = 1;
341                    } else {
342                         if (0==strcmp(var1-&gt;ref, var2-&gt;ref) &amp;&amp; 0==strcmp(var1-&gt;alt, var2-&gt;alt)) {
343 #ifdef TRACE
344                              LOG_DEBUG("Full match for var2 %s:%d\n", var2-&gt;chrom, var2-&gt;pos);
345 #endif
346                              var2_match = 1;                        }
347                    }
348                    vcf_free_var(&amp;var2);
349                    if (var2_match) {
350                         break;                   }
351               }
352          }
353          if (vcfset_conf.vcf_setop == SETOP_COMPLEMENT) {
354               if (!var2_match) {
355                    num_vars_out += 1;
356                    if (! count_only) {
357                         vcf_write_var(&amp; vcfset_conf.vcf_out, var1);
358                    }
359               }
360          } else if (vcfset_conf.vcf_setop == SETOP_INTERSECT) {
361               if (var2_match) {
362                    num_vars_out += 1;
363                    if (! count_only) {
364                         vcf_write_var(&amp; vcfset_conf.vcf_out, var1);
365                    }
366               }
367          } else {
368               LOG_FATAL("Internal error: unsupported vcf_setop %d\n", vcfset_conf.vcf_setop);
369               return 1;
370          }
371          vcf_free_var(&amp; var1);
372          tbx_itr_destroy(var2_itr);
373     }
374     vcf_file_close(&amp; vcfset_conf.vcf_in1);
375     if (vcf_in2) {
376          hts_close(vcf2_hts);
377          tbx_destroy(vcf2_tbx);
378     }
379     LOG_VERBOSE("Parsed %d variants from 1st vcf file (ignoring %d non-passed of those)\n", 
380                 num_vars_vcf1 + num_vars_vcf1_ign, num_vars_vcf1_ign);
381     LOG_VERBOSE("Wrote %d variants to output\n", 
382                 num_vars_out);
383     if (! count_only) {
384          vcf_file_close(&amp; vcfset_conf.vcf_out);
385     }
386     if (0==rc) {
387          if (count_only) {
388               printf("%ld\n", num_vars_out);
389          }
390          LOG_VERBOSE("%s\n", "Successful exit.");
391     }
392     free(vcf_in1);
393     free(vcf_in2);
394     free(vcf_out);
395     return rc;
396 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lofreq_viterbi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;ctype.h&gt;
2 #include &lt;stdio.h&gt;
3 #include &lt;getopt.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include "htslib/faidx.h"
6 #include "htslib/sam.h"
7 #include "viterbi.h"
8 #include "log.h"
9 #include "lofreq_viterbi.h"
10 #include "utils.h"
11 #define SANGERQUAL_TO_PHRED(c) ((int)(c)-33)
12 #define RWIN 10
13 typedef struct {
14      samFile *in;
15      samFile *out;
16      bam_hdr_t *header;
17      faidx_t *fai;
18      uint32_t tid;
19      char *ref;
20      int reflen;
21 } tmpstruct_t;
22 static void replace_cigar(bam1_t *b, int n, uint32_t *cigar)
23 {
24     if (n != b-&gt;core.n_cigar) {
25         int o = b-&gt;core.l_qname + b-&gt;core.n_cigar * 4;
26         if (b-&gt;l_data + (n - b-&gt;core.n_cigar) * 4 &gt; b-&gt;m_data) {
27             b-&gt;m_data = b-&gt;l_data + (n - b-&gt;core.n_cigar) * 4;
28             kroundup32(b-&gt;m_data);
29             b-&gt;data = (uint8_t*)realloc(b-&gt;data, b-&gt;m_data);
30         }
31         memmove(b-&gt;data + b-&gt;core.l_qname + n * 4, b-&gt;data + o, b-&gt;l_data - o);
32         memcpy(b-&gt;data + b-&gt;core.l_qname, cigar, n * 4);
33         b-&gt;l_data += (n - b-&gt;core.n_cigar) * 4;
34         b-&gt;core.n_cigar = n;
35     } else memcpy(b-&gt;data + b-&gt;core.l_qname, cigar, n * 4);
36 }
37 int check_Q2(char *bqual, int *num){
38     int is_all_Q2 = 1;
39     int i, pom = 0;
40     int l = strlen(bqual);
41     *num = 0;
42     for (i=0; i&lt;l; i++){
43             if (SANGERQUAL_TO_PHRED(bqual[i]) != 2){
44                     pom++;
45                     is_all_Q2 = 0;
46             }
47     }       
48     *num = pom;
49     return is_all_Q2;
50 }
51 void remain(char *bqual, int *remaining){
52      int pom = 0;
53      int i, q;
54      int l = strlen(bqual);
55      for (i=0; i&lt;l; i++){
56           q = SANGERQUAL_TO_PHRED(bqual[i]);
57           if (q != 2){
58                remaining[pom] = q;
59                pom++;
60           }
61      }   
62 }
63 static int fetch_func(bam1_t *b, void *data, int del_flag, int q2def, int reclip)
64 {
65      tmpstruct_t *tmp = (tmpstruct_t*)data;
66      bam1_core_t *c = &amp;b-&gt;core;
67      uint8_t *seq = bam_get_seq(b);
68      uint32_t *cigar = bam_get_cigar(b);
69      int reflen;
70      if (del_flag) {
71           uint8_t *old_nm;
72           uint8_t *old_mc;
73           uint8_t *old_md;
74           uint8_t *old_as;
75           old_nm = bam_aux_get(b, "NM");          
76           if (old_nm) {          
77                bam_aux_del(b, old_nm);
78           }
79           old_mc = bam_aux_get(b, "MC");          
80           if (old_mc) {          
81                 bam_aux_del(b, old_mc);          
82           }
83           old_md = bam_aux_get(b, "MD");          
84           if (old_md) {          
85                bam_aux_del(b, old_md);
86           }
87           old_as = bam_aux_get(b, "AS");                    
88           if (old_as) {
89                bam_aux_del(b, old_as);
90           }
91      }
92      if (c-&gt;flag &amp; BAM_FUNMAP) {
93           sam_write1(tmp-&gt;out, tmp-&gt;header, b);
94           return 0;
95      }
96      if (tmp-&gt;tid != c-&gt;tid) {
97           if (tmp-&gt;ref) free(tmp-&gt;ref);
98           if ((tmp-&gt;ref = 
99                fai_fetch(tmp-&gt;fai, tmp-&gt;header-&gt;target_name[c-&gt;tid], &amp;reflen)) == 0) {
100                fprintf(stderr, "failed to find reference sequence %s\n", 
101                                 tmp-&gt;header-&gt;target_name[c-&gt;tid]);
102           }
103           strtoupper(tmp-&gt;ref);          tmp-&gt;tid = c-&gt;tid;
104           tmp-&gt;reflen = reflen;
105      }
106      int i;
107      char query[c-&gt;l_qseq+1];
108      char bqual[c-&gt;l_qseq+1];
109      int x = c-&gt;pos;      int y = 0;      int z = 0; 
110      int indels = 0;
111      for (i = 0; i &lt; c-&gt;n_cigar; ++i) {
112           int j, oplen = cigar[i] &gt;&gt; 4, op = cigar[i]&amp;0xf;
113           if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {
114                for (j = 0; j &lt; oplen; j++) {
115                     query[z] = seq_nt16_str[bam_seqi(seq, y)];
116                     bqual[z] = (char)bam_get_qual(b)[y]+33;
117                     x++;
118                     y++;
119                     z++;
120                }
121           } else if (op == BAM_CHARD_CLIP) {
122                sam_write1(tmp-&gt;out, tmp-&gt;header, b);
123                return 1;
124           } else if (op == BAM_CDEL) {
125                x += oplen;
126                indels += 1;
127           } else if (op == BAM_CINS) {
128                for (j = 0; j &lt; oplen; j++) {
129                     query[z] = seq_nt16_str[bam_seqi(seq, y)];
130                     bqual[z] = (char)bam_get_qual(b)[y]+33;
131                     y++;
132                     z++;
133                }
134                indels += 1;
135           } else if (op == BAM_CSOFT_CLIP) {
136                for (j = 0; j &lt; oplen; j++) {
137                     y++;
138                }
139           } else {
140                LOG_WARN("Unknown cigar op %d. Not touching read %s\n", op, bam_get_qname(b));
141                sam_write1(tmp-&gt;out, tmp-&gt;header, b);
142                return 1;
143           }
144      }
145      query[z] = bqual[z] = '\0';
146      if (indels == 0) {
147           sam_write1(tmp-&gt;out, tmp-&gt;header, b);
148           return 0;
149      }
150     int len_remaining = 0;
151     if (check_Q2(bqual, &amp;len_remaining)) {
152 		if (reclip){
153 			 int curr_oplen_check = cigar[0] &gt;&gt; 4;
154 			 int curr_op_check = cigar[0]&amp;0xf;
155 			 if (curr_op_check == BAM_CINS){
156 				curr_op_check = BAM_CSOFT_CLIP;
157 				cigar[0] = curr_oplen_check &lt;&lt;4 | curr_op_check;
158 			}
159 			 curr_oplen_check = cigar[c-&gt;n_cigar-1] &gt;&gt; 4;
160 			 curr_op_check = cigar[c-&gt;n_cigar-1]&amp;0xf;
161 			 if (curr_op_check == BAM_CINS){
162 				curr_op_check = BAM_CSOFT_CLIP;
163 				cigar[c-&gt;n_cigar-1] = curr_oplen_check &lt;&lt;4 | curr_op_check;
164 			}
165 			replace_cigar(b,c-&gt;n_cigar,cigar);
166 		}
167         sam_write1(tmp-&gt;out, tmp-&gt;header, b);
168         return 0;
169     }
170     int remaining[len_remaining+1];
171     remain(bqual, remaining);
172     remaining[len_remaining] = '\0';
173     if (q2def &lt; 0) {
174         q2def = int_median(remaining, len_remaining);
175     }
176      char ref[c-&gt;l_qseq+1+indels+RWIN*2];
177      int lower = c-&gt;pos - RWIN;
178      lower = lower &lt; 0? 0: lower;
179      int upper = x + RWIN;
180      upper = upper &gt; tmp-&gt;reflen? tmp-&gt;reflen: upper;
181      for (z = 0, i = lower; i &lt; upper; z++, i++) {
182           ref[z] = tmp-&gt;ref[i];
183      }
184      ref[z] = '\0';
185      char *aln = malloc(sizeof(char)*(2*(c-&gt;l_qseq)));
186      int shift = viterbi(ref, query, bqual, aln, q2def);
187      uint32_t *realn_cigar = 0;
188      int realn_n_cigar = 0;
189      int curr_oplen = cigar[0] &gt;&gt; 4; 
190      int curr_op = cigar[0]&amp;0xf;
191      if (curr_op == BAM_CSOFT_CLIP) {
192           realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
193           realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
194           realn_n_cigar += 1;
195      }
196      curr_op = aln[0] == 'M' ? 0 : (aln[0] == 'I'? 1 : 2);
197      curr_oplen = 1;
198      for (i = 1; i &lt; strlen(aln); i++) {
199           int this_op = aln[i] == 'M' ? 0 : (aln[i] == 'I' ? 1 : 2);
200           if (this_op != curr_op) {
201                realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
202                realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
203                realn_n_cigar += 1;
204                curr_op = this_op;
205                curr_oplen = 1;
206           } else {
207                curr_oplen += 1;
208           }
209      }
210      realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
211      realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
212      realn_n_cigar += 1; 
213      curr_oplen = cigar[c-&gt;n_cigar-1] &gt;&gt; 4; 
214      curr_op = cigar[c-&gt;n_cigar-1]&amp;0xf;
215      if (curr_op == BAM_CSOFT_CLIP) {
216           realn_cigar = realloc(realn_cigar, (realn_n_cigar+1)*sizeof(uint32_t));
217           realn_cigar[realn_n_cigar] = curr_oplen&lt;&lt;4 | curr_op;
218           realn_n_cigar += 1;
219      }
220 #if 0
221      int j;
222      for (j = 0; j &lt; realn_n_cigar; j++) {
223           curr_oplen = realn_cigar[j] &gt;&gt; 4;
224           curr_op = realn_cigar[j]&amp;0xf;
225           fprintf(stderr, "op:%d oplen:%d\n", curr_op, curr_oplen);
226      }
227 #endif
228      if (shift-(c-&gt;pos-lower) != 0) {
229           LOG_VERBOSE("Read %s with shift of %d at original pos %s:%d\n", 
230                       bam_get_qname(b), shift-(c-&gt;pos-lower),
231                       tmp-&gt;header-&gt;target_name[c-&gt;tid], c-&gt;pos);
232           c-&gt;pos = c-&gt;pos + (shift - (c-&gt;pos - lower));
233      }
234 	 if (reclip){
235 		 int curr_oplen_reclip = realn_cigar[0] &gt;&gt; 4;
236 		 int curr_op_reclip = realn_cigar[0]&amp;0xf;
237 		 if (curr_op_reclip == BAM_CINS){
238 			curr_op_reclip = BAM_CSOFT_CLIP;
239 			realn_cigar[0] = curr_oplen_reclip &lt;&lt;4 | curr_op_reclip;
240 		}
241 		 curr_oplen_reclip = realn_cigar[realn_n_cigar-1] &gt;&gt; 4;
242 		 curr_op_reclip = realn_cigar[realn_n_cigar-1]&amp;0xf;
243 		 if (curr_op_reclip == BAM_CINS){
244 			curr_op_reclip = BAM_CSOFT_CLIP;
245 			realn_cigar[realn_n_cigar-1] = curr_oplen_reclip &lt;&lt;4 | curr_op_reclip;
246 		}
247 	}
248      replace_cigar(b, realn_n_cigar, realn_cigar);
249      sam_write1(tmp-&gt;out, tmp-&gt;header, b);
250      free(aln);
251      free(realn_cigar);
252      return 0;
253 }
254 static void usage()
255 {
256      fprintf(stderr, "Usage: lofreq viterbi [options] in.bam\n");
257      fprintf(stderr, "Options:\n");
258      fprintf(stderr, "     -f | --ref FILE     Indexed reference fasta file [null]\n");
259      fprintf(stderr, "     -k | --keepflags    Don't delete flags MC, MD, NM and A, which are all prone to change during realignment.\n");
260      fprintf(stderr, "     -q | --defqual INT  Assume INT as quality for all bases with BQ2. Default (=-1) is to use median quality of bases in read.\n");
261 #if 0
262      fprintf(stderr, "     -r | --reclip       Reclip insertions and/or deletions on the beginning and end of read to soft clip\n");
263      fprintf(stderr, "                         FILE HAS TO BE PREVIOUSLY UNCLIPPED!!!\n");
264 #endif
265      fprintf(stderr, "     -o | --out FILE     Output BAM file [- = stdout = default]\n");
266      fprintf(stderr, "          --verbose      Be verbose\n");
267      fprintf(stderr, "\n");
268      fprintf(stderr, "NOTE: Output BAM file will (likely) be unsorted (use samtools sort, e.g. lofreq viterbi ... | samtools sort -')\n");
269 }
270 int main_viterbi(int argc, char *argv[])
271 {
272      tmpstruct_t tmp = {0};
273      static int del_flag = 1;
274      static int q2default = -1;
275 	 static int reclip = 0;
276      char *bam_out = NULL;
277      bam1_t *b = NULL;
278      if (argc == 2) {
279           usage();
280           return 1;
281      }
282      while (1) {
283           int c;
284 <a name="0"></a>
285           static struct option long_options[] = {
286                {"ref", required_argument, NULL, 'f'},
287 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>               {"verbose", no_argument, &amp;verbose, 1},
288                {"keepflags", no_argument, NULL, 'k'},
289 			   {"reclip",	no_argument, NULL, 'r'},
290                {"out", required_argument, NULL, 'o'},
291                {"defqual", required_argument, NULL, 'q'},
292                {0,0,0,0}
293           };
294           static const char *long_opts_str = "rkf:q:o:";
295           int long_option_index = 0;
296           c = getopt_long(argc-1, argv+1, long_opts_str, long_options, &amp;long_option_index);
297           if (c == -1) {
298                break;
299           }
300           switch (c){
301           case 'f':</b></font>
302                if (! file_exists(optarg)) {
303                     LOG_FATAL("Reference fasta file %s does not exist. Exiting...\n", optarg);
304                     return 1;
305                }
306                tmp.fai = fai_load(optarg);	
307                break;
308 <a name="1"></a>          case 'k':
309                del_flag = 0;
310                break;
311 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          case 'q':
312                q2default = atoi(optarg);
313                break;
314 		  case 'r':
315 				reclip = 1;
316 				break;
317           case 'o':
318                if (0 != strcmp(optarg, "-")) {
319                     if (file_exists(optarg)) {
320                          LOG_FATAL("Cowardly refusing to overwrite file '%s'. Exiting...\n", optarg);
321                          return 1;
322                     }
323                }
324                bam_out = strdup(optarg);
325                break;
326           case '?':</b></font>
327                LOG_FATAL("%s\n", "Unrecognized arguments found. Exiting\n");
328                usage();
329                break;
330           default:
331                break;
332           }
333      }
334      if (! tmp.fai) {
335           LOG_FATAL("%s\n", "Couldn't load reference fasta file\n");
336           usage();
337           return 1;
338      }
339      if (1 != argc-optind-1){
340           LOG_FATAL("%s\n", "Need exactly one BAM file as last argument\n");
341           return 1;
342      }
343      if ((tmp.in = sam_open((argv+optind+1)[0], "rb")) == 0){
344           LOG_FATAL("Failed to open BAM file %s. Exiting...\n", (argv+optind+1)[0]);
345           return 1;
346      }
347      if ((tmp.header = sam_hdr_read(tmp.in)) == 0) {
348           LOG_FATAL("Failed to read headers from BAM file %s. Exiting...\n", (argv+optind+1)[0]);
349           return 1;
350      }
351      if (!bam_out || bam_out[0] == '-') {
352           tmp.out = sam_open("-", "wb");
353      } else {
354           tmp.out = sam_open(bam_out, "wb");
355      }
356      sam_hdr_write(tmp.out, tmp.header);
357      b = bam_init1();
358      tmp.tid = -1;
359      tmp.ref = 0;
360      while (sam_read1(tmp.in, tmp.header, b) &gt;= 0){
361           fetch_func(b, &amp;tmp, del_flag, q2default, reclip);
362      }
363      bam_destroy1(b);
364      bam_hdr_destroy(tmp.header);
365      sam_close(tmp.in);
366      sam_close(tmp.out);
367      if (tmp.ref)
368           free(tmp.ref);
369      fai_destroy(tmp.fai);
370      free(bam_out);
371      LOG_VERBOSE("%s\n", "NOTE: Output BAM file will be unsorted (use samtools sort, e.g. samtools sort -')");
372      return 0;
373 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
