
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.137741046831957%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_arm.h</h3>
            <pre><code>1  #ifndef XMRIG_CRYPTONIGHT_ARM_H
2  #define XMRIG_CRYPTONIGHT_ARM_H
3  #include "base/crypto/keccak.h"
4  #include "crypto/cn/CnAlgo.h"
5  #include "crypto/cn/CryptoNight_monero.h"
6  #include "crypto/cn/CryptoNight.h"
7  #include "crypto/cn/soft_aes.h"
8  extern "C"
9  {
10  #include "crypto/cn/c_groestl.h"
11  #include "crypto/cn/c_blake256.h"
12  #include "crypto/cn/c_jh.h"
13  #include "crypto/cn/c_skein.h"
14  }
15  static inline void do_blake_hash(const uint8_t *input, size_t len, uint8_t *output) {
16      blake256_hash(output, input, len);
17  }
18  static inline void do_groestl_hash(const uint8_t *input, size_t len, uint8_t *output) {
19      groestl(input, len * 8, output);
20  }
21  static inline void do_jh_hash(const uint8_t *input, size_t len, uint8_t *output) {
22      jh_hash(32 * 8, input, 8 * len, output);
23  }
24  static inline void do_skein_hash(const uint8_t *input, size_t len, uint8_t *output) {
25      xmr_skein(input, output);
26  }
27  void (* const extra_hashes[4])(const uint8_t *, size_t, uint8_t *) = {do_blake_hash, do_groestl_hash, do_jh_hash, do_skein_hash};
28  static inline __m128i sl_xor(__m128i tmp1)
29  {
30      __m128i tmp4;
31      tmp4 = _mm_slli_si128(tmp1, 0x04);
32      tmp1 = _mm_xor_si128(tmp1, tmp4);
33      tmp4 = _mm_slli_si128(tmp4, 0x04);
34      tmp1 = _mm_xor_si128(tmp1, tmp4);
35      tmp4 = _mm_slli_si128(tmp4, 0x04);
36      tmp1 = _mm_xor_si128(tmp1, tmp4);
37      return tmp1;
38  }
39  template<uint8_t rcon>
40  static inline void soft_aes_genkey_sub(__m128i* xout0, __m128i* xout2)
<span onclick='openModal()' class='match'>41  {
42      __m128i xout1 = soft_aeskeygenassist<rcon>(*xout2);
43      xout1  = _mm_shuffle_epi32(xout1, 0xFF); 
44      *xout0 = sl_xor(*xout0);
45      *xout0 = _mm_xor_si128(*xout0, xout1);
46      xout1  = soft_aeskeygenassist<0x00>(*xout0);
47      xout1  = _mm_shuffle_epi32(xout1, 0xAA); 
48      *xout2 = sl_xor(*xout2);
49      *xout2 = _mm_xor_si128(*xout2, xout1);
50  }
</span>51  template<bool SOFT_AES>
52  static inline void aes_genkey(const __m128i* memory, __m128i* k0, __m128i* k1, __m128i* k2, __m128i* k3, __m128i* k4, __m128i* k5, __m128i* k6, __m128i* k7, __m128i* k8, __m128i* k9)
53  {
54      __m128i xout0 = _mm_load_si128(memory);
55      __m128i xout2 = _mm_load_si128(memory + 1);
56      *k0 = xout0;
57      *k1 = xout2;
58      soft_aes_genkey_sub<0x01>(&xout0, &xout2);
59      *k2 = xout0;
60      *k3 = xout2;
61      soft_aes_genkey_sub<0x02>(&xout0, &xout2);
62      *k4 = xout0;
63      *k5 = xout2;
64      soft_aes_genkey_sub<0x04>(&xout0, &xout2);
65      *k6 = xout0;
66      *k7 = xout2;
67      soft_aes_genkey_sub<0x08>(&xout0, &xout2);
68      *k8 = xout0;
69      *k9 = xout2;
70  }
71  template<bool SOFT_AES>
72  static inline void aes_round(__m128i key, __m128i* x0, __m128i* x1, __m128i* x2, __m128i* x3, __m128i* x4, __m128i* x5, __m128i* x6, __m128i* x7)
73  {
74      if (SOFT_AES) {
75          *x0 = soft_aesenc((uint32_t*)x0, key);
76          *x1 = soft_aesenc((uint32_t*)x1, key);
77          *x2 = soft_aesenc((uint32_t*)x2, key);
78          *x3 = soft_aesenc((uint32_t*)x3, key);
79          *x4 = soft_aesenc((uint32_t*)x4, key);
80          *x5 = soft_aesenc((uint32_t*)x5, key);
81          *x6 = soft_aesenc((uint32_t*)x6, key);
82          *x7 = soft_aesenc((uint32_t*)x7, key);
83      }
84      else {
85          *x0 = _mm_aesenc_si128(*x0, key);
86          *x1 = _mm_aesenc_si128(*x1, key);
87          *x2 = _mm_aesenc_si128(*x2, key);
88          *x3 = _mm_aesenc_si128(*x3, key);
89          *x4 = _mm_aesenc_si128(*x4, key);
90          *x5 = _mm_aesenc_si128(*x5, key);
91          *x6 = _mm_aesenc_si128(*x6, key);
92          *x7 = _mm_aesenc_si128(*x7, key);
93      }
94  }
95  inline void mix_and_propagate(__m128i& x0, __m128i& x1, __m128i& x2, __m128i& x3, __m128i& x4, __m128i& x5, __m128i& x6, __m128i& x7)
96  {
97      __m128i tmp0 = x0;
98      x0 = _mm_xor_si128(x0, x1);
99      x1 = _mm_xor_si128(x1, x2);
100      x2 = _mm_xor_si128(x2, x3);
101      x3 = _mm_xor_si128(x3, x4);
102      x4 = _mm_xor_si128(x4, x5);
103      x5 = _mm_xor_si128(x5, x6);
104      x6 = _mm_xor_si128(x6, x7);
105      x7 = _mm_xor_si128(x7, tmp0);
106  }
107  namespace xmrig {
108  template<Algorithm::Id ALGO, bool SOFT_AES>
109  static inline void cn_explode_scratchpad(const __m128i *input, __m128i *output)
110  {
111      constexpr CnAlgo<ALGO> props;
112      __m128i xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7;
113      __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;
114      aes_genkey<SOFT_AES>(input, &k0, &k1, &k2, &k3, &k4, &k5, &k6, &k7, &k8, &k9);
115      xin0 = _mm_load_si128(input + 4);
116      xin1 = _mm_load_si128(input + 5);
117      xin2 = _mm_load_si128(input + 6);
118      xin3 = _mm_load_si128(input + 7);
119      xin4 = _mm_load_si128(input + 8);
120      xin5 = _mm_load_si128(input + 9);
121      xin6 = _mm_load_si128(input + 10);
122      xin7 = _mm_load_si128(input + 11);
123      if (props.isHeavy()) {
124          for (size_t i = 0; i < 16; i++) {
125              aes_round<SOFT_AES>(k0, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
126              aes_round<SOFT_AES>(k1, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
127              aes_round<SOFT_AES>(k2, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
128              aes_round<SOFT_AES>(k3, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
129              aes_round<SOFT_AES>(k4, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
130              aes_round<SOFT_AES>(k5, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
131              aes_round<SOFT_AES>(k6, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
132              aes_round<SOFT_AES>(k7, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
133              aes_round<SOFT_AES>(k8, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
134              aes_round<SOFT_AES>(k9, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
135              mix_and_propagate(xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7);
136          }
137      }
138      for (size_t i = 0; i < props.memory() / sizeof(__m128i); i += 8) {
139          aes_round<SOFT_AES>(k0, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
140          aes_round<SOFT_AES>(k1, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
141          aes_round<SOFT_AES>(k2, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
142          aes_round<SOFT_AES>(k3, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
143          aes_round<SOFT_AES>(k4, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
144          aes_round<SOFT_AES>(k5, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
145          aes_round<SOFT_AES>(k6, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
146          aes_round<SOFT_AES>(k7, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
147          aes_round<SOFT_AES>(k8, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
148          aes_round<SOFT_AES>(k9, &xin0, &xin1, &xin2, &xin3, &xin4, &xin5, &xin6, &xin7);
149          _mm_store_si128(output + i + 0, xin0);
150          _mm_store_si128(output + i + 1, xin1);
151          _mm_store_si128(output + i + 2, xin2);
152          _mm_store_si128(output + i + 3, xin3);
153          _mm_store_si128(output + i + 4, xin4);
154          _mm_store_si128(output + i + 5, xin5);
155          _mm_store_si128(output + i + 6, xin6);
156          _mm_store_si128(output + i + 7, xin7);
157      }
158  }
159  template<Algorithm::Id ALGO, bool SOFT_AES>
160  static inline void cn_implode_scratchpad(const __m128i *input, __m128i *output)
161  {
162      constexpr CnAlgo<ALGO> props;
163      constexpr bool IS_HEAVY = props.isHeavy();
164      __m128i xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7;
165      __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;
166      aes_genkey<SOFT_AES>(output + 2, &k0, &k1, &k2, &k3, &k4, &k5, &k6, &k7, &k8, &k9);
167      xout0 = _mm_load_si128(output + 4);
168      xout1 = _mm_load_si128(output + 5);
169      xout2 = _mm_load_si128(output + 6);
170      xout3 = _mm_load_si128(output + 7);
171      xout4 = _mm_load_si128(output + 8);
172      xout5 = _mm_load_si128(output + 9);
173      xout6 = _mm_load_si128(output + 10);
174      xout7 = _mm_load_si128(output + 11);
175      for (size_t i = 0; i < props.memory() / sizeof(__m128i); i += 8) {
176          xout0 = _mm_xor_si128(_mm_load_si128(input + i + 0), xout0);
177          xout1 = _mm_xor_si128(_mm_load_si128(input + i + 1), xout1);
178          xout2 = _mm_xor_si128(_mm_load_si128(input + i + 2), xout2);
179          xout3 = _mm_xor_si128(_mm_load_si128(input + i + 3), xout3);
180          xout4 = _mm_xor_si128(_mm_load_si128(input + i + 4), xout4);
181          xout5 = _mm_xor_si128(_mm_load_si128(input + i + 5), xout5);
182          xout6 = _mm_xor_si128(_mm_load_si128(input + i + 6), xout6);
183          xout7 = _mm_xor_si128(_mm_load_si128(input + i + 7), xout7);
184          aes_round<SOFT_AES>(k0, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
185          aes_round<SOFT_AES>(k1, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
186          aes_round<SOFT_AES>(k2, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
187          aes_round<SOFT_AES>(k3, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
188          aes_round<SOFT_AES>(k4, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
189          aes_round<SOFT_AES>(k5, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
190          aes_round<SOFT_AES>(k6, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
191          aes_round<SOFT_AES>(k7, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
192          aes_round<SOFT_AES>(k8, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
193          aes_round<SOFT_AES>(k9, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
194          if (IS_HEAVY) {
195              mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
196          }
197      }
198      if (IS_HEAVY) {
199          for (size_t i = 0; i < props.memory() / sizeof(__m128i); i += 8) {
200              xout0 = _mm_xor_si128(_mm_load_si128(input + i + 0), xout0);
201              xout1 = _mm_xor_si128(_mm_load_si128(input + i + 1), xout1);
202              xout2 = _mm_xor_si128(_mm_load_si128(input + i + 2), xout2);
203              xout3 = _mm_xor_si128(_mm_load_si128(input + i + 3), xout3);
204              xout4 = _mm_xor_si128(_mm_load_si128(input + i + 4), xout4);
205              xout5 = _mm_xor_si128(_mm_load_si128(input + i + 5), xout5);
206              xout6 = _mm_xor_si128(_mm_load_si128(input + i + 6), xout6);
207              xout7 = _mm_xor_si128(_mm_load_si128(input + i + 7), xout7);
208              aes_round<SOFT_AES>(k0, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
209              aes_round<SOFT_AES>(k1, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
210              aes_round<SOFT_AES>(k2, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
211              aes_round<SOFT_AES>(k3, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
212              aes_round<SOFT_AES>(k4, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
213              aes_round<SOFT_AES>(k5, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
214              aes_round<SOFT_AES>(k6, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
215              aes_round<SOFT_AES>(k7, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
216              aes_round<SOFT_AES>(k8, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
217              aes_round<SOFT_AES>(k9, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
218              mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
219          }
220          for (size_t i = 0; i < 16; i++) {
221              aes_round<SOFT_AES>(k0, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
222              aes_round<SOFT_AES>(k1, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
223              aes_round<SOFT_AES>(k2, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
224              aes_round<SOFT_AES>(k3, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
225              aes_round<SOFT_AES>(k4, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
226              aes_round<SOFT_AES>(k5, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
227              aes_round<SOFT_AES>(k6, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
228              aes_round<SOFT_AES>(k7, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
229              aes_round<SOFT_AES>(k8, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
230              aes_round<SOFT_AES>(k9, &xout0, &xout1, &xout2, &xout3, &xout4, &xout5, &xout6, &xout7);
231              mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
232          }
233      }
234      _mm_store_si128(output + 4, xout0);
235      _mm_store_si128(output + 5, xout1);
236      _mm_store_si128(output + 6, xout2);
237      _mm_store_si128(output + 7, xout3);
238      _mm_store_si128(output + 8, xout4);
239      _mm_store_si128(output + 9, xout5);
240      _mm_store_si128(output + 10, xout6);
241      _mm_store_si128(output + 11, xout7);
242  }
243  } &bsol;* namespace xmrig */
244  static inline __m128i aes_round_tweak_div(const __m128i &in, const __m128i &key)
245  {
246      alignas(16) uint32_t k[4];
247      alignas(16) uint32_t x[4];
248      _mm_store_si128((__m128i*) k, key);
249      _mm_store_si128((__m128i*) x, _mm_xor_si128(in, _mm_set_epi64x(0xffffffffffffffff, 0xffffffffffffffff)));
250      #define BYTE(p, i) ((unsigned char*)&x[p])[i]
251      k[0] ^= saes_table[0][BYTE(0, 0)] ^ saes_table[1][BYTE(1, 1)] ^ saes_table[2][BYTE(2, 2)] ^ saes_table[3][BYTE(3, 3)];
252      x[0] ^= k[0];
253      k[1] ^= saes_table[0][BYTE(1, 0)] ^ saes_table[1][BYTE(2, 1)] ^ saes_table[2][BYTE(3, 2)] ^ saes_table[3][BYTE(0, 3)];
254      x[1] ^= k[1];
255      k[2] ^= saes_table[0][BYTE(2, 0)] ^ saes_table[1][BYTE(3, 1)] ^ saes_table[2][BYTE(0, 2)] ^ saes_table[3][BYTE(1, 3)];
256      x[2] ^= k[2];
257      k[3] ^= saes_table[0][BYTE(3, 0)] ^ saes_table[1][BYTE(0, 1)] ^ saes_table[2][BYTE(1, 2)] ^ saes_table[3][BYTE(2, 3)];
258      #undef BYTE
259      return _mm_load_si128((__m128i*)k);
260  }
261  alignas(64) static const uint32_t tweak1_table[256] = { 268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456 };
262  namespace xmrig {
263  template<Algorithm::Id ALGO>
264  static inline void cryptonight_monero_tweak(const uint8_t* l, uint64_t idx, __m128i ax0, __m128i bx0, __m128i bx1, __m128i& cx)
265  {
266      constexpr CnAlgo<ALGO> props;
267      uint64_t* mem_out = (uint64_t*)&l[idx];
268      if (props.base() == Algorithm::CN_2) {
269          VARIANT2_SHUFFLE(l, idx, ax0, bx0, bx1, cx, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
270          _mm_store_si128((__m128i *)mem_out, _mm_xor_si128(bx0, cx));
271      } else {
272          __m128i tmp = _mm_xor_si128(bx0, cx);
273          mem_out[0] = _mm_cvtsi128_si64(tmp);
274          uint64_t vh = vgetq_lane_u64(tmp, 1);
275          mem_out[1] = vh ^ tweak1_table[static_cast<uint8_t>(vh >> 24)];
276      }
277  }
278  static inline void cryptonight_conceal_tweak(__m128i& cx, __m128& conc_var)
279  {
280      __m128 r = _mm_add_ps(_mm_cvtepi32_ps(cx), conc_var);
281      r = _mm_mul_ps(r, _mm_mul_ps(r, r));
282      r = _mm_and_ps(_mm_castsi128_ps(_mm_set1_epi32(0x807FFFFF)), r);
283      r = _mm_or_ps(_mm_castsi128_ps(_mm_set1_epi32(0x40000000)), r);
284      __m128 c_old = conc_var;
285      conc_var = _mm_add_ps(conc_var, r);
286      c_old = _mm_and_ps(_mm_castsi128_ps(_mm_set1_epi32(0x807FFFFF)), c_old);
287      c_old = _mm_or_ps(_mm_castsi128_ps(_mm_set1_epi32(0x40000000)), c_old);
288      __m128 nc = _mm_mul_ps(c_old, _mm_set1_ps(536870880.0f));
289      cx = _mm_xor_si128(cx, _mm_cvttps_epi32(nc));
290  }
291  template<Algorithm::Id ALGO, bool SOFT_AES, int interleave>
292  inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
293  {
294      constexpr CnAlgo<ALGO> props;
295      constexpr size_t MASK        = props.mask();
296      constexpr Algorithm::Id BASE = props.base();
297  #   ifdef XMRIG_ALGO_CN_HEAVY
298      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
299  #   else
300      constexpr bool IS_CN_HEAVY_TUBE = false;
301  #   endif
302      if (BASE == Algorithm::CN_1 && size < 43) {
303          memset(output, 0, 32);
304          return;
305      }
306      keccak(input, size, ctx[0]->state);
307      cn_explode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(ctx[0]->state), reinterpret_cast<__m128i *>(ctx[0]->memory));
308      uint8_t* l0 = ctx[0]->memory;
309      uint64_t* h0 = reinterpret_cast<uint64_t*>(ctx[0]->state);
310      VARIANT1_INIT(0);
311      VARIANT2_INIT(0);
312      VARIANT4_RANDOM_MATH_INIT(0);
313      uint64_t al0 = h0[0] ^ h0[4];
314      uint64_t ah0 = h0[1] ^ h0[5];
315      __m128i bx0  = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);
316      __m128i bx1  = _mm_set_epi64x(h0[9] ^ h0[11], h0[8] ^ h0[10]);
317      __m128 conc_var;
318      if (ALGO == Algorithm::CN_CCX) {
319          conc_var = _mm_setzero_ps();
320      }
321      uint64_t idx0 = al0;
322      for (size_t i = 0; i < props.iterations(); i++) {
323          __m128i cx;
324          if (IS_CN_HEAVY_TUBE || !SOFT_AES) {
325              cx = _mm_load_si128(reinterpret_cast<const __m128i *>(&l0[idx0 & MASK]));
326              if (ALGO == Algorithm::CN_CCX) {
327                  cryptonight_conceal_tweak(cx, conc_var);
328              }
329          }
330          const __m128i ax0 = _mm_set_epi64x(ah0, al0);
331          if (IS_CN_HEAVY_TUBE) {
332              cx = aes_round_tweak_div(cx, ax0);
333          }
334          else if (SOFT_AES) {
335              if (ALGO == Algorithm::CN_CCX) {
336                  cx = _mm_load_si128(reinterpret_cast<const __m128i*>(&l0[idx0 & MASK]));
337                  cryptonight_conceal_tweak(cx, conc_var);
338                  cx = soft_aesenc((uint32_t*)&cx, ax0);
339              }
340              else {
341                  cx = soft_aesenc((uint32_t*)&l0[idx0 & MASK], ax0);
342              }
343          }
344          else {
345              cx = _mm_aesenc_si128(cx, ax0);
346          }
347          if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {
348              cryptonight_monero_tweak<ALGO>(l0, idx0 & MASK, ax0, bx0, bx1, cx);
349          } else {
350              _mm_store_si128((__m128i *)&l0[idx0 & MASK], _mm_xor_si128(bx0, cx));
351          }
352          idx0 = _mm_cvtsi128_si64(cx);
353          uint64_t hi, lo, cl, ch;
354          cl = ((uint64_t*) &l0[idx0 & MASK])[0];
355          ch = ((uint64_t*) &l0[idx0 & MASK])[1];
356          if (BASE == Algorithm::CN_2) {
357              if (props.isR()) {
358                  VARIANT4_RANDOM_MATH(0, al0, ah0, cl, bx0, bx1);
359                  if (ALGO == Algorithm::CN_R) {
360                      al0 ^= r0[2] | ((uint64_t)(r0[3]) << 32);
361                      ah0 ^= r0[0] | ((uint64_t)(r0[1]) << 32);
362                  }
363              } else {
364                  VARIANT2_INTEGER_MATH(0, cl, cx);
365              }
366          }
367          lo = __umul128(idx0, cl, &hi);
368          if (BASE == Algorithm::CN_2) {
369              if (ALGO == Algorithm::CN_R) {
370                  VARIANT2_SHUFFLE(l0, idx0 & MASK, ax0, bx0, bx1, cx, 0);
371              } else {
372                  VARIANT2_SHUFFLE2(l0, idx0 & MASK, ax0, bx0, bx1, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
373              }
374          }
375          al0 += hi;
376          ah0 += lo;
377          ((uint64_t*)&l0[idx0 & MASK])[0] = al0;
378          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
379              ((uint64_t*)&l0[idx0 & MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;
380          } else if (BASE == Algorithm::CN_1) {
381              ((uint64_t*)&l0[idx0 & MASK])[1] = ah0 ^ tweak1_2_0;
382          } else {
383              ((uint64_t*)&l0[idx0 & MASK])[1] = ah0;
384          }
385          al0 ^= cl;
386          ah0 ^= ch;
387          idx0 = al0;
388  #       ifdef XMRIG_ALGO_CN_HEAVY
389          if (props.isHeavy()) {
390              const int64x2_t x = vld1q_s64(reinterpret_cast<const int64_t *>(&l0[idx0 & MASK]));
391              const int64_t n   = vgetq_lane_s64(x, 0);
392              const int32_t d   = vgetq_lane_s32(x, 2);
393              const int64_t q   = n / (d | 0x5);
394              ((int64_t*)&l0[idx0 & MASK])[0] = n ^ q;
395              if (ALGO == Algorithm::CN_HEAVY_XHV) {
396                  idx0 = (~d) ^ q;
397              }
398              else {
399                  idx0 = d ^ q;
400              }
401          }
402  #       endif
403          if (BASE == Algorithm::CN_2) {
404              bx1 = bx0;
405          }
406          bx0 = cx;
407      }
408      cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(ctx[0]->memory), reinterpret_cast<__m128i *>(ctx[0]->state));
409      keccakf(h0, 24);
410      extra_hashes[ctx[0]->state[0] & 3](ctx[0]->state, 200, output);
411  }
412  template<Algorithm::Id ALGO, bool SOFT_AES>
413  inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, struct cryptonight_ctx **__restrict__ ctx, uint64_t height)
414  {
415      constexpr CnAlgo<ALGO> props;
416      constexpr size_t MASK        = props.mask();
417      constexpr Algorithm::Id BASE = props.base();
418  #   ifdef XMRIG_ALGO_CN_HEAVY
419      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
420  #   else
421      constexpr bool IS_CN_HEAVY_TUBE = false;
422  #   endif
423      if (BASE == Algorithm::CN_1 && size < 43) {
424          memset(output, 0, 64);
425          return;
426      }
427      keccak(input,        size, ctx[0]->state);
428      keccak(input + size, size, ctx[1]->state);
429      uint8_t *l0  = ctx[0]->memory;
430      uint8_t *l1  = ctx[1]->memory;
431      uint64_t *h0 = reinterpret_cast<uint64_t*>(ctx[0]->state);
432      uint64_t *h1 = reinterpret_cast<uint64_t*>(ctx[1]->state);
433      VARIANT1_INIT(0);
434      VARIANT1_INIT(1);
435      VARIANT2_INIT(0);
436      VARIANT2_INIT(1);
437      VARIANT4_RANDOM_MATH_INIT(0);
438      VARIANT4_RANDOM_MATH_INIT(1);
439      cn_explode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(h0), reinterpret_cast<__m128i *>(l0));
440      cn_explode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(h1), reinterpret_cast<__m128i *>(l1));
441      uint64_t al0 = h0[0] ^ h0[4];
442      uint64_t al1 = h1[0] ^ h1[4];
443      uint64_t ah0 = h0[1] ^ h0[5];
444      uint64_t ah1 = h1[1] ^ h1[5];
445      __m128i bx00 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);
446      __m128i bx01 = _mm_set_epi64x(h0[9] ^ h0[11], h0[8] ^ h0[10]);
447      __m128i bx10 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);
448      __m128i bx11 = _mm_set_epi64x(h1[9] ^ h1[11], h1[8] ^ h1[10]);
449      __m128 conc_var0, conc_var1;
450      if (ALGO == Algorithm::CN_CCX) {
451          conc_var0 = _mm_setzero_ps();
452          conc_var1 = _mm_setzero_ps();
453      }
454      uint64_t idx0 = al0;
455      uint64_t idx1 = al1;
456      for (size_t i = 0; i < props.iterations(); i++) {
457          __m128i cx0, cx1;
458          if (IS_CN_HEAVY_TUBE || !SOFT_AES) {
459              cx0 = _mm_load_si128((__m128i *) &l0[idx0 & MASK]);
460              cx1 = _mm_load_si128((__m128i *) &l1[idx1 & MASK]);
461              if (ALGO == Algorithm::CN_CCX) {
462                  cryptonight_conceal_tweak(cx0, conc_var0);
463                  cryptonight_conceal_tweak(cx1, conc_var1);
464              }
465          }
466          const __m128i ax0 = _mm_set_epi64x(ah0, al0);
467          const __m128i ax1 = _mm_set_epi64x(ah1, al1);
468          if (IS_CN_HEAVY_TUBE) {
469              cx0 = aes_round_tweak_div(cx0, ax0);
470              cx1 = aes_round_tweak_div(cx1, ax1);
471          }
472          else if (SOFT_AES) {
473              if (ALGO == Algorithm::CN_CCX) {
474                  cx0 = _mm_load_si128((__m128i *) &l0[idx0 & MASK]);
475                  cx1 = _mm_load_si128((__m128i *) &l1[idx1 & MASK]);
476                  cryptonight_conceal_tweak(cx0, conc_var0);
477                  cryptonight_conceal_tweak(cx1, conc_var1);
478                  cx0 = soft_aesenc((uint32_t*)&cx0, ax0);
479                  cx1 = soft_aesenc((uint32_t*)&cx1, ax1);
480              }
481              else {
482                  cx0 = soft_aesenc((uint32_t*)&l0[idx0 & MASK], ax0);
483                  cx1 = soft_aesenc((uint32_t*)&l1[idx1 & MASK], ax1);
484              }
485          }
486          else {
487              cx0 = _mm_aesenc_si128(cx0, ax0);
488              cx1 = _mm_aesenc_si128(cx1, ax1);
489          }
490          if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {
491              cryptonight_monero_tweak<ALGO>(l0, idx0 & MASK, ax0, bx00, bx01, cx0);
492              cryptonight_monero_tweak<ALGO>(l1, idx1 & MASK, ax1, bx10, bx11, cx1);
493          } else {
494              _mm_store_si128((__m128i *) &l0[idx0 & MASK], _mm_xor_si128(bx00, cx0));
495              _mm_store_si128((__m128i *) &l1[idx1 & MASK], _mm_xor_si128(bx10, cx1));
496          }
497          idx0 = _mm_cvtsi128_si64(cx0);
498          idx1 = _mm_cvtsi128_si64(cx1);
499          uint64_t hi, lo, cl, ch;
500          cl = ((uint64_t*) &l0[idx0 & MASK])[0];
501          ch = ((uint64_t*) &l0[idx0 & MASK])[1];
502          if (BASE == Algorithm::CN_2) {
503              if (props.isR()) {
504                  VARIANT4_RANDOM_MATH(0, al0, ah0, cl, bx00, bx01);
505                  if (ALGO == Algorithm::CN_R) {
506                      al0 ^= r0[2] | ((uint64_t)(r0[3]) << 32);
507                      ah0 ^= r0[0] | ((uint64_t)(r0[1]) << 32);
508                  }
509              } else {
510                  VARIANT2_INTEGER_MATH(0, cl, cx0);
511              }
512          }
513          lo = __umul128(idx0, cl, &hi);
514          if (BASE == Algorithm::CN_2) {
515              if (ALGO == Algorithm::CN_R) {
516                  VARIANT2_SHUFFLE(l0, idx0 & MASK, ax0, bx00, bx01, cx0, 0);
517              } else {
518                  VARIANT2_SHUFFLE2(l0, idx0 & MASK, ax0, bx00, bx01, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
519              }
520          }
521          al0 += hi;
522          ah0 += lo;
523          ((uint64_t*)&l0[idx0 & MASK])[0] = al0;
524          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
525              ((uint64_t*)&l0[idx0 & MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;
526          } else if (BASE == Algorithm::CN_1) {
527              ((uint64_t*)&l0[idx0 & MASK])[1] = ah0 ^ tweak1_2_0;
528          } else {
529              ((uint64_t*)&l0[idx0 & MASK])[1] = ah0;
530          }
531          al0 ^= cl;
532          ah0 ^= ch;
533          idx0 = al0;
534  #       ifdef XMRIG_ALGO_CN_HEAVY
535          if (props.isHeavy()) {
536              const int64x2_t x = vld1q_s64(reinterpret_cast<const int64_t *>(&l0[idx0 & MASK]));
537              const int64_t n   = vgetq_lane_s64(x, 0);
538              const int32_t d   = vgetq_lane_s32(x, 2);
539              const int64_t q   = n / (d | 0x5);
540              ((int64_t*)&l0[idx0 & MASK])[0] = n ^ q;
541              if (ALGO == Algorithm::CN_HEAVY_XHV) {
542                  idx0 = (~d) ^ q;
543              }
544              else {
545                  idx0 = d ^ q;
546              }
547          }
548  #       endif
549          cl = ((uint64_t*) &l1[idx1 & MASK])[0];
550          ch = ((uint64_t*) &l1[idx1 & MASK])[1];
551          if (BASE == Algorithm::CN_2) {
552              if (props.isR()) {
553                  VARIANT4_RANDOM_MATH(1, al1, ah1, cl, bx10, bx11);
554                  if (ALGO == Algorithm::CN_R) {
555                      al1 ^= r1[2] | ((uint64_t)(r1[3]) << 32);
556                      ah1 ^= r1[0] | ((uint64_t)(r1[1]) << 32);
557                  }
558              } else {
559                  VARIANT2_INTEGER_MATH(1, cl, cx1);
560              }
561          }
562          lo = __umul128(idx1, cl, &hi);
563          if (BASE == Algorithm::CN_2) {
564              if (ALGO == Algorithm::CN_R) {
565                  VARIANT2_SHUFFLE(l1, idx1 & MASK, ax1, bx10, bx11, cx1, 0);
566              } else {
567                  VARIANT2_SHUFFLE2(l1, idx1 & MASK, ax1, bx10, bx11, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
568              }
569          }
570          al1 += hi;
571          ah1 += lo;
572          ((uint64_t*)&l1[idx1 & MASK])[0] = al1;
573          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
574              ((uint64_t*)&l1[idx1 & MASK])[1] = ah1 ^ tweak1_2_1 ^ al1;
575          } else if (BASE == Algorithm::CN_1) {
576              ((uint64_t*)&l1[idx1 & MASK])[1] = ah1 ^ tweak1_2_1;
577          } else {
578              ((uint64_t*)&l1[idx1 & MASK])[1] = ah1;
579          }
580          al1 ^= cl;
581          ah1 ^= ch;
582          idx1 = al1;
583  #       ifdef XMRIG_ALGO_CN_HEAVY
584          if (props.isHeavy()) {
585              const int64x2_t x = vld1q_s64(reinterpret_cast<const int64_t *>(&l1[idx1 & MASK]));
586              const int64_t n   = vgetq_lane_s64(x, 0);
587              const int32_t d   = vgetq_lane_s32(x, 2);
588              const int64_t q   = n / (d | 0x5);
589              ((int64_t*)&l1[idx1 & MASK])[0] = n ^ q;
590              if (ALGO == Algorithm::CN_HEAVY_XHV) {
591                  idx1 = (~d) ^ q;
592              }
593              else {
594                  idx1 = d ^ q;
595              }
596          }
597  #       endif
598          if (BASE == Algorithm::CN_2) {
599              bx01 = bx00;
600              bx11 = bx10;
601          }
602          bx00 = cx0;
603          bx10 = cx1;
604      }
605      cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(l0), reinterpret_cast<__m128i *>(h0));
606      cn_implode_scratchpad<ALGO, SOFT_AES>(reinterpret_cast<const __m128i *>(l1), reinterpret_cast<__m128i *>(h1));
607      keccakf(h0, 24);
608      keccakf(h1, 24);
609      extra_hashes[ctx[0]->state[0] & 3](ctx[0]->state, 200, output);
610      extra_hashes[ctx[1]->state[0] & 3](ctx[1]->state, 200, output + 32);
611  }
612  template<Algorithm::Id ALGO, bool SOFT_AES>
613  inline void cryptonight_triple_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, struct cryptonight_ctx **__restrict__ ctx, uint64_t height)
614  {
615  }
616  template<Algorithm::Id ALGO, bool SOFT_AES>
617  inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, struct cryptonight_ctx **__restrict__ ctx, uint64_t height)
618  {
619  }
620  template<Algorithm::Id ALGO, bool SOFT_AES>
621  inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, struct cryptonight_ctx **__restrict__ ctx, uint64_t height)
622  {
623  }
624  } &bsol;* namespace xmrig */
625  #endif &bsol;* XMRIG_CRYPTONIGHT_ARM_H */
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-demux.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "src/webp/config.h"
3  #endif
4  #include <assert.h>
5  #include <stdlib.h>
6  #include <string.h>
7  #include "src/utils/utils.h"
8  #include "src/webp/decode.h"     
9  #include "src/webp/demux.h"
10  #include "src/webp/format_constants.h"
11  #define DMUX_MAJ_VERSION 1
12  #define DMUX_MIN_VERSION 1
13  #define DMUX_REV_VERSION 0
14  typedef struct {
15    size_t start_;        
16    size_t end_;          
17    size_t riff_end_;     
18    size_t buf_size_;     
19    const uint8_t* buf_;
20  } MemBuffer;
21  typedef struct {
22    size_t offset_;
23    size_t size_;
24  } ChunkData;
25  typedef struct Frame {
26    int x_offset_, y_offset_;
27    int width_, height_;
28    int has_alpha_;
29    int duration_;
30    WebPMuxAnimDispose dispose_method_;
31    WebPMuxAnimBlend blend_method_;
32    int frame_num_;
33    int complete_;   
34    ChunkData img_components_[2];  
35    struct Frame* next_;
36  } Frame;
37  typedef struct Chunk {
38    ChunkData data_;
39    struct Chunk* next_;
40  } Chunk;
41  struct WebPDemuxer {
42    MemBuffer mem_;
43    WebPDemuxState state_;
44    int is_ext_format_;
45    uint32_t feature_flags_;
46    int canvas_width_, canvas_height_;
47    int loop_count_;
48    uint32_t bgcolor_;
49    int num_frames_;
50    Frame* frames_;
51    Frame** frames_tail_;
52    Chunk* chunks_;  
53    Chunk** chunks_tail_;
54  };
55  typedef enum {
56    PARSE_OK,
57    PARSE_NEED_MORE_DATA,
58    PARSE_ERROR
59  } ParseStatus;
60  typedef struct ChunkParser {
61    uint8_t id[4];
62    ParseStatus (*parse)(WebPDemuxer* const dmux);
63    int (*valid)(const WebPDemuxer* const dmux);
64  } ChunkParser;
65  static ParseStatus ParseSingleImage(WebPDemuxer* const dmux);
66  static ParseStatus ParseVP8X(WebPDemuxer* const dmux);
67  static int IsValidSimpleFormat(const WebPDemuxer* const dmux);
68  static int IsValidExtendedFormat(const WebPDemuxer* const dmux);
69  static const ChunkParser kMasterChunks[] = {
70    { { 'V', 'P', '8', ' ' }, ParseSingleImage, IsValidSimpleFormat },
71    { { 'V', 'P', '8', 'L' }, ParseSingleImage, IsValidSimpleFormat },
72    { { 'V', 'P', '8', 'X' }, ParseVP8X,        IsValidExtendedFormat },
73    { { '0', '0', '0', '0' }, NULL,             NULL },
74  };
75  int WebPGetDemuxVersion(void) {
76    return (DMUX_MAJ_VERSION << 16) | (DMUX_MIN_VERSION << 8) | DMUX_REV_VERSION;
77  }
78  static int RemapMemBuffer(MemBuffer* const mem,
79                            const uint8_t* data, size_t size) {
80    if (size < mem->buf_size_) return 0;  
81    mem->buf_ = data;
82    mem->end_ = mem->buf_size_ = size;
83    return 1;
84  }
85  static int InitMemBuffer(MemBuffer* const mem,
86                           const uint8_t* data, size_t size) {
87    memset(mem, 0, sizeof(*mem));
88    return RemapMemBuffer(mem, data, size);
89  }
90  static WEBP_INLINE size_t MemDataSize(const MemBuffer* const mem) {
91    return (mem->end_ - mem->start_);
92  }
93  static WEBP_INLINE int SizeIsInvalid(const MemBuffer* const mem, size_t size) {
94    return (size > mem->riff_end_ - mem->start_);
95  }
96  static WEBP_INLINE void Skip(MemBuffer* const mem, size_t size) {
97    mem->start_ += size;
98  }
99  static WEBP_INLINE void Rewind(MemBuffer* const mem, size_t size) {
100    mem->start_ -= size;
101  }
102  static WEBP_INLINE const uint8_t* GetBuffer(MemBuffer* const mem) {
103    return mem->buf_ + mem->start_;
104  }
105  static WEBP_INLINE uint8_t ReadByte(MemBuffer* const mem) {
106    const uint8_t byte = mem->buf_[mem->start_];
107    Skip(mem, 1);
108    return byte;
109  }
110  static WEBP_INLINE int ReadLE16s(MemBuffer* const mem) {
111    const uint8_t* const data = mem->buf_ + mem->start_;
112    const int val = GetLE16(data);
113    Skip(mem, 2);
114    return val;
115  }
116  static WEBP_INLINE int ReadLE24s(MemBuffer* const mem) {
117    const uint8_t* const data = mem->buf_ + mem->start_;
118    const int val = GetLE24(data);
119    Skip(mem, 3);
120    return val;
121  }
122  static WEBP_INLINE uint32_t ReadLE32(MemBuffer* const mem) {
123    const uint8_t* const data = mem->buf_ + mem->start_;
124    const uint32_t val = GetLE32(data);
125    Skip(mem, 4);
126    return val;
127  }
128  static void AddChunk(WebPDemuxer* const dmux, Chunk* const chunk) {
129    *dmux->chunks_tail_ = chunk;
130    chunk->next_ = NULL;
131    dmux->chunks_tail_ = &chunk->next_;
132  }
133  static int AddFrame(WebPDemuxer* const dmux, Frame* const frame) {
134    const Frame* const last_frame = *dmux->frames_tail_;
135    if (last_frame != NULL && !last_frame->complete_) return 0;
136    *dmux->frames_tail_ = frame;
137    frame->next_ = NULL;
138    dmux->frames_tail_ = &frame->next_;
139    return 1;
140  }
141  static void SetFrameInfo(size_t start_offset, size_t size,
142                           int frame_num, int complete,
143                           const WebPBitstreamFeatures* const features,
144                           Frame* const frame) {
145    frame->img_components_[0].offset_ = start_offset;
146    frame->img_components_[0].size_ = size;
147    frame->width_ = features->width;
148    frame->height_ = features->height;
149    frame->has_alpha_ |= features->has_alpha;
150    frame->frame_num_ = frame_num;
151    frame->complete_ = complete;
152  }
153  static ParseStatus StoreFrame(int frame_num, uint32_t min_size,
154                                MemBuffer* const mem, Frame* const frame) {
155    int alpha_chunks = 0;
156    int image_chunks = 0;
157    int done = (MemDataSize(mem) < CHUNK_HEADER_SIZE ||
158                MemDataSize(mem) < min_size);
159    ParseStatus status = PARSE_OK;
160    if (done) return PARSE_NEED_MORE_DATA;
161    do {
162      const size_t chunk_start_offset = mem->start_;
163      const uint32_t fourcc = ReadLE32(mem);
164      const uint32_t payload_size = ReadLE32(mem);
165      const uint32_t payload_size_padded = payload_size + (payload_size & 1);
166      const size_t payload_available = (payload_size_padded > MemDataSize(mem))
167                                     ? MemDataSize(mem) : payload_size_padded;
168      const size_t chunk_size = CHUNK_HEADER_SIZE + payload_available;
169      if (payload_size > MAX_CHUNK_PAYLOAD) return PARSE_ERROR;
170      if (SizeIsInvalid(mem, payload_size_padded)) return PARSE_ERROR;
171      if (payload_size_padded > MemDataSize(mem)) status = PARSE_NEED_MORE_DATA;
172      switch (fourcc) {
173        case MKFOURCC('A', 'L', 'P', 'H'):
174          if (alpha_chunks == 0) {
175            ++alpha_chunks;
176            frame->img_components_[1].offset_ = chunk_start_offset;
177            frame->img_components_[1].size_ = chunk_size;
178            frame->has_alpha_ = 1;
179            frame->frame_num_ = frame_num;
180            Skip(mem, payload_available);
181          } else {
182            goto Done;
183          }
184          break;
185        case MKFOURCC('V', 'P', '8', 'L'):
186          if (alpha_chunks > 0) return PARSE_ERROR;  
187        case MKFOURCC('V', 'P', '8', ' '):
188          if (image_chunks == 0) {
189            WebPBitstreamFeatures features;
190            const VP8StatusCode vp8_status =
191                WebPGetFeatures(mem->buf_ + chunk_start_offset, chunk_size,
192                                &features);
193            if (status == PARSE_NEED_MORE_DATA &&
194                vp8_status == VP8_STATUS_NOT_ENOUGH_DATA) {
195              return PARSE_NEED_MORE_DATA;
196            } else if (vp8_status != VP8_STATUS_OK) {
197              return PARSE_ERROR;
198            }
199            ++image_chunks;
200            SetFrameInfo(chunk_start_offset, chunk_size, frame_num,
201                         status == PARSE_OK, &features, frame);
202            Skip(mem, payload_available);
203          } else {
204            goto Done;
205          }
206          break;
207   Done:
208        default:
209          Rewind(mem, CHUNK_HEADER_SIZE);
210          done = 1;
211          break;
212      }
213      if (mem->start_ == mem->riff_end_) {
214        done = 1;
215      } else if (MemDataSize(mem) < CHUNK_HEADER_SIZE) {
216        status = PARSE_NEED_MORE_DATA;
217      }
218    } while (!done && status == PARSE_OK);
219    return status;
220  }
221  static ParseStatus NewFrame(const MemBuffer* const mem,
222                              uint32_t min_size, uint32_t actual_size,
223                              Frame** frame) {
224    if (SizeIsInvalid(mem, min_size)) return PARSE_ERROR;
225    if (actual_size < min_size) return PARSE_ERROR;
226    if (MemDataSize(mem) < min_size)  return PARSE_NEED_MORE_DATA;
227    *frame = (Frame*)WebPSafeCalloc(1ULL, sizeof(**frame));
228    return (*frame == NULL) ? PARSE_ERROR : PARSE_OK;
229  }
230  static ParseStatus ParseAnimationFrame(
231      WebPDemuxer* const dmux, uint32_t frame_chunk_size) {
232    const int is_animation = !!(dmux->feature_flags_ & ANIMATION_FLAG);
233    const uint32_t anmf_payload_size = frame_chunk_size - ANMF_CHUNK_SIZE;
234    int added_frame = 0;
235    int bits;
236    MemBuffer* const mem = &dmux->mem_;
237    Frame* frame;
238    ParseStatus status =
239        NewFrame(mem, ANMF_CHUNK_SIZE, frame_chunk_size, &frame);
240    if (status != PARSE_OK) return status;
241    frame->x_offset_       = 2 * ReadLE24s(mem);
242    frame->y_offset_       = 2 * ReadLE24s(mem);
243    frame->width_          = 1 + ReadLE24s(mem);
244    frame->height_         = 1 + ReadLE24s(mem);
245    frame->duration_       = ReadLE24s(mem);
246    bits = ReadByte(mem);
247    frame->dispose_method_ =
248        (bits & 1) ? WEBP_MUX_DISPOSE_BACKGROUND : WEBP_MUX_DISPOSE_NONE;
249    frame->blend_method_ = (bits & 2) ? WEBP_MUX_NO_BLEND : WEBP_MUX_BLEND;
250    if (frame->width_ * (uint64_t)frame->height_ >= MAX_IMAGE_AREA) {
251      WebPSafeFree(frame);
252      return PARSE_ERROR;
253    }
254    status = StoreFrame(dmux->num_frames_ + 1, anmf_payload_size, mem, frame);
255    if (status != PARSE_ERROR && is_animation && frame->frame_num_ > 0) {
256      added_frame = AddFrame(dmux, frame);
257      if (added_frame) {
258        ++dmux->num_frames_;
259      } else {
260        status = PARSE_ERROR;
261      }
262    }
263    if (!added_frame) WebPSafeFree(frame);
264    return status;
265  }
266  static int StoreChunk(WebPDemuxer* const dmux,
267                        size_t start_offset, uint32_t size) {
268    Chunk* const chunk = (Chunk*)WebPSafeCalloc(1ULL, sizeof(*chunk));
269    if (chunk == NULL) return 0;
270    chunk->data_.offset_ = start_offset;
271    chunk->data_.size_ = size;
272    AddChunk(dmux, chunk);
273    return 1;
274  }
275  static ParseStatus ReadHeader(MemBuffer* const mem) {
276    const size_t min_size = RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE;
277    uint32_t riff_size;
278    if (MemDataSize(mem) < min_size) return PARSE_NEED_MORE_DATA;
279    if (memcmp(GetBuffer(mem), "RIFF", CHUNK_SIZE_BYTES) ||
280        memcmp(GetBuffer(mem) + CHUNK_HEADER_SIZE, "WEBP", CHUNK_SIZE_BYTES)) {
281      return PARSE_ERROR;
282    }
283    riff_size = GetLE32(GetBuffer(mem) + TAG_SIZE);
284    if (riff_size < CHUNK_HEADER_SIZE) return PARSE_ERROR;
285    if (riff_size > MAX_CHUNK_PAYLOAD) return PARSE_ERROR;
286    mem->riff_end_ = riff_size + CHUNK_HEADER_SIZE;
287    if (mem->buf_size_ > mem->riff_end_) {
288      mem->buf_size_ = mem->end_ = mem->riff_end_;
289    }
290    Skip(mem, RIFF_HEADER_SIZE);
291    return PARSE_OK;
292  }
293  static ParseStatus ParseSingleImage(WebPDemuxer* const dmux) {
294    const size_t min_size = CHUNK_HEADER_SIZE;
295    MemBuffer* const mem = &dmux->mem_;
296    Frame* frame;
297    ParseStatus status;
298    int image_added = 0;
299    if (dmux->frames_ != NULL) return PARSE_ERROR;
300    if (SizeIsInvalid(mem, min_size)) return PARSE_ERROR;
301    if (MemDataSize(mem) < min_size) return PARSE_NEED_MORE_DATA;
302    frame = (Frame*)WebPSafeCalloc(1ULL, sizeof(*frame));
303    if (frame == NULL) return PARSE_ERROR;
304    status = StoreFrame(1, 0, &dmux->mem_, frame);
305    if (status != PARSE_ERROR) {
306      const int has_alpha = !!(dmux->feature_flags_ & ALPHA_FLAG);
307      if (!has_alpha && frame->img_components_[1].size_ > 0) {
308        frame->img_components_[1].offset_ = 0;
309        frame->img_components_[1].size_ = 0;
310        frame->has_alpha_ = 0;
311      }
312      if (!dmux->is_ext_format_ && frame->width_ > 0 && frame->height_ > 0) {
313        dmux->state_ = WEBP_DEMUX_PARSED_HEADER;
314        dmux->canvas_width_ = frame->width_;
315        dmux->canvas_height_ = frame->height_;
316        dmux->feature_flags_ |= frame->has_alpha_ ? ALPHA_FLAG : 0;
317      }
318      if (!AddFrame(dmux, frame)) {
319        status = PARSE_ERROR;  
320      } else {
321        image_added = 1;
322        dmux->num_frames_ = 1;
323      }
324    }
325    if (!image_added) WebPSafeFree(frame);
326    return status;
327  }
328  static ParseStatus ParseVP8XChunks(WebPDemuxer* const dmux) {
329    const int is_animation = !!(dmux->feature_flags_ & ANIMATION_FLAG);
330    MemBuffer* const mem = &dmux->mem_;
331    int anim_chunks = 0;
332    ParseStatus status = PARSE_OK;
333    do {
334      int store_chunk = 1;
335      const size_t chunk_start_offset = mem->start_;
336      const uint32_t fourcc = ReadLE32(mem);
337      const uint32_t chunk_size = ReadLE32(mem);
338      const uint32_t chunk_size_padded = chunk_size + (chunk_size & 1);
339      if (chunk_size > MAX_CHUNK_PAYLOAD) return PARSE_ERROR;
340      if (SizeIsInvalid(mem, chunk_size_padded)) return PARSE_ERROR;
341      switch (fourcc) {
342        case MKFOURCC('V', 'P', '8', 'X'): {
343          return PARSE_ERROR;
344        }
345        case MKFOURCC('A', 'L', 'P', 'H'):
346        case MKFOURCC('V', 'P', '8', ' '):
347        case MKFOURCC('V', 'P', '8', 'L'): {
348          if (anim_chunks > 0 || is_animation) return PARSE_ERROR;
349          Rewind(mem, CHUNK_HEADER_SIZE);
350          status = ParseSingleImage(dmux);
351          break;
352        }
353        case MKFOURCC('A', 'N', 'I', 'M'): {
354          if (chunk_size_padded < ANIM_CHUNK_SIZE) return PARSE_ERROR;
355          if (MemDataSize(mem) < chunk_size_padded) {
356            status = PARSE_NEED_MORE_DATA;
357          } else if (anim_chunks == 0) {
358            ++anim_chunks;
359            dmux->bgcolor_ = ReadLE32(mem);
360            dmux->loop_count_ = ReadLE16s(mem);
361            Skip(mem, chunk_size_padded - ANIM_CHUNK_SIZE);
362          } else {
363            store_chunk = 0;
364            goto Skip;
365          }
366          break;
367        }
368        case MKFOURCC('A', 'N', 'M', 'F'): {
369          if (anim_chunks == 0) return PARSE_ERROR;  
370          status = ParseAnimationFrame(dmux, chunk_size_padded);
371          break;
372        }
373        case MKFOURCC('I', 'C', 'C', 'P'): {
374          store_chunk = !!(dmux->feature_flags_ & ICCP_FLAG);
375          goto Skip;
376        }
377        case MKFOURCC('E', 'X', 'I', 'F'): {
378          store_chunk = !!(dmux->feature_flags_ & EXIF_FLAG);
379          goto Skip;
380        }
381        case MKFOURCC('X', 'M', 'P', ' '): {
382          store_chunk = !!(dmux->feature_flags_ & XMP_FLAG);
383          goto Skip;
384        }
385   Skip:
386        default: {
387          if (chunk_size_padded <= MemDataSize(mem)) {
388            if (store_chunk) {
389              if (!StoreChunk(dmux, chunk_start_offset,
390                              CHUNK_HEADER_SIZE + chunk_size)) {
391                return PARSE_ERROR;
392              }
393            }
394            Skip(mem, chunk_size_padded);
395          } else {
396            status = PARSE_NEED_MORE_DATA;
397          }
398        }
399      }
400      if (mem->start_ == mem->riff_end_) {
401        break;
402      } else if (MemDataSize(mem) < CHUNK_HEADER_SIZE) {
403        status = PARSE_NEED_MORE_DATA;
404      }
405    } while (status == PARSE_OK);
406    return status;
407  }
408  static ParseStatus ParseVP8X(WebPDemuxer* const dmux) {
409    MemBuffer* const mem = &dmux->mem_;
410    uint32_t vp8x_size;
411    if (MemDataSize(mem) < CHUNK_HEADER_SIZE) return PARSE_NEED_MORE_DATA;
412    dmux->is_ext_format_ = 1;
413    Skip(mem, TAG_SIZE);  
414    vp8x_size = ReadLE32(mem);
415    if (vp8x_size > MAX_CHUNK_PAYLOAD) return PARSE_ERROR;
416    if (vp8x_size < VP8X_CHUNK_SIZE) return PARSE_ERROR;
417    vp8x_size += vp8x_size & 1;
418    if (SizeIsInvalid(mem, vp8x_size)) return PARSE_ERROR;
419    if (MemDataSize(mem) < vp8x_size) return PARSE_NEED_MORE_DATA;
420    dmux->feature_flags_ = ReadByte(mem);
421    Skip(mem, 3);  
422    dmux->canvas_width_  = 1 + ReadLE24s(mem);
423    dmux->canvas_height_ = 1 + ReadLE24s(mem);
424    if (dmux->canvas_width_ * (uint64_t)dmux->canvas_height_ >= MAX_IMAGE_AREA) {
425      return PARSE_ERROR;  
426    }
427    Skip(mem, vp8x_size - VP8X_CHUNK_SIZE);  
428    dmux->state_ = WEBP_DEMUX_PARSED_HEADER;
429    if (SizeIsInvalid(mem, CHUNK_HEADER_SIZE)) return PARSE_ERROR;
430    if (MemDataSize(mem) < CHUNK_HEADER_SIZE) return PARSE_NEED_MORE_DATA;
431    return ParseVP8XChunks(dmux);
432  }
433  static int IsValidSimpleFormat(const WebPDemuxer* const dmux) {
434    const Frame* const frame = dmux->frames_;
435    if (dmux->state_ == WEBP_DEMUX_PARSING_HEADER) return 1;
436    if (dmux->canvas_width_ <= 0 || dmux->canvas_height_ <= 0) return 0;
437    if (dmux->state_ == WEBP_DEMUX_DONE && frame == NULL) return 0;
438    if (frame->width_ <= 0 || frame->height_ <= 0) return 0;
439    return 1;
440  }
441  static int CheckFrameBounds(const Frame* const frame, int exact,
442                              int canvas_width, int canvas_height) {
443    if (exact) {
444      if (frame->x_offset_ != 0 || frame->y_offset_ != 0) {
445        return 0;
446      }
447      if (frame->width_ != canvas_width || frame->height_ != canvas_height) {
448        return 0;
449      }
450    } else {
451      if (frame->x_offset_ < 0 || frame->y_offset_ < 0) return 0;
452      if (frame->width_ + frame->x_offset_ > canvas_width) return 0;
453      if (frame->height_ + frame->y_offset_ > canvas_height) return 0;
454    }
455    return 1;
456  }
457  static int IsValidExtendedFormat(const WebPDemuxer* const dmux) {
458    const int is_animation = !!(dmux->feature_flags_ & ANIMATION_FLAG);
459    const Frame* f = dmux->frames_;
460    if (dmux->state_ == WEBP_DEMUX_PARSING_HEADER) return 1;
461    if (dmux->canvas_width_ <= 0 || dmux->canvas_height_ <= 0) return 0;
462    if (dmux->loop_count_ < 0) return 0;
463    if (dmux->state_ == WEBP_DEMUX_DONE && dmux->frames_ == NULL) return 0;
464    if (dmux->feature_flags_ & ~ALL_VALID_FLAGS) return 0;  
465    while (f != NULL) {
466      const int cur_frame_set = f->frame_num_;
467      int frame_count = 0;
468      for (; f != NULL && f->frame_num_ == cur_frame_set; f = f->next_) {
469        const ChunkData* const image = f->img_components_;
470        const ChunkData* const alpha = f->img_components_ + 1;
471        if (!is_animation && f->frame_num_ > 1) return 0;
472        if (f->complete_) {
473          if (alpha->size_ == 0 && image->size_ == 0) return 0;
474          if (alpha->size_ > 0 && alpha->offset_ > image->offset_) {
475            return 0;
476          }
477          if (f->width_ <= 0 || f->height_ <= 0) return 0;
478        } else {
479          if (dmux->state_ == WEBP_DEMUX_DONE) return 0;
480          if (alpha->size_ > 0 && image->size_ > 0 &&
481              alpha->offset_ > image->offset_) {
482            return 0;
483          }
484          if (f->next_ != NULL) return 0;
485        }
486        if (f->width_ > 0 && f->height_ > 0 &&
487            !CheckFrameBounds(f, !is_animation,
488                              dmux->canvas_width_, dmux->canvas_height_)) {
489          return 0;
490        }
491        ++frame_count;
492      }
493    }
494    return 1;
495  }
<span onclick='openModal()' class='match'>496  static void InitDemux(WebPDemuxer* const dmux, const MemBuffer* const mem) {
497    dmux->state_ = WEBP_DEMUX_PARSING_HEADER;
498    dmux->loop_count_ = 1;
499    dmux->bgcolor_ = 0xFFFFFFFF;  
500    dmux->canvas_width_ = -1;
501    dmux->canvas_height_ = -1;
502    dmux->frames_tail_ = &dmux->frames_;
503    dmux->chunks_tail_ = &dmux->chunks_;
504    dmux->mem_ = *mem;
505  }
</span>506  static ParseStatus CreateRawImageDemuxer(MemBuffer* const mem,
507                                           WebPDemuxer** demuxer) {
508    WebPBitstreamFeatures features;
509    const VP8StatusCode status =
510        WebPGetFeatures(mem->buf_, mem->buf_size_, &features);
511    *demuxer = NULL;
512    if (status != VP8_STATUS_OK) {
513      return (status == VP8_STATUS_NOT_ENOUGH_DATA) ? PARSE_NEED_MORE_DATA
514                                                    : PARSE_ERROR;
515    }
516    {
517      WebPDemuxer* const dmux = (WebPDemuxer*)WebPSafeCalloc(1ULL, sizeof(*dmux));
518      Frame* const frame = (Frame*)WebPSafeCalloc(1ULL, sizeof(*frame));
519      if (dmux == NULL || frame == NULL) goto Error;
520      InitDemux(dmux, mem);
521      SetFrameInfo(0, mem->buf_size_, 1 &bsol;*frame_num*/, 1 &bsol;*complete*/, &features,
522                   frame);
523      if (!AddFrame(dmux, frame)) goto Error;
524      dmux->state_ = WEBP_DEMUX_DONE;
525      dmux->canvas_width_ = frame->width_;
526      dmux->canvas_height_ = frame->height_;
527      dmux->feature_flags_ |= frame->has_alpha_ ? ALPHA_FLAG : 0;
528      dmux->num_frames_ = 1;
529      assert(IsValidSimpleFormat(dmux));
530      *demuxer = dmux;
531      return PARSE_OK;
532   Error:
533      WebPSafeFree(dmux);
534      WebPSafeFree(frame);
535      return PARSE_ERROR;
536    }
537  }
538  WebPDemuxer* WebPDemuxInternal(const WebPData* data, int allow_partial,
539                                 WebPDemuxState* state, int version) {
540    const ChunkParser* parser;
541    int partial;
542    ParseStatus status = PARSE_ERROR;
543    MemBuffer mem;
544    WebPDemuxer* dmux;
545    if (state != NULL) *state = WEBP_DEMUX_PARSE_ERROR;
546    if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_DEMUX_ABI_VERSION)) return NULL;
547    if (data == NULL || data->bytes == NULL || data->size == 0) return NULL;
548    if (!InitMemBuffer(&mem, data->bytes, data->size)) return NULL;
549    status = ReadHeader(&mem);
550    if (status != PARSE_OK) {
551      if (status == PARSE_ERROR) {
552        status = CreateRawImageDemuxer(&mem, &dmux);
553        if (status == PARSE_OK) {
554          if (state != NULL) *state = WEBP_DEMUX_DONE;
555          return dmux;
556        }
557      }
558      if (state != NULL) {
559        *state = (status == PARSE_NEED_MORE_DATA) ? WEBP_DEMUX_PARSING_HEADER
560                                                  : WEBP_DEMUX_PARSE_ERROR;
561      }
562      return NULL;
563    }
564    partial = (mem.buf_size_ < mem.riff_end_);
565    if (!allow_partial && partial) return NULL;
566    dmux = (WebPDemuxer*)WebPSafeCalloc(1ULL, sizeof(*dmux));
567    if (dmux == NULL) return NULL;
568    InitDemux(dmux, &mem);
569    status = PARSE_ERROR;
570    for (parser = kMasterChunks; parser->parse != NULL; ++parser) {
571      if (!memcmp(parser->id, GetBuffer(&dmux->mem_), TAG_SIZE)) {
572        status = parser->parse(dmux);
573        if (status == PARSE_OK) dmux->state_ = WEBP_DEMUX_DONE;
574        if (status == PARSE_NEED_MORE_DATA && !partial) status = PARSE_ERROR;
575        if (status != PARSE_ERROR && !parser->valid(dmux)) status = PARSE_ERROR;
576        if (status == PARSE_ERROR) dmux->state_ = WEBP_DEMUX_PARSE_ERROR;
577        break;
578      }
579    }
580    if (state != NULL) *state = dmux->state_;
581    if (status == PARSE_ERROR) {
582      WebPDemuxDelete(dmux);
583      return NULL;
584    }
585    return dmux;
586  }
587  void WebPDemuxDelete(WebPDemuxer* dmux) {
588    Chunk* c;
589    Frame* f;
590    if (dmux == NULL) return;
591    for (f = dmux->frames_; f != NULL;) {
592      Frame* const cur_frame = f;
593      f = f->next_;
594      WebPSafeFree(cur_frame);
595    }
596    for (c = dmux->chunks_; c != NULL;) {
597      Chunk* const cur_chunk = c;
598      c = c->next_;
599      WebPSafeFree(cur_chunk);
600    }
601    WebPSafeFree(dmux);
602  }
603  uint32_t WebPDemuxGetI(const WebPDemuxer* dmux, WebPFormatFeature feature) {
604    if (dmux == NULL) return 0;
605    switch (feature) {
606      case WEBP_FF_FORMAT_FLAGS:     return dmux->feature_flags_;
607      case WEBP_FF_CANVAS_WIDTH:     return (uint32_t)dmux->canvas_width_;
608      case WEBP_FF_CANVAS_HEIGHT:    return (uint32_t)dmux->canvas_height_;
609      case WEBP_FF_LOOP_COUNT:       return (uint32_t)dmux->loop_count_;
610      case WEBP_FF_BACKGROUND_COLOR: return dmux->bgcolor_;
611      case WEBP_FF_FRAME_COUNT:      return (uint32_t)dmux->num_frames_;
612    }
613    return 0;
614  }
615  static const Frame* GetFrame(const WebPDemuxer* const dmux, int frame_num) {
616    const Frame* f;
617    for (f = dmux->frames_; f != NULL; f = f->next_) {
618      if (frame_num == f->frame_num_) break;
619    }
620    return f;
621  }
622  static const uint8_t* GetFramePayload(const uint8_t* const mem_buf,
623                                        const Frame* const frame,
624                                        size_t* const data_size) {
625    *data_size = 0;
626    if (frame != NULL) {
627      const ChunkData* const image = frame->img_components_;
628      const ChunkData* const alpha = frame->img_components_ + 1;
629      size_t start_offset = image->offset_;
630      *data_size = image->size_;
631      if (alpha->size_ > 0) {
632        const size_t inter_size = (image->offset_ > 0)
633                                ? image->offset_ - (alpha->offset_ + alpha->size_)
634                                : 0;
635        start_offset = alpha->offset_;
636        *data_size  += alpha->size_ + inter_size;
637      }
638      return mem_buf + start_offset;
639    }
640    return NULL;
641  }
642  static int SynthesizeFrame(const WebPDemuxer* const dmux,
643                             const Frame* const frame,
644                             WebPIterator* const iter) {
645    const uint8_t* const mem_buf = dmux->mem_.buf_;
646    size_t payload_size = 0;
647    const uint8_t* const payload = GetFramePayload(mem_buf, frame, &payload_size);
648    if (payload == NULL) return 0;
649    assert(frame != NULL);
650    iter->frame_num      = frame->frame_num_;
651    iter->num_frames     = dmux->num_frames_;
652    iter->x_offset       = frame->x_offset_;
653    iter->y_offset       = frame->y_offset_;
654    iter->width          = frame->width_;
655    iter->height         = frame->height_;
656    iter->has_alpha      = frame->has_alpha_;
657    iter->duration       = frame->duration_;
658    iter->dispose_method = frame->dispose_method_;
659    iter->blend_method   = frame->blend_method_;
660    iter->complete       = frame->complete_;
661    iter->fragment.bytes = payload;
662    iter->fragment.size  = payload_size;
663    return 1;
664  }
665  static int SetFrame(int frame_num, WebPIterator* const iter) {
666    const Frame* frame;
667    const WebPDemuxer* const dmux = (WebPDemuxer*)iter->private_;
668    if (dmux == NULL || frame_num < 0) return 0;
669    if (frame_num > dmux->num_frames_) return 0;
670    if (frame_num == 0) frame_num = dmux->num_frames_;
671    frame = GetFrame(dmux, frame_num);
672    if (frame == NULL) return 0;
673    return SynthesizeFrame(dmux, frame, iter);
674  }
675  int WebPDemuxGetFrame(const WebPDemuxer* dmux, int frame, WebPIterator* iter) {
676    if (iter == NULL) return 0;
677    memset(iter, 0, sizeof(*iter));
678    iter->private_ = (void*)dmux;
679    return SetFrame(frame, iter);
680  }
681  int WebPDemuxNextFrame(WebPIterator* iter) {
682    if (iter == NULL) return 0;
683    return SetFrame(iter->frame_num + 1, iter);
684  }
685  int WebPDemuxPrevFrame(WebPIterator* iter) {
686    if (iter == NULL) return 0;
687    if (iter->frame_num <= 1) return 0;
688    return SetFrame(iter->frame_num - 1, iter);
689  }
690  void WebPDemuxReleaseIterator(WebPIterator* iter) {
691    (void)iter;
692  }
693  static int ChunkCount(const WebPDemuxer* const dmux, const char fourcc[4]) {
694    const uint8_t* const mem_buf = dmux->mem_.buf_;
695    const Chunk* c;
696    int count = 0;
697    for (c = dmux->chunks_; c != NULL; c = c->next_) {
698      const uint8_t* const header = mem_buf + c->data_.offset_;
699      if (!memcmp(header, fourcc, TAG_SIZE)) ++count;
700    }
701    return count;
702  }
703  static const Chunk* GetChunk(const WebPDemuxer* const dmux,
704                               const char fourcc[4], int chunk_num) {
705    const uint8_t* const mem_buf = dmux->mem_.buf_;
706    const Chunk* c;
707    int count = 0;
708    for (c = dmux->chunks_; c != NULL; c = c->next_) {
709      const uint8_t* const header = mem_buf + c->data_.offset_;
710      if (!memcmp(header, fourcc, TAG_SIZE)) ++count;
711      if (count == chunk_num) break;
712    }
713    return c;
714  }
715  static int SetChunk(const char fourcc[4], int chunk_num,
716                      WebPChunkIterator* const iter) {
717    const WebPDemuxer* const dmux = (WebPDemuxer*)iter->private_;
718    int count;
719    if (dmux == NULL || fourcc == NULL || chunk_num < 0) return 0;
720    count = ChunkCount(dmux, fourcc);
721    if (count == 0) return 0;
722    if (chunk_num == 0) chunk_num = count;
723    if (chunk_num <= count) {
724      const uint8_t* const mem_buf = dmux->mem_.buf_;
725      const Chunk* const chunk = GetChunk(dmux, fourcc, chunk_num);
726      iter->chunk.bytes = mem_buf + chunk->data_.offset_ + CHUNK_HEADER_SIZE;
727      iter->chunk.size  = chunk->data_.size_ - CHUNK_HEADER_SIZE;
728      iter->num_chunks  = count;
729      iter->chunk_num   = chunk_num;
730      return 1;
731    }
732    return 0;
733  }
734  int WebPDemuxGetChunk(const WebPDemuxer* dmux,
735                        const char fourcc[4], int chunk_num,
736                        WebPChunkIterator* iter) {
737    if (iter == NULL) return 0;
738    memset(iter, 0, sizeof(*iter));
739    iter->private_ = (void*)dmux;
740    return SetChunk(fourcc, chunk_num, iter);
741  }
742  int WebPDemuxNextChunk(WebPChunkIterator* iter) {
743    if (iter != NULL) {
744      const char* const fourcc =
745          (const char*)iter->chunk.bytes - CHUNK_HEADER_SIZE;
746      return SetChunk(fourcc, iter->chunk_num + 1, iter);
747    }
748    return 0;
749  }
750  int WebPDemuxPrevChunk(WebPChunkIterator* iter) {
751    if (iter != NULL && iter->chunk_num > 1) {
752      const char* const fourcc =
753          (const char*)iter->chunk.bytes - CHUNK_HEADER_SIZE;
754      return SetChunk(fourcc, iter->chunk_num - 1, iter);
755    }
756    return 0;
757  }
758  void WebPDemuxReleaseChunkIterator(WebPChunkIterator* iter) {
759    (void)iter;
760  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_arm.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-demux.c</div>
                </div>
                <div class="column column_space"><pre><code>41  {
42      __m128i xout1 = soft_aeskeygenassist<rcon>(*xout2);
43      xout1  = _mm_shuffle_epi32(xout1, 0xFF); 
44      *xout0 = sl_xor(*xout0);
45      *xout0 = _mm_xor_si128(*xout0, xout1);
46      xout1  = soft_aeskeygenassist<0x00>(*xout0);
47      xout1  = _mm_shuffle_epi32(xout1, 0xAA); 
48      *xout2 = sl_xor(*xout2);
49      *xout2 = _mm_xor_si128(*xout2, xout1);
50  }
</pre></code></div>
                <div class="column column_space"><pre><code>496  static void InitDemux(WebPDemuxer* const dmux, const MemBuffer* const mem) {
497    dmux->state_ = WEBP_DEMUX_PARSING_HEADER;
498    dmux->loop_count_ = 1;
499    dmux->bgcolor_ = 0xFFFFFFFF;  
500    dmux->canvas_width_ = -1;
501    dmux->canvas_height_ = -1;
502    dmux->frames_tail_ = &dmux->frames_;
503    dmux->chunks_tail_ = &dmux->chunks_;
504    dmux->mem_ = *mem;
505  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    