<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omusrmsg.c &amp; lookup.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omusrmsg.c &amp; lookup.c
      </h3>
<h1 align="center">
        2.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omusrmsg.c (4.980843%)<th>lookup.c (1.3598326%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(112-119)<td><a href="#" name="0">(55-62)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omusrmsg.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;signal.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;sys/param.h&gt;
10 #ifdef HAVE_UTMP_H
11 #  include &lt;utmp.h&gt;
12 #  define STRUCTUTMP struct utmp
13 #  define UTNAME ut_name
14 #else
15 #  include &lt;utmpx.h&gt;
16 #  define STRUCTUTMP struct utmpx
17 #  define UTNAME ut_user
18 #endif
19 #include &lt;unistd.h&gt;
20 #include &lt;sys/uio.h&gt;
21 #include &lt;sys/stat.h&gt;
22 #include &lt;errno.h&gt;
23 #if HAVE_FCNTL_H
24 #include &lt;fcntl.h&gt;
25 #else
26 #include &lt;sys/msgbuf.h&gt;
27 #endif
28 #ifdef HAVE_PATHS_H
29 #include &lt;paths.h&gt;
30 #endif
31 #include "rsyslog.h"
32 #include "srUtils.h"
33 #include "stringbuf.h"
34 #include "syslogd-types.h"
35 #include "conf.h"
36 #include "omusrmsg.h"
37 #include "module-template.h"
38 #include "errmsg.h"
39 #ifndef _PATH_DEV
40 #	define _PATH_DEV	"/dev/"
41 #endif
42 #ifdef UT_NAMESIZE
43 # define UNAMESZ	UT_NAMESIZE	#else
44 # define UNAMESZ	32	#endif
45 #define MAXUNAMES	20	
46 #ifdef OS_SOLARIS
47 #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
48 #endif
49 MODULE_TYPE_OUTPUT
50 MODULE_TYPE_NOKEEP
51 MODULE_CNFNAME("omusrmsg")
52 DEF_OMOD_STATIC_DATA
53 typedef struct _instanceData {
54 	int bIsWall; 	char uname[MAXUNAMES][UNAMESZ+1];
55 	uchar *tplName;
56 } instanceData;
57 typedef struct wrkrInstanceData {
58 	instanceData *pData;
59 } wrkrInstanceData_t;
60 typedef struct configSettings_s {
61 	EMPTY_STRUCT
62 } configSettings_t;
63 static configSettings_t __attribute__((unused)) cs;
64 <a name="0"></a>static struct cnfparamdescr actpdescr[] = {
65 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "users", eCmdHdlrString, CNFPARAM_REQUIRED },
66 	{ "template", eCmdHdlrGetWord, 0 }
67 };
68 static struct cnfparamblk actpblk =
69 	{ CNFPARAMBLK_VERSION,
70 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
71 	  actpdescr
72 	};</b></font>
73 BEGINinitConfVars		CODESTARTinitConfVars
74 ENDinitConfVars
75 BEGINcreateInstance
76 CODESTARTcreateInstance
77 ENDcreateInstance
78 BEGINcreateWrkrInstance
79 CODESTARTcreateWrkrInstance
80 ENDcreateWrkrInstance
81 BEGINisCompatibleWithFeature
82 CODESTARTisCompatibleWithFeature
83 	if(eFeat == sFEATURERepeatedMsgReduction)
84 		iRet = RS_RET_OK;
85 ENDisCompatibleWithFeature
86 BEGINfreeInstance
87 CODESTARTfreeInstance
88 	free(pData-&gt;tplName);
89 ENDfreeInstance
90 BEGINfreeWrkrInstance
91 CODESTARTfreeWrkrInstance
92 ENDfreeWrkrInstance
93 BEGINdbgPrintInstInfo
94 	register int i;
95 CODESTARTdbgPrintInstInfo
96 	for (i = 0; i &lt; MAXUNAMES &amp;&amp; *pData-&gt;uname[i]; i++)
97 		dbgprintf("%s, ", pData-&gt;uname[i]);
98 ENDdbgPrintInstInfo
99 #ifdef OS_BSD
100 #if defined(__FreeBSD__) &amp;&amp; (__FreeBSD_version &gt;= 900007)
101 #  define setutent(void) setutxent(void)
102 #  define getutent(void) getutxent(void)
103 #  define endutent(void) endutxent(void)
104 #else
105 static FILE *BSD_uf = NULL;
106 void setutent(void)
107 {
108 	assert(BSD_uf == NULL);
109 	if ((BSD_uf = fopen(_PATH_UTMP, "r")) == NULL) {
110 		LogError(errno, NO_ERRCODE, "error opening utmp %s", _PATH_UTMP);
111 		return;
112 	}
113 }
114 STRUCTUTMP* getutent(void)
115 {
116 	static STRUCTUTMP st_utmp;
117 	if(fread((char *)&amp;st_utmp, sizeof(st_utmp), 1, BSD_uf) != 1)
118 		return NULL;
119 	return(&amp;st_utmp);
120 }
121 void endutent(void)
122 {
123 	fclose(BSD_uf);
124 	BSD_uf = NULL;
125 }
126 #endif #endif  
127 static rsRetVal wallmsg(uchar* pMsg, instanceData *pData)
128 {
129 	uchar szErr[512];
130 	char p[sizeof(_PATH_DEV) + UNAMESZ];
131 	register int i;
132 	int errnoSave;
133 	int ttyf;
134 	int wrRet;
135 	STRUCTUTMP ut;
136 	STRUCTUTMP *uptr;
137 	struct stat statb;
138 	DEFiRet;
139 	assert(pMsg != NULL);
140 	setutent();
141 	while((uptr = getutent())) {
142 		memcpy(&amp;ut, uptr, sizeof(ut));
143 		if(ut.UTNAME[0] == '\0')
144 			continue;
145 #ifndef OS_BSD
146 		if(ut.ut_type != USER_PROCESS)
147 			continue;
148 #endif
149 		if(!(memcmp (ut.UTNAME,"LOGIN", 6))) 			continue;
150 		if(pData-&gt;bIsWall == 0) {
151 			for(i = 0; i &lt; MAXUNAMES; i++) {
152 				if(!pData-&gt;uname[i][0]) {
153 					i = MAXUNAMES;
154 					break;
155 				}
156 				if(strncmp(pData-&gt;uname[i], ut.UTNAME, UNAMESZ) == 0)
157 					break;
158 			}
159 			if(i == MAXUNAMES) 				continue; 		}
160 		strcpy(p, _PATH_DEV);
161 		strncat(p, ut.ut_line, UNAMESZ);
162 		if((ttyf = open(p, O_WRONLY|O_NOCTTY|O_NONBLOCK)) &gt;= 0) {
163 			if(fstat(ttyf, &amp;statb) == 0 &amp;&amp; (statb.st_mode &amp; S_IWRITE)) {
164 				wrRet = write(ttyf, pMsg, strlen((char*)pMsg));
165 				if(Debug &amp;&amp; wrRet == -1) {
166 					errnoSave = errno;
167 					rs_strerror_r(errno, (char*)szErr, sizeof(szErr));
168 					dbgprintf("write to terminal '%s' failed with [%d]:%s\n",
169 						  p, errnoSave, szErr);
170 				}
171 			}
172 			close(ttyf);
173 		}
174 	}
175 	endutent();
176 	RETiRet;
177 }
178 BEGINtryResume
179 CODESTARTtryResume
180 ENDtryResume
181 BEGINdoAction
182 CODESTARTdoAction
183 	dbgprintf("\n");
184 	iRet = wallmsg(ppString[0], pWrkrData-&gt;pData);
185 ENDdoAction
186 static void
187 populateUsers(instanceData *pData, es_str_t *usrs)
188 {
189 	int i;
190 	int iDst;
191 	es_size_t iUsr;
192 	es_size_t len;
193 	uchar *c;
194 	len = es_strlen(usrs);
195 	c = es_getBufAddr(usrs);
196 	pData-&gt;bIsWall = 0; 	iUsr = 0;
197 	for(i = 0 ; i &lt; MAXUNAMES &amp;&amp; iUsr &lt; len ; ++i) {
198 		for(  iDst = 0
199 		    ; iDst &lt; UNAMESZ &amp;&amp; iUsr &lt; len &amp;&amp; c[iUsr] != ','
200 		    ; ++iDst, ++iUsr) {
201 			pData-&gt;uname[i][iDst] = c[iUsr];
202 		}
203 		pData-&gt;uname[i][iDst] = '\0';
204 		DBGPRINTF("omusrmsg: send to user '%s'\n", pData-&gt;uname[i]);
205 		if(iUsr &lt; len &amp;&amp; c[iUsr] != ',') {
206 			LogError(0, RS_RET_ERR, "user name '%s...' too long - "
207 				"ignored", pData-&gt;uname[i]);
208 			--i;
209 			++iUsr;
210 			while(iUsr &lt; len &amp;&amp; c[iUsr] != ',')
211 				++iUsr; 		} else if(iDst == 0) {
212 			LogError(0, RS_RET_ERR, "no user name given - "
213 				"ignored");
214 			--i;
215 			++iUsr;
216 			while(iUsr &lt; len &amp;&amp; c[iUsr] != ',')
217 				++iUsr; 		}
218 		if(iUsr &lt; len) {
219 			++iUsr; 			while(iUsr &lt; len &amp;&amp; isspace(c[iUsr]))
220 				++iUsr; 		}
221 	}
222 	if(i == MAXUNAMES &amp;&amp; iUsr != len) {
223 		LogError(0, RS_RET_ERR, "omusrmsg supports only up to %d "
224 			"user names in a single action - all others have been ignored",
225 			MAXUNAMES);
226 	}
227 }
228 static inline void
229 setInstParamDefaults(instanceData *pData)
230 {
231 	pData-&gt;bIsWall = 0;
232 	pData-&gt;tplName = NULL;
233 }
234 BEGINnewActInst
235 	struct cnfparamvals *pvals;
236 	int i;
237 CODESTARTnewActInst
238 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
239 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
240 	}
241 	CHKiRet(createInstance(&amp;pData));
242 	setInstParamDefaults(pData);
243 	CODE_STD_STRING_REQUESTnewActInst(1)
244 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
245 		if(!pvals[i].bUsed)
246 			continue;
247 		if(!strcmp(actpblk.descr[i].name, "users")) {
248 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"*", 1)) {
249 				pData-&gt;bIsWall = 1;
250 			} else {
251 				populateUsers(pData, pvals[i].val.d.estr);
252 			}
253 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
254 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
255 		} else {
256 			dbgprintf("omusrmsg: program error, non-handled "
257 			  "param '%s'\n", actpblk.descr[i].name);
258 		}
259 	}
260 	if(pData-&gt;tplName == NULL) {
261 		CHKiRet(OMSRsetEntry(*ppOMSR, 0,
262 			(uchar*) strdup(pData-&gt;bIsWall ? " WallFmt" : " StdUsrMsgFmt"),
263 			OMSR_NO_RQD_TPL_OPTS));
264 	} else {
265 		CHKiRet(OMSRsetEntry(*ppOMSR, 0,
266 			(uchar*) strdup((char*) pData-&gt;tplName),
267 			OMSR_NO_RQD_TPL_OPTS));
268 	}
269 CODE_STD_FINALIZERnewActInst
270 	cnfparamvalsDestruct(pvals, &amp;actpblk);
271 ENDnewActInst
272 BEGINparseSelectorAct
273 	es_str_t *usrs;
274 	int bHadWarning;
275 CODESTARTparseSelectorAct
276 CODE_STD_STRING_REQUESTparseSelectorAct(1)
277 	bHadWarning = 0;
278 	if(!strncmp((char*) p, ":omusrmsg:", sizeof(":omusrmsg:") - 1)) {
279 		p += sizeof(":omusrmsg:") - 1; 	} else {
280 		if(!*p || !((*p &gt;= 'a' &amp;&amp; *p &lt;= 'z') || (*p &gt;= 'A' &amp;&amp; *p &lt;= 'Z')
281 	   || (*p &gt;= '0' &amp;&amp; *p &lt;= '9') || *p == '_' || *p == '.' || *p == '*')) {
282 			ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
283 		} else {
284 			LogMsg(0, RS_RET_OUTDATED_STMT, LOG_WARNING,
285 				"action '%s' treated as ':omusrmsg:%s' - please "
286 				"use ':omusrmsg:%s' syntax instead, '%s' will "
287 				"not be supported in the future",
288 				p, p, p, p);
289 			bHadWarning = 1;
290 		}
291 	}
292 	CHKiRet(createInstance(&amp;pData));
293 	if(*p == '*') { 		dbgprintf("write-all");
294 		++p; 		pData-&gt;bIsWall = 1; 		CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, (uchar*) " WallFmt"));
295 	} else {
296 		usrs = es_newStr(128);
297 		while(*p &amp;&amp; *p != ';') {
298 			es_addChar(&amp;usrs, *p);
299 			++p;
300 		}
301 		populateUsers(pData, usrs);
302 		es_deleteStr(usrs);
303 		if((iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, (uchar*)" StdUsrMsgFmt"))
304 			!= RS_RET_OK)
305 			goto finalize_it;
306 	}
307 	if(iRet == RS_RET_OK &amp;&amp; bHadWarning)
308 		iRet = RS_RET_OK_WARN;
309 CODE_STD_FINALIZERparseSelectorAct
310 ENDparseSelectorAct
311 BEGINmodExit
312 CODESTARTmodExit
313 ENDmodExit
314 BEGINqueryEtryPt
315 CODESTARTqueryEtryPt
316 CODEqueryEtryPt_STD_OMOD_QUERIES
317 CODEqueryEtryPt_STD_OMOD8_QUERIES
318 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
319 ENDqueryEtryPt
320 BEGINmodInit(UsrMsg)
321 CODESTARTmodInit
322 INITLegCnfVars
323 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
324 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lookup.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;errno.h&gt;
5 #include &lt;sys/types.h&gt;
6 #include &lt;sys/stat.h&gt;
7 #include &lt;fcntl.h&gt;
8 #include &lt;unistd.h&gt;
9 #include &lt;json.h&gt;
10 #include &lt;assert.h&gt;
11 #include "rsyslog.h"
12 #include "srUtils.h"
13 #include "errmsg.h"
14 #include "lookup.h"
15 #include "msg.h"
16 #include "rsconf.h"
17 #include "dirty.h"
18 #include "unicode-helper.h"
19 PRAGMA_IGNORE_Wdeprecated_declarations
20 DEFobjStaticHelpers
21 DEFobjCurrIf(glbl)
22 static rsRetVal lookupReadFile(lookup_t *pThis, const uchar* name, const uchar* filename);
23 static void lookupDestruct(lookup_t *pThis);
24 <a name="0"></a>static struct cnfparamdescr modpdescr[] = {
25 	{ "name", eCmdHdlrString, CNFPARAM_REQUIRED },
26 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "file", eCmdHdlrString, CNFPARAM_REQUIRED },
27 	{ "reloadOnHUP", eCmdHdlrBinary, 0 }
28 };
29 static struct cnfparamblk modpblk =
30 	{ CNFPARAMBLK_VERSION,
31 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
32 	  modpdescr
33 	};</b></font>
34 typedef struct uint32_index_val_s {
35 	uint32_t index;
36 	uchar *val;
37 } uint32_index_val_t;
38 const char * reloader_prefix = "lkp_tbl_reloader:";
39 static void *
40 lookupTableReloader(void *self);
41 static void
42 lookupStopReloader(lookup_ref_t *pThis);
43 static rsRetVal
44 lookupNew(lookup_ref_t **ppThis)
45 {
46 	lookup_ref_t *pThis = NULL;
47 	lookup_t *t = NULL;
48 	int initialized = 0;
49 	DEFiRet;
50 	CHKmalloc(pThis = calloc(1, sizeof(lookup_ref_t)));
51 	CHKmalloc(t = calloc(1, sizeof(lookup_t)));
52 	CHKiConcCtrl(pthread_rwlock_init(&amp;pThis-&gt;rwlock, NULL));
53 	CHKiConcCtrl(pthread_mutex_init(&amp;pThis-&gt;reloader_mut, NULL));
54 	CHKiConcCtrl(pthread_cond_init(&amp;pThis-&gt;run_reloader, NULL));
55 	CHKiConcCtrl(pthread_attr_init(&amp;pThis-&gt;reloader_thd_attr));
56 	pThis-&gt;do_reload = pThis-&gt;do_stop = 0;
57 	CHKiConcCtrl(pthread_create(&amp;pThis-&gt;reloader, &amp;pThis-&gt;reloader_thd_attr,
58 		lookupTableReloader, pThis));
59 	pThis-&gt;next = NULL;
60 	if(loadConf-&gt;lu_tabs.root == NULL) {
61 		loadConf-&gt;lu_tabs.root = pThis;
62 	} else {
63 		loadConf-&gt;lu_tabs.last-&gt;next = pThis;
64 	}
65 	loadConf-&gt;lu_tabs.last = pThis;
66 	pThis-&gt;self = t;
67 	*ppThis = pThis;
68 finalize_it:
69 	if(iRet != RS_RET_OK) {
70 		LogError(errno, iRet, "a lookup table could not be initialized: "
71 			"failed at init-step %d (please enable debug logs for details)",
72 			initialized);
73 		if (initialized &gt; 3) pthread_attr_destroy(&amp;pThis-&gt;reloader_thd_attr);
74 		if (initialized &gt; 2) pthread_cond_destroy(&amp;pThis-&gt;run_reloader);
75 		if (initialized &gt; 1) pthread_mutex_destroy(&amp;pThis-&gt;reloader_mut);
76 		if (initialized &gt; 0) pthread_rwlock_destroy(&amp;pThis-&gt;rwlock);
77 		free(t);
78 		free(pThis);
79 	}
80 	RETiRet;
81 }
82 static void ATTR_NONNULL()
83 freeStubValueForReloadFailure(lookup_ref_t *const pThis)
84 {
85 	if (pThis-&gt;stub_value_for_reload_failure != NULL) {
86 		free(pThis-&gt;stub_value_for_reload_failure);
87 		pThis-&gt;stub_value_for_reload_failure = NULL;
88 	}
89 }
90 static void
91 lookupStopReloader(lookup_ref_t *pThis) {
92 	pthread_mutex_lock(&amp;pThis-&gt;reloader_mut);
93 	freeStubValueForReloadFailure(pThis);
94 	pThis-&gt;do_reload = 0;
95 	pThis-&gt;do_stop = 1;
96 	pthread_cond_signal(&amp;pThis-&gt;run_reloader);
97 	pthread_mutex_unlock(&amp;pThis-&gt;reloader_mut);
98 	pthread_join(pThis-&gt;reloader, NULL);
99 }
100 static void
101 lookupRefDestruct(lookup_ref_t *pThis)
102 {
103 	lookupStopReloader(pThis);
104 	pthread_mutex_destroy(&amp;pThis-&gt;reloader_mut);
105 	pthread_cond_destroy(&amp;pThis-&gt;run_reloader);
106 	pthread_attr_destroy(&amp;pThis-&gt;reloader_thd_attr);
107 	pthread_rwlock_destroy(&amp;pThis-&gt;rwlock);
108 	lookupDestruct(pThis-&gt;self);
109 	free(pThis-&gt;name);
110 	free(pThis-&gt;filename);
111 	free(pThis);
112 }
113 static void
114 destructTable_str(lookup_t *pThis) {
115 	uint32_t i = 0;
116 	lookup_string_tab_entry_t *entries = pThis-&gt;table.str-&gt;entries;
117 	for (i = 0; i &lt; pThis-&gt;nmemb; i++) {
118 		free(entries[i].key);
119 	}
120 	free(entries);
121 	free(pThis-&gt;table.str);
122 }
123 static void
124 destructTable_arr(lookup_t *pThis) {
125 	free(pThis-&gt;table.arr-&gt;interned_val_refs);
126 	free(pThis-&gt;table.arr);
127 }
128 static void
129 destructTable_sparseArr(lookup_t *pThis) {
130 	free(pThis-&gt;table.sprsArr-&gt;entries);
131 	free(pThis-&gt;table.sprsArr);
132 }
133 static void
134 lookupDestruct(lookup_t *pThis) {
135 	uint32_t i;
136 	if (pThis == NULL) return;
137 	if (pThis-&gt;type == STRING_LOOKUP_TABLE) {
138 		destructTable_str(pThis);
139 	} else if (pThis-&gt;type == ARRAY_LOOKUP_TABLE) {
140 		destructTable_arr(pThis);
141 	} else if (pThis-&gt;type == SPARSE_ARRAY_LOOKUP_TABLE) {
142 		destructTable_sparseArr(pThis);
143 	} else if (pThis-&gt;type == STUBBED_LOOKUP_TABLE) {
144 	}
145 	for (i = 0; i &lt; pThis-&gt;interned_val_count; i++) {
146 		free(pThis-&gt;interned_vals[i]);
147 	}
148 	free(pThis-&gt;interned_vals);
149 	free(pThis-&gt;nomatch);
150 	free(pThis);
151 }
152 void
153 lookupInitCnf(lookup_tables_t *lu_tabs)
154 {
155 	lu_tabs-&gt;root = NULL;
156 	lu_tabs-&gt;last = NULL;
157 }
158 void
159 lookupDestroyCnf(void)
160 {
161 	lookup_ref_t *luref, *luref_next;
162 	for(luref = runConf-&gt;lu_tabs.root ; luref != NULL ; ) {
163 		luref_next = luref-&gt;next;
164 		lookupRefDestruct(luref);
165 		luref = luref_next;
166 	}
167 }
168 static int
169 qs_arrcmp_strtab(const void *s1, const void *s2)
170 {
171 	return ustrcmp(((lookup_string_tab_entry_t*)s1)-&gt;key, ((lookup_string_tab_entry_t*)s2)-&gt;key);
172 }
173 static int
174 qs_arrcmp_ustrs(const void *s1, const void *s2)
175 {
176 	return ustrcmp(*(uchar**)s1, *(uchar**)s2);
177 }
178 static int
179 qs_arrcmp_uint32_index_val(const void *s1, const void *s2)
180 {
181 	uint32_t first_value = ((uint32_index_val_t*)s1)-&gt;index;
182 	uint32_t second_value = ((uint32_index_val_t*)s2)-&gt;index;
183 	if (first_value &lt; second_value) {
184 		return -1;
185 	}
186 	return first_value - second_value;
187 }
188 static int
189 qs_arrcmp_sprsArrtab(const void *s1, const void *s2)
190 {
191 	uint32_t first_value = ((lookup_sparseArray_tab_entry_t*)s1)-&gt;key;
192 	uint32_t second_value = ((lookup_sparseArray_tab_entry_t*)s2)-&gt;key;
193 	if (first_value &lt; second_value) {
194 		return -1;
195 	}
196 	return first_value - second_value;
197 }
198 static int
199 bs_arrcmp_strtab(const void *s1, const void *s2)
200 {
201 	return strcmp((char*)s1, (char*)((lookup_string_tab_entry_t*)s2)-&gt;key);
202 }
203 static int
204 bs_arrcmp_str(const void *s1, const void *s2)
205 {
206 	return ustrcmp((uchar*)s1, *(uchar**)s2);
207 }
208 static int
209 bs_arrcmp_sprsArrtab(const void *s1, const void *s2)
210 {
211 	uint32_t key = *(uint32_t*)s1;
212 	uint32_t array_member_value = ((lookup_sparseArray_tab_entry_t*)s2)-&gt;key;
213 	if (key &lt; array_member_value) {
214 		return -1;
215 	}
216 	return key - array_member_value;
217 }
218 static inline const char*
219 defaultVal(lookup_t *pThis) {
220 	return (pThis-&gt;nomatch == NULL) ? "" : (const char*) pThis-&gt;nomatch;
221 }
222 static es_str_t*
223 lookupKey_stub(lookup_t *pThis, lookup_key_t __attribute__((unused)) key) {
224 	return es_newStrFromCStr((char*) pThis-&gt;nomatch, ustrlen(pThis-&gt;nomatch));
225 }
226 static es_str_t*
227 lookupKey_str(lookup_t *pThis, lookup_key_t key) {
228 	lookup_string_tab_entry_t *entry;
229 	const char *r;
230 	if(pThis-&gt;nmemb == 0) {
231 		entry = NULL;
232 	} else {
233 		assert(pThis-&gt;table.str-&gt;entries);
234 		entry = bsearch(key.k_str, pThis-&gt;table.str-&gt;entries, pThis-&gt;nmemb,
235 			sizeof(lookup_string_tab_entry_t), bs_arrcmp_strtab);
236 	}
237 	if(entry == NULL) {
238 		r = defaultVal(pThis);
239 	} else {
240 		r = (const char*)entry-&gt;interned_val_ref;
241 	}
242 	return es_newStrFromCStr(r, strlen(r));
243 }
244 static es_str_t*
245 lookupKey_arr(lookup_t *pThis, lookup_key_t key) {
246 	const char *r;
247 	uint32_t uint_key = key.k_uint;
248 	if ((pThis-&gt;nmemb == 0) || (uint_key &lt; pThis-&gt;table.arr-&gt;first_key)) {
249 		r = defaultVal(pThis);
250 	} else {
251 		uint32_t idx = uint_key - pThis-&gt;table.arr-&gt;first_key;
252 		if (idx &gt;= pThis-&gt;nmemb) {
253 			r = defaultVal(pThis);
254 		} else {
255 		    r = (char*) pThis-&gt;table.arr-&gt;interned_val_refs[idx];
256 		}
257 	}
258 	return es_newStrFromCStr(r, strlen(r));
259 }
260 typedef int (comp_fn_t)(const void *s1, const void *s2);
261 static void *
262 bsearch_lte(const void *key, const void *base, size_t nmemb, size_t size, comp_fn_t *comp_fn)
263 {
264 	size_t l, u, idx;
265 	const void *p;
266 	int comparison;
267 	l = 0;
268 	u = nmemb;
269 	if (l == u) {
270 		return NULL;
271 	}
272 	while (l &lt; u) {
273 		idx = (l + u) / 2;
274 		p = (void *) (((const char *) base) + (idx * size));
275 		comparison = (*comp_fn)(key, p);
276 		if (comparison &lt; 0)
277 			u = idx;
278 		else if (comparison &gt; 0)
279 			l = idx + 1;
280 		else
281 			return (void *) p;
282 	}
283 	if (comparison &lt; 0) {
284 		if (idx == 0) {
285 			return NULL;
286 		}
287 		idx--;
288 	}
289 	return (void *) (((const char *) base) + ( idx * size));
290 }
291 static es_str_t*
292 lookupKey_sprsArr(lookup_t *pThis, lookup_key_t key) {
293 	lookup_sparseArray_tab_entry_t *entry;
294 	const char *r;
295 	if (pThis-&gt;nmemb == 0) {
296 		entry = NULL;
297 	} else {
298 		entry = bsearch_lte(&amp;key.k_uint, pThis-&gt;table.sprsArr-&gt;entries, pThis-&gt;nmemb,
299 			sizeof(lookup_sparseArray_tab_entry_t), bs_arrcmp_sprsArrtab);
300 	}
301 	if(entry == NULL) {
302 		r = defaultVal(pThis);
303 	} else {
304 		r = (const char*)entry-&gt;interned_val_ref;
305 	}
306 	return es_newStrFromCStr(r, strlen(r));
307 }
308 #define NO_INDEX_ERROR(type, name)				\
309 	LogError(0, RS_RET_INVALID_VALUE, "'%s' lookup table named: '%s' has record(s) without 'index' "\
310 "field", type, name); \
311 	ABORT_FINALIZE(RS_RET_INVALID_VALUE);
312 static rsRetVal
313 build_StringTable(lookup_t *pThis, struct json_object *jtab, const uchar* name) {
314 	uint32_t i;
315 	struct json_object *jrow, *jindex, *jvalue;
316 	uchar *value, *canonicalValueRef;
317 	DEFiRet;
318 	pThis-&gt;table.str = NULL;
319 	CHKmalloc(pThis-&gt;table.str = calloc(1, sizeof(lookup_string_tab_t)));
320 	if (pThis-&gt;nmemb &gt; 0) {
321 		CHKmalloc(pThis-&gt;table.str-&gt;entries = calloc(pThis-&gt;nmemb, sizeof(lookup_string_tab_entry_t)));
322 		for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
323 			jrow = json_object_array_get_idx(jtab, i);
324 			jindex = json_object_object_get(jrow, "index");
325 			jvalue = json_object_object_get(jrow, "value");
326 			if (jindex == NULL || json_object_is_type(jindex, json_type_null)) {
327 				NO_INDEX_ERROR("string", name);
328 			}
329 			CHKmalloc(pThis-&gt;table.str-&gt;entries[i].key = ustrdup((uchar*) json_object_get_string(jindex)));
330 			value = (uchar*) json_object_get_string(jvalue);
331 			uchar **found  = (uchar**) bsearch(value, pThis-&gt;interned_vals,
332 				pThis-&gt;interned_val_count, sizeof(uchar*), bs_arrcmp_str);
333 			if(found == NULL) {
334 				LogError(0, RS_RET_INTERNAL_ERROR, "lookup.c:build_StringTable(): "
335 					"internal error, bsearch returned NULL for '%s'", value);
336 				ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
337 			}
338 			#ifndef __clang_analyzer__
339 			canonicalValueRef = *found;
340 			if(canonicalValueRef == NULL) {
341 				LogError(0, RS_RET_INTERNAL_ERROR, "lookup.c:build_StringTable(): "
342 					"internal error, canonicalValueRef returned from bsearch "
343 					"is NULL for '%s'", value);
344 				ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
345 			}
346 			pThis-&gt;table.str-&gt;entries[i].interned_val_ref = canonicalValueRef;
347 			#endif
348 		}
349 		qsort(pThis-&gt;table.str-&gt;entries, pThis-&gt;nmemb, sizeof(lookup_string_tab_entry_t), qs_arrcmp_strtab);
350 	}
351 	pThis-&gt;lookup = lookupKey_str;
352 	pThis-&gt;key_type = LOOKUP_KEY_TYPE_STRING;
353 finalize_it:
354 	RETiRet;
355 }
356 static rsRetVal
357 build_ArrayTable(lookup_t *pThis, struct json_object *jtab, const uchar *name) {
358 	uint32_t i;
359 	struct json_object *jrow, *jindex, *jvalue;
360 	uchar *canonicalValueRef;
361 	uint32_t prev_index, _index;
362 	uint8_t prev_index_set;
363 	uint32_index_val_t *indexes = NULL;
364 	DEFiRet;
365 	prev_index_set = 0;
366 	pThis-&gt;table.arr = NULL;
367 	CHKmalloc(pThis-&gt;table.arr = calloc(1, sizeof(lookup_array_tab_t)));
368 	if (pThis-&gt;nmemb &gt; 0) {
369 		CHKmalloc(indexes = calloc(pThis-&gt;nmemb, sizeof(uint32_index_val_t)));
370 		CHKmalloc(pThis-&gt;table.arr-&gt;interned_val_refs = calloc(pThis-&gt;nmemb, sizeof(uchar*)));
371 		for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
372 			jrow = json_object_array_get_idx(jtab, i);
373 			jindex = json_object_object_get(jrow, "index");
374 			jvalue = json_object_object_get(jrow, "value");
375 			if (jindex == NULL || json_object_is_type(jindex, json_type_null)) {
376 				NO_INDEX_ERROR("array", name);
377 			}
378 			indexes[i].index = (uint32_t) json_object_get_int(jindex);
379 			indexes[i].val = (uchar*) json_object_get_string(jvalue);
380 		}
381 		qsort(indexes, pThis-&gt;nmemb, sizeof(uint32_index_val_t), qs_arrcmp_uint32_index_val);
382 		for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
383 			_index = indexes[i].index;
384 			if (prev_index_set == 0) {
385 				prev_index = _index;
386 				prev_index_set = 1;
387 				pThis-&gt;table.arr-&gt;first_key = _index;
388 			} else {
389 				if (_index != ++prev_index) {
390 					LogError(0, RS_RET_INVALID_VALUE, "'array' lookup table name: '%s' "
391 					"has non-contiguous members between index '%d' and '%d'",
392 									name, prev_index, _index);
393 					ABORT_FINALIZE(RS_RET_INVALID_VALUE);
394 				}
395 			}
396 			uchar *const *const canonicalValueRef_ptr = bsearch(indexes[i].val, pThis-&gt;interned_vals,
397 				pThis-&gt;interned_val_count, sizeof(uchar*), bs_arrcmp_str);
398 			if(canonicalValueRef_ptr == NULL) {
399 				LogError(0, RS_RET_ERR, "BUG: canonicalValueRef not found in "
400 					"build_ArrayTable(), %s:%d", __FILE__, __LINE__);
401 				ABORT_FINALIZE(RS_RET_ERR);
402 			}
403 			canonicalValueRef = *canonicalValueRef_ptr;
404 			assert(canonicalValueRef != NULL);
405 			pThis-&gt;table.arr-&gt;interned_val_refs[i] = canonicalValueRef;
406 		}
407 	}
408 	pThis-&gt;lookup = lookupKey_arr;
409 	pThis-&gt;key_type = LOOKUP_KEY_TYPE_UINT;
410 finalize_it:
411 	free(indexes);
412 	RETiRet;
413 }
414 static rsRetVal
415 build_SparseArrayTable(lookup_t *pThis, struct json_object *jtab, const uchar* name) {
416 	uint32_t i;
417 	struct json_object *jrow, *jindex, *jvalue;
418 	uchar *value, *canonicalValueRef;
419 	DEFiRet;
420 	pThis-&gt;table.str = NULL;
421 	CHKmalloc(pThis-&gt;table.sprsArr = calloc(1, sizeof(lookup_sparseArray_tab_t)));
422 	if (pThis-&gt;nmemb &gt; 0) {
423 		CHKmalloc(pThis-&gt;table.sprsArr-&gt;entries = calloc(pThis-&gt;nmemb, sizeof(lookup_sparseArray_tab_entry_t)));
424 		for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
425 			jrow = json_object_array_get_idx(jtab, i);
426 			jindex = json_object_object_get(jrow, "index");
427 			jvalue = json_object_object_get(jrow, "value");
428 			if (jindex == NULL || json_object_is_type(jindex, json_type_null)) {
429 				NO_INDEX_ERROR("sparseArray", name);
430 			}
431 			pThis-&gt;table.sprsArr-&gt;entries[i].key = (uint32_t) json_object_get_int(jindex);
432 			value = (uchar*) json_object_get_string(jvalue);
433 			uchar *const *const canonicalValueRef_ptr = bsearch(value, pThis-&gt;interned_vals,
434 				pThis-&gt;interned_val_count, sizeof(uchar*), bs_arrcmp_str);
435 			if(canonicalValueRef_ptr == NULL) {
436 				LogError(0, RS_RET_ERR, "BUG: canonicalValueRef not found in "
437 					"build_SparseArrayTable(), %s:%d", __FILE__, __LINE__);
438 				ABORT_FINALIZE(RS_RET_ERR);
439 			}
440 			canonicalValueRef = *canonicalValueRef_ptr;
441 			assert(canonicalValueRef != NULL);
442 			pThis-&gt;table.sprsArr-&gt;entries[i].interned_val_ref = canonicalValueRef;
443 		}
444 		qsort(pThis-&gt;table.sprsArr-&gt;entries, pThis-&gt;nmemb, sizeof(lookup_sparseArray_tab_entry_t),
445 				qs_arrcmp_sprsArrtab);
446 	}
447 	pThis-&gt;lookup = lookupKey_sprsArr;
448 	pThis-&gt;key_type = LOOKUP_KEY_TYPE_UINT;
449 finalize_it:
450 	RETiRet;
451 }
452 static rsRetVal
453 lookupBuildStubbedTable(lookup_t *pThis, const uchar* stub_val) {
454 	DEFiRet;
455 	CHKmalloc(pThis-&gt;nomatch = ustrdup(stub_val));
456 	pThis-&gt;lookup = lookupKey_stub;
457 	pThis-&gt;type = STUBBED_LOOKUP_TABLE;
458 	pThis-&gt;key_type = LOOKUP_KEY_TYPE_NONE;
459 finalize_it:
460 	RETiRet;
461 }
462 static rsRetVal
463 lookupBuildTable_v1(lookup_t *pThis, struct json_object *jroot, const uchar* name) {
464 	struct json_object *jnomatch, *jtype, *jtab;
465 	struct json_object *jrow, *jvalue;
466 	const char *table_type, *nomatch_value;
467 	const uchar **all_values;
468 	const uchar *curr, *prev;
469 	uint32_t i, j;
470 	uint32_t uniq_values;
471 	DEFiRet;
472 	all_values = NULL;
473 	jnomatch = json_object_object_get(jroot, "nomatch");
474 	jtype = json_object_object_get(jroot, "type");
475 	jtab = json_object_object_get(jroot, "table");
476 	if (jtab == NULL || !json_object_is_type(jtab, json_type_array)) {
477 		LogError(0, RS_RET_INVALID_VALUE, "lookup table named: '%s' has invalid table definition", name);
478 		ABORT_FINALIZE(RS_RET_INVALID_VALUE);
479 	}
480 	pThis-&gt;nmemb = json_object_array_length(jtab);
481 	table_type = json_object_get_string(jtype);
482 	if (table_type == NULL) {
483 		table_type = "string";
484 	}
485 	CHKmalloc(all_values = malloc(pThis-&gt;nmemb * sizeof(uchar*)));
486 	for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
487 		jrow = json_object_array_get_idx(jtab, i);
488 		jvalue = json_object_object_get(jrow, "value");
489 		if (jvalue == NULL || json_object_is_type(jvalue, json_type_null)) {
490 			LogError(0, RS_RET_INVALID_VALUE, "'%s' lookup table named: '%s' has record(s) "
491 			"without 'value' field", table_type, name);
492 			ABORT_FINALIZE(RS_RET_INVALID_VALUE);
493 		}
494 		all_values[i] = (const uchar*) json_object_get_string(jvalue);
495 	}
496 	qsort(all_values, pThis-&gt;nmemb, sizeof(uchar*), qs_arrcmp_ustrs);
497 	uniq_values = 1;
498 	for(i = 1; i &lt; pThis-&gt;nmemb; i++) {
499 		curr = all_values[i];
500 		prev = all_values[i - 1];
501 		if (ustrcmp(prev, curr) != 0) {
502 			uniq_values++;
503 		}
504 	}
505 	if (pThis-&gt;nmemb &gt; 0)  {
506 		CHKmalloc(pThis-&gt;interned_vals = malloc(uniq_values * sizeof(uchar*)));
507 		j = 0;
508 		CHKmalloc(pThis-&gt;interned_vals[j++] = ustrdup(all_values[0]));
509 		for(i = 1; i &lt; pThis-&gt;nmemb ; ++i) {
510 			curr = all_values[i];
511 			prev = all_values[i - 1];
512 			if (ustrcmp(prev, curr) != 0) {
513 				CHKmalloc(pThis-&gt;interned_vals[j++] = ustrdup(all_values[i]));
514 			}
515 		}
516 		pThis-&gt;interned_val_count = uniq_values;
517 	}
518 	nomatch_value = json_object_get_string(jnomatch);
519 	if (nomatch_value != NULL) {
520 		CHKmalloc(pThis-&gt;nomatch = (uchar*) strdup(nomatch_value));
521 	}
522 	if (strcmp(table_type, "array") == 0) {
523 		pThis-&gt;type = ARRAY_LOOKUP_TABLE;
524 		CHKiRet(build_ArrayTable(pThis, jtab, name));
525 	} else if (strcmp(table_type, "sparseArray") == 0) {
526 		pThis-&gt;type = SPARSE_ARRAY_LOOKUP_TABLE;
527 		CHKiRet(build_SparseArrayTable(pThis, jtab, name));
528 	} else if (strcmp(table_type, "string") == 0) {
529 		pThis-&gt;type = STRING_LOOKUP_TABLE;
530 		CHKiRet(build_StringTable(pThis, jtab, name));
531 	} else {
532 		LogError(0, RS_RET_INVALID_VALUE, "lookup table named: '%s' uses unupported "
533 				"type: '%s'", name, table_type);
534 		ABORT_FINALIZE(RS_RET_INVALID_VALUE);
535 	}
536 finalize_it:
537 	if (all_values != NULL) free(all_values);
538 	RETiRet;
539 }
540 static rsRetVal
541 lookupBuildTable(lookup_t *pThis, struct json_object *jroot, const uchar* name)
542 {
543 	struct json_object *jversion;
544 	int version = 1;
545 	DEFiRet;
546 	jversion = json_object_object_get(jroot, "version");
547 	if (jversion != NULL &amp;&amp; !json_object_is_type(jversion, json_type_null)) {
548 		version = json_object_get_int(jversion);
549 	} else {
550 		LogError(0, RS_RET_INVALID_VALUE, "lookup table named: '%s' doesn't specify version "
551 		"(will use default value: %d)", name, version);
552 	}
553 	if (version == 1) {
554 		CHKiRet(lookupBuildTable_v1(pThis, jroot, name));
555 	} else {
556 		LogError(0, RS_RET_INVALID_VALUE, "lookup table named: '%s' uses unsupported "
557 				"version: %d", name, version);
558 		ABORT_FINALIZE(RS_RET_INVALID_VALUE);
559 	}
560 finalize_it:
561 	RETiRet;
562 }
563 lookup_ref_t * ATTR_NONNULL()
564 lookupFindTable(uchar *name)
565 {
566 	lookup_ref_t *curr;
567 	for(curr = loadConf-&gt;lu_tabs.root ; curr != NULL ; curr = curr-&gt;next) {
568 		if(!ustrcmp(curr-&gt;name, name))
569 			break;
570 	}
571 	return curr;
572 }
573 static rsRetVal
574 lookupReloadOrStub(lookup_ref_t *pThis, const uchar* stub_val) {
575 	DEFiRet;
576 	oldlu = pThis-&gt;self;
577 	newlu = NULL;
578 	DBGPRINTF("reload requested for lookup table '%s'\n", pThis-&gt;name);
579 	CHKmalloc(newlu = calloc(1, sizeof(lookup_t)));
580 	if (stub_val == NULL) {
581 		CHKiRet(lookupReadFile(newlu, pThis-&gt;name, pThis-&gt;filename));
582 	} else {
583 		CHKiRet(lookupBuildStubbedTable(newlu, stub_val));
584 	}
585 	pthread_rwlock_wrlock(&amp;pThis-&gt;rwlock);
586 	pThis-&gt;self = newlu;
587 	pthread_rwlock_unlock(&amp;pThis-&gt;rwlock);
588 finalize_it:
589 	if (iRet != RS_RET_OK) {
590 		if (stub_val == NULL) {
591 			LogError(0, RS_RET_INTERNAL_ERROR,
592 					"lookup table '%s' could not be reloaded from file '%s'",
593 					pThis-&gt;name, pThis-&gt;filename);
594 		} else {
595 			LogError(0, RS_RET_INTERNAL_ERROR,
596 					"lookup table '%s' could not be stubbed with value '%s'",
597 					pThis-&gt;name, stub_val);
598 		}
599 		lookupDestruct(newlu);
600 	} else {
601 		if (stub_val == NULL) {
602 			LogMsg(0, RS_RET_OK, LOG_INFO, "lookup table '%s' reloaded from file '%s'",
603 					pThis-&gt;name, pThis-&gt;filename);
604 		} else {
605 			LogError(0, RS_RET_OK, "lookup table '%s' stubbed with value '%s'",
606 					pThis-&gt;name, stub_val);
607 		}
608 		lookupDestruct(oldlu);
609 	}
610 	RETiRet;
611 }
612 static rsRetVal
613 lookupDoStub(lookup_ref_t *pThis, const uchar* stub_val)
614 {
615 	int already_stubbed = 0;
616 	DEFiRet;
617 	pthread_rwlock_rdlock(&amp;pThis-&gt;rwlock);
618 	if (pThis-&gt;self-&gt;type == STUBBED_LOOKUP_TABLE &amp;&amp;
619 		ustrcmp(pThis-&gt;self-&gt;nomatch, stub_val) == 0)
620 		already_stubbed = 1;
621 	pthread_rwlock_unlock(&amp;pThis-&gt;rwlock);
622 	if (! already_stubbed) {
623 		LogError(0, RS_RET_OK, "stubbing lookup table '%s' with value '%s'",
624 			pThis-&gt;name, stub_val);
625 		CHKiRet(lookupReloadOrStub(pThis, stub_val));
626 	} else {
627 		LogError(0, RS_RET_OK, "lookup table '%s' is already stubbed with value '%s'",
628 			pThis-&gt;name, stub_val);
629 	}
630 finalize_it:
631 	RETiRet;
632 }
633 static uint8_t
634 lookupIsReloadPending(lookup_ref_t *pThis) {
635 	uint8_t reload_pending;
636 	pthread_mutex_lock(&amp;pThis-&gt;reloader_mut);
637 	reload_pending = pThis-&gt;do_reload;
638 	pthread_mutex_unlock(&amp;pThis-&gt;reloader_mut);
639 	return reload_pending;
640 }
641 rsRetVal ATTR_NONNULL(1)
642 lookupReload(lookup_ref_t *const pThis, const uchar *const stub_val_if_reload_fails)
643 {
644 	uint8_t locked = 0;
645 	int lock_errno = 0;
646 	DEFiRet;
647 	assert(pThis != NULL);
648 	if ((lock_errno = pthread_mutex_trylock(&amp;pThis-&gt;reloader_mut)) == 0) {
649 		locked = 1;
650 		freeStubValueForReloadFailure(pThis);
651 		if (stub_val_if_reload_fails != NULL) {
652 			CHKmalloc(pThis-&gt;stub_value_for_reload_failure = ustrdup(stub_val_if_reload_fails));
653 		}
654 		pThis-&gt;do_reload = 1;
655 		pthread_cond_signal(&amp;pThis-&gt;run_reloader);
656 	} else {
657 		LogError(lock_errno, RS_RET_INTERNAL_ERROR, "attempt to trigger "
658 			"reload of lookup table '%s' failed (not stubbing)", pThis-&gt;name);
659 		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
660 	}
661 finalize_it:
662 	if (locked) {
663 		pthread_mutex_unlock(&amp;pThis-&gt;reloader_mut);
664 	}
665 	RETiRet;
666 }
667 static rsRetVal ATTR_NONNULL()
668 lookupDoReload(lookup_ref_t *pThis)
669 {
670 	DEFiRet;
671 	iRet = lookupReloadOrStub(pThis, NULL);
672 	if ((iRet != RS_RET_OK) &amp;&amp;
673 		(pThis-&gt;stub_value_for_reload_failure != NULL)) {
674 		iRet = lookupDoStub(pThis, pThis-&gt;stub_value_for_reload_failure);
675 	}
676 	freeStubValueForReloadFailure(pThis);
677 	RETiRet;
678 }
679 void *
680 lookupTableReloader(void *self)
681 {
682 	lookup_ref_t *pThis = (lookup_ref_t*) self;
683 	pthread_mutex_lock(&amp;pThis-&gt;reloader_mut);
684 	while(1) {
685 		if (pThis-&gt;do_stop) {
686 			break;
687 		} else if (pThis-&gt;do_reload) {
688 			pThis-&gt;do_reload = 0;
689 			lookupDoReload(pThis);
690 		} else {
691 			pthread_cond_wait(&amp;pThis-&gt;run_reloader, &amp;pThis-&gt;reloader_mut);
692 		}
693 	}
694 	pthread_mutex_unlock(&amp;pThis-&gt;reloader_mut);
695 	return NULL;
696 }
697 void
698 lookupDoHUP(void)
699 {
700 	lookup_ref_t *luref;
701 	for(luref = runConf-&gt;lu_tabs.root ; luref != NULL ; luref = luref-&gt;next) {
702 		if (luref-&gt;reload_on_hup) {
703 			lookupReload(luref, NULL);
704 		}
705 	}
706 }
707 uint
708 lookupPendingReloadCount(void)
709 {
710 	uint pending_reload_count = 0;
711 	lookup_ref_t *luref;
712 	for(luref = runConf-&gt;lu_tabs.root ; luref != NULL ; luref = luref-&gt;next) {
713 		if (lookupIsReloadPending(luref)) {
714 			pending_reload_count++;
715 		}
716 	}
717 	return pending_reload_count;
718 }
719 es_str_t *
720 lookupKey(lookup_ref_t *pThis, lookup_key_t key)
721 {
722 	es_str_t *estr;
723 	lookup_t *t;
724 	pthread_rwlock_rdlock(&amp;pThis-&gt;rwlock);
725 	t = pThis-&gt;self;
726 	estr = t-&gt;lookup(t, key);
727 	pthread_rwlock_unlock(&amp;pThis-&gt;rwlock);
728 	return estr;
729 }
730 static rsRetVal ATTR_NONNULL()
731 lookupReadFile(lookup_t *const pThis, const uchar *const name, const uchar *const filename)
732 {
733 	struct json_tokener *tokener = NULL;
734 	struct json_object *json = NULL;
735 	char *iobuf = NULL;
736 	int fd = -1;
737 	ssize_t nread;
738 	struct stat sb;
739 	DEFiRet;
740 	if((fd = open((const char*) filename, O_RDONLY)) == -1) {
741 		LogError(errno, RS_RET_FILE_NOT_FOUND,
742 			"lookup table file '%s' could not be opened", filename);
743 		ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
744 	}
745 	if(fstat(fd, &amp;sb) == -1) {
746 		LogError(errno, RS_RET_FILE_NOT_FOUND,
747 			"lookup table file '%s' stat failed", filename);
748 		ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
749 	}
750 	CHKmalloc(iobuf = malloc(sb.st_size));
751 	tokener = json_tokener_new();
752 	nread = read(fd, iobuf, sb.st_size);
753 	if(nread != (ssize_t) sb.st_size) {
754 		LogError(errno, RS_RET_READ_ERR,
755 			"lookup table file '%s' read error", filename);
756 		ABORT_FINALIZE(RS_RET_READ_ERR);
757 	}
758 	json = json_tokener_parse_ex(tokener, iobuf, sb.st_size);
759 	if(json == NULL) {
760 		LogError(0, RS_RET_JSON_PARSE_ERR,
761 			"lookup table file '%s' json parsing error",
762 			filename);
763 		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
764 	}
765 	iobuf = NULL; 
766 	CHKiRet(lookupBuildTable(pThis, json, name));
767 finalize_it:
768 	if (fd != -1) {
769 		close(fd);
770 	}
771 	free(iobuf);
772 	if(tokener != NULL)
773 		json_tokener_free(tokener);
774 	if(json != NULL)
775 		json_object_put(json);
776 	RETiRet;
777 }
778 rsRetVal
779 lookupTableDefProcessCnf(struct cnfobj *o)
780 {
781 	struct cnfparamvals *pvals;
782 	lookup_ref_t *lu;
783 	short i;
784 #ifdef HAVE_PTHREAD_SETNAME_NP
785 	char *reloader_thd_name = NULL;
786 	int thd_name_len = 0;
787 #endif
788 	DEFiRet;
789 	lu = NULL;
790 	pvals = nvlstGetParams(o-&gt;nvlst, &amp;modpblk, NULL);
791 	if(pvals == NULL) {
792 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
793 	}
794 	DBGPRINTF("lookupTableDefProcessCnf params:\n");
795 	cnfparamsPrint(&amp;modpblk, pvals);
796 	CHKiRet(lookupNew(&amp;lu));
797 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
798 		if(!pvals[i].bUsed)
799 			continue;
800 		if(!strcmp(modpblk.descr[i].name, "file")) {
801 			CHKmalloc(lu-&gt;filename = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL));
802 		} else if(!strcmp(modpblk.descr[i].name, "name")) {
803 			CHKmalloc(lu-&gt;name = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL));
804 		} else if(!strcmp(modpblk.descr[i].name, "reloadOnHUP")) {
805 			lu-&gt;reload_on_hup = (pvals[i].val.d.n != 0);
806 		} else {
807 			dbgprintf("lookup_table: program error, non-handled "
808 			  "param '%s'\n", modpblk.descr[i].name);
809 		}
810 	}
811 #ifdef HAVE_PTHREAD_SETNAME_NP
812 	thd_name_len = ustrlen(lu-&gt;name) + strlen(reloader_prefix) + 1;
813 	CHKmalloc(reloader_thd_name = malloc(thd_name_len));
814 	strcpy(reloader_thd_name, reloader_prefix);
815 	strcpy(reloader_thd_name + strlen(reloader_prefix), (char*) lu-&gt;name);
816 	reloader_thd_name[thd_name_len - 1] = '\0';
817 #if defined(__NetBSD__)
818 	pthread_setname_np(lu-&gt;reloader, "%s", reloader_thd_name);
819 #elif defined(__APPLE__)
820 	pthread_setname_np(reloader_thd_name); #else
821 	pthread_setname_np(lu-&gt;reloader, reloader_thd_name);
822 #endif
823 #endif
824 	CHKiRet(lookupReadFile(lu-&gt;self, lu-&gt;name, lu-&gt;filename));
825 	LogMsg(0, RS_RET_OK, LOG_INFO, "lookup table '%s' loaded from file '%s'",
826 		lu-&gt;name, lu-&gt;filename);
827 finalize_it:
828 #ifdef HAVE_PTHREAD_SETNAME_NP
829 	free(reloader_thd_name);
830 #endif
831 	cnfparamvalsDestruct(pvals, &amp;modpblk);
832 	if (iRet != RS_RET_OK) {
833 		if (lu != NULL) {
834 			lookupDestruct(lu-&gt;self);
835 			lu-&gt;self = NULL;
836 		}
837 	}
838 	RETiRet;
839 }
840 void
841 lookupClassExit(void)
842 {
843 	objRelease(glbl, CORE_COMPONENT);
844 }
845 rsRetVal
846 lookupClassInit(void)
847 {
848 	DEFiRet;
849 	CHKiRet(objGetObjInterface(&amp;obj));
850 	CHKiRet(objUse(glbl, CORE_COMPONENT));
851 finalize_it:
852 	RETiRet;
853 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
