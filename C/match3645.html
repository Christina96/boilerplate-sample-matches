<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for omusrmsg.c & lookup.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for omusrmsg.c & lookup.c
      </h3>
      <h1 align="center">
        2.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>omusrmsg.c (4.980843%)<TH>lookup.c (1.3598326%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match3645-0.html#0',2,'match3645-1.html#0',3)" NAME="0">(112-119)<TD><A HREF="javascript:ZweiFrames('match3645-0.html#0',2,'match3645-1.html#0',3)" NAME="0">(55-62)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omusrmsg.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omusrmsg.c
 * This is the implementation of the build-in output module for sending
 * user messages.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * File begun on 2007-07-20 by RGerhards (extracted from syslogd.c, which at the
 * time of the fork from sysklogd was under BSD license)
 *
 * Copyright 2007-2018 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/param.h&gt;
#ifdef HAVE_UTMP_H
#  include &lt;utmp.h&gt;
#  define STRUCTUTMP struct utmp
#  define UTNAME ut_name
#else
#  include &lt;utmpx.h&gt;
#  define STRUCTUTMP struct utmpx
#  define UTNAME ut_user
#endif
#include &lt;unistd.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;
#if HAVE_FCNTL_H
#include &lt;fcntl.h&gt;
#else
#include &lt;sys/msgbuf.h&gt;
#endif
#ifdef HAVE_PATHS_H
#include &lt;paths.h&gt;
#endif
#include &quot;rsyslog.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;stringbuf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;conf.h&quot;
#include &quot;omusrmsg.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;


/* portability: */
#ifndef _PATH_DEV
#	define _PATH_DEV	&quot;/dev/&quot;
#endif

#ifdef UT_NAMESIZE
# define UNAMESZ	UT_NAMESIZE	/* length of a login name */
#else
# define UNAMESZ	32	/* length of a login name, 32 seems current (2018) good bet */
#endif
#define MAXUNAMES	20	/* maximum number of user names */

#ifdef OS_SOLARIS
#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;
#endif

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omusrmsg&quot;)

/* internal structures
 */
DEF_OMOD_STATIC_DATA

typedef struct _instanceData {
	int bIsWall; /* 1- is wall, 0 - individual users */
	char uname[MAXUNAMES][UNAMESZ+1];
	uchar *tplName;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

typedef struct configSettings_s {
	EMPTY_STRUCT
} configSettings_t;
static configSettings_t __attribute__((unused)) cs;


<A NAME="0"></A>/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3645-1.html#0',3,'match3645-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;users&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
ENDinitConfVars


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;tplName);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
	register int i;
CODESTARTdbgPrintInstInfo
	for (i = 0; i &lt; MAXUNAMES &amp;&amp; *pData-&gt;uname[i]; i++)
		dbgprintf(&quot;%s, &quot;, pData-&gt;uname[i]);
ENDdbgPrintInstInfo


/**
 * BSD setutent/getutent() replacement routines
 * The following routines emulate setutent() and getutent() under
 * BSD because they are not available there. We only emulate what we actually
 * need! rgerhards 2005-03-18
 */
#ifdef OS_BSD
/* Since version 900007, FreeBSD has a POSIX compliant &lt;utmpx.h&gt; */
#if defined(__FreeBSD__) &amp;&amp; (__FreeBSD_version &gt;= 900007)
#  define setutent(void) setutxent(void)
#  define getutent(void) getutxent(void)
#  define endutent(void) endutxent(void)
#else
static FILE *BSD_uf = NULL;
void setutent(void)
{
	assert(BSD_uf == NULL);
	if ((BSD_uf = fopen(_PATH_UTMP, &quot;r&quot;)) == NULL) {
		LogError(errno, NO_ERRCODE, &quot;error opening utmp %s&quot;, _PATH_UTMP);
		return;
	}
}

STRUCTUTMP* getutent(void)
{
	static STRUCTUTMP st_utmp;

	if(fread((char *)&amp;st_utmp, sizeof(st_utmp), 1, BSD_uf) != 1)
		return NULL;

	return(&amp;st_utmp);
}

void endutent(void)
{
	fclose(BSD_uf);
	BSD_uf = NULL;
}
#endif /* if defined(__FreeBSD__) */
#endif  /* #ifdef OS_BSD */


/*  WALLMSG -- Write a message to the world at large
 *
 *	Write the specified message to either the entire
 *	world, or a list of approved users.
 *
 * rgerhards, 2005-10-19: applying the following sysklogd patch:
 * Tue May  4 16:52:01 CEST 2004: Solar Designer &lt;solar@openwall.com&gt;
 *	Adjust the size of a variable to prevent a buffer overflow
 *	should _PATH_DEV ever contain something different than &quot;/dev/&quot;.
 * rgerhards, 2008-07-04: changing the function to no longer use fork() but
 * 	continue run on its thread instead.
 */
static rsRetVal wallmsg(uchar* pMsg, instanceData *pData)
{

	uchar szErr[512];
	char p[sizeof(_PATH_DEV) + UNAMESZ];
	register int i;
	int errnoSave;
	int ttyf;
	int wrRet;
	STRUCTUTMP ut;
	STRUCTUTMP *uptr;
	struct stat statb;
	DEFiRet;

	assert(pMsg != NULL);

	/* open the user login file */
	setutent();

	/* scan the user login file */
	while((uptr = getutent())) {
		memcpy(&amp;ut, uptr, sizeof(ut));
		/* is this slot used? */
		if(ut.UTNAME[0] == '\0')
			continue;
#ifndef OS_BSD
		if(ut.ut_type != USER_PROCESS)
			continue;
#endif
		if(!(memcmp (ut.UTNAME,&quot;LOGIN&quot;, 6))) /* paranoia */
			continue;

		/* should we send the message to this user? */
		if(pData-&gt;bIsWall == 0) {
			for(i = 0; i &lt; MAXUNAMES; i++) {
				if(!pData-&gt;uname[i][0]) {
					i = MAXUNAMES;
					break;
				}
				if(strncmp(pData-&gt;uname[i], ut.UTNAME, UNAMESZ) == 0)
					break;
			}
			if(i == MAXUNAMES) /* user not found? */
				continue; /* on to next user! */
		}

		/* compute the device name */
		strcpy(p, _PATH_DEV);
		strncat(p, ut.ut_line, UNAMESZ);

		/* we must be careful when writing to the terminal. A terminal may block
		 * (for example, a user has pressed &lt;ctl&gt;-s). In that case, we can not
		 * wait indefinitely. So we need to use non-blocking I/O. In case we would
		 * block, we simply do not send the message, because that's the best we can
		 * do. -- rgerhards, 2008-07-04
		 */

		/* open the terminal */
		if((ttyf = open(p, O_WRONLY|O_NOCTTY|O_NONBLOCK)) &gt;= 0) {
			if(fstat(ttyf, &amp;statb) == 0 &amp;&amp; (statb.st_mode &amp; S_IWRITE)) {
				wrRet = write(ttyf, pMsg, strlen((char*)pMsg));
				if(Debug &amp;&amp; wrRet == -1) {
					/* we record the state to the debug log */
					errnoSave = errno;
					rs_strerror_r(errno, (char*)szErr, sizeof(szErr));
					dbgprintf(&quot;write to terminal '%s' failed with [%d]:%s\n&quot;,
						  p, errnoSave, szErr);
				}
			}
			close(ttyf);
		}
	}

	/* close the user login file */
	endutent();
	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
ENDtryResume

BEGINdoAction
CODESTARTdoAction
	dbgprintf(&quot;\n&quot;);
	iRet = wallmsg(ppString[0], pWrkrData-&gt;pData);
ENDdoAction


static void
populateUsers(instanceData *pData, es_str_t *usrs)
{
	int i;
	int iDst;
	es_size_t iUsr;
	es_size_t len;
	uchar *c;

	len = es_strlen(usrs);
	c = es_getBufAddr(usrs);
	pData-&gt;bIsWall = 0; /* write to individual users */
	iUsr = 0;
	for(i = 0 ; i &lt; MAXUNAMES &amp;&amp; iUsr &lt; len ; ++i) {
		for(  iDst = 0
		    ; iDst &lt; UNAMESZ &amp;&amp; iUsr &lt; len &amp;&amp; c[iUsr] != ','
		    ; ++iDst, ++iUsr) {
			pData-&gt;uname[i][iDst] = c[iUsr];
		}
		pData-&gt;uname[i][iDst] = '\0';
		DBGPRINTF(&quot;omusrmsg: send to user '%s'\n&quot;, pData-&gt;uname[i]);
		if(iUsr &lt; len &amp;&amp; c[iUsr] != ',') {
			LogError(0, RS_RET_ERR, &quot;user name '%s...' too long - &quot;
				&quot;ignored&quot;, pData-&gt;uname[i]);
			--i;
			++iUsr;
			while(iUsr &lt; len &amp;&amp; c[iUsr] != ',')
				++iUsr; /* skip to next name */
		} else if(iDst == 0) {
			LogError(0, RS_RET_ERR, &quot;no user name given - &quot;
				&quot;ignored&quot;);
			--i;
			++iUsr;
			while(iUsr &lt; len &amp;&amp; c[iUsr] != ',')
				++iUsr; /* skip to next name */
		}
		if(iUsr &lt; len) {
			++iUsr; /* skip &quot;,&quot; */
			while(iUsr &lt; len &amp;&amp; isspace(c[iUsr]))
				++iUsr; /* skip whitespace */
		}
	}
	if(i == MAXUNAMES &amp;&amp; iUsr != len) {
		LogError(0, RS_RET_ERR, &quot;omusrmsg supports only up to %d &quot;
			&quot;user names in a single action - all others have been ignored&quot;,
			MAXUNAMES);
	}
}


static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;bIsWall = 0;
	pData-&gt;tplName = NULL;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	CODE_STD_STRING_REQUESTnewActInst(1)
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;users&quot;)) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;*&quot;, 1)) {
				pData-&gt;bIsWall = 1;
			} else {
				populateUsers(pData, pvals[i].val.d.estr);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf(&quot;omusrmsg: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	if(pData-&gt;tplName == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0,
			(uchar*) strdup(pData-&gt;bIsWall ? &quot; WallFmt&quot; : &quot; StdUsrMsgFmt&quot;),
			OMSR_NO_RQD_TPL_OPTS));
	} else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0,
			(uchar*) strdup((char*) pData-&gt;tplName),
			OMSR_NO_RQD_TPL_OPTS));
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINparseSelectorAct
	es_str_t *usrs;
	int bHadWarning;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	bHadWarning = 0;
	if(!strncmp((char*) p, &quot;:omusrmsg:&quot;, sizeof(&quot;:omusrmsg:&quot;) - 1)) {
		p += sizeof(&quot;:omusrmsg:&quot;) - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	} else {
		if(!*p || !((*p &gt;= 'a' &amp;&amp; *p &lt;= 'z') || (*p &gt;= 'A' &amp;&amp; *p &lt;= 'Z')
	   || (*p &gt;= '0' &amp;&amp; *p &lt;= '9') || *p == '_' || *p == '.' || *p == '*')) {
			ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
		} else {
			LogMsg(0, RS_RET_OUTDATED_STMT, LOG_WARNING,
				&quot;action '%s' treated as ':omusrmsg:%s' - please &quot;
				&quot;use ':omusrmsg:%s' syntax instead, '%s' will &quot;
				&quot;not be supported in the future&quot;,
				p, p, p, p);
			bHadWarning = 1;
		}
	}

	CHKiRet(createInstance(&amp;pData));

	if(*p == '*') { /* wall */
		dbgprintf(&quot;write-all&quot;);
		++p; /* eat '*' */
		pData-&gt;bIsWall = 1; /* write to all users */
		CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, (uchar*) &quot; WallFmt&quot;));
	} else {
		/* everything else is currently treated as a user name */
		usrs = es_newStr(128);
		while(*p &amp;&amp; *p != ';') {
			es_addChar(&amp;usrs, *p);
			++p;
		}
		populateUsers(pData, usrs);
		es_deleteStr(usrs);
		if((iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, (uchar*)&quot; StdUsrMsgFmt&quot;))
			!= RS_RET_OK)
			goto finalize_it;
	}
	if(iRet == RS_RET_OK &amp;&amp; bHadWarning)
		iRet = RS_RET_OK_WARN;
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit(UsrMsg)
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
ENDmodInit

/* vim:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lookup.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* lookup.c
 * Support for lookup tables in RainerScript.
 *
 * Copyright 2013-2018 Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *		 http://www.apache.org/licenses/LICENSE-2.0
 *		 -or-
 *		 see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;json.h&gt;
#include &lt;assert.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;lookup.h&quot;
#include &quot;msg.h&quot;
#include &quot;rsconf.h&quot;
#include &quot;dirty.h&quot;
#include &quot;unicode-helper.h&quot;

PRAGMA_IGNORE_Wdeprecated_declarations
/* definitions for objects we access */
DEFobjStaticHelpers
DEFobjCurrIf(glbl)

/* forward definitions */
static rsRetVal lookupReadFile(lookup_t *pThis, const uchar* name, const uchar* filename);
static void lookupDestruct(lookup_t *pThis);

/* static data */
<A NAME="0"></A>/* tables for interfacing with the v6 config system (as far as we need to) */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;name&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3645-0.html#0',2,'match3645-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;file&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
	{ &quot;reloadOnHUP&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};</B></FONT>

/* internal data-types */
typedef struct uint32_index_val_s {
	uint32_t index;
	uchar *val;
} uint32_index_val_t;

const char * reloader_prefix = &quot;lkp_tbl_reloader:&quot;;

static void *
lookupTableReloader(void *self);

static void
lookupStopReloader(lookup_ref_t *pThis);

/* create a new lookup table object AND include it in our list of
 * lookup tables.
 */
static rsRetVal
lookupNew(lookup_ref_t **ppThis)
{
	lookup_ref_t *pThis = NULL;
	lookup_t *t = NULL;
	int initialized = 0;
	DEFiRet;

	CHKmalloc(pThis = calloc(1, sizeof(lookup_ref_t)));
	CHKmalloc(t = calloc(1, sizeof(lookup_t)));
	CHKiConcCtrl(pthread_rwlock_init(&amp;pThis-&gt;rwlock, NULL));
	initialized++; /*1*/
	CHKiConcCtrl(pthread_mutex_init(&amp;pThis-&gt;reloader_mut, NULL));
	initialized++; /*2*/
	CHKiConcCtrl(pthread_cond_init(&amp;pThis-&gt;run_reloader, NULL));
	initialized++; /*3*/
	CHKiConcCtrl(pthread_attr_init(&amp;pThis-&gt;reloader_thd_attr));
	initialized++; /*4*/
	pThis-&gt;do_reload = pThis-&gt;do_stop = 0;
	pThis-&gt;reload_on_hup = 1; /*DO reload on HUP (default)*/
	CHKiConcCtrl(pthread_create(&amp;pThis-&gt;reloader, &amp;pThis-&gt;reloader_thd_attr,
		lookupTableReloader, pThis));
	initialized++; /*5*/

	pThis-&gt;next = NULL;
	if(loadConf-&gt;lu_tabs.root == NULL) {
		loadConf-&gt;lu_tabs.root = pThis;
	} else {
		loadConf-&gt;lu_tabs.last-&gt;next = pThis;
	}
	loadConf-&gt;lu_tabs.last = pThis;

	pThis-&gt;self = t;

	*ppThis = pThis;
finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(errno, iRet, &quot;a lookup table could not be initialized: &quot;
			&quot;failed at init-step %d (please enable debug logs for details)&quot;,
			initialized);
		/* Can not happen with current code, but might occur in the future when
		 * an error-condition as added after step 5. If we leave it in, Coverity
		 * scan complains. So we comment it out but do not remove the code.
		 * Triggered by CID 185426
		if (initialized &gt; 4) lookupStopReloader(pThis);
		*/
		if (initialized &gt; 3) pthread_attr_destroy(&amp;pThis-&gt;reloader_thd_attr);
		if (initialized &gt; 2) pthread_cond_destroy(&amp;pThis-&gt;run_reloader);
		if (initialized &gt; 1) pthread_mutex_destroy(&amp;pThis-&gt;reloader_mut);
		if (initialized &gt; 0) pthread_rwlock_destroy(&amp;pThis-&gt;rwlock);
		free(t);
		free(pThis);
	}
	RETiRet;
}

/*must be called with reloader_mut acquired*/
static void ATTR_NONNULL()
freeStubValueForReloadFailure(lookup_ref_t *const pThis)
{
	if (pThis-&gt;stub_value_for_reload_failure != NULL) {
		free(pThis-&gt;stub_value_for_reload_failure);
		pThis-&gt;stub_value_for_reload_failure = NULL;
	}
}

static void
lookupStopReloader(lookup_ref_t *pThis) {
	pthread_mutex_lock(&amp;pThis-&gt;reloader_mut);
	freeStubValueForReloadFailure(pThis);
	pThis-&gt;do_reload = 0;
	pThis-&gt;do_stop = 1;
	pthread_cond_signal(&amp;pThis-&gt;run_reloader);
	pthread_mutex_unlock(&amp;pThis-&gt;reloader_mut);
	pthread_join(pThis-&gt;reloader, NULL);
}

static void
lookupRefDestruct(lookup_ref_t *pThis)
{
	lookupStopReloader(pThis);
	pthread_mutex_destroy(&amp;pThis-&gt;reloader_mut);
	pthread_cond_destroy(&amp;pThis-&gt;run_reloader);
	pthread_attr_destroy(&amp;pThis-&gt;reloader_thd_attr);

	pthread_rwlock_destroy(&amp;pThis-&gt;rwlock);
	lookupDestruct(pThis-&gt;self);
	free(pThis-&gt;name);
	free(pThis-&gt;filename);
	free(pThis);
}

static void
destructTable_str(lookup_t *pThis) {
	uint32_t i = 0;
	lookup_string_tab_entry_t *entries = pThis-&gt;table.str-&gt;entries;
	for (i = 0; i &lt; pThis-&gt;nmemb; i++) {
		free(entries[i].key);
	}
	free(entries);
	free(pThis-&gt;table.str);
}


static void
destructTable_arr(lookup_t *pThis) {
	free(pThis-&gt;table.arr-&gt;interned_val_refs);
	free(pThis-&gt;table.arr);
}

static void
destructTable_sparseArr(lookup_t *pThis) {
	free(pThis-&gt;table.sprsArr-&gt;entries);
	free(pThis-&gt;table.sprsArr);
}

static void
lookupDestruct(lookup_t *pThis) {
	uint32_t i;

	if (pThis == NULL) return;

	if (pThis-&gt;type == STRING_LOOKUP_TABLE) {
		destructTable_str(pThis);
	} else if (pThis-&gt;type == ARRAY_LOOKUP_TABLE) {
		destructTable_arr(pThis);
	} else if (pThis-&gt;type == SPARSE_ARRAY_LOOKUP_TABLE) {
		destructTable_sparseArr(pThis);
	} else if (pThis-&gt;type == STUBBED_LOOKUP_TABLE) {
		/*nothing to be done*/
	}

	for (i = 0; i &lt; pThis-&gt;interned_val_count; i++) {
		free(pThis-&gt;interned_vals[i]);
	}
	free(pThis-&gt;interned_vals);
	free(pThis-&gt;nomatch);
	free(pThis);
}

void
lookupInitCnf(lookup_tables_t *lu_tabs)
{
	lu_tabs-&gt;root = NULL;
	lu_tabs-&gt;last = NULL;
}

void
lookupDestroyCnf(void)
{
	lookup_ref_t *luref, *luref_next;
	for(luref = runConf-&gt;lu_tabs.root ; luref != NULL ; ) {
		luref_next = luref-&gt;next;
		lookupRefDestruct(luref);
		luref = luref_next;
	}
}

/* comparison function for qsort() */
static int
qs_arrcmp_strtab(const void *s1, const void *s2)
{
	return ustrcmp(((lookup_string_tab_entry_t*)s1)-&gt;key, ((lookup_string_tab_entry_t*)s2)-&gt;key);
}

static int
qs_arrcmp_ustrs(const void *s1, const void *s2)
{
	return ustrcmp(*(uchar**)s1, *(uchar**)s2);
}

static int
qs_arrcmp_uint32_index_val(const void *s1, const void *s2)
{
	uint32_t first_value = ((uint32_index_val_t*)s1)-&gt;index;
	uint32_t second_value = ((uint32_index_val_t*)s2)-&gt;index;
	if (first_value &lt; second_value) {
		return -1;
	}
	return first_value - second_value;
}

static int
qs_arrcmp_sprsArrtab(const void *s1, const void *s2)
{
	uint32_t first_value = ((lookup_sparseArray_tab_entry_t*)s1)-&gt;key;
	uint32_t second_value = ((lookup_sparseArray_tab_entry_t*)s2)-&gt;key;
	if (first_value &lt; second_value) {
		return -1;
	}
	return first_value - second_value;
}

/* comparison function for bsearch() and string array compare
 * this is for the string lookup table type
 */
static int
bs_arrcmp_strtab(const void *s1, const void *s2)
{
	return strcmp((char*)s1, (char*)((lookup_string_tab_entry_t*)s2)-&gt;key);
}

static int
bs_arrcmp_str(const void *s1, const void *s2)
{
	return ustrcmp((uchar*)s1, *(uchar**)s2);
}

static int
bs_arrcmp_sprsArrtab(const void *s1, const void *s2)
{
	uint32_t key = *(uint32_t*)s1;
	uint32_t array_member_value = ((lookup_sparseArray_tab_entry_t*)s2)-&gt;key;
	if (key &lt; array_member_value) {
		return -1;
	}
	return key - array_member_value;
}

static inline const char*
defaultVal(lookup_t *pThis) {
	return (pThis-&gt;nomatch == NULL) ? &quot;&quot; : (const char*) pThis-&gt;nomatch;
}

/* lookup_fn for different types of tables */
static es_str_t*
lookupKey_stub(lookup_t *pThis, lookup_key_t __attribute__((unused)) key) {
	return es_newStrFromCStr((char*) pThis-&gt;nomatch, ustrlen(pThis-&gt;nomatch));
}

static es_str_t*
lookupKey_str(lookup_t *pThis, lookup_key_t key) {
	lookup_string_tab_entry_t *entry;
	const char *r;
	if(pThis-&gt;nmemb == 0) {
		entry = NULL;
	} else {
		assert(pThis-&gt;table.str-&gt;entries);
		entry = bsearch(key.k_str, pThis-&gt;table.str-&gt;entries, pThis-&gt;nmemb,
			sizeof(lookup_string_tab_entry_t), bs_arrcmp_strtab);
	}
	if(entry == NULL) {
		r = defaultVal(pThis);
	} else {
		r = (const char*)entry-&gt;interned_val_ref;
	}
	return es_newStrFromCStr(r, strlen(r));
}

static es_str_t*
lookupKey_arr(lookup_t *pThis, lookup_key_t key) {
	const char *r;
	uint32_t uint_key = key.k_uint;
	if ((pThis-&gt;nmemb == 0) || (uint_key &lt; pThis-&gt;table.arr-&gt;first_key)) {
		r = defaultVal(pThis);
	} else {
		uint32_t idx = uint_key - pThis-&gt;table.arr-&gt;first_key;
		if (idx &gt;= pThis-&gt;nmemb) {
			r = defaultVal(pThis);
		} else {
		    r = (char*) pThis-&gt;table.arr-&gt;interned_val_refs[idx];
		}
	}

	return es_newStrFromCStr(r, strlen(r));
}

typedef int (comp_fn_t)(const void *s1, const void *s2);

static void *
bsearch_lte(const void *key, const void *base, size_t nmemb, size_t size, comp_fn_t *comp_fn)
{
	size_t l, u, idx;
	const void *p;
	int comparison;

	l = 0;
	u = nmemb;
	if (l == u) {
		return NULL;
	}
	while (l &lt; u) {
		idx = (l + u) / 2;
		p = (void *) (((const char *) base) + (idx * size));
		comparison = (*comp_fn)(key, p);
		if (comparison &lt; 0)
			u = idx;
		else if (comparison &gt; 0)
			l = idx + 1;
		else
			return (void *) p;
	}
	if (comparison &lt; 0) {
		if (idx == 0) {
			return NULL;
		}
		idx--;
	}
	return (void *) (((const char *) base) + ( idx * size));
}

static es_str_t*
lookupKey_sprsArr(lookup_t *pThis, lookup_key_t key) {
	lookup_sparseArray_tab_entry_t *entry;
	const char *r;
	if (pThis-&gt;nmemb == 0) {
		entry = NULL;
	} else {
		entry = bsearch_lte(&amp;key.k_uint, pThis-&gt;table.sprsArr-&gt;entries, pThis-&gt;nmemb,
			sizeof(lookup_sparseArray_tab_entry_t), bs_arrcmp_sprsArrtab);
	}

	if(entry == NULL) {
		r = defaultVal(pThis);
	} else {
		r = (const char*)entry-&gt;interned_val_ref;
	}
	return es_newStrFromCStr(r, strlen(r));
}

/* builders for different table-types */

#define NO_INDEX_ERROR(type, name)				\
	LogError(0, RS_RET_INVALID_VALUE, &quot;'%s' lookup table named: '%s' has record(s) without 'index' &quot;\
&quot;field&quot;, type, name); \
	ABORT_FINALIZE(RS_RET_INVALID_VALUE);

static rsRetVal
build_StringTable(lookup_t *pThis, struct json_object *jtab, const uchar* name) {
	uint32_t i;
	struct json_object *jrow, *jindex, *jvalue;
	uchar *value, *canonicalValueRef;
	DEFiRet;

	pThis-&gt;table.str = NULL;
	CHKmalloc(pThis-&gt;table.str = calloc(1, sizeof(lookup_string_tab_t)));
	if (pThis-&gt;nmemb &gt; 0) {
		CHKmalloc(pThis-&gt;table.str-&gt;entries = calloc(pThis-&gt;nmemb, sizeof(lookup_string_tab_entry_t)));

		for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
			jrow = json_object_array_get_idx(jtab, i);
			jindex = json_object_object_get(jrow, &quot;index&quot;);
			jvalue = json_object_object_get(jrow, &quot;value&quot;);
			if (jindex == NULL || json_object_is_type(jindex, json_type_null)) {
				NO_INDEX_ERROR(&quot;string&quot;, name);
			}
			CHKmalloc(pThis-&gt;table.str-&gt;entries[i].key = ustrdup((uchar*) json_object_get_string(jindex)));
			value = (uchar*) json_object_get_string(jvalue);
			uchar **found  = (uchar**) bsearch(value, pThis-&gt;interned_vals,
				pThis-&gt;interned_val_count, sizeof(uchar*), bs_arrcmp_str);
			if(found == NULL) {
				LogError(0, RS_RET_INTERNAL_ERROR, &quot;lookup.c:build_StringTable(): &quot;
					&quot;internal error, bsearch returned NULL for '%s'&quot;, value);
				ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
			}
			// I give up, I see no way to remove false positive -- rgerhards, 2017-10-24
			#ifndef __clang_analyzer__
			canonicalValueRef = *found;
			if(canonicalValueRef == NULL) {
				LogError(0, RS_RET_INTERNAL_ERROR, &quot;lookup.c:build_StringTable(): &quot;
					&quot;internal error, canonicalValueRef returned from bsearch &quot;
					&quot;is NULL for '%s'&quot;, value);
				ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
			}
			pThis-&gt;table.str-&gt;entries[i].interned_val_ref = canonicalValueRef;
			#endif
		}
		qsort(pThis-&gt;table.str-&gt;entries, pThis-&gt;nmemb, sizeof(lookup_string_tab_entry_t), qs_arrcmp_strtab);
	}

	pThis-&gt;lookup = lookupKey_str;
	pThis-&gt;key_type = LOOKUP_KEY_TYPE_STRING;
finalize_it:
	RETiRet;
}

static rsRetVal
build_ArrayTable(lookup_t *pThis, struct json_object *jtab, const uchar *name) {
	uint32_t i;
	struct json_object *jrow, *jindex, *jvalue;
	uchar *canonicalValueRef;
	uint32_t prev_index, _index;
	uint8_t prev_index_set;
	uint32_index_val_t *indexes = NULL;
	DEFiRet;

	prev_index_set = 0;

	pThis-&gt;table.arr = NULL;
	CHKmalloc(pThis-&gt;table.arr = calloc(1, sizeof(lookup_array_tab_t)));
	if (pThis-&gt;nmemb &gt; 0) {
		CHKmalloc(indexes = calloc(pThis-&gt;nmemb, sizeof(uint32_index_val_t)));
		CHKmalloc(pThis-&gt;table.arr-&gt;interned_val_refs = calloc(pThis-&gt;nmemb, sizeof(uchar*)));

		for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
			jrow = json_object_array_get_idx(jtab, i);
			jindex = json_object_object_get(jrow, &quot;index&quot;);
			jvalue = json_object_object_get(jrow, &quot;value&quot;);
			if (jindex == NULL || json_object_is_type(jindex, json_type_null)) {
				NO_INDEX_ERROR(&quot;array&quot;, name);
			}
			indexes[i].index = (uint32_t) json_object_get_int(jindex);
			indexes[i].val = (uchar*) json_object_get_string(jvalue);
		}
		qsort(indexes, pThis-&gt;nmemb, sizeof(uint32_index_val_t), qs_arrcmp_uint32_index_val);
		for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
			_index = indexes[i].index;
			if (prev_index_set == 0) {
				prev_index = _index;
				prev_index_set = 1;
				pThis-&gt;table.arr-&gt;first_key = _index;
			} else {
				if (_index != ++prev_index) {
					LogError(0, RS_RET_INVALID_VALUE, &quot;'array' lookup table name: '%s' &quot;
					&quot;has non-contiguous members between index '%d' and '%d'&quot;,
									name, prev_index, _index);
					ABORT_FINALIZE(RS_RET_INVALID_VALUE);
				}
			}
			uchar *const *const canonicalValueRef_ptr = bsearch(indexes[i].val, pThis-&gt;interned_vals,
				pThis-&gt;interned_val_count, sizeof(uchar*), bs_arrcmp_str);
			if(canonicalValueRef_ptr == NULL) {
				LogError(0, RS_RET_ERR, &quot;BUG: canonicalValueRef not found in &quot;
					&quot;build_ArrayTable(), %s:%d&quot;, __FILE__, __LINE__);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			canonicalValueRef = *canonicalValueRef_ptr;
			assert(canonicalValueRef != NULL);
			pThis-&gt;table.arr-&gt;interned_val_refs[i] = canonicalValueRef;
		}
	}

	pThis-&gt;lookup = lookupKey_arr;
	pThis-&gt;key_type = LOOKUP_KEY_TYPE_UINT;

finalize_it:
	free(indexes);
	RETiRet;
}

static rsRetVal
build_SparseArrayTable(lookup_t *pThis, struct json_object *jtab, const uchar* name) {
	uint32_t i;
	struct json_object *jrow, *jindex, *jvalue;
	uchar *value, *canonicalValueRef;
	DEFiRet;

	pThis-&gt;table.str = NULL;
	CHKmalloc(pThis-&gt;table.sprsArr = calloc(1, sizeof(lookup_sparseArray_tab_t)));
	if (pThis-&gt;nmemb &gt; 0) {
		CHKmalloc(pThis-&gt;table.sprsArr-&gt;entries = calloc(pThis-&gt;nmemb, sizeof(lookup_sparseArray_tab_entry_t)));

		for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
			jrow = json_object_array_get_idx(jtab, i);
			jindex = json_object_object_get(jrow, &quot;index&quot;);
			jvalue = json_object_object_get(jrow, &quot;value&quot;);
			if (jindex == NULL || json_object_is_type(jindex, json_type_null)) {
				NO_INDEX_ERROR(&quot;sparseArray&quot;, name);
			}
			pThis-&gt;table.sprsArr-&gt;entries[i].key = (uint32_t) json_object_get_int(jindex);
			value = (uchar*) json_object_get_string(jvalue);
			uchar *const *const canonicalValueRef_ptr = bsearch(value, pThis-&gt;interned_vals,
				pThis-&gt;interned_val_count, sizeof(uchar*), bs_arrcmp_str);
			if(canonicalValueRef_ptr == NULL) {
				LogError(0, RS_RET_ERR, &quot;BUG: canonicalValueRef not found in &quot;
					&quot;build_SparseArrayTable(), %s:%d&quot;, __FILE__, __LINE__);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			canonicalValueRef = *canonicalValueRef_ptr;
			assert(canonicalValueRef != NULL);
			pThis-&gt;table.sprsArr-&gt;entries[i].interned_val_ref = canonicalValueRef;
		}
		qsort(pThis-&gt;table.sprsArr-&gt;entries, pThis-&gt;nmemb, sizeof(lookup_sparseArray_tab_entry_t),
				qs_arrcmp_sprsArrtab);
	}

	pThis-&gt;lookup = lookupKey_sprsArr;
	pThis-&gt;key_type = LOOKUP_KEY_TYPE_UINT;

finalize_it:
	RETiRet;
}

static rsRetVal
lookupBuildStubbedTable(lookup_t *pThis, const uchar* stub_val) {
	DEFiRet;

	CHKmalloc(pThis-&gt;nomatch = ustrdup(stub_val));
	pThis-&gt;lookup = lookupKey_stub;
	pThis-&gt;type = STUBBED_LOOKUP_TABLE;
	pThis-&gt;key_type = LOOKUP_KEY_TYPE_NONE;

finalize_it:
	RETiRet;
}

static rsRetVal
lookupBuildTable_v1(lookup_t *pThis, struct json_object *jroot, const uchar* name) {
	struct json_object *jnomatch, *jtype, *jtab;
	struct json_object *jrow, *jvalue;
	const char *table_type, *nomatch_value;
	const uchar **all_values;
	const uchar *curr, *prev;
	uint32_t i, j;
	uint32_t uniq_values;

	DEFiRet;
	all_values = NULL;

	jnomatch = json_object_object_get(jroot, &quot;nomatch&quot;);
	jtype = json_object_object_get(jroot, &quot;type&quot;);
	jtab = json_object_object_get(jroot, &quot;table&quot;);
	if (jtab == NULL || !json_object_is_type(jtab, json_type_array)) {
		LogError(0, RS_RET_INVALID_VALUE, &quot;lookup table named: '%s' has invalid table definition&quot;, name);
		ABORT_FINALIZE(RS_RET_INVALID_VALUE);
	}
	pThis-&gt;nmemb = json_object_array_length(jtab);
	table_type = json_object_get_string(jtype);
	if (table_type == NULL) {
		table_type = &quot;string&quot;;
	}

	CHKmalloc(all_values = malloc(pThis-&gt;nmemb * sizeof(uchar*)));

	/* before actual table can be loaded, prepare all-value list and remove duplicates*/
	for(i = 0; i &lt; pThis-&gt;nmemb; i++) {
		jrow = json_object_array_get_idx(jtab, i);
		jvalue = json_object_object_get(jrow, &quot;value&quot;);
		if (jvalue == NULL || json_object_is_type(jvalue, json_type_null)) {
			LogError(0, RS_RET_INVALID_VALUE, &quot;'%s' lookup table named: '%s' has record(s) &quot;
			&quot;without 'value' field&quot;, table_type, name);
			ABORT_FINALIZE(RS_RET_INVALID_VALUE);
		}
		all_values[i] = (const uchar*) json_object_get_string(jvalue);
	}
	qsort(all_values, pThis-&gt;nmemb, sizeof(uchar*), qs_arrcmp_ustrs);
	uniq_values = 1;
	for(i = 1; i &lt; pThis-&gt;nmemb; i++) {
		curr = all_values[i];
		prev = all_values[i - 1];
		if (ustrcmp(prev, curr) != 0) {
			uniq_values++;
		}
	}

	if (pThis-&gt;nmemb &gt; 0)  {
		CHKmalloc(pThis-&gt;interned_vals = malloc(uniq_values * sizeof(uchar*)));
		j = 0;
		CHKmalloc(pThis-&gt;interned_vals[j++] = ustrdup(all_values[0]));
		for(i = 1; i &lt; pThis-&gt;nmemb ; ++i) {
			curr = all_values[i];
			prev = all_values[i - 1];
			if (ustrcmp(prev, curr) != 0) {
				CHKmalloc(pThis-&gt;interned_vals[j++] = ustrdup(all_values[i]));
			}
		}
		pThis-&gt;interned_val_count = uniq_values;
	}
	/* uniq values captured (sorted) */

	nomatch_value = json_object_get_string(jnomatch);
	if (nomatch_value != NULL) {
		CHKmalloc(pThis-&gt;nomatch = (uchar*) strdup(nomatch_value));
	}

	if (strcmp(table_type, &quot;array&quot;) == 0) {
		pThis-&gt;type = ARRAY_LOOKUP_TABLE;
		CHKiRet(build_ArrayTable(pThis, jtab, name));
	} else if (strcmp(table_type, &quot;sparseArray&quot;) == 0) {
		pThis-&gt;type = SPARSE_ARRAY_LOOKUP_TABLE;
		CHKiRet(build_SparseArrayTable(pThis, jtab, name));
	} else if (strcmp(table_type, &quot;string&quot;) == 0) {
		pThis-&gt;type = STRING_LOOKUP_TABLE;
		CHKiRet(build_StringTable(pThis, jtab, name));
	} else {
		LogError(0, RS_RET_INVALID_VALUE, &quot;lookup table named: '%s' uses unupported &quot;
				&quot;type: '%s'&quot;, name, table_type);
		ABORT_FINALIZE(RS_RET_INVALID_VALUE);
	}
finalize_it:
	if (all_values != NULL) free(all_values);
	RETiRet;
}

static rsRetVal
lookupBuildTable(lookup_t *pThis, struct json_object *jroot, const uchar* name)
{
	struct json_object *jversion;
	int version = 1;

	DEFiRet;

	jversion = json_object_object_get(jroot, &quot;version&quot;);
	if (jversion != NULL &amp;&amp; !json_object_is_type(jversion, json_type_null)) {
		version = json_object_get_int(jversion);
	} else {
		LogError(0, RS_RET_INVALID_VALUE, &quot;lookup table named: '%s' doesn't specify version &quot;
		&quot;(will use default value: %d)&quot;, name, version);
	}
	if (version == 1) {
		CHKiRet(lookupBuildTable_v1(pThis, jroot, name));
	} else {
		LogError(0, RS_RET_INVALID_VALUE, &quot;lookup table named: '%s' uses unsupported &quot;
				&quot;version: %d&quot;, name, version);
		ABORT_FINALIZE(RS_RET_INVALID_VALUE);
	}

finalize_it:
	RETiRet;
}


/* find a lookup table. This is a naive O(n) algo, but this really
 * doesn't matter as it is called only a few times during config
 * load. The function returns either a pointer to the requested
 * table or NULL, if not found.
 */
lookup_ref_t * ATTR_NONNULL()
lookupFindTable(uchar *name)
{
	lookup_ref_t *curr;

	for(curr = loadConf-&gt;lu_tabs.root ; curr != NULL ; curr = curr-&gt;next) {
		if(!ustrcmp(curr-&gt;name, name))
			break;
	}
	return curr;
}


/* this reloads a lookup table. This is done while the engine is running,
 * as such the function must ensure proper locking and proper order of
 * operations (so that nothing can interfere). If the table cannot be loaded,
 * the old table is continued to be used.
 */
static rsRetVal
lookupReloadOrStub(lookup_ref_t *pThis, const uchar* stub_val) {
	lookup_t *newlu, *oldlu; /* dummy to be able to use support functions without
								affecting current settings. */
	DEFiRet;

	oldlu = pThis-&gt;self;
	newlu = NULL;

	DBGPRINTF(&quot;reload requested for lookup table '%s'\n&quot;, pThis-&gt;name);
	CHKmalloc(newlu = calloc(1, sizeof(lookup_t)));
	if (stub_val == NULL) {
		CHKiRet(lookupReadFile(newlu, pThis-&gt;name, pThis-&gt;filename));
	} else {
		CHKiRet(lookupBuildStubbedTable(newlu, stub_val));
	}
	/* all went well, copy over data members */
	pthread_rwlock_wrlock(&amp;pThis-&gt;rwlock);
	pThis-&gt;self = newlu;
	pthread_rwlock_unlock(&amp;pThis-&gt;rwlock);
finalize_it:
	if (iRet != RS_RET_OK) {
		if (stub_val == NULL) {
			LogError(0, RS_RET_INTERNAL_ERROR,
					&quot;lookup table '%s' could not be reloaded from file '%s'&quot;,
					pThis-&gt;name, pThis-&gt;filename);
		} else {
			LogError(0, RS_RET_INTERNAL_ERROR,
					&quot;lookup table '%s' could not be stubbed with value '%s'&quot;,
					pThis-&gt;name, stub_val);
		}
		lookupDestruct(newlu);
	} else {
		if (stub_val == NULL) {
			LogMsg(0, RS_RET_OK, LOG_INFO, &quot;lookup table '%s' reloaded from file '%s'&quot;,
					pThis-&gt;name, pThis-&gt;filename);
		} else {
			LogError(0, RS_RET_OK, &quot;lookup table '%s' stubbed with value '%s'&quot;,
					pThis-&gt;name, stub_val);
		}
		lookupDestruct(oldlu);
	}
	RETiRet;
}

static rsRetVal
lookupDoStub(lookup_ref_t *pThis, const uchar* stub_val)
{
	int already_stubbed = 0;
	DEFiRet;
	pthread_rwlock_rdlock(&amp;pThis-&gt;rwlock);
	if (pThis-&gt;self-&gt;type == STUBBED_LOOKUP_TABLE &amp;&amp;
		ustrcmp(pThis-&gt;self-&gt;nomatch, stub_val) == 0)
		already_stubbed = 1;
	pthread_rwlock_unlock(&amp;pThis-&gt;rwlock);
	if (! already_stubbed) {
		LogError(0, RS_RET_OK, &quot;stubbing lookup table '%s' with value '%s'&quot;,
			pThis-&gt;name, stub_val);
		CHKiRet(lookupReloadOrStub(pThis, stub_val));
	} else {
		LogError(0, RS_RET_OK, &quot;lookup table '%s' is already stubbed with value '%s'&quot;,
			pThis-&gt;name, stub_val);
	}
finalize_it:
	RETiRet;
}

static uint8_t
lookupIsReloadPending(lookup_ref_t *pThis) {
	uint8_t reload_pending;
	pthread_mutex_lock(&amp;pThis-&gt;reloader_mut);
	reload_pending = pThis-&gt;do_reload;
	pthread_mutex_unlock(&amp;pThis-&gt;reloader_mut);
	return reload_pending;
}

/* note: stub_val_if_reload_fails may or may not be NULL */
rsRetVal ATTR_NONNULL(1)
lookupReload(lookup_ref_t *const pThis, const uchar *const stub_val_if_reload_fails)
{
	uint8_t locked = 0;
	int lock_errno = 0;
	DEFiRet;
	assert(pThis != NULL);
	if ((lock_errno = pthread_mutex_trylock(&amp;pThis-&gt;reloader_mut)) == 0) {
		locked = 1;
		/*so it doesn't leak memory in situation where 2 reload requests are issued back to back*/
		freeStubValueForReloadFailure(pThis);
		if (stub_val_if_reload_fails != NULL) {
			CHKmalloc(pThis-&gt;stub_value_for_reload_failure = ustrdup(stub_val_if_reload_fails));
		}
		pThis-&gt;do_reload = 1;
		pthread_cond_signal(&amp;pThis-&gt;run_reloader);
	} else {
		LogError(lock_errno, RS_RET_INTERNAL_ERROR, &quot;attempt to trigger &quot;
			&quot;reload of lookup table '%s' failed (not stubbing)&quot;, pThis-&gt;name);
		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
		/* we can choose to stub the table here, but it'll hurt because
		   the table reloader may take time to complete the reload
		   and stubbing because of a concurrent reload message may
		   not be desirable (except in very tightly controled environments
		   where reload-triggering messages pushed are timed accurately
		   and an idempotency-filter is used to reject re-deliveries) */
	}
finalize_it:
	if (locked) {
		pthread_mutex_unlock(&amp;pThis-&gt;reloader_mut);
	}
	RETiRet;
}

static rsRetVal ATTR_NONNULL()
lookupDoReload(lookup_ref_t *pThis)
{
	DEFiRet;
	iRet = lookupReloadOrStub(pThis, NULL);
	if ((iRet != RS_RET_OK) &amp;&amp;
		(pThis-&gt;stub_value_for_reload_failure != NULL)) {
		iRet = lookupDoStub(pThis, pThis-&gt;stub_value_for_reload_failure);
	}
	freeStubValueForReloadFailure(pThis);
	RETiRet;
}

void *
lookupTableReloader(void *self)
{
	lookup_ref_t *pThis = (lookup_ref_t*) self;
	pthread_mutex_lock(&amp;pThis-&gt;reloader_mut);
	while(1) {
		if (pThis-&gt;do_stop) {
			break;
		} else if (pThis-&gt;do_reload) {
			pThis-&gt;do_reload = 0;
			lookupDoReload(pThis);
		} else {
			pthread_cond_wait(&amp;pThis-&gt;run_reloader, &amp;pThis-&gt;reloader_mut);
		}
	}
	pthread_mutex_unlock(&amp;pThis-&gt;reloader_mut);
	return NULL;
}

/* reload all lookup tables on HUP */
void
lookupDoHUP(void)
{
	lookup_ref_t *luref;
	for(luref = runConf-&gt;lu_tabs.root ; luref != NULL ; luref = luref-&gt;next) {
		if (luref-&gt;reload_on_hup) {
			lookupReload(luref, NULL);
		}
	}
}

uint
lookupPendingReloadCount(void)
{
	uint pending_reload_count = 0;
	lookup_ref_t *luref;
	for(luref = runConf-&gt;lu_tabs.root ; luref != NULL ; luref = luref-&gt;next) {
		if (lookupIsReloadPending(luref)) {
			pending_reload_count++;
		}
	}
	return pending_reload_count;
}


/* returns either a pointer to the value (read only!) or NULL
 * if either the key could not be found or an error occurred.
 * Note that an estr_t object is returned. The caller is
 * responsible for freeing it.
 */
es_str_t *
lookupKey(lookup_ref_t *pThis, lookup_key_t key)
{
	es_str_t *estr;
	lookup_t *t;
	pthread_rwlock_rdlock(&amp;pThis-&gt;rwlock);
	t = pThis-&gt;self;
	estr = t-&gt;lookup(t, key);
	pthread_rwlock_unlock(&amp;pThis-&gt;rwlock);
	return estr;
}


/* note: widely-deployed json_c 0.9 does NOT support incremental
 * parsing. In order to keep compatible with e.g. Ubuntu 12.04LTS,
 * we read the file into one big memory buffer and parse it at once.
 * While this is not very elegant, it will not pose any real issue
 * for &quot;reasonable&quot; lookup tables (and &quot;unreasonably&quot; large ones
 * will probably have other issues as well...).
 */
static rsRetVal ATTR_NONNULL()
lookupReadFile(lookup_t *const pThis, const uchar *const name, const uchar *const filename)
{
	struct json_tokener *tokener = NULL;
	struct json_object *json = NULL;
	char *iobuf = NULL;
	int fd = -1;
	ssize_t nread;
	struct stat sb;
	DEFiRet;


	if((fd = open((const char*) filename, O_RDONLY)) == -1) {
		LogError(errno, RS_RET_FILE_NOT_FOUND,
			&quot;lookup table file '%s' could not be opened&quot;, filename);
		ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
	}

	if(fstat(fd, &amp;sb) == -1) {
		LogError(errno, RS_RET_FILE_NOT_FOUND,
			&quot;lookup table file '%s' stat failed&quot;, filename);
		ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
	}

	CHKmalloc(iobuf = malloc(sb.st_size));

	tokener = json_tokener_new();
	nread = read(fd, iobuf, sb.st_size);
	if(nread != (ssize_t) sb.st_size) {
		LogError(errno, RS_RET_READ_ERR,
			&quot;lookup table file '%s' read error&quot;, filename);
		ABORT_FINALIZE(RS_RET_READ_ERR);
	}

	json = json_tokener_parse_ex(tokener, iobuf, sb.st_size);
	if(json == NULL) {
		LogError(0, RS_RET_JSON_PARSE_ERR,
			&quot;lookup table file '%s' json parsing error&quot;,
			filename);
		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}
	free(iobuf); /* early free to sever resources*/
	iobuf = NULL; /* make sure no double-free */

	/* got json object, now populate our own in-memory structure */
	CHKiRet(lookupBuildTable(pThis, json, name));

finalize_it:
	if (fd != -1) {
		close(fd);
	}
	free(iobuf);
	if(tokener != NULL)
		json_tokener_free(tokener);
	if(json != NULL)
		json_object_put(json);
	RETiRet;
}


rsRetVal
lookupTableDefProcessCnf(struct cnfobj *o)
{
	struct cnfparamvals *pvals;
	lookup_ref_t *lu;
	short i;
#ifdef HAVE_PTHREAD_SETNAME_NP
	char *reloader_thd_name = NULL;
	int thd_name_len = 0;
#endif
	DEFiRet;
	lu = NULL;

	pvals = nvlstGetParams(o-&gt;nvlst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	DBGPRINTF(&quot;lookupTableDefProcessCnf params:\n&quot;);
	cnfparamsPrint(&amp;modpblk, pvals);

	CHKiRet(lookupNew(&amp;lu));

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;file&quot;)) {
			CHKmalloc(lu-&gt;filename = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL));
		} else if(!strcmp(modpblk.descr[i].name, &quot;name&quot;)) {
			CHKmalloc(lu-&gt;name = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL));
		} else if(!strcmp(modpblk.descr[i].name, &quot;reloadOnHUP&quot;)) {
			lu-&gt;reload_on_hup = (pvals[i].val.d.n != 0);
		} else {
			dbgprintf(&quot;lookup_table: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, modpblk.descr[i].name);
		}
	}
#ifdef HAVE_PTHREAD_SETNAME_NP
	thd_name_len = ustrlen(lu-&gt;name) + strlen(reloader_prefix) + 1;
	CHKmalloc(reloader_thd_name = malloc(thd_name_len));
	strcpy(reloader_thd_name, reloader_prefix);
	strcpy(reloader_thd_name + strlen(reloader_prefix), (char*) lu-&gt;name);
	reloader_thd_name[thd_name_len - 1] = '\0';
#if defined(__NetBSD__)
	pthread_setname_np(lu-&gt;reloader, &quot;%s&quot;, reloader_thd_name);
#elif defined(__APPLE__)
	pthread_setname_np(reloader_thd_name); // must check
#else
	pthread_setname_np(lu-&gt;reloader, reloader_thd_name);
#endif
#endif
	CHKiRet(lookupReadFile(lu-&gt;self, lu-&gt;name, lu-&gt;filename));
	LogMsg(0, RS_RET_OK, LOG_INFO, &quot;lookup table '%s' loaded from file '%s'&quot;,
		lu-&gt;name, lu-&gt;filename);

finalize_it:
#ifdef HAVE_PTHREAD_SETNAME_NP
	free(reloader_thd_name);
#endif
	cnfparamvalsDestruct(pvals, &amp;modpblk);
	if (iRet != RS_RET_OK) {
		if (lu != NULL) {
			lookupDestruct(lu-&gt;self);
			lu-&gt;self = NULL;
		}
	}
	RETiRet;
}

void
lookupClassExit(void)
{
	objRelease(glbl, CORE_COMPONENT);
}

rsRetVal
lookupClassInit(void)
{
	DEFiRet;
	CHKiRet(objGetObjInterface(&amp;obj));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
finalize_it:
	RETiRet;
}
</PRE>
</div>
  </div>
</body>
</html>
