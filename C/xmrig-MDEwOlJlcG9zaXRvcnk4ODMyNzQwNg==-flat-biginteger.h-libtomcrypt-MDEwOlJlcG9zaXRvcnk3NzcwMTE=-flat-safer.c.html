
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.178537511870846%, Tokens: 14</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-biginteger.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_BIGINTEGER_H_
2  #define RAPIDJSON_BIGINTEGER_H_
3  #include "../rapidjson.h"
4  #if defined(_MSC_VER) && !defined(__INTEL_COMPILER) && defined(_M_AMD64)
5  #include <intrin.h> 
6  #pragma intrinsic(_umul128)
7  #endif
8  RAPIDJSON_NAMESPACE_BEGIN
9  namespace internal {
10  class BigInteger {
11  public:
12      typedef uint64_t Type;
13      BigInteger(const BigInteger& rhs) : count_(rhs.count_) {
14          std::memcpy(digits_, rhs.digits_, count_ * sizeof(Type));
15      }
16      explicit BigInteger(uint64_t u) : count_(1) {
17          digits_[0] = u;
18      }
19      template<typename Ch>
20      BigInteger(const Ch* decimals, size_t length) : count_(1) {
21          RAPIDJSON_ASSERT(length > 0);
22          digits_[0] = 0;
23          size_t i = 0;
24          const size_t kMaxDigitPerIteration = 19;  
25          while (length >= kMaxDigitPerIteration) {
26              AppendDecimal64(decimals + i, decimals + i + kMaxDigitPerIteration);
27              length -= kMaxDigitPerIteration;
28              i += kMaxDigitPerIteration;
29          }
30          if (length > 0)
31              AppendDecimal64(decimals + i, decimals + i + length);
32      }
33      BigInteger& operator=(const BigInteger &rhs)
34      {
35          if (this != &rhs) {
36              count_ = rhs.count_;
37              std::memcpy(digits_, rhs.digits_, count_ * sizeof(Type));
38          }
39          return *this;
40      }
41      BigInteger& operator=(uint64_t u) {
42          digits_[0] = u;
43          count_ = 1;
44          return *this;
45      }
46      BigInteger& operator+=(uint64_t u) {
47          Type backup = digits_[0];
48          digits_[0] += u;
49          for (size_t i = 0; i < count_ - 1; i++) {
50              if (digits_[i] >= backup)
51                  return *this; 
52              backup = digits_[i + 1];
53              digits_[i + 1] += 1;
54          }
55          if (digits_[count_ - 1] < backup)
56              PushBack(1);
57          return *this;
58      }
59      BigInteger& operator*=(uint64_t u) {
60          if (u == 0) return *this = 0;
61          if (u == 1) return *this;
62          if (*this == 1) return *this = u;
63          uint64_t k = 0;
64          for (size_t i = 0; i < count_; i++) {
65              uint64_t hi;
66              digits_[i] = MulAdd64(digits_[i], u, k, &hi);
67              k = hi;
68          }
69          if (k > 0)
70              PushBack(k);
71          return *this;
72      }
73      BigInteger& operator*=(uint32_t u) {
74          if (u == 0) return *this = 0;
75          if (u == 1) return *this;
76          if (*this == 1) return *this = u;
77          uint64_t k = 0;
78          for (size_t i = 0; i < count_; i++) {
79              const uint64_t c = digits_[i] >> 32;
80              const uint64_t d = digits_[i] & 0xFFFFFFFF;
81              const uint64_t uc = u * c;
82              const uint64_t ud = u * d;
83              const uint64_t p0 = ud + k;
84              const uint64_t p1 = uc + (p0 >> 32);
85              digits_[i] = (p0 & 0xFFFFFFFF) | (p1 << 32);
86              k = p1 >> 32;
87          }
88          if (k > 0)
89              PushBack(k);
90          return *this;
91      }
92      BigInteger& operator<<=(size_t shift) {
93          if (IsZero() || shift == 0) return *this;
94          size_t offset = shift / kTypeBit;
95          size_t interShift = shift % kTypeBit;
96          RAPIDJSON_ASSERT(count_ + offset <= kCapacity);
97          if (interShift == 0) {
98              std::memmove(digits_ + offset, digits_, count_ * sizeof(Type));
99              count_ += offset;
100          }
101          else {
102              digits_[count_] = 0;
103              for (size_t i = count_; i > 0; i--)
104                  digits_[i + offset] = (digits_[i] << interShift) | (digits_[i - 1] >> (kTypeBit - interShift));
105              digits_[offset] = digits_[0] << interShift;
106              count_ += offset;
107              if (digits_[count_])
108                  count_++;
109          }
110          std::memset(digits_, 0, offset * sizeof(Type));
111          return *this;
112      }
113      bool operator==(const BigInteger& rhs) const {
114          return count_ == rhs.count_ && std::memcmp(digits_, rhs.digits_, count_ * sizeof(Type)) == 0;
115      }
116      bool operator==(const Type rhs) const {
117          return count_ == 1 && digits_[0] == rhs;
118      }
119      BigInteger& MultiplyPow5(unsigned exp) {
120          static const uint32_t kPow5[12] = {
121              5,
122              5 * 5,
123              5 * 5 * 5,
124              5 * 5 * 5 * 5,
125              5 * 5 * 5 * 5 * 5,
126              5 * 5 * 5 * 5 * 5 * 5,
127              5 * 5 * 5 * 5 * 5 * 5 * 5,
128              5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
129              5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
130              5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
131              5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
132              5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5
133          };
134          if (exp == 0) return *this;
135          for (; exp >= 27; exp -= 27) *this *= RAPIDJSON_UINT64_C2(0X6765C793, 0XFA10079D); 
136          for (; exp >= 13; exp -= 13) *this *= static_cast<uint32_t>(1220703125u); 
137          if (exp > 0)                 *this *= kPow5[exp - 1];
138          return *this;
139      }
140      bool Difference(const BigInteger& rhs, BigInteger* out) const {
141          int cmp = Compare(rhs);
142          RAPIDJSON_ASSERT(cmp != 0);
143          const BigInteger *a, *b;  
144          bool ret;
145          if (cmp < 0) { a = &rhs; b = this; ret = true; }
146          else         { a = this; b = &rhs; ret = false; }
147          Type borrow = 0;
148          for (size_t i = 0; i < a->count_; i++) {
149              Type d = a->digits_[i] - borrow;
150              if (i < b->count_)
151                  d -= b->digits_[i];
152              borrow = (d > a->digits_[i]) ? 1 : 0;
153              out->digits_[i] = d;
154              if (d != 0)
155                  out->count_ = i + 1;
156          }
157          return ret;
158      }
159      int Compare(const BigInteger& rhs) const {
160          if (count_ != rhs.count_)
161              return count_ < rhs.count_ ? -1 : 1;
162          for (size_t i = count_; i-- > 0;)
163              if (digits_[i] != rhs.digits_[i])
164                  return digits_[i] < rhs.digits_[i] ? -1 : 1;
165          return 0;
166      }
167      size_t GetCount() const { return count_; }
168      Type GetDigit(size_t index) const { RAPIDJSON_ASSERT(index < count_); return digits_[index]; }
169      bool IsZero() const { return count_ == 1 && digits_[0] == 0; }
170  private:
171      template<typename Ch>
172      void AppendDecimal64(const Ch* begin, const Ch* end) {
173          uint64_t u = ParseUint64(begin, end);
174          if (IsZero())
175              *this = u;
176          else {
177              unsigned exp = static_cast<unsigned>(end - begin);
178              (MultiplyPow5(exp) <<= exp) += u;   
179          }
180      }
181      void PushBack(Type digit) {
182          RAPIDJSON_ASSERT(count_ < kCapacity);
183          digits_[count_++] = digit;
184      }
185      template<typename Ch>
186      static uint64_t ParseUint64(const Ch* begin, const Ch* end) {
187          uint64_t r = 0;
188          for (const Ch* p = begin; p != end; ++p) {
189              RAPIDJSON_ASSERT(*p >= Ch('0') && *p <= Ch('9'));
190              r = r * 10u + static_cast<unsigned>(*p - Ch('0'));
191          }
192          return r;
193      }
194      static uint64_t MulAdd64(uint64_t a, uint64_t b, uint64_t k, uint64_t* outHigh) {
195  #if defined(_MSC_VER) && defined(_M_AMD64)
196          uint64_t low = _umul128(a, b, outHigh) + k;
197          if (low < k)
198              (*outHigh)++;
199          return low;
200  #elif (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)) && defined(__x86_64__)
201          __extension__ typedef unsigned __int128 uint128;
202          uint128 p = static_cast<uint128>(a) * static_cast<uint128>(b);
203          p += k;
204          *outHigh = static_cast<uint64_t>(p >> 64);
205          return static_cast<uint64_t>(p);
206  #else
<span onclick='openModal()' class='match'>207          const uint64_t a0 = a & 0xFFFFFFFF, a1 = a >> 32, b0 = b & 0xFFFFFFFF, b1 = b >> 32;
208          uint64_t x0 = a0 * b0, x1 = a0 * b1, x2 = a1 * b0, x3 = a1 * b1;
209          x1 += (x0 >> 32); 
210          x1 += x2;
211          if (x1 < x2)
212              x3 += (static_cast<uint64_t>(1) << 32);
213          uint64_t lo = (x1 << 32) + (x0 & 0xFFFFFFFF);
214          uint64_t hi = x3 + (x1 >> 32);
215          lo += k;
</span>216          if (lo < k)
217              hi++;
218          *outHigh = hi;
219          return lo;
220  #endif
221      }
222      static const size_t kBitCount = 3328;  
223      static const size_t kCapacity = kBitCount / sizeof(Type);
224      static const size_t kTypeBit = sizeof(Type) * 8;
225      Type digits_[kCapacity];
226      size_t count_;
227  };
228  } 
229  RAPIDJSON_NAMESPACE_END
230  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-safer.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SAFER
3  #define LTC_SAFER_TAB_C
4  #include "safer_tab.c"
5  const struct ltc_cipher_descriptor safer_k64_desc = {
6     "safer-k64",
7     8, 8, 8, 8, LTC_SAFER_K64_DEFAULT_NOF_ROUNDS,
8     &safer_k64_setup,
9     &safer_ecb_encrypt,
10     &safer_ecb_decrypt,
11     &safer_k64_test,
12     &safer_done,
13     &safer_64_keysize,
14     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15     },
16     safer_sk64_desc = {
17     "safer-sk64",
18     9, 8, 8, 8, LTC_SAFER_SK64_DEFAULT_NOF_ROUNDS,
19     &safer_sk64_setup,
20     &safer_ecb_encrypt,
21     &safer_ecb_decrypt,
22     &safer_sk64_test,
23     &safer_done,
24     &safer_64_keysize,
25     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
26     },
27     safer_k128_desc = {
28     "safer-k128",
29     10, 16, 16, 8, LTC_SAFER_K128_DEFAULT_NOF_ROUNDS,
30     &safer_k128_setup,
31     &safer_ecb_encrypt,
32     &safer_ecb_decrypt,
33     &safer_sk128_test,
34     &safer_done,
35     &safer_128_keysize,
36     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
37     },
38     safer_sk128_desc = {
39     "safer-sk128",
40     11, 16, 16, 8, LTC_SAFER_SK128_DEFAULT_NOF_ROUNDS,
41     &safer_sk128_setup,
42     &safer_ecb_encrypt,
43     &safer_ecb_decrypt,
44     &safer_sk128_test,
45     &safer_done,
46     &safer_128_keysize,
47     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
48     };
49  #define ROL8(x, n)   ((unsigned char)((unsigned int)(x) << (n)\
50                                       |(unsigned int)((x) & 0xFF) >> (8 - (n))))
51  #define EXP(x)       safer_ebox[(x) & 0xFF]
52  #define LOG(x)       safer_lbox[(x) & 0xFF]
53  #define PHT(x, y)    { y += x; x += y; }
54  #define IPHT(x, y)   { x -= y; y -= x; }
55  #ifdef LTC_CLEAN_STACK
56  static void s_safer_expand_userkey(const unsigned char *userkey_1,
57                                   const unsigned char *userkey_2,
58                                   unsigned int nof_rounds,
59                                   int strengthened,
60                                   safer_key_t key)
61  #else
62  static void safer_expand_userkey(const unsigned char *userkey_1,
63                                   const unsigned char *userkey_2,
64                                   unsigned int nof_rounds,
65                                   int strengthened,
66                                   safer_key_t key)
67  #endif
68  {   unsigned int i, j, k;
69      unsigned char ka[LTC_SAFER_BLOCK_LEN + 1];
70      unsigned char kb[LTC_SAFER_BLOCK_LEN + 1];
71      if (LTC_SAFER_MAX_NOF_ROUNDS < nof_rounds) {
72          nof_rounds = LTC_SAFER_MAX_NOF_ROUNDS;
73      }
74      *key++ = (unsigned char)nof_rounds;
75      ka[LTC_SAFER_BLOCK_LEN] = (unsigned char)0;
76      kb[LTC_SAFER_BLOCK_LEN] = (unsigned char)0;
77      k = 0;
78      for (j = 0; j < LTC_SAFER_BLOCK_LEN; j++) {
79          ka[j] = ROL8(userkey_1[j], 5);
80          ka[LTC_SAFER_BLOCK_LEN] ^= ka[j];
81          kb[j] = *key++ = userkey_2[j];
82          kb[LTC_SAFER_BLOCK_LEN] ^= kb[j];
83      }
84      for (i = 1; i <= nof_rounds; i++) {
85          for (j = 0; j < LTC_SAFER_BLOCK_LEN + 1; j++) {
86              ka[j] = ROL8(ka[j], 6);
87              kb[j] = ROL8(kb[j], 6);
88          }
89          if (strengthened) {
90             k = 2 * i - 1;
91             while (k >= (LTC_SAFER_BLOCK_LEN + 1)) { k -= LTC_SAFER_BLOCK_LEN + 1; }
92          }
93          for (j = 0; j < LTC_SAFER_BLOCK_LEN; j++) {
94              if (strengthened) {
95                  *key++ = (ka[k]
96                                  + safer_ebox[(int)safer_ebox[(int)((18 * i + j + 1)&0xFF)]]) & 0xFF;
97                  if (++k == (LTC_SAFER_BLOCK_LEN + 1)) { k = 0; }
98              } else {
99                  *key++ = (ka[j] + safer_ebox[(int)safer_ebox[(int)((18 * i + j + 1)&0xFF)]]) & 0xFF;
100              }
101          }
102          if (strengthened) {
103             k = 2 * i;
104             while (k >= (LTC_SAFER_BLOCK_LEN + 1)) { k -= LTC_SAFER_BLOCK_LEN + 1; }
105          }
106          for (j = 0; j < LTC_SAFER_BLOCK_LEN; j++) {
107              if (strengthened) {
108                  *key++ = (kb[k]
109                                  + safer_ebox[(int)safer_ebox[(int)((18 * i + j + 10)&0xFF)]]) & 0xFF;
110                  if (++k == (LTC_SAFER_BLOCK_LEN + 1)) { k = 0; }
111              } else {
112                  *key++ = (kb[j] + safer_ebox[(int)safer_ebox[(int)((18 * i + j + 10)&0xFF)]]) & 0xFF;
113              }
114          }
115      }
116  #ifdef LTC_CLEAN_STACK
117      zeromem(ka, sizeof(ka));
118      zeromem(kb, sizeof(kb));
119  #endif
120  }
121  #ifdef LTC_CLEAN_STACK
122  static void safer_expand_userkey(const unsigned char *userkey_1,
123                                   const unsigned char *userkey_2,
124                                   unsigned int nof_rounds,
125                                   int strengthened,
126                                   safer_key_t key)
127  {
128     s_safer_expand_userkey(userkey_1, userkey_2, nof_rounds, strengthened, key);
129     burn_stack(sizeof(unsigned char) * (2 * (LTC_SAFER_BLOCK_LEN + 1)) + sizeof(unsigned int)*2);
130  }
131  #endif
132  int safer_k64_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
133  {
134     LTC_ARGCHK(key != NULL);
135     LTC_ARGCHK(skey != NULL);
136     if (num_rounds != 0 && (num_rounds < 6 || num_rounds > LTC_SAFER_MAX_NOF_ROUNDS)) {
137        return CRYPT_INVALID_ROUNDS;
138     }
139     if (keylen != 8) {
140        return CRYPT_INVALID_KEYSIZE;
141     }
142     safer_expand_userkey(key, key, (unsigned int)(num_rounds != 0 ?num_rounds:LTC_SAFER_K64_DEFAULT_NOF_ROUNDS), 0, skey->safer.key);
143     return CRYPT_OK;
144  }
145  int safer_sk64_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
146  {
147     LTC_ARGCHK(key != NULL);
148     LTC_ARGCHK(skey != NULL);
149     if (num_rounds != 0 && (num_rounds < 6 || num_rounds > LTC_SAFER_MAX_NOF_ROUNDS)) {
150        return CRYPT_INVALID_ROUNDS;
151     }
152     if (keylen != 8) {
153        return CRYPT_INVALID_KEYSIZE;
154     }
155     safer_expand_userkey(key, key, (unsigned int)(num_rounds != 0 ?num_rounds:LTC_SAFER_SK64_DEFAULT_NOF_ROUNDS), 1, skey->safer.key);
156     return CRYPT_OK;
157  }
158  int safer_k128_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
159  {
160     LTC_ARGCHK(key != NULL);
161     LTC_ARGCHK(skey != NULL);
162     if (num_rounds != 0 && (num_rounds < 6 || num_rounds > LTC_SAFER_MAX_NOF_ROUNDS)) {
163        return CRYPT_INVALID_ROUNDS;
164     }
165     if (keylen != 16) {
166        return CRYPT_INVALID_KEYSIZE;
167     }
168     safer_expand_userkey(key, key+8, (unsigned int)(num_rounds != 0 ?num_rounds:LTC_SAFER_K128_DEFAULT_NOF_ROUNDS), 0, skey->safer.key);
169     return CRYPT_OK;
170  }
171  int safer_sk128_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
172  {
173     LTC_ARGCHK(key != NULL);
174     LTC_ARGCHK(skey != NULL);
175     if (num_rounds != 0 && (num_rounds < 6 || num_rounds > LTC_SAFER_MAX_NOF_ROUNDS)) {
176        return CRYPT_INVALID_ROUNDS;
177     }
178     if (keylen != 16) {
179        return CRYPT_INVALID_KEYSIZE;
180     }
181     safer_expand_userkey(key, key+8, (unsigned int)(num_rounds != 0?num_rounds:LTC_SAFER_SK128_DEFAULT_NOF_ROUNDS), 1, skey->safer.key);
182     return CRYPT_OK;
183  }
184  #ifdef LTC_CLEAN_STACK
185  static int s_safer_ecb_encrypt(const unsigned char *pt,
186                               unsigned char *ct,
187                               const symmetric_key *skey)
188  #else
189  int safer_ecb_encrypt(const unsigned char *pt,
190                               unsigned char *ct,
191                               const symmetric_key *skey)
192  #endif
193  {   unsigned char a, b, c, d, e, f, g, h, t;
194      unsigned int round;
195      const unsigned char *key;
196      LTC_ARGCHK(pt != NULL);
197      LTC_ARGCHK(ct != NULL);
198      LTC_ARGCHK(skey != NULL);
199      key = skey->safer.key;
200      a = pt[0]; b = pt[1]; c = pt[2]; d = pt[3];
201      e = pt[4]; f = pt[5]; g = pt[6]; h = pt[7];
202      if (LTC_SAFER_MAX_NOF_ROUNDS < (round = *key)) round = LTC_SAFER_MAX_NOF_ROUNDS;
203      while(round-- > 0)
204      {
205          a ^= *++key; b += *++key; c += *++key; d ^= *++key;
206          e ^= *++key; f += *++key; g += *++key; h ^= *++key;
207          a = EXP(a) + *++key; b = LOG(b) ^ *++key;
208          c = LOG(c) ^ *++key; d = EXP(d) + *++key;
209          e = EXP(e) + *++key; f = LOG(f) ^ *++key;
210          g = LOG(g) ^ *++key; h = EXP(h) + *++key;
211          PHT(a, b); PHT(c, d); PHT(e, f); PHT(g, h);
212          PHT(a, c); PHT(e, g); PHT(b, d); PHT(f, h);
213          PHT(a, e); PHT(b, f); PHT(c, g); PHT(d, h);
214          t = b; b = e; e = c; c = t; t = d; d = f; f = g; g = t;
215      }
216      a ^= *++key; b += *++key; c += *++key; d ^= *++key;
217      e ^= *++key; f += *++key; g += *++key; h ^= *++key;
218      ct[0] = a & 0xFF; ct[1] = b & 0xFF;
219      ct[2] = c & 0xFF; ct[3] = d & 0xFF;
220      ct[4] = e & 0xFF; ct[5] = f & 0xFF;
221      ct[6] = g & 0xFF; ct[7] = h & 0xFF;
222      return CRYPT_OK;
223  }
224  #ifdef LTC_CLEAN_STACK
225  int safer_ecb_encrypt(const unsigned char *pt,
226                               unsigned char *ct,
227                               const symmetric_key *skey)
228  {
229      int err = s_safer_ecb_encrypt(pt, ct, skey);
230      burn_stack(sizeof(unsigned char) * 9 + sizeof(unsigned int) + sizeof(unsigned char *));
231      return err;
232  }
233  #endif
234  #ifdef LTC_CLEAN_STACK
235  static int s_safer_ecb_decrypt(const unsigned char *ct,
236                               unsigned char *pt,
237                               const symmetric_key *skey)
238  #else
239  int safer_ecb_decrypt(const unsigned char *ct,
240                               unsigned char *pt,
241                               const symmetric_key *skey)
242  #endif
243  {   unsigned char a, b, c, d, e, f, g, h, t;
244      unsigned int round;
245      const unsigned char *key;
246      LTC_ARGCHK(ct != NULL);
247      LTC_ARGCHK(pt != NULL);
248      LTC_ARGCHK(skey != NULL);
<span onclick='openModal()' class='match'>249      key = skey->safer.key;
250      a = ct[0]; b = ct[1]; c = ct[2]; d = ct[3];
251      e = ct[4]; f = ct[5]; g = ct[6]; h = ct[7];
252      if (LTC_SAFER_MAX_NOF_ROUNDS < (round = *key)) round = LTC_SAFER_MAX_NOF_ROUNDS;
253      key += LTC_SAFER_BLOCK_LEN * (1 + 2 * round);
254      h ^= *key; g -= *--key; f -= *--key; e ^= *--key;
</span>255      d ^= *--key; c -= *--key; b -= *--key; a ^= *--key;
256      while (round--)
257      {
258          t = e; e = b; b = c; c = t; t = f; f = d; d = g; g = t;
259          IPHT(a, e); IPHT(b, f); IPHT(c, g); IPHT(d, h);
260          IPHT(a, c); IPHT(e, g); IPHT(b, d); IPHT(f, h);
261          IPHT(a, b); IPHT(c, d); IPHT(e, f); IPHT(g, h);
262          h -= *--key; g ^= *--key; f ^= *--key; e -= *--key;
263          d -= *--key; c ^= *--key; b ^= *--key; a -= *--key;
264          h = LOG(h) ^ *--key; g = EXP(g) - *--key;
265          f = EXP(f) - *--key; e = LOG(e) ^ *--key;
266          d = LOG(d) ^ *--key; c = EXP(c) - *--key;
267          b = EXP(b) - *--key; a = LOG(a) ^ *--key;
268      }
269      pt[0] = a & 0xFF; pt[1] = b & 0xFF;
270      pt[2] = c & 0xFF; pt[3] = d & 0xFF;
271      pt[4] = e & 0xFF; pt[5] = f & 0xFF;
272      pt[6] = g & 0xFF; pt[7] = h & 0xFF;
273      return CRYPT_OK;
274  }
275  #ifdef LTC_CLEAN_STACK
276  int safer_ecb_decrypt(const unsigned char *ct,
277                               unsigned char *pt,
278                               const symmetric_key *skey)
279  {
280      int err = s_safer_ecb_decrypt(ct, pt, skey);
281      burn_stack(sizeof(unsigned char) * 9 + sizeof(unsigned int) + sizeof(unsigned char *));
282      return err;
283  }
284  #endif
285  int safer_64_keysize(int *keysize)
286  {
287     LTC_ARGCHK(keysize != NULL);
288     if (*keysize < 8) {
289        return CRYPT_INVALID_KEYSIZE;
290     }
291     *keysize = 8;
292     return CRYPT_OK;
293  }
294  int safer_128_keysize(int *keysize)
295  {
296     LTC_ARGCHK(keysize != NULL);
297     if (*keysize < 16) {
298        return CRYPT_INVALID_KEYSIZE;
299     }
300     *keysize = 16;
301     return CRYPT_OK;
302  }
303  int safer_k64_test(void)
304  {
305   #ifndef LTC_TEST
306      return CRYPT_NOP;
307   #else
308     static const unsigned char k64_pt[]  = { 1, 2, 3, 4, 5, 6, 7, 8 },
309                                k64_key[] = { 8, 7, 6, 5, 4, 3, 2, 1 },
310                                k64_ct[]  = { 200, 242, 156, 221, 135, 120, 62, 217 };
311     symmetric_key skey;
312     unsigned char buf[2][8];
313     int err;
314     if ((err = safer_k64_setup(k64_key, 8, 6, &skey)) != CRYPT_OK) {
315        return err;
316     }
317     safer_ecb_encrypt(k64_pt, buf[0], &skey);
318     safer_ecb_decrypt(buf[0], buf[1], &skey);
319     if (compare_testvector(buf[0], 8, k64_ct, 8, "Safer K64 Encrypt", 0) != 0 ||
320           compare_testvector(buf[1], 8, k64_pt, 8, "Safer K64 Decrypt", 0) != 0) {
321        return CRYPT_FAIL_TESTVECTOR;
322     }
323     return CRYPT_OK;
324   #endif
325  }
326  int safer_sk64_test(void)
327  {
328   #ifndef LTC_TEST
329      return CRYPT_NOP;
330   #else
331     static const unsigned char sk64_pt[]  = { 1, 2, 3, 4, 5, 6, 7, 8 },
332                                sk64_key[] = { 1, 2, 3, 4, 5, 6, 7, 8 },
333                                sk64_ct[]  = { 95, 206, 155, 162, 5, 132, 56, 199 };
334     symmetric_key skey;
335     unsigned char buf[2][8];
336     int err, y;
337     if ((err = safer_sk64_setup(sk64_key, 8, 6, &skey)) != CRYPT_OK) {
338        return err;
339     }
340     safer_ecb_encrypt(sk64_pt, buf[0], &skey);
341     safer_ecb_decrypt(buf[0], buf[1], &skey);
342     if (compare_testvector(buf[0], 8, sk64_ct, 8, "Safer SK64 Encrypt", 0) != 0 ||
343           compare_testvector(buf[1], 8, sk64_pt, 8, "Safer SK64 Decrypt", 0) != 0) {
344        return CRYPT_FAIL_TESTVECTOR;
345     }
346     for (y = 0; y < 8; y++) buf[0][y] = 0;
347     for (y = 0; y < 1000; y++) safer_ecb_encrypt(buf[0], buf[0], &skey);
348     for (y = 0; y < 1000; y++) safer_ecb_decrypt(buf[0], buf[0], &skey);
349     for (y = 0; y < 8; y++) if (buf[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
350     return CRYPT_OK;
351    #endif
352  }
353  void safer_done(symmetric_key *skey)
354  {
355    LTC_UNUSED_PARAM(skey);
356  }
357  int safer_sk128_test(void)
358  {
359   #ifndef LTC_TEST
360      return CRYPT_NOP;
361   #else
362     static const unsigned char sk128_pt[]  = { 1, 2, 3, 4, 5, 6, 7, 8 },
363                                sk128_key[] = { 1, 2, 3, 4, 5, 6, 7, 8,
364                                                0, 0, 0, 0, 0, 0, 0, 0 },
365                                sk128_ct[]  = { 255, 120, 17, 228, 179, 167, 46, 113 };
366     symmetric_key skey;
367     unsigned char buf[2][8];
368     int err, y;
369     if ((err = safer_sk128_setup(sk128_key, 16, 0, &skey)) != CRYPT_OK) {
370        return err;
371     }
372     safer_ecb_encrypt(sk128_pt, buf[0], &skey);
373     safer_ecb_decrypt(buf[0], buf[1], &skey);
374     if (compare_testvector(buf[0], 8, sk128_ct, 8, "Safer SK128 Encrypt", 0) != 0 ||
375           compare_testvector(buf[1], 8, sk128_pt, 8, "Safer SK128 Decrypt", 0) != 0) {
376        return CRYPT_FAIL_TESTVECTOR;
377     }
378     for (y = 0; y < 8; y++) buf[0][y] = 0;
379     for (y = 0; y < 1000; y++) safer_ecb_encrypt(buf[0], buf[0], &skey);
380     for (y = 0; y < 1000; y++) safer_ecb_decrypt(buf[0], buf[0], &skey);
381     for (y = 0; y < 8; y++) if (buf[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
382     return CRYPT_OK;
383   #endif
384  }
385  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-biginteger.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-safer.c</div>
                <div class="column column_space"><pre><code>207          const uint64_t a0 = a & 0xFFFFFFFF, a1 = a >> 32, b0 = b & 0xFFFFFFFF, b1 = b >> 32;
208          uint64_t x0 = a0 * b0, x1 = a0 * b1, x2 = a1 * b0, x3 = a1 * b1;
209          x1 += (x0 >> 32); 
210          x1 += x2;
211          if (x1 < x2)
212              x3 += (static_cast<uint64_t>(1) << 32);
213          uint64_t lo = (x1 << 32) + (x0 & 0xFFFFFFFF);
214          uint64_t hi = x3 + (x1 >> 32);
215          lo += k;
</pre></code></div>
                <div class="column column_space"><pre><code>249      key = skey->safer.key;
250      a = ct[0]; b = ct[1]; c = ct[2]; d = ct[3];
251      e = ct[4]; f = ct[5]; g = ct[6]; h = ct[7];
252      if (LTC_SAFER_MAX_NOF_ROUNDS < (round = *key)) round = LTC_SAFER_MAX_NOF_ROUNDS;
253      key += LTC_SAFER_BLOCK_LEN * (1 + 2 * round);
254      h ^= *key; g -= *--key; f -= *--key; e ^= *--key;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    