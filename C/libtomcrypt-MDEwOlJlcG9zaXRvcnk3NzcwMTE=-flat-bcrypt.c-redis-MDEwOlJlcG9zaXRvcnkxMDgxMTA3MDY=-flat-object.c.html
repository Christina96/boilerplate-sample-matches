
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.2836970474967908%, Tokens: 10</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-bcrypt.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BCRYPT
3  #define BCRYPT_WORDS 8
4  #define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)
5  static int s_bcrypt_hash(const unsigned char *pt,
6                          const unsigned char *pass, unsigned long passlen,
7                          const unsigned char *salt, unsigned long saltlen,
8                                unsigned char *out,  unsigned long *outlen)
9  {
10     symmetric_key key;
11     int err, n;
12     ulong32 ct[BCRYPT_WORDS];
13     if ((err = blowfish_setup_with_data(pass, passlen, salt, saltlen, &key)) != CRYPT_OK) {
14        return err;
15     }
16     for (n = 0; n < 64; ++n) {
17        if ((err = blowfish_expand(salt, saltlen, NULL, 0, &key)) != CRYPT_OK) {
18           return err;
19        }
20        if ((err = blowfish_expand(pass, passlen, NULL, 0, &key)) != CRYPT_OK) {
21           return err;
22        }
23     }
24     for (n = 0; n < BCRYPT_WORDS; ++n) {
25        LOAD32H(ct[n], &pt[n*4]);
26     }
27     for (n = 0; n < 64; ++n) {
28        blowfish_enc(ct, BCRYPT_WORDS/2, &key);
29     }
30     for (n = 0; n < BCRYPT_WORDS; ++n) {
31        STORE32L(ct[n], &out[4 * n]);
32     }
33     *outlen = sizeof(ct);
34  #ifdef LTC_CLEAN_STACK
35     zeromem(&key, sizeof(key));
36     zeromem(ct, sizeof(ct));
37  #endif
38     return CRYPT_OK;
39  }
40  static int s_bcrypt_pbkdf_hash(const unsigned char *pass, unsigned long passlen,
41                           const unsigned char *salt, unsigned long saltlen,
42                                 unsigned char *out,  unsigned long *outlen)
43  {
44     const unsigned char pt[] = "OxychromaticBlowfishSwatDynamite";
45     return s_bcrypt_hash(pt, pass, passlen, salt, saltlen, out, outlen);
46  }
47  int bcrypt_pbkdf_openbsd(const          void *secret, unsigned long secret_len,
48                           const unsigned char *salt,   unsigned long salt_len,
49                                 unsigned int  rounds,            int hash_idx,
50                                 unsigned char *out,    unsigned long *outlen)
51  {
52     int err;
53     ulong32 blkno;
54     unsigned long left, itts, x, y, hashed_pass_len, step_size, steps, dest, used_rounds;
55     unsigned char *buf[3], blkbuf[4];
56     unsigned char *hashed_pass;
57     LTC_ARGCHK(secret != NULL);
58     LTC_ARGCHK(salt   != NULL);
59     LTC_ARGCHK(out    != NULL);
60     LTC_ARGCHK(outlen != NULL);
61     if ((secret_len == 0) || (salt_len == 0) || (*outlen == 0)) {
62        return CRYPT_INVALID_ARG;
63     }
64     if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
65        return err;
66     }
<span onclick='openModal()' class='match'>67     if (rounds == 0) {
68        used_rounds = LTC_BCRYPT_DEFAULT_ROUNDS;
69     } else {
70        used_rounds = rounds;
71     }
72     buf[0]      = XMALLOC(MAXBLOCKSIZE * 3);
73     hashed_pass = XMALLOC(MAXBLOCKSIZE);
</span>74     if (buf[0] == NULL || hashed_pass == NULL) {
75        if (hashed_pass != NULL) {
76           XFREE(hashed_pass);
77        }
78        if (buf[0] != NULL) {
79           XFREE(buf[0]);
80        }
81        return CRYPT_MEM;
82     }
83     buf[1] = buf[0] + MAXBLOCKSIZE;
84     buf[2] = buf[1] + MAXBLOCKSIZE;
85     step_size = (*outlen + BCRYPT_HASHSIZE - 1) / BCRYPT_HASHSIZE;
86     steps = (*outlen + step_size - 1) / step_size;
87     hashed_pass_len = MAXBLOCKSIZE;
88     if ((err = hash_memory(hash_idx, (unsigned char*)secret, secret_len, hashed_pass, &hashed_pass_len)) != CRYPT_OK) {
89        goto LBL_ERR;
90     }
91     left   = *outlen;
92     blkno  = 0;
93     while (left != 0) {
94         ++blkno;
95         STORE32H(blkno, blkbuf);
96         zeromem(buf[0], MAXBLOCKSIZE*2);
97         x = MAXBLOCKSIZE;
98         if ((err = hash_memory_multi(hash_idx, buf[0], &x,
99                                      salt, salt_len,
100                                      blkbuf, 4uL,
101                                      LTC_NULL)) != CRYPT_OK) {
102            goto LBL_ERR;
103         }
104         y = MAXBLOCKSIZE;
105         if ((err = s_bcrypt_pbkdf_hash(hashed_pass, hashed_pass_len, buf[0], x, buf[1], &y)) != CRYPT_OK) {
106            goto LBL_ERR;
107         }
108         XMEMCPY(buf[2], buf[1], y);
109         for (itts = 1; itts < used_rounds; ++itts) {
110            x = MAXBLOCKSIZE;
111            if ((err = hash_memory(hash_idx, buf[1], y, buf[0], &x)) != CRYPT_OK) {
112               goto LBL_ERR;
113            }
114            y = MAXBLOCKSIZE;
115            if ((err = s_bcrypt_pbkdf_hash(hashed_pass, hashed_pass_len, buf[0], x, buf[1], &y)) != CRYPT_OK) {
116               goto LBL_ERR;
117            }
118            for (x = 0; x < y; x++) {
119               buf[2][x] ^= buf[1][x];
120            }
121         }
122         steps = MIN(steps, left);
123         for (y = 0; y < steps; ++y) {
124            dest = y * step_size + (blkno - 1);
125            if (dest >= *outlen)
126               break;
127            out[dest] = buf[2][y];
128         }
129         left -= y;
130     }
131     err = CRYPT_OK;
132  LBL_ERR:
133  #ifdef LTC_CLEAN_STACK
134     zeromem(buf[0], MAXBLOCKSIZE*3);
135     zeromem(hashed_pass, MAXBLOCKSIZE);
136  #endif
137     XFREE(hashed_pass);
138     XFREE(buf[0]);
139     return err;
140  }
141  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-object.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/win32fixes.h"
3  #endif
4  #include "server.h"
5  #include <math.h>
6  #include <ctype.h>
7  #ifdef __CYGWIN__
8  #define strtold(a,b) ((PORT_LONGDOUBLE)strtod((a),(b)))
9  #endif
10  robj *createObject(int type, void *ptr) {
11      robj *o = zmalloc(sizeof(*o));
12      o->type = type;
13      o->encoding = OBJ_ENCODING_RAW;
14      o->ptr = ptr;
15      o->refcount = 1;
16      if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
17          o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;
18      } else {
19          o->lru = LRU_CLOCK();
20      }
21      return o;
22  }
23  robj *makeObjectShared(robj *o) {
24      serverAssert(o->refcount == 1);
25      o->refcount = OBJ_SHARED_REFCOUNT;
26      return o;
27  }
28  robj *createRawStringObject(const char *ptr, size_t len) {
29      return createObject(OBJ_STRING, sdsnewlen(ptr,len));
30  }
31  robj *createEmbeddedStringObject(const char *ptr, size_t len) {
32      robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);
33      struct sdshdr8 *sh = (void*)(o+1);
34      o->type = OBJ_STRING;
35      o->encoding = OBJ_ENCODING_EMBSTR;
36      o->ptr = sh+1;
37      o->refcount = 1;
<span onclick='openModal()' class='match'>38      if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
39          o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;
40      } else {
41          o->lru = LRU_CLOCK();
42      }
43      sh->len = len;
44      sh->alloc = len;
</span>45      sh->flags = SDS_TYPE_8;
46      if (ptr == SDS_NOINIT)
47          sh->buf[len] = '\0';
48      else if (ptr) {
49          memcpy(sh->buf,ptr,len);
50          sh->buf[len] = '\0';
51      } else {
52          memset(sh->buf,0,len+1);
53      }
54      return o;
55  }
56  #define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
57  robj *createStringObject(const char *ptr, size_t len) {
58      if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
59          return createEmbeddedStringObject(ptr,len);
60      else
61          return createRawStringObject(ptr,len);
62  }
63  robj *createStringObjectFromLongLongWithOptions(PORT_LONGLONG value, int valueobj) {
64      robj *o;
65      if (server.maxmemory == 0 ||
66          !(server.maxmemory_policy & MAXMEMORY_FLAG_NO_SHARED_INTEGERS))
67      {
68          valueobj = 0;
69      }
70      if (value >= 0 && value < OBJ_SHARED_INTEGERS && valueobj == 0) {
71          incrRefCount(shared.integers[value]);
72          o = shared.integers[value];
73      } else {
74          if (value >= PORT_LONG_MIN && value <= PORT_LONG_MAX) {
75              o = createObject(OBJ_STRING, NULL);
76              o->encoding = OBJ_ENCODING_INT;
77              o->ptr = (void*)(value);                                            &bsol;* WIN_PORT_FIX: (PORT_LONG) cast removed */
78          } else {
79              o = createObject(OBJ_STRING,sdsfromlonglong(value));
80          }
81      }
82      return o;
83  }
84  robj *createStringObjectFromLongLong(PORT_LONGLONG value) {
85      return createStringObjectFromLongLongWithOptions(value,0);
86  }
87  robj *createStringObjectFromLongLongForValue(PORT_LONGLONG value) {
88      return createStringObjectFromLongLongWithOptions(value,1);
89  }
90  robj *createStringObjectFromLongDouble(PORT_LONGDOUBLE value, int humanfriendly) {
91      char buf[MAX_LONG_DOUBLE_CHARS];
92      int len = ld2string(buf,sizeof(buf),value,humanfriendly);
93      return createStringObject(buf,len);
94  }
95  robj *dupStringObject(const robj *o) {
96      robj *d;
97      serverAssert(o->type == OBJ_STRING);
98      switch(o->encoding) {
99      case OBJ_ENCODING_RAW:
100          return createRawStringObject(o->ptr,sdslen(o->ptr));
101      case OBJ_ENCODING_EMBSTR:
102          return createEmbeddedStringObject(o->ptr,sdslen(o->ptr));
103      case OBJ_ENCODING_INT:
104          d = createObject(OBJ_STRING, NULL);
105          d->encoding = OBJ_ENCODING_INT;
106          d->ptr = o->ptr;
107          return d;
108      default:
109          serverPanic("Wrong encoding.");
110          break;
111      }
112  }
113  robj *createQuicklistObject(void) {
114      quicklist *l = quicklistCreate();
115      robj *o = createObject(OBJ_LIST,l);
116      o->encoding = OBJ_ENCODING_QUICKLIST;
117      return o;
118  }
119  robj *createZiplistObject(void) {
120      unsigned char *zl = ziplistNew();
121      robj *o = createObject(OBJ_LIST,zl);
122      o->encoding = OBJ_ENCODING_ZIPLIST;
123      return o;
124  }
125  robj *createSetObject(void) {
126      dict *d = dictCreate(&setDictType,NULL);
127      robj *o = createObject(OBJ_SET,d);
128      o->encoding = OBJ_ENCODING_HT;
129      return o;
130  }
131  robj *createIntsetObject(void) {
132      intset *is = intsetNew();
133      robj *o = createObject(OBJ_SET,is);
134      o->encoding = OBJ_ENCODING_INTSET;
135      return o;
136  }
137  robj *createHashObject(void) {
138      unsigned char *zl = ziplistNew();
139      robj *o = createObject(OBJ_HASH, zl);
140      o->encoding = OBJ_ENCODING_ZIPLIST;
141      return o;
142  }
143  robj *createZsetObject(void) {
144      zset *zs = zmalloc(sizeof(*zs));
145      robj *o;
146      zs->dict = dictCreate(&zsetDictType,NULL);
147      zs->zsl = zslCreate();
148      o = createObject(OBJ_ZSET,zs);
149      o->encoding = OBJ_ENCODING_SKIPLIST;
150      return o;
151  }
152  robj *createZsetZiplistObject(void) {
153      unsigned char *zl = ziplistNew();
154      robj *o = createObject(OBJ_ZSET,zl);
155      o->encoding = OBJ_ENCODING_ZIPLIST;
156      return o;
157  }
158  robj *createStreamObject(void) {
159      stream *s = streamNew();
160      robj *o = createObject(OBJ_STREAM,s);
161      o->encoding = OBJ_ENCODING_STREAM;
162      return o;
163  }
164  robj *createModuleObject(moduleType *mt, void *value) {
165      moduleValue *mv = zmalloc(sizeof(*mv));
166      mv->type = mt;
167      mv->value = value;
168      return createObject(OBJ_MODULE,mv);
169  }
170  void freeStringObject(robj *o) {
171      if (o->encoding == OBJ_ENCODING_RAW) {
172          sdsfree(o->ptr);
173      }
174  }
175  void freeListObject(robj *o) {
176      if (o->encoding == OBJ_ENCODING_QUICKLIST) {
177          quicklistRelease(o->ptr);
178      } else {
179          serverPanic("Unknown list encoding type");
180      }
181  }
182  void freeSetObject(robj *o) {
183      switch (o->encoding) {
184      case OBJ_ENCODING_HT:
185          dictRelease((dict*) o->ptr);
186          break;
187      case OBJ_ENCODING_INTSET:
188          zfree(o->ptr);
189          break;
190      default:
191          serverPanic("Unknown set encoding type");
192      }
193  }
194  void freeZsetObject(robj *o) {
195      zset *zs;
196      switch (o->encoding) {
197      case OBJ_ENCODING_SKIPLIST:
198          zs = o->ptr;
199          dictRelease(zs->dict);
200          zslFree(zs->zsl);
201          zfree(zs);
202          break;
203      case OBJ_ENCODING_ZIPLIST:
204          zfree(o->ptr);
205          break;
206      default:
207          serverPanic("Unknown sorted set encoding");
208      }
209  }
210  void freeHashObject(robj *o) {
211      switch (o->encoding) {
212      case OBJ_ENCODING_HT:
213          dictRelease((dict*) o->ptr);
214          break;
215      case OBJ_ENCODING_ZIPLIST:
216          zfree(o->ptr);
217          break;
218      default:
219          serverPanic("Unknown hash encoding type");
220          break;
221      }
222  }
223  void freeModuleObject(robj *o) {
224      moduleValue *mv = o->ptr;
225      mv->type->free(mv->value);
226      zfree(mv);
227  }
228  void freeStreamObject(robj *o) {
229      freeStream(o->ptr);
230  }
231  void incrRefCount(robj *o) {
232      if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount++;
233  }
234  void decrRefCount(robj *o) {
235      if (o->refcount == 1) {
236          switch(o->type) {
237          case OBJ_STRING: freeStringObject(o); break;
238          case OBJ_LIST: freeListObject(o); break;
239          case OBJ_SET: freeSetObject(o); break;
240          case OBJ_ZSET: freeZsetObject(o); break;
241          case OBJ_HASH: freeHashObject(o); break;
242          case OBJ_MODULE: freeModuleObject(o); break;
243          case OBJ_STREAM: freeStreamObject(o); break;
244          default: serverPanic("Unknown object type"); break;
245          }
246          zfree(o);
247      } else {
248          if (o->refcount <= 0) serverPanic("decrRefCount against refcount <= 0");
249          if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount--;
250      }
251  }
252  void decrRefCountVoid(void *o) {
253      decrRefCount(o);
254  }
255  robj *resetRefCount(robj *obj) {
256      obj->refcount = 0;
257      return obj;
258  }
259  int checkType(client *c, robj *o, int type) {
260      if (o->type != type) {
261          addReply(c,shared.wrongtypeerr);
262          return 1;
263      }
264      return 0;
265  }
266  int isSdsRepresentableAsLongLong(sds s, PORT_LONGLONG *llval) {
267      return string2ll(s,sdslen(s),llval) ? C_OK : C_ERR;
268  }
269  int isObjectRepresentableAsLongLong(robj *o, PORT_LONGLONG *llval) {
270      serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
271      if (o->encoding == OBJ_ENCODING_INT) {
272          if (llval) *llval = (PORT_LONG) o->ptr;
273          return C_OK;
274      } else {
275          return isSdsRepresentableAsLongLong(o->ptr,llval);
276      }
277  }
278  void trimStringObjectIfNeeded(robj *o) {
279      if (o->encoding == OBJ_ENCODING_RAW &&
280          sdsavail(o->ptr) > sdslen(o->ptr)/10)
281      {
282          o->ptr = sdsRemoveFreeSpace(o->ptr);
283      }
284  }
285  robj *tryObjectEncoding(robj *o) {
286      PORT_LONG value;
287      sds s = o->ptr;
288      size_t len;
289      serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
290      if (!sdsEncodedObject(o)) return o;
291       if (o->refcount > 1) return o;
292      len = sdslen(s);
293      if (len <= 20 && string2l(s,len,&value)) {
294          if ((server.maxmemory == 0 ||
295              !(server.maxmemory_policy & MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &&
296              value >= 0 &&
297              value < OBJ_SHARED_INTEGERS)
298          {
299              decrRefCount(o);
300              incrRefCount(shared.integers[value]);
301              return shared.integers[value];
302          } else {
303              if (o->encoding == OBJ_ENCODING_RAW) {
304                  sdsfree(o->ptr);
305                  o->encoding = OBJ_ENCODING_INT;
306                  o->ptr = (void*) value;
307                  return o;
308              } else if (o->encoding == OBJ_ENCODING_EMBSTR) {
309                  decrRefCount(o);
310                  return createStringObjectFromLongLongForValue(value);
311              }
312          }
313      }
314      if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) {
315          robj *emb;
316          if (o->encoding == OBJ_ENCODING_EMBSTR) return o;
317          emb = createEmbeddedStringObject(s,sdslen(s));
318          decrRefCount(o);
319          return emb;
320      }
321      trimStringObjectIfNeeded(o);
322      return o;
323  }
324  robj *getDecodedObject(robj *o) {
325      robj *dec;
326      if (sdsEncodedObject(o)) {
327          incrRefCount(o);
328          return o;
329      }
330      if (o->type == OBJ_STRING && o->encoding == OBJ_ENCODING_INT) {
331          char buf[32];
332          ll2string(buf,32,(PORT_LONG)o->ptr);
333          dec = createStringObject(buf,strlen(buf));
334          return dec;
335      } else {
336          serverPanic("Unknown encoding type");
337      }
338  }
339  #define REDIS_COMPARE_BINARY (1<<0)
340  #define REDIS_COMPARE_COLL (1<<1)
341  int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {
342      serverAssertWithInfo(NULL,a,a->type == OBJ_STRING && b->type == OBJ_STRING);
343      char bufa[128], bufb[128], *astr, *bstr;
344      size_t alen, blen, minlen;
345      if (a == b) return 0;
346      if (sdsEncodedObject(a)) {
347          astr = a->ptr;
348          alen = sdslen(astr);
349      } else {
350          alen = ll2string(bufa,sizeof(bufa),(PORT_LONG) a->ptr);
351          astr = bufa;
352      }
353      if (sdsEncodedObject(b)) {
354          bstr = b->ptr;
355          blen = sdslen(bstr);
356      } else {
357          blen = ll2string(bufb,sizeof(bufb),(PORT_LONG) b->ptr);
358          bstr = bufb;
359      }
360      if (flags & REDIS_COMPARE_COLL) {
361          return strcoll(astr,bstr);
362      } else {
363          int cmp;
364          minlen = (alen < blen) ? alen : blen;
365          cmp = memcmp(astr,bstr,minlen);
366          if (cmp == 0) return (int)(alen-blen);                                  WIN_PORT_FIX &bsol;* cast (int) */
367          return cmp;
368      }
369  }
370  int compareStringObjects(robj *a, robj *b) {
371      return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_BINARY);
372  }
373  int collateStringObjects(robj *a, robj *b) {
374      return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_COLL);
375  }
376  int equalStringObjects(robj *a, robj *b) {
377      if (a->encoding == OBJ_ENCODING_INT &&
378          b->encoding == OBJ_ENCODING_INT){
379          return a->ptr == b->ptr;
380      } else {
381          return compareStringObjects(a,b) == 0;
382      }
383  }
384  size_t stringObjectLen(robj *o) {
385      serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
386      if (sdsEncodedObject(o)) {
387          return sdslen(o->ptr);
388      } else {
389          return sdigits10((PORT_LONG)o->ptr);
390      }
391  }
392  int getDoubleFromObject(const robj *o, double *target) {
393      double value;
394      char *eptr;
395      if (o == NULL) {
396          value = 0;
397      } else {
398          serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
399          if (sdsEncodedObject(o)) {
400              errno = 0;
401              value = strtod(o->ptr, &eptr);
402              if (sdslen(o->ptr) == 0 ||
403                  isspace(((const char*)o->ptr)[0]) ||
404                  (size_t)(eptr-(char*)o->ptr) != sdslen(o->ptr) ||
405                  (errno == ERANGE &&
406                      (value == HUGE_VAL || value == -HUGE_VAL || value == 0)) ||
407                  isnan(value))
408                  return C_ERR;
409          } else if (o->encoding == OBJ_ENCODING_INT) {
410              value = (PORT_LONG)o->ptr;
411          } else {
412              serverPanic("Unknown string encoding");
413          }
414      }
415      *target = value;
416      return C_OK;
417  }
418  int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg) {
419      double value;
420      if (getDoubleFromObject(o, &value) != C_OK) {
421          if (msg != NULL) {
422              addReplyError(c,(char*)msg);
423          } else {
424              addReplyError(c,"value is not a valid float");
425          }
426          return C_ERR;
427      }
428      *target = value;
429      return C_OK;
430  }
431  int getLongDoubleFromObject(robj *o, PORT_LONGDOUBLE *target) {
432      PORT_LONGDOUBLE value;
433      char *eptr;
434      if (o == NULL) {
435          value = 0;
436      } else {
437          serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
438          if (sdsEncodedObject(o)) {
439              errno = 0;
440              value = IF_WIN32(wstrtod,strtold)(o->ptr, &eptr);                    
441              if (sdslen(o->ptr) == 0 ||
442                  isspace(((const char*)o->ptr)[0]) ||
443                  (size_t)(eptr-(char*)o->ptr) != sdslen(o->ptr) ||
444                  (errno == ERANGE &&
445                      (value == HUGE_VAL || value == -HUGE_VAL || value == 0)) ||
446                  isnan(value))
447                  return C_ERR;
448          } else if (o->encoding == OBJ_ENCODING_INT) {
449              value = (PORT_LONG)o->ptr;
450          } else {
451              serverPanic("Unknown string encoding");
452          }
453      }
454      *target = value;
455      return C_OK;
456  }
457  int getLongDoubleFromObjectOrReply(client *c, robj *o, PORT_LONGDOUBLE *target, const char *msg) {
458      PORT_LONGDOUBLE value;
459      if (getLongDoubleFromObject(o, &value) != C_OK) {
460          if (msg != NULL) {
461              addReplyError(c,(char*)msg);
462          } else {
463              addReplyError(c,"value is not a valid float");
464          }
465          return C_ERR;
466      }
467      *target = value;
468      return C_OK;
469  }
470  int getLongLongFromObject(robj *o, PORT_LONGLONG *target) {
471      PORT_LONGLONG value;
472      if (o == NULL) {
473          value = 0;
474      } else {
475          serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
476          if (sdsEncodedObject(o)) {
477              if (string2ll(o->ptr,sdslen(o->ptr),&value) == 0) return C_ERR;
478          } else if (o->encoding == OBJ_ENCODING_INT) {
479              value = (PORT_LONG)o->ptr;
480          } else {
481              serverPanic("Unknown string encoding");
482          }
483      }
484      if (target) *target = value;
485      return C_OK;
486  }
487  int getLongLongFromObjectOrReply(client *c, robj *o, PORT_LONGLONG *target, const char *msg) {
488      PORT_LONGLONG value;
489      if (getLongLongFromObject(o, &value) != C_OK) {
490          if (msg != NULL) {
491              addReplyError(c,(char*)msg);
492          } else {
493              addReplyError(c,"value is not an integer or out of range");
494          }
495          return C_ERR;
496      }
497      *target = value;
498      return C_OK;
499  }
500  int getLongFromObjectOrReply(client *c, robj *o, PORT_LONG *target, const char *msg) {
501      PORT_LONGLONG value;
502      if (getLongLongFromObjectOrReply(c, o, &value, msg) != C_OK) return C_ERR;
503      if (value < PORT_LONG_MIN || value > PORT_LONG_MAX) {
504          if (msg != NULL) {
505              addReplyError(c,(char*)msg);
506          } else {
507              addReplyError(c,"value is out of range");
508          }
509          return C_ERR;
510      }
511      *target = (PORT_LONG)value;                                                 WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
512      return C_OK;
513  }
514  char *strEncoding(int encoding) {
515      switch(encoding) {
516      case OBJ_ENCODING_RAW: return "raw";
517      case OBJ_ENCODING_INT: return "int";
518      case OBJ_ENCODING_HT: return "hashtable";
519      case OBJ_ENCODING_QUICKLIST: return "quicklist";
520      case OBJ_ENCODING_ZIPLIST: return "ziplist";
521      case OBJ_ENCODING_INTSET: return "intset";
522      case OBJ_ENCODING_SKIPLIST: return "skiplist";
523      case OBJ_ENCODING_EMBSTR: return "embstr";
524      default: return "unknown";
525      }
526  }
527  size_t streamRadixTreeMemoryUsage(rax *rax) {
528      size_t size;
529      size = rax->numele * sizeof(streamID);
530      size += rax->numnodes * sizeof(raxNode);
531      size += rax->numnodes * sizeof(PORT_LONG)*30;
532      return size;
533  }
534  #define OBJ_COMPUTE_SIZE_DEF_SAMPLES 5 &bsol;* Default sample size. */
535  size_t objectComputeSize(robj *o, size_t sample_size) {
536      sds ele, ele2;
537      dict *d;
538      dictIterator *di;
539      struct dictEntry *de;
540      size_t asize = 0, elesize = 0, samples = 0;
541      if (o->type == OBJ_STRING) {
542          if(o->encoding == OBJ_ENCODING_INT) {
543              asize = sizeof(*o);
544          } else if(o->encoding == OBJ_ENCODING_RAW) {
545              asize = sdsAllocSize(o->ptr)+sizeof(*o);
546          } else if(o->encoding == OBJ_ENCODING_EMBSTR) {
547              asize = sdslen(o->ptr)+2+sizeof(*o);
548          } else {
549              serverPanic("Unknown string encoding");
550          }
551      } else if (o->type == OBJ_LIST) {
552          if (o->encoding == OBJ_ENCODING_QUICKLIST) {
553              quicklist *ql = o->ptr;
554              quicklistNode *node = ql->head;
555              asize = sizeof(*o)+sizeof(quicklist);
556              do {
557                  elesize += sizeof(quicklistNode)+ziplistBlobLen(node->zl);
558                  samples++;
559              } while ((node = node->next) && samples < sample_size);
560              asize += (double)elesize/samples*ql->len;
561          } else if (o->encoding == OBJ_ENCODING_ZIPLIST) {
562              asize = sizeof(*o)+ziplistBlobLen(o->ptr);
563          } else {
564              serverPanic("Unknown list encoding");
565          }
566      } else if (o->type == OBJ_SET) {
567          if (o->encoding == OBJ_ENCODING_HT) {
568              d = o->ptr;
569              di = dictGetIterator(d);
570              asize = sizeof(*o)+sizeof(dict)+(sizeof(struct dictEntry*)*dictSlots(d));
571              while((de = dictNext(di)) != NULL && samples < sample_size) {
572                  ele = dictGetKey(de);
573                  elesize += sizeof(struct dictEntry) + sdsAllocSize(ele);
574                  samples++;
575              }
576              dictReleaseIterator(di);
577              if (samples) asize += (double)elesize/samples*dictSize(d);
578          } else if (o->encoding == OBJ_ENCODING_INTSET) {
579              intset *is = o->ptr;
580              asize = sizeof(*o)+sizeof(*is)+is->encoding*(size_t)is->length;  WIN_PORT_FIX &bsol;* cast (size_t) */
581          } else {
582              serverPanic("Unknown set encoding");
583          }
584      } else if (o->type == OBJ_ZSET) {
585          if (o->encoding == OBJ_ENCODING_ZIPLIST) {
586              asize = sizeof(*o)+(ziplistBlobLen(o->ptr));
587          } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
588              d = ((zset*)o->ptr)->dict;
589              zskiplist *zsl = ((zset*)o->ptr)->zsl;
590              zskiplistNode *znode = zsl->header->level[0].forward;
591              asize = sizeof(*o)+sizeof(zset)+sizeof(zskiplist)+sizeof(dict)+
592                      (sizeof(struct dictEntry*)*dictSlots(d))+
593                      zmalloc_size(zsl->header);
594              while(znode != NULL && samples < sample_size) {
595                  elesize += sdsAllocSize(znode->ele);
596                  elesize += sizeof(struct dictEntry) + zmalloc_size(znode);
597                  samples++;
598                  znode = znode->level[0].forward;
599              }
600              if (samples) asize += (double)elesize/samples*dictSize(d);
601          } else {
602              serverPanic("Unknown sorted set encoding");
603          }
604      } else if (o->type == OBJ_HASH) {
605          if (o->encoding == OBJ_ENCODING_ZIPLIST) {
606              asize = sizeof(*o)+(ziplistBlobLen(o->ptr));
607          } else if (o->encoding == OBJ_ENCODING_HT) {
608              d = o->ptr;
609              di = dictGetIterator(d);
610              asize = sizeof(*o)+sizeof(dict)+(sizeof(struct dictEntry*)*dictSlots(d));
611              while((de = dictNext(di)) != NULL && samples < sample_size) {
612                  ele = dictGetKey(de);
613                  ele2 = dictGetVal(de);
614                  elesize += sdsAllocSize(ele) + sdsAllocSize(ele2);
615                  elesize += sizeof(struct dictEntry);
616                  samples++;
617              }
618              dictReleaseIterator(di);
619              if (samples) asize += (double)elesize/samples*dictSize(d);
620          } else {
621              serverPanic("Unknown hash encoding");
622          }
623      } else if (o->type == OBJ_STREAM) {
624          stream *s = o->ptr;
625          asize = sizeof(*o);
626          asize += streamRadixTreeMemoryUsage(s->rax);
627          raxIterator ri;
628          raxStart(&ri,s->rax);
629          raxSeek(&ri,"^",NULL,0);
630          size_t lpsize = 0, samples = 0;
631          while(samples < sample_size && raxNext(&ri)) {
632              unsigned char *lp = ri.data;
633              lpsize += lpBytes(lp);
634              samples++;
635          }
636          if (s->rax->numele <= samples) {
637              asize += lpsize;
638          } else {
639              if (samples) lpsize /= samples; &bsol;* Compute the average. */
640              asize += lpsize * (s->rax->numele-1);
641              raxSeek(&ri,"$",NULL,0);
642              raxNext(&ri);
643              asize += lpBytes(ri.data);
644          }
645          raxStop(&ri);
646          if (s->cgroups) {
647              raxStart(&ri,s->cgroups);
648              raxSeek(&ri,"^",NULL,0);
649              while(raxNext(&ri)) {
650                  streamCG *cg = ri.data;
651                  asize += sizeof(*cg);
652                  asize += streamRadixTreeMemoryUsage(cg->pel);
653                  asize += sizeof(streamNACK)*raxSize(cg->pel);
654                  raxIterator cri;
655                  raxStart(&cri,cg->consumers);
656                  raxSeek(&cri,"^",NULL,0);
657                  while(raxNext(&cri)) {
658                      streamConsumer *consumer = cri.data;
659                      asize += sizeof(*consumer);
660                      asize += sdslen(consumer->name);
661                      asize += streamRadixTreeMemoryUsage(consumer->pel);
662                  }
663                  raxStop(&cri);
664              }
665              raxStop(&ri);
666          }
667      } else if (o->type == OBJ_MODULE) {
668          moduleValue *mv = o->ptr;
669          moduleType *mt = mv->type;
670          if (mt->mem_usage != NULL) {
671              asize = mt->mem_usage(mv->value);
672          } else {
673              asize = 0;
674          }
675      } else {
676          serverPanic("Unknown object type");
677      }
678      return asize;
679  }
680  void freeMemoryOverheadData(struct redisMemOverhead *mh) {
681      zfree(mh->db);
682      zfree(mh);
683  }
684  struct redisMemOverhead *getMemoryOverheadData(void) {
685      int j;
686      size_t mem_total = 0;
687      size_t mem = 0;
688      size_t zmalloc_used = zmalloc_used_memory();
689      struct redisMemOverhead *mh = zcalloc(sizeof(*mh));
690      mh->total_allocated = zmalloc_used;
691      mh->startup_allocated = server.initial_memory_usage;
692      mh->peak_allocated = server.stat_peak_memory;
693      mh->total_frag =
694          (float)server.cron_malloc_stats.process_rss / server.cron_malloc_stats.zmalloc_used;
695      mh->total_frag_bytes =
696          server.cron_malloc_stats.process_rss - server.cron_malloc_stats.zmalloc_used;
697      mh->allocator_frag =
698          (float)server.cron_malloc_stats.allocator_active / server.cron_malloc_stats.allocator_allocated;
699      mh->allocator_frag_bytes =
700          server.cron_malloc_stats.allocator_active - server.cron_malloc_stats.allocator_allocated;
701      mh->allocator_rss =
702          (float)server.cron_malloc_stats.allocator_resident / server.cron_malloc_stats.allocator_active;
703      mh->allocator_rss_bytes =
704          server.cron_malloc_stats.allocator_resident - server.cron_malloc_stats.allocator_active;
705      mh->rss_extra =
706          (float)server.cron_malloc_stats.process_rss / server.cron_malloc_stats.allocator_resident;
707      mh->rss_extra_bytes =
708          server.cron_malloc_stats.process_rss - server.cron_malloc_stats.allocator_resident;
709      mem_total += server.initial_memory_usage;
710      mem = 0;
711      if (server.repl_backlog)
712          mem += zmalloc_size(server.repl_backlog);
713      mh->repl_backlog = mem;
714      mem_total += mem;
715      mem = 0;
716      if (listLength(server.slaves)) {
717          listIter li;
718          listNode *ln;
719          listRewind(server.slaves,&li);
720          while((ln = listNext(&li))) {
721              client *c = listNodeValue(ln);
722              mem += getClientOutputBufferMemoryUsage(c);
723              mem += sdsAllocSize(c->querybuf);
724              mem += sizeof(client);
725          }
726      }
727      mh->clients_slaves = mem;
728      mem_total+=mem;
729      mem = 0;
730      if (listLength(server.clients)) {
731          listIter li;
732          listNode *ln;
733          listRewind(server.clients,&li);
734          while((ln = listNext(&li))) {
735              client *c = listNodeValue(ln);
736              if (c->flags & CLIENT_SLAVE && !(c->flags & CLIENT_MONITOR))
737                  continue;
738              mem += getClientOutputBufferMemoryUsage(c);
739              mem += sdsAllocSize(c->querybuf);
740              mem += sizeof(client);
741          }
742      }
743      mh->clients_normal = mem;
744      mem_total+=mem;
745      mem = 0;
746      if (server.aof_state != AOF_OFF) {
747          mem += sdsalloc(server.aof_buf);
748          mem += aofRewriteBufferSize();
749      }
750      mh->aof_buffer = mem;
751      mem_total+=mem;
752      mem = server.lua_scripts_mem;
753      mem += dictSize(server.lua_scripts) * sizeof(dictEntry) +
754          dictSlots(server.lua_scripts) * sizeof(dictEntry*);
755      mem += dictSize(server.repl_scriptcache_dict) * sizeof(dictEntry) +
756          dictSlots(server.repl_scriptcache_dict) * sizeof(dictEntry*);
757      if (listLength(server.repl_scriptcache_fifo) > 0) {
758          mem += listLength(server.repl_scriptcache_fifo) * (sizeof(listNode) + 
759              sdsZmallocSize(listNodeValue(listFirst(server.repl_scriptcache_fifo))));
760      }
761      mh->lua_caches = mem;
762      mem_total+=mem;
763      for (j = 0; j < server.dbnum; j++) {
764          redisDb *db = server.db+j;
765          PORT_LONGLONG keyscount = dictSize(db->dict);
766          if (keyscount==0) continue;
767          mh->total_keys += keyscount;
768          mh->db = zrealloc(mh->db,sizeof(mh->db[0])*(mh->num_dbs+1));
769          mh->db[mh->num_dbs].dbid = j;
770          mem = dictSize(db->dict) * sizeof(dictEntry) +
771                dictSlots(db->dict) * sizeof(dictEntry*) +
772                dictSize(db->dict) * sizeof(robj);
773          mh->db[mh->num_dbs].overhead_ht_main = mem;
774          mem_total+=mem;
775          mem = dictSize(db->expires) * sizeof(dictEntry) +
776                dictSlots(db->expires) * sizeof(dictEntry*);
777          mh->db[mh->num_dbs].overhead_ht_expires = mem;
778          mem_total+=mem;
779          mh->num_dbs++;
780      }
781      mh->overhead_total = mem_total;
782      mh->dataset = zmalloc_used - mem_total;
783      mh->peak_perc = (float)zmalloc_used*100/mh->peak_allocated;
784      size_t net_usage = 1;
785      if (zmalloc_used > mh->startup_allocated)
786          net_usage = zmalloc_used - mh->startup_allocated;
787      mh->dataset_perc = (float)mh->dataset*100/net_usage;
788      mh->bytes_per_key = mh->total_keys ? (net_usage / mh->total_keys) : 0;
789      return mh;
790  }
791  void inputCatSds(void *result, const char *str) {
792      sds *info = (sds *)result;
793      *info = sdscat(*info, str);
794  }
795  sds getMemoryDoctorReport(void) {
796      int empty = 0;          &bsol;* Instance is empty or almost empty. */
797      int big_peak = 0;       &bsol;* Memory peak is much larger than used mem. */
798      int high_frag = 0;      &bsol;* High fragmentation. */
799      int high_alloc_frag = 0;&bsol;* High allocator fragmentation. */
800      int high_proc_rss = 0;  &bsol;* High process rss overhead. */
801      int high_alloc_rss = 0; &bsol;* High rss overhead. */
802      int big_slave_buf = 0;  &bsol;* Slave buffers are too big. */
803      int big_client_buf = 0; &bsol;* Client buffers are too big. */
804      int many_scripts = 0;   &bsol;* Script cache has too many scripts. */
805      int num_reports = 0;
806      struct redisMemOverhead *mh = getMemoryOverheadData();
807      if (mh->total_allocated < (1024*1024*5)) {
808          empty = 1;
809          num_reports++;
810      } else {
811          if (((float)mh->peak_allocated / mh->total_allocated) > 1.5) {
812              big_peak = 1;
813              num_reports++;
814          }
815          if (mh->total_frag > 1.4 && mh->total_frag_bytes > 10<<20) {
816              high_frag = 1;
817              num_reports++;
818          }
819          if (mh->allocator_frag > 1.1 && mh->allocator_frag_bytes > 10<<20) {
820              high_alloc_frag = 1;
821              num_reports++;
822          }
823          if (mh->allocator_rss > 1.1 && mh->allocator_rss_bytes > 10<<20) {
824              high_alloc_rss = 1;
825              num_reports++;
826          }
827          if (mh->rss_extra > 1.1 && mh->rss_extra_bytes > 10<<20) {
828              high_proc_rss = 1;
829              num_reports++;
830          }
831          PORT_LONG numslaves = listLength(server.slaves);
832  		PORT_LONG numclients = listLength(server.clients)-numslaves;
833          if (mh->clients_normal / numclients > (1024*200)) {
834              big_client_buf = 1;
835              num_reports++;
836          }
837          if (numslaves > 0 && mh->clients_slaves / numslaves > (1024*1024*10)) {
838              big_slave_buf = 1;
839              num_reports++;
840          }
841          if (dictSize(server.lua_scripts) > 1000) {
842              many_scripts = 1;
843              num_reports++;
844          }
845      }
846      sds s;
847      if (num_reports == 0) {
848          s = sdsnew(
849          "Hi Sam, I can't find any memory issue in your instance. "
850          "I can only account for what occurs on this base.\n");
851      } else if (empty == 1) {
852          s = sdsnew(
853          "Hi Sam, this instance is empty or is using very little memory, "
854          "my issues detector can't be used in these conditions. "
855          "Please, leave for your mission on Earth and fill it with some data. "
856          "The new Sam and I will be back to our programming as soon as I "
857          "finished rebooting.\n");
858      } else {
859          s = sdsnew("Sam, I detected a few issues in this Redis instance memory implants:\n\n");
860          if (big_peak) {
861              s = sdscat(s," * Peak memory: In the past this instance used more than 150% the memory that is currently using. The allocator is normally not able to release memory after a peak, so you can expect to see a big fragmentation ratio, however this is actually harmless and is only due to the memory peak, and if the Redis instance Resident Set Size (RSS) is currently bigger than expected, the memory will be used as soon as you fill the Redis instance with more data. If the memory peak was only occasional and you want to try to reclaim memory, please try the MEMORY PURGE command, otherwise the only other option is to shutdown and restart the instance.\n\n");
862          }
863          if (high_frag) {
864              s = sdscatprintf(s," * High total RSS: This instance has a memory fragmentation and RSS overhead greater than 1.4 (this means that the Resident Set Size of the Redis process is much larger than the sum of the logical allocations Redis performed). This problem is usually due either to a large peak memory (check if there is a peak memory entry above in the report) or may result from a workload that causes the allocator to fragment memory a lot. If the problem is a large peak memory, then there is no issue. Otherwise, make sure you are using the Jemalloc allocator and not the default libc malloc. Note: The currently used allocator is \"%s\".\n\n", ZMALLOC_LIB);
865          }
866          if (high_alloc_frag) {
867              s = sdscatprintf(s," * High allocator fragmentation: This instance has an allocator external fragmentation greater than 1.1. This problem is usually due either to a large peak memory (check if there is a peak memory entry above in the report) or may result from a workload that causes the allocator to fragment memory a lot. You can try enabling 'activedefrag' config option.\n\n");
868          }
869          if (high_alloc_rss) {
870              s = sdscatprintf(s," * High allocator RSS overhead: This instance has an RSS memory overhead is greater than 1.1 (this means that the Resident Set Size of the allocator is much larger than the sum what the allocator actually holds). This problem is usually due to a large peak memory (check if there is a peak memory entry above in the report), you can try the MEMORY PURGE command to reclaim it.\n\n");
871          }
872          if (high_proc_rss) {
873              s = sdscatprintf(s," * High process RSS overhead: This instance has non-allocator RSS memory overhead is greater than 1.1 (this means that the Resident Set Size of the Redis process is much larger than the RSS the allocator holds). This problem may be due to Lua scripts or Modules.\n\n");
874          }
875          if (big_slave_buf) {
876              s = sdscat(s," * Big replica buffers: The replica output buffers in this instance are greater than 10MB for each replica (on average). This likely means that there is some replica instance that is struggling receiving data, either because it is too slow or because of networking issues. As a result, data piles on the master output buffers. Please try to identify what replica is not receiving data correctly and why. You can use the INFO output in order to check the replicas delays and the CLIENT LIST command to check the output buffers of each replica.\n\n");
877          }
878          if (big_client_buf) {
879              s = sdscat(s," * Big client buffers: The clients output buffers in this instance are greater than 200K per client (on average). This may result from different causes, like Pub/Sub clients subscribed to channels bot not receiving data fast enough, so that data piles on the Redis instance output buffer, or clients sending commands with large replies or very large sequences of commands in the same pipeline. Please use the CLIENT LIST command in order to investigate the issue if it causes problems in your instance, or to understand better why certain clients are using a big amount of memory.\n\n");
880          }
881          if (many_scripts) {
882              s = sdscat(s," * Many scripts: There seem to be many cached scripts in this instance (more than 1000). This may be because scripts are generated and `EVAL`ed, instead of being parameterized (with KEYS and ARGV), `SCRIPT LOAD`ed and `EVALSHA`ed. Unless `SCRIPT FLUSH` is called periodically, the scripts' caches may end up consuming most of your memory.\n\n");
883          }
884          s = sdscat(s,"I'm here to keep you safe, Sam. I want to help you.\n");
885      }
886      freeMemoryOverheadData(mh);
887      return s;
888  }
889  void objectSetLRUOrLFU(robj *val, PORT_LONGLONG lfu_freq, PORT_LONGLONG lru_idle,
890                         PORT_LONGLONG lru_clock) {
891      if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
892          if (lfu_freq >= 0) {
893              serverAssert(lfu_freq <= 255);
894              val->lru = (LFUGetTimeInMinutes()<<8) | lfu_freq;
895          }
896      } else if (lru_idle >= 0) {
897          lru_idle = lru_idle*1000/LRU_CLOCK_RESOLUTION;
898          PORT_LONG lru_abs = lru_clock - lru_idle; &bsol;* Absolute access time. */
899          if (lru_abs < 0)
900              lru_abs = (lru_clock+(LRU_CLOCK_MAX/2)) % LRU_CLOCK_MAX;
901          val->lru = lru_abs;
902      }
903  }
904  robj *objectCommandLookup(client *c, robj *key) {
905      dictEntry *de;
906      if ((de = dictFind(c->db->dict,key->ptr)) == NULL) return NULL;
907      return (robj*) dictGetVal(de);
908  }
909  robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {
910      robj *o = objectCommandLookup(c,key);
911      if (!o) addReply(c, reply);
912      return o;
913  }
914  void objectCommand(client *c) {
915      robj *o;
916      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
917          const char *help[] = {
918  "ENCODING <key> -- Return the kind of internal representation used in order to store the value associated with a key.",
919  "FREQ <key> -- Return the access frequency index of the key. The returned integer is proportional to the logarithm of the recent access frequency of the key.",
920  "IDLETIME <key> -- Return the idle time of the key, that is the approximated number of seconds elapsed since the last access to the key.",
921  "REFCOUNT <key> -- Return the number of references of the value associated with the specified key.",
922  NULL
923          };
924          addReplyHelp(c, help);
925      } else if (!strcasecmp(c->argv[1]->ptr,"refcount") && c->argc == 3) {
926          if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))
927                  == NULL) return;
928          addReplyLongLong(c,o->refcount);
929      } else if (!strcasecmp(c->argv[1]->ptr,"encoding") && c->argc == 3) {
930          if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))
931                  == NULL) return;
932          addReplyBulkCString(c,strEncoding(o->encoding));
933      } else if (!strcasecmp(c->argv[1]->ptr,"idletime") && c->argc == 3) {
934          if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))
935                  == NULL) return;
936          if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
937              addReplyError(c,"An LFU maxmemory policy is selected, idle time not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust.");
938              return;
939          }
940          addReplyLongLong(c,estimateObjectIdleTime(o)/1000);
941      } else if (!strcasecmp(c->argv[1]->ptr,"freq") && c->argc == 3) {
942          if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))
943                  == NULL) return;
944          if (!(server.maxmemory_policy & MAXMEMORY_FLAG_LFU)) {
945              addReplyError(c,"An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust.");
946              return;
947          }
948          addReplyLongLong(c,LFUDecrAndReturn(o));
949      } else {
950          addReplySubcommandSyntaxError(c);
951      }
952  }
953  void memoryCommand(client *c) {
954      if (!strcasecmp(c->argv[1]->ptr,"help") && c->argc == 2) {
955          const char *help[] = {
956  "DOCTOR - Return memory problems reports.",
957  "MALLOC-STATS -- Return internal statistics report from the memory allocator.",
958  "PURGE -- Attempt to purge dirty pages for reclamation by the allocator.",
959  "STATS -- Return information about the memory usage of the server.",
960  "USAGE <key> [SAMPLES <count>] -- Return memory in bytes used by <key> and its value. Nested values are sampled up to <count> times (default: 5).",
961  NULL
962          };
963          addReplyHelp(c, help);
964      } else if (!strcasecmp(c->argv[1]->ptr,"usage") && c->argc >= 3) {
965          dictEntry *de;
966          PORT_LONGLONG samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;
967          for (int j = 3; j < c->argc; j++) {
968              if (!strcasecmp(c->argv[j]->ptr,"samples") &&
969                  j+1 < c->argc)
970              {
971                  if (getLongLongFromObjectOrReply(c,c->argv[j+1],&samples,NULL)
972                       == C_ERR) return;
973                  if (samples < 0) {
974                      addReply(c,shared.syntaxerr);
975                      return;
976                  }
977                  if (samples == 0) samples = LLONG_MAX;;
978                  j++; &bsol;* skip option argument. */
979              } else {
980                  addReply(c,shared.syntaxerr);
981                  return;
982              }
983          }
984          if ((de = dictFind(c->db->dict,c->argv[2]->ptr)) == NULL) {
985              addReply(c, shared.nullbulk);
986              return;
987          }
988          size_t usage = objectComputeSize(dictGetVal(de),samples);
989          usage += sdsAllocSize(dictGetKey(de));
990          usage += sizeof(dictEntry);
991          addReplyLongLong(c,usage);
992      } else if (!strcasecmp(c->argv[1]->ptr,"stats") && c->argc == 2) {
993          struct redisMemOverhead *mh = getMemoryOverheadData();
994          addReplyMultiBulkLen(c,(25+mh->num_dbs)*2);
995          addReplyBulkCString(c,"peak.allocated");
996          addReplyLongLong(c,mh->peak_allocated);
997          addReplyBulkCString(c,"total.allocated");
998          addReplyLongLong(c,mh->total_allocated);
999          addReplyBulkCString(c,"startup.allocated");
1000          addReplyLongLong(c,mh->startup_allocated);
1001          addReplyBulkCString(c,"replication.backlog");
1002          addReplyLongLong(c,mh->repl_backlog);
1003          addReplyBulkCString(c,"clients.slaves");
1004          addReplyLongLong(c,mh->clients_slaves);
1005          addReplyBulkCString(c,"clients.normal");
1006          addReplyLongLong(c,mh->clients_normal);
1007          addReplyBulkCString(c,"aof.buffer");
1008          addReplyLongLong(c,mh->aof_buffer);
1009          addReplyBulkCString(c,"lua.caches");
1010          addReplyLongLong(c,mh->lua_caches);
1011          for (size_t j = 0; j < mh->num_dbs; j++) {
1012              char dbname[32];
1013              snprintf(dbname,sizeof(dbname),"db.%zd",mh->db[j].dbid);
1014              addReplyBulkCString(c,dbname);
1015              addReplyMultiBulkLen(c,4);
1016              addReplyBulkCString(c,"overhead.hashtable.main");
1017              addReplyLongLong(c,mh->db[j].overhead_ht_main);
1018              addReplyBulkCString(c,"overhead.hashtable.expires");
1019              addReplyLongLong(c,mh->db[j].overhead_ht_expires);
1020          }
1021          addReplyBulkCString(c,"overhead.total");
1022          addReplyLongLong(c,mh->overhead_total);
1023          addReplyBulkCString(c,"keys.count");
1024          addReplyLongLong(c,mh->total_keys);
1025          addReplyBulkCString(c,"keys.bytes-per-key");
1026          addReplyLongLong(c,mh->bytes_per_key);
1027          addReplyBulkCString(c,"dataset.bytes");
1028          addReplyLongLong(c,mh->dataset);
1029          addReplyBulkCString(c,"dataset.percentage");
1030          addReplyDouble(c,mh->dataset_perc);
1031          addReplyBulkCString(c,"peak.percentage");
1032          addReplyDouble(c,mh->peak_perc);
1033          addReplyBulkCString(c,"allocator.allocated");
1034          addReplyLongLong(c,server.cron_malloc_stats.allocator_allocated);
1035          addReplyBulkCString(c,"allocator.active");
1036          addReplyLongLong(c,server.cron_malloc_stats.allocator_active);
1037          addReplyBulkCString(c,"allocator.resident");
1038          addReplyLongLong(c,server.cron_malloc_stats.allocator_resident);
1039          addReplyBulkCString(c,"allocator-fragmentation.ratio");
1040          addReplyDouble(c,mh->allocator_frag);
1041          addReplyBulkCString(c,"allocator-fragmentation.bytes");
1042          addReplyLongLong(c,mh->allocator_frag_bytes);
1043          addReplyBulkCString(c,"allocator-rss.ratio");
1044          addReplyDouble(c,mh->allocator_rss);
1045          addReplyBulkCString(c,"allocator-rss.bytes");
1046          addReplyLongLong(c,mh->allocator_rss_bytes);
1047          addReplyBulkCString(c,"rss-overhead.ratio");
1048          addReplyDouble(c,mh->rss_extra);
1049          addReplyBulkCString(c,"rss-overhead.bytes");
1050          addReplyLongLong(c,mh->rss_extra_bytes);
1051          addReplyBulkCString(c,"fragmentation"); &bsol;* this is the total RSS overhead, including fragmentation */
1052          addReplyDouble(c,mh->total_frag); &bsol;* it is kept here for backwards compatibility */
1053          addReplyBulkCString(c,"fragmentation.bytes");
1054          addReplyLongLong(c,mh->total_frag_bytes);
1055          freeMemoryOverheadData(mh);
1056      } else if (!strcasecmp(c->argv[1]->ptr,"malloc-stats") && c->argc == 2) {
1057  #if defined(USE_JEMALLOC)
1058          sds info = sdsempty();
1059          je_malloc_stats_print(inputCatSds, &info, NULL);
1060          addReplyBulkSds(c, info);
1061  #else
1062          addReplyBulkCString(c,"Stats not supported for the current allocator");
1063  #endif
1064      } else if (!strcasecmp(c->argv[1]->ptr,"doctor") && c->argc == 2) {
1065          sds report = getMemoryDoctorReport();
1066          addReplyBulkSds(c,report);
1067      } else if (!strcasecmp(c->argv[1]->ptr,"purge") && c->argc == 2) {
1068  #if defined(USE_JEMALLOC)
1069          char tmp[32];
1070          unsigned narenas = 0;
1071          size_t sz = sizeof(unsigned);
1072          if (!je_mallctl("arenas.narenas", &narenas, &sz, NULL, 0)) {
1073              sprintf(tmp, "arena.%d.purge", narenas);
1074              if (!je_mallctl(tmp, NULL, 0, NULL, 0)) {
1075                  addReply(c, shared.ok);
1076                  return;
1077              }
1078          }
1079          addReplyError(c, "Error purging dirty pages");
1080  #else
1081          addReply(c, shared.ok);
1082  #endif
1083      } else {
1084          addReplyErrorFormat(c, "Unknown subcommand or wrong number of arguments for '%s'. Try MEMORY HELP", (char*)c->argv[1]->ptr);
1085      }
1086  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-bcrypt.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-object.c</div>
                <div class="column column_space"><pre><code>67     if (rounds == 0) {
68        used_rounds = LTC_BCRYPT_DEFAULT_ROUNDS;
69     } else {
70        used_rounds = rounds;
71     }
72     buf[0]      = XMALLOC(MAXBLOCKSIZE * 3);
73     hashed_pass = XMALLOC(MAXBLOCKSIZE);
</pre></code></div>
                <div class="column column_space"><pre><code>38      if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
39          o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;
40      } else {
41          o->lru = LRU_CLOCK();
42      }
43      sh->len = len;
44      sh->alloc = len;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    