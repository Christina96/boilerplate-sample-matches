<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ommysql.c &amp; omhttpfs.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ommysql.c &amp; omhttpfs.c
      </h3>
<h1 align="center">
        16.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ommysql.c (17.1875%)<th>omhttpfs.c (15.602837%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(88-100)<td><a href="#" name="0">(130-142)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(376-388)<td><a href="#" name="1">(743-754)</a><td align="center"><font color="#b10000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(435-446)<td><a href="#" name="2">(769-783)</a><td align="center"><font color="#a60000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(397-400)<td><a href="#" name="3">(755-758)</a><td align="center"><font color="#850000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ommysql.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;time.h&gt;
11 #include &lt;netdb.h&gt;
12 #include &lt;mysql.h&gt;
13 #include &lt;mysqld_error.h&gt;
14 #include "conf.h"
15 #include "syslogd-types.h"
16 #include "srUtils.h"
17 #include "template.h"
18 #include "module-template.h"
19 #include "errmsg.h"
20 #include "cfsysline.h"
21 #include "parserif.h"
22 MODULE_TYPE_OUTPUT
23 MODULE_TYPE_NOKEEP
24 MODULE_CNFNAME("ommysql")
25 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
26 DEF_OMOD_STATIC_DATA
27 typedef struct _instanceData {
28 	unsigned int dbsrvPort;			char	dbname[_DB_MAXDBLEN+1];		char	dbuid[_DB_MAXUNAMELEN+1];		char	dbpwd[_DB_MAXPWDLEN+1];		uchar   *configfile;				uchar   *configsection;			uchar	*tplName;				uchar	*socket;			} instanceData;
29 typedef struct wrkrInstanceData {
30 	instanceData *pData;
31 	MYSQL	*hmysql;				unsigned uLastMySQLErrno;		} wrkrInstanceData_t;
32 typedef struct configSettings_s {
33 	int iSrvPort;					uchar *pszMySQLConfigFile;		uchar *pszMySQLConfigSection;	} configSettings_t;
34 static configSettings_t cs;
35 <a name="0"></a>static struct cnfparamdescr actpdescr[] = {
36 	{ "server", eCmdHdlrGetWord, 1 },
37 	{ "db", eCmdHdlrGetWord, 1 },
38 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "uid", eCmdHdlrGetWord, 1 },
39 	{ "pwd", eCmdHdlrGetWord, 1 },
40 	{ "serverport", eCmdHdlrInt, 0 },
41 	{ "mysqlconfig.file", eCmdHdlrGetWord, 0 },
42 	{ "mysqlconfig.section", eCmdHdlrGetWord, 0 },
43 	{ "template", eCmdHdlrGetWord, 0 },
44 	{ "socket", eCmdHdlrGetWord, 0 },
45 };
46 static struct cnfparamblk actpblk =
47 	{ CNFPARAMBLK_VERSION,
48 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
49 	  actpdescr
50 	};</b></font>
51 pthread_rwlock_t rwlock_hmysql;
52 BEGINinitConfVars		CODESTARTinitConfVars
53 	resetConfigVariables(NULL, NULL);
54 ENDinitConfVars
55 BEGINcreateInstance
56 CODESTARTcreateInstance
57 ENDcreateInstance
58 BEGINcreateWrkrInstance
59 CODESTARTcreateWrkrInstance
60 	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
61 	pWrkrData-&gt;hmysql = NULL;
62 	pthread_rwlock_unlock(&amp;rwlock_hmysql);
63 ENDcreateWrkrInstance
64 BEGINisCompatibleWithFeature
65 CODESTARTisCompatibleWithFeature
66 	if(eFeat == sFEATURERepeatedMsgReduction)
67 		iRet = RS_RET_OK;
68 ENDisCompatibleWithFeature
69 static void closeMySQL(wrkrInstanceData_t *pWrkrData)
70 {
71 	pthread_rwlock_unlock(&amp;rwlock_hmysql);
72 	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
73 	if(pWrkrData-&gt;hmysql != NULL) {			mysql_close(pWrkrData-&gt;hmysql);
74 		pWrkrData-&gt;hmysql = NULL;
75 	}
76 	pthread_rwlock_unlock(&amp;rwlock_hmysql);
77 	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
78 }
79 BEGINfreeInstance
80 CODESTARTfreeInstance
81 	free(pData-&gt;configfile);
82 	free(pData-&gt;configsection);
83 	free(pData-&gt;tplName);
84 	free(pData-&gt;socket);
85 ENDfreeInstance
86 BEGINfreeWrkrInstance
87 CODESTARTfreeWrkrInstance
88 	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
89 	closeMySQL(pWrkrData);
90 	mysql_thread_end();
91 	pthread_rwlock_unlock(&amp;rwlock_hmysql);
92 ENDfreeWrkrInstance
93 BEGINdbgPrintInstInfo
94 CODESTARTdbgPrintInstInfo
95 ENDdbgPrintInstInfo
96 static void reportDBError(wrkrInstanceData_t *pWrkrData, int bSilent)
97 {
98 	char errMsg[512];
99 	unsigned uMySQLErrno;
100 	errno = 0;
101 	if(pWrkrData-&gt;hmysql == NULL) {
102 		LogError(0, NO_ERRCODE, "ommysql: unknown DB error occurred - could not obtain MySQL handle");
103 	} else { 		uMySQLErrno = mysql_errno(pWrkrData-&gt;hmysql);
104 		snprintf(errMsg, sizeof(errMsg), "db error (%u): %s\n", uMySQLErrno,
105 			mysql_error(pWrkrData-&gt;hmysql));
106 		if(bSilent || uMySQLErrno == pWrkrData-&gt;uLastMySQLErrno)
107 			dbgprintf("mysql, DBError(silent): %s\n", errMsg);
108 		else {
109 			pWrkrData-&gt;uLastMySQLErrno = uMySQLErrno;
110 			LogError(0, NO_ERRCODE, "ommysql: %s", errMsg);
111 		}
112 	}
113 	return;
114 }
115 static rsRetVal initMySQL(wrkrInstanceData_t *pWrkrData, int bSilent)
116 {
117 	instanceData *pData;
118 	DEFiRet;
119 	assert(pWrkrData-&gt;hmysql == NULL);
120 	pData = pWrkrData-&gt;pData;
121 	pthread_rwlock_unlock(&amp;rwlock_hmysql);
122 	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
123 	pWrkrData-&gt;hmysql = mysql_init(NULL);
124 	if(pWrkrData-&gt;hmysql == NULL) {
125 		LogError(0, RS_RET_SUSPENDED, "can not initialize MySQL handle");
126 		iRet = RS_RET_SUSPENDED;
127 	} else { 		mysql_options(pWrkrData-&gt;hmysql,MYSQL_READ_DEFAULT_GROUP,
128 		((pData-&gt;configsection!=NULL)?(char*)pData-&gt;configsection:"client"));
129 		if(pData-&gt;configfile!=NULL){
130 			FILE * fp;
131 			fp=fopen((char*)pData-&gt;configfile,"r");
132 			int err=errno;
133 			if(fp==NULL){
134 				char msg[512];
135 				snprintf(msg,sizeof(msg),"Could not open '%s' for reading",pData-&gt;configfile);
136 				if(bSilent) {
137 					char errStr[512];
138 					rs_strerror_r(err, errStr, sizeof(errStr));
139 					dbgprintf("mysql configuration error(%d): %s - %s\n",err,msg,errStr);
140 				} else
141 					LogError(err,NO_ERRCODE,"mysql configuration error: %s\n",msg);
142 			} else {
143 				fclose(fp);
144 				mysql_options(pWrkrData-&gt;hmysql,MYSQL_READ_DEFAULT_FILE,pData-&gt;configfile);
145 			}
146 		}
147 		if(mysql_real_connect(pWrkrData-&gt;hmysql, pData-&gt;dbsrv, pData-&gt;dbuid,
148 				      pData-&gt;dbpwd, pData-&gt;dbname, pData-&gt;dbsrvPort,
149 					  (const char *)pData-&gt;socket, 0) == NULL) {
150 			reportDBError(pWrkrData, bSilent);
151 			closeMySQL(pWrkrData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
152 		}
153 		if(mysql_autocommit(pWrkrData-&gt;hmysql, 0)) {
154 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "ommysql: activating autocommit failed, "
155 				"some data may be duplicated\n");
156 			reportDBError(pWrkrData, 0);
157 		}
158 	}
159 finalize_it:
160 	pthread_rwlock_unlock(&amp;rwlock_hmysql);
161 	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
162 	RETiRet;
163 }
164 static rsRetVal writeMySQL(wrkrInstanceData_t *pWrkrData, const uchar *const psz)
165 {
166 	DEFiRet;
167 	if(pWrkrData-&gt;hmysql == NULL) {
168 		CHKiRet(initMySQL(pWrkrData, 0));
169 	}
170 	if(mysql_query(pWrkrData-&gt;hmysql, (char*)psz)) {
171 		const int mysql_err = mysql_errno(pWrkrData-&gt;hmysql);
172 		if(mysql_err &lt; 2000 || mysql_err &gt; 2999) {
173 			reportDBError(pWrkrData, 0);
174 			LogError(0, RS_RET_DATAFAIL, "The error statement was: %s", psz);
175 			ABORT_FINALIZE(RS_RET_DATAFAIL);
176 		}
177 		closeMySQL(pWrkrData); 		CHKiRet(initMySQL(pWrkrData, 0)); 		if(mysql_query(pWrkrData-&gt;hmysql, (char*)psz)) { 			DBGPRINTF("ommysql: suspending due to failed write of '%s'\n", psz);
178 			reportDBError(pWrkrData, 0);
179 			closeMySQL(pWrkrData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
180 		}
181 	}
182 finalize_it:
183 	if(iRet == RS_RET_OK) {
184 		pWrkrData-&gt;uLastMySQLErrno = 0; 	}
185 	RETiRet;
186 }
187 BEGINtryResume
188 CODESTARTtryResume
189 	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
190 	if(pWrkrData-&gt;hmysql == NULL) {
191 		iRet = initMySQL(pWrkrData, 1);
192 	}
193 	pthread_rwlock_unlock(&amp;rwlock_hmysql);
194 ENDtryResume
195 BEGINbeginTransaction
196 CODESTARTbeginTransaction
197 ENDbeginTransaction
198 BEGINcommitTransaction
199 CODESTARTcommitTransaction
200 	DBGPRINTF("ommysql: commitTransaction\n");
201 	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
202 	CHKiRet(writeMySQL(pWrkrData, (uchar*)"START TRANSACTION"));
203 	for(unsigned i = 0 ; i &lt; nParams ; ++i) {
204 		iRet = writeMySQL(pWrkrData, actParam(pParams, 1, i, 0).param);
205 		if(iRet != RS_RET_OK
206 			&amp;&amp; iRet != RS_RET_DEFER_COMMIT
207 			&amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED) {
208 			if(mysql_rollback(pWrkrData-&gt;hmysql) != 0) {
209 				DBGPRINTF("ommysql: server error: transaction could not be rolled back\n");
210 			}
211 			closeMySQL(pWrkrData);
212 			FINALIZE;
213 		}
214 	}
215 	if(mysql_commit(pWrkrData-&gt;hmysql) != 0) {
216 		DBGPRINTF("ommysql: server error: transaction not committed\n");
217 		reportDBError(pWrkrData, 0);
218 		ABORT_FINALIZE(RS_RET_SUSPENDED);
219 	}
220 	DBGPRINTF("ommysql: transaction committed\n");
221 finalize_it:
222 	pthread_rwlock_unlock(&amp;rwlock_hmysql);
223 ENDcommitTransaction
224 static inline void
225 setInstParamDefaults(instanceData *pData)
226 {
227 	pData-&gt;dbsrvPort = 0;
228 	pData-&gt;configfile = NULL;
229 	pData-&gt;configsection = NULL;
230 	pData-&gt;tplName = NULL;
231 	pData-&gt;socket = NULL;
232 }
233 BEGINnewActInst
234 	struct cnfparamvals *pvals;
235 	int i;
236 <a name="1"></a>	char *cstr;
237 	size_t len;
238 CODESTARTnewActInst
239 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
240 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
241 	}
242 	CHKiRet(createInstance(&amp;pData));
243 	setInstParamDefaults(pData);
244 	CODE_STD_STRING_REQUESTparseSelectorAct(1)
245 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
246 		if(!pvals[i].bUsed)
247 			continue;
248 		if(!strcmp(actpblk.descr[i].name, "server")) {
249 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
250 			len = es_strlen(pvals[i].val.d.estr);
251 			if(len &gt;= sizeof(pData-&gt;dbsrv)-1) {
252 				parser_errmsg("ommysql: dbname parameter longer than supported "
253 					"maximum of %d characters", (int)sizeof(pData-&gt;dbsrv)-1);
254 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
255 <a name="3"></a>			}
256 			memcpy(pData-&gt;dbsrv, cstr, len+1);
257 			free(cstr);
258 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "serverport")) {
259 			pData-&gt;dbsrvPort = (int) pvals[i].val.d.n;
260 		} else if(!strcmp(actpblk.descr[i].name, "db")) {
261 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
262 			len = es_strlen(pvals[i].val.d.estr);
263 			if(len &gt;= sizeof(pData-&gt;dbname)-1) {
264 				parser_errmsg("ommysql: dbname parameter longer than supported "
265 					"maximum of %d characters", (int)sizeof(pData-&gt;dbname)-1);
266 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
267 			}
268 			memcpy(pData-&gt;dbname, cstr, len+1);
269 			free(cstr);
270 		} else if(!strcmp(actpblk.descr[i].name, "uid")) {
271 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
272 			len = es_strlen(pvals[i].val.d.estr);
273 			if(len &gt;= sizeof(pData-&gt;dbuid)-1) {
274 				parser_errmsg("ommysql: uid parameter longer than supported "
275 					"maximum of %d characters", (int)sizeof(pData-&gt;dbuid)-1);
276 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
277 			}
278 			memcpy(pData-&gt;dbuid, cstr, len+1);
279 			free(cstr);
280 		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
281 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
282 			len = es_strlen(pvals[i].val.d.estr);
283 			if(len &gt;= sizeof(pData-&gt;dbpwd)-1) {
284 				parser_errmsg("ommysql: pwd parameter longer than supported "
285 					"maximum of %d characters", (int)sizeof(pData-&gt;dbpwd)-1);
286 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
287 			}
288 			memcpy(pData-&gt;dbpwd, cstr, len+1);
289 			free(cstr);
290 		} else if(!strcmp(actpblk.descr[i].name, "mysqlconfig.file")) {
291 			pData-&gt;configfile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
292 		} else if(!strcmp(actpblk.descr[i].name, "mysqlconfig.section")) {
293 <a name="2"></a>			pData-&gt;configsection = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
294 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
295 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
296 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "socket")) {
297 			pData-&gt;socket = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
298 		} else {
299 			dbgprintf("ommysql: program error, non-handled "
300 			  "param '%s'\n", actpblk.descr[i].name);
301 		}
302 	}
303 	if(pData-&gt;tplName == NULL) {
304 		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup(" StdDBFmt"),
305 			OMSR_RQD_TPL_OPT_SQL));
306 	} else {</b></font>
307 		CHKiRet(OMSRsetEntry(*ppOMSR, 0,
308 			(uchar*) strdup((char*) pData-&gt;tplName),
309 			OMSR_RQD_TPL_OPT_SQL));
310 	}
311 CODE_STD_FINALIZERnewActInst
312 	cnfparamvalsDestruct(pvals, &amp;actpblk);
313 ENDnewActInst
314 BEGINparseSelectorAct
315 	int iMySQLPropErr = 0;
316 CODESTARTparseSelectorAct
317 CODE_STD_STRING_REQUESTparseSelectorAct(1)
318 	if(*p == '&gt;') {
319 	} else if(!strncmp((char*) p, ":ommysql:", sizeof(":ommysql:") - 1)) {
320 		p += sizeof(":ommysql:") - 1; 	} else {
321 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
322 	}
323 	CHKiRet(createInstance(&amp;pData));
324 	if(getSubString(&amp;p, pData-&gt;dbsrv, MAXHOSTNAMELEN+1, ','))
325 		iMySQLPropErr++;
326 	if(*pData-&gt;dbsrv == '\0')
327 		iMySQLPropErr++;
328 	if(getSubString(&amp;p, pData-&gt;dbname, _DB_MAXDBLEN+1, ','))
329 		iMySQLPropErr++;
330 	if(*pData-&gt;dbname == '\0')
331 		iMySQLPropErr++;
332 	if(getSubString(&amp;p, pData-&gt;dbuid, _DB_MAXUNAMELEN+1, ','))
333 		iMySQLPropErr++;
334 	if(*pData-&gt;dbuid == '\0')
335 		iMySQLPropErr++;
336 	if(getSubString(&amp;p, pData-&gt;dbpwd, _DB_MAXPWDLEN+1, ';'))
337 		iMySQLPropErr++;
338 	if(*(p-1) == ';')
339 	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*) " StdDBFmt"));
340 	if (iMySQLPropErr) {
341 		LogError(0, RS_RET_INVALID_PARAMS, "Trouble with MySQL connection properties. "
342 				"-MySQL logging disabled");
343 		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
344 	} else {
345 		pData-&gt;dbsrvPort = (unsigned) cs.iSrvPort;			pData-&gt;configfile = cs.pszMySQLConfigFile;
346 		pData-&gt;configsection = cs.pszMySQLConfigSection;
347 		pData-&gt;socket = NULL;
348 	}
349 CODE_STD_FINALIZERparseSelectorAct
350 ENDparseSelectorAct
351 BEGINmodExit
352 CODESTARTmodExit
353 	pthread_rwlock_destroy(&amp;rwlock_hmysql);
354 #	ifdef HAVE_MYSQL_LIBRARY_INIT
355 	mysql_library_end();
356 #	else
357 	mysql_server_end();
358 #	endif
359 ENDmodExit
360 BEGINqueryEtryPt
361 CODESTARTqueryEtryPt
362 CODEqueryEtryPt_STD_OMODTX_QUERIES
363 CODEqueryEtryPt_STD_OMOD8_QUERIES
364 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
365 ENDqueryEtryPt
366 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
367 {
368 	DEFiRet;
369 	cs.iSrvPort = 0; 	free(cs.pszMySQLConfigFile);
370 	cs.pszMySQLConfigFile = NULL;
371 	free(cs.pszMySQLConfigSection);
372 	cs.pszMySQLConfigSection = NULL;
373 	RETiRet;
374 }
375 BEGINmodInit()
376 CODESTARTmodInit
377 INITLegCnfVars
378 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
379 	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
380 	if(!bCoreSupportsBatching) {
381 		LogError(0, NO_ERRCODE, "ommysql: rsyslog core too old");
382 		ABORT_FINALIZE(RS_RET_ERR);
383 	}
384 	if(
385 #	ifdef HAVE_MYSQL_LIBRARY_INIT
386 	   mysql_library_init(0, NULL, NULL)
387 #	else
388 	   mysql_server_init(0, NULL, NULL)
389 #	endif
390 	                                   ) {
391 		LogError(0, NO_ERRCODE, "ommysql: initializing mysql client failed, plugin "
392 		                "can not run");
393 		ABORT_FINALIZE(RS_RET_ERR);
394 	}
395 	pthread_rwlock_init(&amp;rwlock_hmysql, NULL);
396 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionommysqlserverport", 0, eCmdHdlrInt, NULL, &amp;cs.iSrvPort,
397 	STD_LOADABLE_MODULE_ID));
398 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"ommysqlconfigfile",0,eCmdHdlrGetWord,NULL,&amp;cs.pszMySQLConfigFile,
399 	STD_LOADABLE_MODULE_ID));
400 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"ommysqlconfigsection",0,eCmdHdlrGetWord,NULL,&amp;cs.pszMySQLConfigSection,
401 	STD_LOADABLE_MODULE_ID));
402 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
403 	NULL, STD_LOADABLE_MODULE_ID));
404 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttpfs.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;curl/curl.h&gt;
12 #include &lt;json.h&gt;
13 #include &lt;json_object.h&gt;
14 #include "conf.h"
15 #include "syslogd-types.h"
16 #include "srUtils.h"
17 #include "template.h"
18 #include "module-template.h"
19 #include "errmsg.h"
20 #include "cfsysline.h"
21 #include "datetime.h"
22 #include "statsobj.h"
23 #include "unicode-helper.h"
24 MODULE_TYPE_OUTPUT
25 MODULE_TYPE_NOKEEP
26 MODULE_CNFNAME("omhttpfs")
27 DEF_OMOD_STATIC_DATA
28 DEFobjCurrIf(glbl)
29 DEFobjCurrIf(datetime)
30 #define OMHTTPFS_VERSION "1.0"
31 #define OMHTTPFS_DEFAULT_PORT 14000
32 #define OMHTTPFS_DEFAULT_USER "hdfs"
33 #define OMHTTPFS_DEFAULT_HOST "127.0.0.1"
34 #define HTTPFS_URL_PREFIX_V1     "/webhdfs/v1"
35 #define HTTPFS_URL_PREFIX_V1_SSL "/swebhdfs/v1"
36 #define HTTPFS_CONTENT_TYPE      "Content-Type: application/octet-stream"
37 #define HTTPFS_USER_AGENT        "omhttpfs by sskaje/" OMHTTPFS_VERSION
38 #define HTTPFS_CONTENT_TYPE_JSON "application/json"
39 #define HTTPFS_JSON_BOOLEAN_TRUE "{\"boolean\":true}"
40 #define HTTPFS_FILEALREADYEXISTSEXCEPTION "FileAlreadyExistsException"
41 #define HTTPFS_URL_BUFFER_LENGTH 2048
42 #define DPP(x) DBGPRINTF("OMHTTPFS: %s:%d %s(): %s\n", __FILE__, __LINE__, __FUNCTION__, x)
43 typedef struct _HTTPFS_JSON_REMOTE_EXCEPTION {
44 	char message[1024];
45 	char exception[256];
46 	char class[256];
47 } httpfs_json_remote_exception;
48 typedef struct _instanceData {
49 	sbool https;
50 	uchar* host;
51 	uchar* ip;
52 	int  port;
53 	uchar* user;
54 	int timeout;
55 	uchar* file;
56 	sbool isDynFile;
57 	uchar* tplName;
58 } instanceData;
59 typedef struct wrkrInstanceData {
60 	instanceData *pData;
61 	CURL* curl;
62 	uchar* file;
63 	int replyLen;
64 	char* reply;
65 } wrkrInstanceData_t;
66 <a name="0"></a>static struct cnfparamdescr actpdescr[] = {
67 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "host", eCmdHdlrGetWord, 0 },
68 	{ "port", eCmdHdlrInt, 0 },
69 	{ "user", eCmdHdlrGetWord, 0 },
70 	{ "https", eCmdHdlrBinary, 0 },
71 	{ "file", eCmdHdlrGetWord, CNFPARAM_REQUIRED },
72 	{ "isdynfile", eCmdHdlrBinary, 0 },
73 	{ "template", eCmdHdlrGetWord, 0 },
74 };
75 static struct cnfparamblk actpblk = {
76 	CNFPARAMBLK_VERSION,
77 	sizeof(actpdescr)/sizeof(struct cnfparamdescr),
78 	actpdescr
79 };</b></font>
80 static rsRetVal
81 httpfs_init_curl(wrkrInstanceData_t *pWrkrData, instanceData *pData)
82 {
83 	CURL *curl = NULL;
84 	curl = curl_easy_init();
85 	if (curl) {
86 		curl_easy_setopt(curl, CURLOPT_VERBOSE, 0L);
87 		curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
88 		if (pData-&gt;https) {
89 			DBGPRINTF("%s(): Enable HTTPS\n", __FUNCTION__);
90 			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
91 			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
92 		}
93 	} else {
94 		LogError(0, RS_RET_OBJ_CREATION_FAILED, "omhttpfs: failed to init cURL\n");
95 		return RS_RET_OBJ_CREATION_FAILED;
96 	}
97 	curl_easy_setopt(curl, CURLOPT_USERAGENT, HTTPFS_USER_AGENT);
98 	pWrkrData-&gt;curl = curl;
99 	return RS_RET_OK;
100 }
101 static rsRetVal
102 httpfs_build_url(wrkrInstanceData_t *pWrkrData, const char* op, es_str_t** url_buf)
103 {
104 	*url_buf = es_newStr(HTTPFS_URL_BUFFER_LENGTH);
105 	if (pWrkrData-&gt;pData-&gt;https) {
106 	    es_addBuf(url_buf, "https://", sizeof("https://")-1);
107 	} else {
108 	    es_addBuf(url_buf, "http://", sizeof("http://")-1);
109 	}
110 	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;host, strlen((char*)pWrkrData-&gt;pData-&gt;host));
111 	es_addChar(url_buf, ':');
112 	char portBuf[6];
113 	snprintf(portBuf, sizeof(portBuf), "%d", pWrkrData-&gt;pData-&gt;port);
114 	es_addBuf(url_buf, portBuf, strlen(portBuf));
115 	es_addBuf(url_buf, HTTPFS_URL_PREFIX_V1, sizeof(HTTPFS_URL_PREFIX_V1)-1);
116 	if (pWrkrData-&gt;file[0] != '/') {
117 	    es_addChar(url_buf, '/');
118 	}
119 	es_addBuf(url_buf, (char* )pWrkrData-&gt;file, strlen((char* )pWrkrData-&gt;file));
120 	es_addBuf(url_buf, "?user.name=", sizeof("?user.name=")-1);
121 	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;user, strlen((char* )pWrkrData-&gt;pData-&gt;user));
122 	es_addBuf(url_buf, op, strlen(op));
123 	return RS_RET_OK;
124 }
125 static void httpfs_set_url(wrkrInstanceData_t *pWrkrData, const char* op)
126 {
127 	es_str_t* url;
128 	char* url_cstr;
129 	httpfs_build_url(pWrkrData, op, &amp;url);
130 	url_cstr = es_str2cstr(url, NULL);
131 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_URL, url_cstr);
132 	free(url_cstr);
133 }
134 static void httpfs_curl_set_put(CURL* curl)
135 {
136 	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
137 	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
138 	curl_easy_setopt(curl, CURLOPT_POST, 0L);
139 	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
140 	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
141 	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT");
142 }
143 static void httpfs_curl_set_post(CURL* curl)
144 {
145 	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
146 	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
147 	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
148 	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
149 	curl_easy_setopt(curl, CURLOPT_POST, 1L);
150 	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");
151 }
152 static struct curl_slist*
153 httpfs_curl_add_header(struct curl_slist* headers, int hdr_count, ...)
154 {
155 	const char* hdr;
156 	va_list ar;
157 	va_start(ar, hdr_count);
158 	for (; hdr_count &gt; 0; hdr_count--) {
159 	    hdr = va_arg(ar, const char*);
160 	    if (hdr != NULL
161 	            &amp;&amp; hdr[0] != 0) {
162 	        headers = curl_slist_append(headers, hdr);
163 	    } else {
164 	        break;
165 	    }
166 	}
167 	va_end(ar);
168 	headers = curl_slist_append(headers, "Expect:");
169 	headers = curl_slist_append(headers, "Transfer-Encoding:");
170 	return headers;
171 }
172 static size_t
173 httpfs_curl_result_callback(void *contents, size_t size, size_t nmemb, void *userp)
174 {
175 	size_t realsize = size * nmemb;
176 	char *newreply = NULL;
177 	wrkrInstanceData_t *mem = (wrkrInstanceData_t *)userp;
178 	newreply = realloc(mem-&gt;reply, mem-&gt;replyLen + realsize + 1);
179 	if (newreply == NULL) {
180 	    dbgprintf("not enough memory (realloc returned NULL)\n");
181 	    if (mem-&gt;reply != NULL)
182 	        free(mem-&gt;reply);
183 	    mem-&gt;reply = NULL;
184 	    mem-&gt;replyLen = 0;
185 	    return 0;
186 	}
187 	mem-&gt;reply = newreply;
188 	memcpy(&amp;(mem-&gt;reply[mem-&gt;replyLen]), contents, realsize);
189 	mem-&gt;replyLen += realsize;
190 	mem-&gt;reply[mem-&gt;replyLen] = 0;
191 	return realsize;
192 }
193 #define HTTPFS_CURL_VARS_INIT \
194 	struct curl_slist* headers = NULL; \
195 	long response_code; \
196 	CURLcode res; \
197 	char* content_type;
198 #define HTTPFS_CURL_VARS_RELEASE \
199 	curl_slist_free_all(headers);
200 #define HTTPFS_CURL_EXEC \
201 	pWrkrData-&gt;reply = NULL; \
202 	pWrkrData-&gt;replyLen = 0; \
203 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEDATA, pWrkrData); \
204 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEFUNCTION, httpfs_curl_result_callback); \
205 	res = curl_easy_perform(pWrkrData-&gt;curl); \
206 	if (res == CURLE_OK) { \
207 	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_CONTENT_TYPE, &amp;content_type); \
208 	    if (strncmp(content_type, HTTPFS_CONTENT_TYPE_JSON, strlen(HTTPFS_CONTENT_TYPE_JSON))) { \
209 	    } \
210 	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code); \
211 	    if (pWrkrData-&gt;reply != NULL) { \
212 	        pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0'; \
213 	    } \
214 	} else { \
215 	LogError(0, RS_RET_ERR, "CURL request fail, code=%d, error string=%s\n", res, curl_easy_strerror(res)); \
216 	    return -1; \
217 	}
218 static rsRetVal
219 httpfs_parse_exception(char* buf, int length, httpfs_json_remote_exception* jre)
220 {
221 	DEFiRet;
222 	if (!length) {
223 	    return RS_RET_JSON_PARSE_ERR;
224 	}
225 	struct json_tokener* jt = json_tokener_new();
226 	json_tokener_reset(jt);
227 	struct json_object *json;
228 	json = json_tokener_parse_ex(jt, buf, length);
229 	if (!json_object_is_type(json, json_type_object)) {
230 		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
231 	}
232 	if (!json_object_object_get_ex(json, "RemoteException", &amp;json)) {
233 	ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
234 	}
235 	struct json_object *jobj;
236 	memset(jre, 0, sizeof(*jre));
237 	const char *str;
238 	json_object_object_get_ex(json, "javaClassName", &amp;jobj);
239 	str = json_object_get_string(jobj);
240 	strncpy(jre-&gt;class, str, sizeof(jre-&gt;class));
241 	jre-&gt;class[sizeof(jre-&gt;class)-1] = '\0';
242 	json_object_object_get_ex(json, "exception", &amp;jobj);
243 	str = json_object_get_string(jobj);
244 	strncpy(jre-&gt;exception, str, sizeof(jre-&gt;exception));
245 	jre-&gt;exception[sizeof(jre-&gt;exception)-1] = '\0';
246 	json_object_object_get_ex(json, "message", &amp;jobj);
247 	str = json_object_get_string(jobj);
248 	strncpy(jre-&gt;message, str, sizeof(jre-&gt;message));
249 	jre-&gt;message[sizeof(jre-&gt;message)-1] = '\0';
250 finalize_it:
251 	if(jt != NULL)
252 		json_tokener_free(jt);
253 	if(json != NULL)
254 		json_object_put(json);
255 	RETiRet;
256 }
257 static rsRetVal
258 httpfs_create_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
259 {
260 HTTPFS_CURL_VARS_INIT
261 	DBGPRINTF("%s(): file=%s\n", __FUNCTION__, pWrkrData-&gt;file);
262 	httpfs_curl_set_put(pWrkrData-&gt;curl);
263 	httpfs_set_url(pWrkrData, "&amp;op=create&amp;overwrite=false&amp;data=true");
264 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
265 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));
266 	DBGPRINTF("%s(): msg=%s\n", __FUNCTION__, buf);
267 	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
268 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
269 HTTPFS_CURL_EXEC
270 	int success = 0;
271 	if (response_code == 201) {
272 	    success = 1;
273 	}
274 HTTPFS_CURL_VARS_RELEASE
275 	if (success) {
276 	    return RS_RET_OK;
277 	} else {
278 	    return RS_RET_FALSE;
279 	}
280 }
281 static rsRetVal
282 httpfs_append_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
283 {
284 HTTPFS_CURL_VARS_INIT
285 	DBGPRINTF("%s(): file=%s\n", __FUNCTION__, pWrkrData-&gt;file);
286 	httpfs_curl_set_post(pWrkrData-&gt;curl);
287 	httpfs_set_url(pWrkrData, "&amp;op=append&amp;data=true");
288 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
289 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));
290 	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
291 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
292 	DBGPRINTF("%s(): msg=%s\n", __FUNCTION__, buf);
293 HTTPFS_CURL_EXEC
294 	int success = 0;
295 	if (response_code == 200) {
296 	    success = 1;
297 	} else if (response_code == 404) {
298 	}
299 HTTPFS_CURL_VARS_RELEASE
300 	if (success) {
301 	    return RS_RET_OK;
302 	} else {
303 	    return RS_RET_FALSE;
304 	}
305 }
306 static rsRetVal
307 httpfs_log(wrkrInstanceData_t *pWrkrData, uchar* buf)
308 {
309 	DEFiRet;
310 	long response_code;
311 	httpfs_json_remote_exception jre;
312 	iRet = httpfs_append_file(pWrkrData, buf);
313 	if (iRet == RS_RET_OK) {
314 	    DBGPRINTF("omhttpfs: Append success: %s\n", pWrkrData-&gt;file);
315 	    return RS_RET_OK;
316 	}
317 	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
318 	if (response_code != 404) {
319 	    DBGPRINTF("omhttpfs: Append fail HTTP %ld: %s\n", response_code, pWrkrData-&gt;file);
320 	    return RS_RET_FALSE;
321 	}
322 	iRet = httpfs_create_file(pWrkrData, buf);
323 	if (iRet == RS_RET_OK) {
324 	    DBGPRINTF("omhttpfs: Create file success: %s\n", pWrkrData-&gt;file);
325 	    return RS_RET_OK;
326 	}
327 	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
328 	if (response_code == 201) {
329 	    DBGPRINTF("omhttpfs: Create file success HTTP 201: %s\n", pWrkrData-&gt;file);
330 	    return RS_RET_OK;
331 	}
332 	if (response_code == 500) {
333 	    DBGPRINTF("omhttpfs: Create file failed HTTP %ld: %s\n", response_code, pWrkrData-&gt;file);
334 	    httpfs_parse_exception(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen, &amp;jre);
335 	    if (!strncmp(jre.exception, HTTPFS_FILEALREADYEXISTSEXCEPTION, strlen(HTTPFS_FILEALREADYEXISTSEXCEPTION))) {
336 	        DBGPRINTF("omhttpfs: File already exists, append again: %s\n", pWrkrData-&gt;file);
337 	        iRet = httpfs_append_file(pWrkrData, buf);
338 	        if (iRet == RS_RET_OK) {
339 	            DBGPRINTF("omhttpfs: Re-Append success: %s\n", pWrkrData-&gt;file);
340 	            return RS_RET_OK;
341 	        } else {
342 	            DBGPRINTF("omhttpfs: Re-Append failed: %s\n", pWrkrData-&gt;file);
343 	        }
344 	    } else {
345 	        DBGPRINTF("omhttpfs: Create file failed: %s %s\n", pWrkrData-&gt;file, pWrkrData-&gt;reply);
346 	    }
347 	} else {
348 	    DBGPRINTF("omhttpfs: Create file failed: %s %s\n", pWrkrData-&gt;file, pWrkrData-&gt;reply);
349 	}
350 	return RS_RET_FALSE;
351 }
352 BEGINinitConfVars
353 	CODESTARTinitConfVars
354 ENDinitConfVars
355 BEGINcreateInstance
356 CODESTARTcreateInstance
357 	DBGPRINTF("omhttpfs: createInstance\n");
358 ENDcreateInstance
359 BEGINcreateWrkrInstance
360 CODESTARTcreateWrkrInstance
361 	DBGPRINTF("omhttpfs: createWrkrInstance\n");
362 	pWrkrData-&gt;curl = NULL;
363 	iRet = httpfs_init_curl(pWrkrData, pWrkrData-&gt;pData);
364 	DBGPRINTF("omhttpfs: createWrkrInstance,pData %p/%p, pWrkrData %p\n",
365 	pData, pWrkrData-&gt;pData, pWrkrData);
366 ENDcreateWrkrInstance
367 BEGINisCompatibleWithFeature
368 CODESTARTisCompatibleWithFeature
369 	if(eFeat == sFEATURERepeatedMsgReduction)
370 	    iRet = RS_RET_OK;
371 ENDisCompatibleWithFeature
372 BEGINfreeInstance
373 CODESTARTfreeInstance
374 	free(pData-&gt;file);
375 	free(pData-&gt;tplName);
376 	free(pData-&gt;host);
377 	free(pData-&gt;user);
378 ENDfreeInstance
379 BEGINfreeWrkrInstance
380 CODESTARTfreeWrkrInstance
381 	free(pWrkrData-&gt;file);
382 	if(pWrkrData-&gt;curl) {
383 	    curl_easy_cleanup(pWrkrData-&gt;curl);
384 	    pWrkrData-&gt;curl = NULL;
385 	}
386 ENDfreeWrkrInstance
387 BEGINdbgPrintInstInfo
388 CODESTARTdbgPrintInstInfo
389 	DBGPRINTF("OmHTTPFS\n");
390 	DBGPRINTF("Version: %s\n", OMHTTPFS_VERSION);
391 	DBGPRINTF("\tHost: %s\n", pData-&gt;host);
392 	DBGPRINTF("\tPort: %d\n", pData-&gt;port);
393 	DBGPRINTF("\tUser: %s\n", pData-&gt;user);
394 	DBGPRINTF("\tFile: %s\n", pData-&gt;file);
395 ENDdbgPrintInstInfo
396 BEGINtryResume
397 CODESTARTtryResume
398 	DBGPRINTF("omhttpfs: tryResume called\n");
399 	iRet = RS_RET_OK;
400 ENDtryResume
401 BEGINdoAction
402 CODESTARTdoAction
403 	DBGPRINTF("omhttpfs: doAction\n");
404 	if (pWrkrData-&gt;pData-&gt;isDynFile) {
405 	    pWrkrData-&gt;file = ustrdup(ppString[1]);
406 	} else {
407 	    pWrkrData-&gt;file = ustrdup(pWrkrData-&gt;pData-&gt;file);
408 	}
409 	iRet = httpfs_log(pWrkrData, ppString[0]);
410 	if(iRet != RS_RET_OK) {
411 	    DBGPRINTF("omhttpfs: error writing httpfs, suspending\n");
412 	    iRet = RS_RET_SUSPENDED;
413 	}
414 ENDdoAction
415 static void
416 setInstParamDefaults(instanceData *pData)
417 {
418 	pData-&gt;host = (uchar*) strdup(OMHTTPFS_DEFAULT_HOST);
419 	pData-&gt;port = OMHTTPFS_DEFAULT_PORT;
420 	pData-&gt;user = (uchar*) strdup(OMHTTPFS_DEFAULT_USER);
421 	pData-&gt;https = 0;
422 	pData-&gt;file = NULL;
423 	pData-&gt;isDynFile = 0;
424 	pData-&gt;tplName = NULL;
425 }
426 BEGINnewActInst
427 	struct cnfparamvals *pvals;
428 <a name="1"></a>	int i;
429 	uchar *tplToUse;
430 CODESTARTnewActInst
431 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
432 	    ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
433 	}
434 	CHKiRet(createInstance(&amp;pData));
435 	setInstParamDefaults(pData);
436 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
437 	    if(!pvals[i].bUsed)
438 <a name="3"></a>	        continue;
439 	    if(!strcmp(actpblk.descr[i].name, "host")) {
440 	        pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
441 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	    } else if(!strcmp(actpblk.descr[i].name, "port")) {
442 	        pData-&gt;port = (int) pvals[i].val.d.n;
443 	    } else if(!strcmp(actpblk.descr[i].name, "user")) {
444 	        pData-&gt;user = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
445 	    } else if(!strcmp(actpblk.descr[i].name, "https")) {
446 	        pData-&gt;https = pvals[i].val.d.n ? 1 : 0;
447 	    } else if(!strcmp(actpblk.descr[i].name, "file")) {
448 	        pData-&gt;file = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
449 <a name="2"></a>	    } else if(!strcmp(actpblk.descr[i].name, "isdynfile")) {
450 	        pData-&gt;isDynFile = pvals[i].val.d.n ? 1 : 0;
451 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	    } else if(!strcmp(actpblk.descr[i].name, "template")) {
452 	        pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
453 	    } else {
454 	        DBGPRINTF("omhttpfs: program error, non-handled param '%s'\n", actpblk.descr[i].name);
455 	    }
456 	}
457 	if(pData-&gt;file == NULL) {
458 	    LogError(0, RS_RET_INTERNAL_ERROR, "omhttpfs: file is not set "
459 		"[this should not be possible]\n");
460 	ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
461 	}</b></font>
462 	if(pData-&gt;user == NULL || pData-&gt;user[0] == '\0') {
463 	    pData-&gt;user = ustrdup((uchar*) OMHTTPFS_DEFAULT_USER);
464 	}
465 	if(pData-&gt;host == NULL || pData-&gt;host[0] == '\0') {
466 	    pData-&gt;host = ustrdup((uchar*) OMHTTPFS_DEFAULT_HOST);
467 	}
468 	if (pData-&gt;isDynFile) {
469 	    CODE_STD_STRING_REQUESTparseSelectorAct(2)
470 	    CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;file), OMSR_NO_RQD_TPL_OPTS));
471 	} else {
472 	    CODE_STD_STRING_REQUESTparseSelectorAct(1)
473 	}
474 	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? (uchar* ) "RSYSLOG_FileFormat" : pData-&gt;tplName);
475 	iRet = OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS);
476 CODE_STD_FINALIZERnewActInst
477 	cnfparamvalsDestruct(pvals, &amp;actpblk);
478 ENDnewActInst
479 NO_LEGACY_CONF_parseSelectorAct
480 BEGINmodExit
481 CODESTARTmodExit
482 	curl_global_cleanup();
483 	objRelease(datetime, CORE_COMPONENT);
484 	objRelease(glbl, CORE_COMPONENT);
485 ENDmodExit
486 BEGINqueryEtryPt
487 CODESTARTqueryEtryPt
488 	CODEqueryEtryPt_STD_OMOD_QUERIES
489 	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
490 	CODEqueryEtryPt_STD_OMOD8_QUERIES
491 	CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
492 ENDqueryEtryPt
493 BEGINmodInit()
494 CODESTARTmodInit
495 INITLegCnfVars
496 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
497 	CHKiRet(objUse(glbl, CORE_COMPONENT));
498 	CHKiRet(objUse(datetime, CORE_COMPONENT));
499 	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
500 	    LogError(0, RS_RET_OBJ_CREATION_FAILED, "CURL fail. -httpfs module init failed");
501 	    ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
502 	}
503 	DBGPRINTF("omhttpfs version %s is initializing\n", OMHTTPFS_VERSION);
504 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
