<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ommysql.c & omhttpfs.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ommysql.c & omhttpfs.c
      </h3>
      <h1 align="center">
        16.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ommysql.c (17.1875%)<TH>omhttpfs.c (15.602837%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match270-0.html#0',2,'match270-1.html#0',3)" NAME="0">(88-100)<TD><A HREF="javascript:ZweiFrames('match270-0.html#0',2,'match270-1.html#0',3)" NAME="0">(130-142)</A><TD ALIGN=center><FONT COLOR="#ff0000">23</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match270-0.html#1',2,'match270-1.html#1',3)" NAME="1">(376-388)<TD><A HREF="javascript:ZweiFrames('match270-0.html#1',2,'match270-1.html#1',3)" NAME="1">(743-754)</A><TD ALIGN=center><FONT COLOR="#b10000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match270-0.html#2',2,'match270-1.html#2',3)" NAME="2">(435-446)<TD><A HREF="javascript:ZweiFrames('match270-0.html#2',2,'match270-1.html#2',3)" NAME="2">(769-783)</A><TD ALIGN=center><FONT COLOR="#a60000">15</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match270-0.html#3',2,'match270-1.html#3',3)" NAME="3">(397-400)<TD><A HREF="javascript:ZweiFrames('match270-0.html#3',2,'match270-1.html#3',3)" NAME="3">(755-758)</A><TD ALIGN=center><FONT COLOR="#850000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ommysql.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ommysql.c
 * This is the implementation of the build-in output module for MySQL.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * File begun on 2007-07-20 by RGerhards (extracted from syslogd.c)
 *
 * Copyright 2007-2021 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;netdb.h&gt;
#include &lt;mysql.h&gt;
#include &lt;mysqld_error.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;parserif.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;ommysql&quot;)

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

/* internal structures
 */
DEF_OMOD_STATIC_DATA

typedef struct _instanceData {
	char	dbsrv[MAXHOSTNAMELEN+1];	/* IP or hostname of DB server*/
	unsigned int dbsrvPort;		/* port of MySQL server */
	char	dbname[_DB_MAXDBLEN+1];	/* DB name */
	char	dbuid[_DB_MAXUNAMELEN+1];	/* DB user */
	char	dbpwd[_DB_MAXPWDLEN+1];	/* DB user's password */
	uchar   *configfile;			/* MySQL Client Configuration File */
	uchar   *configsection;		/* MySQL Client Configuration Section */
	uchar	*tplName;			/* format template to use */
	uchar	*socket;			/* MySQL socket path */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	MYSQL	*hmysql;			/* handle to MySQL */
	unsigned uLastMySQLErrno;		/* last errno returned by MySQL or 0 if all is well */
} wrkrInstanceData_t;

typedef struct configSettings_s {
	int iSrvPort;				/* database server port */
	uchar *pszMySQLConfigFile;	/* MySQL Client Configuration File */
	uchar *pszMySQLConfigSection;	/* MySQL Client Configuration Section */
} configSettings_t;
static configSettings_t cs;

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
<A NAME="0"></A>static struct cnfparamdescr actpdescr[] = {
	{ &quot;server&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;db&quot;, eCmdHdlrGetWord, 1 },
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match270-1.html#0',3,'match270-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;uid&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;pwd&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;serverport&quot;, eCmdHdlrInt, 0 },
	{ &quot;mysqlconfig.file&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;mysqlconfig.section&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;socket&quot;, eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

/* we need to synchronize access to the mysql handle, because multiple threads
 * use it and we may need to (re)init it during processing. This could lead to
 * races with potentially wrong addresses or NULL accesses.
 */
pthread_rwlock_t rwlock_hmysql;

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	resetConfigVariables(NULL, NULL);
ENDinitConfVars


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
	pWrkrData-&gt;hmysql = NULL;
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


/* The following function is responsible for closing a
 * MySQL connection.
 * Initially added 2004-10-28
 */
static void closeMySQL(wrkrInstanceData_t *pWrkrData)
{
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
	if(pWrkrData-&gt;hmysql != NULL) {	/* just to be on the safe side... */
		mysql_close(pWrkrData-&gt;hmysql);
		pWrkrData-&gt;hmysql = NULL;
	}
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
}

BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;configfile);
	free(pData-&gt;configsection);
	free(pData-&gt;tplName);
	free(pData-&gt;socket);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	closeMySQL(pWrkrData);
	mysql_thread_end();
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	/* nothing special here */
ENDdbgPrintInstInfo


/* log a database error with descriptive message.
 * We check if we have a valid MySQL handle. If not, we simply
 * report an error, but can not be specific. RGerhards, 2007-01-30
 */
static void reportDBError(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	char errMsg[512];
	unsigned uMySQLErrno;

	/* output log message */
	errno = 0;
	if(pWrkrData-&gt;hmysql == NULL) {
		LogError(0, NO_ERRCODE, &quot;ommysql: unknown DB error occurred - could not obtain MySQL handle&quot;);
	} else { /* we can ask mysql for the error description... */
		uMySQLErrno = mysql_errno(pWrkrData-&gt;hmysql);
		snprintf(errMsg, sizeof(errMsg), &quot;db error (%u): %s\n&quot;, uMySQLErrno,
			mysql_error(pWrkrData-&gt;hmysql));
		if(bSilent || uMySQLErrno == pWrkrData-&gt;uLastMySQLErrno)
			dbgprintf(&quot;mysql, DBError(silent): %s\n&quot;, errMsg);
		else {
			pWrkrData-&gt;uLastMySQLErrno = uMySQLErrno;
			LogError(0, NO_ERRCODE, &quot;ommysql: %s&quot;, errMsg);
		}
	}

	return;
}


/* The following function is responsible for initializing a
 * MySQL connection.
 * Initially added 2004-10-28 mmeckelein
 */
static rsRetVal initMySQL(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	instanceData *pData;
	DEFiRet;

	assert(pWrkrData-&gt;hmysql == NULL);
	pData = pWrkrData-&gt;pData;

	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_wrlock(&amp;rwlock_hmysql);

	pWrkrData-&gt;hmysql = mysql_init(NULL);
	if(pWrkrData-&gt;hmysql == NULL) {
		LogError(0, RS_RET_SUSPENDED, &quot;can not initialize MySQL handle&quot;);
		iRet = RS_RET_SUSPENDED;
	} else { /* we could get the handle, now on with work... */
		mysql_options(pWrkrData-&gt;hmysql,MYSQL_READ_DEFAULT_GROUP,
		((pData-&gt;configsection!=NULL)?(char*)pData-&gt;configsection:&quot;client&quot;));
		if(pData-&gt;configfile!=NULL){
			FILE * fp;
			fp=fopen((char*)pData-&gt;configfile,&quot;r&quot;);
			int err=errno;
			if(fp==NULL){
				char msg[512];
				snprintf(msg,sizeof(msg),&quot;Could not open '%s' for reading&quot;,pData-&gt;configfile);
				if(bSilent) {
					char errStr[512];
					rs_strerror_r(err, errStr, sizeof(errStr));
					dbgprintf(&quot;mysql configuration error(%d): %s - %s\n&quot;,err,msg,errStr);
				} else
					LogError(err,NO_ERRCODE,&quot;mysql configuration error: %s\n&quot;,msg);
			} else {
				fclose(fp);
				mysql_options(pWrkrData-&gt;hmysql,MYSQL_READ_DEFAULT_FILE,pData-&gt;configfile);
			}
		}
		/* Connect to database */
		if(mysql_real_connect(pWrkrData-&gt;hmysql, pData-&gt;dbsrv, pData-&gt;dbuid,
				      pData-&gt;dbpwd, pData-&gt;dbname, pData-&gt;dbsrvPort,
					  (const char *)pData-&gt;socket, 0) == NULL) {
			reportDBError(pWrkrData, bSilent);
			closeMySQL(pWrkrData); /* ignore any error we may get */
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		if(mysql_autocommit(pWrkrData-&gt;hmysql, 0)) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;ommysql: activating autocommit failed, &quot;
				&quot;some data may be duplicated\n&quot;);
			reportDBError(pWrkrData, 0);
		}
	}

finalize_it:
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	RETiRet;
}


/* The following function writes the current log entry
 * to an established MySQL session.
 * Initially added 2004-10-28 mmeckelein
 */
static rsRetVal writeMySQL(wrkrInstanceData_t *pWrkrData, const uchar *const psz)
{
	DEFiRet;

	/* see if we are ready to proceed */
	if(pWrkrData-&gt;hmysql == NULL) {
		CHKiRet(initMySQL(pWrkrData, 0));
	}

	/* try insert */
	if(mysql_query(pWrkrData-&gt;hmysql, (char*)psz)) {
		const int mysql_err = mysql_errno(pWrkrData-&gt;hmysql);
		/* We assume server error codes are non-recoverable, mainly data errors.
		 * This also means we need to differentiate between client and server error
		 * codes. Unfortunately, the API does not provide a specified function for
		 * this. Howerver, error codes 2000..2999 are currently client error codes.
		 * So we use this as guideline.
		 */
		if(mysql_err &lt; 2000 || mysql_err &gt; 2999) {
			reportDBError(pWrkrData, 0);
			LogError(0, RS_RET_DATAFAIL, &quot;The error statement was: %s&quot;, psz);
			ABORT_FINALIZE(RS_RET_DATAFAIL);
		}
		/* potentially recoverable error occurred, try to re-init connection and retry */
		closeMySQL(pWrkrData); /* close the current handle */
		CHKiRet(initMySQL(pWrkrData, 0)); /* try to re-open */
		if(mysql_query(pWrkrData-&gt;hmysql, (char*)psz)) { /* re-try insert */
			/* we failed, giving up for now */
			DBGPRINTF(&quot;ommysql: suspending due to failed write of '%s'\n&quot;, psz);
			reportDBError(pWrkrData, 0);
			closeMySQL(pWrkrData); /* free ressources */
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}

finalize_it:
	if(iRet == RS_RET_OK) {
		pWrkrData-&gt;uLastMySQLErrno = 0; /* reset error for error supression */
	}

	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	if(pWrkrData-&gt;hmysql == NULL) {
		iRet = initMySQL(pWrkrData, 1);
	}
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDtryResume

BEGINbeginTransaction
CODESTARTbeginTransaction
	// NOTHING TO DO IN HERE
ENDbeginTransaction

BEGINcommitTransaction
CODESTARTcommitTransaction
	DBGPRINTF(&quot;ommysql: commitTransaction\n&quot;);
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	CHKiRet(writeMySQL(pWrkrData, (uchar*)&quot;START TRANSACTION&quot;));

	for(unsigned i = 0 ; i &lt; nParams ; ++i) {
		iRet = writeMySQL(pWrkrData, actParam(pParams, 1, i, 0).param);
		if(iRet != RS_RET_OK
			&amp;&amp; iRet != RS_RET_DEFER_COMMIT
			&amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED) {
			if(mysql_rollback(pWrkrData-&gt;hmysql) != 0) {
				DBGPRINTF(&quot;ommysql: server error: transaction could not be rolled back\n&quot;);
			}
			closeMySQL(pWrkrData);
			FINALIZE;
		}
	}

	if(mysql_commit(pWrkrData-&gt;hmysql) != 0) {
		DBGPRINTF(&quot;ommysql: server error: transaction not committed\n&quot;);
		reportDBError(pWrkrData, 0);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
	DBGPRINTF(&quot;ommysql: transaction committed\n&quot;);
finalize_it:
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDcommitTransaction

static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;dbsrvPort = 0;
	pData-&gt;configfile = NULL;
	pData-&gt;configsection = NULL;
	pData-&gt;tplName = NULL;
	pData-&gt;socket = NULL;
}


/* note: we use the fixed-size buffers inside the config object to avoid
 * changing too much of the previous plumbing. rgerhards, 2012-02-02
 */
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
<A NAME="1"></A>	char *cstr;
	size_t len;
CODESTARTnewActInst
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match270-1.html#1',3,'match270-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	CODE_STD_STRING_REQUESTparseSelectorAct(1)
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;server&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbsrv)-1) {
				parser_errmsg(&quot;ommysql: dbname parameter longer than supported &quot;
					&quot;maximum of %d characters&quot;, (int)sizeof(pData-&gt;dbsrv)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
<A NAME="3"></A>			}
			memcpy(pData-&gt;dbsrv, cstr, len+1);
			free(cstr);
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match270-1.html#3',3,'match270-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;serverport&quot;)) {
			pData-&gt;dbsrvPort = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;db&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbname)-1) {
				parser_errmsg(&quot;ommysql: dbname parameter longer than supported &quot;
					&quot;maximum of %d characters&quot;, (int)sizeof(pData-&gt;dbname)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbname, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, &quot;uid&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbuid)-1) {
				parser_errmsg(&quot;ommysql: uid parameter longer than supported &quot;
					&quot;maximum of %d characters&quot;, (int)sizeof(pData-&gt;dbuid)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbuid, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, &quot;pwd&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbpwd)-1) {
				parser_errmsg(&quot;ommysql: pwd parameter longer than supported &quot;
					&quot;maximum of %d characters&quot;, (int)sizeof(pData-&gt;dbpwd)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbpwd, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, &quot;mysqlconfig.file&quot;)) {
			pData-&gt;configfile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;mysqlconfig.section&quot;)) {
<A NAME="2"></A>			pData-&gt;configsection = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match270-1.html#2',3,'match270-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;socket&quot;)) {
			pData-&gt;socket = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf(&quot;ommysql: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	if(pData-&gt;tplName == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup(&quot; StdDBFmt&quot;),
			OMSR_RQD_TPL_OPT_SQL));
	} else {</B></FONT>
		CHKiRet(OMSRsetEntry(*ppOMSR, 0,
			(uchar*) strdup((char*) pData-&gt;tplName),
			OMSR_RQD_TPL_OPT_SQL));
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINparseSelectorAct
	int iMySQLPropErr = 0;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us
	 * The first test [*p == '&gt;'] can be skipped if a module shall only
	 * support the newer slection syntax [:modname:]. This is in fact
	 * recommended for new modules. Please note that over time this part
	 * will be handled by rsyslogd itself, but for the time being it is
	 * a good compromise to do it at the module level.
	 * rgerhards, 2007-10-15
	 */
	if(*p == '&gt;') {
		p++; /* eat '&gt;' '*/
	} else if(!strncmp((char*) p, &quot;:ommysql:&quot;, sizeof(&quot;:ommysql:&quot;) - 1)) {
		p += sizeof(&quot;:ommysql:&quot;) - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	} else {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	CHKiRet(createInstance(&amp;pData));

	/* rger 2004-10-28: added support for MySQL
	 * &gt;server,dbname,userid,password
	 * Now we read the MySQL connection properties
	 * and verify that the properties are valid.
	 */
	if(getSubString(&amp;p, pData-&gt;dbsrv, MAXHOSTNAMELEN+1, ','))
		iMySQLPropErr++;
	if(*pData-&gt;dbsrv == '\0')
		iMySQLPropErr++;
	if(getSubString(&amp;p, pData-&gt;dbname, _DB_MAXDBLEN+1, ','))
		iMySQLPropErr++;
	if(*pData-&gt;dbname == '\0')
		iMySQLPropErr++;
	if(getSubString(&amp;p, pData-&gt;dbuid, _DB_MAXUNAMELEN+1, ','))
		iMySQLPropErr++;
	if(*pData-&gt;dbuid == '\0')
		iMySQLPropErr++;
	if(getSubString(&amp;p, pData-&gt;dbpwd, _DB_MAXPWDLEN+1, ';'))
		iMySQLPropErr++;
	/* now check for template
	 * We specify that the SQL option must be present in the template.
	 * This is for your own protection (prevent sql injection).
	 */
	if(*(p-1) == ';')
		--p;	/* TODO: the whole parsing of the MySQL module needs to be re-thought - but this here
			 *       is clean enough for the time being -- rgerhards, 2007-07-30
			 */
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*) &quot; StdDBFmt&quot;));
	
	/* If we detect invalid properties, we disable logging,
	 * because right properties are vital at this place.
	 * Retries make no sense.
	 */
	if (iMySQLPropErr) {
		LogError(0, RS_RET_INVALID_PARAMS, &quot;Trouble with MySQL connection properties. &quot;
				&quot;-MySQL logging disabled&quot;);
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	} else {
		pData-&gt;dbsrvPort = (unsigned) cs.iSrvPort;	/* set configured port */
		pData-&gt;configfile = cs.pszMySQLConfigFile;
		pData-&gt;configsection = cs.pszMySQLConfigSection;
		pData-&gt;socket = NULL;
	}

CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
	pthread_rwlock_destroy(&amp;rwlock_hmysql);
#	ifdef HAVE_MYSQL_LIBRARY_INIT
	mysql_library_end();
#	else
	mysql_server_end();
#	endif
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMODTX_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt


/* Reset config variables for this module to default values.
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	cs.iSrvPort = 0; /* zero is the default port */
	free(cs.pszMySQLConfigFile);
	cs.pszMySQLConfigFile = NULL;
	free(cs.pszMySQLConfigSection);
	cs.pszMySQLConfigSection = NULL;
	RETiRet;
}

BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	if(!bCoreSupportsBatching) {
		LogError(0, NO_ERRCODE, &quot;ommysql: rsyslog core too old&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* we need to init the MySQL library. If that fails, we cannot run */
	if(
#	ifdef HAVE_MYSQL_LIBRARY_INIT
	   mysql_library_init(0, NULL, NULL)
#	else
	   mysql_server_init(0, NULL, NULL)
#	endif
	                                   ) {
		LogError(0, NO_ERRCODE, &quot;ommysql: initializing mysql client failed, plugin &quot;
		                &quot;can not run&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	pthread_rwlock_init(&amp;rwlock_hmysql, NULL);

	/* register our config handlers */
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionommysqlserverport&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iSrvPort,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;ommysqlconfigfile&quot;,0,eCmdHdlrGetWord,NULL,&amp;cs.pszMySQLConfigFile,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;ommysqlconfigsection&quot;,0,eCmdHdlrGetWord,NULL,&amp;cs.pszMySQLConfigSection,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler, resetConfigVariables,
	NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttpfs.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omhttpfs.c
 * Send all output to HDFS via httpfs
 *
 * Author: sskaje (sskaje@gmail.com, http://sskaje.me/)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;json.h&gt;
#include &lt;json_object.h&gt;


#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;datetime.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;unicode-helper.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omhttpfs&quot;)

/* internal structures
 */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(datetime)

/* local definitions */
#define OMHTTPFS_VERSION &quot;1.0&quot;
#define OMHTTPFS_DEFAULT_PORT 14000
#define OMHTTPFS_DEFAULT_USER &quot;hdfs&quot;
#define OMHTTPFS_DEFAULT_HOST &quot;127.0.0.1&quot;

#define HTTPFS_URL_PREFIX_V1     &quot;/webhdfs/v1&quot;
#define HTTPFS_URL_PREFIX_V1_SSL &quot;/swebhdfs/v1&quot;
#define HTTPFS_CONTENT_TYPE      &quot;Content-Type: application/octet-stream&quot;
#define HTTPFS_USER_AGENT        &quot;omhttpfs by sskaje/&quot; OMHTTPFS_VERSION

#define HTTPFS_CONTENT_TYPE_JSON &quot;application/json&quot;
#define HTTPFS_JSON_BOOLEAN_TRUE &quot;{\&quot;boolean\&quot;:true}&quot;

#define HTTPFS_FILEALREADYEXISTSEXCEPTION &quot;FileAlreadyExistsException&quot;

#define HTTPFS_URL_BUFFER_LENGTH 2048


/*
Examples:

module(load=&quot;omhttpfs&quot;)
template(name=&quot;hdfs_tmp_file&quot; type=&quot;string&quot; string=&quot;/tmp/%$YEAR%/test.log&quot;)
template(name=&quot;hdfs_tmp_filecontent&quot; type=&quot;string&quot; string=&quot;%$YEAR%-%$MONTH%-%$DAY% %MSG% ==\n&quot;)
local4.*    action(type=&quot;omhttpfs&quot; host=&quot;10.1.1.161&quot; port=&quot;14000&quot; https=&quot;off&quot; file=&quot;hdfs_tmp_file&quot; isDynFile=&quot;on&quot;)
local5.*    action(type=&quot;omhttpfs&quot; host=&quot;10.1.1.161&quot; port=&quot;14000&quot; https=&quot;off&quot; file=&quot;hdfs_tmp_file&quot; isDynFile=&quot;on&quot;
template=&quot;hdfs_tmp_filecontent&quot;)

*/

#define DPP(x) DBGPRINTF(&quot;OMHTTPFS: %s:%d %s(): %s\n&quot;, __FILE__, __LINE__, __FUNCTION__, x)

/**
 * Exception object
 *
 */
typedef struct _HTTPFS_JSON_REMOTE_EXCEPTION {
	char message[1024];
	char exception[256];
	char class[256];
} httpfs_json_remote_exception;


typedef struct _instanceData {
	sbool https;
	uchar* host;
	uchar* ip;
	int  port;
	uchar* user;

	int timeout;
	uchar* file;
	sbool isDynFile;

	uchar* tplName;
} instanceData;


typedef struct wrkrInstanceData {
	instanceData *pData;

	CURL* curl;

	uchar* file;

	int replyLen;
	char* reply;
} wrkrInstanceData_t;


<A NAME="0"></A>/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match270-0.html#0',2,'match270-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;host&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;port&quot;, eCmdHdlrInt, 0 },
	{ &quot;user&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;https&quot;, eCmdHdlrBinary, 0 },
	{ &quot;file&quot;, eCmdHdlrGetWord, CNFPARAM_REQUIRED },
	{ &quot;isdynfile&quot;, eCmdHdlrBinary, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	actpdescr
};</B></FONT>

/**
 * curl init
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param instanceData *pData
 * @return rsRetVal
 */
static rsRetVal
httpfs_init_curl(wrkrInstanceData_t *pWrkrData, instanceData *pData)
{
	CURL *curl = NULL;

	curl = curl_easy_init();

	if (curl) {
		curl_easy_setopt(curl, CURLOPT_VERBOSE, 0L);

		curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

		if (pData-&gt;https) {
			DBGPRINTF(&quot;%s(): Enable HTTPS\n&quot;, __FUNCTION__);
			/* for ssl */
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
		}
	} else {
		/* LOG */
		LogError(0, RS_RET_OBJ_CREATION_FAILED, &quot;omhttpfs: failed to init cURL\n&quot;);

		return RS_RET_OBJ_CREATION_FAILED;
	}

	curl_easy_setopt(curl, CURLOPT_USERAGENT, HTTPFS_USER_AGENT);

	pWrkrData-&gt;curl = curl;
	return RS_RET_OK;
}

/**
 * Build HTTPFS URL
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param char* op
 * @param es_str_t** url_buf
 * @return rsRetVal
 */
static rsRetVal
httpfs_build_url(wrkrInstanceData_t *pWrkrData, const char* op, es_str_t** url_buf)
{
	*url_buf = es_newStr(HTTPFS_URL_BUFFER_LENGTH);

	if (pWrkrData-&gt;pData-&gt;https) {
	    es_addBuf(url_buf, &quot;https://&quot;, sizeof(&quot;https://&quot;)-1);
	} else {
	    es_addBuf(url_buf, &quot;http://&quot;, sizeof(&quot;http://&quot;)-1);
	}

	/* host */
	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;host, strlen((char*)pWrkrData-&gt;pData-&gt;host));

	/* port */
	es_addChar(url_buf, ':');
	char portBuf[6];
	snprintf(portBuf, sizeof(portBuf), &quot;%d&quot;, pWrkrData-&gt;pData-&gt;port);
	es_addBuf(url_buf, portBuf, strlen(portBuf));

	/* prefix */
	es_addBuf(url_buf, HTTPFS_URL_PREFIX_V1, sizeof(HTTPFS_URL_PREFIX_V1)-1);

	/* path */
	if (pWrkrData-&gt;file[0] != '/') {
	    es_addChar(url_buf, '/');
	}
	es_addBuf(url_buf, (char* )pWrkrData-&gt;file, strlen((char* )pWrkrData-&gt;file));

	/* queries */
	/* user */
	es_addBuf(url_buf, &quot;?user.name=&quot;, sizeof(&quot;?user.name=&quot;)-1);
	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;user, strlen((char* )pWrkrData-&gt;pData-&gt;user));

	/* extra parameters */
	es_addBuf(url_buf, op, strlen(op));

	return RS_RET_OK;
}

/**
 * curl set URL
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param char* op
 * @return void
 */
static void httpfs_set_url(wrkrInstanceData_t *pWrkrData, const char* op)
{
	es_str_t* url;
	char* url_cstr;
	httpfs_build_url(pWrkrData, op, &amp;url);
	url_cstr = es_str2cstr(url, NULL);

	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_URL, url_cstr);
	free(url_cstr);
}
/**
 * Set http method to PUT
 *
 * @param CURL* curl
 * @return void
 */
static void httpfs_curl_set_put(CURL* curl)
{
	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_POST, 0L);
	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);

	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;PUT&quot;);
}
/**
 * Set http method to POST
 *
 * @param CURL* curl
 * @return void
 */
static void httpfs_curl_set_post(CURL* curl)
{
	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
	curl_easy_setopt(curl, CURLOPT_POST, 1L);

	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);
}

/**
 * Build curl slist
 *
 * @param struct curl_slist* headers
 * @param int hdr_count
 * @param ...
 * @return struct curl_slist*
 */
static struct curl_slist*
httpfs_curl_add_header(struct curl_slist* headers, int hdr_count, ...)
{
	const char* hdr;

	va_list ar;
	va_start(ar, hdr_count);
	for (; hdr_count &gt; 0; hdr_count--) {
	    hdr = va_arg(ar, const char*);

	    if (hdr != NULL
	            &amp;&amp; hdr[0] != 0) {
	        /* non-empty string */
	        headers = curl_slist_append(headers, hdr);
	    } else {
	        break;
	    }
	}
	va_end(ar);

	headers = curl_slist_append(headers, &quot;Expect:&quot;);
	headers = curl_slist_append(headers, &quot;Transfer-Encoding:&quot;);

	return headers;
}

/**
 * Callback function for CURLOPT_WRITEFUNCTION
 *
 * @param void* contents
 * @param size_t size
 * @param size_t nmemb
 * @param void *userp
 * @return size_t
 */
static size_t
httpfs_curl_result_callback(void *contents, size_t size, size_t nmemb, void *userp)
{
	size_t realsize = size * nmemb;
	char *newreply = NULL;
	wrkrInstanceData_t *mem = (wrkrInstanceData_t *)userp;

	newreply = realloc(mem-&gt;reply, mem-&gt;replyLen + realsize + 1);
	if (newreply == NULL) {
	    /* out of memory! */
	    dbgprintf(&quot;not enough memory (realloc returned NULL)\n&quot;);

	    if (mem-&gt;reply != NULL)
	        free(mem-&gt;reply);

	    mem-&gt;reply = NULL;
	    mem-&gt;replyLen = 0;

	    return 0;
	}

	mem-&gt;reply = newreply;
	memcpy(&amp;(mem-&gt;reply[mem-&gt;replyLen]), contents, realsize);
	mem-&gt;replyLen += realsize;
	mem-&gt;reply[mem-&gt;replyLen] = 0;

	return realsize;
}

/**
 * Variables declaration
 * used in httpfs related operation
 */
#define HTTPFS_CURL_VARS_INIT \
	struct curl_slist* headers = NULL; \
	long response_code; \
	CURLcode res; \
	char* content_type;

/**
 * Resource release
 * used in httpfs related operation
 */
#define HTTPFS_CURL_VARS_RELEASE \
	curl_slist_free_all(headers);

/**
 * Curl execution
 * used in httpfs related operation
 */
#define HTTPFS_CURL_EXEC \
	pWrkrData-&gt;reply = NULL; \
	pWrkrData-&gt;replyLen = 0; \
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEDATA, pWrkrData); \
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEFUNCTION, httpfs_curl_result_callback); \
	res = curl_easy_perform(pWrkrData-&gt;curl); \
	if (res == CURLE_OK) { \
	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_CONTENT_TYPE, &amp;content_type); \
	    if (strncmp(content_type, HTTPFS_CONTENT_TYPE_JSON, strlen(HTTPFS_CONTENT_TYPE_JSON))) { \
	    } \
	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code); \
	    if (pWrkrData-&gt;reply != NULL) { \
	        pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0'; \
	    } \
	} else { \
	LogError(0, RS_RET_ERR, &quot;CURL request fail, code=%d, error string=%s\n&quot;, res, curl_easy_strerror(res)); \
	    return -1; \
	}

/**
 * Parse remote exception json string
 *
 * @param char* buf
 * @param int   length
 * @param httpfs_json_remote_exception* jre
 * @return rsRetVal
 */
static rsRetVal
httpfs_parse_exception(char* buf, int length, httpfs_json_remote_exception* jre)
{
	DEFiRet;
	
	if (!length) {
	    return RS_RET_JSON_PARSE_ERR;
	}

	struct json_tokener* jt = json_tokener_new();
	json_tokener_reset(jt);

	struct json_object *json;
	json = json_tokener_parse_ex(jt, buf, length);
	if (!json_object_is_type(json, json_type_object)) {
		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}

	if (!json_object_object_get_ex(json, &quot;RemoteException&quot;, &amp;json)) {
	ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}

	struct json_object *jobj;

	memset(jre, 0, sizeof(*jre));

	const char *str;

	json_object_object_get_ex(json, &quot;javaClassName&quot;, &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;class, str, sizeof(jre-&gt;class));
	jre-&gt;class[sizeof(jre-&gt;class)-1] = '\0';

	json_object_object_get_ex(json, &quot;exception&quot;, &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;exception, str, sizeof(jre-&gt;exception));
	jre-&gt;exception[sizeof(jre-&gt;exception)-1] = '\0';

	json_object_object_get_ex(json, &quot;message&quot;, &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;message, str, sizeof(jre-&gt;message));
	jre-&gt;message[sizeof(jre-&gt;message)-1] = '\0';

finalize_it:
	if(jt != NULL)
		json_tokener_free(jt);
	if(json != NULL)
		json_object_put(json);
	RETiRet;
}



/**
 * Create a file
 * op=CREATE
 * overwrite is turned off
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param char*   buf
 * @return rsRetVal
 */
static rsRetVal
httpfs_create_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
	/* httpfs.create automatically create folders, no mkdirs needed. */

	/*
	curl -b /tmp/c.tmp -c /tmp/c.tmp  -d 'aaaaabbbbb' -i -H 'Content-Type: application/octet-stream' -X PUT \
	       'http://172.16.3.20:14000/webhdfs/v1/tmp/a/b?user.name=hdfs&amp;op=create&amp;data=true'
	*/
HTTPFS_CURL_VARS_INIT
	DBGPRINTF(&quot;%s(): file=%s\n&quot;, __FUNCTION__, pWrkrData-&gt;file);
	httpfs_curl_set_put(pWrkrData-&gt;curl);

	/*
overwrite - if a file with this name already exists, then if true, the file will be overwritten, and if
false an error will be thrown.
bufferSize - the size of the buffer to be used.
replication - required block replication for the file.
	 */
	httpfs_set_url(pWrkrData, &quot;&amp;op=create&amp;overwrite=false&amp;data=true&quot;);

	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));

	DBGPRINTF(&quot;%s(): msg=%s\n&quot;, __FUNCTION__, buf);

	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);

HTTPFS_CURL_EXEC

	int success = 0;

	if (response_code == 201) {
	    success = 1;
	}

HTTPFS_CURL_VARS_RELEASE
	if (success) {
	    return RS_RET_OK;
	} else {
	    return RS_RET_FALSE;
	}
}

/**
 * Append to file
 * op=APPEND
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param char*   buf
 * @return rsRetVal
 */
static rsRetVal
httpfs_append_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
	/*
	curl -b /tmp/c.tmp -c /tmp/c.tmp  -d 'aaaaabbbbb' -i -H 'Content-Type: application/octet-stream' \
	       'http://172.16.3.20:14000/webhdfs/v1/tmp/a/b?user.name=hdfs&amp;op=append&amp;data=true'
	*/
HTTPFS_CURL_VARS_INIT
	DBGPRINTF(&quot;%s(): file=%s\n&quot;, __FUNCTION__, pWrkrData-&gt;file);
	httpfs_curl_set_post(pWrkrData-&gt;curl);
	httpfs_set_url(pWrkrData, &quot;&amp;op=append&amp;data=true&quot;);

	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));

	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
	DBGPRINTF(&quot;%s(): msg=%s\n&quot;, __FUNCTION__, buf);

HTTPFS_CURL_EXEC

	int success = 0;

	if (response_code == 200) {
	    success = 1;
	} else if (response_code == 404) {
	    /* TODO: 404 ? */

	}
HTTPFS_CURL_VARS_RELEASE
	if (success) {
	    return RS_RET_OK;
	} else {
	    return RS_RET_FALSE;
	}
}


/**
 * httpfs log
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param uchar* buf
 * @return rsRetVal
 */
static rsRetVal
httpfs_log(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
	/**
	append ? 200/end : (404 || ?)
	    create &amp; ~overwrite ? 201/200/end :
	        append ? 200/end : error ?


	*/
	DEFiRet;

	long response_code;
	httpfs_json_remote_exception jre;

	iRet = httpfs_append_file(pWrkrData, buf);
	if (iRet == RS_RET_OK) {
	    DBGPRINTF(&quot;omhttpfs: Append success: %s\n&quot;, pWrkrData-&gt;file);
	    return RS_RET_OK;
	}

	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
	if (response_code != 404) {
	    /* TODO: log error */
	    DBGPRINTF(&quot;omhttpfs: Append fail HTTP %ld: %s\n&quot;, response_code, pWrkrData-&gt;file);
	    return RS_RET_FALSE;
	}

	iRet = httpfs_create_file(pWrkrData, buf);
	if (iRet == RS_RET_OK) {
	    DBGPRINTF(&quot;omhttpfs: Create file success: %s\n&quot;, pWrkrData-&gt;file);
	    return RS_RET_OK;
	}

	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
	if (response_code == 201) {
	    DBGPRINTF(&quot;omhttpfs: Create file success HTTP 201: %s\n&quot;, pWrkrData-&gt;file);
	    return RS_RET_OK;
	}

	if (response_code == 500) {
	    DBGPRINTF(&quot;omhttpfs: Create file failed HTTP %ld: %s\n&quot;, response_code, pWrkrData-&gt;file);
	    httpfs_parse_exception(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen, &amp;jre);
	    if (!strncmp(jre.exception, HTTPFS_FILEALREADYEXISTSEXCEPTION, strlen(HTTPFS_FILEALREADYEXISTSEXCEPTION))) {
	        /* file exists, go to append */
	        DBGPRINTF(&quot;omhttpfs: File already exists, append again: %s\n&quot;, pWrkrData-&gt;file);

	        iRet = httpfs_append_file(pWrkrData, buf);
	        if (iRet == RS_RET_OK) {
	            DBGPRINTF(&quot;omhttpfs: Re-Append success: %s\n&quot;, pWrkrData-&gt;file);
	            return RS_RET_OK;
	        } else {
	            DBGPRINTF(&quot;omhttpfs: Re-Append failed: %s\n&quot;, pWrkrData-&gt;file);
	            /* error
	               exit */
	        }

	    } else {
	        DBGPRINTF(&quot;omhttpfs: Create file failed: %s %s\n&quot;, pWrkrData-&gt;file, pWrkrData-&gt;reply);
	    }
	} else {
	    DBGPRINTF(&quot;omhttpfs: Create file failed: %s %s\n&quot;, pWrkrData-&gt;file, pWrkrData-&gt;reply);
	}

	return RS_RET_FALSE;
}


BEGINinitConfVars
	CODESTARTinitConfVars
ENDinitConfVars


BEGINcreateInstance
CODESTARTcreateInstance
	DBGPRINTF(&quot;omhttpfs: createInstance\n&quot;);
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	DBGPRINTF(&quot;omhttpfs: createWrkrInstance\n&quot;);
	pWrkrData-&gt;curl = NULL;
	iRet = httpfs_init_curl(pWrkrData, pWrkrData-&gt;pData);
	DBGPRINTF(&quot;omhttpfs: createWrkrInstance,pData %p/%p, pWrkrData %p\n&quot;,
	pData, pWrkrData-&gt;pData, pWrkrData);
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
	    iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;file);
	free(pData-&gt;tplName);
	free(pData-&gt;host);
	free(pData-&gt;user);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	free(pWrkrData-&gt;file);

	if(pWrkrData-&gt;curl) {
	    curl_easy_cleanup(pWrkrData-&gt;curl);
	    pWrkrData-&gt;curl = NULL;
	}
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	DBGPRINTF(&quot;OmHTTPFS\n&quot;);
	DBGPRINTF(&quot;Version: %s\n&quot;, OMHTTPFS_VERSION);
	DBGPRINTF(&quot;\tHost: %s\n&quot;, pData-&gt;host);
	DBGPRINTF(&quot;\tPort: %d\n&quot;, pData-&gt;port);
	DBGPRINTF(&quot;\tUser: %s\n&quot;, pData-&gt;user);
	DBGPRINTF(&quot;\tFile: %s\n&quot;, pData-&gt;file);
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
	DBGPRINTF(&quot;omhttpfs: tryResume called\n&quot;);
	/* TODO: test networking */
	iRet = RS_RET_OK;
ENDtryResume

/**
* Do Action
*/
BEGINdoAction
CODESTARTdoAction
	DBGPRINTF(&quot;omhttpfs: doAction\n&quot;);
	/* dynamic file name */
	if (pWrkrData-&gt;pData-&gt;isDynFile) {
	    pWrkrData-&gt;file = ustrdup(ppString[1]);
	} else {
	    pWrkrData-&gt;file = ustrdup(pWrkrData-&gt;pData-&gt;file);
	}

	/* ppString[0] -&gt; log content */
	iRet = httpfs_log(pWrkrData, ppString[0]);

	if(iRet != RS_RET_OK) {
	    DBGPRINTF(&quot;omhttpfs: error writing httpfs, suspending\n&quot;);
	    iRet = RS_RET_SUSPENDED;
	}
ENDdoAction



/**
 * Set default parameters
 *
 * @param instanceData *pData
 * @return void
 */
static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;host = (uchar*) strdup(OMHTTPFS_DEFAULT_HOST);
	pData-&gt;port = OMHTTPFS_DEFAULT_PORT;
	pData-&gt;user = (uchar*) strdup(OMHTTPFS_DEFAULT_USER);
	pData-&gt;https = 0;

	pData-&gt;file = NULL;
	pData-&gt;isDynFile = 0;
	pData-&gt;tplName = NULL;
}


BEGINnewActInst
	struct cnfparamvals *pvals;
<A NAME="1"></A>	int i;
	uchar *tplToUse;
CODESTARTnewActInst
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match270-0.html#1',2,'match270-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
	    ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
	    if(!pvals[i].bUsed)
<A NAME="3"></A>	        continue;
	    if(!strcmp(actpblk.descr[i].name, &quot;host&quot;)) {
	        pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match270-0.html#3',2,'match270-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	    } else if(!strcmp(actpblk.descr[i].name, &quot;port&quot;)) {
	        pData-&gt;port = (int) pvals[i].val.d.n;
	    } else if(!strcmp(actpblk.descr[i].name, &quot;user&quot;)) {
	        pData-&gt;user = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>

	    } else if(!strcmp(actpblk.descr[i].name, &quot;https&quot;)) {
	        pData-&gt;https = pvals[i].val.d.n ? 1 : 0;

	    } else if(!strcmp(actpblk.descr[i].name, &quot;file&quot;)) {
	        pData-&gt;file = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);

<A NAME="2"></A>	    } else if(!strcmp(actpblk.descr[i].name, &quot;isdynfile&quot;)) {
	        pData-&gt;isDynFile = pvals[i].val.d.n ? 1 : 0;

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match270-0.html#2',2,'match270-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	    } else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
	        pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else {
	        DBGPRINTF(&quot;omhttpfs: program error, non-handled param '%s'\n&quot;, actpblk.descr[i].name);
	    }
	}
	if(pData-&gt;file == NULL) {
	/* Note: this is primarily to make clang static analyzer happy, as we
	 * request via pblk that file is a mandatory parameter. However, this is
	 * also a guard against something going really wrong...
	 */
	    LogError(0, RS_RET_INTERNAL_ERROR, &quot;omhttpfs: file is not set &quot;
		&quot;[this should not be possible]\n&quot;);
	ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
	}</B></FONT>
	if(pData-&gt;user == NULL || pData-&gt;user[0] == '\0') {
	    pData-&gt;user = ustrdup((uchar*) OMHTTPFS_DEFAULT_USER);
	}
	if(pData-&gt;host == NULL || pData-&gt;host[0] == '\0') {
	    pData-&gt;host = ustrdup((uchar*) OMHTTPFS_DEFAULT_HOST);
	}

	if (pData-&gt;isDynFile) {
	    CODE_STD_STRING_REQUESTparseSelectorAct(2)

	    CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;file), OMSR_NO_RQD_TPL_OPTS));
	} else {
	    CODE_STD_STRING_REQUESTparseSelectorAct(1)
	}

	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? (uchar* ) &quot;RSYSLOG_FileFormat&quot; : pData-&gt;tplName);
	iRet = OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS);

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


NO_LEGACY_CONF_parseSelectorAct


/**
* Module Exit
*/
BEGINmodExit
CODESTARTmodExit
	/*  */
	curl_global_cleanup();

	/* release what we no longer need */
	objRelease(datetime, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);

ENDmodExit

/**
* Query Entry Point
*/
BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
	CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
ENDqueryEtryPt


/**
* Module Init
*/
BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	/* tell which objects we need */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));

	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
	    LogError(0, RS_RET_OBJ_CREATION_FAILED, &quot;CURL fail. -httpfs module init failed&quot;);
	    ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
	}

	DBGPRINTF(&quot;omhttpfs version %s is initializing\n&quot;, OMHTTPFS_VERSION);

ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
