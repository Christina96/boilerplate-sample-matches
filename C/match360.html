<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-user.c &amp; infd-xmpp-server.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-user.c &amp; infd-xmpp-server.c
      </h3>
<h1 align="center">
        27.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-user.c (36.021507%)<th>infd-xmpp-server.c (21.895424%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(131-181)<td><a href="#" name="0">(389-427)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(224-250)<td><a href="#" name="1">(503-528)</a><td align="center"><font color="#d00000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(70-107)<td><a href="#" name="2">(36-78)</a><td align="center"><font color="#ad0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(203-223)<td><a href="#" name="3">(171-191)</a><td align="center"><font color="#8b0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-user.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/common/inf-user.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;
#include &lt;string.h&gt;
static const GFlagsValue inf_user_flags_values[] = {
  {
    INF_USER_LOCAL,
    "INF_USER_LOCAL",
    "local"
  }, {
    0,
    NULL,
    NULL
  }
};
static const GEnumValue inf_user_status_values[] = {
  {
    INF_USER_ACTIVE,
    "INF_USER_ACTIVE",
    "active"
  }, {
    INF_USER_INACTIVE,
    "INF_USER_INACTIVE",
    "inactive"
  }, {
    INF_USER_UNAVAILABLE,
    "INF_USER_UNAVAILABLE",
    "unavailable"
  }, {
    0,
<a name="2"></a>    NULL,
    NULL
  }
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
typedef struct _InfUserPrivate InfUserPrivate;
struct _InfUserPrivate {
  guint id;
  gchar* name;
  InfUserStatus status;
  InfUserFlags flags;
  InfXmlConnection* connection;
};
enum {
  PROP_0,
  PROP_ID,
  PROP_NAME,
  PROP_STATUS,
  PROP_FLAGS,
  PROP_CONNECTION
};
enum {
  SET_STATUS,
  LAST_SIGNAL
};
#define INF_USER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_USER, InfUserPrivate))
#define INF_USER_PRIVATE(obj)     ((InfUserPrivate*)(obj)-&gt;priv)
static guint user_signals[LAST_SIGNAL];
INF_DEFINE_FLAGS_TYPE(InfUserFlags, inf_user_flags, inf_user_flags_values)
INF_DEFINE_ENUM_TYPE(InfUserStatus, inf_user_status, inf_user_status_values)
G_DEFINE_TYPE_WITH_CODE(InfUser, inf_user, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfUser))
static void</b></font>
inf_user_init(InfUser* user)
{
  InfUserPrivate* priv;
  user-&gt;priv = INF_USER_GET_PRIVATE(user);
  priv = INF_USER_PRIVATE(user);
  priv-&gt;id = 0;
  priv-&gt;name = NULL;
  priv-&gt;status = INF_USER_UNAVAILABLE;
  priv-&gt;flags = 0;
  priv-&gt;connection = NULL;
}
static void
inf_user_dispose(GObject* object)
{
  InfUser* user;
  InfUserPrivate* priv;
<a name="0"></a>  user = INF_USER(object);
  priv = INF_USER_PRIVATE(user);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if(priv-&gt;connection != NULL)
  {
    g_object_unref(priv-&gt;connection);
    priv-&gt;connection = NULL;
  }
  G_OBJECT_CLASS(inf_user_parent_class)-&gt;dispose(object);
}
static void
inf_user_finalize(GObject* object)
{
  InfUser* user;
  InfUserPrivate* priv;
  user = INF_USER(object);
  priv = INF_USER_PRIVATE(user);
  g_free(priv-&gt;name);
  G_OBJECT_CLASS(inf_user_parent_class)-&gt;finalize(object);
}
static void
inf_user_set_property(GObject* object,
                      guint prop_id,
                      const GValue* value,
                      GParamSpec* pspec)
{
  InfUser* user;
  InfUserPrivate* priv;
  user = INF_USER(object);
  priv = INF_USER_PRIVATE(user);
  switch(prop_id)
  {
  case PROP_ID:</b></font>
    priv-&gt;id = g_value_get_uint(value);
    break;
  case PROP_NAME:
    g_free(priv-&gt;name);
    priv-&gt;name = g_value_dup_string(value);
    break;
  case PROP_STATUS:
    g_signal_emit(
      object,
      user_signals[SET_STATUS],
      0,
      g_value_get_enum(value)
    );
    break;
  case PROP_FLAGS:
    priv-&gt;flags = g_value_get_flags(value);
    break;
<a name="3"></a>  case PROP_CONNECTION:
    if(priv-&gt;connection != NULL) g_object_unref(priv-&gt;connection);
    priv-&gt;connection = INF_XML_CONNECTION(g_value_dup_object(value));
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_user_get_property(GObject* object,
                      guint prop_id,
                      GValue* value,
                      GParamSpec* pspec)
{
  InfUser* user;
  InfUserPrivate* priv;
  user = INF_USER(object);
  priv = INF_USER_PRIVATE(user);
<a name="1"></a>
  switch(prop_id)
  {</b></font>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case PROP_ID:
    g_value_set_uint(value, priv-&gt;id);
    break;
  case PROP_NAME:
    g_value_set_string(value, priv-&gt;name);
    break;
  case PROP_STATUS:
    g_value_set_enum(value, priv-&gt;status);
    break;
  case PROP_FLAGS:
    g_value_set_flags(value, priv-&gt;flags);
    break;
  case PROP_CONNECTION:
    g_value_set_object(value, G_OBJECT(priv-&gt;connection));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_user_set_status_handler(InfUser* user,
                            InfUserStatus status)
{
  InfUserPrivate* priv;
  priv = INF_USER_PRIVATE(user);</b></font>
  priv-&gt;status = status;
}
static void
inf_user_class_init(InfUserClass* user_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(user_class);
  object_class-&gt;dispose = inf_user_dispose;
  object_class-&gt;finalize = inf_user_finalize;
  object_class-&gt;set_property = inf_user_set_property;
  object_class-&gt;get_property = inf_user_get_property;
  user_class-&gt;set_status = inf_user_set_status_handler;
  g_object_class_install_property(
    object_class,
    PROP_ID,
    g_param_spec_uint(
      "id",
      "User ID",
      "A Unique User ID",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_NAME,
    g_param_spec_string(
      "name",
      "User Name",
      "The Name with which a user joined a session. Most servers "
      "ensure that it is unique.",
      "",
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_STATUS,
    g_param_spec_enum(
      "status",
      "User Status",
      "Whether the user is currently available or not.",
      INF_TYPE_USER_STATUS,
      INF_USER_UNAVAILABLE,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_FLAGS,
    g_param_spec_flags(
      "flags",
      "Flags",
      "Flags the user currently has",
      INF_TYPE_USER_FLAGS,
      0,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CONNECTION,
    g_param_spec_object(
      "connection",
      "Connection",
      "Connection to the user",
      INF_TYPE_XML_CONNECTION,
      G_PARAM_READWRITE
    )
  );
  user_signals[SET_STATUS] = g_signal_new(
    "set-status",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfUserClass, set_status),
    NULL, NULL,
    g_cclosure_marshal_VOID__ENUM,
    G_TYPE_NONE,
    1,
    INF_TYPE_USER_STATUS
  );
}
guint
inf_user_get_id(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), 0);
  return INF_USER_PRIVATE(user)-&gt;id;
}
const gchar*
inf_user_get_name(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), NULL);
  return INF_USER_PRIVATE(user)-&gt;name;
}
InfUserStatus
inf_user_get_status(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), INF_USER_UNAVAILABLE);
  return INF_USER_PRIVATE(user)-&gt;status;
}
InfUserFlags
inf_user_get_flags(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), 0);
  return INF_USER_PRIVATE(user)-&gt;flags;
}
InfXmlConnection*
inf_user_get_connection(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), NULL);
  return INF_USER_PRIVATE(user)-&gt;connection;
}
const gchar*
inf_user_status_to_string(InfUserStatus status)
{
  switch(status)
  {
  case INF_USER_ACTIVE: return "active";
  case INF_USER_INACTIVE: return "inactive";
  case INF_USER_UNAVAILABLE: return "unavailable";
  default: g_assert_not_reached();
  }
}
gboolean
inf_user_status_from_string(const gchar* string,
                            InfUserStatus* status,
                            GError** error)
{
  InfUserStatus tmp_status;
  if(strcmp(string, "active") == 0)
    tmp_status = INF_USER_ACTIVE;
  else if(strcmp(string, "inactive") == 0)
    tmp_status = INF_USER_INACTIVE;
  else if(strcmp(string, "unavailable") == 0)
    tmp_status = INF_USER_UNAVAILABLE;
  else
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_INVALID_STATUS,
      _("Invalid user status: '%s'"),
      string
    );
    return FALSE;
  }
  if(status) *status = tmp_status;
  return TRUE;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-xmpp-server.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/server/infd-xmpp-server.h&gt;
#include &lt;libinfinity/server/infd-tcp-server.h&gt;
#include &lt;libinfinity/server/infd-xml-server.h&gt;
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#ifdef G_OS_WIN32
# ifdef ERROR
#  undef ERROR
# endif
#endif
<a name="2"></a>typedef enum InfdXmppServerStatus_ {
  INFD_XMPP_SERVER_CLOSED,
  INFD_XMPP_SERVER_OPEN
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>} InfdXmppServerStatus;
typedef struct _InfdXmppServerPrivate InfdXmppServerPrivate;
struct _InfdXmppServerPrivate {
  InfdTcpServer* tcp;
  InfdXmppServerStatus status;
  gchar* local_hostname;
  InfXmppConnectionSecurityPolicy security_policy;
  InfCertificateCredentials* tls_creds;
  InfSaslContext* sasl_context;
  InfSaslContext* sasl_own_context;
  gchar* sasl_mechanisms;
};
enum {
  PROP_0,
  PROP_TCP,
  PROP_LOCAL_HOSTNAME,
  PROP_CREDENTIALS,
  PROP_SASL_CONTEXT,
  PROP_SASL_MECHANISMS,
  PROP_SECURITY_POLICY,
  PROP_STATUS
};
enum {
  ERROR,
  LAST_SIGNAL
};
#define INFD_XMPP_SERVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_XMPP_SERVER, InfdXmppServerPrivate))
static guint xmpp_server_signals[LAST_SIGNAL];
static void infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface);</b></font>
G_DEFINE_TYPE_WITH_CODE(InfdXmppServer, infd_xmpp_server, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfdXmppServer)
  G_IMPLEMENT_INTERFACE(INFD_TYPE_XML_SERVER, infd_xmpp_server_xml_server_iface_init))
static void
infd_xmpp_server_new_connection_cb(InfdTcpServer* tcp_server,
                                   InfTcpConnection* tcp_connection,
                                   gpointer user_data)
{
  InfdXmppServer* xmpp_server;
  InfdXmppServerPrivate* priv;
  InfXmppConnection* xmpp_connection;
  InfIpAddress* addr;
  gchar* addr_str;
  xmpp_server = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp_server);
  g_object_get(G_OBJECT(tcp_connection), "remote-address", &amp;addr, NULL);
  addr_str = inf_ip_address_to_string(addr);
  inf_ip_address_free(addr);
  xmpp_connection = inf_xmpp_connection_new(
    tcp_connection,
    INF_XMPP_CONNECTION_SERVER,
    priv-&gt;local_hostname,
    addr_str,
    priv-&gt;security_policy,
    priv-&gt;tls_creds,
    priv-&gt;sasl_context,
    priv-&gt;sasl_own_context != NULL ? "ANONYMOUS" : priv-&gt;sasl_mechanisms
  );
  g_free(addr_str);
  infd_xml_server_new_connection(
    INFD_XML_SERVER(xmpp_server),
    INF_XML_CONNECTION(xmpp_connection)
  );
  g_object_unref(G_OBJECT(xmpp_connection));
}
static void
infd_xmpp_server_error_cb(InfdTcpServer* tcp_server,
                          GError* error,
                          gpointer user_data)
{
  g_signal_emit(
    G_OBJECT(user_data),
    xmpp_server_signals[ERROR],
    0,
    error
  );
}
static void
infd_xmpp_server_notify_status_cb(InfdTcpServer* tcp_server,
                                  GParamSpec* pspec,
                                  gpointer user_data)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  InfdTcpServerStatus status;
  xmpp = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_object_get(G_OBJECT(tcp_server), "status", &amp;status, NULL);
  switch(status)
  {
  case INFD_TCP_SERVER_CLOSED:
  case INFD_TCP_SERVER_BOUND:
    if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
    {
      priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
      g_object_notify(G_OBJECT(xmpp), "status");
    }
    break;
  case INFD_TCP_SERVER_OPEN:
    if(priv-&gt;status != INFD_XMPP_SERVER_OPEN)
    {
      priv-&gt;status = INFD_XMPP_SERVER_OPEN;
<a name="3"></a>      g_object_notify(G_OBJECT(xmpp), "status");
    }
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
infd_xmpp_server_sasl_cb(InfSaslContextSession* session,
                         Gsasl_property property,
                         gpointer session_data,
                         gpointer user_data)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  switch(property)
  {</b></font>
  case GSASL_ANONYMOUS_TOKEN:
    inf_sasl_context_session_set_property(
      session,
      GSASL_ANONYMOUS_TOKEN,
      priv-&gt;local_hostname
    );
    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  case GSASL_VALIDATE_ANONYMOUS:
    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  default:
    g_assert_not_reached();
    inf_sasl_context_session_continue(session, GSASL_NO_CALLBACK);
    break;
  }
}
static void
infd_xmpp_server_setup_own_sasl_context(InfdXmppServer* xmpp)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_assert(priv-&gt;sasl_own_context == NULL);
  if(priv-&gt;sasl_context == NULL &amp;&amp; priv-&gt;tcp != NULL)
  {
    priv-&gt;sasl_own_context = inf_sasl_context_new(NULL);
    if(priv-&gt;sasl_own_context != NULL)
    {
      priv-&gt;sasl_context = priv-&gt;sasl_own_context;
      inf_sasl_context_ref(priv-&gt;sasl_context);
      inf_sasl_context_set_callback(
        priv-&gt;sasl_context,
        infd_xmpp_server_sasl_cb,
        xmpp,
        NULL
      );
      g_object_notify(G_OBJECT(xmpp), "sasl-context");
    }
  }
}
static void
infd_xmpp_server_set_tcp(InfdXmppServer* xmpp,
                         InfdTcpServer* tcp)
{
  InfdXmppServerPrivate* priv;
  InfdTcpServerStatus tcp_status;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_object_freeze_notify(G_OBJECT(xmpp));
  if(priv-&gt;tcp != NULL)
  {
    g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;tcp_status, NULL);
    if(tcp_status != INFD_TCP_SERVER_CLOSED)
      infd_tcp_server_close(priv-&gt;tcp);
    if(priv-&gt;sasl_own_context != NULL)
    {
      inf_sasl_context_unref(priv-&gt;sasl_own_context);
      priv-&gt;sasl_own_context = NULL;
    }
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_new_connection_cb),
      xmpp
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_error_cb),
      xmpp
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_notify_status_cb),
      xmpp
    );
    g_object_unref(G_OBJECT(priv-&gt;tcp));
  }
  priv-&gt;tcp = tcp;
  if(tcp != NULL)
  {
    g_object_ref(G_OBJECT(tcp));
    g_signal_connect(
      G_OBJECT(tcp),
      "new-connection",
      G_CALLBACK(infd_xmpp_server_new_connection_cb),
      xmpp
    );
    g_signal_connect(
      G_OBJECT(tcp),
      "error",
      G_CALLBACK(infd_xmpp_server_error_cb),
      xmpp
    );
    g_signal_connect(
      G_OBJECT(tcp),
      "notify::status",
      G_CALLBACK(infd_xmpp_server_notify_status_cb),
      xmpp
    );
    g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
    switch(tcp_status)
    {
    case INFD_TCP_SERVER_CLOSED:
    case INFD_TCP_SERVER_BOUND:
      g_assert(priv-&gt;status == INFD_XMPP_SERVER_CLOSED);
      break;
    case INFD_TCP_SERVER_OPEN:
      priv-&gt;status = INFD_XMPP_SERVER_OPEN;
      g_object_notify(G_OBJECT(xmpp), "status");
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
  infd_xmpp_server_setup_own_sasl_context(xmpp);
  g_object_thaw_notify(G_OBJECT(xmpp));
}
static void
infd_xmpp_server_init(InfdXmppServer* xmpp)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  priv-&gt;tcp = NULL;
  priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
  priv-&gt;local_hostname = g_strdup(g_get_host_name());
  priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED;
  priv-&gt;tls_creds = NULL;
  priv-&gt;sasl_context = NULL;
  priv-&gt;sasl_own_context = NULL;
  priv-&gt;sasl_mechanisms = NULL;
}
static void
infd_xmpp_server_dispose(GObject* object)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
    infd_xml_server_close(INFD_XML_SERVER(xmpp));
  infd_xmpp_server_set_tcp(xmpp, NULL);
  if(priv-&gt;sasl_own_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_own_context);
    priv-&gt;sasl_own_context = NULL;
  }
  if(priv-&gt;sasl_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_context);
<a name="0"></a>    priv-&gt;sasl_context = NULL;
  }
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if(priv-&gt;tls_creds != NULL)
  {
    inf_certificate_credentials_unref(priv-&gt;tls_creds);
    priv-&gt;tls_creds = NULL;
  }
  G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;dispose(object);
}
static void
infd_xmpp_server_finalize(GObject* object)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_free(priv-&gt;local_hostname);
  g_free(priv-&gt;sasl_mechanisms);
  G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;finalize(object);
}
static void
infd_xmpp_server_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  switch(prop_id)
  {
  case PROP_TCP:</b></font>
    infd_xmpp_server_set_tcp(
      xmpp,
      INFD_TCP_SERVER(g_value_get_object(value))
    );
    break;
  case PROP_LOCAL_HOSTNAME:
    g_free(priv-&gt;local_hostname);
    priv-&gt;local_hostname = g_value_dup_string(value);
    if(priv-&gt;local_hostname == NULL)
      priv-&gt;local_hostname = g_strdup(g_get_host_name());
    break;
  case PROP_CREDENTIALS:
    if(priv-&gt;tls_creds != NULL)
      inf_certificate_credentials_unref(priv-&gt;tls_creds);
    priv-&gt;tls_creds = g_value_dup_boxed(value);
    break;
  case PROP_SASL_CONTEXT:
    if(priv-&gt;sasl_own_context != NULL)
    {
      inf_sasl_context_unref(priv-&gt;sasl_own_context);
      priv-&gt;sasl_own_context = NULL;
    }
    if(priv-&gt;sasl_context != NULL)
      inf_sasl_context_unref(priv-&gt;sasl_context);
    priv-&gt;sasl_context = g_value_dup_boxed(value);
    infd_xmpp_server_setup_own_sasl_context(xmpp);
    break;
  case PROP_SASL_MECHANISMS:
    g_free(priv-&gt;sasl_mechanisms);
    priv-&gt;sasl_mechanisms = g_value_dup_string(value);
    break;
  case PROP_SECURITY_POLICY:
    infd_xmpp_server_set_security_policy(xmpp, g_value_get_enum(value));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_xmpp_server_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  switch(prop_id)
  {
  case PROP_STATUS:
    switch(priv-&gt;status)
    {
    case INFD_XMPP_SERVER_CLOSED:
      g_value_set_enum(value, INFD_XML_SERVER_CLOSED);
      break;
    case INFD_XMPP_SERVER_OPEN:
      g_value_set_enum(value, INFD_XML_SERVER_OPEN);
      break;
    default:
      g_assert_not_reached();
      break;
    }
    break;
<a name="1"></a>  case PROP_TCP:
    g_value_set_object(value, priv-&gt;tcp);
    break;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  case PROP_LOCAL_HOSTNAME:
    g_value_set_string(value, priv-&gt;local_hostname);
    break;
  case PROP_CREDENTIALS:
    g_value_set_boxed(value, priv-&gt;tls_creds);
    break;
  case PROP_SASL_CONTEXT:
    g_value_set_boxed(value, priv-&gt;sasl_context);
    break;
  case PROP_SASL_MECHANISMS:
    g_value_set_string(value, priv-&gt;sasl_mechanisms);
    break;
  case PROP_SECURITY_POLICY:
    g_value_set_enum(value, priv-&gt;security_policy);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_xmpp_server_xml_server_close(InfdXmlServer* xml)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xml);</b></font>
  g_return_if_fail(priv-&gt;status != INFD_XMPP_SERVER_CLOSED);
  switch(priv-&gt;status)
  {
  case INFD_XMPP_SERVER_OPEN:
    infd_tcp_server_close(priv-&gt;tcp);
    break;
  case INFD_XMPP_SERVER_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
}
static void
infd_xmpp_server_class_init(InfdXmppServerClass* xmpp_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(xmpp_class);
  object_class-&gt;dispose = infd_xmpp_server_dispose;
  object_class-&gt;finalize = infd_xmpp_server_finalize;
  object_class-&gt;set_property = infd_xmpp_server_set_property;
  object_class-&gt;get_property = infd_xmpp_server_get_property;
  xmpp_class-&gt;error = NULL;
  g_object_class_install_property(
    object_class,
    PROP_TCP,
    g_param_spec_object(
      "tcp-server",
      "TCP server",
      "Underlaying TCP server",
      INFD_TYPE_TCP_SERVER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_LOCAL_HOSTNAME,
    g_param_spec_string(
      "local-hostname",
      "Local hostname",
      "Hostname of the server",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CREDENTIALS,
    g_param_spec_boxed(
      "credentials",
      "Credentials",
      "The certificate credentials for GnuTLS",
      INF_TYPE_CERTIFICATE_CREDENTIALS,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_CONTEXT,
    g_param_spec_boxed(
      "sasl-context",
      "SASL context",
      "The SASL context used for authentaction",
      INF_TYPE_SASL_CONTEXT,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_MECHANISMS,
    g_param_spec_string(
      "sasl-mechanisms",
      "SASL mechanisms",
      "The SASL mechanisms offered to the client for authentication",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SECURITY_POLICY,
    g_param_spec_enum(
      "security-policy",
      "Security policy",
      "Whether to offer or require TLS",
      INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
      INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_override_property(object_class, PROP_STATUS, "status");
  xmpp_server_signals[ERROR] = g_signal_new(
    "error",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdXmppServerClass, error),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    G_TYPE_ERROR
  );
}
static void
infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface)
{
  iface-&gt;close = infd_xmpp_server_xml_server_close;
}
InfdXmppServer*
infd_xmpp_server_new(InfdTcpServer* tcp,
                     InfXmppConnectionSecurityPolicy policy,
                     InfCertificateCredentials* creds,
                     InfSaslContext* sasl_context,
                     const gchar* sasl_mechanisms)
{
  GObject* object;
  g_return_val_if_fail(INFD_IS_TCP_SERVER(tcp), NULL);
  g_return_val_if_fail(
    policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED || creds != NULL,
    NULL
  );
  object = g_object_new(
    INFD_TYPE_XMPP_SERVER,
    "tcp-server", tcp,
    "credentials", creds,
    "security-policy", policy,
    "sasl-context", sasl_context,
    "sasl-mechanisms", sasl_mechanisms,
    NULL
  );
  return INFD_XMPP_SERVER(object);
}
void
infd_xmpp_server_set_security_policy(InfdXmppServer* server,
                                     InfXmppConnectionSecurityPolicy policy)
{
  InfdXmppServerPrivate* priv;
  g_return_if_fail(INFD_IS_XMPP_SERVER(server));
  priv = INFD_XMPP_SERVER_PRIVATE(server);
  if(policy != priv-&gt;security_policy)
  {
    g_return_if_fail(
      policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
      priv-&gt;tls_creds != NULL
    );
    priv-&gt;security_policy = policy;
    g_object_notify(G_OBJECT(server), "security-policy");
  }
}
InfXmppConnectionSecurityPolicy
infd_xmpp_server_get_security_policy(InfdXmppServer* server)
{
  g_return_val_if_fail(
    INFD_IS_XMPP_SERVER(server),
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
  );
  return INFD_XMPP_SERVER_PRIVATE(server)-&gt;security_policy;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
