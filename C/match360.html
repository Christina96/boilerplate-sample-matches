<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-user.c &amp; infd-xmpp-server.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-user.c &amp; infd-xmpp-server.c
      </h3>
<h1 align="center">
        27.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-user.c (36.021507%)<th>infd-xmpp-server.c (21.895424%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(131-181)<td><a href="#" name="0">(389-427)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(224-250)<td><a href="#" name="1">(503-528)</a><td align="center"><font color="#d00000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(70-107)<td><a href="#" name="2">(36-78)</a><td align="center"><font color="#ad0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(203-223)<td><a href="#" name="3">(171-191)</a><td align="center"><font color="#8b0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-user.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-user.h&gt;
2 #include &lt;libinfinity/common/inf-error.h&gt;
3 #include &lt;libinfinity/inf-i18n.h&gt;
4 #include &lt;libinfinity/inf-define-enum.h&gt;
5 #include &lt;string.h&gt;
6 static const GFlagsValue inf_user_flags_values[] = {
7   {
8     INF_USER_LOCAL,
9     "INF_USER_LOCAL",
10     "local"
11   }, {
12     0,
13     NULL,
14     NULL
15   }
16 };
17 static const GEnumValue inf_user_status_values[] = {
18   {
19     INF_USER_ACTIVE,
20     "INF_USER_ACTIVE",
21     "active"
22   }, {
23     INF_USER_INACTIVE,
24     "INF_USER_INACTIVE",
25     "inactive"
26   }, {
27     INF_USER_UNAVAILABLE,
28     "INF_USER_UNAVAILABLE",
29     "unavailable"
30   }, {
31     0,
32 <a name="2"></a>    NULL,
33     NULL
34   }
35 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
36 typedef struct _InfUserPrivate InfUserPrivate;
37 struct _InfUserPrivate {
38   guint id;
39   gchar* name;
40   InfUserStatus status;
41   InfUserFlags flags;
42   InfXmlConnection* connection;
43 };
44 enum {
45   PROP_0,
46   PROP_ID,
47   PROP_NAME,
48   PROP_STATUS,
49   PROP_FLAGS,
50   PROP_CONNECTION
51 };
52 enum {
53   SET_STATUS,
54   LAST_SIGNAL
55 };
56 #define INF_USER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_USER, InfUserPrivate))
57 #define INF_USER_PRIVATE(obj)     ((InfUserPrivate*)(obj)-&gt;priv)
58 static guint user_signals[LAST_SIGNAL];
59 INF_DEFINE_FLAGS_TYPE(InfUserFlags, inf_user_flags, inf_user_flags_values)
60 INF_DEFINE_ENUM_TYPE(InfUserStatus, inf_user_status, inf_user_status_values)
61 G_DEFINE_TYPE_WITH_CODE(InfUser, inf_user, G_TYPE_OBJECT,
62   G_ADD_PRIVATE(InfUser))
63 static void</b></font>
64 inf_user_init(InfUser* user)
65 {
66   InfUserPrivate* priv;
67   user-&gt;priv = INF_USER_GET_PRIVATE(user);
68   priv = INF_USER_PRIVATE(user);
69   priv-&gt;id = 0;
70   priv-&gt;name = NULL;
71   priv-&gt;status = INF_USER_UNAVAILABLE;
72   priv-&gt;flags = 0;
73   priv-&gt;connection = NULL;
74 }
75 static void
76 inf_user_dispose(GObject* object)
77 {
78   InfUser* user;
79   InfUserPrivate* priv;
80 <a name="0"></a>  user = INF_USER(object);
81   priv = INF_USER_PRIVATE(user);
82 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if(priv-&gt;connection != NULL)
83   {
84     g_object_unref(priv-&gt;connection);
85     priv-&gt;connection = NULL;
86   }
87   G_OBJECT_CLASS(inf_user_parent_class)-&gt;dispose(object);
88 }
89 static void
90 inf_user_finalize(GObject* object)
91 {
92   InfUser* user;
93   InfUserPrivate* priv;
94   user = INF_USER(object);
95   priv = INF_USER_PRIVATE(user);
96   g_free(priv-&gt;name);
97   G_OBJECT_CLASS(inf_user_parent_class)-&gt;finalize(object);
98 }
99 static void
100 inf_user_set_property(GObject* object,
101                       guint prop_id,
102                       const GValue* value,
103                       GParamSpec* pspec)
104 {
105   InfUser* user;
106   InfUserPrivate* priv;
107   user = INF_USER(object);
108   priv = INF_USER_PRIVATE(user);
109   switch(prop_id)
110   {
111   case PROP_ID:</b></font>
112     priv-&gt;id = g_value_get_uint(value);
113     break;
114   case PROP_NAME:
115     g_free(priv-&gt;name);
116     priv-&gt;name = g_value_dup_string(value);
117     break;
118   case PROP_STATUS:
119     g_signal_emit(
120       object,
121       user_signals[SET_STATUS],
122       0,
123       g_value_get_enum(value)
124     );
125     break;
126   case PROP_FLAGS:
127     priv-&gt;flags = g_value_get_flags(value);
128     break;
129 <a name="3"></a>  case PROP_CONNECTION:
130     if(priv-&gt;connection != NULL) g_object_unref(priv-&gt;connection);
131     priv-&gt;connection = INF_XML_CONNECTION(g_value_dup_object(value));
132 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
133   default:
134     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
135     break;
136   }
137 }
138 static void
139 inf_user_get_property(GObject* object,
140                       guint prop_id,
141                       GValue* value,
142                       GParamSpec* pspec)
143 {
144   InfUser* user;
145   InfUserPrivate* priv;
146   user = INF_USER(object);
147   priv = INF_USER_PRIVATE(user);
148 <a name="1"></a>
149   switch(prop_id)
150   {</b></font>
151 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case PROP_ID:
152     g_value_set_uint(value, priv-&gt;id);
153     break;
154   case PROP_NAME:
155     g_value_set_string(value, priv-&gt;name);
156     break;
157   case PROP_STATUS:
158     g_value_set_enum(value, priv-&gt;status);
159     break;
160   case PROP_FLAGS:
161     g_value_set_flags(value, priv-&gt;flags);
162     break;
163   case PROP_CONNECTION:
164     g_value_set_object(value, G_OBJECT(priv-&gt;connection));
165     break;
166   default:
167     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
168     break;
169   }
170 }
171 static void
172 inf_user_set_status_handler(InfUser* user,
173                             InfUserStatus status)
174 {
175   InfUserPrivate* priv;
176   priv = INF_USER_PRIVATE(user);</b></font>
177   priv-&gt;status = status;
178 }
179 static void
180 inf_user_class_init(InfUserClass* user_class)
181 {
182   GObjectClass* object_class;
183   object_class = G_OBJECT_CLASS(user_class);
184   object_class-&gt;dispose = inf_user_dispose;
185   object_class-&gt;finalize = inf_user_finalize;
186   object_class-&gt;set_property = inf_user_set_property;
187   object_class-&gt;get_property = inf_user_get_property;
188   user_class-&gt;set_status = inf_user_set_status_handler;
189   g_object_class_install_property(
190     object_class,
191     PROP_ID,
192     g_param_spec_uint(
193       "id",
194       "User ID",
195       "A Unique User ID",
196       0,
197       G_MAXUINT,
198       0,
199       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
200     )
201   );
202   g_object_class_install_property(
203     object_class,
204     PROP_NAME,
205     g_param_spec_string(
206       "name",
207       "User Name",
208       "The Name with which a user joined a session. Most servers "
209       "ensure that it is unique.",
210       "",
211       G_PARAM_READWRITE
212     )
213   );
214   g_object_class_install_property(
215     object_class,
216     PROP_STATUS,
217     g_param_spec_enum(
218       "status",
219       "User Status",
220       "Whether the user is currently available or not.",
221       INF_TYPE_USER_STATUS,
222       INF_USER_UNAVAILABLE,
223       G_PARAM_READWRITE
224     )
225   );
226   g_object_class_install_property(
227     object_class,
228     PROP_FLAGS,
229     g_param_spec_flags(
230       "flags",
231       "Flags",
232       "Flags the user currently has",
233       INF_TYPE_USER_FLAGS,
234       0,
235       G_PARAM_READWRITE
236     )
237   );
238   g_object_class_install_property(
239     object_class,
240     PROP_CONNECTION,
241     g_param_spec_object(
242       "connection",
243       "Connection",
244       "Connection to the user",
245       INF_TYPE_XML_CONNECTION,
246       G_PARAM_READWRITE
247     )
248   );
249   user_signals[SET_STATUS] = g_signal_new(
250     "set-status",
251     G_OBJECT_CLASS_TYPE(object_class),
252     G_SIGNAL_RUN_LAST,
253     G_STRUCT_OFFSET(InfUserClass, set_status),
254     NULL, NULL,
255     g_cclosure_marshal_VOID__ENUM,
256     G_TYPE_NONE,
257     1,
258     INF_TYPE_USER_STATUS
259   );
260 }
261 guint
262 inf_user_get_id(InfUser* user)
263 {
264   g_return_val_if_fail(INF_IS_USER(user), 0);
265   return INF_USER_PRIVATE(user)-&gt;id;
266 }
267 const gchar*
268 inf_user_get_name(InfUser* user)
269 {
270   g_return_val_if_fail(INF_IS_USER(user), NULL);
271   return INF_USER_PRIVATE(user)-&gt;name;
272 }
273 InfUserStatus
274 inf_user_get_status(InfUser* user)
275 {
276   g_return_val_if_fail(INF_IS_USER(user), INF_USER_UNAVAILABLE);
277   return INF_USER_PRIVATE(user)-&gt;status;
278 }
279 InfUserFlags
280 inf_user_get_flags(InfUser* user)
281 {
282   g_return_val_if_fail(INF_IS_USER(user), 0);
283   return INF_USER_PRIVATE(user)-&gt;flags;
284 }
285 InfXmlConnection*
286 inf_user_get_connection(InfUser* user)
287 {
288   g_return_val_if_fail(INF_IS_USER(user), NULL);
289   return INF_USER_PRIVATE(user)-&gt;connection;
290 }
291 const gchar*
292 inf_user_status_to_string(InfUserStatus status)
293 {
294   switch(status)
295   {
296   case INF_USER_ACTIVE: return "active";
297   case INF_USER_INACTIVE: return "inactive";
298   case INF_USER_UNAVAILABLE: return "unavailable";
299   default: g_assert_not_reached();
300   }
301 }
302 gboolean
303 inf_user_status_from_string(const gchar* string,
304                             InfUserStatus* status,
305                             GError** error)
306 {
307   InfUserStatus tmp_status;
308   if(strcmp(string, "active") == 0)
309     tmp_status = INF_USER_ACTIVE;
310   else if(strcmp(string, "inactive") == 0)
311     tmp_status = INF_USER_INACTIVE;
312   else if(strcmp(string, "unavailable") == 0)
313     tmp_status = INF_USER_UNAVAILABLE;
314   else
315   {
316     g_set_error(
317       error,
318       inf_user_error_quark(),
319       INF_USER_ERROR_INVALID_STATUS,
320       _("Invalid user status: '%s'"),
321       string
322     );
323     return FALSE;
324   }
325   if(status) *status = tmp_status;
326   return TRUE;
327 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-xmpp-server.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/server/infd-xmpp-server.h&gt;
2 #include &lt;libinfinity/server/infd-tcp-server.h&gt;
3 #include &lt;libinfinity/server/infd-xml-server.h&gt;
4 #include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
5 #include &lt;libinfinity/inf-signals.h&gt;
6 #ifdef G_OS_WIN32
7 # ifdef ERROR
8 #  undef ERROR
9 # endif
10 #endif
11 <a name="2"></a>typedef enum InfdXmppServerStatus_ {
12   INFD_XMPP_SERVER_CLOSED,
13   INFD_XMPP_SERVER_OPEN
14 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>} InfdXmppServerStatus;
15 typedef struct _InfdXmppServerPrivate InfdXmppServerPrivate;
16 struct _InfdXmppServerPrivate {
17   InfdTcpServer* tcp;
18   InfdXmppServerStatus status;
19   gchar* local_hostname;
20   InfXmppConnectionSecurityPolicy security_policy;
21   InfCertificateCredentials* tls_creds;
22   InfSaslContext* sasl_context;
23   InfSaslContext* sasl_own_context;
24   gchar* sasl_mechanisms;
25 };
26 enum {
27   PROP_0,
28   PROP_TCP,
29   PROP_LOCAL_HOSTNAME,
30   PROP_CREDENTIALS,
31   PROP_SASL_CONTEXT,
32   PROP_SASL_MECHANISMS,
33   PROP_SECURITY_POLICY,
34   PROP_STATUS
35 };
36 enum {
37   ERROR,
38   LAST_SIGNAL
39 };
40 #define INFD_XMPP_SERVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_XMPP_SERVER, InfdXmppServerPrivate))
41 static guint xmpp_server_signals[LAST_SIGNAL];
42 static void infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface);</b></font>
43 G_DEFINE_TYPE_WITH_CODE(InfdXmppServer, infd_xmpp_server, G_TYPE_OBJECT,
44   G_ADD_PRIVATE(InfdXmppServer)
45   G_IMPLEMENT_INTERFACE(INFD_TYPE_XML_SERVER, infd_xmpp_server_xml_server_iface_init))
46 static void
47 infd_xmpp_server_new_connection_cb(InfdTcpServer* tcp_server,
48                                    InfTcpConnection* tcp_connection,
49                                    gpointer user_data)
50 {
51   InfdXmppServer* xmpp_server;
52   InfdXmppServerPrivate* priv;
53   InfXmppConnection* xmpp_connection;
54   InfIpAddress* addr;
55   gchar* addr_str;
56   xmpp_server = INFD_XMPP_SERVER(user_data);
57   priv = INFD_XMPP_SERVER_PRIVATE(xmpp_server);
58   g_object_get(G_OBJECT(tcp_connection), "remote-address", &amp;addr, NULL);
59   addr_str = inf_ip_address_to_string(addr);
60   inf_ip_address_free(addr);
61   xmpp_connection = inf_xmpp_connection_new(
62     tcp_connection,
63     INF_XMPP_CONNECTION_SERVER,
64     priv-&gt;local_hostname,
65     addr_str,
66     priv-&gt;security_policy,
67     priv-&gt;tls_creds,
68     priv-&gt;sasl_context,
69     priv-&gt;sasl_own_context != NULL ? "ANONYMOUS" : priv-&gt;sasl_mechanisms
70   );
71   g_free(addr_str);
72   infd_xml_server_new_connection(
73     INFD_XML_SERVER(xmpp_server),
74     INF_XML_CONNECTION(xmpp_connection)
75   );
76   g_object_unref(G_OBJECT(xmpp_connection));
77 }
78 static void
79 infd_xmpp_server_error_cb(InfdTcpServer* tcp_server,
80                           GError* error,
81                           gpointer user_data)
82 {
83   g_signal_emit(
84     G_OBJECT(user_data),
85     xmpp_server_signals[ERROR],
86     0,
87     error
88   );
89 }
90 static void
91 infd_xmpp_server_notify_status_cb(InfdTcpServer* tcp_server,
92                                   GParamSpec* pspec,
93                                   gpointer user_data)
94 {
95   InfdXmppServer* xmpp;
96   InfdXmppServerPrivate* priv;
97   InfdTcpServerStatus status;
98   xmpp = INFD_XMPP_SERVER(user_data);
99   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
100   g_object_get(G_OBJECT(tcp_server), "status", &amp;status, NULL);
101   switch(status)
102   {
103   case INFD_TCP_SERVER_CLOSED:
104   case INFD_TCP_SERVER_BOUND:
105     if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
106     {
107       priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
108       g_object_notify(G_OBJECT(xmpp), "status");
109     }
110     break;
111   case INFD_TCP_SERVER_OPEN:
112     if(priv-&gt;status != INFD_XMPP_SERVER_OPEN)
113     {
114       priv-&gt;status = INFD_XMPP_SERVER_OPEN;
115 <a name="3"></a>      g_object_notify(G_OBJECT(xmpp), "status");
116     }
117 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
118   default:
119     g_assert_not_reached();
120     break;
121   }
122 }
123 static void
124 infd_xmpp_server_sasl_cb(InfSaslContextSession* session,
125                          Gsasl_property property,
126                          gpointer session_data,
127                          gpointer user_data)
128 {
129   InfdXmppServer* xmpp;
130   InfdXmppServerPrivate* priv;
131   xmpp = INFD_XMPP_SERVER(user_data);
132   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
133   switch(property)
134   {</b></font>
135   case GSASL_ANONYMOUS_TOKEN:
136     inf_sasl_context_session_set_property(
137       session,
138       GSASL_ANONYMOUS_TOKEN,
139       priv-&gt;local_hostname
140     );
141     inf_sasl_context_session_continue(session, GSASL_OK);
142     break;
143   case GSASL_VALIDATE_ANONYMOUS:
144     inf_sasl_context_session_continue(session, GSASL_OK);
145     break;
146   default:
147     g_assert_not_reached();
148     inf_sasl_context_session_continue(session, GSASL_NO_CALLBACK);
149     break;
150   }
151 }
152 static void
153 infd_xmpp_server_setup_own_sasl_context(InfdXmppServer* xmpp)
154 {
155   InfdXmppServerPrivate* priv;
156   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
157   g_assert(priv-&gt;sasl_own_context == NULL);
158   if(priv-&gt;sasl_context == NULL &amp;&amp; priv-&gt;tcp != NULL)
159   {
160     priv-&gt;sasl_own_context = inf_sasl_context_new(NULL);
161     if(priv-&gt;sasl_own_context != NULL)
162     {
163       priv-&gt;sasl_context = priv-&gt;sasl_own_context;
164       inf_sasl_context_ref(priv-&gt;sasl_context);
165       inf_sasl_context_set_callback(
166         priv-&gt;sasl_context,
167         infd_xmpp_server_sasl_cb,
168         xmpp,
169         NULL
170       );
171       g_object_notify(G_OBJECT(xmpp), "sasl-context");
172     }
173   }
174 }
175 static void
176 infd_xmpp_server_set_tcp(InfdXmppServer* xmpp,
177                          InfdTcpServer* tcp)
178 {
179   InfdXmppServerPrivate* priv;
180   InfdTcpServerStatus tcp_status;
181   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
182   g_object_freeze_notify(G_OBJECT(xmpp));
183   if(priv-&gt;tcp != NULL)
184   {
185     g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;tcp_status, NULL);
186     if(tcp_status != INFD_TCP_SERVER_CLOSED)
187       infd_tcp_server_close(priv-&gt;tcp);
188     if(priv-&gt;sasl_own_context != NULL)
189     {
190       inf_sasl_context_unref(priv-&gt;sasl_own_context);
191       priv-&gt;sasl_own_context = NULL;
192     }
193     inf_signal_handlers_disconnect_by_func(
194       G_OBJECT(priv-&gt;tcp),
195       G_CALLBACK(infd_xmpp_server_new_connection_cb),
196       xmpp
197     );
198     inf_signal_handlers_disconnect_by_func(
199       G_OBJECT(priv-&gt;tcp),
200       G_CALLBACK(infd_xmpp_server_error_cb),
201       xmpp
202     );
203     inf_signal_handlers_disconnect_by_func(
204       G_OBJECT(priv-&gt;tcp),
205       G_CALLBACK(infd_xmpp_server_notify_status_cb),
206       xmpp
207     );
208     g_object_unref(G_OBJECT(priv-&gt;tcp));
209   }
210   priv-&gt;tcp = tcp;
211   if(tcp != NULL)
212   {
213     g_object_ref(G_OBJECT(tcp));
214     g_signal_connect(
215       G_OBJECT(tcp),
216       "new-connection",
217       G_CALLBACK(infd_xmpp_server_new_connection_cb),
218       xmpp
219     );
220     g_signal_connect(
221       G_OBJECT(tcp),
222       "error",
223       G_CALLBACK(infd_xmpp_server_error_cb),
224       xmpp
225     );
226     g_signal_connect(
227       G_OBJECT(tcp),
228       "notify::status",
229       G_CALLBACK(infd_xmpp_server_notify_status_cb),
230       xmpp
231     );
232     g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
233     switch(tcp_status)
234     {
235     case INFD_TCP_SERVER_CLOSED:
236     case INFD_TCP_SERVER_BOUND:
237       g_assert(priv-&gt;status == INFD_XMPP_SERVER_CLOSED);
238       break;
239     case INFD_TCP_SERVER_OPEN:
240       priv-&gt;status = INFD_XMPP_SERVER_OPEN;
241       g_object_notify(G_OBJECT(xmpp), "status");
242       break;
243     default:
244       g_assert_not_reached();
245       break;
246     }
247   }
248   infd_xmpp_server_setup_own_sasl_context(xmpp);
249   g_object_thaw_notify(G_OBJECT(xmpp));
250 }
251 static void
252 infd_xmpp_server_init(InfdXmppServer* xmpp)
253 {
254   InfdXmppServerPrivate* priv;
255   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
256   priv-&gt;tcp = NULL;
257   priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
258   priv-&gt;local_hostname = g_strdup(g_get_host_name());
259   priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED;
260   priv-&gt;tls_creds = NULL;
261   priv-&gt;sasl_context = NULL;
262   priv-&gt;sasl_own_context = NULL;
263   priv-&gt;sasl_mechanisms = NULL;
264 }
265 static void
266 infd_xmpp_server_dispose(GObject* object)
267 {
268   InfdXmppServer* xmpp;
269   InfdXmppServerPrivate* priv;
270   xmpp = INFD_XMPP_SERVER(object);
271   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
272   if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
273     infd_xml_server_close(INFD_XML_SERVER(xmpp));
274   infd_xmpp_server_set_tcp(xmpp, NULL);
275   if(priv-&gt;sasl_own_context != NULL)
276   {
277     inf_sasl_context_unref(priv-&gt;sasl_own_context);
278     priv-&gt;sasl_own_context = NULL;
279   }
280   if(priv-&gt;sasl_context != NULL)
281   {
282     inf_sasl_context_unref(priv-&gt;sasl_context);
283 <a name="0"></a>    priv-&gt;sasl_context = NULL;
284   }
285 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if(priv-&gt;tls_creds != NULL)
286   {
287     inf_certificate_credentials_unref(priv-&gt;tls_creds);
288     priv-&gt;tls_creds = NULL;
289   }
290   G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;dispose(object);
291 }
292 static void
293 infd_xmpp_server_finalize(GObject* object)
294 {
295   InfdXmppServer* xmpp;
296   InfdXmppServerPrivate* priv;
297   xmpp = INFD_XMPP_SERVER(object);
298   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
299   g_free(priv-&gt;local_hostname);
300   g_free(priv-&gt;sasl_mechanisms);
301   G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;finalize(object);
302 }
303 static void
304 infd_xmpp_server_set_property(GObject* object,
305                               guint prop_id,
306                               const GValue* value,
307                               GParamSpec* pspec)
308 {
309   InfdXmppServer* xmpp;
310   InfdXmppServerPrivate* priv;
311   xmpp = INFD_XMPP_SERVER(object);
312   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
313   switch(prop_id)
314   {
315   case PROP_TCP:</b></font>
316     infd_xmpp_server_set_tcp(
317       xmpp,
318       INFD_TCP_SERVER(g_value_get_object(value))
319     );
320     break;
321   case PROP_LOCAL_HOSTNAME:
322     g_free(priv-&gt;local_hostname);
323     priv-&gt;local_hostname = g_value_dup_string(value);
324     if(priv-&gt;local_hostname == NULL)
325       priv-&gt;local_hostname = g_strdup(g_get_host_name());
326     break;
327   case PROP_CREDENTIALS:
328     if(priv-&gt;tls_creds != NULL)
329       inf_certificate_credentials_unref(priv-&gt;tls_creds);
330     priv-&gt;tls_creds = g_value_dup_boxed(value);
331     break;
332   case PROP_SASL_CONTEXT:
333     if(priv-&gt;sasl_own_context != NULL)
334     {
335       inf_sasl_context_unref(priv-&gt;sasl_own_context);
336       priv-&gt;sasl_own_context = NULL;
337     }
338     if(priv-&gt;sasl_context != NULL)
339       inf_sasl_context_unref(priv-&gt;sasl_context);
340     priv-&gt;sasl_context = g_value_dup_boxed(value);
341     infd_xmpp_server_setup_own_sasl_context(xmpp);
342     break;
343   case PROP_SASL_MECHANISMS:
344     g_free(priv-&gt;sasl_mechanisms);
345     priv-&gt;sasl_mechanisms = g_value_dup_string(value);
346     break;
347   case PROP_SECURITY_POLICY:
348     infd_xmpp_server_set_security_policy(xmpp, g_value_get_enum(value));
349     break;
350   default:
351     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
352     break;
353   }
354 }
355 static void
356 infd_xmpp_server_get_property(GObject* object,
357                               guint prop_id,
358                               GValue* value,
359                               GParamSpec* pspec)
360 {
361   InfdXmppServer* xmpp;
362   InfdXmppServerPrivate* priv;
363   xmpp = INFD_XMPP_SERVER(object);
364   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
365   switch(prop_id)
366   {
367   case PROP_STATUS:
368     switch(priv-&gt;status)
369     {
370     case INFD_XMPP_SERVER_CLOSED:
371       g_value_set_enum(value, INFD_XML_SERVER_CLOSED);
372       break;
373     case INFD_XMPP_SERVER_OPEN:
374       g_value_set_enum(value, INFD_XML_SERVER_OPEN);
375       break;
376     default:
377       g_assert_not_reached();
378       break;
379     }
380     break;
381 <a name="1"></a>  case PROP_TCP:
382     g_value_set_object(value, priv-&gt;tcp);
383     break;
384 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  case PROP_LOCAL_HOSTNAME:
385     g_value_set_string(value, priv-&gt;local_hostname);
386     break;
387   case PROP_CREDENTIALS:
388     g_value_set_boxed(value, priv-&gt;tls_creds);
389     break;
390   case PROP_SASL_CONTEXT:
391     g_value_set_boxed(value, priv-&gt;sasl_context);
392     break;
393   case PROP_SASL_MECHANISMS:
394     g_value_set_string(value, priv-&gt;sasl_mechanisms);
395     break;
396   case PROP_SECURITY_POLICY:
397     g_value_set_enum(value, priv-&gt;security_policy);
398     break;
399   default:
400     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
401     break;
402   }
403 }
404 static void
405 infd_xmpp_server_xml_server_close(InfdXmlServer* xml)
406 {
407   InfdXmppServerPrivate* priv;
408   priv = INFD_XMPP_SERVER_PRIVATE(xml);</b></font>
409   g_return_if_fail(priv-&gt;status != INFD_XMPP_SERVER_CLOSED);
410   switch(priv-&gt;status)
411   {
412   case INFD_XMPP_SERVER_OPEN:
413     infd_tcp_server_close(priv-&gt;tcp);
414     break;
415   case INFD_XMPP_SERVER_CLOSED:
416   default:
417     g_assert_not_reached();
418     break;
419   }
420 }
421 static void
422 infd_xmpp_server_class_init(InfdXmppServerClass* xmpp_class)
423 {
424   GObjectClass* object_class;
425   object_class = G_OBJECT_CLASS(xmpp_class);
426   object_class-&gt;dispose = infd_xmpp_server_dispose;
427   object_class-&gt;finalize = infd_xmpp_server_finalize;
428   object_class-&gt;set_property = infd_xmpp_server_set_property;
429   object_class-&gt;get_property = infd_xmpp_server_get_property;
430   xmpp_class-&gt;error = NULL;
431   g_object_class_install_property(
432     object_class,
433     PROP_TCP,
434     g_param_spec_object(
435       "tcp-server",
436       "TCP server",
437       "Underlaying TCP server",
438       INFD_TYPE_TCP_SERVER,
439       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
440     )
441   );
442   g_object_class_install_property(
443     object_class,
444     PROP_LOCAL_HOSTNAME,
445     g_param_spec_string(
446       "local-hostname",
447       "Local hostname",
448       "Hostname of the server",
449       NULL,
450       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
451     )
452   );
453   g_object_class_install_property(
454     object_class,
455     PROP_CREDENTIALS,
456     g_param_spec_boxed(
457       "credentials",
458       "Credentials",
459       "The certificate credentials for GnuTLS",
460       INF_TYPE_CERTIFICATE_CREDENTIALS,
461       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
462     )
463   );
464   g_object_class_install_property(
465     object_class,
466     PROP_SASL_CONTEXT,
467     g_param_spec_boxed(
468       "sasl-context",
469       "SASL context",
470       "The SASL context used for authentaction",
471       INF_TYPE_SASL_CONTEXT,
472       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
473     )
474   );
475   g_object_class_install_property(
476     object_class,
477     PROP_SASL_MECHANISMS,
478     g_param_spec_string(
479       "sasl-mechanisms",
480       "SASL mechanisms",
481       "The SASL mechanisms offered to the client for authentication",
482       NULL,
483       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
484     )
485   );
486   g_object_class_install_property(
487     object_class,
488     PROP_SECURITY_POLICY,
489     g_param_spec_enum(
490       "security-policy",
491       "Security policy",
492       "Whether to offer or require TLS",
493       INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
494       INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED,
495       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
496     )
497   );
498   g_object_class_override_property(object_class, PROP_STATUS, "status");
499   xmpp_server_signals[ERROR] = g_signal_new(
500     "error",
501     G_OBJECT_CLASS_TYPE(object_class),
502     G_SIGNAL_RUN_LAST,
503     G_STRUCT_OFFSET(InfdXmppServerClass, error),
504     NULL, NULL,
505     g_cclosure_marshal_VOID__BOXED,
506     G_TYPE_NONE,
507     1,
508     G_TYPE_ERROR
509   );
510 }
511 static void
512 infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface)
513 {
514   iface-&gt;close = infd_xmpp_server_xml_server_close;
515 }
516 InfdXmppServer*
517 infd_xmpp_server_new(InfdTcpServer* tcp,
518                      InfXmppConnectionSecurityPolicy policy,
519                      InfCertificateCredentials* creds,
520                      InfSaslContext* sasl_context,
521                      const gchar* sasl_mechanisms)
522 {
523   GObject* object;
524   g_return_val_if_fail(INFD_IS_TCP_SERVER(tcp), NULL);
525   g_return_val_if_fail(
526     policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED || creds != NULL,
527     NULL
528   );
529   object = g_object_new(
530     INFD_TYPE_XMPP_SERVER,
531     "tcp-server", tcp,
532     "credentials", creds,
533     "security-policy", policy,
534     "sasl-context", sasl_context,
535     "sasl-mechanisms", sasl_mechanisms,
536     NULL
537   );
538   return INFD_XMPP_SERVER(object);
539 }
540 void
541 infd_xmpp_server_set_security_policy(InfdXmppServer* server,
542                                      InfXmppConnectionSecurityPolicy policy)
543 {
544   InfdXmppServerPrivate* priv;
545   g_return_if_fail(INFD_IS_XMPP_SERVER(server));
546   priv = INFD_XMPP_SERVER_PRIVATE(server);
547   if(policy != priv-&gt;security_policy)
548   {
549     g_return_if_fail(
550       policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
551       priv-&gt;tls_creds != NULL
552     );
553     priv-&gt;security_policy = policy;
554     g_object_notify(G_OBJECT(server), "security-policy");
555   }
556 }
557 InfXmppConnectionSecurityPolicy
558 infd_xmpp_server_get_security_policy(InfdXmppServer* server)
559 {
560   g_return_val_if_fail(
561     INFD_IS_XMPP_SERVER(server),
562     INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
563   );
564   return INFD_XMPP_SERVER_PRIVATE(server)-&gt;security_policy;
565 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
