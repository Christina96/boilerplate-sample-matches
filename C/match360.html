<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for inf-user.c & infd-xmpp-server.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for inf-user.c & infd-xmpp-server.c
      </h3>
      <h1 align="center">
        27.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>inf-user.c (36.021507%)<TH>infd-xmpp-server.c (21.895424%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match360-0.html#0',2,'match360-1.html#0',3)" NAME="0">(131-181)<TD><A HREF="javascript:ZweiFrames('match360-0.html#0',2,'match360-1.html#0',3)" NAME="0">(389-427)</A><TD ALIGN=center><FONT COLOR="#ff0000">22</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match360-0.html#1',2,'match360-1.html#1',3)" NAME="1">(224-250)<TD><A HREF="javascript:ZweiFrames('match360-0.html#1',2,'match360-1.html#1',3)" NAME="1">(503-528)</A><TD ALIGN=center><FONT COLOR="#d00000">18</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match360-0.html#2',2,'match360-1.html#2',3)" NAME="2">(70-107)<TD><A HREF="javascript:ZweiFrames('match360-0.html#2',2,'match360-1.html#2',3)" NAME="2">(36-78)</A><TD ALIGN=center><FONT COLOR="#ad0000">15</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match360-0.html#3',2,'match360-1.html#3',3)" NAME="3">(203-223)<TD><A HREF="javascript:ZweiFrames('match360-0.html#3',2,'match360-1.html#3',3)" NAME="3">(171-191)</A><TD ALIGN=center><FONT COLOR="#8b0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-user.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-user
 * @title: InfUser
 * @short_description: User in a #InfSession.
 * @include: libinfinity/common/inf-user.h
 * @see_also: #InfSession
 * @stability: Unstable
 *
 * #InfUser represents a user in an #InfSession. The #InfUser object stores
 * basic user information required in all kinds of sessions, that is the user
 * ID, user name, its status and auxiliary flags.
 */

#include &lt;libinfinity/common/inf-user.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;

#include &lt;string.h&gt;

static const GFlagsValue inf_user_flags_values[] = {
  {
    INF_USER_LOCAL,
    &quot;INF_USER_LOCAL&quot;,
    &quot;local&quot;
  }, {
    0,
    NULL,
    NULL
  }
};

static const GEnumValue inf_user_status_values[] = {
  {
    INF_USER_ACTIVE,
    &quot;INF_USER_ACTIVE&quot;,
    &quot;active&quot;
  }, {
    INF_USER_INACTIVE,
    &quot;INF_USER_INACTIVE&quot;,
    &quot;inactive&quot;
  }, {
    INF_USER_UNAVAILABLE,
    &quot;INF_USER_UNAVAILABLE&quot;,
    &quot;unavailable&quot;
  }, {
    0,
<A NAME="2"></A>    NULL,
    NULL
  }
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match360-1.html#2',3,'match360-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

typedef struct _InfUserPrivate InfUserPrivate;
struct _InfUserPrivate {
  guint id;
  gchar* name;
  InfUserStatus status;
  InfUserFlags flags;
  InfXmlConnection* connection;
};

enum {
  PROP_0,

  PROP_ID,
  PROP_NAME,
  PROP_STATUS,
  PROP_FLAGS,
  PROP_CONNECTION
};

enum {
  SET_STATUS,

  LAST_SIGNAL
};

#define INF_USER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_USER, InfUserPrivate))
#define INF_USER_PRIVATE(obj)     ((InfUserPrivate*)(obj)-&gt;priv)

static guint user_signals[LAST_SIGNAL];

INF_DEFINE_FLAGS_TYPE(InfUserFlags, inf_user_flags, inf_user_flags_values)
INF_DEFINE_ENUM_TYPE(InfUserStatus, inf_user_status, inf_user_status_values)
G_DEFINE_TYPE_WITH_CODE(InfUser, inf_user, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfUser))

static void</B></FONT>
inf_user_init(InfUser* user)
{
  InfUserPrivate* priv;

  user-&gt;priv = INF_USER_GET_PRIVATE(user);
  priv = INF_USER_PRIVATE(user);

  priv-&gt;id = 0;
  priv-&gt;name = NULL;
  priv-&gt;status = INF_USER_UNAVAILABLE;
  priv-&gt;flags = 0;
  priv-&gt;connection = NULL;
}

static void
inf_user_dispose(GObject* object)
{
  InfUser* user;
  InfUserPrivate* priv;

<A NAME="0"></A>  user = INF_USER(object);
  priv = INF_USER_PRIVATE(user);

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match360-1.html#0',3,'match360-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  if(priv-&gt;connection != NULL)
  {
    g_object_unref(priv-&gt;connection);
    priv-&gt;connection = NULL;
  }

  G_OBJECT_CLASS(inf_user_parent_class)-&gt;dispose(object);
}

static void
inf_user_finalize(GObject* object)
{
  InfUser* user;
  InfUserPrivate* priv;

  user = INF_USER(object);
  priv = INF_USER_PRIVATE(user);

  g_free(priv-&gt;name);

  G_OBJECT_CLASS(inf_user_parent_class)-&gt;finalize(object);
}

static void
inf_user_set_property(GObject* object,
                      guint prop_id,
                      const GValue* value,
                      GParamSpec* pspec)
{
  InfUser* user;
  InfUserPrivate* priv;

  user = INF_USER(object);
  priv = INF_USER_PRIVATE(user);

  /* TODO: Check if properties are still valid.
   * There are several combinations possible:
   *
   * Status  | Flags | Connection | Desc
   * UNAVAIL |   0   |   unset    | User not available, was non-local last time
   *  AVAIL  |   0   |   unset    | INVALID
   * UNAVAIL | LOCAL |   unset    | User not available, was local last time
   *  AVAIL  | LOCAL |   unset    | User is available, and local
   * UNAVAIL |   0   |    set     | INVALID
   *  AVAIL  |   0   |    set     | User is available, non-local
   * UNAVAIL | LOCAL |    set     | INVALID
   *  AVAIL  | LOCAL |    set     | INVALID */

  switch(prop_id)
  {
  case PROP_ID:</B></FONT>
    priv-&gt;id = g_value_get_uint(value);
    break;
  case PROP_NAME:
    g_free(priv-&gt;name);
    priv-&gt;name = g_value_dup_string(value);
    break;
  case PROP_STATUS:
    g_signal_emit(
      object,
      user_signals[SET_STATUS],
      0,
      g_value_get_enum(value)
    );

    break;
  case PROP_FLAGS:
    priv-&gt;flags = g_value_get_flags(value);
    break;
<A NAME="3"></A>  case PROP_CONNECTION:
    if(priv-&gt;connection != NULL) g_object_unref(priv-&gt;connection);
    priv-&gt;connection = INF_XML_CONNECTION(g_value_dup_object(value));
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match360-1.html#3',3,'match360-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_user_get_property(GObject* object,
                      guint prop_id,
                      GValue* value,
                      GParamSpec* pspec)
{
  InfUser* user;
  InfUserPrivate* priv;

  user = INF_USER(object);
  priv = INF_USER_PRIVATE(user);
<A NAME="1"></A>
  switch(prop_id)
  {</B></FONT>
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match360-1.html#1',3,'match360-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  case PROP_ID:
    g_value_set_uint(value, priv-&gt;id);
    break;
  case PROP_NAME:
    g_value_set_string(value, priv-&gt;name);
    break;
  case PROP_STATUS:
    g_value_set_enum(value, priv-&gt;status);
    break;
  case PROP_FLAGS:
    g_value_set_flags(value, priv-&gt;flags);
    break;
  case PROP_CONNECTION:
    g_value_set_object(value, G_OBJECT(priv-&gt;connection));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_user_set_status_handler(InfUser* user,
                            InfUserStatus status)
{
  InfUserPrivate* priv;
  priv = INF_USER_PRIVATE(user);</B></FONT>

  priv-&gt;status = status;
}

static void
inf_user_class_init(InfUserClass* user_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(user_class);

  object_class-&gt;dispose = inf_user_dispose;
  object_class-&gt;finalize = inf_user_finalize;
  object_class-&gt;set_property = inf_user_set_property;
  object_class-&gt;get_property = inf_user_get_property;

  user_class-&gt;set_status = inf_user_set_status_handler;

  g_object_class_install_property(
    object_class,
    PROP_ID,
    g_param_spec_uint(
      &quot;id&quot;,
      &quot;User ID&quot;,
      &quot;A Unique User ID&quot;,
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_NAME,
    g_param_spec_string(
      &quot;name&quot;,
      &quot;User Name&quot;,
      &quot;The Name with which a user joined a session. Most servers &quot;
      &quot;ensure that it is unique.&quot;,
      &quot;&quot;,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_STATUS,
    g_param_spec_enum(
      &quot;status&quot;,
      &quot;User Status&quot;,
      &quot;Whether the user is currently available or not.&quot;,
      INF_TYPE_USER_STATUS,
      INF_USER_UNAVAILABLE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_FLAGS,
    g_param_spec_flags(
      &quot;flags&quot;,
      &quot;Flags&quot;,
      &quot;Flags the user currently has&quot;,
      INF_TYPE_USER_FLAGS,
      0,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_CONNECTION,
    g_param_spec_object(
      &quot;connection&quot;,
      &quot;Connection&quot;,
      &quot;Connection to the user&quot;,
      INF_TYPE_XML_CONNECTION,
      G_PARAM_READWRITE
    )
  );

  /**
   * InfUser::set-status:
   * @user: The #InfUser that changes status.
   * @status: The new user status.
   *
   * This signal is emitted whenever the user's status changes. This is
   * basically the same as a notification for the #InfUser:status property,
   * but it allows to access the previous user status when connecting before
   * the default signal handler.
   */
  user_signals[SET_STATUS] = g_signal_new(
    &quot;set-status&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfUserClass, set_status),
    NULL, NULL,
    g_cclosure_marshal_VOID__ENUM,
    G_TYPE_NONE,
    1,
    INF_TYPE_USER_STATUS
  );
}

/**
 * inf_user_get_id:
 * @user: A #InfUser.
 *
 * Returns the ID of the given #InfUser.
 *
 * Returns: A numerical User ID.
 **/
guint
inf_user_get_id(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), 0);
  return INF_USER_PRIVATE(user)-&gt;id;
}

/**
 * inf_user_get_name:
 * @user: A #InfUser.
 *
 * Returns the name of the given #InfUser.
 *
 * Returns: (transfer none): The user's name.
 **/
const gchar*
inf_user_get_name(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), NULL);
  return INF_USER_PRIVATE(user)-&gt;name;
}

/**
 * inf_user_get_status:
 * @user: A #InfUser.
 *
 * Returns the status of the given #InfUser.
 *
 * Returns: The user's status.
 **/
InfUserStatus
inf_user_get_status(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), INF_USER_UNAVAILABLE);
  return INF_USER_PRIVATE(user)-&gt;status;
}

/**
 * inf_user_get_flags:
 * @user: A #InfUser.
 *
 * Returns the flags for the given #InfUser.
 *
 * Returns: The user's flags.
 **/
InfUserFlags
inf_user_get_flags(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), 0);
  return INF_USER_PRIVATE(user)-&gt;flags;
}

/**
 * inf_user_get_connection:
 * @user: A #InfUser.
 *
 * Returns a connection to the given #InfUser, or %NULL. If a non-%NULL
 * connection is returned, then this is the connection through which records
 * from that user come from. This means that, when this connection is closed,
 * then the user is no longer available. However, you cannot send something
 * to this connection expecting the user will receive it. For example,
 * in central messaging mode, this connection is always the publisher, because
 * all records from the user are relayed via the publisher.
 *
 * If this functions returns %NULL, this either means @user is a local user
 * (%INF_USER_LOCAL flag set) or it is not available (status is
 * %INF_USER_UNAVAILABLE).
 *
 * Returns: (transfer none) (allow-none): A #InfXmlConnection, or %NULL.
 **/
InfXmlConnection*
inf_user_get_connection(InfUser* user)
{
  g_return_val_if_fail(INF_IS_USER(user), NULL);
  return INF_USER_PRIVATE(user)-&gt;connection;
}

/**
 * inf_user_status_to_string:
 * @status: A value from the #InfUserStatus enumeration.
 *
 * Returns a non-localized string identifying the given status. This is not
 * meant to be shown to a user, but rather to serialize a user status, for
 * example to store it in XML.
 *
 * Returns: (transfer none): A static string representation of @status.
 */
const gchar*
inf_user_status_to_string(InfUserStatus status)
{
  switch(status)
  {
  case INF_USER_ACTIVE: return &quot;active&quot;;
  case INF_USER_INACTIVE: return &quot;inactive&quot;;
  case INF_USER_UNAVAILABLE: return &quot;unavailable&quot;;
  default: g_assert_not_reached();
  }
}

/**
 * inf_user_status_from_string:
 * @string: A string representation of a #InfUserStatus.
 * @status: (out) (allow-none): A pointer to a #InfUserStatus value, or %NULL.
 * @error: Location to store error information, if any.
 *
 * This function does the opposite of inf_user_status_to_string(). It turns
 * the given string back to a #InfUserStatus, storing the result in @status
 * if @status is non-%NULL. If @string is invalid, then @status is left
 * untouched, @error is set and %FALSE is returned. Otherwise, the function
 * returns %TRUE.
 *
 * Returns: When an error occurred during the conversion, %FALSE is returned,
 * and %TRUE otherwise.
 */
gboolean
inf_user_status_from_string(const gchar* string,
                            InfUserStatus* status,
                            GError** error)
{
  InfUserStatus tmp_status;

  if(strcmp(string, &quot;active&quot;) == 0)
    tmp_status = INF_USER_ACTIVE;
  else if(strcmp(string, &quot;inactive&quot;) == 0)
    tmp_status = INF_USER_INACTIVE;
  else if(strcmp(string, &quot;unavailable&quot;) == 0)
    tmp_status = INF_USER_UNAVAILABLE;
  else
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_INVALID_STATUS,
      _(&quot;Invalid user status: '%s'&quot;),
      string
    );

    return FALSE;
  }

  if(status) *status = tmp_status;
  return TRUE;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-xmpp-server.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinfinity/server/infd-xmpp-server.h&gt;
#include &lt;libinfinity/server/infd-tcp-server.h&gt;
#include &lt;libinfinity/server/infd-xml-server.h&gt;
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

/* Some Windows header #defines ERROR for no good */
#ifdef G_OS_WIN32
# ifdef ERROR
#  undef ERROR
# endif
#endif

<A NAME="2"></A>typedef enum InfdXmppServerStatus_ {
  INFD_XMPP_SERVER_CLOSED,
  INFD_XMPP_SERVER_OPEN
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match360-0.html#2',2,'match360-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>} InfdXmppServerStatus;

typedef struct _InfdXmppServerPrivate InfdXmppServerPrivate;
struct _InfdXmppServerPrivate {
  InfdTcpServer* tcp;
  InfdXmppServerStatus status;
  gchar* local_hostname;
  InfXmppConnectionSecurityPolicy security_policy;

  InfCertificateCredentials* tls_creds;

  InfSaslContext* sasl_context;
  InfSaslContext* sasl_own_context;
  gchar* sasl_mechanisms;
};

enum {
  PROP_0,

  PROP_TCP,
  PROP_LOCAL_HOSTNAME,

  PROP_CREDENTIALS,
  PROP_SASL_CONTEXT,
  PROP_SASL_MECHANISMS,

  PROP_SECURITY_POLICY,

  /* Overridden from XML server */
  PROP_STATUS
};

enum {
  ERROR,

  LAST_SIGNAL
};

#define INFD_XMPP_SERVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_XMPP_SERVER, InfdXmppServerPrivate))

static guint xmpp_server_signals[LAST_SIGNAL];

static void infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface);</B></FONT>
G_DEFINE_TYPE_WITH_CODE(InfdXmppServer, infd_xmpp_server, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfdXmppServer)
  G_IMPLEMENT_INTERFACE(INFD_TYPE_XML_SERVER, infd_xmpp_server_xml_server_iface_init))

static void
infd_xmpp_server_new_connection_cb(InfdTcpServer* tcp_server,
                                   InfTcpConnection* tcp_connection,
                                   gpointer user_data)
{
  InfdXmppServer* xmpp_server;
  InfdXmppServerPrivate* priv;
  InfXmppConnection* xmpp_connection;
  InfIpAddress* addr;
  gchar* addr_str;

  xmpp_server = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp_server);

  /* TODO: We could perform a reverse DNS lookup to find the client hostname
   * here. */
  g_object_get(G_OBJECT(tcp_connection), &quot;remote-address&quot;, &amp;addr, NULL);
  addr_str = inf_ip_address_to_string(addr);
  inf_ip_address_free(addr);

  xmpp_connection = inf_xmpp_connection_new(
    tcp_connection,
    INF_XMPP_CONNECTION_SERVER,
    priv-&gt;local_hostname,
    addr_str,
    priv-&gt;security_policy,
    priv-&gt;tls_creds,
    priv-&gt;sasl_context,
    priv-&gt;sasl_own_context != NULL ? &quot;ANONYMOUS&quot; : priv-&gt;sasl_mechanisms
  );

  g_free(addr_str);

  /* We could, alternatively, keep the connection around until authentication
   * has completed and emit the new_connection signal after that, to guarantee
   * that the connection is open when new_connection is emitted. */
  infd_xml_server_new_connection(
    INFD_XML_SERVER(xmpp_server),
    INF_XML_CONNECTION(xmpp_connection)
  );

  g_object_unref(G_OBJECT(xmpp_connection));
}

static void
infd_xmpp_server_error_cb(InfdTcpServer* tcp_server,
                          GError* error,
                          gpointer user_data)
{
  g_signal_emit(
    G_OBJECT(user_data),
    xmpp_server_signals[ERROR],
    0,
    error
  );
}

static void
infd_xmpp_server_notify_status_cb(InfdTcpServer* tcp_server,
                                  GParamSpec* pspec,
                                  gpointer user_data)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  InfdTcpServerStatus status;

  xmpp = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_object_get(G_OBJECT(tcp_server), &quot;status&quot;, &amp;status, NULL);

  switch(status)
  {
  case INFD_TCP_SERVER_CLOSED:
  case INFD_TCP_SERVER_BOUND:
    if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
    {
      priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
      g_object_notify(G_OBJECT(xmpp), &quot;status&quot;);
    }

    break;
  case INFD_TCP_SERVER_OPEN:
    if(priv-&gt;status != INFD_XMPP_SERVER_OPEN)
    {
      priv-&gt;status = INFD_XMPP_SERVER_OPEN;
<A NAME="3"></A>      g_object_notify(G_OBJECT(xmpp), &quot;status&quot;);
    }

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match360-0.html#3',2,'match360-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    break;
  default:
    g_assert_not_reached();
    break;
  }
}

static void
infd_xmpp_server_sasl_cb(InfSaslContextSession* session,
                         Gsasl_property property,
                         gpointer session_data,
                         gpointer user_data)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;

  xmpp = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);

  switch(property)
  {</B></FONT>
  case GSASL_ANONYMOUS_TOKEN:
    inf_sasl_context_session_set_property(
      session,
      GSASL_ANONYMOUS_TOKEN,
      priv-&gt;local_hostname
    );

    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  case GSASL_VALIDATE_ANONYMOUS:
    /* Authentaction always successful */
    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  default:
    /* This is only used when using built-in SASL context, and this one
     * only supports anonymous authentication. */
    g_assert_not_reached();
    inf_sasl_context_session_continue(session, GSASL_NO_CALLBACK);
    break;
  }
}

/* Set own SASL context based on whether an external one is given or not */
static void
infd_xmpp_server_setup_own_sasl_context(InfdXmppServer* xmpp)
{
  InfdXmppServerPrivate* priv;

  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_assert(priv-&gt;sasl_own_context == NULL);

  if(priv-&gt;sasl_context == NULL &amp;&amp; priv-&gt;tcp != NULL)
  {
    /* Failure does not matter too much because every XMPP connection will
     * generate an own SASL context in this case, and error out if that
     * fails again. */
    priv-&gt;sasl_own_context = inf_sasl_context_new(NULL);

    if(priv-&gt;sasl_own_context != NULL)
    {
      priv-&gt;sasl_context = priv-&gt;sasl_own_context;
      inf_sasl_context_ref(priv-&gt;sasl_context);

      inf_sasl_context_set_callback(
        priv-&gt;sasl_context,
        infd_xmpp_server_sasl_cb,
        xmpp,
        NULL
      );

      g_object_notify(G_OBJECT(xmpp), &quot;sasl-context&quot;);
    }
  }
}

static void
infd_xmpp_server_set_tcp(InfdXmppServer* xmpp,
                         InfdTcpServer* tcp)
{
  InfdXmppServerPrivate* priv;
  InfdTcpServerStatus tcp_status;

  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);

  g_object_freeze_notify(G_OBJECT(xmpp));

  if(priv-&gt;tcp != NULL)
  {
    g_object_get(G_OBJECT(priv-&gt;tcp), &quot;status&quot;, &amp;tcp_status, NULL);

    /* This will cause a notify that will adjust the XMPP status later */
    if(tcp_status != INFD_TCP_SERVER_CLOSED)
      infd_tcp_server_close(priv-&gt;tcp);

    /* TODO: Make sure there are no connections with sasl_own_context out
     * there anymore because otherwise the SASL callback might access an
     * invalid InfdServer pointer once we get finalized. */
    /* TODO: Or, give data associated with the SASL context its own
     * life cycle. Should be easy given that it has a destroy notify. */
    if(priv-&gt;sasl_own_context != NULL)
    {
      inf_sasl_context_unref(priv-&gt;sasl_own_context);
      priv-&gt;sasl_own_context = NULL;
    }

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_new_connection_cb),
      xmpp
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_error_cb),
      xmpp
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_notify_status_cb),
      xmpp
    );

    g_object_unref(G_OBJECT(priv-&gt;tcp));
  }

  priv-&gt;tcp = tcp;

  if(tcp != NULL)
  {
    g_object_ref(G_OBJECT(tcp));

    g_signal_connect(
      G_OBJECT(tcp),
      &quot;new-connection&quot;,
      G_CALLBACK(infd_xmpp_server_new_connection_cb),
      xmpp
    );

    g_signal_connect(
      G_OBJECT(tcp),
      &quot;error&quot;,
      G_CALLBACK(infd_xmpp_server_error_cb),
      xmpp
    );

    g_signal_connect(
      G_OBJECT(tcp),
      &quot;notify::status&quot;,
      G_CALLBACK(infd_xmpp_server_notify_status_cb),
      xmpp
    );

    g_object_get(G_OBJECT(tcp), &quot;status&quot;, &amp;tcp_status, NULL);
    switch(tcp_status)
    {
    case INFD_TCP_SERVER_CLOSED:
    case INFD_TCP_SERVER_BOUND:
      g_assert(priv-&gt;status == INFD_XMPP_SERVER_CLOSED);
      break;
    case INFD_TCP_SERVER_OPEN:
      priv-&gt;status = INFD_XMPP_SERVER_OPEN;
      g_object_notify(G_OBJECT(xmpp), &quot;status&quot;);
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }

  infd_xmpp_server_setup_own_sasl_context(xmpp);
  g_object_thaw_notify(G_OBJECT(xmpp));
}

static void
infd_xmpp_server_init(InfdXmppServer* xmpp)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);

  priv-&gt;tcp = NULL;
  priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
  priv-&gt;local_hostname = g_strdup(g_get_host_name());
  priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED;

  priv-&gt;tls_creds = NULL;
  priv-&gt;sasl_context = NULL;
  priv-&gt;sasl_own_context = NULL;
  priv-&gt;sasl_mechanisms = NULL;
}

static void
infd_xmpp_server_dispose(GObject* object)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;

  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);

  if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
    infd_xml_server_close(INFD_XML_SERVER(xmpp));

  infd_xmpp_server_set_tcp(xmpp, NULL);

  if(priv-&gt;sasl_own_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_own_context);
    priv-&gt;sasl_own_context = NULL;
  }

  if(priv-&gt;sasl_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_context);
<A NAME="0"></A>    priv-&gt;sasl_context = NULL;
  }

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match360-0.html#0',2,'match360-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  if(priv-&gt;tls_creds != NULL)
  {
    inf_certificate_credentials_unref(priv-&gt;tls_creds);
    priv-&gt;tls_creds = NULL;
  }

  G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;dispose(object);
}

static void
infd_xmpp_server_finalize(GObject* object)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;

  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);

  g_free(priv-&gt;local_hostname);
  g_free(priv-&gt;sasl_mechanisms);

  G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;finalize(object);
}

static void
infd_xmpp_server_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;

  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);

  switch(prop_id)
  {
  case PROP_TCP:</B></FONT>
    infd_xmpp_server_set_tcp(
      xmpp,
      INFD_TCP_SERVER(g_value_get_object(value))
    );

    break;
  case PROP_LOCAL_HOSTNAME:
    g_free(priv-&gt;local_hostname);
    priv-&gt;local_hostname = g_value_dup_string(value);
    if(priv-&gt;local_hostname == NULL)
      priv-&gt;local_hostname = g_strdup(g_get_host_name());
    break;
  case PROP_CREDENTIALS:
    if(priv-&gt;tls_creds != NULL)
      inf_certificate_credentials_unref(priv-&gt;tls_creds);
    priv-&gt;tls_creds = g_value_dup_boxed(value);
    break;
  case PROP_SASL_CONTEXT:
    if(priv-&gt;sasl_own_context != NULL)
    {
      inf_sasl_context_unref(priv-&gt;sasl_own_context);
      priv-&gt;sasl_own_context = NULL;
    }

    if(priv-&gt;sasl_context != NULL)
      inf_sasl_context_unref(priv-&gt;sasl_context);

    priv-&gt;sasl_context = g_value_dup_boxed(value);
    infd_xmpp_server_setup_own_sasl_context(xmpp);
    break;
  case PROP_SASL_MECHANISMS:
    g_free(priv-&gt;sasl_mechanisms);
    priv-&gt;sasl_mechanisms = g_value_dup_string(value);
    break;
  case PROP_SECURITY_POLICY:
    infd_xmpp_server_set_security_policy(xmpp, g_value_get_enum(value));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infd_xmpp_server_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;

  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);

  switch(prop_id)
  {
  case PROP_STATUS:
    switch(priv-&gt;status)
    {
    case INFD_XMPP_SERVER_CLOSED:
      g_value_set_enum(value, INFD_XML_SERVER_CLOSED);
      break;
    case INFD_XMPP_SERVER_OPEN:
      g_value_set_enum(value, INFD_XML_SERVER_OPEN);
      break;
    default:
      g_assert_not_reached();
      break;
    }

    break;
<A NAME="1"></A>  case PROP_TCP:
    g_value_set_object(value, priv-&gt;tcp);
    break;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match360-0.html#1',2,'match360-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  case PROP_LOCAL_HOSTNAME:
    g_value_set_string(value, priv-&gt;local_hostname);
    break;
  case PROP_CREDENTIALS:
    g_value_set_boxed(value, priv-&gt;tls_creds);
    break;
  case PROP_SASL_CONTEXT:
    g_value_set_boxed(value, priv-&gt;sasl_context);
    break;
  case PROP_SASL_MECHANISMS:
    g_value_set_string(value, priv-&gt;sasl_mechanisms);
    break;
  case PROP_SECURITY_POLICY:
    g_value_set_enum(value, priv-&gt;security_policy);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infd_xmpp_server_xml_server_close(InfdXmlServer* xml)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xml);</B></FONT>

  g_return_if_fail(priv-&gt;status != INFD_XMPP_SERVER_CLOSED);

  switch(priv-&gt;status)
  {
  case INFD_XMPP_SERVER_OPEN:
    /* This will cause a status notify that will adjust the XMPP status */
    infd_tcp_server_close(priv-&gt;tcp);
    break;
  case INFD_XMPP_SERVER_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
}

static void
infd_xmpp_server_class_init(InfdXmppServerClass* xmpp_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(xmpp_class);

  object_class-&gt;dispose = infd_xmpp_server_dispose;
  object_class-&gt;finalize = infd_xmpp_server_finalize;
  object_class-&gt;set_property = infd_xmpp_server_set_property;
  object_class-&gt;get_property = infd_xmpp_server_get_property;

  xmpp_class-&gt;error = NULL;

  g_object_class_install_property(
    object_class,
    PROP_TCP,
    g_param_spec_object(
      &quot;tcp-server&quot;,
      &quot;TCP server&quot;,
      &quot;Underlaying TCP server&quot;,
      INFD_TYPE_TCP_SERVER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_LOCAL_HOSTNAME,
    g_param_spec_string(
      &quot;local-hostname&quot;,
      &quot;Local hostname&quot;,
      &quot;Hostname of the server&quot;,
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_CREDENTIALS,
    g_param_spec_boxed(
      &quot;credentials&quot;,
      &quot;Credentials&quot;,
      &quot;The certificate credentials for GnuTLS&quot;,
      INF_TYPE_CERTIFICATE_CREDENTIALS,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SASL_CONTEXT,
    g_param_spec_boxed(
      &quot;sasl-context&quot;,
      &quot;SASL context&quot;,
      &quot;The SASL context used for authentaction&quot;,
      INF_TYPE_SASL_CONTEXT,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SASL_MECHANISMS,
    g_param_spec_string(
      &quot;sasl-mechanisms&quot;,
      &quot;SASL mechanisms&quot;,
      &quot;The SASL mechanisms offered to the client for authentication&quot;,
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SECURITY_POLICY,
    g_param_spec_enum(
      &quot;security-policy&quot;,
      &quot;Security policy&quot;,
      &quot;Whether to offer or require TLS&quot;,
      INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
      INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_override_property(object_class, PROP_STATUS, &quot;status&quot;);

  xmpp_server_signals[ERROR] = g_signal_new(
    &quot;error&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdXmppServerClass, error),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    G_TYPE_ERROR
  );
}

static void
infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface)
{
  iface-&gt;close = infd_xmpp_server_xml_server_close;
}

/**
 * infd_xmpp_server_new: (constructor)
 * @tcp: A #InfdTcpServer.
 * @policy: The initial security policy.
 * @creds: Certificate credentials used to secure any communication.
 * @sasl_context: A SASL context used for authentication.
 * @sasl_mechanisms: A whitespace-sparated list of SASL mechanisms.
 *
 * Creates a new #InfdXmppServer with @tcp as underlaying TCP server object.
 * No attempt is being made to open @tcp, if it is not already open. When a
 * new connection comes in, the XMPP server creates a XMPP connection that
 * may be used to communicate with the client. Note however that the
 * resulting connection will be in status OPENING until authentication has
 * completed.
 *
 * If @policy is %INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED, then @creds may
 * be %NULL. If @creds is non-%NULL nevertheless, then it is possible to change
 * the security policy later using infd_xmpp_server_set_security_policy().
 * @creds can also be changed later while the server is running. So just set
 * valid credentials before changing @policy to allow TLS.
 *
 * If @sasl_context is %NULL, the server uses a built-in context that only
 * supports ANONYMOUS authentication. If @sasl_context is not %NULL, then
 * @sasl_mechanisms specifies the mechanisms offered to clients. If
 * @sasl_mechanisms is %NULL, then all available mechanims will be offered.
 * If @sasl_context is %NULL, then this parameter is ignored.
 *
 * Return Value: (transfer full): A new #InfdXmppServer.
 **/
InfdXmppServer*
infd_xmpp_server_new(InfdTcpServer* tcp,
                     InfXmppConnectionSecurityPolicy policy,
                     InfCertificateCredentials* creds,
                     InfSaslContext* sasl_context,
                     const gchar* sasl_mechanisms)
{
  GObject* object;

  g_return_val_if_fail(INFD_IS_TCP_SERVER(tcp), NULL);

  g_return_val_if_fail(
    policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED || creds != NULL,
    NULL
  );

  object = g_object_new(
    INFD_TYPE_XMPP_SERVER,
    &quot;tcp-server&quot;, tcp,
    &quot;credentials&quot;, creds,
    &quot;security-policy&quot;, policy,
    &quot;sasl-context&quot;, sasl_context,
    &quot;sasl-mechanisms&quot;, sasl_mechanisms,
    NULL
  );

  return INFD_XMPP_SERVER(object);
}

/**
 * infd_xmpp_server_set_security_policy:
 * @server: A #InfdXmppServer.
 * @policy: The new security policy.
 *
 * Sets the security policy for newly accepted #InfXmppConnection&lt;!-- --&gt;s.
 * Does not already established connections.
 */
void
infd_xmpp_server_set_security_policy(InfdXmppServer* server,
                                     InfXmppConnectionSecurityPolicy policy)
{
  InfdXmppServerPrivate* priv;

  g_return_if_fail(INFD_IS_XMPP_SERVER(server));

  priv = INFD_XMPP_SERVER_PRIVATE(server);

  if(policy != priv-&gt;security_policy)
  {
    g_return_if_fail(
      policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
      priv-&gt;tls_creds != NULL
    );

    priv-&gt;security_policy = policy;
    g_object_notify(G_OBJECT(server), &quot;security-policy&quot;);
  }
}

/**
 * infd_xmpp_server_get_security_policy:
 * @server: A #InfdXmppServer.
 *
 * Returns the current security policy for newly accepted
 * #InfXmppConnection&lt;!-- --&gt;s.
 *
 * Returns: The current security policy.
 */
InfXmppConnectionSecurityPolicy
infd_xmpp_server_get_security_policy(InfdXmppServer* server)
{
  g_return_val_if_fail(
    INFD_IS_XMPP_SERVER(server),
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
  );

  return INFD_XMPP_SERVER_PRIVATE(server)-&gt;security_policy;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
