
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 29, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc_internal.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_H
2  #define	JEMALLOC_INTERNAL_H
3  #include &quot;jemalloc_internal_defs.h&quot;
4  #include &quot;jemalloc/internal/jemalloc_internal_decls.h&quot;
5  #ifdef JEMALLOC_UTRACE
6  #include &lt;sys/ktrace.h&gt;
7  #endif
8  #define	JEMALLOC_NO_DEMANGLE
9  #ifdef JEMALLOC_JET
10  #  define JEMALLOC_N(n) jet_##n
11  #  include &quot;jemalloc/internal/public_namespace.h&quot;
12  #  define JEMALLOC_NO_RENAME
13  #  include &quot;../jemalloc.h&quot;
14  #  undef JEMALLOC_NO_RENAME
15  #else
16  #  define JEMALLOC_N(n) je_##n
17  #  include &quot;../jemalloc.h&quot;
18  #endif
19  #include &quot;jemalloc/internal/private_namespace.h&quot;
20  static const bool config_debug =
21  #ifdef JEMALLOC_DEBUG
22      true
23  #else
24      false
25  #endif
26      ;
27  static const bool have_dss =
28  #ifdef JEMALLOC_DSS
29      true
30  #else
31      false
32  #endif
33      ;
34  static const bool config_fill =
35  #ifdef JEMALLOC_FILL
36      true
37  #else
38      false
39  #endif
40      ;
41  static const bool config_lazy_lock =
42  #ifdef JEMALLOC_LAZY_LOCK
43      true
44  #else
45      false
46  #endif
47      ;
48  static const bool config_prof =
49  #ifdef JEMALLOC_PROF
50      true
51  #else
52      false
53  #endif
54      ;
55  static const bool config_prof_libgcc =
56  #ifdef JEMALLOC_PROF_LIBGCC
57      true
58  #else
59      false
60  #endif
61      ;
62  static const bool config_prof_libunwind =
63  #ifdef JEMALLOC_PROF_LIBUNWIND
64      true
65  #else
66      false
67  #endif
68      ;
69  static const bool maps_coalesce =
70  #ifdef JEMALLOC_MAPS_COALESCE
71      true
72  #else
73      false
74  #endif
75      ;
76  static const bool config_munmap =
77  #ifdef JEMALLOC_MUNMAP
78      true
79  #else
80      false
81  #endif
82      ;
83  static const bool config_stats =
84  #ifdef JEMALLOC_STATS
85      true
86  #else
87      false
88  #endif
89      ;
90  static const bool config_tcache =
91  #ifdef JEMALLOC_TCACHE
92      true
93  #else
94      false
95  #endif
96      ;
97  static const bool config_tls =
98  #ifdef JEMALLOC_TLS
99      true
100  #else
101      false
102  #endif
103      ;
104  static const bool config_utrace =
105  #ifdef JEMALLOC_UTRACE
106      true
107  #else
108      false
109  #endif
110      ;
111  static const bool config_valgrind =
112  #ifdef JEMALLOC_VALGRIND
113      true
114  #else
115      false
116  #endif
117      ;
118  static const bool config_xmalloc =
119  #ifdef JEMALLOC_XMALLOC
120      true
121  #else
122      false
123  #endif
124      ;
125  static const bool config_ivsalloc =
126  #ifdef JEMALLOC_IVSALLOC
127      true
128  #else
129      false
130  #endif
131      ;
132  static const bool config_cache_oblivious =
133  #ifdef JEMALLOC_CACHE_OBLIVIOUS
134      true
135  #else
136      false
137  #endif
138      ;
139  #ifdef JEMALLOC_C11ATOMICS
140  #include &lt;stdatomic.h&gt;
141  #endif
142  #ifdef JEMALLOC_ATOMIC9
143  #include &lt;machine/atomic.h&gt;
144  #endif
145  #if (defined(JEMALLOC_OSATOMIC) || defined(JEMALLOC_OSSPIN))
146  #include &lt;libkern/OSAtomic.h&gt;
147  #endif
148  #ifdef JEMALLOC_ZONE
149  #include &lt;mach/mach_error.h&gt;
150  #include &lt;mach/mach_init.h&gt;
151  #include &lt;mach/vm_map.h&gt;
152  #include &lt;malloc/malloc.h&gt;
153  #endif
154  #define	RB_COMPACT
155  #include &quot;jemalloc/internal/rb.h&quot;
156  #include &quot;jemalloc/internal/qr.h&quot;
157  #include &quot;jemalloc/internal/ql.h&quot;
158  #define	JEMALLOC_H_TYPES
159  #include &quot;jemalloc/internal/jemalloc_internal_macros.h&quot;
160  typedef unsigned szind_t;
161  #define	MALLOCX_ARENA_MASK	((int)~0xfffff)
162  #define	MALLOCX_ARENA_MAX	0xffe
163  #define	MALLOCX_TCACHE_MASK	((int)~0xfff000ffU)
164  #define	MALLOCX_TCACHE_MAX	0xffd
165  #define	MALLOCX_LG_ALIGN_MASK	((int)0x3f)
166  #define	MALLOCX_ALIGN_GET_SPECIFIED(flags)				\
167      (ZU(1) &lt;&lt; (flags &amp; MALLOCX_LG_ALIGN_MASK))
168  #define	MALLOCX_ALIGN_GET(flags)					\
169      (MALLOCX_ALIGN_GET_SPECIFIED(flags) &amp; (SIZE_T_MAX-1))
170  #define	MALLOCX_ZERO_GET(flags)						\
171      ((bool)(flags &amp; MALLOCX_ZERO))
172  #define	MALLOCX_TCACHE_GET(flags)					\
173      (((unsigned)((flags &amp; MALLOCX_TCACHE_MASK) &gt;&gt; 8)) - 2)
174  #define	MALLOCX_ARENA_GET(flags)					\
175      (((unsigned)(((unsigned)flags) &gt;&gt; 20)) - 1)
176  #define	TINY_MIN		(1U &lt;&lt; LG_TINY_MIN)
177  #ifndef LG_QUANTUM
178  #  if (defined(__i386__) || defined(_M_IX86))
179  #    define LG_QUANTUM		4
180  #  endif
181  #  ifdef __ia64__
182  #    define LG_QUANTUM		4
183  #  endif
184  #  ifdef __alpha__
185  #    define LG_QUANTUM		4
186  #  endif
187  #  if (defined(__sparc64__) || defined(__sparcv9))
188  #    define LG_QUANTUM		4
189  #  endif
190  #  if (defined(__amd64__) || defined(__x86_64__) || defined(_M_X64))
191  #    define LG_QUANTUM		4
192  #  endif
193  #  ifdef __arm__
194  #    define LG_QUANTUM		3
195  #  endif
196  #  ifdef __aarch64__
197  #    define LG_QUANTUM		4
198  #  endif
199  #  ifdef __hppa__
200  #    define LG_QUANTUM		4
201  #  endif
202  #  ifdef __mips__
203  #    define LG_QUANTUM		3
204  #  endif
205  #  ifdef __or1k__
206  #    define LG_QUANTUM		3
207  #  endif
208  #  ifdef __powerpc__
209  #    define LG_QUANTUM		4
210  #  endif
211  #  ifdef __s390__
212  #    define LG_QUANTUM		4
213  #  endif
214  #  ifdef __SH4__
215  #    define LG_QUANTUM		4
216  #  endif
217  #  ifdef __tile__
218  #    define LG_QUANTUM		4
219  #  endif
220  #  ifdef __le32__
221  #    define LG_QUANTUM		4
222  #  endif
223  #  ifndef LG_QUANTUM
224  #    error &quot;Unknown minimum alignment for architecture; specify via &quot;
225  	 &quot;--with-lg-quantum&quot;
226  #  endif
227  #endif
228  #define	QUANTUM			((size_t)(1U &lt;&lt; LG_QUANTUM))
229  #define	QUANTUM_MASK		(QUANTUM - 1)
230  #define	QUANTUM_CEILING(a)						\
231  	(((a) + QUANTUM_MASK) &amp; ~QUANTUM_MASK)
232  #define	LONG			((size_t)(1U &lt;&lt; LG_SIZEOF_LONG))
233  #define	LONG_MASK		(LONG - 1)
234  #define	LONG_CEILING(a)							\
235  	(((a) + LONG_MASK) &amp; ~LONG_MASK)
236  #define	SIZEOF_PTR		(1U &lt;&lt; LG_SIZEOF_PTR)
237  #define	PTR_MASK		(SIZEOF_PTR - 1)
238  #define	PTR_CEILING(a)							\
239  	(((a) + PTR_MASK) &amp; ~PTR_MASK)
240  #define	LG_CACHELINE		6
241  #define	CACHELINE		64
242  #define	CACHELINE_MASK		(CACHELINE - 1)
243  #define	CACHELINE_CEILING(s)						\
244  	(((s) + CACHELINE_MASK) &amp; ~CACHELINE_MASK)
245  #ifdef PAGE_MASK
246  #  undef PAGE_MASK
247  #endif
248  #define	PAGE		((size_t)(1U &lt;&lt; LG_PAGE))
249  #define	PAGE_MASK	((size_t)(PAGE - 1))
250  #define	PAGE_CEILING(s)							\
251  	(((s) + PAGE_MASK) &amp; ~PAGE_MASK)
252  #define	ALIGNMENT_ADDR2BASE(a, alignment)				\
253  	((void *)((uintptr_t)(a) &amp; (-(alignment))))
254  #define	ALIGNMENT_ADDR2OFFSET(a, alignment)				\
255  	((size_t)((uintptr_t)(a) &amp; (alignment - 1)))
256  #define	ALIGNMENT_CEILING(s, alignment)					\
257  	(((s) + (alignment - 1)) &amp; (-(alignment)))
258  #if __STDC_VERSION__ &lt; 199901L
259  #  ifdef _MSC_VER
260  #    include &lt;malloc.h&gt;
261  #    define alloca _alloca
262  #  else
263  #    ifdef JEMALLOC_HAS_ALLOCA_H
264  #      include &lt;alloca.h&gt;
265  #    else
266  #      include &lt;stdlib.h&gt;
267  #    endif
268  #  endif
269  #  define VARIABLE_ARRAY(type, name, count) \
270  	type *name = alloca(sizeof(type) * (count))
271  #else
272  #  define VARIABLE_ARRAY(type, name, count) type name[(count)]
273  #endif
274  #include &quot;jemalloc/internal/valgrind.h&quot;
275  #include &quot;jemalloc/internal/util.h&quot;
276  #include &quot;jemalloc/internal/atomic.h&quot;
277  #include &quot;jemalloc/internal/prng.h&quot;
278  #include &quot;jemalloc/internal/ckh.h&quot;
279  #include &quot;jemalloc/internal/size_classes.h&quot;
280  #include &quot;jemalloc/internal/stats.h&quot;
281  #include &quot;jemalloc/internal/ctl.h&quot;
282  #include &quot;jemalloc/internal/mutex.h&quot;
283  #include &quot;jemalloc/internal/tsd.h&quot;
284  #include &quot;jemalloc/internal/mb.h&quot;
285  #include &quot;jemalloc/internal/extent.h&quot;
286  #include &quot;jemalloc/internal/arena.h&quot;
287  #include &quot;jemalloc/internal/bitmap.h&quot;
288  #include &quot;jemalloc/internal/base.h&quot;
289  #include &quot;jemalloc/internal/rtree.h&quot;
290  #include &quot;jemalloc/internal/pages.h&quot;
291  #include &quot;jemalloc/internal/chunk.h&quot;
292  #include &quot;jemalloc/internal/huge.h&quot;
293  #include &quot;jemalloc/internal/tcache.h&quot;
294  #include &quot;jemalloc/internal/hash.h&quot;
295  #include &quot;jemalloc/internal/quarantine.h&quot;
296  #include &quot;jemalloc/internal/prof.h&quot;
297  #undef JEMALLOC_H_TYPES
298  #define	JEMALLOC_H_STRUCTS
299  #include &quot;jemalloc/internal/valgrind.h&quot;
300  #include &quot;jemalloc/internal/util.h&quot;
301  #include &quot;jemalloc/internal/atomic.h&quot;
302  #include &quot;jemalloc/internal/prng.h&quot;
303  #include &quot;jemalloc/internal/ckh.h&quot;
304  #include &quot;jemalloc/internal/size_classes.h&quot;
305  #include &quot;jemalloc/internal/stats.h&quot;
306  #include &quot;jemalloc/internal/ctl.h&quot;
307  #include &quot;jemalloc/internal/mutex.h&quot;
308  #include &quot;jemalloc/internal/mb.h&quot;
309  #include &quot;jemalloc/internal/bitmap.h&quot;
310  #define	JEMALLOC_ARENA_STRUCTS_A
311  #include &quot;jemalloc/internal/arena.h&quot;
312  #undef JEMALLOC_ARENA_STRUCTS_A
313  #include &quot;jemalloc/internal/extent.h&quot;
314  #define	JEMALLOC_ARENA_STRUCTS_B
315  #include &quot;jemalloc/internal/arena.h&quot;
316  #undef JEMALLOC_ARENA_STRUCTS_B
317  #include &quot;jemalloc/internal/base.h&quot;
318  #include &quot;jemalloc/internal/rtree.h&quot;
319  #include &quot;jemalloc/internal/pages.h&quot;
320  #include &quot;jemalloc/internal/chunk.h&quot;
321  #include &quot;jemalloc/internal/huge.h&quot;
322  #include &quot;jemalloc/internal/tcache.h&quot;
323  #include &quot;jemalloc/internal/hash.h&quot;
324  #include &quot;jemalloc/internal/quarantine.h&quot;
325  #include &quot;jemalloc/internal/prof.h&quot;
326  #include &quot;jemalloc/internal/tsd.h&quot;
327  #undef JEMALLOC_H_STRUCTS
328  #define	JEMALLOC_H_EXTERNS
329  extern bool	opt_abort;
330  extern const char	*opt_junk;
331  extern bool	opt_junk_alloc;
332  extern bool	opt_junk_free;
333  extern size_t	opt_quarantine;
334  extern bool	opt_redzone;
335  extern bool	opt_utrace;
336  extern bool	opt_xmalloc;
337  extern bool	opt_zero;
338  extern size_t	opt_narenas;
339  extern bool	in_valgrind;
340  extern unsigned		ncpus;
341  extern size_t const	index2size_tab[NSIZES];
342  extern uint8_t const	size2index_tab[];
343  arena_t	*a0get(void);
344  void	*a0malloc(size_t size);
345  void	a0dalloc(void *ptr);
346  void	*bootstrap_malloc(size_t size);
347  void	*bootstrap_calloc(size_t num, size_t size);
348  void	bootstrap_free(void *ptr);
349  arena_t	*arenas_extend(unsigned ind);
350  arena_t	*arena_init(unsigned ind);
351  unsigned	narenas_total_get(void);
352  arena_t	*arena_get_hard(tsd_t *tsd, unsigned ind, bool init_if_missing);
353  arena_t	*arena_choose_hard(tsd_t *tsd);
354  void	arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind);
355  unsigned	arena_nbound(unsigned ind);
356  void	thread_allocated_cleanup(tsd_t *tsd);
357  void	thread_deallocated_cleanup(tsd_t *tsd);
358  void	arena_cleanup(tsd_t *tsd);
359  void	arenas_cache_cleanup(tsd_t *tsd);
360  void	narenas_cache_cleanup(tsd_t *tsd);
361  void	arenas_cache_bypass_cleanup(tsd_t *tsd);
362  void	jemalloc_prefork(void);
363  void	jemalloc_postfork_parent(void);
364  void	jemalloc_postfork_child(void);
365  #include &quot;jemalloc/internal/valgrind.h&quot;
366  #include &quot;jemalloc/internal/util.h&quot;
367  #include &quot;jemalloc/internal/atomic.h&quot;
368  #include &quot;jemalloc/internal/prng.h&quot;
369  #include &quot;jemalloc/internal/ckh.h&quot;
370  #include &quot;jemalloc/internal/size_classes.h&quot;
371  #include &quot;jemalloc/internal/stats.h&quot;
372  #include &quot;jemalloc/internal/ctl.h&quot;
373  #include &quot;jemalloc/internal/mutex.h&quot;
374  #include &quot;jemalloc/internal/mb.h&quot;
375  #include &quot;jemalloc/internal/bitmap.h&quot;
376  #include &quot;jemalloc/internal/extent.h&quot;
377  #include &quot;jemalloc/internal/arena.h&quot;
378  #include &quot;jemalloc/internal/base.h&quot;
379  #include &quot;jemalloc/internal/rtree.h&quot;
380  #include &quot;jemalloc/internal/pages.h&quot;
381  #include &quot;jemalloc/internal/chunk.h&quot;
382  #include &quot;jemalloc/internal/huge.h&quot;
383  #include &quot;jemalloc/internal/tcache.h&quot;
384  #include &quot;jemalloc/internal/hash.h&quot;
385  #include &quot;jemalloc/internal/quarantine.h&quot;
386  #include &quot;jemalloc/internal/prof.h&quot;
387  #include &quot;jemalloc/internal/tsd.h&quot;
388  #undef JEMALLOC_H_EXTERNS
389  #define	JEMALLOC_H_INLINES
390  #include &quot;jemalloc/internal/valgrind.h&quot;
391  #include &quot;jemalloc/internal/util.h&quot;
392  #include &quot;jemalloc/internal/atomic.h&quot;
393  #include &quot;jemalloc/internal/prng.h&quot;
394  #include &quot;jemalloc/internal/ckh.h&quot;
395  #include &quot;jemalloc/internal/size_classes.h&quot;
396  #include &quot;jemalloc/internal/stats.h&quot;
397  #include &quot;jemalloc/internal/ctl.h&quot;
398  #include &quot;jemalloc/internal/mutex.h&quot;
399  #include &quot;jemalloc/internal/tsd.h&quot;
400  #include &quot;jemalloc/internal/mb.h&quot;
401  #include &quot;jemalloc/internal/extent.h&quot;
402  #include &quot;jemalloc/internal/base.h&quot;
403  #include &quot;jemalloc/internal/rtree.h&quot;
404  #include &quot;jemalloc/internal/pages.h&quot;
405  #include &quot;jemalloc/internal/chunk.h&quot;
406  #include &quot;jemalloc/internal/huge.h&quot;
407  #ifndef JEMALLOC_ENABLE_INLINE
408  szind_t	size2index_compute(size_t size);
409  szind_t	size2index_lookup(size_t size);
410  szind_t	size2index(size_t size);
411  size_t	index2size_compute(szind_t index);
412  size_t	index2size_lookup(szind_t index);
413  size_t	index2size(szind_t index);
414  size_t	s2u_compute(size_t size);
415  size_t	s2u_lookup(size_t size);
416  size_t	s2u(size_t size);
417  size_t	sa2u(size_t size, size_t alignment);
418  arena_t	*arena_choose(tsd_t *tsd, arena_t *arena);
419  arena_t	*arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
420      bool refresh_if_missing);
421  #endif
422  #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
423  JEMALLOC_INLINE szind_t
424  size2index_compute(size_t size)
425  {
426  #if (NTBINS != 0)
427  	if (size &lt;= (ZU(1) &lt;&lt; LG_TINY_MAXCLASS)) {
428  		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
429  		size_t lg_ceil = lg_floor(pow2_ceil(size));
430  		return (lg_ceil &lt; lg_tmin ? 0 : lg_ceil - lg_tmin);
431  	}
432  #endif
433  	{
434  		size_t x = unlikely(ZI(size) &lt; 0) ? ((size&lt;&lt;1) ?
435  		    (ZU(1)&lt;&lt;(LG_SIZEOF_PTR+3)) : ((ZU(1)&lt;&lt;(LG_SIZEOF_PTR+3))-1))
436  		    : lg_floor((size&lt;&lt;1)-1);
437  		size_t shift = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? 0 :
438  		    x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);
439  		size_t grp = shift &lt;&lt; LG_SIZE_CLASS_GROUP;
440  		size_t lg_delta = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
441  		    ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
442  		size_t delta_inverse_mask = ZI(-1) &lt;&lt; lg_delta;
443  		size_t mod = ((((size-1) &amp; delta_inverse_mask) &gt;&gt; lg_delta)) &amp;
444  		    ((ZU(1) &lt;&lt; LG_SIZE_CLASS_GROUP) - 1);
445  		size_t index = NTBINS + grp + mod;
446  		return (index);
447  	}
448  }
449  JEMALLOC_ALWAYS_INLINE szind_t
450  size2index_lookup(size_t size)
451  {
452  	assert(size &lt;= LOOKUP_MAXCLASS);
453  	{
454  		size_t ret = ((size_t)(size2index_tab[(size-1) &gt;&gt;
455  		    LG_TINY_MIN]));
456  		assert(ret == size2index_compute(size));
457  		return (ret);
458  	}
459  }
460  JEMALLOC_ALWAYS_INLINE szind_t
461  size2index(size_t size)
462  {
463  	assert(size &gt; 0);
464  	if (likely(size &lt;= LOOKUP_MAXCLASS))
465  		return (size2index_lookup(size));
466  	return (size2index_compute(size));
467  }
468  JEMALLOC_INLINE size_t
469  index2size_compute(szind_t index)
470  {
471  #if (NTBINS &gt; 0)
472  	if (index &lt; NTBINS)
473  		return (ZU(1) &lt;&lt; (LG_TINY_MAXCLASS - NTBINS + 1 + index));
474  #endif
475  	{
476  		size_t reduced_index = index - NTBINS;
477  		size_t grp = reduced_index &gt;&gt; LG_SIZE_CLASS_GROUP;
478  		size_t mod = reduced_index &amp; ((ZU(1) &lt;&lt; LG_SIZE_CLASS_GROUP) -
479  		    1);
480  		size_t grp_size_mask = ~((!!grp)-1);
481  		size_t grp_size = ((ZU(1) &lt;&lt; (LG_QUANTUM +
482  		    (LG_SIZE_CLASS_GROUP-1))) &lt;&lt; grp) &amp; grp_size_mask;
483  		size_t shift = (grp == 0) ? 1 : grp;
484  		size_t lg_delta = shift + (LG_QUANTUM-1);
485  		size_t mod_size = (mod+1) &lt;&lt; lg_delta;
486  		size_t usize = grp_size + mod_size;
487  		return (usize);
488  	}
489  }
490  JEMALLOC_ALWAYS_INLINE size_t
491  index2size_lookup(szind_t index)
492  {
493  	size_t ret = (size_t)index2size_tab[index];
494  	assert(ret == index2size_compute(index));
495  	return (ret);
496  }
497  JEMALLOC_ALWAYS_INLINE size_t
498  index2size(szind_t index)
499  {
500  	assert(index &lt; NSIZES);
501  	return (index2size_lookup(index));
502  }
503  JEMALLOC_ALWAYS_INLINE size_t
504  s2u_compute(size_t size)
505  {
506  #if (NTBINS &gt; 0)
507  	if (size &lt;= (ZU(1) &lt;&lt; LG_TINY_MAXCLASS)) {
508  		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
509  		size_t lg_ceil = lg_floor(pow2_ceil(size));
510  		return (lg_ceil &lt; lg_tmin ? (ZU(1) &lt;&lt; lg_tmin) :
511  		    (ZU(1) &lt;&lt; lg_ceil));
512  	}
513  #endif
514  	{
515  		size_t x = unlikely(ZI(size) &lt; 0) ? ((size&lt;&lt;1) ?
516  		    (ZU(1)&lt;&lt;(LG_SIZEOF_PTR+3)) : ((ZU(1)&lt;&lt;(LG_SIZEOF_PTR+3))-1))
517  		    : lg_floor((size&lt;&lt;1)-1);
518  		size_t lg_delta = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
519  		    ?  LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
<span onclick='openModal()' class='match'>520  		size_t delta = ZU(1) &lt;&lt; lg_delta;
521  		size_t delta_mask = delta - 1;
522  		size_t usize = (size + delta_mask) &amp; ~delta_mask;
523  		return (usize);
</span>524  	}
525  }
526  JEMALLOC_ALWAYS_INLINE size_t
527  s2u_lookup(size_t size)
528  {
529  	size_t ret = index2size_lookup(size2index_lookup(size));
530  	assert(ret == s2u_compute(size));
531  	return (ret);
532  }
533  JEMALLOC_ALWAYS_INLINE size_t
534  s2u(size_t size)
535  {
536  	assert(size &gt; 0);
537  	if (likely(size &lt;= LOOKUP_MAXCLASS))
538  		return (s2u_lookup(size));
539  	return (s2u_compute(size));
540  }
541  JEMALLOC_ALWAYS_INLINE size_t
542  sa2u(size_t size, size_t alignment)
543  {
544  	size_t usize;
545  	assert(alignment != 0 &amp;&amp; ((alignment - 1) &amp; alignment) == 0);
546  	if (size &lt;= SMALL_MAXCLASS &amp;&amp; alignment &lt; PAGE) {
547  		usize = s2u(ALIGNMENT_CEILING(size, alignment));
548  		if (usize &lt; LARGE_MINCLASS)
549  			return (usize);
550  	}
551  	if (likely(size &lt;= large_maxclass) &amp;&amp; likely(alignment &lt; chunksize)) {
552  		alignment = PAGE_CEILING(alignment);
553  		usize = (size &lt;= LARGE_MINCLASS) ? LARGE_MINCLASS : s2u(size);
554  		if (usize + large_pad + alignment - PAGE &lt;= arena_maxrun)
555  			return (usize);
556  	}
557  	alignment = CHUNK_CEILING(alignment);
558  	if (alignment == 0) {
559  		return (0);
560  	}
561  	if (size &lt;= chunksize)
562  		usize = chunksize;
563  	else {
564  		usize = s2u(size);
565  		if (usize &lt; size) {
566  			return (0);
567  		}
568  	}
569  	if (usize + alignment - PAGE &lt; usize) {
570  		return (0);
571  	}
572  	return (usize);
573  }
574  JEMALLOC_INLINE arena_t *
575  arena_choose(tsd_t *tsd, arena_t *arena)
576  {
577  	arena_t *ret;
578  	if (arena != NULL)
579  		return (arena);
580  	if (unlikely((ret = tsd_arena_get(tsd)) == NULL))
581  		ret = arena_choose_hard(tsd);
582  	return (ret);
583  }
584  JEMALLOC_INLINE arena_t *
585  arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
586      bool refresh_if_missing)
587  {
588  	arena_t *arena;
589  	arena_t **arenas_cache = tsd_arenas_cache_get(tsd);
590  	assert(!init_if_missing || refresh_if_missing);
591  	if (unlikely(arenas_cache == NULL)) {
592  		return (arena_get_hard(tsd, ind, init_if_missing));
593  	}
594  	if (unlikely(ind &gt;= tsd_narenas_cache_get(tsd))) {
595  		return (refresh_if_missing ? arena_get_hard(tsd, ind,
596  		    init_if_missing) : NULL);
597  	}
598  	arena = arenas_cache[ind];
599  	if (likely(arena != NULL) || !refresh_if_missing)
600  		return (arena);
601  	return (arena_get_hard(tsd, ind, init_if_missing));
602  }
603  #endif
604  #include &quot;jemalloc/internal/bitmap.h&quot;
605  #define	JEMALLOC_ARENA_INLINE_A
606  #include &quot;jemalloc/internal/arena.h&quot;
607  #undef JEMALLOC_ARENA_INLINE_A
608  #include &quot;jemalloc/internal/tcache.h&quot;
609  #define	JEMALLOC_ARENA_INLINE_B
610  #include &quot;jemalloc/internal/arena.h&quot;
611  #undef JEMALLOC_ARENA_INLINE_B
612  #include &quot;jemalloc/internal/hash.h&quot;
613  #include &quot;jemalloc/internal/quarantine.h&quot;
614  #ifndef JEMALLOC_ENABLE_INLINE
615  arena_t	*iaalloc(const void *ptr);
616  size_t	isalloc(const void *ptr, bool demote);
617  void	*iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache,
618      bool is_metadata, arena_t *arena);
619  void	*imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
620  void	*imalloc(tsd_t *tsd, size_t size);
621  void	*icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
622  void	*icalloc(tsd_t *tsd, size_t size);
623  void	*ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
624      tcache_t *tcache, bool is_metadata, arena_t *arena);
625  void	*ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
626      tcache_t *tcache, arena_t *arena);
627  void	*ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero);
628  size_t	ivsalloc(const void *ptr, bool demote);
629  size_t	u2rz(size_t usize);
630  size_t	p2rz(const void *ptr);
631  void	idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata);
632  void	idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache);
633  void	idalloc(tsd_t *tsd, void *ptr);
634  void	iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache);
635  void	isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
636  void	isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
637  void	*iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
638      size_t extra, size_t alignment, bool zero, tcache_t *tcache,
639      arena_t *arena);
640  void	*iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
641      size_t alignment, bool zero, tcache_t *tcache, arena_t *arena);
642  void	*iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
643      size_t alignment, bool zero);
644  bool	ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra,
645      size_t alignment, bool zero);
646  #endif
647  #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
648  JEMALLOC_ALWAYS_INLINE arena_t *
649  iaalloc(const void *ptr)
650  {
651  	assert(ptr != NULL);
652  	return (arena_aalloc(ptr));
653  }
654  JEMALLOC_ALWAYS_INLINE size_t
655  isalloc(const void *ptr, bool demote)
656  {
657  	assert(ptr != NULL);
658  	assert(config_prof || !demote);
659  	return (arena_salloc(ptr, demote));
660  }
661  JEMALLOC_ALWAYS_INLINE void *
662  iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache, bool is_metadata,
663      arena_t *arena)
664  {
665  	void *ret;
666  	assert(size != 0);
667  	ret = arena_malloc(tsd, arena, size, zero, tcache);
668  	if (config_stats &amp;&amp; is_metadata &amp;&amp; likely(ret != NULL)) {
669  		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
670  		    config_prof));
671  	}
672  	return (ret);
673  }
674  JEMALLOC_ALWAYS_INLINE void *
675  imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
676  {
677  	return (iallocztm(tsd, size, false, tcache, false, arena));
678  }
679  JEMALLOC_ALWAYS_INLINE void *
680  imalloc(tsd_t *tsd, size_t size)
681  {
682  	return (iallocztm(tsd, size, false, tcache_get(tsd, true), false, NULL));
683  }
684  JEMALLOC_ALWAYS_INLINE void *
685  icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
686  {
687  	return (iallocztm(tsd, size, true, tcache, false, arena));
688  }
689  JEMALLOC_ALWAYS_INLINE void *
690  icalloc(tsd_t *tsd, size_t size)
691  {
692  	return (iallocztm(tsd, size, true, tcache_get(tsd, true), false, NULL));
693  }
694  JEMALLOC_ALWAYS_INLINE void *
695  ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
696      tcache_t *tcache, bool is_metadata, arena_t *arena)
697  {
698  	void *ret;
699  	assert(usize != 0);
700  	assert(usize == sa2u(usize, alignment));
701  	ret = arena_palloc(tsd, arena, usize, alignment, zero, tcache);
702  	assert(ALIGNMENT_ADDR2BASE(ret, alignment) == ret);
703  	if (config_stats &amp;&amp; is_metadata &amp;&amp; likely(ret != NULL)) {
704  		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
705  		    config_prof));
706  	}
707  	return (ret);
708  }
709  JEMALLOC_ALWAYS_INLINE void *
710  ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
711      tcache_t *tcache, arena_t *arena)
712  {
713  	return (ipallocztm(tsd, usize, alignment, zero, tcache, false, arena));
714  }
715  JEMALLOC_ALWAYS_INLINE void *
716  ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero)
717  {
718  	return (ipallocztm(tsd, usize, alignment, zero, tcache_get(tsd,
719  	    NULL), false, NULL));
720  }
721  JEMALLOC_ALWAYS_INLINE size_t
722  ivsalloc(const void *ptr, bool demote)
723  {
724  	extent_node_t *node;
725  	node = chunk_lookup(ptr, false);
726  	if (node == NULL)
727  		return (0);
728  	assert(extent_node_addr_get(node) == ptr ||
729  	    extent_node_achunk_get(node));
730  	return (isalloc(ptr, demote));
731  }
732  JEMALLOC_INLINE size_t
733  u2rz(size_t usize)
734  {
735  	size_t ret;
736  	if (usize &lt;= SMALL_MAXCLASS) {
737  		szind_t binind = size2index(usize);
738  		ret = arena_bin_info[binind].redzone_size;
739  	} else
740  		ret = 0;
741  	return (ret);
742  }
743  JEMALLOC_INLINE size_t
744  p2rz(const void *ptr)
745  {
746  	size_t usize = isalloc(ptr, false);
747  	return (u2rz(usize));
748  }
749  JEMALLOC_ALWAYS_INLINE void
750  idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata)
751  {
752  	assert(ptr != NULL);
753  	if (config_stats &amp;&amp; is_metadata) {
754  		arena_metadata_allocated_sub(iaalloc(ptr), isalloc(ptr,
755  		    config_prof));
756  	}
757  	arena_dalloc(tsd, ptr, tcache);
758  }
759  JEMALLOC_ALWAYS_INLINE void
760  idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache)
761  {
762  	idalloctm(tsd, ptr, tcache, false);
763  }
764  JEMALLOC_ALWAYS_INLINE void
765  idalloc(tsd_t *tsd, void *ptr)
766  {
767  	idalloctm(tsd, ptr, tcache_get(tsd, false), false);
768  }
769  JEMALLOC_ALWAYS_INLINE void
770  iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache)
771  {
772  	if (config_fill &amp;&amp; unlikely(opt_quarantine))
773  		quarantine(tsd, ptr);
774  	else
775  		idalloctm(tsd, ptr, tcache, false);
776  }
777  JEMALLOC_ALWAYS_INLINE void
778  isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
779  {
780  	arena_sdalloc(tsd, ptr, size, tcache);
781  }
782  JEMALLOC_ALWAYS_INLINE void
783  isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
784  {
785  	if (config_fill &amp;&amp; unlikely(opt_quarantine))
786  		quarantine(tsd, ptr);
787  	else
788  		isdalloct(tsd, ptr, size, tcache);
789  }
790  JEMALLOC_ALWAYS_INLINE void *
791  iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
792      size_t extra, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena)
793  {
794  	void *p;
795  	size_t usize, copysize;
796  	usize = sa2u(size + extra, alignment);
797  	if (usize == 0)
798  		return (NULL);
799  	p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
800  	if (p == NULL) {
801  		if (extra == 0)
802  			return (NULL);
803  		usize = sa2u(size, alignment);
804  		if (usize == 0)
805  			return (NULL);
806  		p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
807  		if (p == NULL)
808  			return (NULL);
809  	}
810  	copysize = (size &lt; oldsize) ? size : oldsize;
811  	memcpy(p, ptr, copysize);
812  	isqalloc(tsd, ptr, oldsize, tcache);
813  	return (p);
814  }
815  JEMALLOC_ALWAYS_INLINE void *
816  iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
817      bool zero, tcache_t *tcache, arena_t *arena)
818  {
819  	assert(ptr != NULL);
820  	assert(size != 0);
821  	if (alignment != 0 &amp;&amp; ((uintptr_t)ptr &amp; ((uintptr_t)alignment-1))
822  	    != 0) {
823  		return (iralloct_realign(tsd, ptr, oldsize, size, 0, alignment,
824  		    zero, tcache, arena));
825  	}
826  	return (arena_ralloc(tsd, arena, ptr, oldsize, size, alignment, zero,
827  	    tcache));
828  }
829  JEMALLOC_ALWAYS_INLINE void *
830  iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
831      bool zero)
832  {
833  	return (iralloct(tsd, ptr, oldsize, size, alignment, zero,
834  	    tcache_get(tsd, true), NULL));
835  }
836  JEMALLOC_ALWAYS_INLINE bool
837  ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra, size_t alignment,
838      bool zero)
839  {
840  	assert(ptr != NULL);
841  	assert(size != 0);
842  	if (alignment != 0 &amp;&amp; ((uintptr_t)ptr &amp; ((uintptr_t)alignment-1))
843  	    != 0) {
844  		return (true);
845  	}
846  	return (arena_ralloc_no_move(ptr, oldsize, size, extra, zero));
847  }
848  #endif
849  #include &quot;jemalloc/internal/prof.h&quot;
850  #undef JEMALLOC_H_INLINES
851  #endif &amp;bsol;* JEMALLOC_INTERNAL_H */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sz.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_SIZE_H
2  #define JEMALLOC_INTERNAL_SIZE_H
3  #include &quot;jemalloc/internal/bit_util.h&quot;
4  #include &quot;jemalloc/internal/pages.h&quot;
5  #include &quot;jemalloc/internal/sc.h&quot;
6  #include &quot;jemalloc/internal/util.h&quot;
7  extern size_t sz_pind2sz_tab[SC_NPSIZES + 1];
8  extern size_t sz_index2size_tab[SC_NSIZES];
9  extern uint8_t sz_size2index_tab[];
10  static const size_t sz_large_pad =
11  #ifdef JEMALLOC_CACHE_OBLIVIOUS
12      PAGE
13  #else
14      0
15  #endif
16      ;
17  extern void sz_boot(const sc_data_t *sc_data);
18  JEMALLOC_ALWAYS_INLINE pszind_t
19  sz_psz2ind(size_t psz) {
20  	if (unlikely(psz &gt; SC_LARGE_MAXCLASS)) {
21  		return SC_NPSIZES;
22  	}
23  	pszind_t x = lg_floor((psz&lt;&lt;1)-1);
24  	pszind_t shift = (x &lt; SC_LG_NGROUP + LG_PAGE) ?
25  	    0 : x - (SC_LG_NGROUP + LG_PAGE);
26  	pszind_t grp = shift &lt;&lt; SC_LG_NGROUP;
27  	pszind_t lg_delta = (x &lt; SC_LG_NGROUP + LG_PAGE + 1) ?
28  	    LG_PAGE : x - SC_LG_NGROUP - 1;
29  	size_t delta_inverse_mask = ZU(-1) &lt;&lt; lg_delta;
30  	pszind_t mod = ((((psz-1) &amp; delta_inverse_mask) &gt;&gt; lg_delta)) &amp;
31  	    ((ZU(1) &lt;&lt; SC_LG_NGROUP) - 1);
32  	pszind_t ind = grp + mod;
33  	return ind;
34  }
35  static inline size_t
36  sz_pind2sz_compute(pszind_t pind) {
37  	if (unlikely(pind == SC_NPSIZES)) {
38  		return SC_LARGE_MAXCLASS + PAGE;
39  	}
40  	size_t grp = pind &gt;&gt; SC_LG_NGROUP;
41  	size_t mod = pind &amp; ((ZU(1) &lt;&lt; SC_LG_NGROUP) - 1);
42  	size_t grp_size_mask = ~((!!grp)-1);
43  	size_t grp_size = ((ZU(1) &lt;&lt; (LG_PAGE + (SC_LG_NGROUP-1))) &lt;&lt; grp)
44  	    &amp; grp_size_mask;
45  	size_t shift = (grp == 0) ? 1 : grp;
46  	size_t lg_delta = shift + (LG_PAGE-1);
47  	size_t mod_size = (mod+1) &lt;&lt; lg_delta;
48  	size_t sz = grp_size + mod_size;
49  	return sz;
50  }
51  static inline size_t
52  sz_pind2sz_lookup(pszind_t pind) {
53  	size_t ret = (size_t)sz_pind2sz_tab[pind];
54  	assert(ret == sz_pind2sz_compute(pind));
55  	return ret;
56  }
57  static inline size_t
58  sz_pind2sz(pszind_t pind) {
59  	assert(pind &lt; SC_NPSIZES + 1);
60  	return sz_pind2sz_lookup(pind);
61  }
62  static inline size_t
63  sz_psz2u(size_t psz) {
64  	if (unlikely(psz &gt; SC_LARGE_MAXCLASS)) {
65  		return SC_LARGE_MAXCLASS + PAGE;
66  	}
67  	size_t x = lg_floor((psz&lt;&lt;1)-1);
68  	size_t lg_delta = (x &lt; SC_LG_NGROUP + LG_PAGE + 1) ?
69  	    LG_PAGE : x - SC_LG_NGROUP - 1;
70  	size_t delta = ZU(1) &lt;&lt; lg_delta;
71  	size_t delta_mask = delta - 1;
72  	size_t usize = (psz + delta_mask) &amp; ~delta_mask;
73  	return usize;
74  }
75  static inline szind_t
76  sz_size2index_compute(size_t size) {
77  	if (unlikely(size &gt; SC_LARGE_MAXCLASS)) {
78  		return SC_NSIZES;
79  	}
80  	if (size == 0) {
81  		return 0;
82  	}
83  #if (SC_NTINY != 0)
84  	if (size &lt;= (ZU(1) &lt;&lt; SC_LG_TINY_MAXCLASS)) {
85  		szind_t lg_tmin = SC_LG_TINY_MAXCLASS - SC_NTINY + 1;
86  		szind_t lg_ceil = lg_floor(pow2_ceil_zu(size));
87  		return (lg_ceil &lt; lg_tmin ? 0 : lg_ceil - lg_tmin);
88  	}
89  #endif
90  	{
91  		szind_t x = lg_floor((size&lt;&lt;1)-1);
92  		szind_t shift = (x &lt; SC_LG_NGROUP + LG_QUANTUM) ? 0 :
93  		    x - (SC_LG_NGROUP + LG_QUANTUM);
94  		szind_t grp = shift &lt;&lt; SC_LG_NGROUP;
95  		szind_t lg_delta = (x &lt; SC_LG_NGROUP + LG_QUANTUM + 1)
96  		    ? LG_QUANTUM : x - SC_LG_NGROUP - 1;
97  		size_t delta_inverse_mask = ZU(-1) &lt;&lt; lg_delta;
98  		szind_t mod = ((((size-1) &amp; delta_inverse_mask) &gt;&gt; lg_delta)) &amp;
99  		    ((ZU(1) &lt;&lt; SC_LG_NGROUP) - 1);
100  		szind_t index = SC_NTINY + grp + mod;
101  		return index;
102  	}
103  }
104  JEMALLOC_ALWAYS_INLINE szind_t
105  sz_size2index_lookup(size_t size) {
106  	assert(size &lt;= SC_LOOKUP_MAXCLASS);
107  	szind_t ret = (sz_size2index_tab[(size + (ZU(1) &lt;&lt; SC_LG_TINY_MIN) - 1)
108  					 &gt;&gt; SC_LG_TINY_MIN]);
109  	assert(ret == sz_size2index_compute(size));
110  	return ret;
111  }
112  JEMALLOC_ALWAYS_INLINE szind_t
113  sz_size2index(size_t size) {
114  	if (likely(size &lt;= SC_LOOKUP_MAXCLASS)) {
115  		return sz_size2index_lookup(size);
116  	}
117  	return sz_size2index_compute(size);
118  }
119  static inline size_t
120  sz_index2size_compute(szind_t index) {
121  #if (SC_NTINY &gt; 0)
122  	if (index &lt; SC_NTINY) {
123  		return (ZU(1) &lt;&lt; (SC_LG_TINY_MAXCLASS - SC_NTINY + 1 + index));
124  	}
125  #endif
126  	{
127  		size_t reduced_index = index - SC_NTINY;
128  		size_t grp = reduced_index &gt;&gt; SC_LG_NGROUP;
129  		size_t mod = reduced_index &amp; ((ZU(1) &lt;&lt; SC_LG_NGROUP) -
130  		    1);
131  		size_t grp_size_mask = ~((!!grp)-1);
132  		size_t grp_size = ((ZU(1) &lt;&lt; (LG_QUANTUM +
133  		    (SC_LG_NGROUP-1))) &lt;&lt; grp) &amp; grp_size_mask;
134  		size_t shift = (grp == 0) ? 1 : grp;
135  		size_t lg_delta = shift + (LG_QUANTUM-1);
136  		size_t mod_size = (mod+1) &lt;&lt; lg_delta;
137  		size_t usize = grp_size + mod_size;
138  		return usize;
139  	}
140  }
141  JEMALLOC_ALWAYS_INLINE size_t
142  sz_index2size_lookup(szind_t index) {
143  	size_t ret = (size_t)sz_index2size_tab[index];
144  	assert(ret == sz_index2size_compute(index));
145  	return ret;
146  }
147  JEMALLOC_ALWAYS_INLINE size_t
148  sz_index2size(szind_t index) {
149  	assert(index &lt; SC_NSIZES);
150  	return sz_index2size_lookup(index);
151  }
152  JEMALLOC_ALWAYS_INLINE size_t
153  sz_s2u_compute(size_t size) {
154  	if (unlikely(size &gt; SC_LARGE_MAXCLASS)) {
155  		return 0;
156  	}
157  	if (size == 0) {
158  		size++;
159  	}
160  #if (SC_NTINY &gt; 0)
161  	if (size &lt;= (ZU(1) &lt;&lt; SC_LG_TINY_MAXCLASS)) {
162  		size_t lg_tmin = SC_LG_TINY_MAXCLASS - SC_NTINY + 1;
163  		size_t lg_ceil = lg_floor(pow2_ceil_zu(size));
164  		return (lg_ceil &lt; lg_tmin ? (ZU(1) &lt;&lt; lg_tmin) :
165  		    (ZU(1) &lt;&lt; lg_ceil));
166  	}
167  #endif
168  	{
169  		size_t x = lg_floor((size&lt;&lt;1)-1);
170  		size_t lg_delta = (x &lt; SC_LG_NGROUP + LG_QUANTUM + 1)
171  		    ?  LG_QUANTUM : x - SC_LG_NGROUP - 1;
<span onclick='openModal()' class='match'>172  		size_t delta = ZU(1) &lt;&lt; lg_delta;
173  		size_t delta_mask = delta - 1;
174  		size_t usize = (size + delta_mask) &amp; ~delta_mask;
175  		return usize;
</span>176  	}
177  }
178  JEMALLOC_ALWAYS_INLINE size_t
179  sz_s2u_lookup(size_t size) {
180  	size_t ret = sz_index2size_lookup(sz_size2index_lookup(size));
181  	assert(ret == sz_s2u_compute(size));
182  	return ret;
183  }
184  JEMALLOC_ALWAYS_INLINE size_t
185  sz_s2u(size_t size) {
186  	if (likely(size &lt;= SC_LOOKUP_MAXCLASS)) {
187  		return sz_s2u_lookup(size);
188  	}
189  	return sz_s2u_compute(size);
190  }
191  JEMALLOC_ALWAYS_INLINE size_t
192  sz_sa2u(size_t size, size_t alignment) {
193  	size_t usize;
194  	assert(alignment != 0 &amp;&amp; ((alignment - 1) &amp; alignment) == 0);
195  	if (size &lt;= SC_SMALL_MAXCLASS &amp;&amp; alignment &lt; PAGE) {
196  		usize = sz_s2u(ALIGNMENT_CEILING(size, alignment));
197  		if (usize &lt; SC_LARGE_MINCLASS) {
198  			return usize;
199  		}
200  	}
201  	if (unlikely(alignment &gt; SC_LARGE_MAXCLASS)) {
202  		return 0;
203  	}
204  	if (size &lt;= SC_LARGE_MINCLASS) {
205  		usize = SC_LARGE_MINCLASS;
206  	} else {
207  		usize = sz_s2u(size);
208  		if (usize &lt; size) {
209  			return 0;
210  		}
211  	}
212  	if (usize + sz_large_pad + PAGE_CEILING(alignment) - PAGE &lt; usize) {
213  		return 0;
214  	}
215  	return usize;
216  }
217  #endif &amp;bsol;* JEMALLOC_INTERNAL_SIZE_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc_internal.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sz.h</div>
                </div>
                <div class="column column_space"><pre><code>520  		size_t delta = ZU(1) &lt;&lt; lg_delta;
521  		size_t delta_mask = delta - 1;
522  		size_t usize = (size + delta_mask) &amp; ~delta_mask;
523  		return (usize);
</pre></code></div>
                <div class="column column_space"><pre><code>172  		size_t delta = ZU(1) &lt;&lt; lg_delta;
173  		size_t delta_mask = delta - 1;
174  		size_t usize = (size + delta_mask) &amp; ~delta_mask;
175  		return usize;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    