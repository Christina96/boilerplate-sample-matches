<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmnormalize.c &amp; imtcp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmnormalize.c &amp; imtcp.c
      </h3>
<h1 align="center">
        10.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmnormalize.c (20.580475%)<th>imtcp.c (6.8481126%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(287-307)<td><a href="#" name="0">(715-735)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(95-105)<td><a href="#" name="1">(216-226)</a><td align="center"><font color="#c10000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(372-377)<td><a href="#" name="2">(587-592)</a><td align="center"><font color="#ad0000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(340-353)<td><a href="#" name="3">(569-581)</a><td align="center"><font color="#ad0000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmnormalize.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;libestr.h&gt;
12 #include &lt;json.h&gt;
13 #include &lt;liblognorm.h&gt;
14 #include "conf.h"
15 #include "syslogd-types.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "cfsysline.h"
20 #include "dirty.h"
21 #include "unicode-helper.h"
22 MODULE_TYPE_OUTPUT
23 MODULE_TYPE_NOKEEP
24 MODULE_CNFNAME("mmnormalize")
25 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
26 DEF_OMOD_STATIC_DATA
27 static struct cnfparamdescr modpdescr[] = {
28 	{ "allowregex", eCmdHdlrBinary, 0 }
29 };
30 static struct cnfparamblk modpblk = {
31 	CNFPARAMBLK_VERSION,
32 	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
33 	modpdescr
34 };
35 typedef struct _instanceData {
36 } instanceData;
37 typedef struct wrkrInstanceData {
38 	instanceData *pData;
39 } wrkrInstanceData_t;
40 typedef struct configSettings_s {
41 	uchar *rule;
42 } configSettings_t;
43 static configSettings_t cs;
44 <a name="1"></a>static struct cnfparamdescr actpdescr[] = {
45 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "rulebase", eCmdHdlrGetWord, 0 },
46 	{ "rule", eCmdHdlrArray, 0 },
47 	{ "path", eCmdHdlrGetWord, 0 },
48 	{ "userawmsg", eCmdHdlrBinary, 0 },
49 	{ "variable", eCmdHdlrGetWord, 0 }
50 };
51 static struct cnfparamblk actpblk =
52 	{ CNFPARAMBLK_VERSION,
53 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
54 	  actpdescr
55 	};</b></font>
56 struct modConfData_s {
57 	rsconf_t *pConf;		int allow_regex;
58 };
59 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
60 static void
61 errCallBack(void __attribute__((unused)) *cookie, const char *msg,
62 	    size_t __attribute__((unused)) lenMsg)
63 {
64 	LogError(0, RS_RET_ERR_LIBLOGNORM, "liblognorm error: %s", msg);
65 }
66 static rsRetVal
67 buildInstance(instanceData *pData)
68 {
69 	DEFiRet;
70 	if((pData-&gt;ctxln = ln_initCtx()) == NULL) {
71 		LogError(0, RS_RET_ERR_LIBLOGNORM_INIT, "error: could not initialize "
72 				"liblognorm ctx, cannot activate action");
73 		ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_INIT);
74 	}
75 	ln_setCtxOpts(pData-&gt;ctxln, loadModConf-&gt;allow_regex);
76 	ln_setErrMsgCB(pData-&gt;ctxln, errCallBack, NULL);
77 	if(pData-&gt;rule !=NULL &amp;&amp; pData-&gt;rulebase == NULL) {
78 		if(ln_loadSamplesFromString(pData-&gt;ctxln, (char*) pData-&gt;rule) !=0) {
79 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rule '%s' "
80 					"could not be loaded cannot activate action", pData-&gt;rule);
81 			ln_exitCtx(pData-&gt;ctxln);
82 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
83 		}
84 		free(pData-&gt;rule);
85 		pData-&gt;rule = NULL;
86 	} else if(pData-&gt;rule ==NULL &amp;&amp; pData-&gt;rulebase != NULL) {
87 		if(ln_loadSamples(pData-&gt;ctxln, (char*) pData-&gt;rulebase) != 0) {
88 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
89 					"could not be loaded cannot activate action", pData-&gt;rulebase);
90 			ln_exitCtx(pData-&gt;ctxln);
91 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
92 		}
93 	}
94 finalize_it:
95 	RETiRet;
96 }
97 BEGINinitConfVars		CODESTARTinitConfVars
98 	resetConfigVariables(NULL, NULL);
99 ENDinitConfVars
100 BEGINcreateInstance
101 CODESTARTcreateInstance
102 ENDcreateInstance
103 BEGINcreateWrkrInstance
104 CODESTARTcreateWrkrInstance
105 ENDcreateWrkrInstance
106 BEGINbeginCnfLoad
107 CODESTARTbeginCnfLoad
108 	loadModConf = pModConf;
109 	pModConf-&gt;pConf = pConf;
110 ENDbeginCnfLoad
111 BEGINendCnfLoad
112 CODESTARTendCnfLoad
113 	loadModConf = NULL; 	free(cs.rulebase);
114 	free(cs.rule);
115 	cs.rulebase = NULL;
116 	cs.rule = NULL;
117 ENDendCnfLoad
118 BEGINcheckCnf
119 CODESTARTcheckCnf
120 ENDcheckCnf
121 BEGINactivateCnf
122 CODESTARTactivateCnf
123 	runModConf = pModConf;
124 ENDactivateCnf
125 BEGINfreeCnf
126 CODESTARTfreeCnf
127 ENDfreeCnf
128 BEGINisCompatibleWithFeature
129 CODESTARTisCompatibleWithFeature
130 ENDisCompatibleWithFeature
131 BEGINfreeInstance
132 CODESTARTfreeInstance
133 	free(pData-&gt;rulebase);
134 	free(pData-&gt;rule);
135 	ln_exitCtx(pData-&gt;ctxln);
136 	free(pData-&gt;pszPath);
137 	msgPropDescrDestruct(pData-&gt;varDescr);
138 	free(pData-&gt;varDescr);
139 ENDfreeInstance
140 BEGINfreeWrkrInstance
141 CODESTARTfreeWrkrInstance
142 ENDfreeWrkrInstance
143 BEGINdbgPrintInstInfo
144 CODESTARTdbgPrintInstInfo
145 	dbgprintf("mmnormalize\n");
146 	dbgprintf("\tvariable='%s'\n", pData-&gt;varDescr-&gt;name);
147 	dbgprintf("\trulebase='%s'\n", pData-&gt;rulebase);
148 	dbgprintf("\trule='%s'\n", pData-&gt;rule);
149 	dbgprintf("\tpath='%s'\n", pData-&gt;pszPath);
150 	dbgprintf("\tbUseRawMsg='%d'\n", pData-&gt;bUseRawMsg);
151 ENDdbgPrintInstInfo
152 BEGINtryResume
153 CODESTARTtryResume
154 ENDtryResume
155 BEGINdoAction_NoStrings
156 	smsg_t **ppMsg = (smsg_t **) pMsgData;
157 	smsg_t *pMsg = ppMsg[0];
158 	uchar *buf;
159 	rs_size_t len;
160 	int r;
161 	struct json_object *json = NULL;
162 	unsigned short freeBuf = 0;
163 CODESTARTdoAction
164 	if(pWrkrData-&gt;pData-&gt;bUseRawMsg) {
165 		getRawMsg(pMsg, &amp;buf, &amp;len);
166 	} else if (pWrkrData-&gt;pData-&gt;varDescr) {
167 		buf = MsgGetProp(pMsg, NULL, pWrkrData-&gt;pData-&gt;varDescr, &amp;len, &amp;freeBuf, NULL);
168 	} else {
169 		buf = getMSG(pMsg);
170 		len = getMSGLen(pMsg);
171 	}
172 	r = ln_normalize(pWrkrData-&gt;pData-&gt;ctxln, (char*)buf, len, &amp;json);
173 	if (freeBuf) {
174 		free(buf);
175 		buf = NULL;
176 	}
177 	if(r != 0) {
178 		DBGPRINTF("error %d during ln_normalize\n", r);
179 		MsgSetParseSuccess(pMsg, 0);
180 	} else {
181 		MsgSetParseSuccess(pMsg, 1);
182 	}
183 	msgAddJSON(pMsg, (uchar*)pWrkrData-&gt;pData-&gt;pszPath + 1, json, 0, 0);
184 ENDdoAction
185 static void
186 setInstParamDefaults(instanceData *pData)
187 {
188 	pData-&gt;rulebase = NULL;
189 	pData-&gt;rule = NULL;
190 	pData-&gt;bUseRawMsg = 0;
191 	pData-&gt;pszPath = strdup("$!");
192 	pData-&gt;varDescr = NULL;
193 <a name="0"></a>}
194 BEGINsetModCnf
195 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	struct cnfparamvals *pvals = NULL;
196 	int i;
197 CODESTARTsetModCnf
198 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
199 	if(pvals == NULL) {
200 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmnormalize: error processing module "
201 						"config parameters missing [module(...)]");
202 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
203 	}
204 	if(Debug) {
205 		dbgprintf("module (global) param blk for mmnormalize:\n");
206 		cnfparamsPrint(&amp;modpblk, pvals);
207 	}
208 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
209 		if(!pvals[i].bUsed)
210 			continue;
211 		if(!strcmp(modpblk.descr[i].name, "allowregex")) {
212 			loadModConf-&gt;allow_regex = (int) pvals[i].val.d.n;
213 		} else {</b></font>
214 			dbgprintf("mmnormalize: program error, non-handled "
215 					  "param '%s' in setModCnf\n", modpblk.descr[i].name);
216 		}
217 	}
218 finalize_it:
219 	if(pvals != NULL)
220 		cnfparamvalsDestruct(pvals, &amp;modpblk);
221 ENDsetModCnf
222 BEGINnewActInst
223 	struct cnfparamvals *pvals;
224 	int i;
225 	int bDestructPValsOnExit;
226 	char *cstr;
227 	char *varName = NULL;
228 	char *buffer;
229 	char *tStr;
230 	int size = 0;
231 CODESTARTnewActInst
232 	DBGPRINTF("newActInst (mmnormalize)\n");
233 	bDestructPValsOnExit = 0;
234 	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
235 	if(pvals == NULL) {
236 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmnormalize: error reading "
237 				"config parameters");
238 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
239 <a name="3"></a>	}
240 	bDestructPValsOnExit = 1;
241 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(Debug) {
242 		dbgprintf("action param blk in mmnormalize:\n");
243 		cnfparamsPrint(&amp;actpblk, pvals);
244 	}
245 	CHKiRet(createInstance(&amp;pData));
246 	setInstParamDefaults(pData);
247 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
248 		if(!pvals[i].bUsed)
249 			continue;
250 		if(!strcmp(actpblk.descr[i].name, "rulebase")) {
251 			pData-&gt;rulebase = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
252 		} else if(!strcmp(actpblk.descr[i].name, "rule")) {</b></font>
253 			for(int j=0; j &lt; pvals[i].val.d.ar-&gt;nmemb; ++j) {
254 				tStr = (char*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
255 				size += strlen(tStr);
256 				free(tStr);
257 			}
258 			buffer = malloc(size + pvals[i].val.d.ar-&gt;nmemb + 1);
259 			tStr = (char*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[0], NULL);
260 			strcpy(buffer, tStr);
261 			free(tStr);
262 			strcat(buffer, "\n");
263 			for(int j=1; j &lt; pvals[i].val.d.ar-&gt;nmemb; ++j) {
264 				tStr = (char*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
265 				strcat(buffer, tStr);
266 				free(tStr);
267 				strcat(buffer, "\n");
268 <a name="2"></a>			}
269 			strcat(buffer, "\0");
270 			pData-&gt;rule = (uchar*)buffer;
271 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "userawmsg")) {
272 			pData-&gt;bUseRawMsg = (int) pvals[i].val.d.n;
273 		} else if(!strcmp(actpblk.descr[i].name, "variable")) {
274 			varName = es_str2cstr(pvals[i].val.d.estr, NULL);
275 		} else if(!strcmp(actpblk.descr[i].name, "path")) {
276 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
277 			if (strlen(cstr) &lt; 2) {
278 				LogError(0, RS_RET_VALUE_NOT_SUPPORTED,
279 						"mmnormalize: valid path name should be at least "
280 						"2 symbols long, got %s",	cstr);
281 				free(cstr);
282 			} else if (cstr[0] != '$') {
283 				LogError(0, RS_RET_VALUE_NOT_SUPPORTED,
284 						"mmnormalize: valid path name should start with $,"
285 						"got %s", cstr);
286 				free(cstr);
287 			} else {
288 				free(pData-&gt;pszPath);
289 				pData-&gt;pszPath = cstr;
290 			}
291 			continue;
292 		} else {
293 			DBGPRINTF("mmnormalize: program error, non-handled "
294 			  "param '%s'\n", actpblk.descr[i].name);
295 		}
296 	}
297 	if (varName) {
298 		if(pData-&gt;bUseRawMsg) {
299 			LogError(0, RS_RET_CONFIG_ERROR,
300 			                "mmnormalize: 'variable' param can't be used with 'useRawMsg'. "
301 			                "Ignoring 'variable', will use raw message.");
302 		} else {
303 			CHKmalloc(pData-&gt;varDescr = malloc(sizeof(msgPropDescr_t)));
304 			CHKiRet(msgPropDescrFill(pData-&gt;varDescr, (uchar*) varName, strlen(varName)));
305 		}
306 		free(varName);
307 		varName = NULL;
308 	}
309 	if(!pData-&gt;rulebase) {
310 		if(!pData-&gt;rule) {
311 			LogError(0, RS_RET_CONFIG_ERROR, "mmnormalize: rulebase needed. "
312 					"Use option rulebase or rule.");
313 		}
314 	}
315 	if(pData-&gt;rulebase) {
316 		if(pData-&gt;rule) {
317 			LogError(0, RS_RET_CONFIG_ERROR,
318 					"mmnormalize: only one rulebase possible, rulebase "
319 					"can't be used with rule");
320 		}
321 	}
322 	CODE_STD_STRING_REQUESTnewActInst(1)
323 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
324 	iRet = buildInstance(pData);
325 CODE_STD_FINALIZERnewActInst
326 	if(bDestructPValsOnExit)
327 		cnfparamvalsDestruct(pvals, &amp;actpblk);
328 ENDnewActInst
329 BEGINparseSelectorAct
330 CODESTARTparseSelectorAct
331 CODE_STD_STRING_REQUESTparseSelectorAct(1)
332 	if(strncmp((char*) p, ":mmnormalize:", sizeof(":mmnormalize:") - 1)) {
333 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
334 	}
335 	if(cs.rulebase == NULL &amp;&amp; cs.rule == NULL) {
336 		LogError(0, RS_RET_NO_RULEBASE, "error: no normalization rulebase was specified, use "
337 				"$MMNormalizeSampleDB directive first!");
338 		ABORT_FINALIZE(RS_RET_NO_RULEBASE);
339 	}
340 	p += sizeof(":mmnormalize:") - 1; 	CHKiRet(createInstance(&amp;pData));
341 	pData-&gt;rulebase = cs.rulebase;
342 	pData-&gt;rule = cs.rule;
343 	pData-&gt;bUseRawMsg = cs.bUseRawMsg;
344 	pData-&gt;pszPath = strdup("$!"); 	cs.bUseRawMsg = 0;
345 	cs.rulebase = NULL; 	cs.rule = NULL;
346 	if(*(p-1) == ';')
347 		--p;
348 	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) "RSYSLOG_FileFormat"));
349 	CHKiRet(buildInstance(pData));
350 CODE_STD_FINALIZERparseSelectorAct
351 ENDparseSelectorAct
352 BEGINmodExit
353 CODESTARTmodExit
354 ENDmodExit
355 BEGINqueryEtryPt
356 CODESTARTqueryEtryPt
357 CODEqueryEtryPt_STD_OMOD_QUERIES
358 CODEqueryEtryPt_STD_OMOD8_QUERIES
359 CODEqueryEtryPt_STD_CONF2_QUERIES
360 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
361 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
362 ENDqueryEtryPt
363 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
364 {
365 	DEFiRet;
366 	cs.rulebase = NULL;
367 	cs.rule = NULL;
368 	cs.bUseRawMsg = 0;
369 	RETiRet;
370 }
371 static rsRetVal
372 setRuleBase(void __attribute__((unused)) *pVal, uchar *pszName)
373 {
374 	DEFiRet;
375 	cs.rulebase = pszName;
376 	pszName = NULL;
377 	RETiRet;
378 }
379 BEGINmodInit()
380 	rsRetVal localRet;
381 	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
382 	unsigned long opts;
383 	int bMsgPassingSupported;
384 CODESTARTmodInit
385 INITLegCnfVars
386 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
387 CODEmodInit_QueryRegCFSLineHdlr
388 	DBGPRINTF("mmnormalize: module compiled with rsyslog version %s.\n", VERSION);
389 	bMsgPassingSupported = 0;
390 	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts",
391 			&amp;pomsrGetSupportedTplOpts);
392 	if(localRet == RS_RET_OK) {
393 		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
394 		if(opts &amp; OMSR_TPL_AS_MSG)
395 			bMsgPassingSupported = 1;
396 	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
397 		ABORT_FINALIZE(localRet); 	}
398 	if(!bMsgPassingSupported) {
399 		DBGPRINTF("mmnormalize: msg-passing is not supported by rsyslog core, "
400 			  "can not continue.\n");
401 		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
402 	}
403 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmnormalizerulebase", 0, eCmdHdlrGetWord,
404 				    setRuleBase, NULL, STD_LOADABLE_MODULE_ID));
405 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmnormalizerule", 0, eCmdHdlrGetWord, NULL,
406 				NULL, STD_LOADABLE_MODULE_ID));
407 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmnormalizeuserawmsg", 0, eCmdHdlrBinary,
408 				NULL, &amp;cs.bUseRawMsg, STD_LOADABLE_MODULE_ID));
409 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
410 				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
411 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imtcp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;assert.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;errno.h&gt;
6 #include &lt;unistd.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;netinet/in.h&gt;
10 #include &lt;netdb.h&gt;
11 #include &lt;signal.h&gt;
12 #include &lt;sys/types.h&gt;
13 #include &lt;sys/socket.h&gt;
14 #if HAVE_FCNTL_H
15 #include &lt;fcntl.h&gt;
16 #endif
17 #include "rsyslog.h"
18 #include "dirty.h"
19 #include "cfsysline.h"
20 #include "module-template.h"
21 #include "unicode-helper.h"
22 #include "net.h"
23 #include "netstrm.h"
24 #include "errmsg.h"
25 #include "tcpsrv.h"
26 #include "ruleset.h"
27 #include "rainerscript.h"
28 #include "net.h"
29 #include "parserif.h"
30 MODULE_TYPE_INPUT
31 MODULE_TYPE_NOKEEP
32 MODULE_CNFNAME("imtcp")
33 DEF_IMOD_STATIC_DATA
34 DEFobjCurrIf(tcpsrv)
35 DEFobjCurrIf(tcps_sess)
36 DEFobjCurrIf(net)
37 DEFobjCurrIf(netstrm)
38 DEFobjCurrIf(ruleset)
39 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
40 typedef struct tcpsrv_etry_s {
41 	tcpsrv_t *tcpsrv;
42 	pthread_t tid;		struct tcpsrv_etry_s *next;
43 } tcpsrv_etry_t;
44 static tcpsrv_etry_t *tcpsrv_root = NULL;
45 static int n_tcpsrv = 0;
46 static permittedPeers_t *pPermPeersRoot = NULL;
47 #define FRAMING_UNSET -1
48 static struct configSettings_s {
49 	int iTCPSessMax;
50 	int iTCPLstnMax;
51 	int bSuppOctetFram;
52 	int iStrmDrvrMode;
53 	int bKeepAlive;
54 	int iKeepAliveIntvl;
55 	int iKeepAliveProbes;
56 	int iKeepAliveTime;
57 	int bEmitMsgOnClose;
58 	int iAddtlFrameDelim;
59 	int maxFrameSize;
60 	int bDisableLFDelim;
61 	int discardTruncatedMsg;
62 	int bUseFlowControl;
63 	int bPreserveCase;
64 	uchar *gnutlsPriorityString;
65 	uchar *pszStrmDrvrAuthMode;
66 	uchar *pszStrmDrvrPermitExpiredCerts;
67 	uchar *pszInputName;
68 	uchar *pszBindRuleset;
69 	uchar *lstnIP;				uchar *lstnPortFile;
70 } cs;
71 struct instanceConf_s {
72 	int iTCPSessMax;
73 	int iTCPLstnMax;
74 	uchar *pszBindRuleset;			ruleset_t *pBindRuleset;		uchar *pszInputName;			uchar *dfltTZ;
75 	sbool bSPFramingFix;
76 	unsigned int ratelimitInterval;
77 	unsigned int ratelimitBurst;
78 	int iAddtlFrameDelim; 	int maxFrameSize;
79 	int bUseFlowControl;
80 	int bDisableLFDelim;
81 	int discardTruncatedMsg;
82 	int bEmitMsgOnClose;
83 	int bPreserveCase;
84 	uchar *pszStrmDrvrName; 	int iStrmDrvrMode;
85 	uchar *pszStrmDrvrAuthMode;
86 	uchar *pszStrmDrvrPermitExpiredCerts;
87 	uchar *pszStrmDrvrCAFile;
88 	uchar *pszStrmDrvrKeyFile;
89 	uchar *pszStrmDrvrCertFile;
90 	permittedPeers_t *pPermPeersRoot;
91 	uchar *gnutlsPriorityString;
92 	int iStrmDrvrExtendedCertCheck;
93 	int iStrmDrvrSANPreference;
94 	int iStrmTlsVerifyDepth;
95 	int bKeepAlive;
96 	int iKeepAliveIntvl;
97 	int iKeepAliveProbes;
98 	int iKeepAliveTime;
99 	struct instanceConf_s *next;
100 };
101 struct modConfData_s {
102 	rsconf_t *pConf;			instanceConf_t *root, *tail;
103 	int iAddtlFrameDelim; 	int maxFrameSize;
104 	int bSuppOctetFram;
105 	sbool bDisableLFDelim; 	sbool discardTruncatedMsg;
106 	sbool bUseFlowControl; 	sbool bKeepAlive;
107 	int iKeepAliveIntvl;
108 	int iKeepAliveProbes;
109 	int iKeepAliveTime;
110 	sbool bEmitMsgOnClose; 	uchar *gnutlsPriorityString;
111 	uchar *pszStrmDrvrName; 	uchar *pszStrmDrvrAuthMode; 	uchar *pszStrmDrvrPermitExpiredCerts; 	uchar *pszStrmDrvrCAFile;
112 	uchar *pszStrmDrvrKeyFile;
113 	uchar *pszStrmDrvrCertFile;
114 	permittedPeers_t *pPermPeersRoot;
115 	sbool configSetViaV2Method;
116 	sbool bPreserveCase; };
117 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
118 static struct cnfparamdescr modpdescr[] = {
119 	{ "flowcontrol", eCmdHdlrBinary, 0 },
120 	{ "disablelfdelimiter", eCmdHdlrBinary, 0 },
121 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
122 	{ "octetcountedframing", eCmdHdlrBinary, 0 },
123 	{ "notifyonconnectionclose", eCmdHdlrBinary, 0 },
124 	{ "addtlframedelimiter", eCmdHdlrNonNegInt, 0 },
125 	{ "maxframesize", eCmdHdlrInt, 0 },
126 	{ "maxsessions", eCmdHdlrPositiveInt, 0 },
127 	{ "maxlistners", eCmdHdlrPositiveInt, 0 },
128 	{ "maxlisteners", eCmdHdlrPositiveInt, 0 },
129 	{ "streamdriver.mode", eCmdHdlrNonNegInt, 0 },
130 	{ "streamdriver.authmode", eCmdHdlrString, 0 },
131 	{ "streamdriver.permitexpiredcerts", eCmdHdlrString, 0 },
132 	{ "streamdriver.name", eCmdHdlrString, 0 },
133 	{ "streamdriver.CheckExtendedKeyPurpose", eCmdHdlrBinary, 0 },
134 	{ "streamdriver.PrioritizeSAN", eCmdHdlrBinary, 0 },
135 <a name="1"></a>	{ "streamdriver.TlsVerifyDepth", eCmdHdlrPositiveInt, 0 },
136 	{ "permittedpeer", eCmdHdlrArray, 0 },
137 	{ "keepalive", eCmdHdlrBinary, 0 },
138 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "keepalive.probes", eCmdHdlrNonNegInt, 0 },
139 	{ "keepalive.time", eCmdHdlrNonNegInt, 0 },
140 	{ "keepalive.interval", eCmdHdlrNonNegInt, 0 },
141 	{ "gnutlsprioritystring", eCmdHdlrString, 0 },
142 	{ "preservecase", eCmdHdlrBinary, 0 }
143 };
144 static struct cnfparamblk modpblk =
145 	{ CNFPARAMBLK_VERSION,
146 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
147 	  modpdescr
148 	};</b></font>
149 static struct cnfparamdescr inppdescr[] = {
150 	{ "port", eCmdHdlrString, CNFPARAM_REQUIRED }, 	{ "maxsessions", eCmdHdlrPositiveInt, 0 },
151 	{ "maxlisteners", eCmdHdlrPositiveInt, 0 },
152 	{ "flowcontrol", eCmdHdlrBinary, 0 },
153 	{ "disablelfdelimiter", eCmdHdlrBinary, 0 },
154 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
155 	{ "notifyonconnectionclose", eCmdHdlrBinary, 0 },
156 	{ "addtlframedelimiter", eCmdHdlrNonNegInt, 0 },
157 	{ "maxframesize", eCmdHdlrInt, 0 },
158 	{ "preservecase", eCmdHdlrBinary, 0 },
159 	{ "listenportfilename", eCmdHdlrString, 0 },
160 	{ "address", eCmdHdlrString, 0 },
161 	{ "name", eCmdHdlrString, 0 },
162 	{ "defaulttz", eCmdHdlrString, 0 },
163 	{ "ruleset", eCmdHdlrString, 0 },
164 	{ "streamdriver.mode", eCmdHdlrNonNegInt, 0 },
165 	{ "streamdriver.authmode", eCmdHdlrString, 0 },
166 	{ "streamdriver.permitexpiredcerts", eCmdHdlrString, 0 },
167 	{ "streamdriver.name", eCmdHdlrString, 0 },
168 	{ "streamdriver.CheckExtendedKeyPurpose", eCmdHdlrBinary, 0 },
169 	{ "streamdriver.PrioritizeSAN", eCmdHdlrBinary, 0 },
170 	{ "streamdriver.TlsVerifyDepth", eCmdHdlrPositiveInt, 0 },
171 	{ "streamdriver.cafile", eCmdHdlrString, 0 },
172 	{ "streamdriver.keyfile", eCmdHdlrString, 0 },
173 	{ "streamdriver.certfile", eCmdHdlrString, 0 },
174 	{ "permittedpeer", eCmdHdlrArray, 0 },
175 	{ "gnutlsprioritystring", eCmdHdlrString, 0 },
176 	{ "keepalive", eCmdHdlrBinary, 0 },
177 	{ "keepalive.probes", eCmdHdlrNonNegInt, 0 },
178 	{ "keepalive.time", eCmdHdlrNonNegInt, 0 },
179 	{ "keepalive.interval", eCmdHdlrNonNegInt, 0 },
180 	{ "supportoctetcountedframing", eCmdHdlrBinary, 0 },
181 	{ "ratelimit.interval", eCmdHdlrInt, 0 },
182 	{ "framingfix.cisco.asa", eCmdHdlrBinary, 0 },
183 	{ "ratelimit.burst", eCmdHdlrInt, 0 }
184 };
185 static struct cnfparamblk inppblk =
186 	{ CNFPARAMBLK_VERSION,
187 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
188 	  inppdescr
189 	};
190 #include "im-helper.h" 
191 static int bLegacyCnfModGlobalsPermitted;
192 static int
193 isPermittedHost(struct sockaddr *addr, char *fromHostFQDN, void __attribute__((unused)) *pUsrSrv,
194 	        void __attribute__((unused)) *pUsrSess)
195 {
196 	return net.isAllowedSender2(UCHAR_CONSTANT("TCP"), addr, fromHostFQDN, 1);
197 }
198 static rsRetVal
199 doOpenLstnSocks(tcpsrv_t *pSrv)
200 {
201 	ISOBJ_TYPE_assert(pSrv, tcpsrv);
202 	dbgprintf("in imtcp doOpenLstnSocks\n");
203 	return tcpsrv.create_tcp_socket(pSrv);
204 }
205 static rsRetVal
206 doRcvData(tcps_sess_t *pSess, char *buf, size_t lenBuf, ssize_t *piLenRcvd, int *const oserr)
207 {
208 	assert(pSess != NULL);
209 	assert(piLenRcvd != NULL);
210 	*piLenRcvd = lenBuf;
211 	return netstrm.Rcv(pSess-&gt;pStrm, (uchar*) buf, piLenRcvd, oserr);
212 }
213 static rsRetVal
214 onRegularClose(tcps_sess_t *pSess)
215 {
216 	DEFiRet;
217 	assert(pSess != NULL);
218 	tcps_sess.PrepareClose(pSess);
219 	tcps_sess.Close(pSess);
220 	RETiRet;
221 }
222 static rsRetVal
223 onErrClose(tcps_sess_t *pSess)
224 {
225 	DEFiRet;
226 	assert(pSess != NULL);
227 	tcps_sess.Close(pSess);
228 	RETiRet;
229 }
230 static rsRetVal
231 setPermittedPeer(void __attribute__((unused)) *pVal, uchar *pszID)
232 {
233 	DEFiRet;
234 	CHKiRet(net.AddPermittedPeer(&amp;pPermPeersRoot, pszID));
235 	free(pszID); finalize_it:
236 	RETiRet;
237 }
238 static rsRetVal
239 createInstance(instanceConf_t **pinst)
240 {
241 	instanceConf_t *inst = NULL;
242 	DEFiRet;
243 	CHKmalloc(inst = (instanceConf_t*) calloc(1, sizeof(instanceConf_t)));
244 	CHKmalloc(inst-&gt;cnf_params = (tcpLstnParams_t*) calloc(1, sizeof(tcpLstnParams_t)));
245 	inst-&gt;next = NULL;
246 	inst-&gt;pszBindRuleset = NULL;
247 	inst-&gt;pszInputName = NULL;
248 	inst-&gt;dfltTZ = NULL;
249 	inst-&gt;cnf_params-&gt;bSuppOctetFram = -1; 	inst-&gt;bSPFramingFix = 0;
250 	inst-&gt;ratelimitInterval = 0;
251 	inst-&gt;ratelimitBurst = 10000;
252 	inst-&gt;pszStrmDrvrName = NULL;
253 	inst-&gt;pszStrmDrvrAuthMode = NULL;
254 	inst-&gt;pszStrmDrvrPermitExpiredCerts = NULL;
255 	inst-&gt;pszStrmDrvrCAFile = NULL;
256 	inst-&gt;pszStrmDrvrKeyFile = NULL;
257 	inst-&gt;pszStrmDrvrCertFile = NULL;
258 	inst-&gt;pPermPeersRoot = NULL;
259 	inst-&gt;gnutlsPriorityString = NULL;
260 	inst-&gt;iStrmDrvrMode = loadModConf-&gt;iStrmDrvrMode;
261 	inst-&gt;iStrmDrvrExtendedCertCheck = loadModConf-&gt;iStrmDrvrExtendedCertCheck;
262 	inst-&gt;iStrmDrvrSANPreference = loadModConf-&gt;iStrmDrvrSANPreference;
263 	inst-&gt;iStrmTlsVerifyDepth = loadModConf-&gt;iStrmTlsVerifyDepth;
264 	inst-&gt;bKeepAlive = loadModConf-&gt;bKeepAlive;
265 	inst-&gt;iKeepAliveIntvl = loadModConf-&gt;iKeepAliveIntvl;
266 	inst-&gt;iKeepAliveProbes = loadModConf-&gt;iKeepAliveProbes;
267 	inst-&gt;iKeepAliveTime = loadModConf-&gt;iKeepAliveTime;
268 	inst-&gt;iAddtlFrameDelim = loadModConf-&gt;iAddtlFrameDelim;
269 	inst-&gt;maxFrameSize = loadModConf-&gt;maxFrameSize;
270 	inst-&gt;bUseFlowControl = loadModConf-&gt;bUseFlowControl;
271 	inst-&gt;bDisableLFDelim = loadModConf-&gt;bDisableLFDelim;
272 	inst-&gt;discardTruncatedMsg = loadModConf-&gt;discardTruncatedMsg;
273 	inst-&gt;bEmitMsgOnClose = loadModConf-&gt;bEmitMsgOnClose;
274 	inst-&gt;bPreserveCase = loadModConf-&gt;bPreserveCase;
275 	inst-&gt;iTCPLstnMax = loadModConf-&gt;iTCPLstnMax;
276 	inst-&gt;iTCPSessMax = loadModConf-&gt;iTCPSessMax;
277 	inst-&gt;cnf_params-&gt;pszLstnPortFileName = NULL;
278 	if(loadModConf-&gt;tail == NULL) {
279 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
280 	} else {
281 		loadModConf-&gt;tail-&gt;next = inst;
282 		loadModConf-&gt;tail = inst;
283 	}
284 	*pinst = inst;
285 finalize_it:
286 	if(iRet != RS_RET_OK) {
287 		free(inst-&gt;cnf_params);
288 		free(inst);
289 	}
290 	RETiRet;
291 }
292 static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
293 {
294 	instanceConf_t *inst;
295 	DEFiRet;
296 	CHKiRet(createInstance(&amp;inst));
297 	CHKmalloc(inst-&gt;cnf_params-&gt;pszPort = ustrdup((pNewVal == NULL || *pNewVal == '\0')
298 				 	       ? (uchar*) "10514" : pNewVal));
299 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
300 		inst-&gt;pszBindRuleset = NULL;
301 	} else {
302 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
303 	}
304 	if((cs.lstnIP == NULL) || (cs.lstnIP[0] == '\0')) {
305 		inst-&gt;cnf_params-&gt;pszAddr = NULL;
306 	} else {
307 		CHKmalloc(inst-&gt;cnf_params-&gt;pszAddr = ustrdup(cs.lstnIP));
308 	}
309 	if((cs.lstnPortFile == NULL) || (cs.lstnPortFile[0] == '\0')) {
310 		inst-&gt;cnf_params-&gt;pszLstnPortFileName = NULL;
311 	} else {
312 		CHKmalloc(inst-&gt;cnf_params-&gt;pszLstnPortFileName = ustrdup(cs.lstnPortFile));
313 	}
314 	if((cs.pszInputName == NULL) || (cs.pszInputName[0] == '\0')) {
315 		inst-&gt;pszInputName = NULL;
316 	} else {
317 		CHKmalloc(inst-&gt;pszInputName = ustrdup(cs.pszInputName));
318 	}
319 	inst-&gt;cnf_params-&gt;bSuppOctetFram = cs.bSuppOctetFram;
320 finalize_it:
321 	free(pNewVal);
322 	RETiRet;
323 }
324 static rsRetVal
325 addListner(modConfData_t *modConf, instanceConf_t *inst)
326 {
327 	DEFiRet;
328 	uchar *psz;		permittedPeers_t *peers;
329 	tcpsrv_t *pOurTcpsrv;
330 	CHKiRet(tcpsrv.Construct(&amp;pOurTcpsrv));
331 	CHKiRet(tcpsrv.SetCBIsPermittedHost(pOurTcpsrv, isPermittedHost));
332 	CHKiRet(tcpsrv.SetCBRcvData(pOurTcpsrv, doRcvData));
333 	CHKiRet(tcpsrv.SetCBOpenLstnSocks(pOurTcpsrv, doOpenLstnSocks));
334 	CHKiRet(tcpsrv.SetCBOnRegularClose(pOurTcpsrv, onRegularClose));
335 	CHKiRet(tcpsrv.SetCBOnErrClose(pOurTcpsrv, onErrClose));
336 	CHKiRet(tcpsrv.SetKeepAlive(pOurTcpsrv, inst-&gt;bKeepAlive));
337 	CHKiRet(tcpsrv.SetKeepAliveIntvl(pOurTcpsrv, inst-&gt;iKeepAliveIntvl));
338 	CHKiRet(tcpsrv.SetKeepAliveProbes(pOurTcpsrv, inst-&gt;iKeepAliveProbes));
339 	CHKiRet(tcpsrv.SetKeepAliveTime(pOurTcpsrv, inst-&gt;iKeepAliveTime));
340 	CHKiRet(tcpsrv.SetSessMax(pOurTcpsrv, inst-&gt;iTCPSessMax));
341 	CHKiRet(tcpsrv.SetLstnMax(pOurTcpsrv, inst-&gt;iTCPLstnMax));
342 	CHKiRet(tcpsrv.SetDrvrMode(pOurTcpsrv, inst-&gt;iStrmDrvrMode));
343 	CHKiRet(tcpsrv.SetDrvrCheckExtendedKeyUsage(pOurTcpsrv, inst-&gt;iStrmDrvrExtendedCertCheck));
344 	CHKiRet(tcpsrv.SetDrvrPrioritizeSAN(pOurTcpsrv, inst-&gt;iStrmDrvrSANPreference));
345 	CHKiRet(tcpsrv.SetDrvrTlsVerifyDepth(pOurTcpsrv, inst-&gt;iStrmTlsVerifyDepth));
346 	CHKiRet(tcpsrv.SetUseFlowControl(pOurTcpsrv, inst-&gt;bUseFlowControl));
347 	CHKiRet(tcpsrv.SetAddtlFrameDelim(pOurTcpsrv, inst-&gt;iAddtlFrameDelim));
348 	CHKiRet(tcpsrv.SetMaxFrameSize(pOurTcpsrv, inst-&gt;maxFrameSize));
349 	CHKiRet(tcpsrv.SetbDisableLFDelim(pOurTcpsrv, inst-&gt;bDisableLFDelim));
350 	CHKiRet(tcpsrv.SetDiscardTruncatedMsg(pOurTcpsrv, inst-&gt;discardTruncatedMsg));
351 	CHKiRet(tcpsrv.SetNotificationOnRemoteClose(pOurTcpsrv, inst-&gt;bEmitMsgOnClose));
352 	CHKiRet(tcpsrv.SetPreserveCase(pOurTcpsrv, inst-&gt;bPreserveCase));
353 	psz = (inst-&gt;pszStrmDrvrName == NULL) ? modConf-&gt;pszStrmDrvrName : inst-&gt;pszStrmDrvrName;
354 	if(psz != NULL) {
355 		CHKiRet(tcpsrv.SetDrvrName(pOurTcpsrv, psz));
356 	}
357 	psz = (inst-&gt;pszStrmDrvrAuthMode == NULL) ? modConf-&gt;pszStrmDrvrAuthMode : inst-&gt;pszStrmDrvrAuthMode;
358 	if(psz != NULL) {
359 		CHKiRet(tcpsrv.SetDrvrAuthMode(pOurTcpsrv, psz));
360 	}
361 	psz = (inst-&gt;gnutlsPriorityString == NULL)
362 			? modConf-&gt;gnutlsPriorityString : inst-&gt;gnutlsPriorityString;
363 	CHKiRet(tcpsrv.SetGnutlsPriorityString(pOurTcpsrv, psz));
364 	psz = (inst-&gt;pszStrmDrvrPermitExpiredCerts == NULL)
365 			? modConf-&gt;pszStrmDrvrPermitExpiredCerts : inst-&gt;pszStrmDrvrPermitExpiredCerts;
366 	CHKiRet(tcpsrv.SetDrvrPermitExpiredCerts(pOurTcpsrv, psz));
367 	psz = (inst-&gt;pszStrmDrvrCAFile == NULL)
368 			? modConf-&gt;pszStrmDrvrCAFile : inst-&gt;pszStrmDrvrCAFile;
369 	CHKiRet(tcpsrv.SetDrvrCAFile(pOurTcpsrv, psz));
370 	psz = (inst-&gt;pszStrmDrvrKeyFile == NULL)
371 			? modConf-&gt;pszStrmDrvrKeyFile : inst-&gt;pszStrmDrvrKeyFile;
372 	CHKiRet(tcpsrv.SetDrvrKeyFile(pOurTcpsrv, psz));
373 	psz = (inst-&gt;pszStrmDrvrCertFile == NULL)
374 			? modConf-&gt;pszStrmDrvrCertFile : inst-&gt;pszStrmDrvrCertFile;
375 	CHKiRet(tcpsrv.SetDrvrCertFile(pOurTcpsrv, psz));
376 	peers = (inst-&gt;pPermPeersRoot == NULL)
377 			? modConf-&gt;pPermPeersRoot : inst-&gt;pPermPeersRoot;
378 	if(peers != NULL) {
379 			CHKiRet(tcpsrv.SetDrvrPermPeers(pOurTcpsrv, peers));
380 	}
381 	DBGPRINTF("imtcp: trying to add port *:%s\n", inst-&gt;cnf_params-&gt;pszPort);
382 	inst-&gt;cnf_params-&gt;pRuleset = inst-&gt;pBindRuleset;
383 	CHKiRet(tcpsrv.SetInputName(pOurTcpsrv, inst-&gt;cnf_params, inst-&gt;pszInputName == NULL ?
384 						UCHAR_CONSTANT("imtcp") : inst-&gt;pszInputName));
385 	CHKiRet(tcpsrv.SetOrigin(pOurTcpsrv, (uchar*)"imtcp"));
386 	CHKiRet(tcpsrv.SetDfltTZ(pOurTcpsrv, (inst-&gt;dfltTZ == NULL) ? (uchar*)"" : inst-&gt;dfltTZ));
387 	CHKiRet(tcpsrv.SetbSPFramingFix(pOurTcpsrv, inst-&gt;bSPFramingFix));
388 	CHKiRet(tcpsrv.SetLinuxLikeRatelimiters(pOurTcpsrv, inst-&gt;ratelimitInterval, inst-&gt;ratelimitBurst));
389 	if((ustrcmp(inst-&gt;cnf_params-&gt;pszPort, UCHAR_CONSTANT("0")) == 0
390 		&amp;&amp; inst-&gt;cnf_params-&gt;pszLstnPortFileName == NULL)
391 			|| ustrcmp(inst-&gt;cnf_params-&gt;pszPort, UCHAR_CONSTANT("0")) &lt; 0) {
392 		LogMsg(0, RS_RET_OK, LOG_WARNING, "imtcp: port 0 and no port file set -&gt; using port 514 instead");
393 		CHKmalloc(inst-&gt;cnf_params-&gt;pszPort = (uchar*)strdup("514"));
394 	}
395 	tcpsrv.configureTCPListen(pOurTcpsrv, inst-&gt;cnf_params);
396 	tcpsrv_etry_t *etry;
397 	CHKmalloc(etry = (tcpsrv_etry_t*) calloc(1, sizeof(tcpsrv_etry_t)));
398 	etry-&gt;tcpsrv = pOurTcpsrv;
399 	etry-&gt;next = tcpsrv_root;
400 	tcpsrv_root = etry;
401 	++n_tcpsrv;
402 finalize_it:
403 	if(iRet != RS_RET_OK) {
404 		LogError(0, NO_ERRCODE, "imtcp: error %d trying to add listener", iRet);
405 	}
406 	RETiRet;
407 }
408 BEGINnewInpInst
409 	struct cnfparamvals *pvals;
410 	instanceConf_t *inst;
411 	int i;
412 CODESTARTnewInpInst
413 	DBGPRINTF("newInpInst (imtcp)\n");
414 	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
415 	if(pvals == NULL) {
416 		LogError(0, RS_RET_MISSING_CNFPARAMS,
417 			        "imtcp: required parameter are missing\n");
418 <a name="3"></a>		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
419 	}
420 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(Debug) {
421 		dbgprintf("input param blk in imtcp:\n");
422 		cnfparamsPrint(&amp;inppblk, pvals);
423 	}
424 	CHKiRet(createInstance(&amp;inst));
425 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
426 		if(!pvals[i].bUsed)
427 			continue;
428 		if(!strcmp(inppblk.descr[i].name, "port")) {
429 			inst-&gt;cnf_params-&gt;pszPort = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
430 		} else if(!strcmp(inppblk.descr[i].name, "address")) {</b></font>
431 			inst-&gt;cnf_params-&gt;pszAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
432 		} else if(!strcmp(inppblk.descr[i].name, "name")) {
433 <a name="2"></a>			inst-&gt;pszInputName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
434 		} else if(!strcmp(inppblk.descr[i].name, "defaulttz")) {
435 			inst-&gt;dfltTZ = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
436 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "framingfix.cisco.asa")) {
437 			inst-&gt;bSPFramingFix = (int) pvals[i].val.d.n;
438 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
439 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
440 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.mode")) {
441 			inst-&gt;iStrmDrvrMode = (int) pvals[i].val.d.n;</b></font>
442 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.CheckExtendedKeyPurpose")) {
443 			inst-&gt;iStrmDrvrExtendedCertCheck = (int) pvals[i].val.d.n;
444 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.PrioritizeSAN")) {
445 			inst-&gt;iStrmDrvrSANPreference = (int) pvals[i].val.d.n;
446 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.TlsVerifyDepth")) {
447 			if (pvals[i].val.d.n &gt;= 2) {
448 				inst-&gt;iStrmTlsVerifyDepth = (int) pvals[i].val.d.n;
449 			} else {
450 				parser_errmsg("streamdriver.TlsVerifyDepth must be 2 or higher but is %d",
451 									(int) pvals[i].val.d.n);
452 			}
453 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.authmode")) {
454 			inst-&gt;pszStrmDrvrAuthMode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
455 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.permitexpiredcerts")) {
456 			inst-&gt;pszStrmDrvrPermitExpiredCerts = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
457 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.cafile")) {
458 			inst-&gt;pszStrmDrvrCAFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
459 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.keyfile")) {
460 			inst-&gt;pszStrmDrvrKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
461 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.certfile")) {
462 			inst-&gt;pszStrmDrvrCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
463 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.name")) {
464 			inst-&gt;pszStrmDrvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
465 		} else if(!strcmp(inppblk.descr[i].name, "gnutlsprioritystring")) {
466 			inst-&gt;gnutlsPriorityString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
467 		} else if(!strcmp(inppblk.descr[i].name, "permittedpeer")) {
468 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
469 				uchar *const peer = (uchar*) es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
470 				CHKiRet(net.AddPermittedPeer(&amp;inst-&gt;pPermPeersRoot, peer));
471 				free(peer);
472 			}
473 		} else if(!strcmp(inppblk.descr[i].name, "flowcontrol")) {
474 			inst-&gt;bUseFlowControl = (int) pvals[i].val.d.n;
475 		} else if(!strcmp(inppblk.descr[i].name, "disablelfdelimiter")) {
476 			inst-&gt;bDisableLFDelim = (int) pvals[i].val.d.n;
477 		} else if(!strcmp(inppblk.descr[i].name, "discardtruncatedmsg")) {
478 			inst-&gt;discardTruncatedMsg = (int) pvals[i].val.d.n;
479 		} else if(!strcmp(inppblk.descr[i].name, "notifyonconnectionclose")) {
480 			inst-&gt;bEmitMsgOnClose = (int) pvals[i].val.d.n;
481 		} else if(!strcmp(inppblk.descr[i].name, "addtlframedelimiter")) {
482 			inst-&gt;iAddtlFrameDelim = (int) pvals[i].val.d.n;
483 		} else if(!strcmp(inppblk.descr[i].name, "maxframesize")) {
484 			const int max = (int) pvals[i].val.d.n;
485 			if(max &lt;= 200000000) {
486 				inst-&gt;maxFrameSize = max;
487 			} else {
488 				LogError(0, RS_RET_PARAM_ERROR, "imtcp: invalid value for 'maxFrameSize' "
489 						"parameter given is %d, max is 200000000", max);
490 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
491 			}
492 		} else if(!strcmp(inppblk.descr[i].name, "maxsessions")) {
493 			inst-&gt;iTCPSessMax = (int) pvals[i].val.d.n;
494 		} else if(!strcmp(inppblk.descr[i].name, "maxlisteners")) {
495 			inst-&gt;iTCPLstnMax = (int) pvals[i].val.d.n;
496 		} else if(!strcmp(inppblk.descr[i].name, "supportoctetcountedframing")) {
497 			inst-&gt;cnf_params-&gt;bSuppOctetFram = (int) pvals[i].val.d.n;
498 		} else if(!strcmp(inppblk.descr[i].name, "keepalive")) {
499 			inst-&gt;bKeepAlive = (int) pvals[i].val.d.n;
500 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.probes")) {
501 			inst-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
502 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.time")) {
503 			inst-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
504 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.interval")) {
505 			inst-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
506 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.burst")) {
507 			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
508 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.interval")) {
509 			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
510 		} else if(!strcmp(inppblk.descr[i].name, "preservecase")) {
511 			inst-&gt;bPreserveCase = (int) pvals[i].val.d.n;
512 		} else if(!strcmp(inppblk.descr[i].name, "listenportfilename")) {
513 			inst-&gt;cnf_params-&gt;pszLstnPortFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
514 		} else {
515 			dbgprintf("imtcp: program error, non-handled "
516 			  "param '%s'\n", inppblk.descr[i].name);
517 		}
518 	}
519 finalize_it:
520 CODE_STD_FINALIZERnewInpInst
521 	cnfparamvalsDestruct(pvals, &amp;inppblk);
522 ENDnewInpInst
523 BEGINbeginCnfLoad
524 CODESTARTbeginCnfLoad
525 	loadModConf = pModConf;
526 	pModConf-&gt;pConf = pConf;
527 	loadModConf-&gt;iTCPSessMax = 200;
528 	loadModConf-&gt;iTCPLstnMax = 20;
529 	loadModConf-&gt;bSuppOctetFram = 1;
530 	loadModConf-&gt;iStrmDrvrMode = 0;
531 	loadModConf-&gt;iStrmDrvrExtendedCertCheck = 0;
532 	loadModConf-&gt;iStrmDrvrSANPreference = 0;
533 	loadModConf-&gt;iStrmTlsVerifyDepth = 0;
534 	loadModConf-&gt;bUseFlowControl = 1;
535 	loadModConf-&gt;bKeepAlive = 0;
536 	loadModConf-&gt;iKeepAliveIntvl = 0;
537 	loadModConf-&gt;iKeepAliveProbes = 0;
538 	loadModConf-&gt;iKeepAliveTime = 0;
539 	loadModConf-&gt;bEmitMsgOnClose = 0;
540 	loadModConf-&gt;iAddtlFrameDelim = TCPSRV_NO_ADDTL_DELIMITER;
541 	loadModConf-&gt;maxFrameSize = 200000;
542 	loadModConf-&gt;bDisableLFDelim = 0;
543 	loadModConf-&gt;discardTruncatedMsg = 0;
544 	loadModConf-&gt;gnutlsPriorityString = NULL;
545 	loadModConf-&gt;pszStrmDrvrName = NULL;
546 	loadModConf-&gt;pszStrmDrvrAuthMode = NULL;
547 	loadModConf-&gt;pszStrmDrvrPermitExpiredCerts = NULL;
548 	loadModConf-&gt;pszStrmDrvrCAFile = NULL;
549 	loadModConf-&gt;pszStrmDrvrKeyFile = NULL;
550 	loadModConf-&gt;pszStrmDrvrCertFile = NULL;
551 	loadModConf-&gt;pPermPeersRoot = NULL;
552 	loadModConf-&gt;configSetViaV2Method = 0;
553 	loadModConf-&gt;bPreserveCase = 1; 	bLegacyCnfModGlobalsPermitted = 1;
554 	resetConfigVariables(NULL, NULL); ENDbeginCnfLoad
555 <a name="0"></a>
556 BEGINsetModCnf
557 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	struct cnfparamvals *pvals = NULL;
558 	int i;
559 CODESTARTsetModCnf
560 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
561 	if(pvals == NULL) {
562 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imtcp: error processing module "
563 				"config parameters [module(...)]");
564 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
565 	}
566 	if(Debug) {
567 		dbgprintf("module (global) param blk for imtcp:\n");
568 		cnfparamsPrint(&amp;modpblk, pvals);
569 	}
570 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
571 		if(!pvals[i].bUsed)
572 			continue;
573 		if(!strcmp(modpblk.descr[i].name, "flowcontrol")) {
574 			loadModConf-&gt;bUseFlowControl = (int) pvals[i].val.d.n;
575 		} else if(!strcmp(modpblk.descr[i].name, "disablelfdelimiter")) {</b></font>
576 			loadModConf-&gt;bDisableLFDelim = (int) pvals[i].val.d.n;
577 		} else if(!strcmp(modpblk.descr[i].name, "discardtruncatedmsg")) {
578 			loadModConf-&gt;discardTruncatedMsg = (int) pvals[i].val.d.n;
579 		} else if(!strcmp(modpblk.descr[i].name, "octetcountedframing")) {
580 			loadModConf-&gt;bSuppOctetFram = (int) pvals[i].val.d.n;
581 		} else if(!strcmp(modpblk.descr[i].name, "notifyonconnectionclose")) {
582 			loadModConf-&gt;bEmitMsgOnClose = (int) pvals[i].val.d.n;
583 		} else if(!strcmp(modpblk.descr[i].name, "addtlframedelimiter")) {
584 			loadModConf-&gt;iAddtlFrameDelim = (int) pvals[i].val.d.n;
585 		} else if(!strcmp(modpblk.descr[i].name, "maxframesize")) {
586 			const int max = (int) pvals[i].val.d.n;
587 			if(max &lt;= 200000000) {
588 				loadModConf-&gt;maxFrameSize = max;
589 			} else {
590 				LogError(0, RS_RET_PARAM_ERROR, "imtcp: invalid value for 'maxFrameSize' "
591 						"parameter given is %d, max is 200000000", max);
592 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
593 			}
594 		} else if(!strcmp(modpblk.descr[i].name, "maxsessions")) {
595 			loadModConf-&gt;iTCPSessMax = (int) pvals[i].val.d.n;
596 		} else if(!strcmp(modpblk.descr[i].name, "maxlisteners") ||
597 			  !strcmp(modpblk.descr[i].name, "maxlistners")) { 			loadModConf-&gt;iTCPLstnMax = (int) pvals[i].val.d.n;
598 		} else if(!strcmp(modpblk.descr[i].name, "keepalive")) {
599 			loadModConf-&gt;bKeepAlive = (int) pvals[i].val.d.n;
600 		} else if(!strcmp(modpblk.descr[i].name, "keepalive.probes")) {
601 			loadModConf-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
602 		} else if(!strcmp(modpblk.descr[i].name, "keepalive.time")) {
603 			loadModConf-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
604 		} else if(!strcmp(modpblk.descr[i].name, "keepalive.interval")) {
605 			loadModConf-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
606 		} else if(!strcmp(modpblk.descr[i].name, "gnutlsprioritystring")) {
607 			loadModConf-&gt;gnutlsPriorityString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
608 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.mode")) {
609 			loadModConf-&gt;iStrmDrvrMode = (int) pvals[i].val.d.n;
610 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.CheckExtendedKeyPurpose")) {
611 			loadModConf-&gt;iStrmDrvrExtendedCertCheck = (int) pvals[i].val.d.n;
612 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.PrioritizeSAN")) {
613 			loadModConf-&gt;iStrmDrvrSANPreference = (int) pvals[i].val.d.n;
614 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.TlsVerifyDepth")) {
615 			if (pvals[i].val.d.n &gt;= 2) {
616 				loadModConf-&gt;iStrmTlsVerifyDepth = (int) pvals[i].val.d.n;
617 			} else {
618 				parser_errmsg("streamdriver.TlsVerifyDepth must be 2 or higher but is %d",
619 									(int) pvals[i].val.d.n);
620 			}
621 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.authmode")) {
622 			loadModConf-&gt;pszStrmDrvrAuthMode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
623 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.permitexpiredcerts")) {
624 			loadModConf-&gt;pszStrmDrvrPermitExpiredCerts = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
625 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.cafile")) {
626 			loadModConf-&gt;pszStrmDrvrCAFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
627 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.keyfile")) {
628 			loadModConf-&gt;pszStrmDrvrKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
629 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.certfile")) {
630 			loadModConf-&gt;pszStrmDrvrCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
631 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.name")) {
632 			loadModConf-&gt;pszStrmDrvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
633 		} else if(!strcmp(modpblk.descr[i].name, "permittedpeer")) {
634 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
635 				uchar *const peer = (uchar*) es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
636 				CHKiRet(net.AddPermittedPeer(&amp;loadModConf-&gt;pPermPeersRoot, peer));
637 				free(peer);
638 			}
639 		} else if(!strcmp(modpblk.descr[i].name, "preservecase")) {
640 			loadModConf-&gt;bPreserveCase = (int) pvals[i].val.d.n;
641 		} else {
642 			dbgprintf("imtcp: program error, non-handled "
643 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
644 		}
645 	}
646 	bLegacyCnfModGlobalsPermitted = 0;
647 	loadModConf-&gt;configSetViaV2Method = 1;
648 finalize_it:
649 	if(pvals != NULL)
650 		cnfparamvalsDestruct(pvals, &amp;modpblk);
651 ENDsetModCnf
652 BEGINendCnfLoad
653 CODESTARTendCnfLoad
654 	if(!loadModConf-&gt;configSetViaV2Method) {
655 		pModConf-&gt;iTCPSessMax = cs.iTCPSessMax;
656 		pModConf-&gt;iTCPLstnMax = cs.iTCPLstnMax;
657 		pModConf-&gt;iStrmDrvrMode = cs.iStrmDrvrMode;
658 		pModConf-&gt;bEmitMsgOnClose = cs.bEmitMsgOnClose;
659 		pModConf-&gt;bSuppOctetFram = cs.bSuppOctetFram;
660 		pModConf-&gt;iAddtlFrameDelim = cs.iAddtlFrameDelim;
661 		pModConf-&gt;maxFrameSize = cs.maxFrameSize;
662 		pModConf-&gt;bDisableLFDelim = cs.bDisableLFDelim;
663 		pModConf-&gt;bUseFlowControl = cs.bUseFlowControl;
664 		pModConf-&gt;bKeepAlive = cs.bKeepAlive;
665 		pModConf-&gt;iKeepAliveProbes = cs.iKeepAliveProbes;
666 		pModConf-&gt;iKeepAliveIntvl = cs.iKeepAliveIntvl;
667 		pModConf-&gt;iKeepAliveTime = cs.iKeepAliveTime;
668 		if(pPermPeersRoot != NULL) {
669 			assert(pModConf-&gt;pPermPeersRoot == NULL);
670 			pModConf-&gt;pPermPeersRoot = pPermPeersRoot;
671 			pPermPeersRoot = NULL; 		}
672 		if((cs.pszStrmDrvrAuthMode == NULL) || (cs.pszStrmDrvrAuthMode[0] == '\0')) {
673 			loadModConf-&gt;pszStrmDrvrAuthMode = NULL;
674 		} else {
675 			loadModConf-&gt;pszStrmDrvrAuthMode = cs.pszStrmDrvrAuthMode;
676 			cs.pszStrmDrvrAuthMode = NULL;
677 		}
678 		pModConf-&gt;bPreserveCase = cs.bPreserveCase;
679 	}
680 	free(cs.pszStrmDrvrAuthMode);
681 	cs.pszStrmDrvrAuthMode = NULL;
682 	loadModConf = NULL; ENDendCnfLoad
683 static inline void
684 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
685 {
686 	LogError(0, NO_ERRCODE, "imtcp: ruleset '%s' for port %s not found - "
687 			"using default ruleset instead", inst-&gt;pszBindRuleset,
688 			inst-&gt;cnf_params-&gt;pszPort);
689 }
690 BEGINcheckCnf
691 	instanceConf_t *inst;
692 CODESTARTcheckCnf
693 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
694 		std_checkRuleset(pModConf, inst);
695 		if(inst-&gt;cnf_params-&gt;bSuppOctetFram == FRAMING_UNSET)
696 			inst-&gt;cnf_params-&gt;bSuppOctetFram = pModConf-&gt;bSuppOctetFram;
697 	}
698 	if(pModConf-&gt;root == NULL) {
699 		LogError(0, RS_RET_NO_LISTNERS , "imtcp: module loaded, but "
700 				"no listeners defined - no input will be gathered");
701 		iRet = RS_RET_NO_LISTNERS;
702 	}
703 ENDcheckCnf
704 BEGINactivateCnfPrePrivDrop
705 	instanceConf_t *inst;
706 CODESTARTactivateCnfPrePrivDrop
707 	runModConf = pModConf;
708 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
709 		addListner(runModConf, inst);
710 	}
711 	if(tcpsrv_root == NULL)
712 		ABORT_FINALIZE(RS_RET_NO_RUN);
713 	tcpsrv_etry_t *etry = tcpsrv_root;
714 	while(etry != NULL) {
715 		CHKiRet(tcpsrv.ConstructFinalize(etry-&gt;tcpsrv));
716 		etry = etry-&gt;next;
717 	}
718 finalize_it:
719 ENDactivateCnfPrePrivDrop
720 BEGINactivateCnf
721 CODESTARTactivateCnf
722 ENDactivateCnf
723 BEGINfreeCnf
724 	instanceConf_t *inst, *del;
725 CODESTARTfreeCnf
726 	free(pModConf-&gt;gnutlsPriorityString);
727 	free(pModConf-&gt;pszStrmDrvrName);
728 	free(pModConf-&gt;pszStrmDrvrAuthMode);
729 	free(pModConf-&gt;pszStrmDrvrPermitExpiredCerts);
730 	free(pModConf-&gt;pszStrmDrvrCAFile);
731 	free(pModConf-&gt;pszStrmDrvrKeyFile);
732 	free(pModConf-&gt;pszStrmDrvrCertFile);
733 	if(pModConf-&gt;pPermPeersRoot != NULL) {
734 		net.DestructPermittedPeers(&amp;pModConf-&gt;pPermPeersRoot);
735 	}
736 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
737 		free((void*)inst-&gt;pszBindRuleset);
738 		free((void*)inst-&gt;pszStrmDrvrAuthMode);
739 		free((void*)inst-&gt;pszStrmDrvrName);
740 		free((void*)inst-&gt;pszStrmDrvrPermitExpiredCerts);
741 		free((void*)inst-&gt;pszStrmDrvrCAFile);
742 		free((void*)inst-&gt;pszStrmDrvrKeyFile);
743 		free((void*)inst-&gt;pszStrmDrvrCertFile);
744 		free((void*)inst-&gt;gnutlsPriorityString);
745 		free((void*)inst-&gt;pszInputName);
746 		free((void*)inst-&gt;dfltTZ);
747 		if(inst-&gt;pPermPeersRoot != NULL) {
748 			net.DestructPermittedPeers(&amp;inst-&gt;pPermPeersRoot);
749 		}
750 		del = inst;
751 		inst = inst-&gt;next;
752 		free(del);
753 	}
754 ENDfreeCnf
755 static void *
756 RunServerThread(void *myself)
757 {
758 	tcpsrv_etry_t *const etry = (tcpsrv_etry_t*) myself;
759 	rsRetVal iRet;
760 	dbgprintf("RGER: running ety %p\n", etry);
761 	iRet = tcpsrv.Run(etry-&gt;tcpsrv);
762 	if(iRet != RS_RET_OK) {
763 		LogError(0, iRet, "imtcp: error while terminating server; rsyslog may hang on shutdown");
764 	}
765 	return NULL;
766 }
767 static void
768 startSrvWrkr(tcpsrv_etry_t *const etry)
769 {
770 	int r;
771 	pthread_attr_t sessThrdAttr;
772 	sigset_t sigSet, sigSetSave;
773 	sigfillset(&amp;sigSet);
774 	sigdelset(&amp;sigSet, SIGTTIN);
775 	sigdelset(&amp;sigSet, SIGSEGV);
776 	pthread_sigmask(SIG_SETMASK, &amp;sigSet, &amp;sigSetSave);
777 	pthread_attr_init(&amp;sessThrdAttr);
778 	pthread_attr_setstacksize(&amp;sessThrdAttr, 4096*1024);
779 	r = pthread_create(&amp;etry-&gt;tid, &amp;sessThrdAttr, RunServerThread, etry);
780 	if(r != 0) {
781 		LogError(r, NO_ERRCODE, "imtcp error creating server thread");
782 	}
783 	pthread_attr_destroy(&amp;sessThrdAttr);
784 	pthread_sigmask(SIG_SETMASK, &amp;sigSetSave, NULL);
785 }
786 static void
787 stopSrvWrkr(tcpsrv_etry_t *const etry)
788 {
789 	DBGPRINTF("Wait for thread shutdown etry %p\n", etry);
790 	pthread_kill(etry-&gt;tid, SIGTTIN);
791 	pthread_join(etry-&gt;tid, NULL);
792 	DBGPRINTF("input %p terminated\n", etry);
793 }
794 BEGINrunInput
795 CODESTARTrunInput
796 	tcpsrv_etry_t *etry = tcpsrv_root-&gt;next;
797 	while(etry != NULL) {
798 		startSrvWrkr(etry);
799 		etry = etry-&gt;next;
800 	}
801 	iRet = tcpsrv.Run(tcpsrv_root-&gt;tcpsrv);
802 	etry = tcpsrv_root-&gt;next;
803 	while(etry != NULL) {
804 		stopSrvWrkr(etry);
805 		etry = etry-&gt;next;
806 	}
807 ENDrunInput
808 BEGINwillRun
809 CODESTARTwillRun
810 	net.PrintAllowedSenders(2); ENDwillRun
811 BEGINafterRun
812 CODESTARTafterRun
813 	tcpsrv_etry_t *etry = tcpsrv_root;
814 	tcpsrv_etry_t *del;
815 	while(etry != NULL) {
816 		iRet = tcpsrv.Destruct(&amp;etry-&gt;tcpsrv);
817 		del = etry;
818 		etry = etry-&gt;next;
819 		free(del);
820 	}
821 	net.clearAllowedSenders(UCHAR_CONSTANT("TCP"));
822 ENDafterRun
823 BEGINisCompatibleWithFeature
824 CODESTARTisCompatibleWithFeature
825 	if(eFeat == sFEATURENonCancelInputTermination)
826 		iRet = RS_RET_OK;
827 ENDisCompatibleWithFeature
828 BEGINmodExit
829 CODESTARTmodExit
830 	objRelease(net, LM_NET_FILENAME);
831 	objRelease(netstrm, LM_NETSTRMS_FILENAME);
832 	objRelease(tcps_sess, LM_TCPSRV_FILENAME);
833 	objRelease(tcpsrv, LM_TCPSRV_FILENAME);
834 	objRelease(ruleset, CORE_COMPONENT);
835 ENDmodExit
836 static rsRetVal
837 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
838 {
839 	cs.iTCPSessMax = 200;
840 	cs.iTCPLstnMax = 20;
841 	cs.bSuppOctetFram = 1;
842 	cs.iStrmDrvrMode = 0;
843 	cs.bUseFlowControl = 1;
844 	cs.bKeepAlive = 0;
845 	cs.iKeepAliveProbes = 0;
846 	cs.iKeepAliveTime = 0;
847 	cs.iKeepAliveIntvl = 0;
848 	cs.bEmitMsgOnClose = 0;
849 	cs.iAddtlFrameDelim = TCPSRV_NO_ADDTL_DELIMITER;
850 	cs.maxFrameSize = 200000;
851 	cs.bDisableLFDelim = 0;
852 	cs.bPreserveCase = 1;
853 	free(cs.pszStrmDrvrAuthMode);
854 	cs.pszStrmDrvrAuthMode = NULL;
855 	free(cs.pszInputName);
856 	cs.pszInputName = NULL;
857 	free(cs.lstnPortFile);
858 	cs.lstnPortFile = NULL;
859 	return RS_RET_OK;
860 }
861 BEGINqueryEtryPt
862 CODESTARTqueryEtryPt
863 CODEqueryEtryPt_STD_IMOD_QUERIES
864 CODEqueryEtryPt_STD_CONF2_QUERIES
865 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
866 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
867 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
868 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
869 ENDqueryEtryPt
870 BEGINmodInit()
871 CODESTARTmodInit
872 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
873 	tcpsrv_root = NULL;
874 	CHKiRet(objUse(net, LM_NET_FILENAME));
875 	CHKiRet(objUse(netstrm, LM_NETSTRMS_FILENAME));
876 	CHKiRet(objUse(tcps_sess, LM_TCPSRV_FILENAME));
877 	CHKiRet(objUse(tcpsrv, LM_TCPSRV_FILENAME));
878 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
879 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("inputtcpserverrun"), 0, eCmdHdlrGetWord,
880 				   addInstance, NULL, STD_LOADABLE_MODULE_ID));
881 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("inputtcpserverinputname"), 0, eCmdHdlrGetWord,
882 				   NULL, &amp;cs.pszInputName, STD_LOADABLE_MODULE_ID));
883 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("inputtcpserverbindruleset"), 0, eCmdHdlrGetWord,
884 				   NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
885 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverstreamdriverpermittedpeer"), 0, eCmdHdlrGetWord,
886 			   setPermittedPeer, NULL, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
887 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverstreamdriverauthmode"), 0, eCmdHdlrGetWord,
888 			   NULL, &amp;cs.pszStrmDrvrAuthMode, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
889 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive"), 0, eCmdHdlrBinary,
890 			   NULL, &amp;cs.bKeepAlive, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
891 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive_probes"), 0, eCmdHdlrInt,
892 			   NULL, &amp;cs.iKeepAliveProbes, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
893 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive_intvl"), 0, eCmdHdlrInt,
894 			   NULL, &amp;cs.iKeepAliveIntvl, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
895 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive_time"), 0, eCmdHdlrInt,
896 			   NULL, &amp;cs.iKeepAliveTime, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
897 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpflowcontrol"), 0, eCmdHdlrBinary,
898 			   NULL, &amp;cs.bUseFlowControl, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
899 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverdisablelfdelimiter"), 0, eCmdHdlrBinary,
900 			   NULL, &amp;cs.bDisableLFDelim, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
901 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserveraddtlframedelimiter"), 0, eCmdHdlrInt,
902 			   NULL, &amp;cs.iAddtlFrameDelim, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
903 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserversupportoctetcountedframing"), 0, eCmdHdlrBinary,
904 			   NULL, &amp;cs.bSuppOctetFram, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
905 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpmaxsessions"), 0, eCmdHdlrInt,
906 			   NULL, &amp;cs.iTCPSessMax, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
907 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpmaxlisteners"), 0, eCmdHdlrInt,
908 			   NULL, &amp;cs.iTCPLstnMax, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
909 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpservernotifyonconnectionclose"), 0, eCmdHdlrBinary,
910 			   NULL, &amp;cs.bEmitMsgOnClose, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
911 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverstreamdrivermode"), 0, eCmdHdlrInt,
912 			   NULL, &amp;cs.iStrmDrvrMode, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
913 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverpreservecase"), 1, eCmdHdlrBinary,
914 			   NULL, &amp;cs.bPreserveCase, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
915 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverlistenportfile"), 1, eCmdHdlrGetWord,
916 			   NULL, &amp;cs.lstnPortFile, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
917 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("resetconfigvariables"), 1, eCmdHdlrCustomHandler,
918 				   resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
919 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
