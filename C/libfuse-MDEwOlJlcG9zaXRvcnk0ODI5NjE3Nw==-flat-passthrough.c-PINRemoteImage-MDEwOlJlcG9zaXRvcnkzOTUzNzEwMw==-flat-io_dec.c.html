
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.368460955269144%, Tokens: 8</h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 31
2  #define _GNU_SOURCE
3  #ifdef linux
4  #define _XOPEN_SOURCE 700
5  #endif
6  #include <fuse.h>
7  #include <stdio.h>
8  #include <string.h>
9  #include <unistd.h>
10  #include <fcntl.h>
11  #include <sys/stat.h>
12  #include <dirent.h>
13  #include <errno.h>
14  #ifdef __FreeBSD__
15  #include <sys/socket.h>
16  #include <sys/un.h>
17  #endif
18  #include <sys/time.h>
19  #ifdef HAVE_SETXATTR
20  #include <sys/xattr.h>
21  #endif
22  #include "passthrough_helpers.h"
23  static int fill_dir_plus = 0;
24  static void *xmp_init(struct fuse_conn_info *conn,
25  		      struct fuse_config *cfg)
26  {
27  	(void) conn;
28  	cfg->use_ino = 1;
29  	cfg->entry_timeout = 0;
30  	cfg->attr_timeout = 0;
31  	cfg->negative_timeout = 0;
32  	return NULL;
33  }
34  static int xmp_getattr(const char *path, struct stat *stbuf,
35  		       struct fuse_file_info *fi)
36  {
37  	(void) fi;
38  	int res;
39  	res = lstat(path, stbuf);
40  	if (res == -1)
41  		return -errno;
42  	return 0;
43  }
44  static int xmp_access(const char *path, int mask)
45  {
46  	int res;
47  	res = access(path, mask);
48  	if (res == -1)
49  		return -errno;
50  	return 0;
51  }
52  static int xmp_readlink(const char *path, char *buf, size_t size)
53  {
54  	int res;
55  	res = readlink(path, buf, size - 1);
56  	if (res == -1)
57  		return -errno;
58  	buf[res] = '\0';
59  	return 0;
60  }
61  static int xmp_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
62  		       off_t offset, struct fuse_file_info *fi,
63  		       enum fuse_readdir_flags flags)
64  {
65  	DIR *dp;
66  	struct dirent *de;
67  	(void) offset;
68  	(void) fi;
69  	(void) flags;
70  	dp = opendir(path);
71  	if (dp == NULL)
72  		return -errno;
73  	while ((de = readdir(dp)) != NULL) {
74  		struct stat st;
75  		memset(&st, 0, sizeof(st));
76  		st.st_ino = de->d_ino;
77  		st.st_mode = de->d_type << 12;
78  		if (filler(buf, de->d_name, &st, 0, fill_dir_plus))
79  			break;
<span onclick='openModal()' class='match'>80  	}
81  	closedir(dp);
82  	return 0;
83  }
84  static int xmp_mknod(const char *path, mode_t mode, dev_t rdev)
85  {
</span>86  	int res;
87  	res = mknod_wrapper(AT_FDCWD, path, NULL, mode, rdev);
88  	if (res == -1)
89  		return -errno;
90  	return 0;
91  }
92  static int xmp_mkdir(const char *path, mode_t mode)
93  {
94  	int res;
95  	res = mkdir(path, mode);
96  	if (res == -1)
97  		return -errno;
98  	return 0;
99  }
100  static int xmp_unlink(const char *path)
101  {
102  	int res;
103  	res = unlink(path);
104  	if (res == -1)
105  		return -errno;
106  	return 0;
107  }
108  static int xmp_rmdir(const char *path)
109  {
110  	int res;
111  	res = rmdir(path);
112  	if (res == -1)
113  		return -errno;
114  	return 0;
115  }
116  static int xmp_symlink(const char *from, const char *to)
117  {
118  	int res;
119  	res = symlink(from, to);
120  	if (res == -1)
121  		return -errno;
122  	return 0;
123  }
124  static int xmp_rename(const char *from, const char *to, unsigned int flags)
125  {
126  	int res;
127  	if (flags)
128  		return -EINVAL;
129  	res = rename(from, to);
130  	if (res == -1)
131  		return -errno;
132  	return 0;
133  }
134  static int xmp_link(const char *from, const char *to)
135  {
136  	int res;
137  	res = link(from, to);
138  	if (res == -1)
139  		return -errno;
140  	return 0;
141  }
142  static int xmp_chmod(const char *path, mode_t mode,
143  		     struct fuse_file_info *fi)
144  {
145  	(void) fi;
146  	int res;
147  	res = chmod(path, mode);
148  	if (res == -1)
149  		return -errno;
150  	return 0;
151  }
152  static int xmp_chown(const char *path, uid_t uid, gid_t gid,
153  		     struct fuse_file_info *fi)
154  {
155  	(void) fi;
156  	int res;
157  	res = lchown(path, uid, gid);
158  	if (res == -1)
159  		return -errno;
160  	return 0;
161  }
162  static int xmp_truncate(const char *path, off_t size,
163  			struct fuse_file_info *fi)
164  {
165  	int res;
166  	if (fi != NULL)
167  		res = ftruncate(fi->fh, size);
168  	else
169  		res = truncate(path, size);
170  	if (res == -1)
171  		return -errno;
172  	return 0;
173  }
174  #ifdef HAVE_UTIMENSAT
175  static int xmp_utimens(const char *path, const struct timespec ts[2],
176  		       struct fuse_file_info *fi)
177  {
178  	(void) fi;
179  	int res;
180  	res = utimensat(0, path, ts, AT_SYMLINK_NOFOLLOW);
181  	if (res == -1)
182  		return -errno;
183  	return 0;
184  }
185  #endif
186  static int xmp_create(const char *path, mode_t mode,
187  		      struct fuse_file_info *fi)
188  {
189  	int res;
190  	res = open(path, fi->flags, mode);
191  	if (res == -1)
192  		return -errno;
193  	fi->fh = res;
194  	return 0;
195  }
196  static int xmp_open(const char *path, struct fuse_file_info *fi)
197  {
198  	int res;
199  	res = open(path, fi->flags);
200  	if (res == -1)
201  		return -errno;
202  	fi->fh = res;
203  	return 0;
204  }
205  static int xmp_read(const char *path, char *buf, size_t size, off_t offset,
206  		    struct fuse_file_info *fi)
207  {
208  	int fd;
209  	int res;
210  	if(fi == NULL)
211  		fd = open(path, O_RDONLY);
212  	else
213  		fd = fi->fh;
214  	if (fd == -1)
215  		return -errno;
216  	res = pread(fd, buf, size, offset);
217  	if (res == -1)
218  		res = -errno;
219  	if(fi == NULL)
220  		close(fd);
221  	return res;
222  }
223  static int xmp_write(const char *path, const char *buf, size_t size,
224  		     off_t offset, struct fuse_file_info *fi)
225  {
226  	int fd;
227  	int res;
228  	(void) fi;
229  	if(fi == NULL)
230  		fd = open(path, O_WRONLY);
231  	else
232  		fd = fi->fh;
233  	if (fd == -1)
234  		return -errno;
235  	res = pwrite(fd, buf, size, offset);
236  	if (res == -1)
237  		res = -errno;
238  	if(fi == NULL)
239  		close(fd);
240  	return res;
241  }
242  static int xmp_statfs(const char *path, struct statvfs *stbuf)
243  {
244  	int res;
245  	res = statvfs(path, stbuf);
246  	if (res == -1)
247  		return -errno;
248  	return 0;
249  }
250  static int xmp_release(const char *path, struct fuse_file_info *fi)
251  {
252  	(void) path;
253  	close(fi->fh);
254  	return 0;
255  }
256  static int xmp_fsync(const char *path, int isdatasync,
257  		     struct fuse_file_info *fi)
258  {
259  	(void) path;
260  	(void) isdatasync;
261  	(void) fi;
262  	return 0;
263  }
264  #ifdef HAVE_POSIX_FALLOCATE
265  static int xmp_fallocate(const char *path, int mode,
266  			off_t offset, off_t length, struct fuse_file_info *fi)
267  {
268  	int fd;
269  	int res;
270  	(void) fi;
271  	if (mode)
272  		return -EOPNOTSUPP;
273  	if(fi == NULL)
274  		fd = open(path, O_WRONLY);
275  	else
276  		fd = fi->fh;
277  	if (fd == -1)
278  		return -errno;
279  	res = -posix_fallocate(fd, offset, length);
280  	if(fi == NULL)
281  		close(fd);
282  	return res;
283  }
284  #endif
285  #ifdef HAVE_SETXATTR
286  static int xmp_setxattr(const char *path, const char *name, const char *value,
287  			size_t size, int flags)
288  {
289  	int res = lsetxattr(path, name, value, size, flags);
290  	if (res == -1)
291  		return -errno;
292  	return 0;
293  }
294  static int xmp_getxattr(const char *path, const char *name, char *value,
295  			size_t size)
296  {
297  	int res = lgetxattr(path, name, value, size);
298  	if (res == -1)
299  		return -errno;
300  	return res;
301  }
302  static int xmp_listxattr(const char *path, char *list, size_t size)
303  {
304  	int res = llistxattr(path, list, size);
305  	if (res == -1)
306  		return -errno;
307  	return res;
308  }
309  static int xmp_removexattr(const char *path, const char *name)
310  {
311  	int res = lremovexattr(path, name);
312  	if (res == -1)
313  		return -errno;
314  	return 0;
315  }
316  #endif &bsol;* HAVE_SETXATTR */
317  #ifdef HAVE_COPY_FILE_RANGE
318  static ssize_t xmp_copy_file_range(const char *path_in,
319  				   struct fuse_file_info *fi_in,
320  				   off_t offset_in, const char *path_out,
321  				   struct fuse_file_info *fi_out,
322  				   off_t offset_out, size_t len, int flags)
323  {
324  	int fd_in, fd_out;
325  	ssize_t res;
326  	if(fi_in == NULL)
327  		fd_in = open(path_in, O_RDONLY);
328  	else
329  		fd_in = fi_in->fh;
330  	if (fd_in == -1)
331  		return -errno;
332  	if(fi_out == NULL)
333  		fd_out = open(path_out, O_WRONLY);
334  	else
335  		fd_out = fi_out->fh;
336  	if (fd_out == -1) {
337  		close(fd_in);
338  		return -errno;
339  	}
340  	res = copy_file_range(fd_in, &offset_in, fd_out, &offset_out, len,
341  			      flags);
342  	if (res == -1)
343  		res = -errno;
344  	if (fi_out == NULL)
345  		close(fd_out);
346  	if (fi_in == NULL)
347  		close(fd_in);
348  	return res;
349  }
350  #endif
351  static off_t xmp_lseek(const char *path, off_t off, int whence, struct fuse_file_info *fi)
352  {
353  	int fd;
354  	off_t res;
355  	if (fi == NULL)
356  		fd = open(path, O_RDONLY);
357  	else
358  		fd = fi->fh;
359  	if (fd == -1)
360  		return -errno;
361  	res = lseek(fd, off, whence);
362  	if (res == -1)
363  		res = -errno;
364  	if (fi == NULL)
365  		close(fd);
366  	return res;
367  }
368  static const struct fuse_operations xmp_oper = {
369  	.init           = xmp_init,
370  	.getattr	= xmp_getattr,
371  	.access		= xmp_access,
372  	.readlink	= xmp_readlink,
373  	.readdir	= xmp_readdir,
374  	.mknod		= xmp_mknod,
375  	.mkdir		= xmp_mkdir,
376  	.symlink	= xmp_symlink,
377  	.unlink		= xmp_unlink,
378  	.rmdir		= xmp_rmdir,
379  	.rename		= xmp_rename,
380  	.link		= xmp_link,
381  	.chmod		= xmp_chmod,
382  	.chown		= xmp_chown,
383  	.truncate	= xmp_truncate,
384  #ifdef HAVE_UTIMENSAT
385  	.utimens	= xmp_utimens,
386  #endif
387  	.open		= xmp_open,
388  	.create 	= xmp_create,
389  	.read		= xmp_read,
390  	.write		= xmp_write,
391  	.statfs		= xmp_statfs,
392  	.release	= xmp_release,
393  	.fsync		= xmp_fsync,
394  #ifdef HAVE_POSIX_FALLOCATE
395  	.fallocate	= xmp_fallocate,
396  #endif
397  #ifdef HAVE_SETXATTR
398  	.setxattr	= xmp_setxattr,
399  	.getxattr	= xmp_getxattr,
400  	.listxattr	= xmp_listxattr,
401  	.removexattr	= xmp_removexattr,
402  #endif
403  #ifdef HAVE_COPY_FILE_RANGE
404  	.copy_file_range = xmp_copy_file_range,
405  #endif
406  	.lseek		= xmp_lseek,
407  };
408  int main(int argc, char *argv[])
409  {
410  	enum { MAX_ARGS = 10 };
411  	int i,new_argc;
412  	char *new_argv[MAX_ARGS];
413  	umask(0);
414  	for (i=0, new_argc=0; (i<argc) && (new_argc<MAX_ARGS); i++) {
415  		if (!strcmp(argv[i], "--plus")) {
416  			fill_dir_plus = FUSE_FILL_DIR_PLUS;
417  		} else {
418  			new_argv[new_argc++] = argv[i];
419  		}
420  	}
421  	return fuse_main(new_argc, new_argv, &xmp_oper, NULL);
422  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-io_dec.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include "src/dec/vp8i_dec.h"
4  #include "src/dec/webpi_dec.h"
5  #include "src/dsp/dsp.h"
6  #include "src/dsp/yuv.h"
7  #include "src/utils/utils.h"
8  static int EmitYUV(const VP8Io* const io, WebPDecParams* const p) {
9    WebPDecBuffer* output = p->output;
10    const WebPYUVABuffer* const buf = &output->u.YUVA;
11    uint8_t* const y_dst = buf->y + io->mb_y * buf->y_stride;
12    uint8_t* const u_dst = buf->u + (io->mb_y >> 1) * buf->u_stride;
13    uint8_t* const v_dst = buf->v + (io->mb_y >> 1) * buf->v_stride;
14    const int mb_w = io->mb_w;
15    const int mb_h = io->mb_h;
16    const int uv_w = (mb_w + 1) / 2;
17    const int uv_h = (mb_h + 1) / 2;
18    int j;
19    for (j = 0; j < mb_h; ++j) {
20      memcpy(y_dst + j * buf->y_stride, io->y + j * io->y_stride, mb_w);
21    }
22    for (j = 0; j < uv_h; ++j) {
23      memcpy(u_dst + j * buf->u_stride, io->u + j * io->uv_stride, uv_w);
24      memcpy(v_dst + j * buf->v_stride, io->v + j * io->uv_stride, uv_w);
25    }
26    return io->mb_h;
27  }
28  static int EmitSampledRGB(const VP8Io* const io, WebPDecParams* const p) {
29    WebPDecBuffer* const output = p->output;
30    WebPRGBABuffer* const buf = &output->u.RGBA;
31    uint8_t* const dst = buf->rgba + io->mb_y * buf->stride;
32    WebPSamplerProcessPlane(io->y, io->y_stride,
33                            io->u, io->v, io->uv_stride,
34                            dst, buf->stride, io->mb_w, io->mb_h,
35                            WebPSamplers[output->colorspace]);
36    return io->mb_h;
37  }
38  #ifdef FANCY_UPSAMPLING
39  static int EmitFancyRGB(const VP8Io* const io, WebPDecParams* const p) {
40    int num_lines_out = io->mb_h;   
41    const WebPRGBABuffer* const buf = &p->output->u.RGBA;
42    uint8_t* dst = buf->rgba + io->mb_y * buf->stride;
43    WebPUpsampleLinePairFunc upsample = WebPUpsamplers[p->output->colorspace];
44    const uint8_t* cur_y = io->y;
45    const uint8_t* cur_u = io->u;
46    const uint8_t* cur_v = io->v;
47    const uint8_t* top_u = p->tmp_u;
48    const uint8_t* top_v = p->tmp_v;
49    int y = io->mb_y;
50    const int y_end = io->mb_y + io->mb_h;
51    const int mb_w = io->mb_w;
52    const int uv_w = (mb_w + 1) / 2;
53    if (y == 0) {
54      upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, mb_w);
55    } else {
56      upsample(p->tmp_y, cur_y, top_u, top_v, cur_u, cur_v,
57               dst - buf->stride, dst, mb_w);
58      ++num_lines_out;
59    }
60    for (; y + 2 < y_end; y += 2) {
61      top_u = cur_u;
62      top_v = cur_v;
63      cur_u += io->uv_stride;
64      cur_v += io->uv_stride;
65      dst += 2 * buf->stride;
66      cur_y += 2 * io->y_stride;
67      upsample(cur_y - io->y_stride, cur_y,
68               top_u, top_v, cur_u, cur_v,
69               dst - buf->stride, dst, mb_w);
70    }
71    cur_y += io->y_stride;
72    if (io->crop_top + y_end < io->crop_bottom) {
73      memcpy(p->tmp_y, cur_y, mb_w * sizeof(*p->tmp_y));
74      memcpy(p->tmp_u, cur_u, uv_w * sizeof(*p->tmp_u));
75      memcpy(p->tmp_v, cur_v, uv_w * sizeof(*p->tmp_v));
76      num_lines_out--;
77    } else {
78      if (!(y_end & 1)) {
79        upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v,
80                 dst + buf->stride, NULL, mb_w);
81      }
82    }
83    return num_lines_out;
84  }
85  #endif    &bsol;* FANCY_UPSAMPLING */
86  static void FillAlphaPlane(uint8_t* dst, int w, int h, int stride) {
87    int j;
88    for (j = 0; j < h; ++j) {
89      memset(dst, 0xff, w * sizeof(*dst));
90      dst += stride;
91    }
92  }
93  static int EmitAlphaYUV(const VP8Io* const io, WebPDecParams* const p,
94                          int expected_num_lines_out) {
95    const uint8_t* alpha = io->a;
96    const WebPYUVABuffer* const buf = &p->output->u.YUVA;
97    const int mb_w = io->mb_w;
98    const int mb_h = io->mb_h;
99    uint8_t* dst = buf->a + io->mb_y * buf->a_stride;
100    int j;
101    (void)expected_num_lines_out;
102    assert(expected_num_lines_out == mb_h);
103    if (alpha != NULL) {
104      for (j = 0; j < mb_h; ++j) {
105        memcpy(dst, alpha, mb_w * sizeof(*dst));
106        alpha += io->width;
107        dst += buf->a_stride;
108      }
109    } else if (buf->a != NULL) {
110      FillAlphaPlane(dst, mb_w, mb_h, buf->a_stride);
111    }
112    return 0;
113  }
114  static int GetAlphaSourceRow(const VP8Io* const io,
115                               const uint8_t** alpha, int* const num_rows) {
116    int start_y = io->mb_y;
117    *num_rows = io->mb_h;
118    if (io->fancy_upsampling) {
119      if (start_y == 0) {
120        --*num_rows;
121      } else {
122        --start_y;
123        *alpha -= io->width;
124      }
125      if (io->crop_top + io->mb_y + io->mb_h == io->crop_bottom) {
126        *num_rows = io->crop_bottom - io->crop_top - start_y;
127      }
128    }
129    return start_y;
130  }
131  static int EmitAlphaRGB(const VP8Io* const io, WebPDecParams* const p,
132                          int expected_num_lines_out) {
133    const uint8_t* alpha = io->a;
134    if (alpha != NULL) {
135      const int mb_w = io->mb_w;
136      const WEBP_CSP_MODE colorspace = p->output->colorspace;
137      const int alpha_first =
138          (colorspace == MODE_ARGB || colorspace == MODE_Argb);
139      const WebPRGBABuffer* const buf = &p->output->u.RGBA;
140      int num_rows;
141      const int start_y = GetAlphaSourceRow(io, &alpha, &num_rows);
142      uint8_t* const base_rgba = buf->rgba + start_y * buf->stride;
143      uint8_t* const dst = base_rgba + (alpha_first ? 0 : 3);
144      const int has_alpha = WebPDispatchAlpha(alpha, io->width, mb_w,
145                                              num_rows, dst, buf->stride);
146      (void)expected_num_lines_out;
147      assert(expected_num_lines_out == num_rows);
148      if (has_alpha && WebPIsPremultipliedMode(colorspace)) {
149        WebPApplyAlphaMultiply(base_rgba, alpha_first,
150                               mb_w, num_rows, buf->stride);
151      }
152    }
153    return 0;
154  }
155  static int EmitAlphaRGBA4444(const VP8Io* const io, WebPDecParams* const p,
156                               int expected_num_lines_out) {
157    const uint8_t* alpha = io->a;
158    if (alpha != NULL) {
159      const int mb_w = io->mb_w;
160      const WEBP_CSP_MODE colorspace = p->output->colorspace;
161      const WebPRGBABuffer* const buf = &p->output->u.RGBA;
162      int num_rows;
163      const int start_y = GetAlphaSourceRow(io, &alpha, &num_rows);
164      uint8_t* const base_rgba = buf->rgba + start_y * buf->stride;
165  #if (WEBP_SWAP_16BIT_CSP == 1)
166      uint8_t* alpha_dst = base_rgba;
167  #else
168      uint8_t* alpha_dst = base_rgba + 1;
169  #endif
170      uint32_t alpha_mask = 0x0f;
171      int i, j;
172      for (j = 0; j < num_rows; ++j) {
173        for (i = 0; i < mb_w; ++i) {
174          const uint32_t alpha_value = alpha[i] >> 4;
175          alpha_dst[2 * i] = (alpha_dst[2 * i] & 0xf0) | alpha_value;
176          alpha_mask &= alpha_value;
177        }
178        alpha += io->width;
179        alpha_dst += buf->stride;
180      }
181      (void)expected_num_lines_out;
182      assert(expected_num_lines_out == num_rows);
183      if (alpha_mask != 0x0f && WebPIsPremultipliedMode(colorspace)) {
184        WebPApplyAlphaMultiply4444(base_rgba, mb_w, num_rows, buf->stride);
185      }
186    }
187    return 0;
188  }
189  #if !defined(WEBP_REDUCE_SIZE)
190  static int Rescale(const uint8_t* src, int src_stride,
191                     int new_lines, WebPRescaler* const wrk) {
192    int num_lines_out = 0;
193    while (new_lines > 0) {    
194      const int lines_in = WebPRescalerImport(wrk, new_lines, src, src_stride);
195      src += lines_in * src_stride;
196      new_lines -= lines_in;
197      num_lines_out += WebPRescalerExport(wrk);    
198    }
199    return num_lines_out;
200  }
201  static int EmitRescaledYUV(const VP8Io* const io, WebPDecParams* const p) {
202    const int mb_h = io->mb_h;
203    const int uv_mb_h = (mb_h + 1) >> 1;
204    WebPRescaler* const scaler = p->scaler_y;
205    int num_lines_out = 0;
206    if (WebPIsAlphaMode(p->output->colorspace) && io->a != NULL) {
207      WebPMultRows((uint8_t*)io->y, io->y_stride,
208                   io->a, io->width, io->mb_w, mb_h, 0);
209    }
210    num_lines_out = Rescale(io->y, io->y_stride, mb_h, scaler);
211    Rescale(io->u, io->uv_stride, uv_mb_h, p->scaler_u);
212    Rescale(io->v, io->uv_stride, uv_mb_h, p->scaler_v);
213    return num_lines_out;
214  }
215  static int EmitRescaledAlphaYUV(const VP8Io* const io, WebPDecParams* const p,
216                                  int expected_num_lines_out) {
217    const WebPYUVABuffer* const buf = &p->output->u.YUVA;
218    uint8_t* const dst_a = buf->a + p->last_y * buf->a_stride;
219    if (io->a != NULL) {
220      uint8_t* const dst_y = buf->y + p->last_y * buf->y_stride;
221      const int num_lines_out = Rescale(io->a, io->width, io->mb_h, p->scaler_a);
222      assert(expected_num_lines_out == num_lines_out);
223      if (num_lines_out > 0) {   
224        WebPMultRows(dst_y, buf->y_stride, dst_a, buf->a_stride,
225                     p->scaler_a->dst_width, num_lines_out, 1);
226      }
227    } else if (buf->a != NULL) {
228      assert(p->last_y + expected_num_lines_out <= io->scaled_height);
229      FillAlphaPlane(dst_a, io->scaled_width, expected_num_lines_out,
230                     buf->a_stride);
231    }
232    return 0;
233  }
234  static int InitYUVRescaler(const VP8Io* const io, WebPDecParams* const p) {
235    const int has_alpha = WebPIsAlphaMode(p->output->colorspace);
236    const WebPYUVABuffer* const buf = &p->output->u.YUVA;
237    const int out_width  = io->scaled_width;
238    const int out_height = io->scaled_height;
239    const int uv_out_width  = (out_width + 1) >> 1;
240    const int uv_out_height = (out_height + 1) >> 1;
241    const int uv_in_width  = (io->mb_w + 1) >> 1;
242    const int uv_in_height = (io->mb_h + 1) >> 1;
243    const size_t work_size = 2 * out_width;   
244    const size_t uv_work_size = 2 * uv_out_width;  
245    size_t tmp_size, rescaler_size;
246    rescaler_t* work;
247    WebPRescaler* scalers;
248    const int num_rescalers = has_alpha ? 4 : 3;
249    tmp_size = (work_size + 2 * uv_work_size) * sizeof(*work);
250    if (has_alpha) {
251      tmp_size += work_size * sizeof(*work);
252    }
253    rescaler_size = num_rescalers * sizeof(*p->scaler_y) + WEBP_ALIGN_CST;
254    p->memory = WebPSafeMalloc(1ULL, tmp_size + rescaler_size);
255    if (p->memory == NULL) {
256      return 0;   
257    }
258    work = (rescaler_t*)p->memory;
259    scalers = (WebPRescaler*)WEBP_ALIGN((const uint8_t*)work + tmp_size);
260    p->scaler_y = &scalers[0];
261    p->scaler_u = &scalers[1];
262    p->scaler_v = &scalers[2];
263    p->scaler_a = has_alpha ? &scalers[3] : NULL;
264    WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h,
265                     buf->y, out_width, out_height, buf->y_stride, 1,
266                     work);
267    WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height,
268                     buf->u, uv_out_width, uv_out_height, buf->u_stride, 1,
269                     work + work_size);
270    WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height,
271                     buf->v, uv_out_width, uv_out_height, buf->v_stride, 1,
272                     work + work_size + uv_work_size);
273    p->emit = EmitRescaledYUV;
274    if (has_alpha) {
275      WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h,
276                       buf->a, out_width, out_height, buf->a_stride, 1,
277                       work + work_size + 2 * uv_work_size);
278      p->emit_alpha = EmitRescaledAlphaYUV;
279      WebPInitAlphaProcessing();
<span onclick='openModal()' class='match'>280    }
281    return 1;
282  }
283  static int ExportRGB(WebPDecParams* const p, int y_pos) {
</span>284    const WebPYUV444Converter convert =
285        WebPYUV444Converters[p->output->colorspace];
286    const WebPRGBABuffer* const buf = &p->output->u.RGBA;
287    uint8_t* dst = buf->rgba + y_pos * buf->stride;
288    int num_lines_out = 0;
289    while (WebPRescalerHasPendingOutput(p->scaler_y) &&
290           WebPRescalerHasPendingOutput(p->scaler_u)) {
291      assert(y_pos + num_lines_out < p->output->height);
292      assert(p->scaler_u->y_accum == p->scaler_v->y_accum);
293      WebPRescalerExportRow(p->scaler_y);
294      WebPRescalerExportRow(p->scaler_u);
295      WebPRescalerExportRow(p->scaler_v);
296      convert(p->scaler_y->dst, p->scaler_u->dst, p->scaler_v->dst,
297              dst, p->scaler_y->dst_width);
298      dst += buf->stride;
299      ++num_lines_out;
300    }
301    return num_lines_out;
302  }
303  static int EmitRescaledRGB(const VP8Io* const io, WebPDecParams* const p) {
304    const int mb_h = io->mb_h;
305    const int uv_mb_h = (mb_h + 1) >> 1;
306    int j = 0, uv_j = 0;
307    int num_lines_out = 0;
308    while (j < mb_h) {
309      const int y_lines_in =
310          WebPRescalerImport(p->scaler_y, mb_h - j,
311                             io->y + j * io->y_stride, io->y_stride);
312      j += y_lines_in;
313      if (WebPRescaleNeededLines(p->scaler_u, uv_mb_h - uv_j)) {
314        const int u_lines_in =
315            WebPRescalerImport(p->scaler_u, uv_mb_h - uv_j,
316                               io->u + uv_j * io->uv_stride, io->uv_stride);
317        const int v_lines_in =
318            WebPRescalerImport(p->scaler_v, uv_mb_h - uv_j,
319                               io->v + uv_j * io->uv_stride, io->uv_stride);
320        (void)v_lines_in;   
321        assert(u_lines_in == v_lines_in);
322        uv_j += u_lines_in;
323      }
324      num_lines_out += ExportRGB(p, p->last_y + num_lines_out);
325    }
326    return num_lines_out;
327  }
328  static int ExportAlpha(WebPDecParams* const p, int y_pos, int max_lines_out) {
329    const WebPRGBABuffer* const buf = &p->output->u.RGBA;
330    uint8_t* const base_rgba = buf->rgba + y_pos * buf->stride;
331    const WEBP_CSP_MODE colorspace = p->output->colorspace;
332    const int alpha_first =
333        (colorspace == MODE_ARGB || colorspace == MODE_Argb);
334    uint8_t* dst = base_rgba + (alpha_first ? 0 : 3);
335    int num_lines_out = 0;
336    const int is_premult_alpha = WebPIsPremultipliedMode(colorspace);
337    uint32_t non_opaque = 0;
338    const int width = p->scaler_a->dst_width;
339    while (WebPRescalerHasPendingOutput(p->scaler_a) &&
340           num_lines_out < max_lines_out) {
341      assert(y_pos + num_lines_out < p->output->height);
342      WebPRescalerExportRow(p->scaler_a);
343      non_opaque |= WebPDispatchAlpha(p->scaler_a->dst, 0, width, 1, dst, 0);
344      dst += buf->stride;
345      ++num_lines_out;
346    }
347    if (is_premult_alpha && non_opaque) {
348      WebPApplyAlphaMultiply(base_rgba, alpha_first,
349                             width, num_lines_out, buf->stride);
350    }
351    return num_lines_out;
352  }
353  static int ExportAlphaRGBA4444(WebPDecParams* const p, int y_pos,
354                                 int max_lines_out) {
355    const WebPRGBABuffer* const buf = &p->output->u.RGBA;
356    uint8_t* const base_rgba = buf->rgba + y_pos * buf->stride;
357  #if (WEBP_SWAP_16BIT_CSP == 1)
358    uint8_t* alpha_dst = base_rgba;
359  #else
360    uint8_t* alpha_dst = base_rgba + 1;
361  #endif
362    int num_lines_out = 0;
363    const WEBP_CSP_MODE colorspace = p->output->colorspace;
364    const int width = p->scaler_a->dst_width;
365    const int is_premult_alpha = WebPIsPremultipliedMode(colorspace);
366    uint32_t alpha_mask = 0x0f;
367    while (WebPRescalerHasPendingOutput(p->scaler_a) &&
368           num_lines_out < max_lines_out) {
369      int i;
370      assert(y_pos + num_lines_out < p->output->height);
371      WebPRescalerExportRow(p->scaler_a);
372      for (i = 0; i < width; ++i) {
373        const uint32_t alpha_value = p->scaler_a->dst[i] >> 4;
374        alpha_dst[2 * i] = (alpha_dst[2 * i] & 0xf0) | alpha_value;
375        alpha_mask &= alpha_value;
376      }
377      alpha_dst += buf->stride;
378      ++num_lines_out;
379    }
380    if (is_premult_alpha && alpha_mask != 0x0f) {
381      WebPApplyAlphaMultiply4444(base_rgba, width, num_lines_out, buf->stride);
382    }
383    return num_lines_out;
384  }
385  static int EmitRescaledAlphaRGB(const VP8Io* const io, WebPDecParams* const p,
386                                  int expected_num_out_lines) {
387    if (io->a != NULL) {
388      WebPRescaler* const scaler = p->scaler_a;
389      int lines_left = expected_num_out_lines;
390      const int y_end = p->last_y + lines_left;
391      while (lines_left > 0) {
392        const int row_offset = scaler->src_y - io->mb_y;
393        WebPRescalerImport(scaler, io->mb_h + io->mb_y - scaler->src_y,
394                           io->a + row_offset * io->width, io->width);
395        lines_left -= p->emit_alpha_row(p, y_end - lines_left, lines_left);
396      }
397    }
398    return 0;
399  }
400  static int InitRGBRescaler(const VP8Io* const io, WebPDecParams* const p) {
401    const int has_alpha = WebPIsAlphaMode(p->output->colorspace);
402    const int out_width  = io->scaled_width;
403    const int out_height = io->scaled_height;
404    const int uv_in_width  = (io->mb_w + 1) >> 1;
405    const int uv_in_height = (io->mb_h + 1) >> 1;
406    const size_t work_size = 2 * out_width;   
407    rescaler_t* work;  
408    uint8_t* tmp;   
409    size_t tmp_size1, tmp_size2, total_size, rescaler_size;
410    WebPRescaler* scalers;
411    const int num_rescalers = has_alpha ? 4 : 3;
412    tmp_size1 = 3 * work_size;
413    tmp_size2 = 3 * out_width;
414    if (has_alpha) {
415      tmp_size1 += work_size;
416      tmp_size2 += out_width;
417    }
418    total_size = tmp_size1 * sizeof(*work) + tmp_size2 * sizeof(*tmp);
419    rescaler_size = num_rescalers * sizeof(*p->scaler_y) + WEBP_ALIGN_CST;
420    p->memory = WebPSafeMalloc(1ULL, total_size + rescaler_size);
421    if (p->memory == NULL) {
422      return 0;   
423    }
424    work = (rescaler_t*)p->memory;
425    tmp = (uint8_t*)(work + tmp_size1);
426    scalers = (WebPRescaler*)WEBP_ALIGN((const uint8_t*)work + total_size);
427    p->scaler_y = &scalers[0];
428    p->scaler_u = &scalers[1];
429    p->scaler_v = &scalers[2];
430    p->scaler_a = has_alpha ? &scalers[3] : NULL;
431    WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h,
432                     tmp + 0 * out_width, out_width, out_height, 0, 1,
433                     work + 0 * work_size);
434    WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height,
435                     tmp + 1 * out_width, out_width, out_height, 0, 1,
436                     work + 1 * work_size);
437    WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height,
438                     tmp + 2 * out_width, out_width, out_height, 0, 1,
439                     work + 2 * work_size);
440    p->emit = EmitRescaledRGB;
441    WebPInitYUV444Converters();
442    if (has_alpha) {
443      WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h,
444                       tmp + 3 * out_width, out_width, out_height, 0, 1,
445                       work + 3 * work_size);
446      p->emit_alpha = EmitRescaledAlphaRGB;
447      if (p->output->colorspace == MODE_RGBA_4444 ||
448          p->output->colorspace == MODE_rgbA_4444) {
449        p->emit_alpha_row = ExportAlphaRGBA4444;
450      } else {
451        p->emit_alpha_row = ExportAlpha;
452      }
453      WebPInitAlphaProcessing();
454    }
455    return 1;
456  }
457  #endif  
458  static int CustomSetup(VP8Io* io) {
459    WebPDecParams* const p = (WebPDecParams*)io->opaque;
460    const WEBP_CSP_MODE colorspace = p->output->colorspace;
461    const int is_rgb = WebPIsRGBMode(colorspace);
462    const int is_alpha = WebPIsAlphaMode(colorspace);
463    p->memory = NULL;
464    p->emit = NULL;
465    p->emit_alpha = NULL;
466    p->emit_alpha_row = NULL;
467    if (!WebPIoInitFromOptions(p->options, io, is_alpha ? MODE_YUV : MODE_YUVA)) {
468      return 0;
469    }
470    if (is_alpha && WebPIsPremultipliedMode(colorspace)) {
471      WebPInitUpsamplers();
472    }
473    if (io->use_scaling) {
474  #if !defined(WEBP_REDUCE_SIZE)
475      const int ok = is_rgb ? InitRGBRescaler(io, p) : InitYUVRescaler(io, p);
476      if (!ok) {
477        return 0;    
478      }
479  #else
480      return 0;   
481  #endif
482    } else {
483      if (is_rgb) {
484        WebPInitSamplers();
485        p->emit = EmitSampledRGB;   
486        if (io->fancy_upsampling) {
487  #ifdef FANCY_UPSAMPLING
488          const int uv_width = (io->mb_w + 1) >> 1;
489          p->memory = WebPSafeMalloc(1ULL, (size_t)(io->mb_w + 2 * uv_width));
490          if (p->memory == NULL) {
491            return 0;   
492          }
493          p->tmp_y = (uint8_t*)p->memory;
494          p->tmp_u = p->tmp_y + io->mb_w;
495          p->tmp_v = p->tmp_u + uv_width;
496          p->emit = EmitFancyRGB;
497          WebPInitUpsamplers();
498  #endif
499        }
500      } else {
501        p->emit = EmitYUV;
502      }
503      if (is_alpha) {  
504        p->emit_alpha =
505            (colorspace == MODE_RGBA_4444 || colorspace == MODE_rgbA_4444) ?
506                EmitAlphaRGBA4444
507            : is_rgb ? EmitAlphaRGB
508            : EmitAlphaYUV;
509        if (is_rgb) {
510          WebPInitAlphaProcessing();
511        }
512      }
513    }
514    return 1;
515  }
516  static int CustomPut(const VP8Io* io) {
517    WebPDecParams* const p = (WebPDecParams*)io->opaque;
518    const int mb_w = io->mb_w;
519    const int mb_h = io->mb_h;
520    int num_lines_out;
521    assert(!(io->mb_y & 1));
522    if (mb_w <= 0 || mb_h <= 0) {
523      return 0;
524    }
525    num_lines_out = p->emit(io, p);
526    if (p->emit_alpha != NULL) {
527      p->emit_alpha(io, p, num_lines_out);
528    }
529    p->last_y += num_lines_out;
530    return 1;
531  }
532  static void CustomTeardown(const VP8Io* io) {
533    WebPDecParams* const p = (WebPDecParams*)io->opaque;
534    WebPSafeFree(p->memory);
535    p->memory = NULL;
536  }
537  void WebPInitCustomIo(WebPDecParams* const params, VP8Io* const io) {
538    io->put      = CustomPut;
539    io->setup    = CustomSetup;
540    io->teardown = CustomTeardown;
541    io->opaque   = params;
542  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-io_dec.c</div>
                </div>
                <div class="column column_space"><pre><code>80  	}
81  	closedir(dp);
82  	return 0;
83  }
84  static int xmp_mknod(const char *path, mode_t mode, dev_t rdev)
85  {
</pre></code></div>
                <div class="column column_space"><pre><code>280    }
281    return 1;
282  }
283  static int ExportRGB(WebPDecParams* const p, int y_pos) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    