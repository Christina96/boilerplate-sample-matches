
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 31.12391930835735%, Tokens: 10</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_verify_hash.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MECC
3  int ecc_verify_hash_ex(const unsigned char *sig,  unsigned long siglen,
4                         const unsigned char *hash, unsigned long hashlen,
5                         ecc_signature_type sigformat, int *stat, const ecc_key *key)
6  {
7     ecc_point     *mG = NULL, *mQ = NULL;
8     void          *r, *s, *v, *w, *u1, *u2, *e, *p, *m, *a, *a_plus3;
9     void          *mu = NULL, *ma = NULL;
10     void          *mp = NULL;
11     int           err;
12     unsigned long pbits, pbytes, i, shift_right;
13     unsigned char ch, buf[MAXBLOCKSIZE];
14     LTC_ARGCHK(sig  != NULL);
15     LTC_ARGCHK(hash != NULL);
16     LTC_ARGCHK(stat != NULL);
17     LTC_ARGCHK(key  != NULL);
18     *stat = 0;
19     if ((err = mp_init_multi(&r, &s, &v, &w, &u1, &u2, &e, &a_plus3, LTC_NULL)) != CRYPT_OK) {
20        return err;
21     }
22     p = key->dp.order;
23     m = key->dp.prime;
24     a = key->dp.A;
25     if ((err = mp_add_d(a, 3, a_plus3)) != CRYPT_OK) {
26        goto error;
27     }
28     mG = ltc_ecc_new_point();
29     mQ = ltc_ecc_new_point();
30     if (mQ  == NULL || mG == NULL) {
31        err = CRYPT_MEM;
<span onclick='openModal()' class='match'>32        goto error;
33     }
34     if (sigformat == LTC_ECCSIG_ANSIX962) {
35        if ((err = der_decode_sequence_multi_ex(sig, siglen, LTC_DER_SEQ_SEQUENCE | LTC_DER_SEQ_STRICT,
36                                       LTC_ASN1_INTEGER, 1UL, r,
37                                       LTC_ASN1_INTEGER, 1UL, s,
38                                       LTC_ASN1_EOL, 0UL, LTC_NULL)) != CRYPT_OK)                         { goto error; }
39     }
</span>40     else if (sigformat == LTC_ECCSIG_RFC7518) {
41        i = mp_unsigned_bin_size(key->dp.order);
42        if (siglen != (2 * i)) {
43           err = CRYPT_INVALID_PACKET;
44           goto error;
45        }
46        if ((err = mp_read_unsigned_bin(r, (unsigned char *)sig,   i)) != CRYPT_OK)                       { goto error; }
47        if ((err = mp_read_unsigned_bin(s, (unsigned char *)sig+i, i)) != CRYPT_OK)                       { goto error; }
48     }
49     else if (sigformat == LTC_ECCSIG_ETH27) {
50        if (pk_oid_cmp_with_ulong("1.3.132.0.10", key->dp.oid, key->dp.oidlen) != CRYPT_OK) {
51           err = CRYPT_ERROR; goto error;
52        }
53        if (siglen != 65) { &bsol;* Only secp256k1 curves use this format, so must be 65 bytes long */
54           err = CRYPT_INVALID_PACKET;
55           goto error;
56        }
57        if ((err = mp_read_unsigned_bin(r, (unsigned char *)sig,  32)) != CRYPT_OK)                       { goto error; }
58        if ((err = mp_read_unsigned_bin(s, (unsigned char *)sig+32, 32)) != CRYPT_OK)                     { goto error; }
59     }
60  #ifdef LTC_SSH
61     else if (sigformat == LTC_ECCSIG_RFC5656) {
62        char name[64], name2[64];
63        unsigned long namelen = sizeof(name);
64        unsigned long name2len = sizeof(name2);
65        if ((err = ssh_decode_sequence_multi(sig, &siglen,
66                                             LTC_SSHDATA_STRING, name, &namelen,
67                                             LTC_SSHDATA_MPINT,  r,
68                                             LTC_SSHDATA_MPINT,  s,
69                                             LTC_SSHDATA_EOL,    NULL)) != CRYPT_OK)                      { goto error; }
70        if ((err = ecc_ssh_ecdsa_encode_name(name2, &name2len, key)) != CRYPT_OK)                         { goto error; }
71        if ((namelen != name2len) || (XSTRCMP(name, name2) != 0)) {
72           err = CRYPT_INVALID_ARG;
73           goto error;
74        }
75     }
76  #endif
77     else {
78        err = CRYPT_ERROR;
79        goto error;
80     }
81     if (mp_cmp_d(r, 0) != LTC_MP_GT || mp_cmp_d(s, 0) != LTC_MP_GT ||
82         mp_cmp(r, p) != LTC_MP_LT || mp_cmp(s, p) != LTC_MP_LT) {
83        err = CRYPT_INVALID_PACKET;
84        goto error;
85     }
86     pbits = mp_count_bits(p);
87     pbytes = (pbits+7) >> 3;
88     if (pbits > hashlen*8) {
89        if ((err = mp_read_unsigned_bin(e, (unsigned char *)hash, hashlen)) != CRYPT_OK)                  { goto error; }
90     }
91     else if (pbits % 8 == 0) {
92        if ((err = mp_read_unsigned_bin(e, (unsigned char *)hash, pbytes)) != CRYPT_OK)                   { goto error; }
93     }
94     else {
95        shift_right = 8 - pbits % 8;
96        for (i=0, ch=0; i<pbytes; i++) {
97          buf[i] = ch;
98          ch = (hash[i] << (8-shift_right));
99          buf[i] = buf[i] ^ (hash[i] >> shift_right);
100        }
101        if ((err = mp_read_unsigned_bin(e, (unsigned char *)buf, pbytes)) != CRYPT_OK)                    { goto error; }
102     }
103     if ((err = mp_invmod(s, p, w)) != CRYPT_OK)                                                          { goto error; }
104     if ((err = mp_mulmod(e, w, p, u1)) != CRYPT_OK)                                                      { goto error; }
105     if ((err = mp_mulmod(r, w, p, u2)) != CRYPT_OK)                                                      { goto error; }
106     if ((err = ltc_ecc_copy_point(&key->dp.base, mG)) != CRYPT_OK)                                       { goto error; }
107     if ((err = ltc_ecc_copy_point(&key->pubkey, mQ)) != CRYPT_OK)                                        { goto error; }
108     if ((err = mp_montgomery_setup(m, &mp)) != CRYPT_OK)                                                 { goto error; }
109     if (mp_cmp(a_plus3, m) != LTC_MP_EQ) {
110        if ((err = mp_init_multi(&mu, &ma, LTC_NULL)) != CRYPT_OK)                                        { goto error; }
111        if ((err = mp_montgomery_normalization(mu, m)) != CRYPT_OK)                                       { goto error; }
112        if ((err = mp_mulmod(a, mu, m, ma)) != CRYPT_OK)                                                  { goto error; }
113     }
114     if (ltc_mp.ecc_mul2add == NULL) {
115        if ((err = ltc_mp.ecc_ptmul(u1, mG, mG, a, m, 0)) != CRYPT_OK)                                    { goto error; }
116        if ((err = ltc_mp.ecc_ptmul(u2, mQ, mQ, a, m, 0)) != CRYPT_OK)                                    { goto error; }
117        if ((err = ltc_mp.ecc_ptadd(mQ, mG, mG, ma, m, mp)) != CRYPT_OK)                                  { goto error; }
118        if ((err = ltc_mp.ecc_map(mG, m, mp)) != CRYPT_OK)                                                { goto error; }
119     } else {
120        if ((err = ltc_mp.ecc_mul2add(mG, u1, mQ, u2, mG, ma, m)) != CRYPT_OK)                            { goto error; }
121     }
122     if ((err = mp_mod(mG->x, p, v)) != CRYPT_OK)                                                         { goto error; }
123     if (mp_cmp(v, r) == LTC_MP_EQ) {
124        *stat = 1;
125     }
126     err = CRYPT_OK;
127  error:
128     if (mG != NULL) ltc_ecc_del_point(mG);
129     if (mQ != NULL) ltc_ecc_del_point(mQ);
130     if (mu != NULL) mp_clear(mu);
131     if (ma != NULL) mp_clear(ma);
132     mp_clear_multi(r, s, v, w, u1, u2, e, a_plus3, LTC_NULL);
133     if (mp != NULL) mp_montgomery_free(mp);
134     return err;
135  }
136  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltc_ecc_projective_add_point.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #if defined(LTC_MECC) && (!defined(LTC_MECC_ACCEL) || defined(LTM_DESC))
3  int ltc_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *mp)
4  {
5     void  *t1, *t2, *x, *y, *z;
6     int    err, inf;
7     LTC_ARGCHK(P       != NULL);
8     LTC_ARGCHK(Q       != NULL);
9     LTC_ARGCHK(R       != NULL);
10     LTC_ARGCHK(modulus != NULL);
11     LTC_ARGCHK(mp      != NULL);
12     if ((err = mp_init_multi(&t1, &t2, &x, &y, &z, LTC_NULL)) != CRYPT_OK) {
13        return err;
14     }
15     if ((err = ltc_ecc_is_point_at_infinity(P, modulus, &inf)) != CRYPT_OK) return err;
16     if (inf) {
17        err = ltc_ecc_copy_point(Q, R);
18        goto done;
19     }
20     if ((err = ltc_ecc_is_point_at_infinity(Q, modulus, &inf)) != CRYPT_OK) return err;
21     if (inf) {
22        err = ltc_ecc_copy_point(P, R);
23        goto done;
24     }
25     if ((mp_cmp(P->x, Q->x) == LTC_MP_EQ) && (mp_cmp(P->z, Q->z) == LTC_MP_EQ)) {
26        if (mp_cmp(P->y, Q->y) == LTC_MP_EQ) {
27           mp_clear_multi(t1, t2, x, y, z, LTC_NULL);
28           return ltc_ecc_projective_dbl_point(P, R, ma, modulus, mp);
29        }
30        if ((err = mp_sub(modulus, Q->y, t1)) != CRYPT_OK)                       { goto done; }
31        if (mp_cmp(P->y, t1) == LTC_MP_EQ) {
32           err = ltc_ecc_set_point_xyz(1, 1, 0, R);
33           goto done;
34        }
35     }
36     if ((err = mp_copy(P->x, x)) != CRYPT_OK)                                   { goto done; }
37     if ((err = mp_copy(P->y, y)) != CRYPT_OK)                                   { goto done; }
38     if ((err = mp_copy(P->z, z)) != CRYPT_OK)                                   { goto done; }
39     if (Q->z != NULL) {
40        if ((err = mp_sqr(Q->z, t1)) != CRYPT_OK)                                { goto done; }
41        if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)           { goto done; }
42        if ((err = mp_mul(t1, x, x)) != CRYPT_OK)                                { goto done; }
43        if ((err = mp_montgomery_reduce(x, modulus, mp)) != CRYPT_OK)            { goto done; }
44        if ((err = mp_mul(Q->z, t1, t1)) != CRYPT_OK)                            { goto done; }
45        if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)           { goto done; }
46        if ((err = mp_mul(t1, y, y)) != CRYPT_OK)                                { goto done; }
47        if ((err = mp_montgomery_reduce(y, modulus, mp)) != CRYPT_OK)            { goto done; }
48     }
49     if ((err = mp_sqr(z, t1)) != CRYPT_OK)                                      { goto done; }
50     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
51     if ((err = mp_mul(Q->x, t1, t2)) != CRYPT_OK)                               { goto done; }
52     if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
53     if ((err = mp_mul(z, t1, t1)) != CRYPT_OK)                                  { goto done; }
54     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
55     if ((err = mp_mul(Q->y, t1, t1)) != CRYPT_OK)                               { goto done; }
56     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
57     if ((err = mp_sub(y, t1, y)) != CRYPT_OK)                                   { goto done; }
58     if (mp_cmp_d(y, 0) == LTC_MP_LT) {
59        if ((err = mp_add(y, modulus, y)) != CRYPT_OK)                           { goto done; }
60     }
61     if ((err = mp_add(t1, t1, t1)) != CRYPT_OK)                                 { goto done; }
62     if (mp_cmp(t1, modulus) != LTC_MP_LT) {
63        if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
64     }
65     if ((err = mp_add(t1, y, t1)) != CRYPT_OK)                                  { goto done; }
66     if (mp_cmp(t1, modulus) != LTC_MP_LT) {
67        if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
68     }
<span onclick='openModal()' class='match'>69     if ((err = mp_sub(x, t2, x)) != CRYPT_OK)                                   { goto done; }
70     if (mp_cmp_d(x, 0) == LTC_MP_LT) {
71        if ((err = mp_add(x, modulus, x)) != CRYPT_OK)                           { goto done; }
72     }
</span>73     if ((err = mp_add(t2, t2, t2)) != CRYPT_OK)                                 { goto done; }
74     if (mp_cmp(t2, modulus) != LTC_MP_LT) {
75        if ((err = mp_sub(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
76     }
77     if ((err = mp_add(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
78     if (mp_cmp(t2, modulus) != LTC_MP_LT) {
79        if ((err = mp_sub(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
80     }
81     if (Q->z != NULL) {
82        if ((err = mp_mul(z, Q->z, z)) != CRYPT_OK)                              { goto done; }
83        if ((err = mp_montgomery_reduce(z, modulus, mp)) != CRYPT_OK)            { goto done; }
84     }
85     if ((err = mp_mul(z, x, z)) != CRYPT_OK)                                    { goto done; }
86     if ((err = mp_montgomery_reduce(z, modulus, mp)) != CRYPT_OK)               { goto done; }
87     if ((err = mp_mul(t1, x, t1)) != CRYPT_OK)                                  { goto done; }
88     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
89     if ((err = mp_sqr(x, x)) != CRYPT_OK)                                       { goto done; }
90     if ((err = mp_montgomery_reduce(x, modulus, mp)) != CRYPT_OK)               { goto done; }
91     if ((err = mp_mul(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
92     if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
93     if ((err = mp_mul(t1, x, t1)) != CRYPT_OK)                                  { goto done; }
94     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
95     if ((err = mp_sqr(y, x)) != CRYPT_OK)                                       { goto done; }
96     if ((err = mp_montgomery_reduce(x, modulus, mp)) != CRYPT_OK)               { goto done; }
97     if ((err = mp_sub(x, t2, x)) != CRYPT_OK)                                   { goto done; }
98     if (mp_cmp_d(x, 0) == LTC_MP_LT) {
99        if ((err = mp_add(x, modulus, x)) != CRYPT_OK)                           { goto done; }
100     }
101     if ((err = mp_sub(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
102     if (mp_cmp_d(t2, 0) == LTC_MP_LT) {
103        if ((err = mp_add(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
104     }
105     if ((err = mp_sub(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
106     if (mp_cmp_d(t2, 0) == LTC_MP_LT) {
107        if ((err = mp_add(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
108     }
109     if ((err = mp_mul(t2, y, t2)) != CRYPT_OK)                                  { goto done; }
110     if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
111     if ((err = mp_sub(t2, t1, y)) != CRYPT_OK)                                  { goto done; }
112     if (mp_cmp_d(y, 0) == LTC_MP_LT) {
113        if ((err = mp_add(y, modulus, y)) != CRYPT_OK)                           { goto done; }
114     }
115     if (mp_isodd(y)) {
116        if ((err = mp_add(y, modulus, y)) != CRYPT_OK)                           { goto done; }
117     }
118     if ((err = mp_div_2(y, y)) != CRYPT_OK)                                     { goto done; }
119     if ((err = mp_copy(x, R->x)) != CRYPT_OK)                                   { goto done; }
120     if ((err = mp_copy(y, R->y)) != CRYPT_OK)                                   { goto done; }
121     if ((err = mp_copy(z, R->z)) != CRYPT_OK)                                   { goto done; }
122     err = CRYPT_OK;
123  done:
124     mp_clear_multi(t1, t2, x, y, z, LTC_NULL);
125     return err;
126  }
127  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_verify_hash.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltc_ecc_projective_add_point.c</div>
                <div class="column column_space"><pre><code>32        goto error;
33     }
34     if (sigformat == LTC_ECCSIG_ANSIX962) {
35        if ((err = der_decode_sequence_multi_ex(sig, siglen, LTC_DER_SEQ_SEQUENCE | LTC_DER_SEQ_STRICT,
36                                       LTC_ASN1_INTEGER, 1UL, r,
37                                       LTC_ASN1_INTEGER, 1UL, s,
38                                       LTC_ASN1_EOL, 0UL, LTC_NULL)) != CRYPT_OK)                         { goto error; }
39     }
</pre></code></div>
                <div class="column column_space"><pre><code>69     if ((err = mp_sub(x, t2, x)) != CRYPT_OK)                                   { goto done; }
70     if (mp_cmp_d(x, 0) == LTC_MP_LT) {
71        if ((err = mp_add(x, modulus, x)) != CRYPT_OK)                           { goto done; }
72     }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    