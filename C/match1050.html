<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infinoted-plugin-linekeeper.c &amp; inf-test-text-quick-write.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infinoted-plugin-linekeeper.c &amp; inf-test-text-quick-write.c
      </h3>
<h1 align="center">
        10.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infinoted-plugin-linekeeper.c (11.2%)<th>inf-test-text-quick-write.c (9.364549%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(313-354)<td><a href="#" name="0">(183-212)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(516-533)<td><a href="#" name="1">(379-397)</a><td align="center"><font color="#dd0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infinoted-plugin-linekeeper.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;infinoted/infinoted-plugin-manager.h&gt;
#include &lt;infinoted/infinoted-parameter.h&gt;
#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;string.h&gt;
typedef struct _InfinotedPluginLinekeeper InfinotedPluginLinekeeper;
struct _InfinotedPluginLinekeeper {
  InfinotedPluginManager* manager;
  guint n_lines;
};
typedef struct _InfinotedPluginLinekeeperSessionInfo
  InfinotedPluginLinekeeperSessionInfo;
struct _InfinotedPluginLinekeeperSessionInfo {
  InfinotedPluginLinekeeper* plugin;
  InfSessionProxy* proxy;
  InfRequest* request;
  InfUser* user;
  InfTextBuffer* buffer;
  InfIoDispatch* dispatch;
};
typedef struct _InfinotedPluginLinekeeperHasAvailableUsersData
  InfinotedPluginLinekeeperHasAvailableUsersData;
struct _InfinotedPluginLinekeeperHasAvailableUsersData {
  InfUser* own_user;
  gboolean has_available_user;
};
static gboolean
infinoted_plugin_linekeeper_initialize(InfinotedPluginManager* manager,
                                       gpointer plugin_info,
                                       GError** error)
{
  InfinotedPluginLinekeeper* plugin;
  plugin = (InfinotedPluginLinekeeper*)plugin_info;
  plugin-&gt;manager = manager;
  return TRUE;
}
static void
infinoted_plugin_linekeeper_deinitialize(gpointer plugin_info)
{
  InfinotedPluginLinekeeper* plugin;
  plugin = (InfinotedPluginLinekeeper*)plugin_info;
}
static guint
infinoted_plugin_linekeeper_count_lines(InfTextBuffer* buffer)
{
  InfTextBufferIter* iter;
  guint n_lines;
  gboolean has_iter;
  guint length;
  gsize bytes;
  gchar* text;
  gchar* pos;
  gchar* new_pos;
  gunichar c;
  g_assert(strcmp(inf_text_buffer_get_encoding(buffer), "UTF-8") == 0);
  n_lines = 0;
  iter = inf_text_buffer_create_end_iter(buffer);
  if(iter == NULL) return 0;
  do
  {
    length = inf_text_buffer_iter_get_length(buffer, iter);
    bytes = inf_text_buffer_iter_get_bytes(buffer, iter);
    text = inf_text_buffer_iter_get_text(buffer, iter);
    pos = text + bytes;
    while(length &gt; 0)
    {
      new_pos = g_utf8_prev_char(pos);
      g_assert(bytes &gt;= (pos - new_pos));
      c = g_utf8_get_char(new_pos);
      if(c == '\n' || g_unichar_type(c) == G_UNICODE_LINE_SEPARATOR)
        ++n_lines;
      else
        break;
      --length;
      bytes -= (pos - new_pos);
      pos = new_pos;
    }
    g_free(text);
  } while(length == 0 &amp;&amp; inf_text_buffer_iter_prev(buffer, iter));
  inf_text_buffer_destroy_iter(buffer, iter);
  return n_lines;
}
static void
infinoted_plugin_linekeeper_run(InfinotedPluginLinekeeperSessionInfo* info)
{
  guint cur_lines;
  guint n;
  gchar* text;
  cur_lines = infinoted_plugin_linekeeper_count_lines(info-&gt;buffer);
  if(cur_lines &gt; info-&gt;plugin-&gt;n_lines)
  {
    n = cur_lines - info-&gt;plugin-&gt;n_lines;
    inf_text_buffer_erase_text(
      info-&gt;buffer,
      inf_text_buffer_get_length(info-&gt;buffer) - n,
      n,
      info-&gt;user
    );
  }
  else if(cur_lines &lt; info-&gt;plugin-&gt;n_lines)
  {
    n = info-&gt;plugin-&gt;n_lines - cur_lines;
    text = g_malloc(n * sizeof(gchar));
    memset(text, '\n', n);
    inf_text_buffer_insert_text(
      info-&gt;buffer,
      inf_text_buffer_get_length(info-&gt;buffer),
      text,
      n,
      n,
      info-&gt;user
    );
  }
}
static void
infinoted_plugin_linekeeper_run_dispatch_func(gpointer user_data)
{
  InfinotedPluginLinekeeperSessionInfo* info;
  info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
  info-&gt;dispatch = NULL;
  infinoted_plugin_linekeeper_run(info);
}
static void
infinoted_plugin_linekeeper_text_inserted_cb(InfTextBuffer* buffer,
                                             guint pos,
                                             InfTextChunk* chunk,
                                             InfUser* user,
                                             gpointer user_data)
{
  InfinotedPluginLinekeeperSessionInfo* info;
  InfdDirectory* directory;
  info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
  if(info-&gt;dispatch == NULL)
  {
    directory = infinoted_plugin_manager_get_directory(info-&gt;plugin-&gt;manager);
    info-&gt;dispatch = inf_io_add_dispatch(
      infd_directory_get_io(directory),
      infinoted_plugin_linekeeper_run_dispatch_func,
      info,
      NULL
    );
  }
}
static void
infinoted_plugin_linekeeper_text_erased_cb(InfTextBuffer* buffer,
                                           guint pos,
                                           InfTextChunk* chunk,
                                           InfUser* user,
                                           gpointer user_data)
{
  InfinotedPluginLinekeeperSessionInfo* info;
  InfdDirectory* directory;
  info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
  if(info-&gt;dispatch == NULL)
  {
    directory = infinoted_plugin_manager_get_directory(info-&gt;plugin-&gt;manager);
    info-&gt;dispatch = inf_io_add_dispatch(
      infd_directory_get_io(directory),
      infinoted_plugin_linekeeper_run_dispatch_func,
      info,
      NULL
    );
  }
}
static void
infinoted_plugin_linekeeper_remove_user(
  InfinotedPluginLinekeeperSessionInfo* info)
{
  InfSession* session;
  InfUser* user;
  g_assert(info-&gt;user != NULL);
  g_assert(info-&gt;request == NULL);
  user = info-&gt;user;
  info-&gt;user = NULL;
  g_object_get(G_OBJECT(info-&gt;proxy), "session", &amp;session, NULL); 
  inf_session_set_user_status(session, user, INF_USER_UNAVAILABLE);
  g_object_unref(user);
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(info-&gt;buffer),
    G_CALLBACK(infinoted_plugin_linekeeper_text_inserted_cb),
    info
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(info-&gt;buffer),
    G_CALLBACK(infinoted_plugin_linekeeper_text_erased_cb),
    info
  );
  g_object_unref(session);
}
static void
infinoted_plugin_linekeeper_has_available_users_foreach_func(InfUser* user,
                                                             gpointer udata)
{
  InfinotedPluginLinekeeperHasAvailableUsersData* data;
  data = (InfinotedPluginLinekeeperHasAvailableUsersData*)udata;
  if(user != data-&gt;own_user &amp;&amp;
     inf_user_get_status(user) != INF_USER_UNAVAILABLE &amp;&amp;
     (inf_user_get_flags(user) &amp; INF_USER_LOCAL) == 0)
  {
    data-&gt;has_available_user = TRUE;
  }
}
static gboolean
infinoted_plugin_linekeeper_has_available_users(
  InfinotedPluginLinekeeperSessionInfo* info)
{
  InfinotedPluginLinekeeperHasAvailableUsersData data;
  InfSession* session;
  InfUserTable* user_table;
  g_object_get(G_OBJECT(info-&gt;proxy), "session", &amp;session, NULL); 
  user_table = inf_session_get_user_table(session);
  data.has_available_user = FALSE;
  data.own_user = info-&gt;user;
  inf_user_table_foreach_user(
    user_table,
    infinoted_plugin_linekeeper_has_available_users_foreach_func,
    &amp;data
  );
  g_object_unref(session);
  return data.has_available_user;
}
static void
infinoted_plugin_linekeeper_user_join_cb(InfRequest* request,
                                         const InfRequestResult* result,
                                         const GError* error,
                                         gpointer user_data)
{
  InfinotedPluginLinekeeperSessionInfo* info;
  InfUser* user;
  info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
<a name="0"></a>
  info-&gt;request = NULL;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if(error != NULL)
  {
    infinoted_log_warning(
      infinoted_plugin_manager_get_log(info-&gt;plugin-&gt;manager),
      _("Could not join LineKeeper user for document: %s\n"),
      error-&gt;message
    );
  }
  else
  {
    inf_request_result_get_join_user(result, NULL, &amp;user);
    info-&gt;user = user;
    g_object_ref(info-&gt;user);
    infinoted_plugin_linekeeper_run(info);
    g_signal_connect(
      G_OBJECT(info-&gt;buffer),
      "text-inserted",
      G_CALLBACK(infinoted_plugin_linekeeper_text_inserted_cb),
      info
    );
    g_signal_connect(
      G_OBJECT(info-&gt;buffer),
      "text-erased",
      G_CALLBACK(infinoted_plugin_linekeeper_text_erased_cb),
      info
    );
    if(infinoted_plugin_linekeeper_has_available_users(info) == FALSE)
    {
      infinoted_plugin_linekeeper_remove_user(info);
    }
  }
}
static void</b></font>
infinoted_plugin_linekeeper_add_available_user_cb(InfUserTable* user_table,
                                                  InfUser* user,
                                                  gpointer user_data);
static void
infinoted_plugin_linekeeper_join_user(
  InfinotedPluginLinekeeperSessionInfo* info)
{
  InfSession* session;
  InfUserTable* user_table;
  g_assert(info-&gt;user == NULL);
  g_assert(info-&gt;request == NULL);
  g_object_get(G_OBJECT(info-&gt;proxy), "session", &amp;session, NULL);
  user_table = inf_session_get_user_table(session);
  g_signal_handlers_block_by_func(
    user_table,
    G_CALLBACK(infinoted_plugin_linekeeper_add_available_user_cb),
    info
  );
  info-&gt;request = inf_text_session_join_user(
    info-&gt;proxy,
    "LineKeeper",
    INF_USER_ACTIVE,
    0.0,
    inf_text_buffer_get_length(info-&gt;buffer),
    0,
    infinoted_plugin_linekeeper_user_join_cb,
    info
  );
  g_signal_handlers_unblock_by_func(
    user_table,
    G_CALLBACK(infinoted_plugin_linekeeper_add_available_user_cb),
    info
  );
  g_object_unref(session);
}
static void
infinoted_plugin_linekeeper_add_available_user_cb(InfUserTable* user_table,
                                                  InfUser* user,
                                                  gpointer user_data)
{
  InfinotedPluginLinekeeperSessionInfo* info;
  info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
  if(info-&gt;user == NULL &amp;&amp; info-&gt;request == NULL &amp;&amp;
     infinoted_plugin_linekeeper_has_available_users(info))
  {
    infinoted_plugin_linekeeper_join_user(info);
  }
}
static void
infinoted_plugin_linekeeper_remove_available_user_cb(InfUserTable* user_table,
                                                     InfUser* user,
                                                     gpointer user_data)
{
  InfinotedPluginLinekeeperSessionInfo* info;
  info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
  if(info-&gt;user != NULL &amp;&amp;
     !infinoted_plugin_linekeeper_has_available_users(info))
  {
    infinoted_plugin_linekeeper_remove_user(info);
  }
}
static void
infinoted_plugin_linekeeper_session_added(const InfBrowserIter* iter,
                                          InfSessionProxy* proxy,
                                          gpointer plugin_info,
                                          gpointer session_info)
{
  InfinotedPluginLinekeeperSessionInfo* info;
  InfSession* session;
  InfUserTable* user_table;
  info = (InfinotedPluginLinekeeperSessionInfo*)session_info;
  info-&gt;plugin = (InfinotedPluginLinekeeper*)plugin_info;
  info-&gt;proxy = proxy;
  info-&gt;request = NULL;
  info-&gt;user = NULL;
  info-&gt;dispatch = NULL;
  g_object_ref(proxy);
  g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
  g_assert(inf_session_get_status(session) == INF_SESSION_RUNNING);
  info-&gt;buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
  g_object_ref(info-&gt;buffer);
  user_table = inf_session_get_user_table(session);
  g_signal_connect(
    G_OBJECT(user_table),
    "add-available-user",
    G_CALLBACK(infinoted_plugin_linekeeper_add_available_user_cb),
    info
  );
  g_signal_connect(
    G_OBJECT(user_table),
    "remove-available-user",
    G_CALLBACK(infinoted_plugin_linekeeper_remove_available_user_cb),
    info
  );
  if(infinoted_plugin_linekeeper_has_available_users(info) == TRUE)
    infinoted_plugin_linekeeper_join_user(info);
  g_object_unref(session);
}
static void
infinoted_plugin_linekeeper_session_removed(const InfBrowserIter* iter,
                                            InfSessionProxy* proxy,
                                            gpointer plugin_info,
                                            gpointer session_info)
{
  InfinotedPluginLinekeeperSessionInfo* info;
  InfdDirectory* directory;
  InfSession* session;
  InfUserTable* user_table;
  info = (InfinotedPluginLinekeeperSessionInfo*)session_info;
  g_object_get(G_OBJECT(info-&gt;proxy), "session", &amp;session, NULL);
  user_table = inf_session_get_user_table(session);
  g_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(infinoted_plugin_linekeeper_add_available_user_cb),
    info
  );
  g_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(infinoted_plugin_linekeeper_remove_available_user_cb),
    info
  );
  if(info-&gt;dispatch != NULL)
  {
    directory = infinoted_plugin_manager_get_directory(info-&gt;plugin-&gt;manager);
    inf_io_remove_dispatch(infd_directory_get_io(directory), info-&gt;dispatch);
    info-&gt;dispatch = NULL;
  }
<a name="1"></a>  if(info-&gt;user != NULL)
  {
    infinoted_plugin_linekeeper_remove_user(info);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
  if(info-&gt;buffer != NULL)
  {
    g_object_unref(info-&gt;buffer);
    info-&gt;buffer = NULL;
  }
  if(info-&gt;request != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      info-&gt;request,
      G_CALLBACK(infinoted_plugin_linekeeper_user_join_cb),
      info
    );
    info-&gt;request = NULL;
  }</b></font>
  g_assert(info-&gt;proxy != NULL);
  g_object_unref(info-&gt;proxy);
  g_object_unref(session);
}
static const InfinotedParameterInfo INFINOTED_PLUGIN_LINEKEEPER_OPTIONS[] = {
  {
    "n-lines",
    INFINOTED_PARAMETER_INT,
    INFINOTED_PARAMETER_REQUIRED,
    offsetof(InfinotedPluginLinekeeper, n_lines),
    infinoted_parameter_convert_nonnegative,
    0,
    N_("The number of empty lines to keep at the end of the document."),
    N_("LINES")
  }, {
    NULL,
    0,
    0,
    0,
    NULL
  }
};
const InfinotedPlugin INFINOTED_PLUGIN = {
  "linekeeper",
  N_("This plugin makes sure that at the end of every document there is "
     "always a fixed number of empty lines."),
  INFINOTED_PLUGIN_LINEKEEPER_OPTIONS,
  sizeof(InfinotedPluginLinekeeper),
  0,
  sizeof(InfinotedPluginLinekeeperSessionInfo),
  "InfTextSession",
  NULL,
  infinoted_plugin_linekeeper_initialize,
  infinoted_plugin_linekeeper_deinitialize,
  NULL,
  NULL,
  infinoted_plugin_linekeeper_session_added,
  infinoted_plugin_linekeeper_session_removed
};
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-quick-write.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinftext/inf-text-default-buffer.h&gt;
#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;
#include &lt;libinfinity/client/infc-note-plugin.h&gt;
#include &lt;libinfinity/client/infc-browser.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/common/inf-browser.h&gt;
#include &lt;libinfinity/common/inf-session-proxy.h&gt;
#include &lt;libinfinity/common/inf-session.h&gt;
#include &lt;libinfinity/common/inf-user.h&gt;
#include &lt;libinfinity/common/inf-protocol.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;
#include &lt;libinfinity/common/inf-cert-util.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;string.h&gt;
typedef struct _InfTestTextQuickWrite InfTestTextQuickWrite;
struct _InfTestTextQuickWrite {
  InfCertificateCredentials* credentials;
  gchar* content;
  gsize content_pos;
  gsize content_length;
  InfStandaloneIo* io;
  InfXmppConnection* conn;
  InfBrowser* browser;
  InfSessionProxy* proxy;
  InfSession* session;
  InfUser* user;
  InfTextBuffer* buffer;
};
static InfSession*
inf_test_text_quick_write_session_new(InfIo* io,
                                      InfCommunicationManager* manager,
                                      InfSessionStatus status,
                                      InfCommunicationGroup* sync_group,
                                      InfXmlConnection* sync_connection,
                                      const gchar* path,
                                      gpointer user_data)
{
  InfTextDefaultBuffer* buffer;
  InfTextSession* session;
  buffer = inf_text_default_buffer_new("UTF-8");
  session = inf_text_session_new(
    manager,
    INF_TEXT_BUFFER(buffer),
    io,
    status,
    sync_group,
    sync_connection
  );
  g_object_unref(buffer);
  return INF_SESSION(session);
}
static const InfcNotePlugin INF_TEST_TEXT_QUICK_WRITE_PLUGIN = {
  NULL, "InfText", inf_test_text_quick_write_session_new
};
static void
inf_test_text_quick_write_reconnect(InfTestTextQuickWrite* test);
static void
inf_test_text_quick_write_schedule_next(InfTestTextQuickWrite* test);
static void
inf_test_text_quick_write_next_cb(gpointer user_data)
{
  InfTestTextQuickWrite* test;
  int action;
  test = (InfTestTextQuickWrite*)user_data;
  action = g_random_int_range(0, 100000);
  if(action &lt; 50)
  {
    inf_test_text_quick_write_reconnect(test);
  }
  else if(action &lt; 90000)
  {
    inf_text_buffer_insert_text(
      test-&gt;buffer,
      MIN(test-&gt;content_pos, inf_text_buffer_get_length(test-&gt;buffer)),
      &amp;test-&gt;content[test-&gt;content_pos],
      1,
      1,
      test-&gt;user
    );
    ++test-&gt;content_pos;
    if(test-&gt;content[test-&gt;content_pos] == '\0')
      test-&gt;content_pos = 0;
    inf_test_text_quick_write_schedule_next(test);
  }
  else
  {
    if(inf_text_buffer_get_length(test-&gt;buffer) &gt; 0 &amp;&amp; test-&gt;content_pos &gt; 0)
    {
      inf_text_buffer_erase_text(
        test-&gt;buffer,
        test-&gt;content_pos - 1,
        1,
        test-&gt;user
      );
      g_assert(test-&gt;content_length &gt; 0);
      if(test-&gt;content_pos == 0)
        test-&gt;content_pos = test-&gt;content_length - 1;
      else
        --test-&gt;content_pos;
    }
    inf_test_text_quick_write_schedule_next(test);
  }
}
static void
inf_test_text_quick_write_schedule_next(InfTestTextQuickWrite* test)
{
  int secs;
  secs = g_random_int_range(10, 50);
  inf_io_add_timeout(
    INF_IO(test-&gt;io),
    secs,
    inf_test_text_quick_write_next_cb,
    test,
    NULL
  );
}
static void
inf_test_text_quick_write_user_join_cb(InfRequest* request,
                                       const InfRequestResult* result,
                                       const GError* error,
                                       gpointer user_data)
{
<a name="0"></a>  InfTestTextQuickWrite* test;
  test = (InfTestTextQuickWrite*)user_data;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if(error != NULL)
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    inf_standalone_io_loop_quit(test-&gt;io);
  }
  else
  {
    inf_request_result_get_join_user(result, NULL, &amp;test-&gt;user);
    g_object_ref(test-&gt;user);
    test-&gt;buffer = INF_TEXT_BUFFER(inf_session_get_buffer(test-&gt;session));
    g_object_ref(test-&gt;buffer);
    if(inf_text_buffer_get_length(test-&gt;buffer) &gt; 0)
    {
      inf_text_buffer_erase_text(
        test-&gt;buffer,
        0,
        inf_text_buffer_get_length(test-&gt;buffer),
        test-&gt;user
      );
    }
    inf_test_text_quick_write_schedule_next(test);
  }
}
static void</b></font>
inf_test_text_quick_write_join_user(InfTestTextQuickWrite* test)
{
  inf_text_session_join_user(
    test-&gt;proxy,
    "TestUser",
    INF_USER_ACTIVE,
    0.0,
    0,
    0,
    inf_test_text_quick_write_user_join_cb,
    test
  );
}
static void
inf_test_text_quick_write_session_notify_status_cb(GObject* object,
                                                   GParamSpec* pspec,
                                                   gpointer user_data)
{
  InfTestTextQuickWrite* test;
  test = (InfTestTextQuickWrite*)user_data;
  if(inf_session_get_status(test-&gt;session) == INF_SESSION_RUNNING)
    inf_test_text_quick_write_join_user(test);
  if(inf_session_get_status(test-&gt;session) == INF_SESSION_CLOSED)
  {
    fprintf(stderr, "Session closed remotely\n");
    inf_standalone_io_loop_quit(test-&gt;io);
  }
}
static void
inf_test_text_quick_write_subscribe_cb(InfRequest* request,
                                       const InfRequestResult* result,
                                       const GError* error,
                                       gpointer user_data)
{
  InfTestTextQuickWrite* test;
  test = (InfTestTextQuickWrite*)user_data;
  if(error != NULL)
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    inf_standalone_io_loop_quit(test-&gt;io);
  }
  else
  {
    inf_request_result_get_subscribe_session(
      result,
      NULL,
      NULL,
      &amp;test-&gt;proxy
    );
    g_object_ref(test-&gt;proxy);
    g_object_get(test-&gt;proxy, "session", &amp;test-&gt;session, NULL);
    g_signal_connect(
      G_OBJECT(test-&gt;session),
      "notify::status",
      G_CALLBACK(inf_test_text_quick_write_session_notify_status_cb),
      test
    );
    if(inf_session_get_status(test-&gt;session) == INF_SESSION_RUNNING)
      inf_test_text_quick_write_join_user(test);
  }
}
static void
inf_test_text_quick_write_explore_cb(InfRequest* request,
                                     const InfRequestResult* result,
                                     const GError* error,
                                     gpointer user_data)
{
  InfTestTextQuickWrite* test;
  InfBrowserIter iter;
  gboolean have_iter;
  test = (InfTestTextQuickWrite*)user_data;
  if(error != NULL)
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    inf_standalone_io_loop_quit(test-&gt;io);
  }
  else
  {
    inf_browser_get_root(test-&gt;browser, &amp;iter);
    for(have_iter = inf_browser_get_child(test-&gt;browser, &amp;iter);
        have_iter == TRUE;
        have_iter = inf_browser_get_next(test-&gt;browser, &amp;iter))
    {
      if(strcmp(inf_browser_get_node_name(test-&gt;browser, &amp;iter), "test") == 0)
      {
        inf_browser_subscribe(
          test-&gt;browser,
          &amp;iter,
          inf_test_text_quick_write_subscribe_cb,
          test
        );
        break;
      }
    }
    if(have_iter == FALSE)
    {
      fprintf(stderr, "No document named /test\n");
      inf_standalone_io_loop_quit(test-&gt;io);
    }
  }
}
static void
inf_test_text_quick_write_error_cb(InfcBrowser* browser,
                                   GError* error,
                                   gpointer user_data)
{
  fprintf(stderr, "Connection error: %s\n", error-&gt;message);
}
static void
inf_test_text_quick_write_notify_status_cb(GObject* object,
                                           GParamSpec* pspec,
                                           gpointer user_data)
{
  InfTestTextQuickWrite* test;
  InfBrowserStatus status;
  InfBrowserIter iter;
  test = (InfTestTextQuickWrite*)user_data;
  g_object_get(G_OBJECT(test-&gt;browser), "status", &amp;status, NULL);
  if(status == INF_BROWSER_OPEN)
  {
    printf("Connection established\n");
    inf_browser_get_root(test-&gt;browser, &amp;iter);
    inf_browser_explore(
      test-&gt;browser,
      &amp;iter,
      inf_test_text_quick_write_explore_cb,
      test
    );
  }
  if(status == INF_BROWSER_CLOSED)
  {
    if(inf_standalone_io_loop_running(test-&gt;io))
      inf_standalone_io_loop_quit(test-&gt;io);
  }
}
static void
inf_test_text_quick_write_disconnect(InfTestTextQuickWrite* test)
{
  if(test-&gt;buffer != NULL)
<a name="1"></a>  {
    g_object_unref(test-&gt;buffer);
    test-&gt;buffer = NULL;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
  if(test-&gt;user != NULL)
  {
    g_object_unref(test-&gt;user);
    test-&gt;user = NULL;
  }
  if(test-&gt;session != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(test-&gt;session),
      G_CALLBACK(inf_test_text_quick_write_session_notify_status_cb),
      test
    );
    g_object_unref(test-&gt;session);
    test-&gt;session = NULL;
  }</b></font>
  if(test-&gt;proxy != NULL)
  {
    g_object_unref(test-&gt;proxy);
    test-&gt;proxy = NULL;
  }
  if(test-&gt;browser != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(test-&gt;browser),
      G_CALLBACK(inf_test_text_quick_write_notify_status_cb),
      test
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(test-&gt;browser),
      G_CALLBACK(inf_test_text_quick_write_error_cb),
      test
    );
    g_object_unref(test-&gt;browser);
    test-&gt;browser = NULL;
  }
  if(test-&gt;conn != NULL)
  {
    g_object_unref(test-&gt;conn);
    test-&gt;conn = NULL;
  }
}
static void
inf_test_text_quick_write_reconnect(InfTestTextQuickWrite* test)
{
  const char* hostname;
  InfNameResolver* resolver;
  InfTcpConnection* tcp_conn;
  InfCommunicationManager* manager;
  GError* error;
  test-&gt;content_pos = 0;
  error = NULL;
  inf_test_text_quick_write_disconnect(test);
  hostname = "londeroth.org";
  resolver = inf_name_resolver_new(
    INF_IO(test-&gt;io),
    hostname,
    "6523",
    "_infinote._tcp"
  );
  tcp_conn = inf_tcp_connection_new_resolve(INF_IO(test-&gt;io), resolver);
  g_object_unref(resolver);
  if(inf_tcp_connection_open(tcp_conn, &amp;error) == FALSE)
  {
    fprintf(stderr, "Could not open TCP connection: %s\n", error-&gt;message);
    g_error_free(error);
    g_object_unref(tcp_conn);
    inf_standalone_io_loop_quit(test-&gt;io);
  }
  else
  {
    test-&gt;conn = inf_xmpp_connection_new(
      tcp_conn,
      INF_XMPP_CONNECTION_CLIENT,
      NULL,
      "localhost",
      INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
      test-&gt;credentials,
      NULL,
      NULL
    );
    g_object_unref(tcp_conn);
    manager = inf_communication_manager_new();
    test-&gt;browser = INF_BROWSER(
      infc_browser_new(
        INF_IO(test-&gt;io),
        manager,
        INF_XML_CONNECTION(test-&gt;conn)
      )
    );
    g_object_unref(manager);
    infc_browser_add_plugin(
      INFC_BROWSER(test-&gt;browser),
      &amp;INF_TEST_TEXT_QUICK_WRITE_PLUGIN
    );
    g_signal_connect_after(
      G_OBJECT(test-&gt;browser),
      "notify::status",
      G_CALLBACK(inf_test_text_quick_write_notify_status_cb),
      test
    );
    g_signal_connect(
      G_OBJECT(test-&gt;browser),
      "error",
      G_CALLBACK(inf_test_text_quick_write_error_cb),
      test
    );
  }
}
static void
inf_test_text_quick_write_start_cb(gpointer user_data)
{
  inf_test_text_quick_write_reconnect((InfTestTextQuickWrite*)user_data);
}
static InfCertificateCredentials*
inf_test_text_quick_write_load_credentials(const char* filename,
                                           GError** error)
{
  InfCertificateCredentials* creds;
  GPtrArray* certs;
  gnutls_x509_privkey_t key;
  guint i;
  key = inf_cert_util_read_private_key(filename, error);
  if(key == NULL) return NULL;
  certs = inf_cert_util_read_certificate(filename, NULL, error);
  if(certs == NULL)
  {
    gnutls_x509_privkey_deinit(key);
    return NULL;
  }
  creds = inf_certificate_credentials_new();
  gnutls_certificate_set_x509_key(
    inf_certificate_credentials_get(creds),
    (gnutls_x509_crt_t*)certs-&gt;pdata,
    certs-&gt;len,
    key
  );
  gnutls_certificate_set_x509_trust(
    inf_certificate_credentials_get(creds),
    (gnutls_x509_crt_t*)&amp;certs-&gt;pdata[certs-&gt;len - 1],
    certs-&gt;len
  );
  gnutls_x509_privkey_deinit(key);
  for(i = 0; i &lt; certs-&gt;len; ++i)
    gnutls_x509_crt_deinit(certs-&gt;pdata[i]);
  g_ptr_array_free(certs, TRUE);
  return creds;
}
int
main(int argc, char* argv[])
{
  guint32 seed;
  const gchar* filename;
  const gchar* credentials;
  InfTestTextQuickWrite test;
  GError* error;
  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    return 1;
  }
  seed = time(NULL);
  printf("Random seed: %u\n", seed);
  g_random_set_seed(seed);
  if(argc &lt; 2)
    filename = "inf-test-quick-write.c";
  else
    filename = argv[1];
  credentials = NULL;
  g_file_get_contents(filename, &amp;test.content, &amp;test.content_length, &amp;error);
  if(error != NULL)
  {
    fprintf(stderr, "%s: %s\n", filename, error-&gt;message);
    g_error_free(error);
    return 1;
  }
  if(test.content_length == 0)
  {
    fprintf(stderr, "%s: File is empty\n", filename);
    return 1;
  }
  test.credentials = NULL;
  test.io = NULL;
  test.conn = NULL;
  test.browser = NULL;
  test.proxy = NULL;
  test.session = NULL;
  test.user = NULL;
  test.buffer = NULL;
  if(credentials != NULL)
  {
    test.credentials = inf_test_text_quick_write_load_credentials(
      credentials,
      &amp;error
    );
    if(test.credentials == NULL)
    {
      fprintf(stderr, "%s\n", error-&gt;message);
      g_error_free(error);
      return 1;
    }
  }
  test.io = inf_standalone_io_new();
  inf_io_add_dispatch(
    INF_IO(test.io),
    inf_test_text_quick_write_start_cb,
    &amp;test,
    NULL
  );
  inf_standalone_io_loop(test.io);
  g_object_unref(test.io);
  inf_certificate_credentials_unref(test.credentials);
  g_free(test.content);
  return 0;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
