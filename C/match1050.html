<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infinoted-plugin-linekeeper.c &amp; inf-test-text-quick-write.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infinoted-plugin-linekeeper.c &amp; inf-test-text-quick-write.c
      </h3>
<h1 align="center">
        10.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infinoted-plugin-linekeeper.c (11.2%)<th>inf-test-text-quick-write.c (9.364549%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(313-354)<td><a href="#" name="0">(183-212)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(516-533)<td><a href="#" name="1">(379-397)</a><td align="center"><font color="#dd0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infinoted-plugin-linekeeper.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;infinoted/infinoted-plugin-manager.h&gt;
2 #include &lt;infinoted/infinoted-parameter.h&gt;
3 #include &lt;libinftext/inf-text-session.h&gt;
4 #include &lt;libinftext/inf-text-buffer.h&gt;
5 #include &lt;libinfinity/common/inf-request-result.h&gt;
6 #include &lt;libinfinity/inf-signals.h&gt;
7 #include &lt;libinfinity/inf-i18n.h&gt;
8 #include &lt;string.h&gt;
9 typedef struct _InfinotedPluginLinekeeper InfinotedPluginLinekeeper;
10 struct _InfinotedPluginLinekeeper {
11   InfinotedPluginManager* manager;
12   guint n_lines;
13 };
14 typedef struct _InfinotedPluginLinekeeperSessionInfo
15   InfinotedPluginLinekeeperSessionInfo;
16 struct _InfinotedPluginLinekeeperSessionInfo {
17   InfinotedPluginLinekeeper* plugin;
18   InfSessionProxy* proxy;
19   InfRequest* request;
20   InfUser* user;
21   InfTextBuffer* buffer;
22   InfIoDispatch* dispatch;
23 };
24 typedef struct _InfinotedPluginLinekeeperHasAvailableUsersData
25   InfinotedPluginLinekeeperHasAvailableUsersData;
26 struct _InfinotedPluginLinekeeperHasAvailableUsersData {
27   InfUser* own_user;
28   gboolean has_available_user;
29 };
30 static gboolean
31 infinoted_plugin_linekeeper_initialize(InfinotedPluginManager* manager,
32                                        gpointer plugin_info,
33                                        GError** error)
34 {
35   InfinotedPluginLinekeeper* plugin;
36   plugin = (InfinotedPluginLinekeeper*)plugin_info;
37   plugin-&gt;manager = manager;
38   return TRUE;
39 }
40 static void
41 infinoted_plugin_linekeeper_deinitialize(gpointer plugin_info)
42 {
43   InfinotedPluginLinekeeper* plugin;
44   plugin = (InfinotedPluginLinekeeper*)plugin_info;
45 }
46 static guint
47 infinoted_plugin_linekeeper_count_lines(InfTextBuffer* buffer)
48 {
49   InfTextBufferIter* iter;
50   guint n_lines;
51   gboolean has_iter;
52   guint length;
53   gsize bytes;
54   gchar* text;
55   gchar* pos;
56   gchar* new_pos;
57   gunichar c;
58   g_assert(strcmp(inf_text_buffer_get_encoding(buffer), "UTF-8") == 0);
59   n_lines = 0;
60   iter = inf_text_buffer_create_end_iter(buffer);
61   if(iter == NULL) return 0;
62   do
63   {
64     length = inf_text_buffer_iter_get_length(buffer, iter);
65     bytes = inf_text_buffer_iter_get_bytes(buffer, iter);
66     text = inf_text_buffer_iter_get_text(buffer, iter);
67     pos = text + bytes;
68     while(length &gt; 0)
69     {
70       new_pos = g_utf8_prev_char(pos);
71       g_assert(bytes &gt;= (pos - new_pos));
72       c = g_utf8_get_char(new_pos);
73       if(c == '\n' || g_unichar_type(c) == G_UNICODE_LINE_SEPARATOR)
74         ++n_lines;
75       else
76         break;
77       --length;
78       bytes -= (pos - new_pos);
79       pos = new_pos;
80     }
81     g_free(text);
82   } while(length == 0 &amp;&amp; inf_text_buffer_iter_prev(buffer, iter));
83   inf_text_buffer_destroy_iter(buffer, iter);
84   return n_lines;
85 }
86 static void
87 infinoted_plugin_linekeeper_run(InfinotedPluginLinekeeperSessionInfo* info)
88 {
89   guint cur_lines;
90   guint n;
91   gchar* text;
92   cur_lines = infinoted_plugin_linekeeper_count_lines(info-&gt;buffer);
93   if(cur_lines &gt; info-&gt;plugin-&gt;n_lines)
94   {
95     n = cur_lines - info-&gt;plugin-&gt;n_lines;
96     inf_text_buffer_erase_text(
97       info-&gt;buffer,
98       inf_text_buffer_get_length(info-&gt;buffer) - n,
99       n,
100       info-&gt;user
101     );
102   }
103   else if(cur_lines &lt; info-&gt;plugin-&gt;n_lines)
104   {
105     n = info-&gt;plugin-&gt;n_lines - cur_lines;
106     text = g_malloc(n * sizeof(gchar));
107     memset(text, '\n', n);
108     inf_text_buffer_insert_text(
109       info-&gt;buffer,
110       inf_text_buffer_get_length(info-&gt;buffer),
111       text,
112       n,
113       n,
114       info-&gt;user
115     );
116   }
117 }
118 static void
119 infinoted_plugin_linekeeper_run_dispatch_func(gpointer user_data)
120 {
121   InfinotedPluginLinekeeperSessionInfo* info;
122   info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
123   info-&gt;dispatch = NULL;
124   infinoted_plugin_linekeeper_run(info);
125 }
126 static void
127 infinoted_plugin_linekeeper_text_inserted_cb(InfTextBuffer* buffer,
128                                              guint pos,
129                                              InfTextChunk* chunk,
130                                              InfUser* user,
131                                              gpointer user_data)
132 {
133   InfinotedPluginLinekeeperSessionInfo* info;
134   InfdDirectory* directory;
135   info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
136   if(info-&gt;dispatch == NULL)
137   {
138     directory = infinoted_plugin_manager_get_directory(info-&gt;plugin-&gt;manager);
139     info-&gt;dispatch = inf_io_add_dispatch(
140       infd_directory_get_io(directory),
141       infinoted_plugin_linekeeper_run_dispatch_func,
142       info,
143       NULL
144     );
145   }
146 }
147 static void
148 infinoted_plugin_linekeeper_text_erased_cb(InfTextBuffer* buffer,
149                                            guint pos,
150                                            InfTextChunk* chunk,
151                                            InfUser* user,
152                                            gpointer user_data)
153 {
154   InfinotedPluginLinekeeperSessionInfo* info;
155   InfdDirectory* directory;
156   info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
157   if(info-&gt;dispatch == NULL)
158   {
159     directory = infinoted_plugin_manager_get_directory(info-&gt;plugin-&gt;manager);
160     info-&gt;dispatch = inf_io_add_dispatch(
161       infd_directory_get_io(directory),
162       infinoted_plugin_linekeeper_run_dispatch_func,
163       info,
164       NULL
165     );
166   }
167 }
168 static void
169 infinoted_plugin_linekeeper_remove_user(
170   InfinotedPluginLinekeeperSessionInfo* info)
171 {
172   InfSession* session;
173   InfUser* user;
174   g_assert(info-&gt;user != NULL);
175   g_assert(info-&gt;request == NULL);
176   user = info-&gt;user;
177   info-&gt;user = NULL;
178   g_object_get(G_OBJECT(info-&gt;proxy), "session", &amp;session, NULL); 
179   inf_session_set_user_status(session, user, INF_USER_UNAVAILABLE);
180   g_object_unref(user);
181   inf_signal_handlers_disconnect_by_func(
182     G_OBJECT(info-&gt;buffer),
183     G_CALLBACK(infinoted_plugin_linekeeper_text_inserted_cb),
184     info
185   );
186   inf_signal_handlers_disconnect_by_func(
187     G_OBJECT(info-&gt;buffer),
188     G_CALLBACK(infinoted_plugin_linekeeper_text_erased_cb),
189     info
190   );
191   g_object_unref(session);
192 }
193 static void
194 infinoted_plugin_linekeeper_has_available_users_foreach_func(InfUser* user,
195                                                              gpointer udata)
196 {
197   InfinotedPluginLinekeeperHasAvailableUsersData* data;
198   data = (InfinotedPluginLinekeeperHasAvailableUsersData*)udata;
199   if(user != data-&gt;own_user &amp;&amp;
200      inf_user_get_status(user) != INF_USER_UNAVAILABLE &amp;&amp;
201      (inf_user_get_flags(user) &amp; INF_USER_LOCAL) == 0)
202   {
203     data-&gt;has_available_user = TRUE;
204   }
205 }
206 static gboolean
207 infinoted_plugin_linekeeper_has_available_users(
208   InfinotedPluginLinekeeperSessionInfo* info)
209 {
210   InfinotedPluginLinekeeperHasAvailableUsersData data;
211   InfSession* session;
212   InfUserTable* user_table;
213   g_object_get(G_OBJECT(info-&gt;proxy), "session", &amp;session, NULL); 
214   user_table = inf_session_get_user_table(session);
215   data.has_available_user = FALSE;
216   data.own_user = info-&gt;user;
217   inf_user_table_foreach_user(
218     user_table,
219     infinoted_plugin_linekeeper_has_available_users_foreach_func,
220     &amp;data
221   );
222   g_object_unref(session);
223   return data.has_available_user;
224 }
225 static void
226 infinoted_plugin_linekeeper_user_join_cb(InfRequest* request,
227                                          const InfRequestResult* result,
228                                          const GError* error,
229                                          gpointer user_data)
230 {
231   InfinotedPluginLinekeeperSessionInfo* info;
232   InfUser* user;
233   info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
234 <a name="0"></a>
235   info-&gt;request = NULL;
236 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if(error != NULL)
237   {
238     infinoted_log_warning(
239       infinoted_plugin_manager_get_log(info-&gt;plugin-&gt;manager),
240       _("Could not join LineKeeper user for document: %s\n"),
241       error-&gt;message
242     );
243   }
244   else
245   {
246     inf_request_result_get_join_user(result, NULL, &amp;user);
247     info-&gt;user = user;
248     g_object_ref(info-&gt;user);
249     infinoted_plugin_linekeeper_run(info);
250     g_signal_connect(
251       G_OBJECT(info-&gt;buffer),
252       "text-inserted",
253       G_CALLBACK(infinoted_plugin_linekeeper_text_inserted_cb),
254       info
255     );
256     g_signal_connect(
257       G_OBJECT(info-&gt;buffer),
258       "text-erased",
259       G_CALLBACK(infinoted_plugin_linekeeper_text_erased_cb),
260       info
261     );
262     if(infinoted_plugin_linekeeper_has_available_users(info) == FALSE)
263     {
264       infinoted_plugin_linekeeper_remove_user(info);
265     }
266   }
267 }
268 static void</b></font>
269 infinoted_plugin_linekeeper_add_available_user_cb(InfUserTable* user_table,
270                                                   InfUser* user,
271                                                   gpointer user_data);
272 static void
273 infinoted_plugin_linekeeper_join_user(
274   InfinotedPluginLinekeeperSessionInfo* info)
275 {
276   InfSession* session;
277   InfUserTable* user_table;
278   g_assert(info-&gt;user == NULL);
279   g_assert(info-&gt;request == NULL);
280   g_object_get(G_OBJECT(info-&gt;proxy), "session", &amp;session, NULL);
281   user_table = inf_session_get_user_table(session);
282   g_signal_handlers_block_by_func(
283     user_table,
284     G_CALLBACK(infinoted_plugin_linekeeper_add_available_user_cb),
285     info
286   );
287   info-&gt;request = inf_text_session_join_user(
288     info-&gt;proxy,
289     "LineKeeper",
290     INF_USER_ACTIVE,
291     0.0,
292     inf_text_buffer_get_length(info-&gt;buffer),
293     0,
294     infinoted_plugin_linekeeper_user_join_cb,
295     info
296   );
297   g_signal_handlers_unblock_by_func(
298     user_table,
299     G_CALLBACK(infinoted_plugin_linekeeper_add_available_user_cb),
300     info
301   );
302   g_object_unref(session);
303 }
304 static void
305 infinoted_plugin_linekeeper_add_available_user_cb(InfUserTable* user_table,
306                                                   InfUser* user,
307                                                   gpointer user_data)
308 {
309   InfinotedPluginLinekeeperSessionInfo* info;
310   info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
311   if(info-&gt;user == NULL &amp;&amp; info-&gt;request == NULL &amp;&amp;
312      infinoted_plugin_linekeeper_has_available_users(info))
313   {
314     infinoted_plugin_linekeeper_join_user(info);
315   }
316 }
317 static void
318 infinoted_plugin_linekeeper_remove_available_user_cb(InfUserTable* user_table,
319                                                      InfUser* user,
320                                                      gpointer user_data)
321 {
322   InfinotedPluginLinekeeperSessionInfo* info;
323   info = (InfinotedPluginLinekeeperSessionInfo*)user_data;
324   if(info-&gt;user != NULL &amp;&amp;
325      !infinoted_plugin_linekeeper_has_available_users(info))
326   {
327     infinoted_plugin_linekeeper_remove_user(info);
328   }
329 }
330 static void
331 infinoted_plugin_linekeeper_session_added(const InfBrowserIter* iter,
332                                           InfSessionProxy* proxy,
333                                           gpointer plugin_info,
334                                           gpointer session_info)
335 {
336   InfinotedPluginLinekeeperSessionInfo* info;
337   InfSession* session;
338   InfUserTable* user_table;
339   info = (InfinotedPluginLinekeeperSessionInfo*)session_info;
340   info-&gt;plugin = (InfinotedPluginLinekeeper*)plugin_info;
341   info-&gt;proxy = proxy;
342   info-&gt;request = NULL;
343   info-&gt;user = NULL;
344   info-&gt;dispatch = NULL;
345   g_object_ref(proxy);
346   g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
347   g_assert(inf_session_get_status(session) == INF_SESSION_RUNNING);
348   info-&gt;buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
349   g_object_ref(info-&gt;buffer);
350   user_table = inf_session_get_user_table(session);
351   g_signal_connect(
352     G_OBJECT(user_table),
353     "add-available-user",
354     G_CALLBACK(infinoted_plugin_linekeeper_add_available_user_cb),
355     info
356   );
357   g_signal_connect(
358     G_OBJECT(user_table),
359     "remove-available-user",
360     G_CALLBACK(infinoted_plugin_linekeeper_remove_available_user_cb),
361     info
362   );
363   if(infinoted_plugin_linekeeper_has_available_users(info) == TRUE)
364     infinoted_plugin_linekeeper_join_user(info);
365   g_object_unref(session);
366 }
367 static void
368 infinoted_plugin_linekeeper_session_removed(const InfBrowserIter* iter,
369                                             InfSessionProxy* proxy,
370                                             gpointer plugin_info,
371                                             gpointer session_info)
372 {
373   InfinotedPluginLinekeeperSessionInfo* info;
374   InfdDirectory* directory;
375   InfSession* session;
376   InfUserTable* user_table;
377   info = (InfinotedPluginLinekeeperSessionInfo*)session_info;
378   g_object_get(G_OBJECT(info-&gt;proxy), "session", &amp;session, NULL);
379   user_table = inf_session_get_user_table(session);
380   g_signal_handlers_disconnect_by_func(
381     G_OBJECT(user_table),
382     G_CALLBACK(infinoted_plugin_linekeeper_add_available_user_cb),
383     info
384   );
385   g_signal_handlers_disconnect_by_func(
386     G_OBJECT(user_table),
387     G_CALLBACK(infinoted_plugin_linekeeper_remove_available_user_cb),
388     info
389   );
390   if(info-&gt;dispatch != NULL)
391   {
392     directory = infinoted_plugin_manager_get_directory(info-&gt;plugin-&gt;manager);
393     inf_io_remove_dispatch(infd_directory_get_io(directory), info-&gt;dispatch);
394     info-&gt;dispatch = NULL;
395   }
396 <a name="1"></a>  if(info-&gt;user != NULL)
397   {
398     infinoted_plugin_linekeeper_remove_user(info);
399 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
400   if(info-&gt;buffer != NULL)
401   {
402     g_object_unref(info-&gt;buffer);
403     info-&gt;buffer = NULL;
404   }
405   if(info-&gt;request != NULL)
406   {
407     inf_signal_handlers_disconnect_by_func(
408       info-&gt;request,
409       G_CALLBACK(infinoted_plugin_linekeeper_user_join_cb),
410       info
411     );
412     info-&gt;request = NULL;
413   }</b></font>
414   g_assert(info-&gt;proxy != NULL);
415   g_object_unref(info-&gt;proxy);
416   g_object_unref(session);
417 }
418 static const InfinotedParameterInfo INFINOTED_PLUGIN_LINEKEEPER_OPTIONS[] = {
419   {
420     "n-lines",
421     INFINOTED_PARAMETER_INT,
422     INFINOTED_PARAMETER_REQUIRED,
423     offsetof(InfinotedPluginLinekeeper, n_lines),
424     infinoted_parameter_convert_nonnegative,
425     0,
426     N_("The number of empty lines to keep at the end of the document."),
427     N_("LINES")
428   }, {
429     NULL,
430     0,
431     0,
432     0,
433     NULL
434   }
435 };
436 const InfinotedPlugin INFINOTED_PLUGIN = {
437   "linekeeper",
438   N_("This plugin makes sure that at the end of every document there is "
439      "always a fixed number of empty lines."),
440   INFINOTED_PLUGIN_LINEKEEPER_OPTIONS,
441   sizeof(InfinotedPluginLinekeeper),
442   0,
443   sizeof(InfinotedPluginLinekeeperSessionInfo),
444   "InfTextSession",
445   NULL,
446   infinoted_plugin_linekeeper_initialize,
447   infinoted_plugin_linekeeper_deinitialize,
448   NULL,
449   NULL,
450   infinoted_plugin_linekeeper_session_added,
451   infinoted_plugin_linekeeper_session_removed
452 };
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-quick-write.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-default-buffer.h&gt;
2 #include &lt;libinftext/inf-text-session.h&gt;
3 #include &lt;libinftext/inf-text-buffer.h&gt;
4 #include &lt;libinfinity/client/infc-note-plugin.h&gt;
5 #include &lt;libinfinity/client/infc-browser.h&gt;
6 #include &lt;libinfinity/common/inf-standalone-io.h&gt;
7 #include &lt;libinfinity/common/inf-request-result.h&gt;
8 #include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
9 #include &lt;libinfinity/common/inf-browser.h&gt;
10 #include &lt;libinfinity/common/inf-session-proxy.h&gt;
11 #include &lt;libinfinity/common/inf-session.h&gt;
12 #include &lt;libinfinity/common/inf-user.h&gt;
13 #include &lt;libinfinity/common/inf-protocol.h&gt;
14 #include &lt;libinfinity/common/inf-init.h&gt;
15 #include &lt;libinfinity/common/inf-cert-util.h&gt;
16 #include &lt;libinfinity/inf-signals.h&gt;
17 #include &lt;string.h&gt;
18 typedef struct _InfTestTextQuickWrite InfTestTextQuickWrite;
19 struct _InfTestTextQuickWrite {
20   InfCertificateCredentials* credentials;
21   gchar* content;
22   gsize content_pos;
23   gsize content_length;
24   InfStandaloneIo* io;
25   InfXmppConnection* conn;
26   InfBrowser* browser;
27   InfSessionProxy* proxy;
28   InfSession* session;
29   InfUser* user;
30   InfTextBuffer* buffer;
31 };
32 static InfSession*
33 inf_test_text_quick_write_session_new(InfIo* io,
34                                       InfCommunicationManager* manager,
35                                       InfSessionStatus status,
36                                       InfCommunicationGroup* sync_group,
37                                       InfXmlConnection* sync_connection,
38                                       const gchar* path,
39                                       gpointer user_data)
40 {
41   InfTextDefaultBuffer* buffer;
42   InfTextSession* session;
43   buffer = inf_text_default_buffer_new("UTF-8");
44   session = inf_text_session_new(
45     manager,
46     INF_TEXT_BUFFER(buffer),
47     io,
48     status,
49     sync_group,
50     sync_connection
51   );
52   g_object_unref(buffer);
53   return INF_SESSION(session);
54 }
55 static const InfcNotePlugin INF_TEST_TEXT_QUICK_WRITE_PLUGIN = {
56   NULL, "InfText", inf_test_text_quick_write_session_new
57 };
58 static void
59 inf_test_text_quick_write_reconnect(InfTestTextQuickWrite* test);
60 static void
61 inf_test_text_quick_write_schedule_next(InfTestTextQuickWrite* test);
62 static void
63 inf_test_text_quick_write_next_cb(gpointer user_data)
64 {
65   InfTestTextQuickWrite* test;
66   int action;
67   test = (InfTestTextQuickWrite*)user_data;
68   action = g_random_int_range(0, 100000);
69   if(action &lt; 50)
70   {
71     inf_test_text_quick_write_reconnect(test);
72   }
73   else if(action &lt; 90000)
74   {
75     inf_text_buffer_insert_text(
76       test-&gt;buffer,
77       MIN(test-&gt;content_pos, inf_text_buffer_get_length(test-&gt;buffer)),
78       &amp;test-&gt;content[test-&gt;content_pos],
79       1,
80       1,
81       test-&gt;user
82     );
83     ++test-&gt;content_pos;
84     if(test-&gt;content[test-&gt;content_pos] == '\0')
85       test-&gt;content_pos = 0;
86     inf_test_text_quick_write_schedule_next(test);
87   }
88   else
89   {
90     if(inf_text_buffer_get_length(test-&gt;buffer) &gt; 0 &amp;&amp; test-&gt;content_pos &gt; 0)
91     {
92       inf_text_buffer_erase_text(
93         test-&gt;buffer,
94         test-&gt;content_pos - 1,
95         1,
96         test-&gt;user
97       );
98       g_assert(test-&gt;content_length &gt; 0);
99       if(test-&gt;content_pos == 0)
100         test-&gt;content_pos = test-&gt;content_length - 1;
101       else
102         --test-&gt;content_pos;
103     }
104     inf_test_text_quick_write_schedule_next(test);
105   }
106 }
107 static void
108 inf_test_text_quick_write_schedule_next(InfTestTextQuickWrite* test)
109 {
110   int secs;
111   secs = g_random_int_range(10, 50);
112   inf_io_add_timeout(
113     INF_IO(test-&gt;io),
114     secs,
115     inf_test_text_quick_write_next_cb,
116     test,
117     NULL
118   );
119 }
120 static void
121 inf_test_text_quick_write_user_join_cb(InfRequest* request,
122                                        const InfRequestResult* result,
123                                        const GError* error,
124                                        gpointer user_data)
125 {
126 <a name="0"></a>  InfTestTextQuickWrite* test;
127   test = (InfTestTextQuickWrite*)user_data;
128 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if(error != NULL)
129   {
130     fprintf(stderr, "%s\n", error-&gt;message);
131     inf_standalone_io_loop_quit(test-&gt;io);
132   }
133   else
134   {
135     inf_request_result_get_join_user(result, NULL, &amp;test-&gt;user);
136     g_object_ref(test-&gt;user);
137     test-&gt;buffer = INF_TEXT_BUFFER(inf_session_get_buffer(test-&gt;session));
138     g_object_ref(test-&gt;buffer);
139     if(inf_text_buffer_get_length(test-&gt;buffer) &gt; 0)
140     {
141       inf_text_buffer_erase_text(
142         test-&gt;buffer,
143         0,
144         inf_text_buffer_get_length(test-&gt;buffer),
145         test-&gt;user
146       );
147     }
148     inf_test_text_quick_write_schedule_next(test);
149   }
150 }
151 static void</b></font>
152 inf_test_text_quick_write_join_user(InfTestTextQuickWrite* test)
153 {
154   inf_text_session_join_user(
155     test-&gt;proxy,
156     "TestUser",
157     INF_USER_ACTIVE,
158     0.0,
159     0,
160     0,
161     inf_test_text_quick_write_user_join_cb,
162     test
163   );
164 }
165 static void
166 inf_test_text_quick_write_session_notify_status_cb(GObject* object,
167                                                    GParamSpec* pspec,
168                                                    gpointer user_data)
169 {
170   InfTestTextQuickWrite* test;
171   test = (InfTestTextQuickWrite*)user_data;
172   if(inf_session_get_status(test-&gt;session) == INF_SESSION_RUNNING)
173     inf_test_text_quick_write_join_user(test);
174   if(inf_session_get_status(test-&gt;session) == INF_SESSION_CLOSED)
175   {
176     fprintf(stderr, "Session closed remotely\n");
177     inf_standalone_io_loop_quit(test-&gt;io);
178   }
179 }
180 static void
181 inf_test_text_quick_write_subscribe_cb(InfRequest* request,
182                                        const InfRequestResult* result,
183                                        const GError* error,
184                                        gpointer user_data)
185 {
186   InfTestTextQuickWrite* test;
187   test = (InfTestTextQuickWrite*)user_data;
188   if(error != NULL)
189   {
190     fprintf(stderr, "%s\n", error-&gt;message);
191     inf_standalone_io_loop_quit(test-&gt;io);
192   }
193   else
194   {
195     inf_request_result_get_subscribe_session(
196       result,
197       NULL,
198       NULL,
199       &amp;test-&gt;proxy
200     );
201     g_object_ref(test-&gt;proxy);
202     g_object_get(test-&gt;proxy, "session", &amp;test-&gt;session, NULL);
203     g_signal_connect(
204       G_OBJECT(test-&gt;session),
205       "notify::status",
206       G_CALLBACK(inf_test_text_quick_write_session_notify_status_cb),
207       test
208     );
209     if(inf_session_get_status(test-&gt;session) == INF_SESSION_RUNNING)
210       inf_test_text_quick_write_join_user(test);
211   }
212 }
213 static void
214 inf_test_text_quick_write_explore_cb(InfRequest* request,
215                                      const InfRequestResult* result,
216                                      const GError* error,
217                                      gpointer user_data)
218 {
219   InfTestTextQuickWrite* test;
220   InfBrowserIter iter;
221   gboolean have_iter;
222   test = (InfTestTextQuickWrite*)user_data;
223   if(error != NULL)
224   {
225     fprintf(stderr, "%s\n", error-&gt;message);
226     inf_standalone_io_loop_quit(test-&gt;io);
227   }
228   else
229   {
230     inf_browser_get_root(test-&gt;browser, &amp;iter);
231     for(have_iter = inf_browser_get_child(test-&gt;browser, &amp;iter);
232         have_iter == TRUE;
233         have_iter = inf_browser_get_next(test-&gt;browser, &amp;iter))
234     {
235       if(strcmp(inf_browser_get_node_name(test-&gt;browser, &amp;iter), "test") == 0)
236       {
237         inf_browser_subscribe(
238           test-&gt;browser,
239           &amp;iter,
240           inf_test_text_quick_write_subscribe_cb,
241           test
242         );
243         break;
244       }
245     }
246     if(have_iter == FALSE)
247     {
248       fprintf(stderr, "No document named /test\n");
249       inf_standalone_io_loop_quit(test-&gt;io);
250     }
251   }
252 }
253 static void
254 inf_test_text_quick_write_error_cb(InfcBrowser* browser,
255                                    GError* error,
256                                    gpointer user_data)
257 {
258   fprintf(stderr, "Connection error: %s\n", error-&gt;message);
259 }
260 static void
261 inf_test_text_quick_write_notify_status_cb(GObject* object,
262                                            GParamSpec* pspec,
263                                            gpointer user_data)
264 {
265   InfTestTextQuickWrite* test;
266   InfBrowserStatus status;
267   InfBrowserIter iter;
268   test = (InfTestTextQuickWrite*)user_data;
269   g_object_get(G_OBJECT(test-&gt;browser), "status", &amp;status, NULL);
270   if(status == INF_BROWSER_OPEN)
271   {
272     printf("Connection established\n");
273     inf_browser_get_root(test-&gt;browser, &amp;iter);
274     inf_browser_explore(
275       test-&gt;browser,
276       &amp;iter,
277       inf_test_text_quick_write_explore_cb,
278       test
279     );
280   }
281   if(status == INF_BROWSER_CLOSED)
282   {
283     if(inf_standalone_io_loop_running(test-&gt;io))
284       inf_standalone_io_loop_quit(test-&gt;io);
285   }
286 }
287 static void
288 inf_test_text_quick_write_disconnect(InfTestTextQuickWrite* test)
289 {
290   if(test-&gt;buffer != NULL)
291 <a name="1"></a>  {
292     g_object_unref(test-&gt;buffer);
293     test-&gt;buffer = NULL;
294 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
295   if(test-&gt;user != NULL)
296   {
297     g_object_unref(test-&gt;user);
298     test-&gt;user = NULL;
299   }
300   if(test-&gt;session != NULL)
301   {
302     inf_signal_handlers_disconnect_by_func(
303       G_OBJECT(test-&gt;session),
304       G_CALLBACK(inf_test_text_quick_write_session_notify_status_cb),
305       test
306     );
307     g_object_unref(test-&gt;session);
308     test-&gt;session = NULL;
309   }</b></font>
310   if(test-&gt;proxy != NULL)
311   {
312     g_object_unref(test-&gt;proxy);
313     test-&gt;proxy = NULL;
314   }
315   if(test-&gt;browser != NULL)
316   {
317     inf_signal_handlers_disconnect_by_func(
318       G_OBJECT(test-&gt;browser),
319       G_CALLBACK(inf_test_text_quick_write_notify_status_cb),
320       test
321     );
322     inf_signal_handlers_disconnect_by_func(
323       G_OBJECT(test-&gt;browser),
324       G_CALLBACK(inf_test_text_quick_write_error_cb),
325       test
326     );
327     g_object_unref(test-&gt;browser);
328     test-&gt;browser = NULL;
329   }
330   if(test-&gt;conn != NULL)
331   {
332     g_object_unref(test-&gt;conn);
333     test-&gt;conn = NULL;
334   }
335 }
336 static void
337 inf_test_text_quick_write_reconnect(InfTestTextQuickWrite* test)
338 {
339   const char* hostname;
340   InfNameResolver* resolver;
341   InfTcpConnection* tcp_conn;
342   InfCommunicationManager* manager;
343   GError* error;
344   test-&gt;content_pos = 0;
345   error = NULL;
346   inf_test_text_quick_write_disconnect(test);
347   hostname = "londeroth.org";
348   resolver = inf_name_resolver_new(
349     INF_IO(test-&gt;io),
350     hostname,
351     "6523",
352     "_infinote._tcp"
353   );
354   tcp_conn = inf_tcp_connection_new_resolve(INF_IO(test-&gt;io), resolver);
355   g_object_unref(resolver);
356   if(inf_tcp_connection_open(tcp_conn, &amp;error) == FALSE)
357   {
358     fprintf(stderr, "Could not open TCP connection: %s\n", error-&gt;message);
359     g_error_free(error);
360     g_object_unref(tcp_conn);
361     inf_standalone_io_loop_quit(test-&gt;io);
362   }
363   else
364   {
365     test-&gt;conn = inf_xmpp_connection_new(
366       tcp_conn,
367       INF_XMPP_CONNECTION_CLIENT,
368       NULL,
369       "localhost",
370       INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
371       test-&gt;credentials,
372       NULL,
373       NULL
374     );
375     g_object_unref(tcp_conn);
376     manager = inf_communication_manager_new();
377     test-&gt;browser = INF_BROWSER(
378       infc_browser_new(
379         INF_IO(test-&gt;io),
380         manager,
381         INF_XML_CONNECTION(test-&gt;conn)
382       )
383     );
384     g_object_unref(manager);
385     infc_browser_add_plugin(
386       INFC_BROWSER(test-&gt;browser),
387       &amp;INF_TEST_TEXT_QUICK_WRITE_PLUGIN
388     );
389     g_signal_connect_after(
390       G_OBJECT(test-&gt;browser),
391       "notify::status",
392       G_CALLBACK(inf_test_text_quick_write_notify_status_cb),
393       test
394     );
395     g_signal_connect(
396       G_OBJECT(test-&gt;browser),
397       "error",
398       G_CALLBACK(inf_test_text_quick_write_error_cb),
399       test
400     );
401   }
402 }
403 static void
404 inf_test_text_quick_write_start_cb(gpointer user_data)
405 {
406   inf_test_text_quick_write_reconnect((InfTestTextQuickWrite*)user_data);
407 }
408 static InfCertificateCredentials*
409 inf_test_text_quick_write_load_credentials(const char* filename,
410                                            GError** error)
411 {
412   InfCertificateCredentials* creds;
413   GPtrArray* certs;
414   gnutls_x509_privkey_t key;
415   guint i;
416   key = inf_cert_util_read_private_key(filename, error);
417   if(key == NULL) return NULL;
418   certs = inf_cert_util_read_certificate(filename, NULL, error);
419   if(certs == NULL)
420   {
421     gnutls_x509_privkey_deinit(key);
422     return NULL;
423   }
424   creds = inf_certificate_credentials_new();
425   gnutls_certificate_set_x509_key(
426     inf_certificate_credentials_get(creds),
427     (gnutls_x509_crt_t*)certs-&gt;pdata,
428     certs-&gt;len,
429     key
430   );
431   gnutls_certificate_set_x509_trust(
432     inf_certificate_credentials_get(creds),
433     (gnutls_x509_crt_t*)&amp;certs-&gt;pdata[certs-&gt;len - 1],
434     certs-&gt;len
435   );
436   gnutls_x509_privkey_deinit(key);
437   for(i = 0; i &lt; certs-&gt;len; ++i)
438     gnutls_x509_crt_deinit(certs-&gt;pdata[i]);
439   g_ptr_array_free(certs, TRUE);
440   return creds;
441 }
442 int
443 main(int argc, char* argv[])
444 {
445   guint32 seed;
446   const gchar* filename;
447   const gchar* credentials;
448   InfTestTextQuickWrite test;
449   GError* error;
450   error = NULL;
451   if(!inf_init(&amp;error))
452   {
453     fprintf(stderr, "%s\n", error-&gt;message);
454     return 1;
455   }
456   seed = time(NULL);
457   printf("Random seed: %u\n", seed);
458   g_random_set_seed(seed);
459   if(argc &lt; 2)
460     filename = "inf-test-quick-write.c";
461   else
462     filename = argv[1];
463   credentials = NULL;
464   g_file_get_contents(filename, &amp;test.content, &amp;test.content_length, &amp;error);
465   if(error != NULL)
466   {
467     fprintf(stderr, "%s: %s\n", filename, error-&gt;message);
468     g_error_free(error);
469     return 1;
470   }
471   if(test.content_length == 0)
472   {
473     fprintf(stderr, "%s: File is empty\n", filename);
474     return 1;
475   }
476   test.credentials = NULL;
477   test.io = NULL;
478   test.conn = NULL;
479   test.browser = NULL;
480   test.proxy = NULL;
481   test.session = NULL;
482   test.user = NULL;
483   test.buffer = NULL;
484   if(credentials != NULL)
485   {
486     test.credentials = inf_test_text_quick_write_load_credentials(
487       credentials,
488       &amp;error
489     );
490     if(test.credentials == NULL)
491     {
492       fprintf(stderr, "%s\n", error-&gt;message);
493       g_error_free(error);
494       return 1;
495     }
496   }
497   test.io = inf_standalone_io_new();
498   inf_io_add_dispatch(
499     INF_IO(test.io),
500     inf_test_text_quick_write_start_cb,
501     &amp;test,
502     NULL
503   );
504   inf_standalone_io_loop(test.io);
505   g_object_unref(test.io);
506   inf_certificate_credentials_unref(test.credentials);
507   g_free(test.content);
508   return 0;
509 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
