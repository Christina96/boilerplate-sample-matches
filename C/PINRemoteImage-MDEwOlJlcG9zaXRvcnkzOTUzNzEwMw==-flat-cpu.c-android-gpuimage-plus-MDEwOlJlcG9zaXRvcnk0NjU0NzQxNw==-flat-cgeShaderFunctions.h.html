
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.050632911392405%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cpu.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_HAVE_NEON_RTCD)
3  #include <stdio.h>
4  #include <string.h>
5  #endif
6  #if defined(WEBP_ANDROID_NEON)
7  #include <cpu-features.h>
8  #endif
9  #if (defined(__pic__) || defined(__PIC__)) && defined(__i386__)
10  static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
11    __asm__ volatile (
12      "mov %%ebx, %%edi\n"
13      "cpuid\n"
14      "xchg %%edi, %%ebx\n"
15      : "=a"(cpu_info[0]), "=D"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
16      : "a"(info_type), "c"(0));
17  }
18  #elif defined(__x86_64__) && \
19        (defined(__code_model_medium__) || defined(__code_model_large__)) && \
20        defined(__PIC__)
21  static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
22    __asm__ volatile (
23      "xchg{q}\t{%%rbx}, %q1\n"
24      "cpuid\n"
25      "xchg{q}\t{%%rbx}, %q1\n"
26      : "=a"(cpu_info[0]), "=&r"(cpu_info[1]), "=c"(cpu_info[2]),
27        "=d"(cpu_info[3])
28      : "a"(info_type), "c"(0));
29  }
30  #elif defined(__i386__) || defined(__x86_64__)
31  static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
32    __asm__ volatile (
33      "cpuid\n"
34      : "=a"(cpu_info[0]), "=b"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
35      : "a"(info_type), "c"(0));
36  }
37  #elif (defined(_M_X64) || defined(_M_IX86)) && \
38        defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 150030729  
39  #include <intrin.h>
40  #define GetCPUInfo(info, type) __cpuidex(info, type, 0)  
41  #elif defined(WEBP_MSC_SSE2)
42  #define GetCPUInfo __cpuid
43  #endif
44  #if !defined(__native_client__) && (defined(__i386__) || defined(__x86_64__))
45  static WEBP_INLINE uint64_t xgetbv(void) {
46    const uint32_t ecx = 0;
47    uint32_t eax, edx;
48    __asm__ volatile (
49      ".byte 0x0f, 0x01, 0xd0\n"
50      : "=a"(eax), "=d"(edx) : "c" (ecx));
51    return ((uint64_t)edx << 32) | eax;
52  }
53  #elif (defined(_M_X64) || defined(_M_IX86)) && \
54        defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 160040219  
55  #include <immintrin.h>
56  #define xgetbv() _xgetbv(0)
57  #elif defined(_MSC_VER) && defined(_M_IX86)
58  static WEBP_INLINE uint64_t xgetbv(void) {
59    uint32_t eax_, edx_;
60    __asm {
61      xor ecx, ecx  
62      __asm _emit 0x0f __asm _emit 0x01 __asm _emit 0xd0
63      mov eax_, eax
64      mov edx_, edx
65    }
66    return ((uint64_t)edx_ << 32) | eax_;
67  }
68  #else
69  #define xgetbv() 0U  
70  #endif
71  #if defined(__i386__) || defined(__x86_64__) || defined(WEBP_MSC_SSE2)
72  static int CheckSlowModel(int info) {
73    static const uint8_t kSlowModels[] = {
74      0x37, 0x4a, 0x4d,  
75      0x1c, 0x26, 0x27   
76    };
77    const uint32_t model = ((info & 0xf0000) >> 12) | ((info >> 4) & 0xf);
78    const uint32_t family = (info >> 8) & 0xf;
79    if (family == 0x06) {
80      size_t i;
81      for (i = 0; i < sizeof(kSlowModels) / sizeof(kSlowModels[0]); ++i) {
82        if (model == kSlowModels[i]) return 1;
83      }
84    }
85    return 0;
86  }
87  static int x86CPUInfo(CPUFeature feature) {
88    int max_cpuid_value;
89    int cpu_info[4];
90    int is_intel = 0;
91    GetCPUInfo(cpu_info, 0);
92    max_cpuid_value = cpu_info[0];
93    if (max_cpuid_value < 1) {
94      return 0;
95    } else {
<span onclick='openModal()' class='match'>96      const int VENDOR_ID_INTEL_EBX = 0x756e6547;  
97      const int VENDOR_ID_INTEL_EDX = 0x49656e69;  
98      const int VENDOR_ID_INTEL_ECX = 0x6c65746e;  
</span>99      is_intel = (cpu_info[1] == VENDOR_ID_INTEL_EBX &&
100                  cpu_info[2] == VENDOR_ID_INTEL_ECX &&
101                  cpu_info[3] == VENDOR_ID_INTEL_EDX);    
102    }
103    GetCPUInfo(cpu_info, 1);
104    if (feature == kSSE2) {
105      return !!(cpu_info[3] & (1 << 26));
106    }
107    if (feature == kSSE3) {
108      return !!(cpu_info[2] & (1 << 0));
109    }
110    if (feature == kSlowSSSE3) {
111      if (is_intel && (cpu_info[2] & (1 << 9))) {   
112        return CheckSlowModel(cpu_info[0]);
113      }
114      return 0;
115    }
116    if (feature == kSSE4_1) {
117      return !!(cpu_info[2] & (1 << 19));
118    }
119    if (feature == kAVX) {
120      if ((cpu_info[2] & 0x18000000) == 0x18000000) {
121        return (xgetbv() & 0x6) == 0x6;
122      }
123    }
124    if (feature == kAVX2) {
125      if (x86CPUInfo(kAVX) && max_cpuid_value >= 7) {
126        GetCPUInfo(cpu_info, 7);
127        return !!(cpu_info[1] & (1 << 5));
128      }
129    }
130    return 0;
131  }
132  VP8CPUInfo VP8GetCPUInfo = x86CPUInfo;
133  #elif defined(WEBP_ANDROID_NEON)  
134  static int AndroidCPUInfo(CPUFeature feature) {
135    const AndroidCpuFamily cpu_family = android_getCpuFamily();
136    const uint64_t cpu_features = android_getCpuFeatures();
137    if (feature == kNEON) {
138      return cpu_family == ANDROID_CPU_FAMILY_ARM &&
139             (cpu_features & ANDROID_CPU_ARM_FEATURE_NEON) != 0;
140    }
141    return 0;
142  }
143  VP8CPUInfo VP8GetCPUInfo = AndroidCPUInfo;
144  #elif defined(WEBP_USE_NEON)
145  static int armCPUInfo(CPUFeature feature) {
146    if (feature != kNEON) return 0;
147  #if defined(__linux__) && defined(WEBP_HAVE_NEON_RTCD)
148    {
149      int has_neon = 0;
150      char line[200];
151      FILE* const cpuinfo = fopen("/proc/cpuinfo", "r");
152      if (cpuinfo == NULL) return 0;
153      while (fgets(line, sizeof(line), cpuinfo)) {
154        if (!strncmp(line, "Features", 8)) {
155          if (strstr(line, " neon ") != NULL) {
156            has_neon = 1;
157            break;
158          }
159        }
160      }
161      fclose(cpuinfo);
162      return has_neon;
163    }
164  #else
165    return 1;
166  #endif
167  }
168  VP8CPUInfo VP8GetCPUInfo = armCPUInfo;
169  #elif defined(WEBP_USE_MIPS32) || defined(WEBP_USE_MIPS_DSP_R2) || \
170        defined(WEBP_USE_MSA)
171  static int mipsCPUInfo(CPUFeature feature) {
172    if ((feature == kMIPS32) || (feature == kMIPSdspR2) || (feature == kMSA)) {
173      return 1;
174    } else {
175      return 0;
176    }
177  }
178  VP8CPUInfo VP8GetCPUInfo = mipsCPUInfo;
179  #else
180  VP8CPUInfo VP8GetCPUInfo = NULL;
181  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeShaderFunctions.h</h3>
            <pre><code>1  &bsol;*
2   * cgeShaderFunctions.h
3   *
4   *  Created on: 2013-12-6
5   *      Author: Wang Yang
6   */
7  #ifndef _CGESAHDERFUNCTIONS_H_
8  #define _CGESAHDERFUNCTIONS_H_
9  #include "cgeCommonDefine.h"
10  #include "cgeGLFunctions.h"
11  #include <cstring>
12  namespace CGE
13  {
14  class ShaderObject
15  {
16  private:
17      explicit ShaderObject(const ShaderObject&) {}
18  public:
19      ShaderObject();
20      ~ShaderObject();
21      bool init(GLenum shaderType);
22      bool loadShaderSourceFromString(const char* shaderString);
23      inline GLuint shaderID() { return m_shaderID; }
24      inline GLenum shaderType() { return m_shaderType; }
25      void clear();
26  private:
27      GLenum m_shaderType;
28      GLuint m_shaderID;
29  };
30  class CGEImageHandlerInterface;
31  class UniformParameters
32  {
33  public:
34      ~UniformParameters();
35      typedef enum UNIFORM_TYPE
36      {
37          uniformBOOL,
38          uniformBOOLV2,
39          uniformBOOLV3,
40          uniformBOOLV4,
41          uniformINT,
42          uniformINTV2,
43          uniformINTV3,
44          uniformINTV4,
45          uniformFLOAT,
46          uniformFLOATV2,
47          uniformFLOATV3,
48          uniformFLOATV4,
49          uniformSAMPLER1D,
50          uniformSAMPLER2D,
51          uniformStepsFactor,
52          uniformRatioAspect,
53          uniformStepsRatio,
54      } UNIFORM_TYPE;
55      typedef union UniformValue
56      {
57          GLfloat valuef;
58          GLint valuei;
59          GLuint* valuePtr;
60      } UniformValue;
61      typedef struct UniformData
62      {
63          UniformData() {}
64          UniformData(const char* name, UNIFORM_TYPE type) :
65              uniformType(type) { strncpy(uniformName, name, CGE_UNIFORM_MAX_LEN); }
66          inline void setValuesi(GLint x, GLint y = 0, GLint z = 0, GLint w = 0)
67          {
68              uniformValue[0].valuei = x;
69              uniformValue[1].valuei = y;
70              uniformValue[2].valuei = z;
71              uniformValue[3].valuei = w;
72          }
73          inline void setValuesf(GLfloat x, GLfloat y = 0, GLfloat z = 0, GLfloat w = 0)
74          {
75              uniformValue[0].valuef = x;
76              uniformValue[1].valuef = y;
77              uniformValue[2].valuef = z;
78              uniformValue[3].valuef = w;
79          }
80          char uniformName[CGE_UNIFORM_MAX_LEN];
81          UNIFORM_TYPE uniformType;
82          UniformValue uniformValue[4];
83      } UniformData;
84      void pushi(const char* name, GLint);
85      void pushi(const char* name, GLint, GLint);
86      void pushi(const char* name, GLint, GLint, GLint);
87      void pushi(const char* name, GLint, GLint, GLint, GLint);
88      void pushf(const char* name, GLfloat);
89      void pushf(const char* name, GLfloat, GLfloat);
90      void pushf(const char* name, GLfloat, GLfloat, GLfloat);
91      void pushf(const char* name, GLfloat, GLfloat, GLfloat, GLfloat);
92      void pushSampler1D(const char* name, GLuint* textureID, GLint textureBindID);
93      void pushSampler2D(const char* name, GLuint* textureID, GLint textureBindID);
94      void requireStepsFactor(const char* name);
<span onclick='openModal()' class='match'>95      void requireRatioAspect(const char* name, GLfloat texAspectRatio = 1.0f);
96      void requireStepsRatio(const char* name, GLfloat texAspectRatio = 1.0f);
97      void clear();
98      void assignUniforms(CGEImageHandlerInterface* handler, GLuint programID);
99      UniformData* getDataPointerByName(const char* name);
</span>100  private:
101      std::vector<UniformData*> m_vecUniforms;
102  };
103  class ProgramObject
104  {
105  public:
106      ProgramObject();
107      ~ProgramObject();
108      explicit ProgramObject(const ProgramObject&) = delete;
109      bool initWithComputeShader(const char* csh);
110      bool initWithShaderStrings(const char* vsh, const char* fsh);
111      bool initFragmentShaderSourceFromString(const char* fragShader);
112      bool initVertexShaderSourceFromString(const char* vertShader);
113      bool linkWithShaderObject(ShaderObject& vertObj, ShaderObject& fragObj, bool shouldClear = true);
114      inline bool link() { return linkWithShaderObject(m_vertShader, m_fragOrComputeShader); }
115      inline void bind() { glUseProgram(m_programID); }
116      inline void sendUniformf(const char* name, GLfloat x)
117      {
118          GLint uniform = _getUniform(m_programID, name);
119          glUniform1f(uniform, x);
120      }
121      inline void sendUniformf(const char* name, GLfloat x, GLfloat y)
122      {
123          GLint uniform = _getUniform(m_programID, name);
124          glUniform2f(uniform, x, y);
125      }
126      inline void sendUniformf(const char* name, GLfloat x, GLfloat y, GLfloat z)
127      {
128          GLint uniform = _getUniform(m_programID, name);
129          glUniform3f(uniform, x, y, z);
130      }
131      inline void sendUniformf(const char* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
132      {
133          GLint uniform = _getUniform(m_programID, name);
134          glUniform4f(uniform, x, y, z, w);
135      }
136      inline void sendUniformi(const char* name, GLint x)
137      {
138          GLint uniform = _getUniform(m_programID, name);
139          glUniform1i(uniform, x);
140      }
141      inline void sendUniformi(const char* name, GLint x, GLint y)
142      {
143          GLint uniform = _getUniform(m_programID, name);
144          glUniform2i(uniform, x, y);
145      }
146      inline void sendUniformi(const char* name, GLint x, GLint y, GLint z)
147      {
148          GLint uniform = _getUniform(m_programID, name);
149          glUniform3i(uniform, x, y, z);
150      }
151      inline void sendUniformi(const char* name, GLint x, GLint y, GLint z, GLint w)
152      {
153          GLint uniform = _getUniform(m_programID, name);
154          glUniform4i(uniform, x, y, z, w);
155      }
156      inline void sendUniformMat2(const char* name, int count, GLboolean transpose, const GLfloat* matrix)
157      {
158          GLint uniform = _getUniform(m_programID, name);
159          glUniformMatrix2fv(uniform, count, transpose, matrix);
160      }
161      inline void sendUniformMat3(const char* name, GLsizei count, GLboolean transpose, const GLfloat* matrix)
162      {
163          GLint uniform = _getUniform(m_programID, name);
164          glUniformMatrix3fv(uniform, count, transpose, matrix);
165      }
166      inline void sendUniformMat4(const char* name, GLsizei count, GLboolean transpose, const GLfloat* matrix)
167      {
168          GLint uniform = _getUniform(m_programID, name);
169          glUniformMatrix4fv(uniform, count, transpose, matrix);
170      }
171      inline GLuint programID() { return m_programID; }
172      inline GLint attributeLocation(const char* name) { return glGetAttribLocation(m_programID, name); }
173      inline GLint uniformLocation(const char* name) { return glGetUniformLocation(m_programID, name); }
174      inline void bindAttribLocation(const char* name, GLuint index) { glBindAttribLocation(m_programID, index, name); }
175  protected:
176      inline GLint _getUniform(GLuint programId, const char* name)
177      {
178          GLint uniform = glGetUniformLocation(programId, name);
179          CGE_LOG_CODE(
180              if (uniform < 0)
181                  CGE_LOG_ERROR("uniform name %s does not exist!\n", name););
182          return uniform;
183      }
184  private:
185      ShaderObject m_vertShader, m_fragOrComputeShader;
186      GLuint m_programID;
187  };
188  } 
189  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cpu.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeShaderFunctions.h</div>
                </div>
                <div class="column column_space"><pre><code>96      const int VENDOR_ID_INTEL_EBX = 0x756e6547;  
97      const int VENDOR_ID_INTEL_EDX = 0x49656e69;  
98      const int VENDOR_ID_INTEL_ECX = 0x6c65746e;  
</pre></code></div>
                <div class="column column_space"><pre><code>95      void requireRatioAspect(const char* name, GLfloat texAspectRatio = 1.0f);
96      void requireStepsRatio(const char* name, GLfloat texAspectRatio = 1.0f);
97      void clear();
98      void assignUniforms(CGEImageHandlerInterface* handler, GLuint programID);
99      UniformData* getDataPointerByName(const char* name);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    