<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lmcry_gcry.c &amp; omfile.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lmcry_gcry.c &amp; omfile.c
      </h3>
<h1 align="center">
        9.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lmcry_gcry.c (28.333334%)<th>omfile.c (5.811966%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(48-65)<td><a href="#" name="0">(242-260)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(120-135)<td><a href="#" name="1">(1253-1272)</a><td align="center"><font color="#8b0000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(143-151)<td><a href="#" name="2">(1319-1326)</a><td align="center"><font color="#830000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lmcry_gcry.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;errno.h&gt;
7 #include "module-template.h"
8 #include "glbl.h"
9 #include "errmsg.h"
10 #include "cryprov.h"
11 #include "parserif.h"
12 #include "libgcry.h"
13 #include "lmcry_gcry.h"
14 MODULE_TYPE_LIB
15 MODULE_TYPE_NOKEEP
16 DEFobjStaticHelpers
17 DEFobjCurrIf(glbl)
18 <a name="0"></a>
19 static struct cnfparamdescr cnfpdescrRegular[] = {
20 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "cry.key", eCmdHdlrGetWord, 0 },
21 	{ "cry.keyfile", eCmdHdlrGetWord, 0 },
22 	{ "cry.keyprogram", eCmdHdlrGetWord, 0 },
23 	{ "cry.mode", eCmdHdlrGetWord, 0 }, 	{ "cry.algo", eCmdHdlrGetWord, 0 }
24 };
25 static struct cnfparamblk pblkRegular =
26 	{ CNFPARAMBLK_VERSION,
27 	  sizeof(cnfpdescrRegular)/sizeof(struct cnfparamdescr),
28 	  cnfpdescrRegular
29 	};
30 static struct cnfparamdescr cnfpdescrQueue[] = {
31 	{ "queue.cry.key", eCmdHdlrGetWord, 0 },
32 	{ "queue.cry.keyfile", eCmdHdlrGetWord, 0 },
33 	{ "queue.cry.keyprogram", eCmdHdlrGetWord, 0 },
34 	{ "queue.cry.mode", eCmdHdlrGetWord, 0 }, 	{ "queue.cry.algo", eCmdHdlrGetWord, 0 }</b></font>
35 };
36 static struct cnfparamblk pblkQueue =
37 	{ CNFPARAMBLK_VERSION,
38 	  sizeof(cnfpdescrQueue)/sizeof(struct cnfparamdescr),
39 	  cnfpdescrQueue
40 	};
41 #if 0
42 static void
43 errfunc(__attribute__((unused)) void *usrptr, uchar *emsg)
44 {
45 	LogError(0, RS_RET_CRYPROV_ERR, "Crypto Provider"
46 		"Error: %s - disabling encryption", emsg);
47 }
48 #endif
49 BEGINobjConstruct(lmcry_gcry)
50 	CHKmalloc(pThis-&gt;ctx = gcryCtxNew());
51 finalize_it:
52 ENDobjConstruct(lmcry_gcry)
53 BEGINobjDestruct(lmcry_gcry) CODESTARTobjDestruct(lmcry_gcry)
54 	rsgcryCtxDel(pThis-&gt;ctx);
55 ENDobjDestruct(lmcry_gcry)
56 static rsRetVal
57 SetCnfParam(void *pT, struct nvlst *lst, int paramType)
58 {
59 	lmcry_gcry_t *pThis = (lmcry_gcry_t*) pT;
60 	int i, r;
61 	unsigned keylen = 0;
62 	uchar *key = NULL;
63 	uchar *keyfile = NULL;
64 	uchar *keyprogram = NULL;
65 	uchar *algo = NULL;
66 	uchar *mode = NULL;
67 	int nKeys; 	struct cnfparamvals *pvals;
68 	struct cnfparamblk *pblk;
69 	DEFiRet;
70 <a name="1"></a>
71 	pblk = (paramType == CRYPROV_PARAMTYPE_REGULAR ) ?  &amp;pblkRegular : &amp;pblkQueue;
72 	nKeys = 0;
73 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pvals = nvlstGetParams(lst, pblk, NULL);
74 	if(pvals == NULL) {
75 		parser_errmsg("error crypto provider gcryconfig parameters]");
76 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
77 	}
78 	if(Debug) {
79 		dbgprintf("param blk in lmcry_gcry:\n");
80 		cnfparamsPrint(pblk, pvals);
81 	}
82 	for(i = 0 ; i &lt; pblk-&gt;nParams ; ++i) {
83 		if(!pvals[i].bUsed)
84 			continue;
85 		if(!strcmp(pblk-&gt;descr[i].name, "cry.key") ||
86 		   !strcmp(pblk-&gt;descr[i].name, "queue.cry.key")) {
87 			key = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
88 			++nKeys;
89 		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.keyfile") ||
90 		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.keyfile")) {
91 			keyfile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
92 <a name="2"></a>			++nKeys;
93 		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.keyprogram") ||
94 		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.keyprogram")) {
95 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			keyprogram = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
96 			++nKeys;
97 		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.mode") ||
98 		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.mode")) {
99 			mode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
100 		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.algo") ||
101 		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.algo")) {
102 			algo = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
103 		} else {</b></font>
104 			DBGPRINTF("lmcry_gcry: program error, non-handled "
105 			  "param '%s'\n", pblk-&gt;descr[i].name);
106 		}
107 	}
108 	if(algo != NULL) {
109 		iRet = rsgcrySetAlgo(pThis-&gt;ctx, algo);
110 		if(iRet != RS_RET_OK) {
111 			LogError(0, iRet, "cry.algo '%s' is not know/supported", algo);
112 			FINALIZE;
113 		}
114 	}
115 	if(mode != NULL) {
116 		iRet = rsgcrySetMode(pThis-&gt;ctx, mode);
117 		if(iRet != RS_RET_OK) {
118 			LogError(0, iRet, "cry.mode '%s' is not know/supported", mode);
119 			FINALIZE;
120 		}
121 	}
122 	if(nKeys != 1) {
123 		LogError(0, RS_RET_INVALID_PARAMS, "excactly one of the following "
124 			"parameters can be specified: cry.key, cry.keyfile, cry.keyprogram\n");
125 		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
126 	}
127 	if(key != NULL) {
128 		LogError(0, RS_RET_ERR, "Note: specifying an actual key directly from the "
129 			"config file is highly insecure - DO NOT USE FOR PRODUCTION");
130 		keylen = strlen((char*)key);
131 	}
132 	if(keyfile != NULL) {
133 		r = gcryGetKeyFromFile((char*)keyfile, (char**)&amp;key, &amp;keylen);
134 		if(r != 0) {
135 			LogError(errno, RS_RET_ERR, "error reading keyfile %s",
136 				keyfile);
137 			ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
138 		}
139 	}
140 	if(keyprogram != NULL) {
141 		r = gcryGetKeyFromProg((char*)keyprogram, (char**)&amp;key, &amp;keylen);
142 		if(r != 0) {
143 			LogError(0, RS_RET_ERR, "error %d obtaining key from program %s\n",
144 				r, keyprogram);
145 			ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
146 		}
147 	}
148 	r = rsgcrySetKey(pThis-&gt;ctx, key, keylen);
149 	if(r &gt; 0) {
150 		LogError(0, RS_RET_INVALID_PARAMS, "Key length %d expected, but "
151 			"key of length %d given", r, keylen);
152 		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
153 	}
154 finalize_it:
155 	free(key);
156 	free(keyfile);
157 	free(algo);
158 	free(keyprogram);
159 	free(mode);
160 	if(pvals != NULL)
161 		cnfparamvalsDestruct(pvals, pblk);
162 	RETiRet;
163 }
164 static void
165 SetDeleteOnClose(void *pF, int val)
166 {
167 	gcryfileSetDeleteOnClose(pF, val);
168 }
169 static rsRetVal
170 GetBytesLeftInBlock(void *pF, ssize_t *left)
171 {
172 	return gcryfileGetBytesLeftInBlock((gcryfile) pF, left);
173 }
174 static rsRetVal
175 DeleteStateFiles(uchar *logfn)
176 {
177 	return gcryfileDeleteState(logfn);
178 }
179 static rsRetVal
180 OnFileOpen(void *pT, uchar *fn, void *pGF, char openMode)
181 {
182 	lmcry_gcry_t *pThis = (lmcry_gcry_t*) pT;
183 	gcryfile *pgf = (gcryfile*) pGF;
184 	DEFiRet;
185 	DBGPRINTF("lmcry_gcry: open file '%s', mode '%c'\n", fn, openMode);
186 	iRet = rsgcryInitCrypt(pThis-&gt;ctx, pgf, fn, openMode);
187 	if(iRet != RS_RET_OK) {
188 		LogError(0, iRet, "Encryption Provider"
189 			"Error: cannot open .encinfo file - disabling log file");
190 	}
191 	RETiRet;
192 }
193 static rsRetVal
194 Decrypt(void *pF, uchar *rec, size_t *lenRec)
195 {
196 	DEFiRet;
197 	iRet = rsgcryDecrypt(pF, rec, lenRec);
198 	RETiRet;
199 }
200 static rsRetVal
201 Encrypt(void *pF, uchar *rec, size_t *lenRec)
202 {
203 	DEFiRet;
204 	iRet = rsgcryEncrypt(pF, rec, lenRec);
205 	RETiRet;
206 }
207 static rsRetVal
208 OnFileClose(void *pF, off64_t offsLogfile)
209 {
210 	DEFiRet;
211 	gcryfileDestruct(pF, offsLogfile);
212 	RETiRet;
213 }
214 BEGINobjQueryInterface(lmcry_gcry)
215 CODESTARTobjQueryInterface(lmcry_gcry)
216 	 if(pIf-&gt;ifVersion != cryprovCURR_IF_VERSION) {		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
217 	}
218 	pIf-&gt;Construct = (rsRetVal(*)(void*)) lmcry_gcryConstruct;
219 	pIf-&gt;SetCnfParam = SetCnfParam;
220 	pIf-&gt;SetDeleteOnClose = SetDeleteOnClose;
221 	pIf-&gt;Destruct = (rsRetVal(*)(void*)) lmcry_gcryDestruct;
222 	pIf-&gt;OnFileOpen = OnFileOpen;
223 	pIf-&gt;Encrypt = Encrypt;
224 	pIf-&gt;Decrypt = Decrypt;
225 	pIf-&gt;OnFileClose = OnFileClose;
226 	pIf-&gt;DeleteStateFiles = DeleteStateFiles;
227 	pIf-&gt;GetBytesLeftInBlock = GetBytesLeftInBlock;
228 finalize_it:
229 ENDobjQueryInterface(lmcry_gcry)
230 BEGINObjClassExit(lmcry_gcry, OBJ_IS_LOADABLE_MODULE) CODESTARTObjClassExit(lmcry_gcry)
231 	objRelease(glbl, CORE_COMPONENT);
232 	rsgcryExit();
233 ENDObjClassExit(lmcry_gcry)
234 BEGINObjClassInit(lmcry_gcry, 1, OBJ_IS_LOADABLE_MODULE) 	CHKiRet(objUse(glbl, CORE_COMPONENT));
235 	if(rsgcryInit() != 0) {
236 		LogError(0, RS_RET_CRYPROV_ERR, "error initializing "
237 			"crypto provider - cannot encrypt");
238 		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
239 	}
240 ENDObjClassInit(lmcry_gcry)
241 BEGINmodExit
242 CODESTARTmodExit
243 	lmcry_gcryClassExit();
244 ENDmodExit
245 BEGINqueryEtryPt
246 CODESTARTqueryEtryPt
247 CODEqueryEtryPt_STD_LIB_QUERIES
248 ENDqueryEtryPt
249 BEGINmodInit()
250 CODESTARTmodInit
251 	*ipIFVersProvided = CURR_MOD_IF_VERSION; 	CHKiRet(lmcry_gcryClassInit(pModInfo)); ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omfile.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;time.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;errno.h&gt;
9 #include &lt;ctype.h&gt;
10 #include &lt;libgen.h&gt;
11 #include &lt;unistd.h&gt;
12 #include &lt;sys/file.h&gt;
13 #include &lt;fcntl.h&gt;
14 #ifdef HAVE_ATOMIC_BUILTINS
15 #	include &lt;pthread.h&gt;
16 #endif
17 #include "rsyslog.h"
18 #include "conf.h"
19 #include "syslogd-types.h"
20 #include "srUtils.h"
21 #include "template.h"
22 #include "outchannel.h"
23 #include "omfile.h"
24 #include "cfsysline.h"
25 #include "module-template.h"
26 #include "errmsg.h"
27 #include "stream.h"
28 #include "unicode-helper.h"
29 #include "atomic.h"
30 #include "statsobj.h"
31 #include "sigprov.h"
32 #include "cryprov.h"
33 #include "parserif.h"
34 #include "janitor.h"
35 #include "rsconf.h"
36 MODULE_TYPE_OUTPUT
37 MODULE_TYPE_NOKEEP
38 MODULE_CNFNAME("omfile")
39 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
40 DEF_OMOD_STATIC_DATA
41 DEFobjCurrIf(strm)
42 DEFobjCurrIf(statsobj)
43 #ifdef HAVE_ATOMIC_BUILTINS64
44 static uint64 clockFileAccess = 0;
45 #else
46 static unsigned clockFileAccess = 0;
47 #endif
48 #ifndef HAVE_ATOMIC_BUILTINS
49 static pthread_mutex_t mutClock;
50 #endif
51 static uint64
52 getClockFileAccess(void)
53 {
54 #ifdef HAVE_ATOMIC_BUILTINS64
55 	return ATOMIC_INC_AND_FETCH_uint64(&amp;clockFileAccess, &amp;mutClock);
56 #else
57 	return ATOMIC_INC_AND_FETCH_unsigned(&amp;clockFileAccess, &amp;mutClock);
58 #endif
59 }
60 struct s_dynaFileCacheEntry {
61 	uchar *pName;			strm_t	*pStrm;			void	*sigprovFileData;		uint64	clkTickAccessed;	short nInactive;	};
62 typedef struct s_dynaFileCacheEntry dynaFileCacheEntry;
63 #define IOBUF_DFLT_SIZE 4096	#define FLUSH_INTRVL_DFLT 1 	#define USE_ASYNCWRITER_DFLT 0 	#define FLUSHONTX_DFLT 1 	
64 typedef struct _instanceData {
65 	pthread_mutex_t mutWrite; 	uchar	*fname;		uchar 	*tplName;		strm_t	*pStrm;			short nInactive;		char	bDynamicName;		int	fCreateMode;		int	fDirCreateMode;		int	bCreateDirs;		int	bSyncFile;		uint8_t iNumTpls;		uid_t	fileUID;		uid_t	dirUID;
66 	gid_t	fileGID;
67 	gid_t	dirGID;
68 	dynaFileCacheEntry **dynCache;
69 	off_t	iSizeLimit;			uchar	*pszSizeLimitCmd;		int 	iZipLevel;			int	iIOBufSize;			int	iFlushInterval;			short	iCloseTimeout;			sbool	bFlushOnTXEnd;			sbool	bUseAsyncWriter;		sbool	bVeryRobustZip;
70 	statsobj_t *stats;			STATSCOUNTER_DEF(ctrRequests, mutCtrRequests);
71 	STATSCOUNTER_DEF(ctrLevel0, mutCtrLevel0);
72 	STATSCOUNTER_DEF(ctrEvict, mutCtrEvict);
73 	STATSCOUNTER_DEF(ctrMiss, mutCtrMiss);
74 	STATSCOUNTER_DEF(ctrMax, mutCtrMax);
75 	STATSCOUNTER_DEF(ctrCloseTimeouts, mutCtrCloseTimeouts);
76 	char janitorID[128];		} instanceData;
77 typedef struct wrkrInstanceData {
78 	instanceData *pData;
79 } wrkrInstanceData_t;
80 typedef struct configSettings_s {
81 	int iDynaFileCacheSize; 	int fCreateMode; 	int fDirCreateMode; 	int	bFailOnChown;		uid_t	fileUID;		uid_t	fileGID;		uid_t	dirUID;			uid_t	dirGID;			int	bCreateDirs;	int	bEnableSync;	int	iZipLevel;		sbool	bFlushOnTXEnd;	int64	iIOBufSize;		int	iFlushInterval; 		int	bUseAsyncWriter;		EMPTY_STRUCT
82 } configSettings_t;
83 static configSettings_t cs;
84 uchar	*pszFileDfltTplName; 
85 struct modConfData_s {
86 	rsconf_t *pConf;		uchar 	*tplName;		int fCreateMode; 	int fDirCreateMode; 	uid_t fileUID;		uid_t dirUID;
87 	gid_t fileGID;
88 	gid_t dirGID;
89 	int bDynafileDoNotSuspend;
90 };
91 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
92 static struct cnfparamdescr modpdescr[] = {
93 	{ "template", eCmdHdlrGetWord, 0 },
94 	{ "dircreatemode", eCmdHdlrFileCreateMode, 0 },
95 	{ "filecreatemode", eCmdHdlrFileCreateMode, 0 },
96 	{ "dirowner", eCmdHdlrUID, 0 },
97 <a name="0"></a>	{ "dirownernum", eCmdHdlrInt, 0 },
98 	{ "dirgroup", eCmdHdlrGID, 0 },
99 	{ "dirgroupnum", eCmdHdlrInt, 0 },
100 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "fileowner", eCmdHdlrUID, 0 },
101 	{ "fileownernum", eCmdHdlrInt, 0 },
102 	{ "filegroup", eCmdHdlrGID, 0 },
103 	{ "dynafile.donotsuspend", eCmdHdlrBinary, 0 },
104 	{ "filegroupnum", eCmdHdlrInt, 0 },
105 };
106 static struct cnfparamblk modpblk =
107 	{ CNFPARAMBLK_VERSION,
108 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
109 	  modpdescr
110 	};
111 static struct cnfparamdescr actpdescr[] = {
112 	{ "dynafilecachesize", eCmdHdlrInt, 0 }, 	{ "ziplevel", eCmdHdlrInt, 0 }, 	{ "flushinterval", eCmdHdlrInt, 0 }, 	{ "asyncwriting", eCmdHdlrBinary, 0 }, 	{ "veryrobustzip", eCmdHdlrBinary, 0 },</b></font>
113 	{ "flushontxend", eCmdHdlrBinary, 0 }, 	{ "iobuffersize", eCmdHdlrSize, 0 }, 	{ "dirowner", eCmdHdlrUID, 0 }, 	{ "dirownernum", eCmdHdlrInt, 0 }, 	{ "dirgroup", eCmdHdlrGID, 0 }, 	{ "dirgroupnum", eCmdHdlrInt, 0 }, 	{ "fileowner", eCmdHdlrUID, 0 }, 	{ "fileownernum", eCmdHdlrInt, 0 }, 	{ "filegroup", eCmdHdlrGID, 0 }, 	{ "filegroupnum", eCmdHdlrInt, 0 }, 	{ "dircreatemode", eCmdHdlrFileCreateMode, 0 }, 	{ "filecreatemode", eCmdHdlrFileCreateMode, 0 }, 	{ "failonchownfailure", eCmdHdlrBinary, 0 }, 	{ "createdirs", eCmdHdlrBinary, 0 }, 	{ "sync", eCmdHdlrBinary, 0 }, 	{ "file", eCmdHdlrString, 0 },     	{ "dynafile", eCmdHdlrString, 0 }, 	{ "sig.provider", eCmdHdlrGetWord, 0 },
114 	{ "cry.provider", eCmdHdlrGetWord, 0 },
115 	{ "closetimeout", eCmdHdlrPositiveInt, 0 },
116 	{ "template", eCmdHdlrGetWord, 0 }
117 };
118 static struct cnfparamblk actpblk =
119 	{ CNFPARAMBLK_VERSION,
120 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
121 	  actpdescr
122 	};
123 static uchar*
124 getDfltTpl(void)
125 {
126 	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
127 		return loadModConf-&gt;tplName;
128 	else if(pszFileDfltTplName == NULL)
129 		return (uchar*)"RSYSLOG_FileFormat";
130 	else
131 		return pszFileDfltTplName;
132 }
133 BEGINinitConfVars		CODESTARTinitConfVars
134 	pszFileDfltTplName = NULL; 	iRet = resetConfigVariables(NULL, NULL); ENDinitConfVars
135 BEGINisCompatibleWithFeature
136 CODESTARTisCompatibleWithFeature
137 	if(eFeat == sFEATURERepeatedMsgReduction)
138 		iRet = RS_RET_OK;
139 ENDisCompatibleWithFeature
140 BEGINdbgPrintInstInfo
141 CODESTARTdbgPrintInstInfo
142 	if(pData-&gt;bDynamicName) {
143 		dbgprintf("[dynamic]\n");
144 	} else { 		dbgprintf("%s%s\n", pData-&gt;fname,
145 			  (pData-&gt;pStrm == NULL) ? " (closed)" : "");
146 	}
147 	dbgprintf("\ttemplate='%s'\n", pData-&gt;fname);
148 	dbgprintf("\tuse async writer=%d\n", pData-&gt;bUseAsyncWriter);
149 	dbgprintf("\tflush on TX end=%d\n", pData-&gt;bFlushOnTXEnd);
150 	dbgprintf("\tflush interval=%d\n", pData-&gt;iFlushInterval);
151 	dbgprintf("\tfile cache size=%d\n", pData-&gt;iDynaFileCacheSize);
152 	dbgprintf("\tcreate directories: %s\n", pData-&gt;bCreateDirs ? "on" : "off");
153 	dbgprintf("\tvery robust zip: %s\n", pData-&gt;bCreateDirs ? "on" : "off");
154 	dbgprintf("\tfile owner %d, group %d\n", (int) pData-&gt;fileUID, (int) pData-&gt;fileGID);
155 	dbgprintf("\tdirectory owner %d, group %d\n", (int) pData-&gt;dirUID, (int) pData-&gt;dirGID);
156 	dbgprintf("\tdir create mode 0%3.3o, file create mode 0%3.3o\n",
157 		  pData-&gt;fDirCreateMode, pData-&gt;fCreateMode);
158 	dbgprintf("\tfail if owner/group can not be set: %s\n", pData-&gt;bFailOnChown ? "yes" : "no");
159 ENDdbgPrintInstInfo
160 static rsRetVal
161 setLegacyDfltTpl(void __attribute__((unused)) *pVal, uchar* newVal)
162 {
163 	DEFiRet;
164 	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL) {
165 		free(newVal);
166 		parser_errmsg("omfile: default template already set via module "
167 			"global parameter - can no longer be changed");
168 		ABORT_FINALIZE(RS_RET_ERR);
169 	}
170 	free(pszFileDfltTplName);
171 	pszFileDfltTplName = newVal;
172 finalize_it:
173 	RETiRet;
174 }
175 static rsRetVal setDynaFileCacheSize(void __attribute__((unused)) *pVal, int iNewVal)
176 {
177 	DEFiRet;
178 	if(iNewVal &lt; 1) {
179 		errno = 0;
180 		parser_errmsg(
181 		         "DynaFileCacheSize must be greater 0 (%d given), changed to 1.", iNewVal);
182 		iRet = RS_RET_VAL_OUT_OF_RANGE;
183 		iNewVal = 1;
184 	} else if(iNewVal &gt; 25000) {
185 		errno = 0;
186 		parser_warnmsg("DynaFileCacheSize is larger than 25,000 (%d given) - this looks very "
187 			"large. Is it intended?", iNewVal);
188 	}
189 	cs.iDynaFileCacheSize = iNewVal;
190 	DBGPRINTF("DynaFileCacheSize changed to %d.\n", iNewVal);
191 	RETiRet;
192 }
193 static rsRetVal cflineParseOutchannel(instanceData *pData, uchar* p, omodStringRequest_t *pOMSR,
194 	int iEntry, int iTplOpts)
195 {
196 	DEFiRet;
197 	size_t i;
198 	struct outchannel *pOch;
199 	char szBuf[128];	
200 	++p; 	i = 0;
201 	while(*p &amp;&amp; *p != ';' &amp;&amp; *p != ' ' &amp;&amp;
202 	      i &lt; (sizeof(szBuf) - 1) ) {
203 	      szBuf[i++] = *p++;
204 	}
205 	szBuf[i] = '\0';
206 	pOch = ochFind(szBuf, i);
207 	if(pOch == NULL) {
208 		parser_errmsg(
209 			 "outchannel '%s' not found - ignoring action line",
210 			 szBuf);
211 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
212 	}
213 	if(pOch-&gt;pszFileTemplate == NULL) {
214 		parser_errmsg(
215 			 "outchannel '%s' has no file name template - ignoring action line",
216 			 szBuf);
217 		ABORT_FINALIZE(RS_RET_ERR);
218 	}
219 	pData-&gt;fname = ustrdup(pOch-&gt;pszFileTemplate);
220 	pData-&gt;iSizeLimit = pOch-&gt;uSizeLimit;
221 	pData-&gt;pszSizeLimitCmd = pOch-&gt;cmdOnSizeLimit;
222 	iRet = cflineParseTemplateName(&amp;p, pOMSR, iEntry, iTplOpts, getDfltTpl());
223 finalize_it:
224 	RETiRet;
225 }
226 static rsRetVal
227 dynaFileDelCacheEntry(instanceData *__restrict__ const pData, const int iEntry, const int bFreeEntry)
228 {
229 	dynaFileCacheEntry **pCache = pData-&gt;dynCache;
230 	DEFiRet;
231 	assert(pCache != NULL);
232 	if(pCache[iEntry] == NULL)
233 		FINALIZE;
234 	DBGPRINTF("Removing entry %d for file '%s' from dynaCache.\n", iEntry,
235 		pCache[iEntry]-&gt;pName == NULL ? UCHAR_CONSTANT("[OPEN FAILED]") : pCache[iEntry]-&gt;pName);
236 	if(pCache[iEntry]-&gt;pName != NULL) {
237 		free(pCache[iEntry]-&gt;pName);
238 		pCache[iEntry]-&gt;pName = NULL;
239 	}
240 	if(pCache[iEntry]-&gt;pStrm != NULL) {
241 		if(iEntry == pData-&gt;iCurrElt) {
242 			pData-&gt;iCurrElt = -1;
243 			pData-&gt;pStrm = NULL;
244 		}
245 		strm.Destruct(&amp;pCache[iEntry]-&gt;pStrm);
246 		if(pData-&gt;useSigprov) {
247 			pData-&gt;sigprov.OnFileClose(pCache[iEntry]-&gt;sigprovFileData);
248 			pCache[iEntry]-&gt;sigprovFileData = NULL;
249 		}
250 	}
251 	if(bFreeEntry) {
252 		free(pCache[iEntry]);
253 		pCache[iEntry] = NULL;
254 	}
255 finalize_it:
256 	RETiRet;
257 }
258 static void
259 dynaFileFreeCacheEntries(instanceData *__restrict__ const pData)
260 {
261 	register int i;
262 	assert(pData != NULL);
263 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
264 		dynaFileDelCacheEntry(pData, i, 1);
265 	}
266 	pData-&gt;iCurrElt = -1;
267 	pData-&gt;pStrm = NULL;
268 }
269 static void dynaFileFreeCache(instanceData *__restrict__ const pData)
270 {
271 	assert(pData != NULL);
272 	dynaFileFreeCacheEntries(pData);
273 	if(pData-&gt;dynCache != NULL)
274 		free(pData-&gt;dynCache);
275 }
276 static rsRetVal
277 closeFile(instanceData *__restrict__ const pData)
278 {
279 	DEFiRet;
280 	if(pData-&gt;useSigprov) {
281 		pData-&gt;sigprov.OnFileClose(pData-&gt;sigprovFileData);
282 		pData-&gt;sigprovFileData = NULL;
283 	}
284 	strm.Destruct(&amp;pData-&gt;pStrm);
285 	RETiRet;
286 }
287 static rsRetVal
288 sigprovPrepare(instanceData *__restrict__ const pData, uchar *__restrict__ const fn)
289 {
290 	DEFiRet;
291 	pData-&gt;sigprov.OnFileOpen(pData-&gt;sigprovData, fn, &amp;pData-&gt;sigprovFileData);
292 	RETiRet;
293 }
294 static rsRetVal
295 prepareFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
296 {
297 	int fd;
298 	char errStr[1024]; 	DEFiRet;
299 	pData-&gt;pStrm = NULL;
300 	if(access((char*)newFileName, F_OK) != 0) {
301 		if(pData-&gt;bCreateDirs) {
302 			if(makeFileParentDirs(newFileName, ustrlen(newFileName),
303 			     pData-&gt;fDirCreateMode, pData-&gt;dirUID,
304 			     pData-&gt;dirGID, pData-&gt;bFailOnChown) != 0) {
305 				rs_strerror_r(errno, errStr, sizeof(errStr));
306 				parser_errmsg( "omfile: creating parent "
307 					"directories for file  '%s' failed: %s",
308 					newFileName, errStr);
309 			     	ABORT_FINALIZE(RS_RET_ERR); 			}
310 		}
311 		fd = open((char*) newFileName, O_WRONLY|O_APPEND|O_CREAT|O_NOCTTY|O_CLOEXEC,
312 				pData-&gt;fCreateMode);
313 		if(fd != -1) {
314 			if(pData-&gt;fileUID != (uid_t)-1 || pData-&gt;fileGID != (gid_t) -1) {
315 				if(fchown(fd, pData-&gt;fileUID, pData-&gt;fileGID) != 0) {
316 					rs_strerror_r(errno, errStr, sizeof(errStr));
317 					parser_errmsg(
318 						"omfile: chown for file '%s' failed: %s",
319 						newFileName, errStr);
320 					if(pData-&gt;bFailOnChown) {
321 						close(fd);
322 						ABORT_FINALIZE(RS_RET_ERR); 					}
323 				}
324 			}
325 			close(fd); 		}
326 	}
327 	uchar szNameBuf[MAXFNAME+1];
328 	uchar szDirName[MAXFNAME+1];
329 	uchar szBaseName[MAXFNAME+1];
330 	ustrncpy(szNameBuf, newFileName, MAXFNAME);
331 	szNameBuf[MAXFNAME] = '\0';
332 	ustrncpy(szDirName, (uchar*)dirname((char*)szNameBuf), MAXFNAME);
333 	szDirName[MAXFNAME] = '\0';
334 	ustrncpy(szNameBuf, newFileName, MAXFNAME);
335 	szNameBuf[MAXFNAME] = '\0';
336 	ustrncpy(szBaseName, (uchar*)basename((char*)szNameBuf), MAXFNAME);
337 	szBaseName[MAXFNAME] = '\0';
338 	CHKiRet(strm.Construct(&amp;pData-&gt;pStrm));
339 	CHKiRet(strm.SetFName(pData-&gt;pStrm, szBaseName, ustrlen(szBaseName)));
340 	CHKiRet(strm.SetDir(pData-&gt;pStrm, szDirName, ustrlen(szDirName)));
341 	CHKiRet(strm.SetiZipLevel(pData-&gt;pStrm, pData-&gt;iZipLevel));
342 	CHKiRet(strm.SetbVeryReliableZip(pData-&gt;pStrm, pData-&gt;bVeryRobustZip));
343 	CHKiRet(strm.SetsIOBufSize(pData-&gt;pStrm, (size_t) pData-&gt;iIOBufSize));
344 	CHKiRet(strm.SettOperationsMode(pData-&gt;pStrm, STREAMMODE_WRITE_APPEND));
345 	CHKiRet(strm.SettOpenMode(pData-&gt;pStrm, cs.fCreateMode));
346 	CHKiRet(strm.SetbSync(pData-&gt;pStrm, pData-&gt;bSyncFile));
347 	CHKiRet(strm.SetsType(pData-&gt;pStrm, STREAMTYPE_FILE_SINGLE));
348 	CHKiRet(strm.SetiSizeLimit(pData-&gt;pStrm, pData-&gt;iSizeLimit));
349 	if(pData-&gt;useCryprov) {
350 		CHKiRet(strm.Setcryprov(pData-&gt;pStrm, &amp;pData-&gt;cryprov));
351 		CHKiRet(strm.SetcryprovData(pData-&gt;pStrm, pData-&gt;cryprovData));
352 	}
353 	if(pData-&gt;bUseAsyncWriter)
354 		CHKiRet(strm.SetiFlushInterval(pData-&gt;pStrm, pData-&gt;iFlushInterval));
355 	if(pData-&gt;pszSizeLimitCmd != NULL)
356 		CHKiRet(strm.SetpszSizeLimitCmd(pData-&gt;pStrm, ustrdup(pData-&gt;pszSizeLimitCmd)));
357 	CHKiRet(strm.ConstructFinalize(pData-&gt;pStrm));
358 	if(pData-&gt;useSigprov)
359 		sigprovPrepare(pData, szNameBuf);
360 finalize_it:
361 	if(iRet != RS_RET_OK) {
362 		if(pData-&gt;pStrm != NULL) {
363 			closeFile(pData);
364 		}
365 	}
366 	RETiRet;
367 }
368 static rsRetVal ATTR_NONNULL()
369 prepareDynFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
370 {
371 	uint64 ctOldest; 	int iOldest;
372 	int i;
373 	int iFirstFree;
374 	rsRetVal localRet;
375 	dynaFileCacheEntry **pCache;
376 	DEFiRet;
377 	assert(pData != NULL);
378 	assert(newFileName != NULL);
379 	pCache = pData-&gt;dynCache;
380 	if(   (pData-&gt;iCurrElt != -1)
381 	   &amp;&amp; !ustrcmp(newFileName, pCache[pData-&gt;iCurrElt]-&gt;pName)) {
382 		pCache[pData-&gt;iCurrElt]-&gt;clkTickAccessed = getClockFileAccess();
383 		STATSCOUNTER_INC(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
384 		FINALIZE;
385 	}
386 	if(((runModConf-&gt;pConf-&gt;globals.glblDevOptions &amp; DEV_OPTION_8_1905_HANG_TEST) == 0) &amp;&amp;
387 	    pData-&gt;bFlushOnTXEnd &amp;&amp; pData-&gt;pStrm != NULL) {
388 		CHKiRet(strm.Flush(pData-&gt;pStrm));
389 	}
390 	pData-&gt;iCurrElt = -1;		iFirstFree = -1; 	iOldest = 0; 	ctOldest = getClockFileAccess(); 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
391 		if(pCache[i] == NULL || pCache[i]-&gt;pName == NULL) {
392 			if(iFirstFree == -1)
393 				iFirstFree = i;
394 		} else { 			if(!ustrcmp(newFileName, pCache[i]-&gt;pName)) {
395 				pData-&gt;pStrm = pCache[i]-&gt;pStrm;
396 				if(pData-&gt;useSigprov)
397 					pData-&gt;sigprovFileData = pCache[i]-&gt;sigprovFileData;
398 				pData-&gt;iCurrElt = i;
399 				pCache[i]-&gt;clkTickAccessed = getClockFileAccess(); 				FINALIZE;
400 			}
401 			if(pCache[i]-&gt;clkTickAccessed &lt; ctOldest) {
402 				ctOldest = pCache[i]-&gt;clkTickAccessed;
403 				iOldest = i;
404 				}
405 		}
406 	}
407 	STATSCOUNTER_INC(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);
408 	pData-&gt;pStrm = NULL, pData-&gt;sigprovFileData = NULL;
409 	if(iFirstFree == -1 &amp;&amp; (pData-&gt;iCurrCacheSize &lt; pData-&gt;iDynaFileCacheSize)) {
410 		iFirstFree = pData-&gt;iCurrCacheSize++;
411 		STATSCOUNTER_SETMAX_NOMUT(pData-&gt;ctrMax, (unsigned) pData-&gt;iCurrCacheSize);
412 	}
413 	if(iFirstFree == -1) {
414 		dynaFileDelCacheEntry(pData, iOldest, 0);
415 		STATSCOUNTER_INC(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
416 		iFirstFree = iOldest; 	} else {
417 		CHKmalloc(pCache[iFirstFree] = (dynaFileCacheEntry*) calloc(1, sizeof(dynaFileCacheEntry)));
418 	}
419 	localRet = prepareFile(pData, newFileName); 
420 	if(localRet != RS_RET_OK) {
421 		parser_errmsg("Could not open dynamic file '%s' [state %d] - discarding "
422 		"message", newFileName, localRet);
423 		ABORT_FINALIZE(localRet);
424 	}
425 	if((pCache[iFirstFree]-&gt;pName = ustrdup(newFileName)) == NULL) {
426 		closeFile(pData); 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
427 	}
428 	pCache[iFirstFree]-&gt;pStrm = pData-&gt;pStrm;
429 	if(pData-&gt;useSigprov)
430 		pCache[iFirstFree]-&gt;sigprovFileData = pData-&gt;sigprovFileData;
431 	pCache[iFirstFree]-&gt;clkTickAccessed = getClockFileAccess();
432 	pData-&gt;iCurrElt = iFirstFree;
433 	DBGPRINTF("Added new entry %d for file cache, file '%s'.\n", iFirstFree, newFileName);
434 finalize_it:
435 	if(iRet == RS_RET_OK)
436 		pCache[pData-&gt;iCurrElt]-&gt;nInactive = 0;
437 	RETiRet;
438 }
439 static  rsRetVal
440 doWrite(instanceData *__restrict__ const pData, uchar *__restrict__ const pszBuf, const int lenBuf)
441 {
442 	DEFiRet;
443 	assert(pData != NULL);
444 	assert(pszBuf != NULL);
445 	DBGPRINTF("omfile: write to stream, pData-&gt;pStrm %p, lenBuf %d, strt data %.128s\n",
446 		  pData-&gt;pStrm, lenBuf, pszBuf);
447 	if(pData-&gt;pStrm != NULL){
448 		CHKiRet(strm.Write(pData-&gt;pStrm, pszBuf, lenBuf));
449 		if(pData-&gt;useSigprov) {
450 			CHKiRet(pData-&gt;sigprov.OnRecordWrite(pData-&gt;sigprovFileData, pszBuf, lenBuf));
451 		}
452 	}
453 finalize_it:
454 	RETiRet;
455 }
456 static rsRetVal
457 writeFile(instanceData *__restrict__ const pData,
458 	  const actWrkrIParams_t *__restrict__ const pParam,
459 	  const int iMsg)
460 {
461 	DEFiRet;
462 	STATSCOUNTER_INC(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
463 	if(pData-&gt;bDynamicName) {
464 		DBGPRINTF("omfile: file to log to: %s\n",
465 			  actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param);
466 		CHKiRet(prepareDynFile(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param));
467 	} else { 		if(pData-&gt;pStrm == NULL) {
468 			CHKiRet(prepareFile(pData, pData-&gt;fname));
469 			if(pData-&gt;pStrm == NULL) {
470 				parser_errmsg(
471 					"Could not open output file '%s'", pData-&gt;fname);
472 			}
473 		}
474 		pData-&gt;nInactive = 0;
475 	}
476 	iRet = doWrite(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).param,
477 		actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).lenStr);
478 finalize_it:
479 	RETiRet;
480 }
481 BEGINbeginCnfLoad
482 CODESTARTbeginCnfLoad
483 	loadModConf = pModConf;
484 	pModConf-&gt;pConf = pConf;
485 	pModConf-&gt;tplName = NULL;
486 	pModConf-&gt;fCreateMode = 0644;
487 	pModConf-&gt;fDirCreateMode = 0700;
488 	pModConf-&gt;fileUID = -1;
489 	pModConf-&gt;dirUID = -1;
490 	pModConf-&gt;fileGID = -1;
491 	pModConf-&gt;dirGID = -1;
492 	pModConf-&gt;bDynafileDoNotSuspend = 1;
493 ENDbeginCnfLoad
494 BEGINsetModCnf
495 	struct cnfparamvals *pvals = NULL;
496 	int i;
497 CODESTARTsetModCnf
498 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
499 	if(pvals == NULL) {
500 		parser_errmsg("error processing module "
501 				"config parameters [module(...)]");
502 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
503 	}
504 	if(Debug) {
505 		dbgprintf("module (global) param blk for omfile:\n");
506 		cnfparamsPrint(&amp;modpblk, pvals);
507 	}
508 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
509 		if(!pvals[i].bUsed) {
510 			continue;
511 		}
512 		if(!strcmp(modpblk.descr[i].name, "template")) {
513 			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
514 			if(pszFileDfltTplName != NULL) {
515 				parser_errmsg("omfile: warning: default template was already "
516 					"set via legacy directive - may lead to inconsistent "
517 					"results.");
518 			}
519 		} else if(!strcmp(modpblk.descr[i].name, "dircreatemode")) {
520 			loadModConf-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
521 		} else if(!strcmp(modpblk.descr[i].name, "filecreatemode")) {
522 			loadModConf-&gt;fCreateMode = (int) pvals[i].val.d.n;
523 		} else if(!strcmp(modpblk.descr[i].name, "dirowner")) {
524 			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;
525 		} else if(!strcmp(modpblk.descr[i].name, "dirownernum")) {
526 			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;
527 		} else if(!strcmp(modpblk.descr[i].name, "dirgroup")) {
528 			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
529 		} else if(!strcmp(modpblk.descr[i].name, "dirgroupnum")) {
530 			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
531 		} else if(!strcmp(modpblk.descr[i].name, "fileowner")) {
532 			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
533 		} else if(!strcmp(modpblk.descr[i].name, "fileownernum")) {
534 			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
535 		} else if(!strcmp(modpblk.descr[i].name, "filegroup")) {
536 			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
537 		} else if(!strcmp(modpblk.descr[i].name, "filegroupnum")) {
538 			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
539 		} else if(!strcmp(modpblk.descr[i].name, "dynafile.donotsuspend")) {
540 			loadModConf-&gt;bDynafileDoNotSuspend = (int) pvals[i].val.d.n;
541 		} else {
542 			dbgprintf("omfile: program error, non-handled "
543 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
544 		}
545 	}
546 finalize_it:
547 	if(pvals != NULL)
548 		cnfparamvalsDestruct(pvals, &amp;modpblk);
549 ENDsetModCnf
550 static void
551 janitorChkDynaFiles(instanceData *__restrict__ const pData)
552 {
553 	int i;
554 	dynaFileCacheEntry **pCache = pData-&gt;dynCache;
555 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
556 		if(pCache[i] == NULL)
557 			continue;
558 		DBGPRINTF("omfile janitor: checking dynafile %d:%s, inactive since %d\n", i,
559 			pCache[i]-&gt;pName == NULL ? UCHAR_CONSTANT("[OPEN FAILED]") : pCache[i]-&gt;pName,
560 			(int) pCache[i]-&gt;nInactive);
561 		if(pCache[i]-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
562 			STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
563 			dynaFileDelCacheEntry(pData, i, 1);
564 			if(pData-&gt;iCurrElt == i)
565 				pData-&gt;iCurrElt = -1; 		} else {
566 			pCache[i]-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
567 		}
568 	}
569 }
570 static void
571 janitorCB(void *pUsr)
572 {
573 	instanceData *__restrict__ const pData = (instanceData *) pUsr;
574 	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
575 	if(pData-&gt;bDynamicName) {
576 		janitorChkDynaFiles(pData);
577 	} else {
578 		if(pData-&gt;pStrm != NULL) {
579 			DBGPRINTF("omfile janitor: checking file %s, inactive since %d\n",
580 				pData-&gt;fname, pData-&gt;nInactive);
581 			if(pData-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
582 				STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
583 				closeFile(pData);
584 			} else {
585 				pData-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
586 			}
587 		}
588 	}
589 	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
590 }
591 BEGINendCnfLoad
592 CODESTARTendCnfLoad
593 	loadModConf = NULL; 	free(pszFileDfltTplName);
594 	pszFileDfltTplName = NULL;
595 ENDendCnfLoad
596 BEGINcheckCnf
597 CODESTARTcheckCnf
598 ENDcheckCnf
599 BEGINactivateCnf
600 CODESTARTactivateCnf
601 	runModConf = pModConf;
602 ENDactivateCnf
603 BEGINfreeCnf
604 CODESTARTfreeCnf
605 	free(pModConf-&gt;tplName);
606 ENDfreeCnf
607 BEGINcreateInstance
608 CODESTARTcreateInstance
609 	pData-&gt;pStrm = NULL;
610 	pthread_mutex_init(&amp;pData-&gt;mutWrite, NULL);
611 ENDcreateInstance
612 BEGINcreateWrkrInstance
613 CODESTARTcreateWrkrInstance
614 ENDcreateWrkrInstance
615 BEGINfreeInstance
616 CODESTARTfreeInstance
617 	free(pData-&gt;tplName);
618 	free(pData-&gt;fname);
619 	if(pData-&gt;iCloseTimeout &gt; 0)
620 		janitorDelEtry(pData-&gt;janitorID);
621 	if(pData-&gt;bDynamicName) {
622 		dynaFileFreeCache(pData);
623 	} else if(pData-&gt;pStrm != NULL)
624 		closeFile(pData);
625 	if(pData-&gt;stats != NULL)
626 		statsobj.Destruct(&amp;(pData-&gt;stats));
627 	if(pData-&gt;useSigprov) {
628 		pData-&gt;sigprov.Destruct(&amp;pData-&gt;sigprovData);
629 		obj.ReleaseObj(__FILE__, pData-&gt;sigprovNameFull+2, pData-&gt;sigprovNameFull,
630 			       (void*) &amp;pData-&gt;sigprov);
631 		free(pData-&gt;sigprovName);
632 		free(pData-&gt;sigprovNameFull);
633 	}
634 	if(pData-&gt;useCryprov) {
635 		pData-&gt;cryprov.Destruct(&amp;pData-&gt;cryprovData);
636 		obj.ReleaseObj(__FILE__, pData-&gt;cryprovNameFull+2, pData-&gt;cryprovNameFull,
637 			       (void*) &amp;pData-&gt;cryprov);
638 		free(pData-&gt;cryprovName);
639 		free(pData-&gt;cryprovNameFull);
640 	}
641 	pthread_mutex_destroy(&amp;pData-&gt;mutWrite);
642 ENDfreeInstance
643 BEGINfreeWrkrInstance
644 CODESTARTfreeWrkrInstance
645 ENDfreeWrkrInstance
646 BEGINtryResume
647 CODESTARTtryResume
648 ENDtryResume
649 BEGINbeginTransaction
650 CODESTARTbeginTransaction
651 ENDbeginTransaction
652 BEGINcommitTransaction
653 	instanceData *__restrict__ const pData = pWrkrData-&gt;pData;
654 	unsigned i;
655 CODESTARTcommitTransaction
656 	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
657 	for(i = 0 ; i &lt; nParams ; ++i) {
658 		writeFile(pData, pParams, i);
659 	}
660 	if(pData-&gt;bFlushOnTXEnd &amp;&amp; pData-&gt;pStrm != NULL) {
661 		CHKiRet(strm.Flush(pData-&gt;pStrm));
662 	}
663 finalize_it:
664 	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
665 	if(iRet == RS_RET_FILE_OPEN_ERROR || iRet == RS_RET_FILE_NOT_FOUND) {
666 		iRet = (pData-&gt;bDynamicName &amp;&amp; runModConf-&gt;bDynafileDoNotSuspend) ?
667 			RS_RET_OK : RS_RET_SUSPENDED;
668 	}
669 ENDcommitTransaction
670 static void
671 setInstParamDefaults(instanceData *__restrict__ const pData)
672 {
673 	pData-&gt;fname = NULL;
674 	pData-&gt;tplName = NULL;
675 	pData-&gt;fileUID = loadModConf-&gt;fileUID;
676 	pData-&gt;fileGID = loadModConf-&gt;fileGID;
677 	pData-&gt;dirUID = loadModConf-&gt;dirUID;
678 	pData-&gt;dirGID = loadModConf-&gt;dirGID;
679 	pData-&gt;bFailOnChown = 1;
680 	pData-&gt;iDynaFileCacheSize = 10;
681 	pData-&gt;fCreateMode = loadModConf-&gt;fCreateMode;
682 	pData-&gt;fDirCreateMode = loadModConf-&gt;fDirCreateMode;
683 	pData-&gt;bCreateDirs = 1;
684 	pData-&gt;bSyncFile = 0;
685 	pData-&gt;iZipLevel = 0;
686 	pData-&gt;bVeryRobustZip = 0;
687 	pData-&gt;bFlushOnTXEnd = FLUSHONTX_DFLT;
688 	pData-&gt;iIOBufSize = IOBUF_DFLT_SIZE;
689 	pData-&gt;iFlushInterval = FLUSH_INTRVL_DFLT;
690 	pData-&gt;bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
691 	pData-&gt;sigprovName = NULL;
692 	pData-&gt;cryprovName = NULL;
693 	pData-&gt;useSigprov = 0;
694 	pData-&gt;useCryprov = 0;
695 	pData-&gt;iCloseTimeout = -1;
696 }
697 static rsRetVal
698 setupInstStatsCtrs(instanceData *__restrict__ const pData)
699 {
700 	uchar ctrName[512];
701 	DEFiRet;
702 	if(!pData-&gt;bDynamicName) {
703 		FINALIZE;
704 	}
705 	snprintf((char*)ctrName, sizeof(ctrName), "dynafile cache %s", pData-&gt;fname);
706 	ctrName[sizeof(ctrName)-1] = '\0'; 	CHKiRet(statsobj.Construct(&amp;(pData-&gt;stats)));
707 	CHKiRet(statsobj.SetName(pData-&gt;stats, ctrName));
708 	CHKiRet(statsobj.SetOrigin(pData-&gt;stats, (uchar*)"omfile"));
709 	STATSCOUNTER_INIT(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
710 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("requests"),
711 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrRequests)));
712 	STATSCOUNTER_INIT(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
713 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("level0"),
714 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrLevel0)));
715 	STATSCOUNTER_INIT(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);
716 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("missed"),
717 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMiss)));
718 	STATSCOUNTER_INIT(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
719 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("evicted"),
720 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrEvict)));
721 	STATSCOUNTER_INIT(pData-&gt;ctrMax, pData-&gt;mutCtrMax);
722 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("maxused"),
723 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMax)));
724 	STATSCOUNTER_INIT(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
725 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("closetimeouts"),
726 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrCloseTimeouts)));
727 	CHKiRet(statsobj.ConstructFinalize(pData-&gt;stats));
728 finalize_it:
729 	RETiRet;
730 }
731 static void
732 initSigprov(instanceData *__restrict__ const pData, struct nvlst *lst)
733 {
734 	uchar szDrvrName[1024];
735 	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), "lmsig_%s", pData-&gt;sigprovName)
736 		== sizeof(szDrvrName)) {
737 		parser_errmsg("omfile: signature provider "
738 				"name is too long: '%s' - signatures disabled",
739 				pData-&gt;sigprovName);
740 		goto done;
741 	}
742 	pData-&gt;sigprovNameFull = ustrdup(szDrvrName);
743 	pData-&gt;sigprov.ifVersion = sigprovCURR_IF_VERSION;
744 	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;sigprov)
745 		!= RS_RET_OK) {
746 		parser_errmsg("omfile: could not load "
747 				"signature provider '%s' - signatures disabled",
748 				szDrvrName);
749 		goto done;
750 	}
751 	if(pData-&gt;sigprov.Construct(&amp;pData-&gt;sigprovData) != RS_RET_OK) {
752 		parser_errmsg("omfile: error constructing "
753 				"signature provider %s dataset - signatures disabled",
754 				szDrvrName);
755 		goto done;
756 	}
757 	pData-&gt;sigprov.SetCnfParam(pData-&gt;sigprovData, lst);
758 	dbgprintf("loaded signature provider %s, data instance at %p\n",
759 		  szDrvrName, pData-&gt;sigprovData);
760 	pData-&gt;useSigprov = 1;
761 done:	return;
762 }
763 static rsRetVal
764 initCryprov(instanceData *__restrict__ const pData, struct nvlst *lst)
765 {
766 	uchar szDrvrName[1024];
767 	DEFiRet;
768 	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), "lmcry_%s", pData-&gt;cryprovName)
769 		== sizeof(szDrvrName)) {
770 		parser_errmsg("omfile: crypto provider "
771 				"name is too long: '%s' - encryption disabled",
772 				pData-&gt;cryprovName);
773 		ABORT_FINALIZE(RS_RET_ERR);
774 	}
775 	pData-&gt;cryprovNameFull = ustrdup(szDrvrName);
776 	pData-&gt;cryprov.ifVersion = cryprovCURR_IF_VERSION;
777 	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;cryprov)
778 		!= RS_RET_OK) {
779 		parser_errmsg("omfile: could not load "
780 				"crypto provider '%s' - encryption disabled",
781 				szDrvrName);
782 		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
783 	}
784 	if(pData-&gt;cryprov.Construct(&amp;pData-&gt;cryprovData) != RS_RET_OK) {
785 		parser_errmsg("omfile: error constructing "
786 				"crypto provider %s dataset - encryption disabled",
787 				szDrvrName);
788 		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
789 	}
790 	CHKiRet(pData-&gt;cryprov.SetCnfParam(pData-&gt;cryprovData, lst, CRYPROV_PARAMTYPE_REGULAR));
791 	dbgprintf("loaded crypto provider %s, data instance at %p\n",
792 		  szDrvrName, pData-&gt;cryprovData);
793 	pData-&gt;useCryprov = 1;
794 finalize_it:
795 	RETiRet;
796 }
797 BEGINnewActInst
798 	struct cnfparamvals *pvals;
799 	uchar *tplToUse;
800 	int i;
801 <a name="1"></a>CODESTARTnewActInst
802 	DBGPRINTF("newActInst (omfile)\n");
803 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
804 	if(pvals == NULL) {
805 		parser_errmsg("omfile: either the \"file\" or "
806 				"\"dynafile\" parameter must be given");
807 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
808 	}
809 	if(Debug) {
810 		dbgprintf("action param blk in omfile:\n");
811 		cnfparamsPrint(&amp;actpblk, pvals);
812 	}
813 	CHKiRet(createInstance(&amp;pData));
814 	setInstParamDefaults(pData);
815 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
816 		if(!pvals[i].bUsed)
817 			continue;
818 		if(!strcmp(actpblk.descr[i].name, "dynafilecachesize")) {
819 			pData-&gt;iDynaFileCacheSize = (int) pvals[i].val.d.n;</b></font>
820 		} else if(!strcmp(actpblk.descr[i].name, "ziplevel")) {
821 			pData-&gt;iZipLevel = (int) pvals[i].val.d.n;
822 		} else if(!strcmp(actpblk.descr[i].name, "flushinterval")) {
823 			pData-&gt;iFlushInterval = pvals[i].val.d.n;
824 		} else if(!strcmp(actpblk.descr[i].name, "veryrobustzip")) {
825 			pData-&gt;bVeryRobustZip = pvals[i].val.d.n;
826 		} else if(!strcmp(actpblk.descr[i].name, "asyncwriting")) {
827 			pData-&gt;bUseAsyncWriter = pvals[i].val.d.n;
828 		} else if(!strcmp(actpblk.descr[i].name, "flushontxend")) {
829 			pData-&gt;bFlushOnTXEnd = pvals[i].val.d.n;
830 		} else if(!strcmp(actpblk.descr[i].name, "iobuffersize")) {
831 			pData-&gt;iIOBufSize = (int) pvals[i].val.d.n;
832 		} else if(!strcmp(actpblk.descr[i].name, "dirowner")) {
833 			pData-&gt;dirUID = (int) pvals[i].val.d.n;
834 		} else if(!strcmp(actpblk.descr[i].name, "dirownernum")) {
835 			pData-&gt;dirUID = (int) pvals[i].val.d.n;
836 		} else if(!strcmp(actpblk.descr[i].name, "dirgroup")) {
837 			pData-&gt;dirGID = (int) pvals[i].val.d.n;
838 		} else if(!strcmp(actpblk.descr[i].name, "dirgroupnum")) {
839 			pData-&gt;dirGID = (int) pvals[i].val.d.n;
840 		} else if(!strcmp(actpblk.descr[i].name, "fileowner")) {
841 			pData-&gt;fileUID = (int) pvals[i].val.d.n;
842 		} else if(!strcmp(actpblk.descr[i].name, "fileownernum")) {
843 			pData-&gt;fileUID = (int) pvals[i].val.d.n;
844 		} else if(!strcmp(actpblk.descr[i].name, "filegroup")) {
845 			pData-&gt;fileGID = (int) pvals[i].val.d.n;
846 		} else if(!strcmp(actpblk.descr[i].name, "filegroupnum")) {
847 			pData-&gt;fileGID = (int) pvals[i].val.d.n;
848 		} else if(!strcmp(actpblk.descr[i].name, "dircreatemode")) {
849 			pData-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
850 		} else if(!strcmp(actpblk.descr[i].name, "filecreatemode")) {
851 			pData-&gt;fCreateMode = (int) pvals[i].val.d.n;
852 		} else if(!strcmp(actpblk.descr[i].name, "failonchownfailure")) {
853 			pData-&gt;bFailOnChown = (int) pvals[i].val.d.n;
854 		} else if(!strcmp(actpblk.descr[i].name, "sync")) {
855 			pData-&gt;bSyncFile = (int) pvals[i].val.d.n;
856 		} else if(!strcmp(actpblk.descr[i].name, "createdirs")) {
857 			pData-&gt;bCreateDirs = (int) pvals[i].val.d.n;
858 		} else if(!strcmp(actpblk.descr[i].name, "file")) {
859 			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
860 			CODE_STD_STRING_REQUESTnewActInst(1)
861 			pData-&gt;bDynamicName = 0;
862 		} else if(!strcmp(actpblk.descr[i].name, "dynafile")) {
863 <a name="2"></a>			if(pData-&gt;fname != NULL) {
864 				parser_errmsg("omfile: both \"file\" and \"dynafile\" set, will use dynafile");
865 			}
866 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
867 			CODE_STD_STRING_REQUESTnewActInst(2)
868 			pData-&gt;bDynamicName = 1;
869 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
870 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
871 		} else if(!strcmp(actpblk.descr[i].name, "sig.provider")) {
872 			pData-&gt;sigprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
873 		} else if(!strcmp(actpblk.descr[i].name, "cry.provider")) {</b></font>
874 			pData-&gt;cryprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
875 		} else if(!strcmp(actpblk.descr[i].name, "closetimeout")) {
876 			pData-&gt;iCloseTimeout = (int) pvals[i].val.d.n;
877 		} else {
878 			dbgprintf("omfile: program error, non-handled "
879 			  "param '%s'\n", actpblk.descr[i].name);
880 		}
881 	}
882 	if(pData-&gt;fname == NULL || *pData-&gt;fname == '\0') {
883 		parser_errmsg("omfile: either the \"file\" or "
884 				"\"dynafile\" parameter must be given");
885 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
886 	}
887 	int allWhiteSpace = 1;
888 	for(const char *p = (const char*) pData-&gt;fname ; *p ; ++p) {
889 		if(!isspace(*p)) {
890 			allWhiteSpace = 0;
891 			break;
892 		}
893 	}
894 	if(allWhiteSpace) {
895 		parser_errmsg("omfile: \"file\" or \"dynafile\" parameter "
896 			"consist only of whitespace - this is not permitted");
897 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
898 	}
899 	if(pData-&gt;sigprovName != NULL) {
900 		initSigprov(pData, lst);
901 	}
902 	if(pData-&gt;cryprovName != NULL) {
903 		CHKiRet(initCryprov(pData, lst));
904 	}
905 	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? getDfltTpl() : pData-&gt;tplName);
906 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
907 	pData-&gt;iNumTpls = 1;
908 	if(pData-&gt;bDynamicName) {
909 		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
910 		pData-&gt;iNumTpls = 2;
911 		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
912 				calloc(pData-&gt;iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
913 		pData-&gt;iCurrElt = -1;		  	}
914 	setupInstStatsCtrs(pData);
915 	if(pData-&gt;iCloseTimeout == -1) { 		pData-&gt;iCloseTimeout = (pData-&gt;bDynamicName) ? 10 : 0;
916 	}
917 	snprintf(pData-&gt;janitorID, sizeof(pData-&gt;janitorID), "omfile:%sfile:%s:%p",
918 		(pData-&gt;bDynamicName) ? "dyna" : "", pData-&gt;fname, pData);
919 	pData-&gt;janitorID[sizeof(pData-&gt;janitorID)-1] = '\0'; 
920 	if(pData-&gt;iCloseTimeout &gt; 0)
921 		janitorAddEtry(janitorCB, pData-&gt;janitorID, pData);
922 CODE_STD_FINALIZERnewActInst
923 	cnfparamvalsDestruct(pvals, &amp;actpblk);
924 ENDnewActInst
925 BEGINparseSelectorAct
926 	uchar fname[MAXFNAME];
927 CODESTARTparseSelectorAct
928 	if(!strncmp((char*) p, ":omfile:", sizeof(":omfile:") - 1)) {
929 		p += sizeof(":omfile:") - 1;
930 	}
931 	if(!(*p == '$' || *p == '?' || *p == '/' || *p == '.' || *p == '-'))
932 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
933 	CHKiRet(createInstance(&amp;pData));
934 	if(*p == '-') {
935 		pData-&gt;bSyncFile = 0;
936 		p++;
937 	} else {
938 		pData-&gt;bSyncFile = cs.bEnableSync;
939 	}
940 	pData-&gt;iSizeLimit = 0; 
941 	switch(*p) {
942 	case '$':
943 		CODE_STD_STRING_REQUESTparseSelectorAct(1)
944 		pData-&gt;iNumTpls = 1;
945 		CHKiRet(cflineParseOutchannel(pData, p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS));
946 		pData-&gt;bDynamicName = 0;
947 		break;
948 		CODE_STD_STRING_REQUESTparseSelectorAct(2)
949 		pData-&gt;iNumTpls = 2;
950 		++p; 		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
951 		pData-&gt;fname = ustrdup(fname);
952 		pData-&gt;bDynamicName = 1;
953 		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
954 		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
955 				calloc(cs.iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
956 		break;
957 	case '/':
958 	case '.':
959 		CODE_STD_STRING_REQUESTparseSelectorAct(1)
960 		pData-&gt;iNumTpls = 1;
961 		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
962 		pData-&gt;fname = ustrdup(fname);
963 		pData-&gt;bDynamicName = 0;
964 		break;
965 	default:
966 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
967 	}
968 	pData-&gt;iDynaFileCacheSize = cs.iDynaFileCacheSize;
969 	pData-&gt;fCreateMode = cs.fCreateMode;
970 	pData-&gt;fDirCreateMode = cs.fDirCreateMode;
971 	pData-&gt;bCreateDirs = cs.bCreateDirs;
972 	pData-&gt;bFailOnChown = cs.bFailOnChown;
973 	pData-&gt;fileUID = cs.fileUID;
974 	pData-&gt;fileGID = cs.fileGID;
975 	pData-&gt;dirUID = cs.dirUID;
976 	pData-&gt;dirGID = cs.dirGID;
977 	pData-&gt;iZipLevel = cs.iZipLevel;
978 	pData-&gt;bFlushOnTXEnd = cs.bFlushOnTXEnd;
979 	pData-&gt;iIOBufSize = (int) cs.iIOBufSize;
980 	pData-&gt;iFlushInterval = cs.iFlushInterval;
981 	pData-&gt;bUseAsyncWriter = cs.bUseAsyncWriter;
982 	pData-&gt;bVeryRobustZip = 0;		pData-&gt;iCloseTimeout = 0;		setupInstStatsCtrs(pData);
983 CODE_STD_FINALIZERparseSelectorAct
984 ENDparseSelectorAct
985 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
986 {
987 	cs.fileUID = -1;
988 	cs.fileGID = -1;
989 	cs.dirUID = -1;
990 	cs.dirGID = -1;
991 	cs.bFailOnChown = 1;
992 	cs.iDynaFileCacheSize = 10;
993 	cs.fCreateMode = 0644;
994 	cs.fDirCreateMode = 0700;
995 	cs.bCreateDirs = 1;
996 	cs.bEnableSync = 0;
997 	cs.iZipLevel = 0;
998 	cs.bFlushOnTXEnd = FLUSHONTX_DFLT;
999 	cs.iIOBufSize = IOBUF_DFLT_SIZE;
1000 	cs.iFlushInterval = FLUSH_INTRVL_DFLT;
1001 	cs.bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
1002 	free(pszFileDfltTplName);
1003 	pszFileDfltTplName = NULL;
1004 	return RS_RET_OK;
1005 }
1006 BEGINdoHUP
1007 CODESTARTdoHUP
1008 	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
1009 	if(pData-&gt;bDynamicName) {
1010 		dynaFileFreeCacheEntries(pData);
1011 	} else {
1012 		if(pData-&gt;pStrm != NULL) {
1013 			closeFile(pData);
1014 		}
1015 	}
1016 	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
1017 ENDdoHUP
1018 BEGINmodExit
1019 CODESTARTmodExit
1020 	objRelease(strm, CORE_COMPONENT);
1021 	objRelease(statsobj, CORE_COMPONENT);
1022 	DESTROY_ATOMIC_HELPER_MUT(mutClock);
1023 ENDmodExit
1024 BEGINqueryEtryPt
1025 CODESTARTqueryEtryPt
1026 CODEqueryEtryPt_STD_OMODTX_QUERIES
1027 CODEqueryEtryPt_STD_OMOD8_QUERIES
1028 CODEqueryEtryPt_STD_CONF2_QUERIES
1029 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
1030 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1031 CODEqueryEtryPt_doHUP
1032 ENDqueryEtryPt
1033 BEGINmodInit(File)
1034 CODESTARTmodInit
1035 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1036 INITLegCnfVars
1037 	CHKiRet(objUse(strm, CORE_COMPONENT));
1038 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1039 	INIT_ATOMIC_HELPER_MUT(mutClock);
1040 	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
1041 	DBGPRINTF("omfile: %susing transactional output interface.\n", bCoreSupportsBatching ? "" : "not ");
1042 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dynafilecachesize", 0, eCmdHdlrInt, setDynaFileCacheSize,
1043 		NULL, STD_LOADABLE_MODULE_ID));
1044 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileziplevel", 0, eCmdHdlrInt, NULL, &amp;cs.iZipLevel,
1045 		STD_LOADABLE_MODULE_ID));
1046 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileflushinterval", 0, eCmdHdlrInt, NULL, &amp;cs.iFlushInterval,
1047 		STD_LOADABLE_MODULE_ID));
1048 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileasyncwriting", 0, eCmdHdlrBinary, NULL, &amp;cs.bUseAsyncWriter,
1049 		STD_LOADABLE_MODULE_ID));
1050 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileflushontxend", 0, eCmdHdlrBinary, NULL, &amp;cs.bFlushOnTXEnd,
1051 		STD_LOADABLE_MODULE_ID));
1052 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileiobuffersize", 0, eCmdHdlrSize, NULL, &amp;cs.iIOBufSize,
1053 		STD_LOADABLE_MODULE_ID));
1054 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirowner", 0, eCmdHdlrUID, NULL, &amp;cs.dirUID,
1055 		STD_LOADABLE_MODULE_ID));
1056 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirownernum", 0, eCmdHdlrInt, NULL, &amp;cs.dirUID,
1057 		STD_LOADABLE_MODULE_ID));
1058 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirgroup", 0, eCmdHdlrGID, NULL, &amp;cs.dirGID,
1059 		STD_LOADABLE_MODULE_ID));
1060 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirgroupnum", 0, eCmdHdlrInt, NULL, &amp;cs.dirGID,
1061 		STD_LOADABLE_MODULE_ID));
1062 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"fileowner", 0, eCmdHdlrUID, NULL, &amp;cs.fileUID,
1063 		STD_LOADABLE_MODULE_ID));
1064 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"fileownernum", 0, eCmdHdlrInt, NULL, &amp;cs.fileUID,
1065 		STD_LOADABLE_MODULE_ID));
1066 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filegroup", 0, eCmdHdlrGID, NULL, &amp;cs.fileGID,
1067 		STD_LOADABLE_MODULE_ID));
1068 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filegroupnum", 0, eCmdHdlrInt, NULL, &amp;cs.fileGID,
1069 		STD_LOADABLE_MODULE_ID));
1070 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dircreatemode", 0, eCmdHdlrFileCreateMode, NULL,
1071 		&amp;cs.fDirCreateMode, STD_LOADABLE_MODULE_ID));
1072 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filecreatemode", 0, eCmdHdlrFileCreateMode, NULL,
1073 		&amp;cs.fCreateMode, STD_LOADABLE_MODULE_ID));
1074 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"createdirs", 0, eCmdHdlrBinary, NULL, &amp;cs.bCreateDirs,
1075 		STD_LOADABLE_MODULE_ID));
1076 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"failonchownfailure", 0, eCmdHdlrBinary, NULL, &amp;cs.bFailOnChown,
1077 		STD_LOADABLE_MODULE_ID));
1078 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileforcechown", 0, eCmdHdlrGoneAway, NULL, NULL,
1079 		STD_LOADABLE_MODULE_ID));
1080 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionfileenablesync", 0, eCmdHdlrBinary, NULL, &amp;cs.bEnableSync,
1081 		STD_LOADABLE_MODULE_ID));
1082 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionfiledefaulttemplate", 0, eCmdHdlrGetWord, setLegacyDfltTpl,
1083 		NULL, STD_LOADABLE_MODULE_ID));
1084 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
1085 		NULL, STD_LOADABLE_MODULE_ID));
1086 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
