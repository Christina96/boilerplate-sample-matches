
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 23.52941176470588%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rodft00e-r2hc.c</h3>
            <pre><code>1  #include "reodft/reodft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft super;
7       plan *cld;
8       twid *td;
9       INT is, os;
10       INT n;
11       INT vl;
12       INT ivs, ovs;
<span onclick='openModal()' class='match'>13  } P;
14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       INT is = ego->is, os = ego->os;
18       INT i, n = ego->n;
19       INT iv, vl = ego->vl;
</span>20       INT ivs = ego->ivs, ovs = ego->ovs;
21       R *W = ego->td->W;
22       R *buf;
23       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
24       for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {
25  	  buf[0] = 0;
26  	  for (i = 1; i < n - i; ++i) {
27  	       E a, b, apb, amb;
28  	       a = I[is * (i - 1)];
29  	       b = I[is * ((n - i) - 1)];
30  	       apb =  K(2.0) * W[i] * (a + b);
31  	       amb = (a - b);
32  	       buf[i] = apb + amb;
33  	       buf[n - i] = apb - amb;
34  	  }
35  	  if (i == n - i) {
36  	       buf[i] = K(4.0) * I[is * (i - 1)];
37  	  }
38  	  {
39  	       plan_rdft *cld = (plan_rdft *) ego->cld;
40  	       cld->apply((plan *) cld, buf, buf);
41  	  }
42  	  O[0] = buf[0] * 0.5;
43  	  for (i = 1; i + i < n - 1; ++i) {
44  	       INT k = i + i;
45  	       O[os * (k - 1)] = -buf[n - i];
46  	       O[os * k] = O[os * (k - 2)] + buf[i];
47  	  }
48  	  if (i + i == n - 1) {
49  	       O[os * (n - 2)] = -buf[n - i];
50  	  }
51       }
52       X(ifree)(buf);
53  }
54  static void awake(plan *ego_, enum wakefulness wakefulness)
55  {
56       P *ego = (P *) ego_;
57       static const tw_instr rodft00e_tw[] = {
58            { TW_SIN, 0, 1 },
59            { TW_NEXT, 1, 0 }
60       };
61       X(plan_awake)(ego->cld, wakefulness);
62       X(twiddle_awake)(wakefulness,
63  		      &ego->td, rodft00e_tw, 2*ego->n, 1, (ego->n+1)/2);
64  }
65  static void destroy(plan *ego_)
66  {
67       P *ego = (P *) ego_;
68       X(plan_destroy_internal)(ego->cld);
69  }
70  static void print(const plan *ego_, printer *p)
71  {
72       const P *ego = (const P *) ego_;
73       p->print(p, "(rodft00e-r2hc-%D%v%(%p%))", ego->n - 1, ego->vl, ego->cld);
74  }
75  static int applicable0(const solver *ego_, const problem *p_)
76  {
77       const problem_rdft *p = (const problem_rdft *) p_;
78       UNUSED(ego_);
79       return (1
80  	     && p->sz->rnk == 1
81  	     && p->vecsz->rnk <= 1
82  	     && p->kind[0] == RODFT00
83  	  );
84  }
85  static int applicable(const solver *ego, const problem *p, const planner *plnr)
86  {
87       return (!NO_SLOWP(plnr) && applicable0(ego, p));
88  }
89  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
90  {
91       P *pln;
92       const problem_rdft *p;
93       plan *cld;
94       R *buf;
95       INT n;
96       opcnt ops;
97       static const plan_adt padt = {
98  	  X(rdft_solve), awake, print, destroy
99       };
100       if (!applicable(ego_, p_, plnr))
101            return (plan *)0;
102       p = (const problem_rdft *) p_;
103       n = p->sz->dims[0].n + 1;
104       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
105       cld = X(mkplan_d)(plnr, X(mkproblem_rdft_1_d)(X(mktensor_1d)(n, 1, 1),
106                                                     X(mktensor_0d)(),
107                                                     buf, buf, R2HC));
108       X(ifree)(buf);
109       if (!cld)
110            return (plan *)0;
111       pln = MKPLAN_RDFT(P, &padt, apply);
112       pln->n = n;
113       pln->is = p->sz->dims[0].is;
114       pln->os = p->sz->dims[0].os;
115       pln->cld = cld;
116       pln->td = 0;
117       X(tensor_tornk1)(p->vecsz, &pln->vl, &pln->ivs, &pln->ovs);
118       X(ops_zero)(&ops);
119       ops.other = 4 + (n-1)/2 * 5 + (n-2)/2 * 5;
120       ops.add = (n-1)/2 * 4 + (n-2)/2 * 1;
121       ops.mul = 1 + (n-1)/2 * 2;
122       if (n % 2 == 0)
123  	  ops.mul += 1;
124       X(ops_zero)(&pln->super.super.ops);
125       X(ops_madd2)(pln->vl, &ops, &pln->super.super.ops);
126       X(ops_madd2)(pln->vl, &cld->ops, &pln->super.super.ops);
127       return &(pln->super.super);
128  }
129  static solver *mksolver(void)
130  {
131       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
132       S *slv = MKSOLVER(S, &sadt);
133       return &(slv->super);
134  }
135  void X(rodft00e_r2hc_register)(planner *p)
136  {
137       REGISTER_SOLVER(p, mksolver());
138  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-direct.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  typedef struct {
3       ct_solver super;
4       const ct_desc *desc;
5       int bufferedp;
6       kdftw k;
7  } S;
8  typedef struct {
9       plan_dftw super;
10       kdftw k;
11       INT r;
12       stride rs;
13       INT m, ms, v, vs, mb, me, extra_iter;
14       stride brs;
15       twid *td;
16       const S *slv;
17  } P;
18  static void apply(const plan *ego_, R *rio, R *iio)
19  {
20       const P *ego = (const P *) ego_;
21       INT i;
22       ASSERT_ALIGNED_DOUBLE;
23       for (i = 0; i < ego->v; ++i, rio += ego->vs, iio += ego->vs) {
24  	  INT  mb = ego->mb, ms = ego->ms;
25  	  ego->k(rio + mb*ms, iio + mb*ms, ego->td->W, 
26  		 ego->rs, mb, ego->me, ms);
27       }
28  }
29  static void apply_extra_iter(const plan *ego_, R *rio, R *iio)
30  {
31       const P *ego = (const P *) ego_;
32       INT i, v = ego->v, vs = ego->vs;
33       INT mb = ego->mb, me = ego->me, mm = me - 1, ms = ego->ms;
34       ASSERT_ALIGNED_DOUBLE;
35       for (i = 0; i < v; ++i, rio += vs, iio += vs) {
36  	  ego->k(rio + mb*ms, iio + mb*ms, ego->td->W, 
37  		 ego->rs, mb, mm, ms);
38  	  ego->k(rio + mm*ms, iio + mm*ms, ego->td->W, 
39  		 ego->rs, mm, mm+2, 0);
40       }
41  }
42  static void dobatch(const P *ego, R *rA, R *iA, INT mb, INT me, R *buf)
43  {
44       INT brs = WS(ego->brs, 1);
45       INT rs = WS(ego->rs, 1);
46       INT ms = ego->ms;
47       X(cpy2d_pair_ci)(rA + mb*ms, iA + mb*ms, buf, buf + 1,
48  		      ego->r, rs, brs,
49  		      me - mb, ms, 2);
50       ego->k(buf, buf + 1, ego->td->W, ego->brs, mb, me, 2);
51       X(cpy2d_pair_co)(buf, buf + 1, rA + mb*ms, iA + mb*ms,
52  		      ego->r, brs, rs,
53  		      me - mb, 2, ms);
54  }
55  static INT compute_batchsize(INT radix)
56  {
57       radix += 3;
58       radix &= -4;
59       return (radix + 2);
<span onclick='openModal()' class='match'>60  }
61  static void apply_buf(const plan *ego_, R *rio, R *iio)
62  {
63       const P *ego = (const P *) ego_;
64       INT i, j, v = ego->v, r = ego->r;
65       INT batchsz = compute_batchsize(r);
66       R *buf;
67       INT mb = ego->mb, me = ego->me;
</span>68       size_t bufsz = r * batchsz * 2 * sizeof(R);
69       BUF_ALLOC(R *, buf, bufsz);
70       for (i = 0; i < v; ++i, rio += ego->vs, iio += ego->vs) {
71  	  for (j = mb; j + batchsz < me; j += batchsz) 
72  	       dobatch(ego, rio, iio, j, j + batchsz, buf);
73  	  dobatch(ego, rio, iio, j, me, buf);
74       }
75       BUF_FREE(buf, bufsz);
76  }
77  static void awake(plan *ego_, enum wakefulness wakefulness)
78  {
79       P *ego = (P *) ego_;
80       X(twiddle_awake)(wakefulness, &ego->td, ego->slv->desc->tw,
81  		      ego->r * ego->m, ego->r, ego->m + ego->extra_iter);
82  }
83  static void destroy(plan *ego_)
84  {
85       P *ego = (P *) ego_;
86       X(stride_destroy)(ego->brs);
87       X(stride_destroy)(ego->rs);
88  }
89  static void print(const plan *ego_, printer *p)
90  {
91       const P *ego = (const P *) ego_;
92       const S *slv = ego->slv;
93       const ct_desc *e = slv->desc;
94       if (slv->bufferedp)
95  	  p->print(p, "(dftw-directbuf/%D-%D/%D%v \"%s\")",
96  		   compute_batchsize(ego->r), ego->r,
97  		   X(twiddle_length)(ego->r, e->tw), ego->v, e->nam);
98       else
99  	  p->print(p, "(dftw-direct-%D/%D%v \"%s\")",
100  		   ego->r, X(twiddle_length)(ego->r, e->tw), ego->v, e->nam);
101  }
102  static int applicable0(const S *ego,
103  		       INT r, INT irs, INT ors,
104  		       INT m, INT ms,
105  		       INT v, INT ivs, INT ovs,
106  		       INT mb, INT me,
107  		       R *rio, R *iio,
108  		       const planner *plnr, INT *extra_iter)
109  {
110       const ct_desc *e = ego->desc;
111       UNUSED(v);
112       return (
113  	  1
114  	  && r == e->radix
115  	  && irs == ors &bsol;* in-place along R */
116  	  && ivs == ovs &bsol;* in-place along V */
117  	  && ((*extra_iter = 0,
118  	       e->genus->okp(e, rio, iio, irs, ivs, m, mb, me, ms, plnr))
119  	      ||
120  	      (*extra_iter = 1,
121  	       (1
122  		&& mb == 0 && me == m
123  		&& e->genus->okp(e, rio, iio, irs, ivs,
124  				 m, mb, me - 1, ms, plnr)
125  		&& e->genus->okp(e, rio, iio, irs, ivs,
126  				 m, me - 1, me + 1, ms, plnr))))
127  	  && (e->genus->okp(e, rio + ivs, iio + ivs, irs, ivs,
128  			    m, mb, me - *extra_iter, ms, plnr))
129  	  );
130  }
131  static int applicable0_buf(const S *ego,
132  			   INT r, INT irs, INT ors,
133  			   INT m, INT ms,
134  			   INT v, INT ivs, INT ovs,
135  			   INT mb, INT me,
136  			   R *rio, R *iio,
137  			   const planner *plnr)
138  {
139       const ct_desc *e = ego->desc;
140       INT batchsz;
141       UNUSED(v); UNUSED(ms); UNUSED(rio); UNUSED(iio);
142       return (
143  	  1
144  	  && r == e->radix
145  	  && irs == ors &bsol;* in-place along R */
146  	  && ivs == ovs &bsol;* in-place along V */
147  	  && (batchsz = compute_batchsize(r), 1)
148  	  && (e->genus->okp(e, 0, ((const R *)0) + 1, 2 * batchsz, 0,
149  			    m, mb, mb + batchsz, 2, plnr))
150  	  && (e->genus->okp(e, 0, ((const R *)0) + 1, 2 * batchsz, 0,
151  			    m, mb, me, 2, plnr))
152  	  );
153  }
154  static int applicable(const S *ego,
155  		      INT r, INT irs, INT ors,
156  		      INT m, INT ms,
157  		      INT v, INT ivs, INT ovs,
158  		      INT mb, INT me,
159  		      R *rio, R *iio,
160  		      const planner *plnr, INT *extra_iter)
161  {
162       if (ego->bufferedp) {
163  	  *extra_iter = 0;
164  	  if (!applicable0_buf(ego,
165  			       r, irs, ors, m, ms, v, ivs, ovs, mb, me,
166  			       rio, iio, plnr))
167  	       return 0;
168       } else {
169  	  if (!applicable0(ego,
170  			   r, irs, ors, m, ms, v, ivs, ovs, mb, me,
171  			   rio, iio, plnr, extra_iter))
172  	       return 0;
173       }
174       if (NO_UGLYP(plnr) && X(ct_uglyp)((ego->bufferedp? (INT)512 : (INT)16),
175  				       v, m * r, r))
176  	  return 0;
177       if (m * r > 262144 && NO_FIXED_RADIX_LARGE_NP(plnr))
178  	  return 0;
179       return 1;
180  }
181  static plan *mkcldw(const ct_solver *ego_,
182  		    INT r, INT irs, INT ors,
183  		    INT m, INT ms,
184  		    INT v, INT ivs, INT ovs,
185  		    INT mstart, INT mcount,
186  		    R *rio, R *iio,
187  		    planner *plnr)
188  {
189       const S *ego = (const S *) ego_;
190       P *pln;
191       const ct_desc *e = ego->desc;
192       INT extra_iter;
193       static const plan_adt padt = {
194  	  0, awake, print, destroy
195       };
196       A(mstart >= 0 && mstart + mcount <= m);
197       if (!applicable(ego,
198  		     r, irs, ors, m, ms, v, ivs, ovs, mstart, mstart + mcount,
199  		     rio, iio, plnr, &extra_iter))
200            return (plan *)0;
201       if (ego->bufferedp) {
202  	  pln = MKPLAN_DFTW(P, &padt, apply_buf);
203       } else {
204  	  pln = MKPLAN_DFTW(P, &padt, extra_iter ? apply_extra_iter : apply);
205       }
206       pln->k = ego->k;
207       pln->rs = X(mkstride)(r, irs);
208       pln->td = 0;
209       pln->r = r;
210       pln->m = m;
211       pln->ms = ms;
212       pln->v = v;
213       pln->vs = ivs;
214       pln->mb = mstart;
215       pln->me = mstart + mcount;
216       pln->slv = ego;
217       pln->brs = X(mkstride)(r, 2 * compute_batchsize(r));
218       pln->extra_iter = extra_iter;
219       X(ops_zero)(&pln->super.super.ops);
220       X(ops_madd2)(v * (mcount/e->genus->vl), &e->ops, &pln->super.super.ops);
221       if (ego->bufferedp) {
222  	  pln->super.super.ops.other += 8 * r * mcount * v;
223       }
224       pln->super.super.could_prune_now_p =
225  	  (!ego->bufferedp && r >= 5 && r < 64 && m >= r);
226       return &(pln->super.super);
227  }
228  static void regone(planner *plnr, kdftw codelet,
229  		   const ct_desc *desc, int dec, int bufferedp)
230  {
231       S *slv = (S *)X(mksolver_ct)(sizeof(S), desc->radix, dec, mkcldw, 0);
232       slv->k = codelet;
233       slv->desc = desc;
234       slv->bufferedp = bufferedp;
235       REGISTER_SOLVER(plnr, &(slv->super.super));
236       if (X(mksolver_ct_hook)) {
237  	  slv = (S *)X(mksolver_ct_hook)(sizeof(S), desc->radix,
238  					 dec, mkcldw, 0);
239  	  slv->k = codelet;
240  	  slv->desc = desc;
241  	  slv->bufferedp = bufferedp;
242  	  REGISTER_SOLVER(plnr, &(slv->super.super));
243       }
244  }
245  void X(regsolver_ct_directw)(planner *plnr, kdftw codelet,
246  			     const ct_desc *desc, int dec)
247  {
248       regone(plnr, codelet, desc, dec, &bsol;* bufferedp */ 0);
249       regone(plnr, codelet, desc, dec, &bsol;* bufferedp */ 1);
250  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rodft00e-r2hc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-direct.c</div>
                </div>
                <div class="column column_space"><pre><code>13  } P;
14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       INT is = ego->is, os = ego->os;
18       INT i, n = ego->n;
19       INT iv, vl = ego->vl;
</pre></code></div>
                <div class="column column_space"><pre><code>60  }
61  static void apply_buf(const plan *ego_, R *rio, R *iio)
62  {
63       const P *ego = (const P *) ego_;
64       INT i, j, v = ego->v, r = ego->r;
65       INT batchsz = compute_batchsize(r);
66       R *buf;
67       INT mb = ego->mb, me = ego->me;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    