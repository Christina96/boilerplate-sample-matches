<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imkafka.c &amp; imuxsock.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imkafka.c &amp; imuxsock.c
      </h3>
<h1 align="center">
        10.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imkafka.c (16.962843%)<th>imuxsock.c (7.3477955%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(135-150)<td><a href="#" name="0">(275-290)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(607-631)<td><a href="#" name="1">(1262-1286)</a><td align="center"><font color="#d90000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(536-551)<td><a href="#" name="2">(1339-1356)</a><td align="center"><font color="#8d0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(305-319)<td><a href="#" name="3">(344-362)</a><td align="center"><font color="#840000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(576-582)<td><a href="#" name="4">(407-413)</a><td align="center"><font color="#7a0000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(279-290)<td><a href="#" name="5">(317-327)</a><td align="center"><font color="#7a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imkafka.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;fcntl.h&gt;
9 #include &lt;pthread.h&gt;
10 #include &lt;sys/uio.h&gt;
11 #include &lt;librdkafka/rdkafka.h&gt;
12 #include "rsyslog.h"
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "atomic.h"
20 #include "statsobj.h"
21 #include "unicode-helper.h"
22 #include "prop.h"
23 #include "ruleset.h"
24 #include "glbl.h"
25 #include "cfsysline.h"
26 #include "msg.h"
27 #include "dirty.h"
28 MODULE_TYPE_INPUT
29 MODULE_TYPE_NOKEEP
30 MODULE_CNFNAME("imkafka")
31 DEF_IMOD_STATIC_DATA
32 DEFobjCurrIf(prop)
33 DEFobjCurrIf(ruleset)
34 DEFobjCurrIf(glbl)
35 DEFobjCurrIf(statsobj)
36 static void * imkafkawrkr(void *myself);
37 struct kafka_params {
38 	const char *name;
39 	const char *val;
40 };
41 static struct configSettings_s {
42 	uchar *topic;
43 	uchar *consumergroup;
44 	char *brokers;
45 	uchar *pszBindRuleset;
46 	int nConfParams;
47 	struct kafka_params *confParams;
48 } cs;
49 struct instanceConf_s {
50 	uchar *topic;
51 	uchar *consumergroup;
52 	char *brokers;
53 	int64_t offset;
54 	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;			int bReportErrs;
55 	int nConfParams;
56 	struct kafka_params *confParams;
57 	int bIsConnected;
58 	rd_kafka_conf_t *conf;
59 	rd_kafka_t *rk;
60 	rd_kafka_topic_conf_t *topic_conf;
61 	int partition;
62 	int bIsSubscribed;
63 	int nMsgParsingFlags;
64 	struct instanceConf_s *next;
65 };
66 struct modConfData_s {
67 	rsconf_t *pConf;			uchar *topic;
68 	uchar *consumergroup;
69 	char *brokers;
70 	instanceConf_t *root, *tail;
71 	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;		};
72 pthread_attr_t wrkrThrdAttr;	static int activeKafkaworkers = 0;
73 static struct kafkaWrkrInfo_s {
74 	pthread_t tid;			instanceConf_t *inst;	} *kafkaWrkrInfo;
75 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
76 static prop_t *pInputName = NULL;
77 <a name="0"></a>
78 static struct cnfparamdescr modpdescr[] = {
79 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "ruleset", eCmdHdlrGetWord, 0 },
80 };
81 static struct cnfparamblk modpblk =
82 	{ CNFPARAMBLK_VERSION,
83 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
84 	  modpdescr
85 	};
86 static struct cnfparamdescr inppdescr[] = {
87 	{ "topic", eCmdHdlrString, CNFPARAM_REQUIRED },
88 	{ "broker", eCmdHdlrArray, 0 },
89 	{ "confparam", eCmdHdlrArray, 0 },
90 	{ "consumergroup", eCmdHdlrString, 0},
91 	{ "ruleset", eCmdHdlrString, 0 },
92 	{ "parsehostname", eCmdHdlrBinary, 0 },</b></font>
93 };
94 static struct cnfparamblk inppblk =
95 	{ CNFPARAMBLK_VERSION,
96 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
97 	  inppdescr
98 	};
99 #include "im-helper.h" 
100 static void
101 kafkaLogger(const rd_kafka_t __attribute__((unused)) *rk, int level,
102 	    const char *fac, const char *buf)
103 {
104 	DBGPRINTF("imkafka: kafka log message [%d,%s]: %s\n",
105 		  level, fac, buf);
106 }
107 static rsRetVal enqMsg(instanceConf_t *const __restrict__ inst,
108 			rd_kafka_message_t *const __restrict__ rkmessage)
109 {
110 	DEFiRet;
111 	smsg_t *pMsg;
112 	if((int)rkmessage-&gt;len == 0) {
113 		FINALIZE;
114 	}
115 DBGPRINTF("imkafka: enqMsg: Msg: %.*s\n", (int)rkmessage-&gt;len, (char *)rkmessage-&gt;payload);
116 	CHKiRet(msgConstruct(&amp;pMsg));
117 	MsgSetInputName(pMsg, pInputName);
118 	MsgSetRawMsg(pMsg, (char*)rkmessage-&gt;payload, (int)rkmessage-&gt;len);
119 	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
120 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
121 	pMsg-&gt;msgFlags  = inst-&gt;nMsgParsingFlags;
122 	if (rkmessage-&gt;key_len) {
123 		DBGPRINTF("imkafka: enqMsg: Key: %.*s\n", (int)rkmessage-&gt;key_len, (char *)rkmessage-&gt;key);
124 		MsgSetTAG(pMsg, (const uchar *)rkmessage-&gt;key, (int)rkmessage-&gt;key_len);
125 	}
126 	MsgSetMSGoffs(pMsg, 0);	
127 	CHKiRet(submitMsg2(pMsg));
128 finalize_it:
129 	RETiRet;
130 }
131 static void msgConsume (instanceConf_t *inst) {
132 	rd_kafka_message_t *rkmessage = NULL;
133 	do { 		rkmessage = rd_kafka_consumer_poll(inst-&gt;rk, 1000); 		if(rkmessage == NULL) {
134 			DBGPRINTF("imkafka: msgConsume EMPTY Loop on %s/%s/%s\n",
135 				inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
136 			goto done;
137 		}
138 		if (rkmessage-&gt;err) {
139 			if (rkmessage-&gt;err == RD_KAFKA_RESP_ERR__PARTITION_EOF) {
140 				DBGPRINTF("imkafka: Consumer "
141 					"reached end of topic \"%s\" [%"PRId32"]"
142 					"message queue offset %"PRId64"\n",
143 					rd_kafka_topic_name(rkmessage-&gt;rkt),
144 					rkmessage-&gt;partition,
145 					rkmessage-&gt;offset);
146 				goto done;
147 			}
148 			if (rkmessage-&gt;rkt) {
149 				LogError(0, RS_RET_KAFKA_ERROR,
150 				"imkafka: Consumer error for topic \"%s\" [%"PRId32"]"
151 				"message queue offset %"PRId64": %s\n",
152 					rd_kafka_topic_name(rkmessage-&gt;rkt),
153 					rkmessage-&gt;partition,
154 					rkmessage-&gt;offset,
155 					rd_kafka_message_errstr(rkmessage));
156 			} else {
157 				LogError(0, RS_RET_KAFKA_ERROR,
158 					"imkafka: Consumer error for topic \"%s\": \"%s\"\n",
159 					rd_kafka_err2str(rkmessage-&gt;err),
160 					rd_kafka_message_errstr(rkmessage));
161 			}
162 			goto done;
163 		}
164 		DBGPRINTF("imkafka: msgConsume Loop on %s/%s/%s: [%"PRId32"], "
165 					"offset %"PRId64", %zd bytes):\n",
166 					inst-&gt;consumergroup,
167 					inst-&gt;brokers,
168 					rkmessage-&gt;partition,
169 					rkmessage-&gt;offset,
170 					rkmessage-&gt;len);
171 		enqMsg(inst, rkmessage);
172 		rd_kafka_message_destroy(rkmessage);
173 		rkmessage = NULL;
174 	} while(1); done:
175 	if(rkmessage != NULL) {
176 		rd_kafka_message_destroy(rkmessage);
177 	}
178 	return;
179 }
180 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static rsRetVal
181 createInstance(instanceConf_t **pinst)
182 {
183 	instanceConf_t *inst;
184 	DEFiRet;
185 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
186 	inst-&gt;next = NULL;
187 	inst-&gt;brokers = NULL;
188 	inst-&gt;topic = NULL;
189 	inst-&gt;consumergroup = NULL;
190 	inst-&gt;pszBindRuleset = NULL;</b></font>
191 	inst-&gt;nConfParams = 0;
192 	inst-&gt;confParams = NULL;
193 	inst-&gt;pBindRuleset = NULL;
194 	inst-&gt;bReportErrs = 1; 	inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
195 	inst-&gt;bIsConnected = 0;
196 	inst-&gt;bIsSubscribed = 0;
197 	inst-&gt;conf = NULL;
198 	inst-&gt;rk = NULL;
199 	inst-&gt;topic_conf = NULL;
200 <a name="3"></a>	inst-&gt;partition = RD_KAFKA_PARTITION_UA;
201 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(loadModConf-&gt;tail == NULL) {
202 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
203 	} else {
204 		loadModConf-&gt;tail-&gt;next = inst;
205 		loadModConf-&gt;tail = inst;
206 	}
207 	*pinst = inst;
208 finalize_it:
209 	RETiRet;
210 }
211 static rsRetVal ATTR_NONNULL()</b></font>
212 checkInstance(instanceConf_t *const inst)
213 {
214 	DEFiRet;
215 	char kafkaErrMsg[1024];
216 	inst-&gt;conf = rd_kafka_conf_new();
217 	if(inst-&gt;conf == NULL) {
218 		if(inst-&gt;bReportErrs) {
219 			LogError(0, RS_RET_KAFKA_ERROR,
220 				"imkafka: error creating kafka conf obj: %s\n",
221 				rd_kafka_err2str(rd_kafka_last_error()));
222 		}
223 		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
224 	}
225 #	ifdef DEBUG
226 	if(rd_kafka_conf_set(inst-&gt;conf, "debug", RD_KAFKA_DEBUG_CONTEXTS,
227 		kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
228 		LogError(0, RS_RET_KAFKA_ERROR, "imkafka: error setting kafka debug option: %s\n", kafkaErrMsg);
229 	}
230 #	endif
231 	for(int i = 0 ; i &lt; inst-&gt;nConfParams ; ++i) {
232 		assert(inst-&gt;confParams+i != NULL); 		DBGPRINTF("imkafka: setting custom configuration parameter: %s:%s\n",
233 			inst-&gt;confParams[i].name,
234 			inst-&gt;confParams[i].val);
235 		if(rd_kafka_conf_set(inst-&gt;conf,
236 			inst-&gt;confParams[i].name,
237 			inst-&gt;confParams[i].val,
238 			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
239 			if(inst-&gt;bReportErrs) {
240 				LogError(0, RS_RET_PARAM_ERROR, "error setting custom configuration "
241 					"parameter '%s=%s': %s",
242 					inst-&gt;confParams[i].name,
243 					inst-&gt;confParams[i].val, kafkaErrMsg);
244 			} else {
245 				DBGPRINTF("imkafka: error setting custom configuration parameter '%s=%s': %s",
246 					inst-&gt;confParams[i].name,
247 					inst-&gt;confParams[i].val, kafkaErrMsg);
248 			}
249 			ABORT_FINALIZE(RS_RET_PARAM_ERROR);
250 		}
251 	}
252 	inst-&gt;topic_conf = rd_kafka_topic_conf_new();
253 	if (inst-&gt;consumergroup != NULL) {
254 		DBGPRINTF("imkafka: setting consumergroup: '%s'\n", inst-&gt;consumergroup);
255 		if (rd_kafka_conf_set(inst-&gt;conf, "group.id", (char*) inst-&gt;consumergroup,
256 			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
257 			if(inst-&gt;bReportErrs) {
258 				LogError(0, RS_RET_KAFKA_ERROR,
259 					"imkafka: error assigning consumergroup %s to "
260 					"kafka config: %s\n", inst-&gt;consumergroup,
261 					kafkaErrMsg);
262 			}
263 			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
264 		}
265 		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, "auto.offset.reset",
266 			"smallest", kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
267 			if(inst-&gt;bReportErrs) {
268 				LogError(0, RS_RET_KAFKA_ERROR,
269 					"imkafka: error setting kafka auto.offset.reset on %s: %s\n",
270 					inst-&gt;consumergroup,
271 					kafkaErrMsg);
272 			}
273 			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
274 		}
275 		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, "offset.store.method",
276 			"broker", kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
277 			if(inst-&gt;bReportErrs) {
278 				LogError(0, RS_RET_KAFKA_ERROR,
279 					"imkafka: error setting kafka offset.store.method on %s: %s\n",
280 					inst-&gt;consumergroup,
281 					kafkaErrMsg);
282 			}
283 			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
284 		}
285 		rd_kafka_conf_set_default_topic_conf(inst-&gt;conf, inst-&gt;topic_conf);
286 	}
287 	#if RD_KAFKA_VERSION &gt;= 0x00090001
288 		rd_kafka_conf_set_log_cb(inst-&gt;conf, kafkaLogger);
289 	#endif
290 	inst-&gt;rk = rd_kafka_new(RD_KAFKA_CONSUMER, inst-&gt;conf,
291 				     kafkaErrMsg, sizeof(kafkaErrMsg));
292 	if(inst-&gt;rk == NULL) {
293 		if(inst-&gt;bReportErrs) {
294 			LogError(0, RS_RET_KAFKA_ERROR,
295 				"imkafka: error creating kafka handle: %s\n", kafkaErrMsg);
296 		}
297 		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
298 	}
299 	#if RD_KAFKA_VERSION &lt; 0x00090001
300 		rd_kafka_set_logger(inst-&gt;rk, kafkaLogger);
301 	#endif
302 	DBGPRINTF("imkafka: setting brokers: '%s'\n", inst-&gt;brokers);
303 	if(rd_kafka_brokers_add(inst-&gt;rk, (char*)inst-&gt;brokers) == 0) {
304 		if(inst-&gt;bReportErrs) {
305 			LogError(0, RS_RET_KAFKA_NO_VALID_BROKERS,
306 				"imkafka: no valid brokers specified: %s", inst-&gt;brokers);
307 		}
308 		ABORT_FINALIZE(RS_RET_KAFKA_NO_VALID_BROKERS);
309 	}
310 	inst-&gt;bIsConnected = 1;
311 finalize_it:
312 	if(iRet != RS_RET_OK) {
313 		if(inst-&gt;rk == NULL) {
314 			if(inst-&gt;conf != NULL) {
315 				rd_kafka_conf_destroy(inst-&gt;conf);
316 				inst-&gt;conf = NULL;
317 			}
318 		} else { 			rd_kafka_destroy(inst-&gt;rk);
319 			inst-&gt;rk = NULL;
320 		}
321 	}
322 	RETiRet;
323 }
324 static inline void
325 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
326 {
327 	if(inst-&gt;bReportErrs) {
328 		LogError(0, NO_ERRCODE, "imkafka: ruleset '%s' not found - "
329 			"using default ruleset instead",
330 			inst-&gt;pszBindRuleset);
331 	}
332 }
333 static rsRetVal ATTR_NONNULL(2)
334 addConsumer(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
335 {
336 	DEFiRet;
337 	rd_kafka_resp_err_t err;
338 	assert(inst != NULL);
339 	rd_kafka_topic_partition_list_t *topics = NULL;
340 	DBGPRINTF("imkafka: creating kafka consumer on %s/%s/%s\n",
341 		inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
342 	rd_kafka_poll_set_consumer(inst-&gt;rk);
343 	topics = rd_kafka_topic_partition_list_new(1);
344 	rd_kafka_topic_partition_list_add(topics, (const char*)inst-&gt;topic, inst-&gt;partition);
345 	DBGPRINTF("imkafka: Created topics(%d) for %s)\n",
346 		topics-&gt;cnt, inst-&gt;topic);
347 	if ((err = rd_kafka_subscribe(inst-&gt;rk, topics))) {
348 		inst-&gt;bIsSubscribed = 0;
349 		LogError(0, RS_RET_KAFKA_ERROR, "imkafka: Failed to start consuming "
350 			"topics: %s\n", rd_kafka_err2str(err));
351 		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
352 	} else {
353 		DBGPRINTF("imkafka: Successfully subscribed to %s/%s/%s\n",
354 			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
355 		inst-&gt;bIsSubscribed = 1;
356 	}
357 finalize_it:
358 	if(topics != NULL)
359 		rd_kafka_topic_partition_list_destroy(topics);
360 	RETiRet;
361 }
362 static rsRetVal ATTR_NONNULL()
363 processKafkaParam(char *const param,
364 	const char **const name,
365 	const char **const paramval)
366 {
367 	DEFiRet;
368 	char *val = strstr(param, "=");
369 	if(val == NULL) {
370 		LogError(0, RS_RET_PARAM_ERROR, "missing equal sign in "
371 				"parameter '%s'", param);
372 		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
373 	}
374 	*val = '\0'; 	++val; 	CHKmalloc(*name = strdup(param));
375 	CHKmalloc(*paramval = strdup(val));
376 finalize_it:
377 	RETiRet;
378 }
379 BEGINnewInpInst
380 	struct cnfparamvals *pvals;
381 	instanceConf_t *inst;
382 	int i;
383 <a name="2"></a>CODESTARTnewInpInst
384 	DBGPRINTF("newInpInst (imkafka)\n");
385 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
386 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
387 	}
388 	if(Debug) {
389 		dbgprintf("input param blk in imkafka:\n");
390 		cnfparamsPrint(&amp;inppblk, pvals);
391 	}
392 	CHKiRet(createInstance(&amp;inst));
393 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
394 		if(!pvals[i].bUsed)
395 			continue;
396 		if(!strcmp(inppblk.descr[i].name, "broker")) {
397 			es_str_t *es = es_newStr(128);</b></font>
398 			int bNeedComma = 0;
399 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
400 				if(bNeedComma)
401 					es_addChar(&amp;es, ',');
402 				es_addStr(&amp;es, pvals[i].val.d.ar-&gt;arr[j]);
403 				bNeedComma = 1;
404 			}
405 			inst-&gt;brokers = es_str2cstr(es, NULL);
406 			es_deleteStr(es);
407 		} else if(!strcmp(inppblk.descr[i].name, "confparam")) {
408 			inst-&gt;nConfParams = pvals[i].val.d.ar-&gt;nmemb;
409 			CHKmalloc(inst-&gt;confParams = malloc(sizeof(struct kafka_params)*inst-&gt;nConfParams));
410 			for(int j = 0; j &lt; inst-&gt;nConfParams; j++) {
411 				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
412 				CHKiRet(processKafkaParam(cstr, &amp;inst-&gt;confParams[j].name,
413 								&amp;inst-&gt;confParams[j].val));
414 				free(cstr);
415 			}
416 		} else if(!strcmp(inppblk.descr[i].name, "topic")) {
417 			inst-&gt;topic = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
418 		} else if(!strcmp(inppblk.descr[i].name, "consumergroup")) {
419 <a name="4"></a>			inst-&gt;consumergroup = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
420 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
421 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
422 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "parsehostname")) {
423 			if (pvals[i].val.d.n) {
424 				inst-&gt;nMsgParsingFlags = NEEDS_PARSING | PARSE_HOSTNAME;
425 			} else {
426 				inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
427 			}
428 		} else {</b></font>
429 			dbgprintf("imkafka: program error, non-handled "
430 			  "param '%s'\n", inppblk.descr[i].name);
431 		}
432 	}
433 	if(inst-&gt;brokers == NULL) {
434 		CHKmalloc(inst-&gt;brokers = strdup("localhost:9092"));
435 		LogMsg(0, NO_ERRCODE, LOG_INFO, "imkafka: \"broker\" parameter not specified "
436 			"using default of localhost:9092 -- this may not be what you want!");
437 	}
438 	DBGPRINTF("imkafka: newInpIns brokers=%s, topic=%s, consumergroup=%s\n",
439 		inst-&gt;brokers, inst-&gt;topic, inst-&gt;consumergroup);
440 finalize_it:
441 CODE_STD_FINALIZERnewInpInst
442 	cnfparamvalsDestruct(pvals, &amp;inppblk);
443 ENDnewInpInst
444 BEGINbeginCnfLoad
445 <a name="1"></a>CODESTARTbeginCnfLoad
446 	loadModConf = pModConf;
447 	pModConf-&gt;pConf = pConf;
448 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pModConf-&gt;pszBindRuleset = NULL;
449 ENDbeginCnfLoad
450 BEGINsetModCnf
451 	struct cnfparamvals *pvals = NULL;
452 	int i;
453 CODESTARTsetModCnf
454 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
455 	if(pvals == NULL) {
456 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imkafka: error processing module "
457 			"config parameters [module(...)]");
458 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
459 	}
460 	if(Debug) {
461 		dbgprintf("module (global) param blk for imkafka:\n");
462 		cnfparamsPrint(&amp;modpblk, pvals);
463 	}
464 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
465 		if(!pvals[i].bUsed)
466 			continue;
467 		if(!strcmp(modpblk.descr[i].name, "ruleset")) {
468 			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
469 		} else {
470 			dbgprintf("imkafka: program error, non-handled "
471 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
472 		}
473 	}
474 finalize_it:
475 	if(pvals != NULL)
476 		cnfparamvalsDestruct(pvals, &amp;modpblk);
477 ENDsetModCnf
478 BEGINendCnfLoad
479 CODESTARTendCnfLoad
480 	if(loadModConf-&gt;pszBindRuleset == NULL) {
481 		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
482 			loadModConf-&gt;pszBindRuleset = NULL;
483 		} else {
484 			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
485 		}
486 	}
487 finalize_it:
488 	free(cs.pszBindRuleset);
489 	cs.pszBindRuleset = NULL;
490 	loadModConf = NULL; ENDendCnfLoad
491 BEGINcheckCnf
492 	instanceConf_t *inst;
493 CODESTARTcheckCnf
494 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
495 		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
496 			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
497 		}
498 		std_checkRuleset(pModConf, inst);
499 	}
500 finalize_it:
501 ENDcheckCnf
502 BEGINactivateCnfPrePrivDrop
503 CODESTARTactivateCnfPrePrivDrop
504 	runModConf = pModConf;
505 ENDactivateCnfPrePrivDrop
506 BEGINactivateCnf
507 CODESTARTactivateCnf
508 	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
509 		iRet = checkInstance(inst);
510 	}
511 ENDactivateCnf
512 BEGINfreeCnf
513 	instanceConf_t *inst, *del;
514 CODESTARTfreeCnf
515 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
516 		free(inst-&gt;topic);
517 		free(inst-&gt;consumergroup);
518 		free(inst-&gt;brokers);
519 		free(inst-&gt;pszBindRuleset);
520 		for(int i = 0; i &lt; inst-&gt;nConfParams; i++) {
521 			free((void*)inst-&gt;confParams[i].name);
522 			free((void*)inst-&gt;confParams[i].val);
523 		}
524 		free((void*)inst-&gt;confParams);
525 		del = inst;
526 		inst = inst-&gt;next;
527 		free(del);
528 	}
529 	free(pModConf-&gt;pszBindRuleset);
530 ENDfreeCnf
531 static void
532 shutdownKafkaWorkers(void)
533 {
534 	int i;
535 	instanceConf_t *inst;
536 	assert(kafkaWrkrInfo != NULL);
537 	DBGPRINTF("imkafka: waiting on imkafka workerthread termination\n");
538 	for(i = 0 ; i &lt; activeKafkaworkers ; ++i) {
539 		pthread_join(kafkaWrkrInfo[i].tid, NULL);
540 		DBGPRINTF("imkafka: Stopped worker %d\n", i);
541 	}
542 	free(kafkaWrkrInfo);
543 	kafkaWrkrInfo = NULL;
544 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
545 		DBGPRINTF("imkafka: stop consuming %s/%s/%s\n",
546 			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
547 		rd_kafka_consumer_close(inst-&gt;rk); 		rd_kafka_destroy(inst-&gt;rk); 		DBGPRINTF("imkafka: stopped consuming %s/%s/%s\n",
548 			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
549 		#if RD_KAFKA_VERSION &lt; 0x00090001
550 		if (rd_kafka_wait_destroyed(10000) &lt; 0)	{
551 			DBGPRINTF("imkafka: error, rd_kafka_destroy did not finish after grace "
552 				"timeout (10s)!\n");
553 		} else {
554 			DBGPRINTF("imkafka: rd_kafka_destroy successfully finished\n");
555 		}
556 		#endif
557 	}
558 }
559 BEGINrunInput
560 	int i;
561 	instanceConf_t *inst;
562 CODESTARTrunInput
563 	DBGPRINTF("imkafka: runInput loop started ...\n");
564 	activeKafkaworkers = 0;
565 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
566 		if(inst-&gt;rk != NULL) {
567 			++activeKafkaworkers;
568 		}
569 	}
570 	if(activeKafkaworkers == 0) {
571 		LogError(0, RS_RET_ERR, "imkafka: no active inputs, input does "
572 			"not run - there should have been additional error "
573 			"messages given previously");
574 		ABORT_FINALIZE(RS_RET_ERR);
575 	}
576 	DBGPRINTF("imkafka: Starting %d imkafka workerthreads\n", activeKafkaworkers);
577 	kafkaWrkrInfo = calloc(activeKafkaworkers, sizeof(struct kafkaWrkrInfo_s));
578 	if (kafkaWrkrInfo == NULL) {
579 		LogError(errno, RS_RET_OUT_OF_MEMORY, "imkafka: worker-info array allocation failed.");
580 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
581 	}
582 	i = 0;
583 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
584 		kafkaWrkrInfo[i].inst = inst; 		pthread_create(&amp;kafkaWrkrInfo[i].tid, &amp;wrkrThrdAttr, imkafkawrkr, &amp;(kafkaWrkrInfo[i]));
585 		i++;
586 	}
587 	while(glbl.GetGlobalInputTermState() == 0) {
588 		if(glbl.GetGlobalInputTermState() == 0)
589 			srSleep(0, 100000);
590 	}
591 	DBGPRINTF("imkafka: terminating upon request of rsyslog core\n");
592 	shutdownKafkaWorkers();
593 finalize_it:
594 ENDrunInput
595 BEGINwillRun
596 CODESTARTwillRun
597 	CHKiRet(prop.Construct(&amp;pInputName));
598 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imkafka"), sizeof("imkafka") - 1));
599 	CHKiRet(prop.ConstructFinalize(pInputName));
600 finalize_it:
601 ENDwillRun
602 BEGINafterRun
603 CODESTARTafterRun
604 	if(pInputName != NULL)
605 		prop.Destruct(&amp;pInputName);
606 ENDafterRun
607 BEGINmodExit
608 CODESTARTmodExit
609 	pthread_attr_destroy(&amp;wrkrThrdAttr);
610 	objRelease(statsobj, CORE_COMPONENT);
611 	objRelease(ruleset, CORE_COMPONENT);
612 	objRelease(glbl, CORE_COMPONENT);
613 	objRelease(prop, CORE_COMPONENT);
614 ENDmodExit
615 BEGINisCompatibleWithFeature
616 CODESTARTisCompatibleWithFeature
617 	if(eFeat == sFEATURENonCancelInputTermination)
618 		iRet = RS_RET_OK;
619 ENDisCompatibleWithFeature
620 BEGINqueryEtryPt
621 CODESTARTqueryEtryPt
622 CODEqueryEtryPt_STD_IMOD_QUERIES
623 CODEqueryEtryPt_STD_CONF2_QUERIES
624 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
625 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
626 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
627 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
628 ENDqueryEtryPt
629 BEGINmodInit()
630 CODESTARTmodInit
631 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
632 CODEmodInit_QueryRegCFSLineHdlr
633 	CHKiRet(objUse(glbl, CORE_COMPONENT));
634 	CHKiRet(objUse(prop, CORE_COMPONENT));
635 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
636 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
637 	pthread_attr_init(&amp;wrkrThrdAttr);
638 	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
639 	DBGPRINTF("imkafka %s using librdkafka version %s, 0x%x\n",
640 		VERSION, rd_kafka_version_str(), rd_kafka_version());
641 ENDmodInit
642 static void *
643 imkafkawrkr(void *myself)
644 {
645 	struct kafkaWrkrInfo_s *me = (struct kafkaWrkrInfo_s*) myself;
646 	DBGPRINTF("imkafka: started kafka consumer workerthread on %s/%s/%s\n",
647 		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
648 	do {
649 		if(glbl.GetGlobalInputTermState() == 1)
650 			break; 
651 		if(me-&gt;inst-&gt;rk == NULL) {
652 			continue;
653 		}
654 		if(me-&gt;inst-&gt;bIsConnected == 1 &amp;&amp; me-&gt;inst-&gt;bIsSubscribed == 0 ) {
655 			addConsumer(runModConf, me-&gt;inst);
656 		}
657 		if(me-&gt;inst-&gt;bIsSubscribed == 1 ) {
658 			msgConsume(me-&gt;inst);
659 		}
660 		if(glbl.GetGlobalInputTermState() == 0)
661 			srSleep(0, 100000);
662 	} while(glbl.GetGlobalInputTermState() == 0);
663 	DBGPRINTF("imkafka: stopped kafka consumer workerthread on %s/%s/%s\n",
664 		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
665 	return NULL;
666 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imuxsock.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef __sun
2 #define _XPG4_2
3 #endif
4 #include "config.h"
5 #include &lt;stdlib.h&gt;
6 #include &lt;stdio.h&gt;
7 #include &lt;ctype.h&gt;
8 #include &lt;assert.h&gt;
9 #include &lt;string.h&gt;
10 #include &lt;errno.h&gt;
11 #include &lt;unistd.h&gt;
12 #include &lt;fcntl.h&gt;
13 #include &lt;poll.h&gt;
14 #include &lt;sys/stat.h&gt;
15 #include &lt;sys/un.h&gt;
16 #include &lt;sys/socket.h&gt;
17 #ifdef HAVE_LIBSYSTEMD
18 #	include &lt;systemd/sd-daemon.h&gt;
19 #endif
20 #if defined(__FreeBSD__)
21 	#include &lt;sys/param.h&gt;
22 #endif
23 #include "rsyslog.h"
24 #include "dirty.h"
25 #include "cfsysline.h"
26 #include "unicode-helper.h"
27 #include "module-template.h"
28 #include "srUtils.h"
29 #include "errmsg.h"
30 #include "net.h"
31 #include "glbl.h"
32 #include "msg.h"
33 #include "parser.h"
34 #include "prop.h"
35 #include "debug.h"
36 #include "ruleset.h"
37 #include "unlimited_select.h"
38 #include "statsobj.h"
39 #include "datetime.h"
40 #include "hashtable.h"
41 #include "ratelimit.h"
42 MODULE_TYPE_INPUT
43 MODULE_TYPE_NOKEEP
44 MODULE_CNFNAME("imuxsock")
45 #ifndef _PATH_LOG
46 #ifdef BSD
47 #define _PATH_LOG	"/var/run/log"
48 #else
49 #define _PATH_LOG	"/dev/log"
50 #endif
51 #endif
52 #ifndef SYSTEMD_JOURNAL
53 #define SYSTEMD_JOURNAL  "/run/systemd/journal"
54 #endif
55 #ifndef SYSTEMD_PATH_LOG
56 #define SYSTEMD_PATH_LOG SYSTEMD_JOURNAL "/syslog"
57 #endif
58 #define UNSET -1 
59 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
60 #if defined(_AIX)
61 #define ucred  ucred_t
62 #endif
63 #ifndef HAVE_SCM_CREDENTIALS
64 struct ucred { int pid; uid_t uid; gid_t gid; };
65 #endif
66 #ifndef SUN_LEN
67 #define SUN_LEN(su) \
68 	(sizeof(*(su)) - sizeof((su)-&gt;sun_path) + strlen((su)-&gt;sun_path))
69 #endif
70 DEF_IMOD_STATIC_DATA
71 DEFobjCurrIf(glbl)
72 DEFobjCurrIf(prop)
73 DEFobjCurrIf(net)
74 DEFobjCurrIf(parser)
75 DEFobjCurrIf(datetime)
76 DEFobjCurrIf(statsobj)
77 DEFobjCurrIf(ruleset)
78 statsobj_t *modStats;
79 STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
80 STATSCOUNTER_DEF(ctrLostRatelimit, mutCtrLostRatelimit)
81 STATSCOUNTER_DEF(ctrNumRatelimiters, mutCtrNumRatelimiters)
82 static unsigned int
83 hash_from_key_fn(void *k)
84 {
85 	return((unsigned) *((pid_t*) k));
86 }
87 static int
88 key_equals_fn(void *key1, void *key2)
89 {
90 	return *((pid_t*) key1) == *((pid_t*) key2);
91 }
92 typedef struct lstn_s {
93 	uchar *sockName;		prop_t *hostName;		int fd;				int flags;			int flowCtl;			unsigned int ratelimitInterval;
94 	unsigned int ratelimitBurst;
95 	intTiny ratelimitSev;		struct hashtable *ht;		sbool bParseHost;		sbool bCreatePath;		sbool bUseCreds;		sbool bAnnotate;		sbool bParseTrusted;		sbool bWritePid;		sbool bDiscardOwnMsgs;		sbool bUseSysTimeStamp;		sbool bUnlink;			sbool bUseSpecialParser;	ruleset_t *pRuleset;
96 } lstn_t;
97 static lstn_t *listeners;
98 static int sd_fds = 0;			
99 #if (defined(__FreeBSD__) &amp;&amp; (__FreeBSD_version &gt;= 1200061))
100 	#define DFLT_bUseSpecialParser 0
101 #else
102 	#define DFLT_bUseSpecialParser 1
103 #endif
104 #define DFLT_bCreatePath 0
105 #define DFLT_ratelimitInterval 0
106 #define DFLT_ratelimitBurst 200
107 #define DFLT_ratelimitSeverity 1			static struct configSettings_s {
108 	int bOmitLocalLogging;
109 	uchar *pLogSockName;
110 	uchar *pLogHostName;			int bUseFlowCtl;			int bUseFlowCtlSysSock;
111 	int bIgnoreTimestamp;			int bIgnoreTimestampSysSock;
112 	int bUseSysTimeStamp;			int bUseSysTimeStampSysSock;		int bWritePid;				int bWritePidSysSock;			int bCreatePath;			unsigned int ratelimitInterval;			unsigned int ratelimitIntervalSysSock;
113 	unsigned int ratelimitBurst;			unsigned int ratelimitBurstSysSock;
114 	int ratelimitSeverity;
115 	int ratelimitSeveritySysSock;
116 	int bAnnotate;				int bAnnotateSysSock;			int bParseTrusted;		} cs;
117 struct instanceConf_s {
118 	uchar *sockName;
119 	uchar *pLogHostName;			sbool bUseFlowCtl;			sbool bIgnoreTimestamp;			sbool bWritePid;			sbool bUseSysTimeStamp;			int bCreatePath;			unsigned int ratelimitInterval;			unsigned int ratelimitBurst;			int ratelimitSeverity;
120 	int bAnnotate;				int bParseTrusted;			sbool bDiscardOwnMsgs;			sbool bUnlink;
121 	sbool bUseSpecialParser;
122 	sbool bParseHost;
123 	uchar *pszBindRuleset;			ruleset_t *pBindRuleset;		struct instanceConf_s *next;
124 };
125 struct modConfData_s {
126 	rsconf_t *pConf;			instanceConf_t *root, *tail;
127 	uchar *pLogSockName;
128 	unsigned int ratelimitIntervalSysSock;
129 	unsigned int ratelimitBurstSysSock;
130 	int ratelimitSeveritySysSock;
131 	int bAnnotateSysSock;
132 	int bParseTrusted;
133 	int bUseSpecialParser;
134 	int bParseHost;
135 	sbool bIgnoreTimestamp;			sbool bUseFlowCtl;			sbool bOmitLocalLogging;
136 	sbool bWritePidSysSock;
137 	sbool bUseSysTimeStamp;
138 	sbool bDiscardOwnMsgs;
139 	sbool configSetViaV2Method;
140 	sbool bUnlink;
141 };
142 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
143 static struct cnfparamdescr modpdescr[] = {
144 	{ "syssock.use", eCmdHdlrBinary, 0 },
145 	{ "syssock.name", eCmdHdlrGetWord, 0 },
146 	{ "syssock.unlink", eCmdHdlrBinary, 0 },
147 	{ "syssock.ignoretimestamp", eCmdHdlrBinary, 0 },
148 	{ "syssock.ignoreownmessages", eCmdHdlrBinary, 0 },
149 	{ "syssock.flowcontrol", eCmdHdlrBinary, 0 },
150 	{ "syssock.usesystimestamp", eCmdHdlrBinary, 0 },
151 	{ "syssock.annotate", eCmdHdlrBinary, 0 },
152 	{ "syssock.parsetrusted", eCmdHdlrBinary, 0 },
153 	{ "syssock.usespecialparser", eCmdHdlrBinary, 0 },
154 	{ "syssock.parsehostname", eCmdHdlrBinary, 0 },
155 <a name="0"></a>	{ "syssock.usepidfromsystem", eCmdHdlrBinary, 0 },
156 	{ "syssock.ratelimit.interval", eCmdHdlrInt, 0 },
157 	{ "syssock.ratelimit.burst", eCmdHdlrInt, 0 },
158 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "syssock.ratelimit.severity", eCmdHdlrInt, 0 }
159 };
160 static struct cnfparamblk modpblk =
161 	{ CNFPARAMBLK_VERSION,
162 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
163 	  modpdescr
164 	};
165 static struct cnfparamdescr inppdescr[] = {
166 	{ "socket", eCmdHdlrString, CNFPARAM_REQUIRED }, 	{ "unlink", eCmdHdlrBinary, 0 },
167 	{ "createpath", eCmdHdlrBinary, 0 },
168 	{ "parsetrusted", eCmdHdlrBinary, 0 },
169 	{ "ignoreownmessages", eCmdHdlrBinary, 0 },
170 	{ "hostname", eCmdHdlrString, 0 },</b></font>
171 	{ "ignoretimestamp", eCmdHdlrBinary, 0 },
172 	{ "flowcontrol", eCmdHdlrBinary, 0 },
173 	{ "usesystimestamp", eCmdHdlrBinary, 0 },
174 	{ "annotate", eCmdHdlrBinary, 0 },
175 	{ "usespecialparser", eCmdHdlrBinary, 0 },
176 	{ "parsehostname", eCmdHdlrBinary, 0 },
177 	{ "usepidfromsystem", eCmdHdlrBinary, 0 },
178 	{ "ruleset", eCmdHdlrString, 0 },
179 	{ "ratelimit.interval", eCmdHdlrInt, 0 },
180 	{ "ratelimit.burst", eCmdHdlrInt, 0 },
181 	{ "ratelimit.severity", eCmdHdlrInt, 0 }
182 };
183 static struct cnfparamblk inppblk =
184 	{ CNFPARAMBLK_VERSION,
185 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
186 	  inppdescr
187 	};
188 #include "im-helper.h" 
189 static int bLegacyCnfModGlobalsPermitted;
190 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static rsRetVal
191 createInstance(instanceConf_t **pinst)
192 {
193 	instanceConf_t *inst;
194 	DEFiRet;
195 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
196 	inst-&gt;sockName = NULL;
197 	inst-&gt;pLogHostName = NULL;
198 	inst-&gt;pszBindRuleset = NULL;
199 	inst-&gt;pBindRuleset = NULL;
200 	inst-&gt;ratelimitInterval = DFLT_ratelimitInterval;</b></font>
201 	inst-&gt;ratelimitBurst = DFLT_ratelimitBurst;
202 	inst-&gt;ratelimitSeverity = DFLT_ratelimitSeverity;
203 	inst-&gt;bUseFlowCtl = 0;
204 	inst-&gt;bUseSpecialParser = DFLT_bUseSpecialParser;
205 	inst-&gt;bParseHost = UNSET;
206 	inst-&gt;bIgnoreTimestamp = 1;
207 	inst-&gt;bCreatePath = DFLT_bCreatePath;
208 	inst-&gt;bUseSysTimeStamp = 1;
209 	inst-&gt;bWritePid = 0;
210 	inst-&gt;bAnnotate = 0;
211 	inst-&gt;bParseTrusted = 0;
212 	inst-&gt;bDiscardOwnMsgs = loadModConf-&gt;pConf-&gt;globals.bProcessInternalMessages;
213 	inst-&gt;bUnlink = 1;
214 <a name="3"></a>	inst-&gt;next = NULL;
215 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(loadModConf-&gt;tail == NULL) {
216 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
217 	} else {
218 		loadModConf-&gt;tail-&gt;next = inst;
219 		loadModConf-&gt;tail = inst;
220 	}
221 	*pinst = inst;
222 finalize_it:
223 	RETiRet;
224 }
225 static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)</b></font>
226 {
227 	instanceConf_t *inst;
228 	DEFiRet;
229 	if(pNewVal == NULL || pNewVal[0] == '\0') {
230 		LogError(0, RS_RET_SOCKNAME_MISSING , "imuxsock: socket name must be specified, "
231 			        "but is not - listener not created\n");
232 		if(pNewVal != NULL)
233 			free(pNewVal);
234 		ABORT_FINALIZE(RS_RET_SOCKNAME_MISSING);
235 	}
236 	CHKiRet(createInstance(&amp;inst));
237 	inst-&gt;sockName = pNewVal;
238 	inst-&gt;ratelimitInterval = cs.ratelimitInterval;
239 	inst-&gt;pLogHostName = cs.pLogHostName;
240 	inst-&gt;ratelimitBurst = cs.ratelimitBurst;
241 	inst-&gt;ratelimitSeverity = cs.ratelimitSeverity;
242 	inst-&gt;bUseFlowCtl = cs.bUseFlowCtl;
243 	inst-&gt;bIgnoreTimestamp = cs.bIgnoreTimestamp;
244 	inst-&gt;bCreatePath = cs.bCreatePath;
245 	inst-&gt;bUseSysTimeStamp = cs.bUseSysTimeStamp;
246 	inst-&gt;bWritePid = cs.bWritePid;
247 	inst-&gt;bAnnotate = cs.bAnnotate;
248 	inst-&gt;bParseTrusted = cs.bParseTrusted;
249 	inst-&gt;bParseHost = UNSET;
250 	inst-&gt;next = NULL;
251 	cs.pLogHostName = NULL;
252 finalize_it:
253 	RETiRet;
254 }
255 static rsRetVal
256 addListner(instanceConf_t *inst)
257 <a name="4"></a>{
258 	DEFiRet;
259 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(inst-&gt;bParseHost == UNSET) {
260 		if(*inst-&gt;sockName == ':') {
261 			listeners[nfd].bParseHost = 1;
262 		} else {
263 			listeners[nfd].bParseHost = 0;
264 		}
265 	} else {</b></font>
266 		listeners[nfd].bParseHost = inst-&gt;bParseHost;
267 	}
268 	if(inst-&gt;pLogHostName == NULL) {
269 		listeners[nfd].hostName = NULL;
270 	} else {
271 		CHKiRet(prop.Construct(&amp;(listeners[nfd].hostName)));
272 		CHKiRet(prop.SetString(listeners[nfd].hostName, inst-&gt;pLogHostName, ustrlen(inst-&gt;pLogHostName)));
273 		CHKiRet(prop.ConstructFinalize(listeners[nfd].hostName));
274 	}
275 	if(inst-&gt;ratelimitInterval &gt; 0) {
276 		if((listeners[nfd].ht = create_hashtable(100, hash_from_key_fn, key_equals_fn,
277 			(void(*)(void*))ratelimitDestruct)) == NULL) {
278 			DBGPRINTF("imuxsock: turning off rate limiting because we could not "
279 				  "create hash table\n");
280 			inst-&gt;ratelimitInterval = 0;
281 		}
282 	} else {
283 		listeners[nfd].ht = NULL;
284 	}
285 	listeners[nfd].ratelimitInterval = inst-&gt;ratelimitInterval;
286 	listeners[nfd].ratelimitBurst = inst-&gt;ratelimitBurst;
287 	listeners[nfd].ratelimitSev = inst-&gt;ratelimitSeverity;
288 	listeners[nfd].flowCtl = inst-&gt;bUseFlowCtl ? eFLOWCTL_LIGHT_DELAY : eFLOWCTL_NO_DELAY;
289 	listeners[nfd].flags = inst-&gt;bIgnoreTimestamp ? IGNDATE : NOFLAG;
290 	listeners[nfd].bCreatePath = inst-&gt;bCreatePath;
291 	listeners[nfd].sockName = ustrdup(inst-&gt;sockName);
292 	listeners[nfd].bUseCreds = (inst-&gt;bDiscardOwnMsgs || inst-&gt;bWritePid || inst-&gt;ratelimitInterval
293 	|| inst-&gt;bAnnotate || inst-&gt;bUseSysTimeStamp) ? 1 : 0;
294 	listeners[nfd].bAnnotate = inst-&gt;bAnnotate;
295 	listeners[nfd].bParseTrusted = inst-&gt;bParseTrusted;
296 	listeners[nfd].bDiscardOwnMsgs = inst-&gt;bDiscardOwnMsgs;
297 	listeners[nfd].bUnlink = inst-&gt;bUnlink;
298 	listeners[nfd].bWritePid = inst-&gt;bWritePid;
299 	listeners[nfd].bUseSysTimeStamp = inst-&gt;bUseSysTimeStamp;
300 	listeners[nfd].bUseSpecialParser = inst-&gt;bUseSpecialParser;
301 	listeners[nfd].pRuleset = inst-&gt;pBindRuleset;
302 	CHKiRet(ratelimitNew(&amp;listeners[nfd].dflt_ratelimiter, "imuxsock", NULL));
303 	ratelimitSetLinuxLike(listeners[nfd].dflt_ratelimiter,
304 			      listeners[nfd].ratelimitInterval,
305 			      listeners[nfd].ratelimitBurst);
306 	ratelimitSetSeverity(listeners[nfd].dflt_ratelimiter,
307 			     listeners[nfd].ratelimitSev);
308 	nfd++;
309 finalize_it:
310 	RETiRet;
311 }
312 static rsRetVal discardLogSockets(void)
313 {
314 	int i;
315 	if(startIndexUxLocalSockets == 0) {
316 		if(listeners[0].ht != NULL) {
317 			hashtable_destroy(listeners[0].ht, 1); 		}
318 		ratelimitDestruct(listeners[0].dflt_ratelimiter);
319 	}
320 	for (i = 1; i &lt; nfd; i++) {
321 		if(listeners[i].sockName != NULL) {
322 			free(listeners[i].sockName);
323 			listeners[i].sockName = NULL;
324 		}
325 		if(listeners[i].hostName != NULL) {
326 			prop.Destruct(&amp;(listeners[i].hostName));
327 		}
328 		if(listeners[i].ht != NULL) {
329 			hashtable_destroy(listeners[i].ht, 1); 		}
330 		ratelimitDestruct(listeners[i].dflt_ratelimiter);
331 	}
332 	return RS_RET_OK;
333 }
334 #if defined(__clang__)
335 #pragma GCC diagnostic ignored "-Wunknown-attributes"
336 #endif
337 static rsRetVal
338 #if defined(__clang__)
339 __attribute__((no_sanitize("undefined")))
340 #endif
341 createLogSocket(lstn_t *pLstn)
342 {
343 	struct sockaddr_un sunx;
344 	DEFiRet;
345 	if(pLstn-&gt;bUnlink)
346 		unlink((char*)pLstn-&gt;sockName);
347 	memset(&amp;sunx, 0, sizeof(sunx));
348 	sunx.sun_family = AF_UNIX;
349 	if(pLstn-&gt;bCreatePath) {
350 		makeFileParentDirs((uchar*)pLstn-&gt;sockName, ustrlen(pLstn-&gt;sockName), 0755, -1, -1, 0);
351 	}
352 	strncpy(sunx.sun_path, (char*)pLstn-&gt;sockName, sizeof(sunx.sun_path));
353 	sunx.sun_path[sizeof(sunx.sun_path)-1] = '\0';
354 	pLstn-&gt;fd = socket(AF_UNIX, SOCK_DGRAM, 0);
355 	if(pLstn-&gt;fd &lt; 0 ) {
356 		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
357 	}
358 	if(bind(pLstn-&gt;fd, (struct sockaddr *) &amp;sunx, SUN_LEN(&amp;sunx)) &lt; 0) {
359 		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
360 	}
361 	if(chmod((char*)pLstn-&gt;sockName, 0666) &lt; 0) {
362 		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
363 	}
364 finalize_it:
365 	if(iRet != RS_RET_OK) {
366 		LogError(errno, iRet, "cannot create '%s'", pLstn-&gt;sockName);
367 		if(pLstn-&gt;fd != -1) {
368 			close(pLstn-&gt;fd);
369 			pLstn-&gt;fd = -1;
370 		}
371 	}
372 	RETiRet;
373 }
374 static rsRetVal
375 openLogSocket(lstn_t *pLstn)
376 {
377 	DEFiRet;
378 #	ifdef HAVE_SCM_CREDENTIALS
379 	int one;
380 #	endif 
381 	if(pLstn-&gt;sockName[0] == '\0')
382 		return -1;
383 	pLstn-&gt;fd = -1;
384 #ifdef HAVE_LIBSYSTEMD
385 	if (sd_fds &gt; 0) {
386 		int fd;
387 		for (fd = SD_LISTEN_FDS_START; fd &lt; SD_LISTEN_FDS_START + sd_fds; fd++) {
388 			if( sd_is_socket_unix(fd, SOCK_DGRAM, -1, (const char*) pLstn-&gt;sockName, 0) == 1) {
389 				pLstn-&gt;fd = fd;
390 				LogMsg(0, NO_ERRCODE, LOG_INFO,
391 					"imuxsock: Acquired UNIX socket '%s' (fd %d) from systemd.\n",
392 					pLstn-&gt;sockName, pLstn-&gt;fd);
393 				break;
394 			}
395 		}
396 	}
397 #endif
398 	if (pLstn-&gt;fd == -1) {
399 		CHKiRet(createLogSocket(pLstn));
400 		assert(pLstn-&gt;fd != -1); 	}
401 #	ifdef HAVE_SCM_CREDENTIALS
402 	if(pLstn-&gt;bUseCreds) {
403 		one = 1;
404 		if(setsockopt(pLstn-&gt;fd, SOL_SOCKET, SO_PASSCRED, &amp;one, (socklen_t) sizeof(one)) != 0) {
405 			LogError(errno, NO_ERRCODE, "set SO_PASSCRED failed on '%s'", pLstn-&gt;sockName);
406 			pLstn-&gt;bUseCreds = 0;
407 		}
408 		if(setsockopt(pLstn-&gt;fd, SOL_SOCKET, SO_TIMESTAMP, &amp;one, sizeof(one)) != 0) {
409 			LogError(errno, NO_ERRCODE, "set SO_TIMESTAMP failed on '%s'", pLstn-&gt;sockName);
410 		}
411 	}
412 #	else 	pLstn-&gt;bUseCreds = 0;
413 	pLstn-&gt;bAnnotate = 0;
414 #	endif 
415 finalize_it:
416 	if(iRet != RS_RET_OK) {
417 		if(pLstn-&gt;fd != -1) {
418 			close(pLstn-&gt;fd);
419 			pLstn-&gt;fd = -1;
420 		}
421 	}
422 	RETiRet;
423 }
424 static rsRetVal
425 findRatelimiter(lstn_t *pLstn, struct ucred *cred, ratelimit_t **prl)
426 {
427 	ratelimit_t *rl = NULL;
428 	int r;
429 	pid_t *keybuf;
430 	char pinfobuf[512];
431 	DEFiRet;
432 	if(cred == NULL)
433 		FINALIZE;
434 #if 0 	if(pLstn-&gt;ratelimitInterval == 0) {
435 		*prl = NULL;
436 		FINALIZE;
437 	}
438 #endif
439 	if(pLstn-&gt;ht == NULL) {
440 		*prl = NULL;
441 		FINALIZE;
442 	}
443 	rl = hashtable_search(pLstn-&gt;ht, &amp;cred-&gt;pid);
444 	if(rl == NULL) {
445 		DBGPRINTF("imuxsock: no ratelimiter for pid %lu, creating one\n",
446 			  (unsigned long) cred-&gt;pid);
447 		STATSCOUNTER_INC(ctrNumRatelimiters, mutCtrNumRatelimiters);
448 		char procName[256]; 		snprintf(procName, sizeof(procName), "/proc/%lu/cmdline", (unsigned long) cred-&gt;pid);
449 		FILE *f = fopen(procName, "r");
450 		if (f) {
451 			size_t len;
452 			len = fread(procName, sizeof(char), 256, f);
453 			if (len &gt; 0) {
454 				snprintf(pinfobuf, sizeof(pinfobuf), "pid: %lu, name: %s",
455 					(unsigned long) cred-&gt;pid, procName);
456 			}
457 			fclose(f);
458 		}
459 		else {
460 			snprintf(pinfobuf, sizeof(pinfobuf), "pid: %lu",
461 				(unsigned long) cred-&gt;pid);
462 		}
463 		pinfobuf[sizeof(pinfobuf)-1] = '\0'; 		CHKiRet(ratelimitNew(&amp;rl, "imuxsock", pinfobuf));
464 		ratelimitSetLinuxLike(rl, pLstn-&gt;ratelimitInterval, pLstn-&gt;ratelimitBurst);
465 		ratelimitSetSeverity(rl, pLstn-&gt;ratelimitSev);
466 		CHKmalloc(keybuf = malloc(sizeof(pid_t)));
467 		*keybuf = cred-&gt;pid;
468 		r = hashtable_insert(pLstn-&gt;ht, keybuf, rl);
469 		if(r == 0)
470 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
471 	}
472 	*prl = rl;
473 	rl = NULL;
474 finalize_it:
475 	if(rl != NULL)
476 		ratelimitDestruct(rl);
477 	if(*prl == NULL)
478 		*prl = pLstn-&gt;dflt_ratelimiter;
479 	RETiRet;
480 }
481 static void
482 fixPID(uchar *bufTAG, int *lenTag, struct ucred *cred)
483 {
484 	int i;
485 	char bufPID[16];
486 	int lenPID;
487 	if(cred == NULL)
488 		return;
489 	lenPID = snprintf(bufPID, sizeof(bufPID), "[%lu]:", (unsigned long) cred-&gt;pid);
490 	for(i = *lenTag ; i &gt;= 0  &amp;&amp; bufTAG[i] != '[' ; --i)
491 	if(i &lt; 0)
492 		i = *lenTag - 1; 
493 	if(i + lenPID &gt; CONF_TAG_MAXSIZE)
494 		return; 
495 	memcpy(bufTAG + i, bufPID, lenPID);
496 	*lenTag = i + lenPID;
497 }
498 static rsRetVal
499 getTrustedProp(struct ucred *cred, const char *propName, uchar *buf, size_t lenBuf, int *lenProp)
500 {
501 	int fd;
502 	int i;
503 	int lenRead;
504 	char namebuf[1024];
505 	DEFiRet;
506 	if(snprintf(namebuf, sizeof(namebuf), "/proc/%lu/%s", (long unsigned) cred-&gt;pid,
507 		propName) &gt;= (int) sizeof(namebuf)) {
508 		ABORT_FINALIZE(RS_RET_ERR);
509 	}
510 	if((fd = open(namebuf, O_RDONLY)) == -1) {
511 		DBGPRINTF("error reading '%s'\n", namebuf);
512 		ABORT_FINALIZE(RS_RET_ERR);
513 	}
514 	if((lenRead = read(fd, buf, lenBuf - 1)) == -1) {
515 		DBGPRINTF("error reading file data for '%s'\n", namebuf);
516 		close(fd);
517 		ABORT_FINALIZE(RS_RET_ERR);
518 	}
519 	for(i = 0 ; i &lt; lenRead ; ++i) {
520 		if(buf[i] == '\n')
521 			break;
522 		else if(iscntrl(buf[i]))
523 			buf[i] = ' ';
524 	}
525 	buf[i] = '\0';
526 	*lenProp = i;
527 	close(fd);
528 finalize_it:
529 	RETiRet;
530 }
531 static rsRetVal
532 getTrustedExe(struct ucred *cred, uchar *buf, size_t lenBuf, int* lenProp)
533 {
534 	int lenRead;
535 	char namebuf[1024];
536 	DEFiRet;
537 	if(snprintf(namebuf, sizeof(namebuf), "/proc/%lu/exe", (long unsigned) cred-&gt;pid)
538 		&gt;= (int) sizeof(namebuf)) {
539 		ABORT_FINALIZE(RS_RET_ERR);
540 	}
541 	if((lenRead = readlink(namebuf, (char*)buf, lenBuf - 1)) == -1) {
542 		DBGPRINTF("error reading link '%s'\n", namebuf);
543 		ABORT_FINALIZE(RS_RET_ERR);
544 	}
545 	buf[lenRead] = '\0';
546 	*lenProp = lenRead;
547 finalize_it:
548 	RETiRet;
549 }
550 static int
551 copyescaped(uchar *dstbuf, uchar *inbuf, int inlen)
552 {
553 	int iDst, iSrc;
554 	*dstbuf = '"';
555 	for(iDst=1, iSrc=0 ; iSrc &lt; inlen ; ++iDst, ++iSrc) {
556 		if(inbuf[iSrc] == '"' || inbuf[iSrc] == '\\') {
557 			dstbuf[iDst++] = '\\';
558 		}
559 		dstbuf[iDst] = inbuf[iSrc];
560 	}
561 	dstbuf[iDst++] = '"';
562 	return iDst;
563 }
564 static rsRetVal
565 SubmitMsg(uchar *pRcv, int lenRcv, lstn_t *pLstn, struct ucred *cred, struct timeval *ts)
566 {
567 	smsg_t *pMsg = NULL;
568 	int lenMsg;
569 	int offs;
570 	int i;
571 	uchar *parse;
572 	syslog_pri_t pri;
573 	uchar bufParseTAG[CONF_TAG_MAXSIZE];
574 	struct syslogTime st;
575 	time_t tt;
576 	ratelimit_t *ratelimiter = NULL;
577 	struct syslogTime dummyTS;
578 	DEFiRet;
579 	if(pLstn-&gt;bDiscardOwnMsgs &amp;&amp; cred != NULL &amp;&amp; cred-&gt;pid == glblGetOurPid()) {
580 		DBGPRINTF("imuxsock: discarding message from our own pid\n");
581 		FINALIZE;
582 	}
583 	parse = pRcv;
584 	lenMsg = lenRcv;
585 	offs = 1; 
586 	parse++;
587 	pri = 0;
588 	while(offs &lt; lenMsg &amp;&amp; isdigit(*parse)) {
589 		pri = pri * 10 + *parse - '0';
590 		++parse;
591 		++offs;
592 	}
593 	findRatelimiter(pLstn, cred, &amp;ratelimiter); 
594 	if(ts == NULL) {
595 		datetime.getCurrTime(&amp;st, &amp;tt, TIME_IN_LOCALTIME);
596 	} else {
597 		datetime.timeval2syslogTime(ts, &amp;st, TIME_IN_LOCALTIME);
598 		tt = ts-&gt;tv_sec;
599 	}
600 #if 0 	if(ratelimiter != NULL &amp;&amp; !withinRatelimit(ratelimiter, tt, cred-&gt;pid)) {
601 		STATSCOUNTER_INC(ctrLostRatelimit, mutCtrLostRatelimit);
602 		FINALIZE;
603 	}
604 #endif
605 	CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tt));
606 	if(cred != NULL &amp;&amp; pLstn-&gt;bAnnotate) {
607 		uchar propBuf[1024];
608 		int lenProp;
609 		if (pLstn-&gt;bParseTrusted) {
610 			struct json_object *json, *jval;
611 #define CHKjson(operation, toBeFreed)					\
612 			if((operation) == NULL) {			\
613 				json_object_put(toBeFreed);		\
614 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);	\
615 			}
616 			CHKmalloc(json = json_object_new_object());
617 			CHKjson(jval = json_object_new_int(cred-&gt;pid), json);
618 			json_object_object_add(json, "pid", jval);
619 			CHKjson(jval = json_object_new_int(cred-&gt;uid), json);
620 			json_object_object_add(json, "uid", jval);
621 			CHKjson(jval = json_object_new_int(cred-&gt;gid), json);
622 			json_object_object_add(json, "gid", jval);
623 			if(getTrustedProp(cred, "comm", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
624 				CHKjson(jval = json_object_new_string((char*)propBuf), json);
625 				json_object_object_add(json, "appname", jval);
626 			}
627 			if(getTrustedExe(cred, propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
628 				CHKjson(jval = json_object_new_string((char*)propBuf), json);
629 				json_object_object_add(json, "exe", jval);
630 			}
631 			if(getTrustedProp(cred, "cmdline", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
632 				CHKjson(jval = json_object_new_string((char*)propBuf), json);
633 				json_object_object_add(json, "cmd", jval);
634 			}
635 #undef CHKjson
636 			msgAddJSON(pMsg, (uchar*)"!", json, 0, 0);
637 			MsgSetRawMsg(pMsg, (char*)pRcv, lenRcv);
638 		} else {
639 			uchar msgbuf[8192];
640 			uchar *pmsgbuf = msgbuf;
641 			int toffs; 
642 			if((unsigned) (lenRcv + 4096) &gt;= sizeof(msgbuf)) {
643 				CHKmalloc(pmsgbuf = malloc(lenRcv+4096));
644 			}
645 			memcpy(pmsgbuf, pRcv, lenRcv);
646 			memcpy(pmsgbuf+lenRcv, " @[", 3);
647 			toffs = lenRcv + 3; 			lenProp = snprintf((char*)propBuf, sizeof(propBuf), "_PID=%lu _UID=%lu _GID=%lu",
648 				 		(long unsigned) cred-&gt;pid, (long unsigned) cred-&gt;uid,
649 						(long unsigned) cred-&gt;gid);
650 			memcpy(pmsgbuf+toffs, propBuf, lenProp);
651 			toffs = toffs + lenProp;
652 			if(getTrustedProp(cred, "comm", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
653 				memcpy(pmsgbuf+toffs, " _COMM=", 7);
654 				memcpy(pmsgbuf+toffs+7, propBuf, lenProp);
655 				toffs = toffs + 7 + lenProp;
656 			}
657 			if(getTrustedExe(cred, propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
658 				memcpy(pmsgbuf+toffs, " _EXE=", 6);
659 				memcpy(pmsgbuf+toffs+6, propBuf, lenProp);
660 				toffs = toffs + 6 + lenProp;
661 			}
662 			if(getTrustedProp(cred, "cmdline", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
663 				memcpy(pmsgbuf+toffs, " _CMDLINE=", 10);
664 				toffs = toffs + 10 +
665 					copyescaped(pmsgbuf+toffs+10, propBuf, lenProp);
666 			}
667 			pmsgbuf[toffs] = ']';
668 			pmsgbuf[toffs+1] = '\0';
669 			MsgSetRawMsg(pMsg, (char*)pmsgbuf, toffs + 1);
670 			if (pmsgbuf != msgbuf) {
671 				free(pmsgbuf);
672 			}
673 		}
674 	} else {
675 		MsgSetRawMsg(pMsg, (char*)pRcv, lenRcv);
676 	}
677 	MsgSetFlowControlType(pMsg, pLstn-&gt;flowCtl);
678 	MsgSetInputName(pMsg, pInputName);
679 	if(pLstn-&gt;bParseHost) {
680 		pMsg-&gt;msgFlags  = pLstn-&gt;flags | PARSE_HOSTNAME;
681 	} else {
682 		pMsg-&gt;msgFlags  = pLstn-&gt;flags;
683 	}
684 	if(pLstn-&gt;bUseSpecialParser) {
685 		parser.SanitizeMsg(pMsg);
686 		lenMsg = pMsg-&gt;iLenRawMsg - offs; 		msgSetPRI(pMsg, pri);
687 		MsgSetAfterPRIOffs(pMsg, offs);
688 		parse++; lenMsg--; 		if(ts == NULL) {
689 			if((pLstn-&gt;flags &amp; IGNDATE)) {
690 				if (datetime.ParseTIMESTAMP3339(&amp;dummyTS, &amp;parse, &amp;lenMsg) != RS_RET_OK) {
691 					datetime.ParseTIMESTAMP3164(&amp;dummyTS, &amp;parse, &amp;lenMsg,
692 					NO_PARSE3164_TZSTRING, NO_PERMIT_YEAR_AFTER_TIME);
693 				}
694 			} else {
695 				if(datetime.ParseTIMESTAMP3339(&amp;(pMsg-&gt;tTIMESTAMP), &amp;parse, &amp;lenMsg) != RS_RET_OK &amp;&amp;
696 				datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;parse, &amp;lenMsg,
697 				NO_PARSE3164_TZSTRING, NO_PERMIT_YEAR_AFTER_TIME) != RS_RET_OK) {
698 					DBGPRINTF("we have a problem, invalid timestamp in msg!\n");
699 				}
700 			}
701 		} else { 			uchar *tmpParse = parse; 			if(datetime.ParseTIMESTAMP3339(&amp;dummyTS, &amp;tmpParse, &amp;lenMsg) == RS_RET_OK ||
702 		 	datetime.ParseTIMESTAMP3164(&amp;dummyTS, &amp;tmpParse, &amp;lenMsg, NO_PARSE3164_TZSTRING,
703 			NO_PERMIT_YEAR_AFTER_TIME) == RS_RET_OK) {
704 				datetime.formatTimestamp3164(&amp;st, (char*)parse, 0);
705 				parse[15] = ' '; 				parse += 16;
706 			}
707 		}
708 		i = 0;
709 		while(lenMsg &gt; 0 &amp;&amp; *parse != ' ' &amp;&amp; i &lt; CONF_TAG_MAXSIZE - 1) {
710 			bufParseTAG[i++] = *parse++;
711 			--lenMsg;
712 		}
713 		bufParseTAG[i] = '\0';			if(pLstn-&gt;bWritePid)
714 			fixPID(bufParseTAG, &amp;i, cred);
715 		MsgSetTAG(pMsg, bufParseTAG, i);
716 		MsgSetMSGoffs(pMsg, pMsg-&gt;iLenRawMsg - lenMsg);
717 	} else { 		pMsg-&gt;msgFlags  |= NEEDS_PARSING;
718 	}
719 	MsgSetRcvFrom(pMsg, pLstn-&gt;hostName == NULL ? glbl.GetLocalHostNameProp() : pLstn-&gt;hostName);
720 	CHKiRet(MsgSetRcvFromIP(pMsg, pLocalHostIP));
721 	MsgSetRuleset(pMsg, pLstn-&gt;pRuleset);
722 	ratelimitAddMsg(ratelimiter, NULL, pMsg);
723 	STATSCOUNTER_INC(ctrSubmit, mutCtrSubmit);
724 finalize_it:
725 	if(iRet != RS_RET_OK) {
726 		if(pMsg != NULL)
727 			msgDestruct(&amp;pMsg);
728 	}
729 	RETiRet;
730 }
731 static rsRetVal readSocket(lstn_t *pLstn)
732 {
733 	DEFiRet;
734 	int iRcvd;
735 	int iMaxLine;
736 	struct msghdr msgh;
737 	struct iovec msgiov;
738 	struct ucred cred;
739 	struct timeval ts;
740 	int cred_set = 0;
741 	int ts_set = 0;
742 	uchar bufRcv[4096+1];
743 	uchar *pRcv = NULL; #	ifdef HAVE_SCM_CREDENTIALS
744 	union {
745 		char buf[128];
746 		struct cmsghdr cm;
747 	} aux;
748 #	endif
749 	assert(pLstn-&gt;fd &gt;= 0);
750 	iMaxLine = glbl.GetMaxLine(runConf);
751 	if((size_t) iMaxLine &lt; sizeof(bufRcv) - 1) {
752 		pRcv = bufRcv;
753 	} else {
754 		CHKmalloc(pRcv = (uchar*) malloc(iMaxLine + 1));
755 	}
756 	memset(&amp;msgh, 0, sizeof(msgh));
757 	memset(&amp;msgiov, 0, sizeof(msgiov));
758 #	ifdef HAVE_SCM_CREDENTIALS
759 	if(pLstn-&gt;bUseCreds) {
760 		memset(&amp;aux, 0, sizeof(aux));
761 		msgh.msg_control = &amp;aux;
762 		msgh.msg_controllen = sizeof(aux);
763 	}
764 #	endif
765 	msgiov.iov_base = (char*)pRcv;
766 	msgiov.iov_len = iMaxLine;
767 	msgh.msg_iov = &amp;msgiov;
768 	msgh.msg_iovlen = 1;
769 #if defined (_AIX)
770 #define MSG_DONTWAIT    MSG_NONBLOCK
771 #endif
772 	iRcvd = recvmsg(pLstn-&gt;fd, &amp;msgh, MSG_DONTWAIT);
773 	DBGPRINTF("Message from UNIX socket: #%d, size %d\n", pLstn-&gt;fd, (int) iRcvd);
774 	if(iRcvd &gt; 0) {
775 #		if defined(HAVE_SCM_CREDENTIALS) || defined(HAVE_SO_TIMESTAMP)
776 		if(pLstn-&gt;bUseCreds) {
777 			struct cmsghdr *cm;
778 			for(cm = CMSG_FIRSTHDR(&amp;msgh); cm; cm = CMSG_NXTHDR(&amp;msgh, cm)) {
779 #				ifdef HAVE_SCM_CREDENTIALS
780 				if(   pLstn-&gt;bUseCreds
781 				   &amp;&amp; cm-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cm-&gt;cmsg_type == SCM_CREDENTIALS) {
782 					memcpy(&amp;cred, CMSG_DATA(cm), sizeof(cred));
783 					cred_set = 1;
784 				}
785 #				endif #				if HAVE_SO_TIMESTAMP
786 				if(   pLstn-&gt;bUseSysTimeStamp
787 				   &amp;&amp; cm-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cm-&gt;cmsg_type == SO_TIMESTAMP) {
788 					memcpy(&amp;ts, CMSG_DATA(cm), sizeof(ts));
789 					ts_set = 1;
790 				}
791 #				endif 			}
792 		}
793 #		endif 		CHKiRet(SubmitMsg(pRcv, iRcvd, pLstn, (cred_set ? &amp;cred : NULL), (ts_set ? &amp;ts : NULL)));
794 	} else if(iRcvd &lt; 0 &amp;&amp; errno != EINTR &amp;&amp; errno != EAGAIN) {
795 		char errStr[1024];
796 		rs_strerror_r(errno, errStr, sizeof(errStr));
797 		DBGPRINTF("UNIX socket error: %d = %s.\n", errno, errStr);
798 		LogError(errno, NO_ERRCODE, "imuxsock: recvfrom UNIX");
799 	}
800 finalize_it:
801 	if(pRcv != NULL &amp;&amp; (size_t) iMaxLine &gt;= sizeof(bufRcv) - 1)
802 		free(pRcv);
803 	RETiRet;
804 }
805 static rsRetVal
806 activateListeners(void)
807 {
808 	int actSocks;
809 	int i;
810 	DEFiRet;
811 	if(startIndexUxLocalSockets == 0) {
812 		listeners[0].sockName = UCHAR_CONSTANT(_PATH_LOG);
813 		if(runModConf-&gt;pLogSockName != NULL) {
814 			listeners[0].sockName = runModConf-&gt;pLogSockName;
815 		}
816 #ifdef HAVE_LIBSYSTEMD
817 		else if(sd_booted()) {
818 			struct stat st;
819 			if(stat(SYSTEMD_PATH_LOG, &amp;st) != -1 &amp;&amp; S_ISSOCK(st.st_mode)) {
820 				listeners[0].sockName = (uchar*) SYSTEMD_PATH_LOG;
821 			}
822 		}
823 #endif
824 		if(runModConf-&gt;ratelimitIntervalSysSock &gt; 0) {
825 			if((listeners[0].ht = create_hashtable(100, hash_from_key_fn, key_equals_fn, NULL)) == NULL) {
826 				LogError(0, NO_ERRCODE, "imuxsock: turning off rate limiting because "
827 					"we could not create hash table\n");
828 				runModConf-&gt;ratelimitIntervalSysSock = 0;
829 			}
830 		} else {
831 			listeners[0].ht = NULL;
832 		}
833 		listeners[0].fd = -1;
834 		listeners[0].pRuleset = NULL;
835 		listeners[0].hostName = NULL;
836 		listeners[0].bParseHost = 0;
837 		listeners[0].bCreatePath = 0;
838 		listeners[0].ratelimitInterval = runModConf-&gt;ratelimitIntervalSysSock;
839 		listeners[0].ratelimitBurst = runModConf-&gt;ratelimitBurstSysSock;
840 		listeners[0].ratelimitSev = runModConf-&gt;ratelimitSeveritySysSock;
841 		listeners[0].bUseCreds = (runModConf-&gt;bWritePidSysSock || runModConf-&gt;ratelimitIntervalSysSock
842 		|| runModConf-&gt;bAnnotateSysSock || runModConf-&gt;bDiscardOwnMsgs
843 		|| runModConf-&gt;bUseSysTimeStamp) ? 1 : 0;
844 		listeners[0].bWritePid = runModConf-&gt;bWritePidSysSock;
845 		listeners[0].bAnnotate = runModConf-&gt;bAnnotateSysSock;
846 		listeners[0].bParseTrusted = runModConf-&gt;bParseTrusted;
847 		listeners[0].bParseHost = runModConf-&gt;bParseHost;
848 		listeners[0].bUseSpecialParser = runModConf-&gt;bUseSpecialParser;
849 		listeners[0].bDiscardOwnMsgs = runModConf-&gt;bDiscardOwnMsgs;
850 		listeners[0].bUnlink = runModConf-&gt;bUnlink;
851 		listeners[0].bUseSysTimeStamp = runModConf-&gt;bUseSysTimeStamp;
852 		listeners[0].flags = runModConf-&gt;bIgnoreTimestamp ? IGNDATE : NOFLAG;
853 		listeners[0].flowCtl = runModConf-&gt;bUseFlowCtl ? eFLOWCTL_LIGHT_DELAY : eFLOWCTL_NO_DELAY;
854 		CHKiRet(ratelimitNew(&amp;listeners[0].dflt_ratelimiter, "imuxsock", NULL));
855 			ratelimitSetLinuxLike(listeners[0].dflt_ratelimiter,
856 			listeners[0].ratelimitInterval,
857 			listeners[0].ratelimitBurst);
858 		ratelimitSetSeverity(listeners[0].dflt_ratelimiter,listeners[0].ratelimitSev);
859 	}
860 #ifdef HAVE_LIBSYSTEMD
861 	sd_fds = sd_listen_fds(0);
862 	if(sd_fds &lt; 0) {
863 		LogError(-sd_fds, NO_ERRCODE, "imuxsock: Failed to acquire systemd socket");
864 		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
865 	}
866 #endif
867 	actSocks = 0;
868 	for (i = startIndexUxLocalSockets ; i &lt; nfd ; i++) {
869 		if(openLogSocket(&amp;(listeners[i])) == RS_RET_OK) {
870 			++actSocks;
871 			DBGPRINTF("imuxsock: Opened UNIX socket '%s' (fd %d).\n",
872 				  listeners[i].sockName, listeners[i].fd);
873 		}
874 	}
875 	if(actSocks == 0) {
876 		LogError(0, RS_RET_ERR, "imuxsock does not run because we could not "
877 			"acquire any socket\n");
878 		ABORT_FINALIZE(RS_RET_ERR);
879 	}
880 finalize_it:
881 	RETiRet;
882 }
883 BEGINbeginCnfLoad
884 CODESTARTbeginCnfLoad
885 	loadModConf = pModConf;
886 	pModConf-&gt;pConf = pConf;
887 	pModConf-&gt;pLogSockName = NULL;
888 	pModConf-&gt;bOmitLocalLogging = 0;
889 	pModConf-&gt;bIgnoreTimestamp = 1;
890 	pModConf-&gt;bUseFlowCtl = 0;
891 	pModConf-&gt;bUseSysTimeStamp = 1;
892 	pModConf-&gt;bWritePidSysSock = 0;
893 	pModConf-&gt;bAnnotateSysSock = 0;
894 	pModConf-&gt;bParseTrusted = 0;
895 	pModConf-&gt;bParseHost = UNSET;
896 	pModConf-&gt;bUseSpecialParser = DFLT_bUseSpecialParser;
897 	pModConf-&gt;bDiscardOwnMsgs = pConf-&gt;globals.bProcessInternalMessages;
898 	pModConf-&gt;bUnlink = 1;
899 	pModConf-&gt;ratelimitIntervalSysSock = DFLT_ratelimitInterval;
900 	pModConf-&gt;ratelimitBurstSysSock = DFLT_ratelimitBurst;
901 <a name="1"></a>	pModConf-&gt;ratelimitSeveritySysSock = DFLT_ratelimitSeverity;
902 	bLegacyCnfModGlobalsPermitted = 1;
903 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	resetConfigVariables(NULL, NULL);
904 ENDbeginCnfLoad
905 BEGINsetModCnf
906 	struct cnfparamvals *pvals = NULL;
907 	int i;
908 CODESTARTsetModCnf
909 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
910 	if(pvals == NULL) {
911 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
912 				"config parameters [module(...)]");
913 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
914 	}
915 	if(Debug) {
916 		dbgprintf("module (global) param blk for imuxsock:\n");
917 		cnfparamsPrint(&amp;modpblk, pvals);
918 	}
919 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
920 		if(!pvals[i].bUsed)
921 			continue;
922 		if(!strcmp(modpblk.descr[i].name, "syssock.use")) {
923 			loadModConf-&gt;bOmitLocalLogging = ((int) pvals[i].val.d.n) ? 0 : 1;</b></font>
924 		} else if(!strcmp(modpblk.descr[i].name, "syssock.name")) {
925 			loadModConf-&gt;pLogSockName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
926 		} else if(!strcmp(modpblk.descr[i].name, "syssock.ignoretimestamp")) {
927 			loadModConf-&gt;bIgnoreTimestamp = (int) pvals[i].val.d.n;
928 		} else if(!strcmp(modpblk.descr[i].name, "syssock.ignoreownmessages")) {
929 			loadModConf-&gt;bDiscardOwnMsgs = (int) pvals[i].val.d.n;
930 		} else if(!strcmp(modpblk.descr[i].name, "syssock.unlink")) {
931 			loadModConf-&gt;bUnlink = (int) pvals[i].val.d.n;
932 		} else if(!strcmp(modpblk.descr[i].name, "syssock.flowcontrol")) {
933 			loadModConf-&gt;bUseFlowCtl = (int) pvals[i].val.d.n;
934 		} else if(!strcmp(modpblk.descr[i].name, "syssock.usesystimestamp")) {
935 			loadModConf-&gt;bUseSysTimeStamp = (int) pvals[i].val.d.n;
936 		} else if(!strcmp(modpblk.descr[i].name, "syssock.annotate")) {
937 			loadModConf-&gt;bAnnotateSysSock = (int) pvals[i].val.d.n;
938 		} else if(!strcmp(modpblk.descr[i].name, "syssock.parsetrusted")) {
939 			loadModConf-&gt;bParseTrusted = (int) pvals[i].val.d.n;
940 		} else if(!strcmp(modpblk.descr[i].name, "syssock.parsehostname")) {
941 			loadModConf-&gt;bParseHost = (int) pvals[i].val.d.n;
942 		} else if(!strcmp(modpblk.descr[i].name, "syssock.usespecialparser")) {
943 			loadModConf-&gt;bUseSpecialParser = (int) pvals[i].val.d.n;
944 		} else if(!strcmp(modpblk.descr[i].name, "syssock.usepidfromsystem")) {
945 			loadModConf-&gt;bWritePidSysSock = (int) pvals[i].val.d.n;
946 		} else if(!strcmp(modpblk.descr[i].name, "syssock.ratelimit.interval")) {
947 			loadModConf-&gt;ratelimitIntervalSysSock = (unsigned int) pvals[i].val.d.n;
948 		} else if(!strcmp(modpblk.descr[i].name, "syssock.ratelimit.burst")) {
949 			loadModConf-&gt;ratelimitBurstSysSock = (unsigned int) pvals[i].val.d.n;
950 		} else if(!strcmp(modpblk.descr[i].name, "syssock.ratelimit.severity")) {
951 			loadModConf-&gt;ratelimitSeveritySysSock = (int) pvals[i].val.d.n;
952 		} else {
953 			dbgprintf("imuxsock: program error, non-handled "
954 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
955 		}
956 	}
957 	bLegacyCnfModGlobalsPermitted = 0;
958 	loadModConf-&gt;configSetViaV2Method = 1;
959 finalize_it:
960 	if(pvals != NULL)
961 		cnfparamvalsDestruct(pvals, &amp;modpblk);
962 ENDsetModCnf
963 BEGINnewInpInst
964 	struct cnfparamvals *pvals;
965 	instanceConf_t *inst;
966 	int i;
967 CODESTARTnewInpInst
968 <a name="2"></a>	DBGPRINTF("newInpInst (imuxsock)\n");
969 	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
970 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
971 		LogError(0, RS_RET_MISSING_CNFPARAMS,
972 			        "imuxsock: required parameter are missing\n");
973 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
974 	}
975 	if(Debug) {
976 		dbgprintf("input param blk in imuxsock:\n");
977 		cnfparamsPrint(&amp;inppblk, pvals);
978 	}
979 	CHKiRet(createInstance(&amp;inst));
980 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
981 		if(!pvals[i].bUsed)
982 			continue;
983 		if(!strcmp(inppblk.descr[i].name, "socket")) {
984 			inst-&gt;sockName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
985 		} else if(!strcmp(inppblk.descr[i].name, "createpath")) {
986 			inst-&gt;bCreatePath = (int) pvals[i].val.d.n;
987 		} else if(!strcmp(inppblk.descr[i].name, "parsetrusted")) {
988 			inst-&gt;bParseTrusted = (int) pvals[i].val.d.n;
989 		} else if(!strcmp(inppblk.descr[i].name, "ignoreownmessages")) {
990 			inst-&gt;bDiscardOwnMsgs = (int) pvals[i].val.d.n;
991 		} else if(!strcmp(inppblk.descr[i].name, "unlink")) {
992 			inst-&gt;bUnlink = (int) pvals[i].val.d.n;
993 		} else if(!strcmp(inppblk.descr[i].name, "hostname")) {
994 			inst-&gt;pLogHostName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
995 		} else if(!strcmp(inppblk.descr[i].name, "ignoretimestamp")) {
996 			inst-&gt;bIgnoreTimestamp = (int) pvals[i].val.d.n;
997 		} else if(!strcmp(inppblk.descr[i].name, "flowcontrol")) {
998 			inst-&gt;bUseFlowCtl = (int) pvals[i].val.d.n;
999 		} else if(!strcmp(inppblk.descr[i].name, "usesystimestamp")) {
1000 			inst-&gt;bUseSysTimeStamp = (int) pvals[i].val.d.n;
1001 		} else if(!strcmp(inppblk.descr[i].name, "annotate")) {
1002 			inst-&gt;bAnnotate = (int) pvals[i].val.d.n;
1003 		} else if(!strcmp(inppblk.descr[i].name, "usepidfromsystem")) {
1004 			inst-&gt;bWritePid = (int) pvals[i].val.d.n;
1005 		} else if(!strcmp(inppblk.descr[i].name, "parsehostname")) {
1006 			inst-&gt;bParseHost  = (int) pvals[i].val.d.n;
1007 		} else if(!strcmp(inppblk.descr[i].name, "usespecialparser")) {
1008 			inst-&gt;bUseSpecialParser  = (int) pvals[i].val.d.n;
1009 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
1010 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1011 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.interval")) {
1012 			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
1013 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.burst")) {
1014 			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
1015 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.severity")) {
1016 			inst-&gt;ratelimitSeverity = (int) pvals[i].val.d.n;
1017 		} else {
1018 			dbgprintf("imuxsock: program error, non-handled "
1019 			  "param '%s'\n", inppblk.descr[i].name);
1020 		}
1021 	}
1022 finalize_it:
1023 CODE_STD_FINALIZERnewInpInst
1024 	cnfparamvalsDestruct(pvals, &amp;inppblk);
1025 ENDnewInpInst
1026 BEGINendCnfLoad
1027 CODESTARTendCnfLoad
1028 	if(!loadModConf-&gt;configSetViaV2Method) {
1029 		loadModConf-&gt;bOmitLocalLogging = cs.bOmitLocalLogging;
1030 		loadModConf-&gt;pLogSockName = cs.pLogSockName;
1031 		loadModConf-&gt;bIgnoreTimestamp = cs.bIgnoreTimestampSysSock;
1032 		loadModConf-&gt;bUseSysTimeStamp = cs.bUseSysTimeStampSysSock;
1033 		loadModConf-&gt;bUseFlowCtl = cs.bUseFlowCtlSysSock;
1034 		loadModConf-&gt;bAnnotateSysSock = cs.bAnnotateSysSock;
1035 		loadModConf-&gt;bWritePidSysSock = cs.bWritePidSysSock;
1036 		loadModConf-&gt;bParseTrusted = cs.bParseTrusted;
1037 		loadModConf-&gt;ratelimitIntervalSysSock = cs.ratelimitIntervalSysSock;
1038 		loadModConf-&gt;ratelimitBurstSysSock = cs.ratelimitBurstSysSock;
1039 		loadModConf-&gt;ratelimitSeveritySysSock = cs.ratelimitSeveritySysSock;
1040 	}
1041 	loadModConf = NULL; 	free(cs.pLogHostName);
1042 	cs.pLogSockName = NULL;
1043 	cs.pLogHostName = NULL;
1044 ENDendCnfLoad
1045 static void
1046 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
1047 {
1048 	LogError(0, NO_ERRCODE, "imuxsock: ruleset '%s' for socket %s not found - "
1049 			"using default ruleset instead", inst-&gt;pszBindRuleset,
1050 			inst-&gt;sockName);
1051 }
1052 BEGINcheckCnf
1053 	instanceConf_t *inst;
1054 CODESTARTcheckCnf
1055 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1056 		std_checkRuleset(pModConf, inst);
1057 	}
1058 ENDcheckCnf
1059 BEGINactivateCnfPrePrivDrop
1060 	instanceConf_t *inst;
1061 	int nLstn;
1062 	int i;
1063 CODESTARTactivateCnfPrePrivDrop
1064 	runModConf = pModConf;
1065 #	ifdef OS_SOLARIS
1066 		startIndexUxLocalSockets = 1;
1067 #	else
1068 		startIndexUxLocalSockets = runModConf-&gt;bOmitLocalLogging ? 1 : 0;
1069 #	endif
1070 	nLstn = 0;
1071 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1072 		++nLstn;
1073 	}
1074 	if(nLstn &gt; 0 || startIndexUxLocalSockets == 0) {
1075 		DBGPRINTF("imuxsock: allocating memory for %d listeners\n", nLstn);
1076 		lstn_t *const listeners_new = realloc(listeners, (1+nLstn)*sizeof(lstn_t));
1077 		CHKmalloc(listeners_new);
1078 		listeners = listeners_new;
1079 		for(i = 1 ; i &lt; nLstn ; ++i) {
1080 			listeners[i].sockName = NULL;
1081 			listeners[i].fd  = -1;
1082 		}
1083 		for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1084 			addListner(inst);
1085 		}
1086 		CHKiRet(activateListeners());
1087 	}
1088 finalize_it:
1089 ENDactivateCnfPrePrivDrop
1090 BEGINactivateCnf
1091 CODESTARTactivateCnf
1092 ENDactivateCnf
1093 BEGINfreeCnf
1094 	instanceConf_t *inst, *del;
1095 CODESTARTfreeCnf
1096 	free(pModConf-&gt;pLogSockName);
1097 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
1098 		free(inst-&gt;sockName);
1099 		free(inst-&gt;pszBindRuleset);
1100 		free(inst-&gt;pLogHostName);
1101 		del = inst;
1102 		inst = inst-&gt;next;
1103 		free(del);
1104 	}
1105 ENDfreeCnf
1106 BEGINrunInput
1107 	int nfds;
1108 	int i;
1109 CODESTARTrunInput
1110 	struct pollfd *const pollfds = calloc(nfd, sizeof(struct pollfd));
1111 	CHKmalloc(pollfds);
1112 	if(startIndexUxLocalSockets == 1 &amp;&amp; nfd == 1) {
1113 		ABORT_FINALIZE(RS_RET_OK);
1114 	}
1115 	if(startIndexUxLocalSockets == 1) {
1116 		pollfds[0].fd = -1;
1117 	}
1118 	for (i = startIndexUxLocalSockets; i &lt; nfd; i++) {
1119 		pollfds[i].fd = listeners[i].fd;
1120 		pollfds[i].events = POLLIN;
1121 	}
1122 	while(1) {
1123 		DBGPRINTF("--------imuxsock calling poll() on %d fds\n", nfd);
1124 		nfds = poll(pollfds, nfd, -1);
1125 		if(glbl.GetGlobalInputTermState() == 1)
1126 			break; 
1127 		if(nfds &lt; 0) {
1128 			if(errno == EINTR) {
1129 				DBGPRINTF("imuxsock: EINTR occurred\n");
1130 			} else {
1131 				LogMsg(errno, RS_RET_POLL_ERR, LOG_WARNING, "imuxsock: poll "
1132 					"system call failed, may cause further troubles");
1133 			}
1134 			nfds = 0;
1135 		}
1136 		for (i = startIndexUxLocalSockets ; i &lt; nfd &amp;&amp; nfds &gt; 0; i++) {
1137 			if(glbl.GetGlobalInputTermState() == 1)
1138 				ABORT_FINALIZE(RS_RET_FORCE_TERM); 			if(pollfds[i].revents &amp; POLLIN) {
1139 				readSocket(&amp;(listeners[i]));
1140 				--nfds; 			}
1141 		}
1142 	}
1143 finalize_it:
1144 	free(pollfds);
1145 ENDrunInput
1146 BEGINwillRun
1147 CODESTARTwillRun
1148 ENDwillRun
1149 BEGINafterRun
1150 	int i;
1151 CODESTARTafterRun
1152 	if(startIndexUxLocalSockets == 1 &amp;&amp; nfd == 1) {
1153 		return RS_RET_OK;
1154 	}
1155 	for (i = 0; i &lt; nfd; i++)
1156 		if (listeners[i].fd != -1)
1157 			close(listeners[i].fd);
1158 	for(i = startIndexUxLocalSockets; i &lt; nfd; i++)
1159 		if (listeners[i].sockName &amp;&amp; listeners[i].fd != -1) {
1160 			if (sd_fds &gt; 0
1161 #			ifdef HAVE_LIBSYSTEMD
1162 			    &amp;&amp; listeners[i].fd &gt;= SD_LISTEN_FDS_START &amp;&amp;
1163 			       listeners[i].fd &lt;  SD_LISTEN_FDS_START + sd_fds
1164 #			endif
1165 			   )
1166 				continue;
1167 			if(listeners[i].bUnlink) {
1168 				DBGPRINTF("imuxsock: unlinking unix socket file[%d] %s\n", i, listeners[i].sockName);
1169 				unlink((char*) listeners[i].sockName);
1170 			}
1171 		}
1172 	discardLogSockets();
1173 	nfd = 1;
1174 ENDafterRun
1175 BEGINmodExit
1176 CODESTARTmodExit
1177 	free(listeners);
1178 	if(pInputName != NULL)
1179 		prop.Destruct(&amp;pInputName);
1180 	statsobj.Destruct(&amp;modStats);
1181 	objRelease(parser, CORE_COMPONENT);
1182 	objRelease(glbl, CORE_COMPONENT);
1183 	objRelease(prop, CORE_COMPONENT);
1184 	objRelease(statsobj, CORE_COMPONENT);
1185 	objRelease(datetime, CORE_COMPONENT);
1186 	objRelease(ruleset, CORE_COMPONENT);
1187 ENDmodExit
1188 BEGINisCompatibleWithFeature
1189 CODESTARTisCompatibleWithFeature
1190 	if(eFeat == sFEATURENonCancelInputTermination)
1191 		iRet = RS_RET_OK;
1192 ENDisCompatibleWithFeature
1193 BEGINqueryEtryPt
1194 CODESTARTqueryEtryPt
1195 CODEqueryEtryPt_STD_IMOD_QUERIES
1196 CODEqueryEtryPt_STD_CONF2_QUERIES
1197 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
1198 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
1199 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
1200 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
1201 ENDqueryEtryPt
1202 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
1203 {
1204 	free(cs.pLogSockName);
1205 	cs.pLogSockName = NULL;
1206 	free(cs.pLogHostName);
1207 	cs.bOmitLocalLogging = 0;
1208 	cs.pLogHostName = NULL;
1209 	cs.bIgnoreTimestamp = 1;
1210 	cs.bIgnoreTimestampSysSock = 1;
1211 	cs.bUseFlowCtl = 0;
1212 	cs.bUseFlowCtlSysSock = 0;
1213 	cs.bUseSysTimeStamp = 1;
1214 	cs.bUseSysTimeStampSysSock = 1;
1215 	cs.bWritePid = 0;
1216 	cs.bWritePidSysSock = 0;
1217 	cs.bAnnotate = 0;
1218 	cs.bAnnotateSysSock = 0;
1219 	cs.bParseTrusted = 0;
1220 	cs.bCreatePath = DFLT_bCreatePath;
1221 	cs.ratelimitInterval = DFLT_ratelimitInterval;
1222 	cs.ratelimitIntervalSysSock = DFLT_ratelimitInterval;
1223 	cs.ratelimitBurst = DFLT_ratelimitBurst;
1224 	cs.ratelimitBurstSysSock = DFLT_ratelimitBurst;
1225 	cs.ratelimitSeverity = DFLT_ratelimitSeverity;
1226 	cs.ratelimitSeveritySysSock = DFLT_ratelimitSeverity;
1227 	return RS_RET_OK;
1228 }
1229 BEGINmodInit()
1230 CODESTARTmodInit
1231 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1232 	CHKiRet(objUse(glbl, CORE_COMPONENT));
1233 	CHKiRet(objUse(net, CORE_COMPONENT));
1234 	CHKiRet(objUse(prop, CORE_COMPONENT));
1235 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1236 	CHKiRet(objUse(datetime, CORE_COMPONENT));
1237 	CHKiRet(objUse(parser, CORE_COMPONENT));
1238 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
1239 	DBGPRINTF("imuxsock version %s initializing\n", PACKAGE_VERSION);
1240 	cs.pLogSockName = NULL;
1241 	cs.pLogHostName = NULL;	
1242 	CHKiRet(prop.Construct(&amp;pInputName));
1243 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imuxsock"), sizeof("imuxsock") - 1));
1244 	CHKiRet(prop.ConstructFinalize(pInputName));
1245 	pLocalHostIP = glbl.GetLocalHostIP();
1246 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketignoremsgtimestamp", 0, eCmdHdlrBinary,
1247 		NULL, &amp;cs.bIgnoreTimestamp, STD_LOADABLE_MODULE_ID));
1248 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensockethostname", 0, eCmdHdlrGetWord,
1249 		NULL, &amp;cs.pLogHostName, STD_LOADABLE_MODULE_ID));
1250 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketflowcontrol", 0, eCmdHdlrBinary,
1251 		NULL, &amp;cs.bUseFlowCtl, STD_LOADABLE_MODULE_ID));
1252 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketannotate", 0, eCmdHdlrBinary,
1253 		NULL, &amp;cs.bAnnotate, STD_LOADABLE_MODULE_ID));
1254 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketcreatepath", 0, eCmdHdlrBinary,
1255 		NULL, &amp;cs.bCreatePath, STD_LOADABLE_MODULE_ID));
1256 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketusesystimestamp", 0, eCmdHdlrBinary,
1257 		NULL, &amp;cs.bUseSysTimeStamp, STD_LOADABLE_MODULE_ID));
1258 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"addunixlistensocket", 0, eCmdHdlrGetWord,
1259 		addInstance, NULL, STD_LOADABLE_MODULE_ID));
1260 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketusepidfromsystem", 0, eCmdHdlrBinary,
1261 		NULL, &amp;cs.bWritePid, STD_LOADABLE_MODULE_ID));
1262 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imuxsockratelimitinterval", 0, eCmdHdlrInt,
1263 		NULL, &amp;cs.ratelimitInterval, STD_LOADABLE_MODULE_ID));
1264 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imuxsockratelimitburst", 0, eCmdHdlrInt,
1265 		NULL, &amp;cs.ratelimitBurst, STD_LOADABLE_MODULE_ID));
1266 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imuxsockratelimitseverity", 0, eCmdHdlrInt,
1267 		NULL, &amp;cs.ratelimitSeverity, STD_LOADABLE_MODULE_ID));
1268 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
1269 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
1270 	CHKiRet(regCfSysLineHdlr2((uchar *)"omitlocallogging", 0, eCmdHdlrBinary,
1271 		NULL, &amp;cs.bOmitLocalLogging, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1272 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketname", 0, eCmdHdlrGetWord,
1273 		NULL, &amp;cs.pLogSockName, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1274 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketignoremsgtimestamp", 0, eCmdHdlrBinary,
1275 		NULL, &amp;cs.bIgnoreTimestampSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1276 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketflowcontrol", 0, eCmdHdlrBinary,
1277 		NULL, &amp;cs.bUseFlowCtlSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1278 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogusesystimestamp", 0, eCmdHdlrBinary,
1279 		NULL, &amp;cs.bUseSysTimeStampSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1280 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketannotate", 0, eCmdHdlrBinary,
1281 		NULL, &amp;cs.bAnnotateSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1282 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogparsetrusted", 0, eCmdHdlrBinary,
1283 		NULL, &amp;cs.bParseTrusted, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1284 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogusepidfromsystem", 0, eCmdHdlrBinary,
1285 		NULL, &amp;cs.bWritePidSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1286 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogratelimitinterval", 0, eCmdHdlrInt,
1287 		NULL, &amp;cs.ratelimitIntervalSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1288 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogratelimitburst", 0, eCmdHdlrInt,
1289 		NULL, &amp;cs.ratelimitBurstSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1290 	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogratelimitseverity", 0, eCmdHdlrInt,
1291 		NULL, &amp;cs.ratelimitSeveritySysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1292 	CHKiRet(statsobj.Construct(&amp;modStats));
1293 	CHKiRet(statsobj.SetName(modStats, UCHAR_CONSTANT("imuxsock")));
1294 	CHKiRet(statsobj.SetOrigin(modStats, UCHAR_CONSTANT("imuxsock")));
1295 	STATSCOUNTER_INIT(ctrSubmit, mutCtrSubmit);
1296 	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("submitted"),
1297 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrSubmit));
1298 	STATSCOUNTER_INIT(ctrLostRatelimit, mutCtrLostRatelimit);
1299 	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("ratelimit.discarded"),
1300 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrLostRatelimit));
1301 	STATSCOUNTER_INIT(ctrNumRatelimiters, mutCtrNumRatelimiters);
1302 	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("ratelimit.numratelimiters"),
1303 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrNumRatelimiters));
1304 	CHKiRet(statsobj.ConstructFinalize(modStats));
1305 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
