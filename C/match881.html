<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imkafka.c &amp; imuxsock.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imkafka.c &amp; imuxsock.c
      </h3>
<h1 align="center">
        10.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imkafka.c (16.962843%)<th>imuxsock.c (7.3477955%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(135-150)<td><a href="#" name="0">(275-290)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(607-631)<td><a href="#" name="1">(1262-1286)</a><td align="center"><font color="#d90000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(536-551)<td><a href="#" name="2">(1339-1356)</a><td align="center"><font color="#8d0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(305-319)<td><a href="#" name="3">(344-362)</a><td align="center"><font color="#840000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(576-582)<td><a href="#" name="4">(407-413)</a><td align="center"><font color="#7a0000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(279-290)<td><a href="#" name="5">(317-327)</a><td align="center"><font color="#7a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imkafka.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;librdkafka/rdkafka.h&gt;
#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "atomic.h"
#include "statsobj.h"
#include "unicode-helper.h"
#include "prop.h"
#include "ruleset.h"
#include "glbl.h"
#include "cfsysline.h"
#include "msg.h"
#include "dirty.h"
MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imkafka")
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)
static void * imkafkawrkr(void *myself);
struct kafka_params {
	const char *name;
	const char *val;
};
static struct configSettings_s {
	uchar *topic;
	uchar *consumergroup;
	char *brokers;
	uchar *pszBindRuleset;
	int nConfParams;
	struct kafka_params *confParams;
} cs;
struct instanceConf_s {
	uchar *topic;
	uchar *consumergroup;
	char *brokers;
	int64_t offset;
	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;			int bReportErrs;
	int nConfParams;
	struct kafka_params *confParams;
	int bIsConnected;
	rd_kafka_conf_t *conf;
	rd_kafka_t *rk;
	rd_kafka_topic_conf_t *topic_conf;
	int partition;
	int bIsSubscribed;
	int nMsgParsingFlags;
	struct instanceConf_s *next;
};
struct modConfData_s {
	rsconf_t *pConf;			uchar *topic;
	uchar *consumergroup;
	char *brokers;
	instanceConf_t *root, *tail;
	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;		};
pthread_attr_t wrkrThrdAttr;	static int activeKafkaworkers = 0;
static struct kafkaWrkrInfo_s {
	pthread_t tid;			instanceConf_t *inst;	} *kafkaWrkrInfo;
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
static prop_t *pInputName = NULL;
<a name="0"></a>
static struct cnfparamdescr modpdescr[] = {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "ruleset", eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
static struct cnfparamdescr inppdescr[] = {
	{ "topic", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "broker", eCmdHdlrArray, 0 },
	{ "confparam", eCmdHdlrArray, 0 },
	{ "consumergroup", eCmdHdlrString, 0},
	{ "ruleset", eCmdHdlrString, 0 },
	{ "parsehostname", eCmdHdlrBinary, 0 },</b></font>
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};
#include "im-helper.h" 
static void
kafkaLogger(const rd_kafka_t __attribute__((unused)) *rk, int level,
	    const char *fac, const char *buf)
{
	DBGPRINTF("imkafka: kafka log message [%d,%s]: %s\n",
		  level, fac, buf);
}
static rsRetVal enqMsg(instanceConf_t *const __restrict__ inst,
			rd_kafka_message_t *const __restrict__ rkmessage)
{
	DEFiRet;
	smsg_t *pMsg;
	if((int)rkmessage-&gt;len == 0) {
		FINALIZE;
	}
DBGPRINTF("imkafka: enqMsg: Msg: %.*s\n", (int)rkmessage-&gt;len, (char *)rkmessage-&gt;payload);
	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, (char*)rkmessage-&gt;payload, (int)rkmessage-&gt;len);
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	pMsg-&gt;msgFlags  = inst-&gt;nMsgParsingFlags;
	if (rkmessage-&gt;key_len) {
		DBGPRINTF("imkafka: enqMsg: Key: %.*s\n", (int)rkmessage-&gt;key_len, (char *)rkmessage-&gt;key);
		MsgSetTAG(pMsg, (const uchar *)rkmessage-&gt;key, (int)rkmessage-&gt;key_len);
	}
	MsgSetMSGoffs(pMsg, 0);	
	CHKiRet(submitMsg2(pMsg));
finalize_it:
	RETiRet;
}
static void msgConsume (instanceConf_t *inst) {
	rd_kafka_message_t *rkmessage = NULL;
	do { 		rkmessage = rd_kafka_consumer_poll(inst-&gt;rk, 1000); 		if(rkmessage == NULL) {
			DBGPRINTF("imkafka: msgConsume EMPTY Loop on %s/%s/%s\n",
				inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
			goto done;
		}
		if (rkmessage-&gt;err) {
			if (rkmessage-&gt;err == RD_KAFKA_RESP_ERR__PARTITION_EOF) {
				DBGPRINTF("imkafka: Consumer "
					"reached end of topic \"%s\" [%"PRId32"]"
					"message queue offset %"PRId64"\n",
					rd_kafka_topic_name(rkmessage-&gt;rkt),
					rkmessage-&gt;partition,
					rkmessage-&gt;offset);
				goto done;
			}
			if (rkmessage-&gt;rkt) {
				LogError(0, RS_RET_KAFKA_ERROR,
				"imkafka: Consumer error for topic \"%s\" [%"PRId32"]"
				"message queue offset %"PRId64": %s\n",
					rd_kafka_topic_name(rkmessage-&gt;rkt),
					rkmessage-&gt;partition,
					rkmessage-&gt;offset,
					rd_kafka_message_errstr(rkmessage));
			} else {
				LogError(0, RS_RET_KAFKA_ERROR,
					"imkafka: Consumer error for topic \"%s\": \"%s\"\n",
					rd_kafka_err2str(rkmessage-&gt;err),
					rd_kafka_message_errstr(rkmessage));
			}
			goto done;
		}
		DBGPRINTF("imkafka: msgConsume Loop on %s/%s/%s: [%"PRId32"], "
					"offset %"PRId64", %zd bytes):\n",
					inst-&gt;consumergroup,
					inst-&gt;brokers,
					rkmessage-&gt;partition,
					rkmessage-&gt;offset,
					rkmessage-&gt;len);
		enqMsg(inst, rkmessage);
		rd_kafka_message_destroy(rkmessage);
		rkmessage = NULL;
	} while(1); done:
	if(rkmessage != NULL) {
		rd_kafka_message_destroy(rkmessage);
	}
	return;
}
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;
	inst-&gt;brokers = NULL;
	inst-&gt;topic = NULL;
	inst-&gt;consumergroup = NULL;
	inst-&gt;pszBindRuleset = NULL;</b></font>
	inst-&gt;nConfParams = 0;
	inst-&gt;confParams = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;bReportErrs = 1; 	inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
	inst-&gt;bIsConnected = 0;
	inst-&gt;bIsSubscribed = 0;
	inst-&gt;conf = NULL;
	inst-&gt;rk = NULL;
	inst-&gt;topic_conf = NULL;
<a name="3"></a>	inst-&gt;partition = RD_KAFKA_PARTITION_UA;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}
	*pinst = inst;
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()</b></font>
checkInstance(instanceConf_t *const inst)
{
	DEFiRet;
	char kafkaErrMsg[1024];
	inst-&gt;conf = rd_kafka_conf_new();
	if(inst-&gt;conf == NULL) {
		if(inst-&gt;bReportErrs) {
			LogError(0, RS_RET_KAFKA_ERROR,
				"imkafka: error creating kafka conf obj: %s\n",
				rd_kafka_err2str(rd_kafka_last_error()));
		}
		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
	}
#	ifdef DEBUG
	if(rd_kafka_conf_set(inst-&gt;conf, "debug", RD_KAFKA_DEBUG_CONTEXTS,
		kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
		LogError(0, RS_RET_KAFKA_ERROR, "imkafka: error setting kafka debug option: %s\n", kafkaErrMsg);
	}
#	endif
	for(int i = 0 ; i &lt; inst-&gt;nConfParams ; ++i) {
		assert(inst-&gt;confParams+i != NULL); 		DBGPRINTF("imkafka: setting custom configuration parameter: %s:%s\n",
			inst-&gt;confParams[i].name,
			inst-&gt;confParams[i].val);
		if(rd_kafka_conf_set(inst-&gt;conf,
			inst-&gt;confParams[i].name,
			inst-&gt;confParams[i].val,
			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_PARAM_ERROR, "error setting custom configuration "
					"parameter '%s=%s': %s",
					inst-&gt;confParams[i].name,
					inst-&gt;confParams[i].val, kafkaErrMsg);
			} else {
				DBGPRINTF("imkafka: error setting custom configuration parameter '%s=%s': %s",
					inst-&gt;confParams[i].name,
					inst-&gt;confParams[i].val, kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_PARAM_ERROR);
		}
	}
	inst-&gt;topic_conf = rd_kafka_topic_conf_new();
	if (inst-&gt;consumergroup != NULL) {
		DBGPRINTF("imkafka: setting consumergroup: '%s'\n", inst-&gt;consumergroup);
		if (rd_kafka_conf_set(inst-&gt;conf, "group.id", (char*) inst-&gt;consumergroup,
			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_KAFKA_ERROR,
					"imkafka: error assigning consumergroup %s to "
					"kafka config: %s\n", inst-&gt;consumergroup,
					kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
		}
		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, "auto.offset.reset",
			"smallest", kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_KAFKA_ERROR,
					"imkafka: error setting kafka auto.offset.reset on %s: %s\n",
					inst-&gt;consumergroup,
					kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
		}
		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, "offset.store.method",
			"broker", kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_KAFKA_ERROR,
					"imkafka: error setting kafka offset.store.method on %s: %s\n",
					inst-&gt;consumergroup,
					kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
		}
		rd_kafka_conf_set_default_topic_conf(inst-&gt;conf, inst-&gt;topic_conf);
	}
	#if RD_KAFKA_VERSION &gt;= 0x00090001
		rd_kafka_conf_set_log_cb(inst-&gt;conf, kafkaLogger);
	#endif
	inst-&gt;rk = rd_kafka_new(RD_KAFKA_CONSUMER, inst-&gt;conf,
				     kafkaErrMsg, sizeof(kafkaErrMsg));
	if(inst-&gt;rk == NULL) {
		if(inst-&gt;bReportErrs) {
			LogError(0, RS_RET_KAFKA_ERROR,
				"imkafka: error creating kafka handle: %s\n", kafkaErrMsg);
		}
		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
	}
	#if RD_KAFKA_VERSION &lt; 0x00090001
		rd_kafka_set_logger(inst-&gt;rk, kafkaLogger);
	#endif
	DBGPRINTF("imkafka: setting brokers: '%s'\n", inst-&gt;brokers);
	if(rd_kafka_brokers_add(inst-&gt;rk, (char*)inst-&gt;brokers) == 0) {
		if(inst-&gt;bReportErrs) {
			LogError(0, RS_RET_KAFKA_NO_VALID_BROKERS,
				"imkafka: no valid brokers specified: %s", inst-&gt;brokers);
		}
		ABORT_FINALIZE(RS_RET_KAFKA_NO_VALID_BROKERS);
	}
	inst-&gt;bIsConnected = 1;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(inst-&gt;rk == NULL) {
			if(inst-&gt;conf != NULL) {
				rd_kafka_conf_destroy(inst-&gt;conf);
				inst-&gt;conf = NULL;
			}
		} else { 			rd_kafka_destroy(inst-&gt;rk);
			inst-&gt;rk = NULL;
		}
	}
	RETiRet;
}
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	if(inst-&gt;bReportErrs) {
		LogError(0, NO_ERRCODE, "imkafka: ruleset '%s' not found - "
			"using default ruleset instead",
			inst-&gt;pszBindRuleset);
	}
}
static rsRetVal ATTR_NONNULL(2)
addConsumer(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
{
	DEFiRet;
	rd_kafka_resp_err_t err;
	assert(inst != NULL);
	rd_kafka_topic_partition_list_t *topics = NULL;
	DBGPRINTF("imkafka: creating kafka consumer on %s/%s/%s\n",
		inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
	rd_kafka_poll_set_consumer(inst-&gt;rk);
	topics = rd_kafka_topic_partition_list_new(1);
	rd_kafka_topic_partition_list_add(topics, (const char*)inst-&gt;topic, inst-&gt;partition);
	DBGPRINTF("imkafka: Created topics(%d) for %s)\n",
		topics-&gt;cnt, inst-&gt;topic);
	if ((err = rd_kafka_subscribe(inst-&gt;rk, topics))) {
		inst-&gt;bIsSubscribed = 0;
		LogError(0, RS_RET_KAFKA_ERROR, "imkafka: Failed to start consuming "
			"topics: %s\n", rd_kafka_err2str(err));
		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
	} else {
		DBGPRINTF("imkafka: Successfully subscribed to %s/%s/%s\n",
			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
		inst-&gt;bIsSubscribed = 1;
	}
finalize_it:
	if(topics != NULL)
		rd_kafka_topic_partition_list_destroy(topics);
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
processKafkaParam(char *const param,
	const char **const name,
	const char **const paramval)
{
	DEFiRet;
	char *val = strstr(param, "=");
	if(val == NULL) {
		LogError(0, RS_RET_PARAM_ERROR, "missing equal sign in "
				"parameter '%s'", param);
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	*val = '\0'; 	++val; 	CHKmalloc(*name = strdup(param));
	CHKmalloc(*paramval = strdup(val));
finalize_it:
	RETiRet;
}
BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
<a name="2"></a>CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imkafka)\n");
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("input param blk in imkafka:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}
	CHKiRet(createInstance(&amp;inst));
	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "broker")) {
			es_str_t *es = es_newStr(128);</b></font>
			int bNeedComma = 0;
			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				if(bNeedComma)
					es_addChar(&amp;es, ',');
				es_addStr(&amp;es, pvals[i].val.d.ar-&gt;arr[j]);
				bNeedComma = 1;
			}
			inst-&gt;brokers = es_str2cstr(es, NULL);
			es_deleteStr(es);
		} else if(!strcmp(inppblk.descr[i].name, "confparam")) {
			inst-&gt;nConfParams = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(inst-&gt;confParams = malloc(sizeof(struct kafka_params)*inst-&gt;nConfParams));
			for(int j = 0; j &lt; inst-&gt;nConfParams; j++) {
				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				CHKiRet(processKafkaParam(cstr, &amp;inst-&gt;confParams[j].name,
								&amp;inst-&gt;confParams[j].val));
				free(cstr);
			}
		} else if(!strcmp(inppblk.descr[i].name, "topic")) {
			inst-&gt;topic = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "consumergroup")) {
<a name="4"></a>			inst-&gt;consumergroup = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "parsehostname")) {
			if (pvals[i].val.d.n) {
				inst-&gt;nMsgParsingFlags = NEEDS_PARSING | PARSE_HOSTNAME;
			} else {
				inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
			}
		} else {</b></font>
			dbgprintf("imkafka: program error, non-handled "
			  "param '%s'\n", inppblk.descr[i].name);
		}
	}
	if(inst-&gt;brokers == NULL) {
		CHKmalloc(inst-&gt;brokers = strdup("localhost:9092"));
		LogMsg(0, NO_ERRCODE, LOG_INFO, "imkafka: \"broker\" parameter not specified "
			"using default of localhost:9092 -- this may not be what you want!");
	}
	DBGPRINTF("imkafka: newInpIns brokers=%s, topic=%s, consumergroup=%s\n",
		inst-&gt;brokers, inst-&gt;topic, inst-&gt;consumergroup);
finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst
BEGINbeginCnfLoad
<a name="1"></a>CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pModConf-&gt;pszBindRuleset = NULL;
ENDbeginCnfLoad
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imkafka: error processing module "
			"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for imkafka:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "ruleset")) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else {
			dbgprintf("imkafka: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINendCnfLoad
CODESTARTendCnfLoad
	if(loadModConf-&gt;pszBindRuleset == NULL) {
		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
			loadModConf-&gt;pszBindRuleset = NULL;
		} else {
			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
		}
	}
finalize_it:
	free(cs.pszBindRuleset);
	cs.pszBindRuleset = NULL;
	loadModConf = NULL; ENDendCnfLoad
BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
		}
		std_checkRuleset(pModConf, inst);
	}
finalize_it:
ENDcheckCnf
BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
ENDactivateCnfPrePrivDrop
BEGINactivateCnf
CODESTARTactivateCnf
	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		iRet = checkInstance(inst);
	}
ENDactivateCnf
BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;topic);
		free(inst-&gt;consumergroup);
		free(inst-&gt;brokers);
		free(inst-&gt;pszBindRuleset);
		for(int i = 0; i &lt; inst-&gt;nConfParams; i++) {
			free((void*)inst-&gt;confParams[i].name);
			free((void*)inst-&gt;confParams[i].val);
		}
		free((void*)inst-&gt;confParams);
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
	free(pModConf-&gt;pszBindRuleset);
ENDfreeCnf
static void
shutdownKafkaWorkers(void)
{
	int i;
	instanceConf_t *inst;
	assert(kafkaWrkrInfo != NULL);
	DBGPRINTF("imkafka: waiting on imkafka workerthread termination\n");
	for(i = 0 ; i &lt; activeKafkaworkers ; ++i) {
		pthread_join(kafkaWrkrInfo[i].tid, NULL);
		DBGPRINTF("imkafka: Stopped worker %d\n", i);
	}
	free(kafkaWrkrInfo);
	kafkaWrkrInfo = NULL;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		DBGPRINTF("imkafka: stop consuming %s/%s/%s\n",
			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
		rd_kafka_consumer_close(inst-&gt;rk); 		rd_kafka_destroy(inst-&gt;rk); 		DBGPRINTF("imkafka: stopped consuming %s/%s/%s\n",
			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
		#if RD_KAFKA_VERSION &lt; 0x00090001
		if (rd_kafka_wait_destroyed(10000) &lt; 0)	{
			DBGPRINTF("imkafka: error, rd_kafka_destroy did not finish after grace "
				"timeout (10s)!\n");
		} else {
			DBGPRINTF("imkafka: rd_kafka_destroy successfully finished\n");
		}
		#endif
	}
}
BEGINrunInput
	int i;
	instanceConf_t *inst;
CODESTARTrunInput
	DBGPRINTF("imkafka: runInput loop started ...\n");
	activeKafkaworkers = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if(inst-&gt;rk != NULL) {
			++activeKafkaworkers;
		}
	}
	if(activeKafkaworkers == 0) {
		LogError(0, RS_RET_ERR, "imkafka: no active inputs, input does "
			"not run - there should have been additional error "
			"messages given previously");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	DBGPRINTF("imkafka: Starting %d imkafka workerthreads\n", activeKafkaworkers);
	kafkaWrkrInfo = calloc(activeKafkaworkers, sizeof(struct kafkaWrkrInfo_s));
	if (kafkaWrkrInfo == NULL) {
		LogError(errno, RS_RET_OUT_OF_MEMORY, "imkafka: worker-info array allocation failed.");
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	i = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		kafkaWrkrInfo[i].inst = inst; 		pthread_create(&amp;kafkaWrkrInfo[i].tid, &amp;wrkrThrdAttr, imkafkawrkr, &amp;(kafkaWrkrInfo[i]));
		i++;
	}
	while(glbl.GetGlobalInputTermState() == 0) {
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(0, 100000);
	}
	DBGPRINTF("imkafka: terminating upon request of rsyslog core\n");
	shutdownKafkaWorkers();
finalize_it:
ENDrunInput
BEGINwillRun
CODESTARTwillRun
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imkafka"), sizeof("imkafka") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun
BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
ENDafterRun
BEGINmodExit
CODESTARTmodExit
	pthread_attr_destroy(&amp;wrkrThrdAttr);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	pthread_attr_init(&amp;wrkrThrdAttr);
	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
	DBGPRINTF("imkafka %s using librdkafka version %s, 0x%x\n",
		VERSION, rd_kafka_version_str(), rd_kafka_version());
ENDmodInit
static void *
imkafkawrkr(void *myself)
{
	struct kafkaWrkrInfo_s *me = (struct kafkaWrkrInfo_s*) myself;
	DBGPRINTF("imkafka: started kafka consumer workerthread on %s/%s/%s\n",
		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
	do {
		if(glbl.GetGlobalInputTermState() == 1)
			break; 
		if(me-&gt;inst-&gt;rk == NULL) {
			continue;
		}
		if(me-&gt;inst-&gt;bIsConnected == 1 &amp;&amp; me-&gt;inst-&gt;bIsSubscribed == 0 ) {
			addConsumer(runModConf, me-&gt;inst);
		}
		if(me-&gt;inst-&gt;bIsSubscribed == 1 ) {
			msgConsume(me-&gt;inst);
		}
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(0, 100000);
	} while(glbl.GetGlobalInputTermState() == 0);
	DBGPRINTF("imkafka: stopped kafka consumer workerthread on %s/%s/%s\n",
		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
	return NULL;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imuxsock.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef __sun
#define _XPG4_2
#endif
#include "config.h"
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;poll.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;sys/socket.h&gt;
#ifdef HAVE_LIBSYSTEMD
#	include &lt;systemd/sd-daemon.h&gt;
#endif
#if defined(__FreeBSD__)
	#include &lt;sys/param.h&gt;
#endif
#include "rsyslog.h"
#include "dirty.h"
#include "cfsysline.h"
#include "unicode-helper.h"
#include "module-template.h"
#include "srUtils.h"
#include "errmsg.h"
#include "net.h"
#include "glbl.h"
#include "msg.h"
#include "parser.h"
#include "prop.h"
#include "debug.h"
#include "ruleset.h"
#include "unlimited_select.h"
#include "statsobj.h"
#include "datetime.h"
#include "hashtable.h"
#include "ratelimit.h"
MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imuxsock")
#ifndef _PATH_LOG
#ifdef BSD
#define _PATH_LOG	"/var/run/log"
#else
#define _PATH_LOG	"/dev/log"
#endif
#endif
#ifndef SYSTEMD_JOURNAL
#define SYSTEMD_JOURNAL  "/run/systemd/journal"
#endif
#ifndef SYSTEMD_PATH_LOG
#define SYSTEMD_PATH_LOG SYSTEMD_JOURNAL "/syslog"
#endif
#define UNSET -1 
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
#if defined(_AIX)
#define ucred  ucred_t
#endif
#ifndef HAVE_SCM_CREDENTIALS
struct ucred { int pid; uid_t uid; gid_t gid; };
#endif
#ifndef SUN_LEN
#define SUN_LEN(su) \
	(sizeof(*(su)) - sizeof((su)-&gt;sun_path) + strlen((su)-&gt;sun_path))
#endif
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(net)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(ruleset)
statsobj_t *modStats;
STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
STATSCOUNTER_DEF(ctrLostRatelimit, mutCtrLostRatelimit)
STATSCOUNTER_DEF(ctrNumRatelimiters, mutCtrNumRatelimiters)
static unsigned int
hash_from_key_fn(void *k)
{
	return((unsigned) *((pid_t*) k));
}
static int
key_equals_fn(void *key1, void *key2)
{
	return *((pid_t*) key1) == *((pid_t*) key2);
}
typedef struct lstn_s {
	uchar *sockName;		prop_t *hostName;		int fd;				int flags;			int flowCtl;			unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	intTiny ratelimitSev;		struct hashtable *ht;		sbool bParseHost;		sbool bCreatePath;		sbool bUseCreds;		sbool bAnnotate;		sbool bParseTrusted;		sbool bWritePid;		sbool bDiscardOwnMsgs;		sbool bUseSysTimeStamp;		sbool bUnlink;			sbool bUseSpecialParser;	ruleset_t *pRuleset;
} lstn_t;
static lstn_t *listeners;
static int sd_fds = 0;			
#if (defined(__FreeBSD__) &amp;&amp; (__FreeBSD_version &gt;= 1200061))
	#define DFLT_bUseSpecialParser 0
#else
	#define DFLT_bUseSpecialParser 1
#endif
#define DFLT_bCreatePath 0
#define DFLT_ratelimitInterval 0
#define DFLT_ratelimitBurst 200
#define DFLT_ratelimitSeverity 1			static struct configSettings_s {
	int bOmitLocalLogging;
	uchar *pLogSockName;
	uchar *pLogHostName;			int bUseFlowCtl;			int bUseFlowCtlSysSock;
	int bIgnoreTimestamp;			int bIgnoreTimestampSysSock;
	int bUseSysTimeStamp;			int bUseSysTimeStampSysSock;		int bWritePid;				int bWritePidSysSock;			int bCreatePath;			unsigned int ratelimitInterval;			unsigned int ratelimitIntervalSysSock;
	unsigned int ratelimitBurst;			unsigned int ratelimitBurstSysSock;
	int ratelimitSeverity;
	int ratelimitSeveritySysSock;
	int bAnnotate;				int bAnnotateSysSock;			int bParseTrusted;		} cs;
struct instanceConf_s {
	uchar *sockName;
	uchar *pLogHostName;			sbool bUseFlowCtl;			sbool bIgnoreTimestamp;			sbool bWritePid;			sbool bUseSysTimeStamp;			int bCreatePath;			unsigned int ratelimitInterval;			unsigned int ratelimitBurst;			int ratelimitSeverity;
	int bAnnotate;				int bParseTrusted;			sbool bDiscardOwnMsgs;			sbool bUnlink;
	sbool bUseSpecialParser;
	sbool bParseHost;
	uchar *pszBindRuleset;			ruleset_t *pBindRuleset;		struct instanceConf_s *next;
};
struct modConfData_s {
	rsconf_t *pConf;			instanceConf_t *root, *tail;
	uchar *pLogSockName;
	unsigned int ratelimitIntervalSysSock;
	unsigned int ratelimitBurstSysSock;
	int ratelimitSeveritySysSock;
	int bAnnotateSysSock;
	int bParseTrusted;
	int bUseSpecialParser;
	int bParseHost;
	sbool bIgnoreTimestamp;			sbool bUseFlowCtl;			sbool bOmitLocalLogging;
	sbool bWritePidSysSock;
	sbool bUseSysTimeStamp;
	sbool bDiscardOwnMsgs;
	sbool configSetViaV2Method;
	sbool bUnlink;
};
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
static struct cnfparamdescr modpdescr[] = {
	{ "syssock.use", eCmdHdlrBinary, 0 },
	{ "syssock.name", eCmdHdlrGetWord, 0 },
	{ "syssock.unlink", eCmdHdlrBinary, 0 },
	{ "syssock.ignoretimestamp", eCmdHdlrBinary, 0 },
	{ "syssock.ignoreownmessages", eCmdHdlrBinary, 0 },
	{ "syssock.flowcontrol", eCmdHdlrBinary, 0 },
	{ "syssock.usesystimestamp", eCmdHdlrBinary, 0 },
	{ "syssock.annotate", eCmdHdlrBinary, 0 },
	{ "syssock.parsetrusted", eCmdHdlrBinary, 0 },
	{ "syssock.usespecialparser", eCmdHdlrBinary, 0 },
	{ "syssock.parsehostname", eCmdHdlrBinary, 0 },
<a name="0"></a>	{ "syssock.usepidfromsystem", eCmdHdlrBinary, 0 },
	{ "syssock.ratelimit.interval", eCmdHdlrInt, 0 },
	{ "syssock.ratelimit.burst", eCmdHdlrInt, 0 },
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "syssock.ratelimit.severity", eCmdHdlrInt, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
static struct cnfparamdescr inppdescr[] = {
	{ "socket", eCmdHdlrString, CNFPARAM_REQUIRED }, 	{ "unlink", eCmdHdlrBinary, 0 },
	{ "createpath", eCmdHdlrBinary, 0 },
	{ "parsetrusted", eCmdHdlrBinary, 0 },
	{ "ignoreownmessages", eCmdHdlrBinary, 0 },
	{ "hostname", eCmdHdlrString, 0 },</b></font>
	{ "ignoretimestamp", eCmdHdlrBinary, 0 },
	{ "flowcontrol", eCmdHdlrBinary, 0 },
	{ "usesystimestamp", eCmdHdlrBinary, 0 },
	{ "annotate", eCmdHdlrBinary, 0 },
	{ "usespecialparser", eCmdHdlrBinary, 0 },
	{ "parsehostname", eCmdHdlrBinary, 0 },
	{ "usepidfromsystem", eCmdHdlrBinary, 0 },
	{ "ruleset", eCmdHdlrString, 0 },
	{ "ratelimit.interval", eCmdHdlrInt, 0 },
	{ "ratelimit.burst", eCmdHdlrInt, 0 },
	{ "ratelimit.severity", eCmdHdlrInt, 0 }
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};
#include "im-helper.h" 
static int bLegacyCnfModGlobalsPermitted;
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;sockName = NULL;
	inst-&gt;pLogHostName = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;ratelimitInterval = DFLT_ratelimitInterval;</b></font>
	inst-&gt;ratelimitBurst = DFLT_ratelimitBurst;
	inst-&gt;ratelimitSeverity = DFLT_ratelimitSeverity;
	inst-&gt;bUseFlowCtl = 0;
	inst-&gt;bUseSpecialParser = DFLT_bUseSpecialParser;
	inst-&gt;bParseHost = UNSET;
	inst-&gt;bIgnoreTimestamp = 1;
	inst-&gt;bCreatePath = DFLT_bCreatePath;
	inst-&gt;bUseSysTimeStamp = 1;
	inst-&gt;bWritePid = 0;
	inst-&gt;bAnnotate = 0;
	inst-&gt;bParseTrusted = 0;
	inst-&gt;bDiscardOwnMsgs = loadModConf-&gt;pConf-&gt;globals.bProcessInternalMessages;
	inst-&gt;bUnlink = 1;
<a name="3"></a>	inst-&gt;next = NULL;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}
	*pinst = inst;
finalize_it:
	RETiRet;
}
static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)</b></font>
{
	instanceConf_t *inst;
	DEFiRet;
	if(pNewVal == NULL || pNewVal[0] == '\0') {
		LogError(0, RS_RET_SOCKNAME_MISSING , "imuxsock: socket name must be specified, "
			        "but is not - listener not created\n");
		if(pNewVal != NULL)
			free(pNewVal);
		ABORT_FINALIZE(RS_RET_SOCKNAME_MISSING);
	}
	CHKiRet(createInstance(&amp;inst));
	inst-&gt;sockName = pNewVal;
	inst-&gt;ratelimitInterval = cs.ratelimitInterval;
	inst-&gt;pLogHostName = cs.pLogHostName;
	inst-&gt;ratelimitBurst = cs.ratelimitBurst;
	inst-&gt;ratelimitSeverity = cs.ratelimitSeverity;
	inst-&gt;bUseFlowCtl = cs.bUseFlowCtl;
	inst-&gt;bIgnoreTimestamp = cs.bIgnoreTimestamp;
	inst-&gt;bCreatePath = cs.bCreatePath;
	inst-&gt;bUseSysTimeStamp = cs.bUseSysTimeStamp;
	inst-&gt;bWritePid = cs.bWritePid;
	inst-&gt;bAnnotate = cs.bAnnotate;
	inst-&gt;bParseTrusted = cs.bParseTrusted;
	inst-&gt;bParseHost = UNSET;
	inst-&gt;next = NULL;
	cs.pLogHostName = NULL;
finalize_it:
	RETiRet;
}
static rsRetVal
addListner(instanceConf_t *inst)
<a name="4"></a>{
	DEFiRet;
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(inst-&gt;bParseHost == UNSET) {
		if(*inst-&gt;sockName == ':') {
			listeners[nfd].bParseHost = 1;
		} else {
			listeners[nfd].bParseHost = 0;
		}
	} else {</b></font>
		listeners[nfd].bParseHost = inst-&gt;bParseHost;
	}
	if(inst-&gt;pLogHostName == NULL) {
		listeners[nfd].hostName = NULL;
	} else {
		CHKiRet(prop.Construct(&amp;(listeners[nfd].hostName)));
		CHKiRet(prop.SetString(listeners[nfd].hostName, inst-&gt;pLogHostName, ustrlen(inst-&gt;pLogHostName)));
		CHKiRet(prop.ConstructFinalize(listeners[nfd].hostName));
	}
	if(inst-&gt;ratelimitInterval &gt; 0) {
		if((listeners[nfd].ht = create_hashtable(100, hash_from_key_fn, key_equals_fn,
			(void(*)(void*))ratelimitDestruct)) == NULL) {
			DBGPRINTF("imuxsock: turning off rate limiting because we could not "
				  "create hash table\n");
			inst-&gt;ratelimitInterval = 0;
		}
	} else {
		listeners[nfd].ht = NULL;
	}
	listeners[nfd].ratelimitInterval = inst-&gt;ratelimitInterval;
	listeners[nfd].ratelimitBurst = inst-&gt;ratelimitBurst;
	listeners[nfd].ratelimitSev = inst-&gt;ratelimitSeverity;
	listeners[nfd].flowCtl = inst-&gt;bUseFlowCtl ? eFLOWCTL_LIGHT_DELAY : eFLOWCTL_NO_DELAY;
	listeners[nfd].flags = inst-&gt;bIgnoreTimestamp ? IGNDATE : NOFLAG;
	listeners[nfd].bCreatePath = inst-&gt;bCreatePath;
	listeners[nfd].sockName = ustrdup(inst-&gt;sockName);
	listeners[nfd].bUseCreds = (inst-&gt;bDiscardOwnMsgs || inst-&gt;bWritePid || inst-&gt;ratelimitInterval
	|| inst-&gt;bAnnotate || inst-&gt;bUseSysTimeStamp) ? 1 : 0;
	listeners[nfd].bAnnotate = inst-&gt;bAnnotate;
	listeners[nfd].bParseTrusted = inst-&gt;bParseTrusted;
	listeners[nfd].bDiscardOwnMsgs = inst-&gt;bDiscardOwnMsgs;
	listeners[nfd].bUnlink = inst-&gt;bUnlink;
	listeners[nfd].bWritePid = inst-&gt;bWritePid;
	listeners[nfd].bUseSysTimeStamp = inst-&gt;bUseSysTimeStamp;
	listeners[nfd].bUseSpecialParser = inst-&gt;bUseSpecialParser;
	listeners[nfd].pRuleset = inst-&gt;pBindRuleset;
	CHKiRet(ratelimitNew(&amp;listeners[nfd].dflt_ratelimiter, "imuxsock", NULL));
	ratelimitSetLinuxLike(listeners[nfd].dflt_ratelimiter,
			      listeners[nfd].ratelimitInterval,
			      listeners[nfd].ratelimitBurst);
	ratelimitSetSeverity(listeners[nfd].dflt_ratelimiter,
			     listeners[nfd].ratelimitSev);
	nfd++;
finalize_it:
	RETiRet;
}
static rsRetVal discardLogSockets(void)
{
	int i;
	if(startIndexUxLocalSockets == 0) {
		if(listeners[0].ht != NULL) {
			hashtable_destroy(listeners[0].ht, 1); 		}
		ratelimitDestruct(listeners[0].dflt_ratelimiter);
	}
	for (i = 1; i &lt; nfd; i++) {
		if(listeners[i].sockName != NULL) {
			free(listeners[i].sockName);
			listeners[i].sockName = NULL;
		}
		if(listeners[i].hostName != NULL) {
			prop.Destruct(&amp;(listeners[i].hostName));
		}
		if(listeners[i].ht != NULL) {
			hashtable_destroy(listeners[i].ht, 1); 		}
		ratelimitDestruct(listeners[i].dflt_ratelimiter);
	}
	return RS_RET_OK;
}
#if defined(__clang__)
#pragma GCC diagnostic ignored "-Wunknown-attributes"
#endif
static rsRetVal
#if defined(__clang__)
__attribute__((no_sanitize("undefined")))
#endif
createLogSocket(lstn_t *pLstn)
{
	struct sockaddr_un sunx;
	DEFiRet;
	if(pLstn-&gt;bUnlink)
		unlink((char*)pLstn-&gt;sockName);
	memset(&amp;sunx, 0, sizeof(sunx));
	sunx.sun_family = AF_UNIX;
	if(pLstn-&gt;bCreatePath) {
		makeFileParentDirs((uchar*)pLstn-&gt;sockName, ustrlen(pLstn-&gt;sockName), 0755, -1, -1, 0);
	}
	strncpy(sunx.sun_path, (char*)pLstn-&gt;sockName, sizeof(sunx.sun_path));
	sunx.sun_path[sizeof(sunx.sun_path)-1] = '\0';
	pLstn-&gt;fd = socket(AF_UNIX, SOCK_DGRAM, 0);
	if(pLstn-&gt;fd &lt; 0 ) {
		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
	}
	if(bind(pLstn-&gt;fd, (struct sockaddr *) &amp;sunx, SUN_LEN(&amp;sunx)) &lt; 0) {
		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
	}
	if(chmod((char*)pLstn-&gt;sockName, 0666) &lt; 0) {
		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
	}
finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(errno, iRet, "cannot create '%s'", pLstn-&gt;sockName);
		if(pLstn-&gt;fd != -1) {
			close(pLstn-&gt;fd);
			pLstn-&gt;fd = -1;
		}
	}
	RETiRet;
}
static rsRetVal
openLogSocket(lstn_t *pLstn)
{
	DEFiRet;
#	ifdef HAVE_SCM_CREDENTIALS
	int one;
#	endif 
	if(pLstn-&gt;sockName[0] == '\0')
		return -1;
	pLstn-&gt;fd = -1;
#ifdef HAVE_LIBSYSTEMD
	if (sd_fds &gt; 0) {
		int fd;
		for (fd = SD_LISTEN_FDS_START; fd &lt; SD_LISTEN_FDS_START + sd_fds; fd++) {
			if( sd_is_socket_unix(fd, SOCK_DGRAM, -1, (const char*) pLstn-&gt;sockName, 0) == 1) {
				pLstn-&gt;fd = fd;
				LogMsg(0, NO_ERRCODE, LOG_INFO,
					"imuxsock: Acquired UNIX socket '%s' (fd %d) from systemd.\n",
					pLstn-&gt;sockName, pLstn-&gt;fd);
				break;
			}
		}
	}
#endif
	if (pLstn-&gt;fd == -1) {
		CHKiRet(createLogSocket(pLstn));
		assert(pLstn-&gt;fd != -1); 	}
#	ifdef HAVE_SCM_CREDENTIALS
	if(pLstn-&gt;bUseCreds) {
		one = 1;
		if(setsockopt(pLstn-&gt;fd, SOL_SOCKET, SO_PASSCRED, &amp;one, (socklen_t) sizeof(one)) != 0) {
			LogError(errno, NO_ERRCODE, "set SO_PASSCRED failed on '%s'", pLstn-&gt;sockName);
			pLstn-&gt;bUseCreds = 0;
		}
		if(setsockopt(pLstn-&gt;fd, SOL_SOCKET, SO_TIMESTAMP, &amp;one, sizeof(one)) != 0) {
			LogError(errno, NO_ERRCODE, "set SO_TIMESTAMP failed on '%s'", pLstn-&gt;sockName);
		}
	}
#	else 	pLstn-&gt;bUseCreds = 0;
	pLstn-&gt;bAnnotate = 0;
#	endif 
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pLstn-&gt;fd != -1) {
			close(pLstn-&gt;fd);
			pLstn-&gt;fd = -1;
		}
	}
	RETiRet;
}
static rsRetVal
findRatelimiter(lstn_t *pLstn, struct ucred *cred, ratelimit_t **prl)
{
	ratelimit_t *rl = NULL;
	int r;
	pid_t *keybuf;
	char pinfobuf[512];
	DEFiRet;
	if(cred == NULL)
		FINALIZE;
#if 0 	if(pLstn-&gt;ratelimitInterval == 0) {
		*prl = NULL;
		FINALIZE;
	}
#endif
	if(pLstn-&gt;ht == NULL) {
		*prl = NULL;
		FINALIZE;
	}
	rl = hashtable_search(pLstn-&gt;ht, &amp;cred-&gt;pid);
	if(rl == NULL) {
		DBGPRINTF("imuxsock: no ratelimiter for pid %lu, creating one\n",
			  (unsigned long) cred-&gt;pid);
		STATSCOUNTER_INC(ctrNumRatelimiters, mutCtrNumRatelimiters);
		char procName[256]; 		snprintf(procName, sizeof(procName), "/proc/%lu/cmdline", (unsigned long) cred-&gt;pid);
		FILE *f = fopen(procName, "r");
		if (f) {
			size_t len;
			len = fread(procName, sizeof(char), 256, f);
			if (len &gt; 0) {
				snprintf(pinfobuf, sizeof(pinfobuf), "pid: %lu, name: %s",
					(unsigned long) cred-&gt;pid, procName);
			}
			fclose(f);
		}
		else {
			snprintf(pinfobuf, sizeof(pinfobuf), "pid: %lu",
				(unsigned long) cred-&gt;pid);
		}
		pinfobuf[sizeof(pinfobuf)-1] = '\0'; 		CHKiRet(ratelimitNew(&amp;rl, "imuxsock", pinfobuf));
		ratelimitSetLinuxLike(rl, pLstn-&gt;ratelimitInterval, pLstn-&gt;ratelimitBurst);
		ratelimitSetSeverity(rl, pLstn-&gt;ratelimitSev);
		CHKmalloc(keybuf = malloc(sizeof(pid_t)));
		*keybuf = cred-&gt;pid;
		r = hashtable_insert(pLstn-&gt;ht, keybuf, rl);
		if(r == 0)
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	*prl = rl;
	rl = NULL;
finalize_it:
	if(rl != NULL)
		ratelimitDestruct(rl);
	if(*prl == NULL)
		*prl = pLstn-&gt;dflt_ratelimiter;
	RETiRet;
}
static void
fixPID(uchar *bufTAG, int *lenTag, struct ucred *cred)
{
	int i;
	char bufPID[16];
	int lenPID;
	if(cred == NULL)
		return;
	lenPID = snprintf(bufPID, sizeof(bufPID), "[%lu]:", (unsigned long) cred-&gt;pid);
	for(i = *lenTag ; i &gt;= 0  &amp;&amp; bufTAG[i] != '[' ; --i)
	if(i &lt; 0)
		i = *lenTag - 1; 
	if(i + lenPID &gt; CONF_TAG_MAXSIZE)
		return; 
	memcpy(bufTAG + i, bufPID, lenPID);
	*lenTag = i + lenPID;
}
static rsRetVal
getTrustedProp(struct ucred *cred, const char *propName, uchar *buf, size_t lenBuf, int *lenProp)
{
	int fd;
	int i;
	int lenRead;
	char namebuf[1024];
	DEFiRet;
	if(snprintf(namebuf, sizeof(namebuf), "/proc/%lu/%s", (long unsigned) cred-&gt;pid,
		propName) &gt;= (int) sizeof(namebuf)) {
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if((fd = open(namebuf, O_RDONLY)) == -1) {
		DBGPRINTF("error reading '%s'\n", namebuf);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if((lenRead = read(fd, buf, lenBuf - 1)) == -1) {
		DBGPRINTF("error reading file data for '%s'\n", namebuf);
		close(fd);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	for(i = 0 ; i &lt; lenRead ; ++i) {
		if(buf[i] == '\n')
			break;
		else if(iscntrl(buf[i]))
			buf[i] = ' ';
	}
	buf[i] = '\0';
	*lenProp = i;
	close(fd);
finalize_it:
	RETiRet;
}
static rsRetVal
getTrustedExe(struct ucred *cred, uchar *buf, size_t lenBuf, int* lenProp)
{
	int lenRead;
	char namebuf[1024];
	DEFiRet;
	if(snprintf(namebuf, sizeof(namebuf), "/proc/%lu/exe", (long unsigned) cred-&gt;pid)
		&gt;= (int) sizeof(namebuf)) {
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if((lenRead = readlink(namebuf, (char*)buf, lenBuf - 1)) == -1) {
		DBGPRINTF("error reading link '%s'\n", namebuf);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	buf[lenRead] = '\0';
	*lenProp = lenRead;
finalize_it:
	RETiRet;
}
static int
copyescaped(uchar *dstbuf, uchar *inbuf, int inlen)
{
	int iDst, iSrc;
	*dstbuf = '"';
	for(iDst=1, iSrc=0 ; iSrc &lt; inlen ; ++iDst, ++iSrc) {
		if(inbuf[iSrc] == '"' || inbuf[iSrc] == '\\') {
			dstbuf[iDst++] = '\\';
		}
		dstbuf[iDst] = inbuf[iSrc];
	}
	dstbuf[iDst++] = '"';
	return iDst;
}
static rsRetVal
SubmitMsg(uchar *pRcv, int lenRcv, lstn_t *pLstn, struct ucred *cred, struct timeval *ts)
{
	smsg_t *pMsg = NULL;
	int lenMsg;
	int offs;
	int i;
	uchar *parse;
	syslog_pri_t pri;
	uchar bufParseTAG[CONF_TAG_MAXSIZE];
	struct syslogTime st;
	time_t tt;
	ratelimit_t *ratelimiter = NULL;
	struct syslogTime dummyTS;
	DEFiRet;
	if(pLstn-&gt;bDiscardOwnMsgs &amp;&amp; cred != NULL &amp;&amp; cred-&gt;pid == glblGetOurPid()) {
		DBGPRINTF("imuxsock: discarding message from our own pid\n");
		FINALIZE;
	}
	parse = pRcv;
	lenMsg = lenRcv;
	offs = 1; 
	parse++;
	pri = 0;
	while(offs &lt; lenMsg &amp;&amp; isdigit(*parse)) {
		pri = pri * 10 + *parse - '0';
		++parse;
		++offs;
	}
	findRatelimiter(pLstn, cred, &amp;ratelimiter); 
	if(ts == NULL) {
		datetime.getCurrTime(&amp;st, &amp;tt, TIME_IN_LOCALTIME);
	} else {
		datetime.timeval2syslogTime(ts, &amp;st, TIME_IN_LOCALTIME);
		tt = ts-&gt;tv_sec;
	}
#if 0 	if(ratelimiter != NULL &amp;&amp; !withinRatelimit(ratelimiter, tt, cred-&gt;pid)) {
		STATSCOUNTER_INC(ctrLostRatelimit, mutCtrLostRatelimit);
		FINALIZE;
	}
#endif
	CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tt));
	if(cred != NULL &amp;&amp; pLstn-&gt;bAnnotate) {
		uchar propBuf[1024];
		int lenProp;
		if (pLstn-&gt;bParseTrusted) {
			struct json_object *json, *jval;
#define CHKjson(operation, toBeFreed)					\
			if((operation) == NULL) {			\
				json_object_put(toBeFreed);		\
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);	\
			}
			CHKmalloc(json = json_object_new_object());
			CHKjson(jval = json_object_new_int(cred-&gt;pid), json);
			json_object_object_add(json, "pid", jval);
			CHKjson(jval = json_object_new_int(cred-&gt;uid), json);
			json_object_object_add(json, "uid", jval);
			CHKjson(jval = json_object_new_int(cred-&gt;gid), json);
			json_object_object_add(json, "gid", jval);
			if(getTrustedProp(cred, "comm", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				CHKjson(jval = json_object_new_string((char*)propBuf), json);
				json_object_object_add(json, "appname", jval);
			}
			if(getTrustedExe(cred, propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				CHKjson(jval = json_object_new_string((char*)propBuf), json);
				json_object_object_add(json, "exe", jval);
			}
			if(getTrustedProp(cred, "cmdline", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				CHKjson(jval = json_object_new_string((char*)propBuf), json);
				json_object_object_add(json, "cmd", jval);
			}
#undef CHKjson
			msgAddJSON(pMsg, (uchar*)"!", json, 0, 0);
			MsgSetRawMsg(pMsg, (char*)pRcv, lenRcv);
		} else {
			uchar msgbuf[8192];
			uchar *pmsgbuf = msgbuf;
			int toffs; 
			if((unsigned) (lenRcv + 4096) &gt;= sizeof(msgbuf)) {
				CHKmalloc(pmsgbuf = malloc(lenRcv+4096));
			}
			memcpy(pmsgbuf, pRcv, lenRcv);
			memcpy(pmsgbuf+lenRcv, " @[", 3);
			toffs = lenRcv + 3; 			lenProp = snprintf((char*)propBuf, sizeof(propBuf), "_PID=%lu _UID=%lu _GID=%lu",
				 		(long unsigned) cred-&gt;pid, (long unsigned) cred-&gt;uid,
						(long unsigned) cred-&gt;gid);
			memcpy(pmsgbuf+toffs, propBuf, lenProp);
			toffs = toffs + lenProp;
			if(getTrustedProp(cred, "comm", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				memcpy(pmsgbuf+toffs, " _COMM=", 7);
				memcpy(pmsgbuf+toffs+7, propBuf, lenProp);
				toffs = toffs + 7 + lenProp;
			}
			if(getTrustedExe(cred, propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				memcpy(pmsgbuf+toffs, " _EXE=", 6);
				memcpy(pmsgbuf+toffs+6, propBuf, lenProp);
				toffs = toffs + 6 + lenProp;
			}
			if(getTrustedProp(cred, "cmdline", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				memcpy(pmsgbuf+toffs, " _CMDLINE=", 10);
				toffs = toffs + 10 +
					copyescaped(pmsgbuf+toffs+10, propBuf, lenProp);
			}
			pmsgbuf[toffs] = ']';
			pmsgbuf[toffs+1] = '\0';
			MsgSetRawMsg(pMsg, (char*)pmsgbuf, toffs + 1);
			if (pmsgbuf != msgbuf) {
				free(pmsgbuf);
			}
		}
	} else {
		MsgSetRawMsg(pMsg, (char*)pRcv, lenRcv);
	}
	MsgSetFlowControlType(pMsg, pLstn-&gt;flowCtl);
	MsgSetInputName(pMsg, pInputName);
	if(pLstn-&gt;bParseHost) {
		pMsg-&gt;msgFlags  = pLstn-&gt;flags | PARSE_HOSTNAME;
	} else {
		pMsg-&gt;msgFlags  = pLstn-&gt;flags;
	}
	if(pLstn-&gt;bUseSpecialParser) {
		parser.SanitizeMsg(pMsg);
		lenMsg = pMsg-&gt;iLenRawMsg - offs; 		msgSetPRI(pMsg, pri);
		MsgSetAfterPRIOffs(pMsg, offs);
		parse++; lenMsg--; 		if(ts == NULL) {
			if((pLstn-&gt;flags &amp; IGNDATE)) {
				if (datetime.ParseTIMESTAMP3339(&amp;dummyTS, &amp;parse, &amp;lenMsg) != RS_RET_OK) {
					datetime.ParseTIMESTAMP3164(&amp;dummyTS, &amp;parse, &amp;lenMsg,
					NO_PARSE3164_TZSTRING, NO_PERMIT_YEAR_AFTER_TIME);
				}
			} else {
				if(datetime.ParseTIMESTAMP3339(&amp;(pMsg-&gt;tTIMESTAMP), &amp;parse, &amp;lenMsg) != RS_RET_OK &amp;&amp;
				datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;parse, &amp;lenMsg,
				NO_PARSE3164_TZSTRING, NO_PERMIT_YEAR_AFTER_TIME) != RS_RET_OK) {
					DBGPRINTF("we have a problem, invalid timestamp in msg!\n");
				}
			}
		} else { 			uchar *tmpParse = parse; 			if(datetime.ParseTIMESTAMP3339(&amp;dummyTS, &amp;tmpParse, &amp;lenMsg) == RS_RET_OK ||
		 	datetime.ParseTIMESTAMP3164(&amp;dummyTS, &amp;tmpParse, &amp;lenMsg, NO_PARSE3164_TZSTRING,
			NO_PERMIT_YEAR_AFTER_TIME) == RS_RET_OK) {
				datetime.formatTimestamp3164(&amp;st, (char*)parse, 0);
				parse[15] = ' '; 				parse += 16;
			}
		}
		i = 0;
		while(lenMsg &gt; 0 &amp;&amp; *parse != ' ' &amp;&amp; i &lt; CONF_TAG_MAXSIZE - 1) {
			bufParseTAG[i++] = *parse++;
			--lenMsg;
		}
		bufParseTAG[i] = '\0';			if(pLstn-&gt;bWritePid)
			fixPID(bufParseTAG, &amp;i, cred);
		MsgSetTAG(pMsg, bufParseTAG, i);
		MsgSetMSGoffs(pMsg, pMsg-&gt;iLenRawMsg - lenMsg);
	} else { 		pMsg-&gt;msgFlags  |= NEEDS_PARSING;
	}
	MsgSetRcvFrom(pMsg, pLstn-&gt;hostName == NULL ? glbl.GetLocalHostNameProp() : pLstn-&gt;hostName);
	CHKiRet(MsgSetRcvFromIP(pMsg, pLocalHostIP));
	MsgSetRuleset(pMsg, pLstn-&gt;pRuleset);
	ratelimitAddMsg(ratelimiter, NULL, pMsg);
	STATSCOUNTER_INC(ctrSubmit, mutCtrSubmit);
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pMsg != NULL)
			msgDestruct(&amp;pMsg);
	}
	RETiRet;
}
static rsRetVal readSocket(lstn_t *pLstn)
{
	DEFiRet;
	int iRcvd;
	int iMaxLine;
	struct msghdr msgh;
	struct iovec msgiov;
	struct ucred cred;
	struct timeval ts;
	int cred_set = 0;
	int ts_set = 0;
	uchar bufRcv[4096+1];
	uchar *pRcv = NULL; #	ifdef HAVE_SCM_CREDENTIALS
	union {
		char buf[128];
		struct cmsghdr cm;
	} aux;
#	endif
	assert(pLstn-&gt;fd &gt;= 0);
	iMaxLine = glbl.GetMaxLine(runConf);
	if((size_t) iMaxLine &lt; sizeof(bufRcv) - 1) {
		pRcv = bufRcv;
	} else {
		CHKmalloc(pRcv = (uchar*) malloc(iMaxLine + 1));
	}
	memset(&amp;msgh, 0, sizeof(msgh));
	memset(&amp;msgiov, 0, sizeof(msgiov));
#	ifdef HAVE_SCM_CREDENTIALS
	if(pLstn-&gt;bUseCreds) {
		memset(&amp;aux, 0, sizeof(aux));
		msgh.msg_control = &amp;aux;
		msgh.msg_controllen = sizeof(aux);
	}
#	endif
	msgiov.iov_base = (char*)pRcv;
	msgiov.iov_len = iMaxLine;
	msgh.msg_iov = &amp;msgiov;
	msgh.msg_iovlen = 1;
#if defined (_AIX)
#define MSG_DONTWAIT    MSG_NONBLOCK
#endif
	iRcvd = recvmsg(pLstn-&gt;fd, &amp;msgh, MSG_DONTWAIT);
	DBGPRINTF("Message from UNIX socket: #%d, size %d\n", pLstn-&gt;fd, (int) iRcvd);
	if(iRcvd &gt; 0) {
#		if defined(HAVE_SCM_CREDENTIALS) || defined(HAVE_SO_TIMESTAMP)
		if(pLstn-&gt;bUseCreds) {
			struct cmsghdr *cm;
			for(cm = CMSG_FIRSTHDR(&amp;msgh); cm; cm = CMSG_NXTHDR(&amp;msgh, cm)) {
#				ifdef HAVE_SCM_CREDENTIALS
				if(   pLstn-&gt;bUseCreds
				   &amp;&amp; cm-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cm-&gt;cmsg_type == SCM_CREDENTIALS) {
					memcpy(&amp;cred, CMSG_DATA(cm), sizeof(cred));
					cred_set = 1;
				}
#				endif #				if HAVE_SO_TIMESTAMP
				if(   pLstn-&gt;bUseSysTimeStamp
				   &amp;&amp; cm-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cm-&gt;cmsg_type == SO_TIMESTAMP) {
					memcpy(&amp;ts, CMSG_DATA(cm), sizeof(ts));
					ts_set = 1;
				}
#				endif 			}
		}
#		endif 		CHKiRet(SubmitMsg(pRcv, iRcvd, pLstn, (cred_set ? &amp;cred : NULL), (ts_set ? &amp;ts : NULL)));
	} else if(iRcvd &lt; 0 &amp;&amp; errno != EINTR &amp;&amp; errno != EAGAIN) {
		char errStr[1024];
		rs_strerror_r(errno, errStr, sizeof(errStr));
		DBGPRINTF("UNIX socket error: %d = %s.\n", errno, errStr);
		LogError(errno, NO_ERRCODE, "imuxsock: recvfrom UNIX");
	}
finalize_it:
	if(pRcv != NULL &amp;&amp; (size_t) iMaxLine &gt;= sizeof(bufRcv) - 1)
		free(pRcv);
	RETiRet;
}
static rsRetVal
activateListeners(void)
{
	int actSocks;
	int i;
	DEFiRet;
	if(startIndexUxLocalSockets == 0) {
		listeners[0].sockName = UCHAR_CONSTANT(_PATH_LOG);
		if(runModConf-&gt;pLogSockName != NULL) {
			listeners[0].sockName = runModConf-&gt;pLogSockName;
		}
#ifdef HAVE_LIBSYSTEMD
		else if(sd_booted()) {
			struct stat st;
			if(stat(SYSTEMD_PATH_LOG, &amp;st) != -1 &amp;&amp; S_ISSOCK(st.st_mode)) {
				listeners[0].sockName = (uchar*) SYSTEMD_PATH_LOG;
			}
		}
#endif
		if(runModConf-&gt;ratelimitIntervalSysSock &gt; 0) {
			if((listeners[0].ht = create_hashtable(100, hash_from_key_fn, key_equals_fn, NULL)) == NULL) {
				LogError(0, NO_ERRCODE, "imuxsock: turning off rate limiting because "
					"we could not create hash table\n");
				runModConf-&gt;ratelimitIntervalSysSock = 0;
			}
		} else {
			listeners[0].ht = NULL;
		}
		listeners[0].fd = -1;
		listeners[0].pRuleset = NULL;
		listeners[0].hostName = NULL;
		listeners[0].bParseHost = 0;
		listeners[0].bCreatePath = 0;
		listeners[0].ratelimitInterval = runModConf-&gt;ratelimitIntervalSysSock;
		listeners[0].ratelimitBurst = runModConf-&gt;ratelimitBurstSysSock;
		listeners[0].ratelimitSev = runModConf-&gt;ratelimitSeveritySysSock;
		listeners[0].bUseCreds = (runModConf-&gt;bWritePidSysSock || runModConf-&gt;ratelimitIntervalSysSock
		|| runModConf-&gt;bAnnotateSysSock || runModConf-&gt;bDiscardOwnMsgs
		|| runModConf-&gt;bUseSysTimeStamp) ? 1 : 0;
		listeners[0].bWritePid = runModConf-&gt;bWritePidSysSock;
		listeners[0].bAnnotate = runModConf-&gt;bAnnotateSysSock;
		listeners[0].bParseTrusted = runModConf-&gt;bParseTrusted;
		listeners[0].bParseHost = runModConf-&gt;bParseHost;
		listeners[0].bUseSpecialParser = runModConf-&gt;bUseSpecialParser;
		listeners[0].bDiscardOwnMsgs = runModConf-&gt;bDiscardOwnMsgs;
		listeners[0].bUnlink = runModConf-&gt;bUnlink;
		listeners[0].bUseSysTimeStamp = runModConf-&gt;bUseSysTimeStamp;
		listeners[0].flags = runModConf-&gt;bIgnoreTimestamp ? IGNDATE : NOFLAG;
		listeners[0].flowCtl = runModConf-&gt;bUseFlowCtl ? eFLOWCTL_LIGHT_DELAY : eFLOWCTL_NO_DELAY;
		CHKiRet(ratelimitNew(&amp;listeners[0].dflt_ratelimiter, "imuxsock", NULL));
			ratelimitSetLinuxLike(listeners[0].dflt_ratelimiter,
			listeners[0].ratelimitInterval,
			listeners[0].ratelimitBurst);
		ratelimitSetSeverity(listeners[0].dflt_ratelimiter,listeners[0].ratelimitSev);
	}
#ifdef HAVE_LIBSYSTEMD
	sd_fds = sd_listen_fds(0);
	if(sd_fds &lt; 0) {
		LogError(-sd_fds, NO_ERRCODE, "imuxsock: Failed to acquire systemd socket");
		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
	}
#endif
	actSocks = 0;
	for (i = startIndexUxLocalSockets ; i &lt; nfd ; i++) {
		if(openLogSocket(&amp;(listeners[i])) == RS_RET_OK) {
			++actSocks;
			DBGPRINTF("imuxsock: Opened UNIX socket '%s' (fd %d).\n",
				  listeners[i].sockName, listeners[i].fd);
		}
	}
	if(actSocks == 0) {
		LogError(0, RS_RET_ERR, "imuxsock does not run because we could not "
			"acquire any socket\n");
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	RETiRet;
}
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;pLogSockName = NULL;
	pModConf-&gt;bOmitLocalLogging = 0;
	pModConf-&gt;bIgnoreTimestamp = 1;
	pModConf-&gt;bUseFlowCtl = 0;
	pModConf-&gt;bUseSysTimeStamp = 1;
	pModConf-&gt;bWritePidSysSock = 0;
	pModConf-&gt;bAnnotateSysSock = 0;
	pModConf-&gt;bParseTrusted = 0;
	pModConf-&gt;bParseHost = UNSET;
	pModConf-&gt;bUseSpecialParser = DFLT_bUseSpecialParser;
	pModConf-&gt;bDiscardOwnMsgs = pConf-&gt;globals.bProcessInternalMessages;
	pModConf-&gt;bUnlink = 1;
	pModConf-&gt;ratelimitIntervalSysSock = DFLT_ratelimitInterval;
	pModConf-&gt;ratelimitBurstSysSock = DFLT_ratelimitBurst;
<a name="1"></a>	pModConf-&gt;ratelimitSeveritySysSock = DFLT_ratelimitSeverity;
	bLegacyCnfModGlobalsPermitted = 1;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	resetConfigVariables(NULL, NULL);
ENDbeginCnfLoad
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for imuxsock:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "syssock.use")) {
			loadModConf-&gt;bOmitLocalLogging = ((int) pvals[i].val.d.n) ? 0 : 1;</b></font>
		} else if(!strcmp(modpblk.descr[i].name, "syssock.name")) {
			loadModConf-&gt;pLogSockName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ignoretimestamp")) {
			loadModConf-&gt;bIgnoreTimestamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ignoreownmessages")) {
			loadModConf-&gt;bDiscardOwnMsgs = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.unlink")) {
			loadModConf-&gt;bUnlink = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.flowcontrol")) {
			loadModConf-&gt;bUseFlowCtl = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.usesystimestamp")) {
			loadModConf-&gt;bUseSysTimeStamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.annotate")) {
			loadModConf-&gt;bAnnotateSysSock = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.parsetrusted")) {
			loadModConf-&gt;bParseTrusted = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.parsehostname")) {
			loadModConf-&gt;bParseHost = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.usespecialparser")) {
			loadModConf-&gt;bUseSpecialParser = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.usepidfromsystem")) {
			loadModConf-&gt;bWritePidSysSock = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ratelimit.interval")) {
			loadModConf-&gt;ratelimitIntervalSysSock = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ratelimit.burst")) {
			loadModConf-&gt;ratelimitBurstSysSock = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ratelimit.severity")) {
			loadModConf-&gt;ratelimitSeveritySysSock = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("imuxsock: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
<a name="2"></a>	DBGPRINTF("newInpInst (imuxsock)\n");
	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS,
			        "imuxsock: required parameter are missing\n");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("input param blk in imuxsock:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}
	CHKiRet(createInstance(&amp;inst));
	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "socket")) {
			inst-&gt;sockName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "createpath")) {
			inst-&gt;bCreatePath = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "parsetrusted")) {
			inst-&gt;bParseTrusted = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ignoreownmessages")) {
			inst-&gt;bDiscardOwnMsgs = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "unlink")) {
			inst-&gt;bUnlink = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "hostname")) {
			inst-&gt;pLogHostName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ignoretimestamp")) {
			inst-&gt;bIgnoreTimestamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "flowcontrol")) {
			inst-&gt;bUseFlowCtl = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "usesystimestamp")) {
			inst-&gt;bUseSysTimeStamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "annotate")) {
			inst-&gt;bAnnotate = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "usepidfromsystem")) {
			inst-&gt;bWritePid = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "parsehostname")) {
			inst-&gt;bParseHost  = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "usespecialparser")) {
			inst-&gt;bUseSpecialParser  = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.interval")) {
			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.burst")) {
			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.severity")) {
			inst-&gt;ratelimitSeverity = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("imuxsock: program error, non-handled "
			  "param '%s'\n", inppblk.descr[i].name);
		}
	}
finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst
BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		loadModConf-&gt;bOmitLocalLogging = cs.bOmitLocalLogging;
		loadModConf-&gt;pLogSockName = cs.pLogSockName;
		loadModConf-&gt;bIgnoreTimestamp = cs.bIgnoreTimestampSysSock;
		loadModConf-&gt;bUseSysTimeStamp = cs.bUseSysTimeStampSysSock;
		loadModConf-&gt;bUseFlowCtl = cs.bUseFlowCtlSysSock;
		loadModConf-&gt;bAnnotateSysSock = cs.bAnnotateSysSock;
		loadModConf-&gt;bWritePidSysSock = cs.bWritePidSysSock;
		loadModConf-&gt;bParseTrusted = cs.bParseTrusted;
		loadModConf-&gt;ratelimitIntervalSysSock = cs.ratelimitIntervalSysSock;
		loadModConf-&gt;ratelimitBurstSysSock = cs.ratelimitBurstSysSock;
		loadModConf-&gt;ratelimitSeveritySysSock = cs.ratelimitSeveritySysSock;
	}
	loadModConf = NULL; 	free(cs.pLogHostName);
	cs.pLogSockName = NULL;
	cs.pLogHostName = NULL;
ENDendCnfLoad
static void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imuxsock: ruleset '%s' for socket %s not found - "
			"using default ruleset instead", inst-&gt;pszBindRuleset,
			inst-&gt;sockName);
}
BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
ENDcheckCnf
BEGINactivateCnfPrePrivDrop
	instanceConf_t *inst;
	int nLstn;
	int i;
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
#	ifdef OS_SOLARIS
		startIndexUxLocalSockets = 1;
#	else
		startIndexUxLocalSockets = runModConf-&gt;bOmitLocalLogging ? 1 : 0;
#	endif
	nLstn = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		++nLstn;
	}
	if(nLstn &gt; 0 || startIndexUxLocalSockets == 0) {
		DBGPRINTF("imuxsock: allocating memory for %d listeners\n", nLstn);
		lstn_t *const listeners_new = realloc(listeners, (1+nLstn)*sizeof(lstn_t));
		CHKmalloc(listeners_new);
		listeners = listeners_new;
		for(i = 1 ; i &lt; nLstn ; ++i) {
			listeners[i].sockName = NULL;
			listeners[i].fd  = -1;
		}
		for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
			addListner(inst);
		}
		CHKiRet(activateListeners());
	}
finalize_it:
ENDactivateCnfPrePrivDrop
BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf
BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	free(pModConf-&gt;pLogSockName);
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;sockName);
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;pLogHostName);
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf
BEGINrunInput
	int nfds;
	int i;
CODESTARTrunInput
	struct pollfd *const pollfds = calloc(nfd, sizeof(struct pollfd));
	CHKmalloc(pollfds);
	if(startIndexUxLocalSockets == 1 &amp;&amp; nfd == 1) {
		ABORT_FINALIZE(RS_RET_OK);
	}
	if(startIndexUxLocalSockets == 1) {
		pollfds[0].fd = -1;
	}
	for (i = startIndexUxLocalSockets; i &lt; nfd; i++) {
		pollfds[i].fd = listeners[i].fd;
		pollfds[i].events = POLLIN;
	}
	while(1) {
		DBGPRINTF("--------imuxsock calling poll() on %d fds\n", nfd);
		nfds = poll(pollfds, nfd, -1);
		if(glbl.GetGlobalInputTermState() == 1)
			break; 
		if(nfds &lt; 0) {
			if(errno == EINTR) {
				DBGPRINTF("imuxsock: EINTR occurred\n");
			} else {
				LogMsg(errno, RS_RET_POLL_ERR, LOG_WARNING, "imuxsock: poll "
					"system call failed, may cause further troubles");
			}
			nfds = 0;
		}
		for (i = startIndexUxLocalSockets ; i &lt; nfd &amp;&amp; nfds &gt; 0; i++) {
			if(glbl.GetGlobalInputTermState() == 1)
				ABORT_FINALIZE(RS_RET_FORCE_TERM); 			if(pollfds[i].revents &amp; POLLIN) {
				readSocket(&amp;(listeners[i]));
				--nfds; 			}
		}
	}
finalize_it:
	free(pollfds);
ENDrunInput
BEGINwillRun
CODESTARTwillRun
ENDwillRun
BEGINafterRun
	int i;
CODESTARTafterRun
	if(startIndexUxLocalSockets == 1 &amp;&amp; nfd == 1) {
		return RS_RET_OK;
	}
	for (i = 0; i &lt; nfd; i++)
		if (listeners[i].fd != -1)
			close(listeners[i].fd);
	for(i = startIndexUxLocalSockets; i &lt; nfd; i++)
		if (listeners[i].sockName &amp;&amp; listeners[i].fd != -1) {
			if (sd_fds &gt; 0
#			ifdef HAVE_LIBSYSTEMD
			    &amp;&amp; listeners[i].fd &gt;= SD_LISTEN_FDS_START &amp;&amp;
			       listeners[i].fd &lt;  SD_LISTEN_FDS_START + sd_fds
#			endif
			   )
				continue;
			if(listeners[i].bUnlink) {
				DBGPRINTF("imuxsock: unlinking unix socket file[%d] %s\n", i, listeners[i].sockName);
				unlink((char*) listeners[i].sockName);
			}
		}
	discardLogSockets();
	nfd = 1;
ENDafterRun
BEGINmodExit
CODESTARTmodExit
	free(listeners);
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
	statsobj.Destruct(&amp;modStats);
	objRelease(parser, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
ENDmodExit
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	free(cs.pLogSockName);
	cs.pLogSockName = NULL;
	free(cs.pLogHostName);
	cs.bOmitLocalLogging = 0;
	cs.pLogHostName = NULL;
	cs.bIgnoreTimestamp = 1;
	cs.bIgnoreTimestampSysSock = 1;
	cs.bUseFlowCtl = 0;
	cs.bUseFlowCtlSysSock = 0;
	cs.bUseSysTimeStamp = 1;
	cs.bUseSysTimeStampSysSock = 1;
	cs.bWritePid = 0;
	cs.bWritePidSysSock = 0;
	cs.bAnnotate = 0;
	cs.bAnnotateSysSock = 0;
	cs.bParseTrusted = 0;
	cs.bCreatePath = DFLT_bCreatePath;
	cs.ratelimitInterval = DFLT_ratelimitInterval;
	cs.ratelimitIntervalSysSock = DFLT_ratelimitInterval;
	cs.ratelimitBurst = DFLT_ratelimitBurst;
	cs.ratelimitBurstSysSock = DFLT_ratelimitBurst;
	cs.ratelimitSeverity = DFLT_ratelimitSeverity;
	cs.ratelimitSeveritySysSock = DFLT_ratelimitSeverity;
	return RS_RET_OK;
}
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(net, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	DBGPRINTF("imuxsock version %s initializing\n", PACKAGE_VERSION);
	cs.pLogSockName = NULL;
	cs.pLogHostName = NULL;	
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imuxsock"), sizeof("imuxsock") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
	pLocalHostIP = glbl.GetLocalHostIP();
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketignoremsgtimestamp", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bIgnoreTimestamp, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensockethostname", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pLogHostName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketflowcontrol", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bUseFlowCtl, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketannotate", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bAnnotate, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketcreatepath", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bCreatePath, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketusesystimestamp", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bUseSysTimeStamp, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"addunixlistensocket", 0, eCmdHdlrGetWord,
		addInstance, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketusepidfromsystem", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bWritePid, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imuxsockratelimitinterval", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitInterval, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imuxsockratelimitburst", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitBurst, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imuxsockratelimitseverity", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitSeverity, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(regCfSysLineHdlr2((uchar *)"omitlocallogging", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bOmitLocalLogging, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketname", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pLogSockName, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketignoremsgtimestamp", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bIgnoreTimestampSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketflowcontrol", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bUseFlowCtlSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogusesystimestamp", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bUseSysTimeStampSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketannotate", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bAnnotateSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogparsetrusted", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bParseTrusted, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogusepidfromsystem", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bWritePidSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogratelimitinterval", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitIntervalSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogratelimitburst", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitBurstSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogratelimitseverity", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitSeveritySysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(statsobj.Construct(&amp;modStats));
	CHKiRet(statsobj.SetName(modStats, UCHAR_CONSTANT("imuxsock")));
	CHKiRet(statsobj.SetOrigin(modStats, UCHAR_CONSTANT("imuxsock")));
	STATSCOUNTER_INIT(ctrSubmit, mutCtrSubmit);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("submitted"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrSubmit));
	STATSCOUNTER_INIT(ctrLostRatelimit, mutCtrLostRatelimit);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("ratelimit.discarded"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrLostRatelimit));
	STATSCOUNTER_INIT(ctrNumRatelimiters, mutCtrNumRatelimiters);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("ratelimit.numratelimiters"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrNumRatelimiters));
	CHKiRet(statsobj.ConstructFinalize(modStats));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
