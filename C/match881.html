<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for imkafka.c &amp; imuxsock.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imkafka.c &amp; imuxsock.c
      </h3>
<h1 align="center">
        10.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imkafka.c (16.962843%)<th>imuxsock.c (7.3477955%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(135-150)<td><a href="#" name="0">(275-290)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(607-631)<td><a href="#" name="1">(1262-1286)</a><td align="center"><font color="#d90000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(536-551)<td><a href="#" name="2">(1339-1356)</a><td align="center"><font color="#8d0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(305-319)<td><a href="#" name="3">(344-362)</a><td align="center"><font color="#840000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(576-582)<td><a href="#" name="4">(407-413)</a><td align="center"><font color="#7a0000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(279-290)<td><a href="#" name="5">(317-327)</a><td align="center"><font color="#7a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imkafka.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* imkafka.c
 *
 * This input plugin is a consumer for Apache Kafka.
 *
 * File begun on 2017-04-25 by alorbach
 *
 * Copyright 2008-2017 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;librdkafka/rdkafka.h&gt;

#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "atomic.h"
#include "statsobj.h"
#include "unicode-helper.h"
#include "prop.h"
#include "ruleset.h"
#include "glbl.h"
#include "cfsysline.h"
#include "msg.h"
#include "dirty.h"

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imkafka")

/* static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)

/* forward references */
static void * imkafkawrkr(void *myself);


struct kafka_params {
	const char *name;
	const char *val;
};

/* Module static data */
static struct configSettings_s {
	uchar *topic;
	uchar *consumergroup;
	char *brokers;
	uchar *pszBindRuleset;
	int nConfParams;
	struct kafka_params *confParams;
} cs;

struct instanceConf_s {
	uchar *topic;
	uchar *consumergroup;
	char *brokers;
	int64_t offset;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	uchar *pszBindRuleset;		/* default name of Ruleset to bind to */
	int bReportErrs;
	int nConfParams;
	struct kafka_params *confParams;
	int bIsConnected;
	rd_kafka_conf_t *conf;
	rd_kafka_t *rk;
	rd_kafka_topic_conf_t *topic_conf;
	int partition;
	int bIsSubscribed;
	int nMsgParsingFlags;

	struct instanceConf_s *next;
};


struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	uchar *topic;
	uchar *consumergroup;
	char *brokers;
	instanceConf_t *root, *tail;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	uchar *pszBindRuleset;		/* default name of Ruleset to bind to */
};

/* global data */
pthread_attr_t wrkrThrdAttr;	/* Attribute for worker threads ; read only after startup */
static int activeKafkaworkers = 0;
/* The following structure controls the worker threads. Global data is
 * needed for their access.
 */
static struct kafkaWrkrInfo_s {
	pthread_t tid;		/* the worker's thread ID */
	instanceConf_t *inst;	/* Pointer to imkafka instance */
} *kafkaWrkrInfo;

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

static prop_t *pInputName = NULL;
/* there is only one global inputName for all messages generated by this input */
<a name="0"></a>
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "ruleset", eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ "topic", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "broker", eCmdHdlrArray, 0 },
	{ "confparam", eCmdHdlrArray, 0 },
	{ "consumergroup", eCmdHdlrString, 0},
	{ "ruleset", eCmdHdlrString, 0 },
	{ "parsehostname", eCmdHdlrBinary, 0 },</b></font>
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

#include "im-helper.h" /* must be included AFTER the type definitions! */

/* ------------------------------ callbacks ------------------------------ */




/* ------------------------------ end callbacks ------------------------------ */

static void
kafkaLogger(const rd_kafka_t __attribute__((unused)) *rk, int level,
	    const char *fac, const char *buf)
{
	DBGPRINTF("imkafka: kafka log message [%d,%s]: %s\n",
		  level, fac, buf);
}


/* enqueue the kafka message. The provided string is
 * not freed - thuis must be done by the caller.
 */
static rsRetVal enqMsg(instanceConf_t *const __restrict__ inst,
			rd_kafka_message_t *const __restrict__ rkmessage)
{
	DEFiRet;
	smsg_t *pMsg;

	if((int)rkmessage-&gt;len == 0) {
		/* we do not process empty lines */
		FINALIZE;
	}

DBGPRINTF("imkafka: enqMsg: Msg: %.*s\n", (int)rkmessage-&gt;len, (char *)rkmessage-&gt;payload);

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, (char*)rkmessage-&gt;payload, (int)rkmessage-&gt;len);
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	pMsg-&gt;msgFlags  = inst-&gt;nMsgParsingFlags;
	/* Optional Fields */
	if (rkmessage-&gt;key_len) {
		DBGPRINTF("imkafka: enqMsg: Key: %.*s\n", (int)rkmessage-&gt;key_len, (char *)rkmessage-&gt;key);
		MsgSetTAG(pMsg, (const uchar *)rkmessage-&gt;key, (int)rkmessage-&gt;key_len);
	}
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */

	CHKiRet(submitMsg2(pMsg));

finalize_it:
	RETiRet;
}

/**
 * Handle Kafka Consumer Loop until all msgs are processed
 */
static void msgConsume (instanceConf_t *inst) {
	rd_kafka_message_t *rkmessage = NULL;

	do { /* Consume messages */
		rkmessage = rd_kafka_consumer_poll(inst-&gt;rk, 1000); /* Block for 1000 ms max */
		if(rkmessage == NULL) {
			DBGPRINTF("imkafka: msgConsume EMPTY Loop on %s/%s/%s\n",
				inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
			goto done;
		}

		if (rkmessage-&gt;err) {
			if (rkmessage-&gt;err == RD_KAFKA_RESP_ERR__PARTITION_EOF) {
				/* not an error, just a regular status! */
				DBGPRINTF("imkafka: Consumer "
					"reached end of topic \"%s\" [%"PRId32"]"
					"message queue offset %"PRId64"\n",
					rd_kafka_topic_name(rkmessage-&gt;rkt),
					rkmessage-&gt;partition,
					rkmessage-&gt;offset);
				goto done;
			}
			if (rkmessage-&gt;rkt) {
				LogError(0, RS_RET_KAFKA_ERROR,
				"imkafka: Consumer error for topic \"%s\" [%"PRId32"]"
				"message queue offset %"PRId64": %s\n",
					rd_kafka_topic_name(rkmessage-&gt;rkt),
					rkmessage-&gt;partition,
					rkmessage-&gt;offset,
					rd_kafka_message_errstr(rkmessage));
			} else {
				LogError(0, RS_RET_KAFKA_ERROR,
					"imkafka: Consumer error for topic \"%s\": \"%s\"\n",
					rd_kafka_err2str(rkmessage-&gt;err),
					rd_kafka_message_errstr(rkmessage));
			}
			goto done;
		}

		DBGPRINTF("imkafka: msgConsume Loop on %s/%s/%s: [%"PRId32"], "
					"offset %"PRId64", %zd bytes):\n",
					rd_kafka_topic_name(rkmessage-&gt;rkt) /*inst-&gt;topic*/,
					inst-&gt;consumergroup,
					inst-&gt;brokers,
					rkmessage-&gt;partition,
					rkmessage-&gt;offset,
					rkmessage-&gt;len);
		enqMsg(inst, rkmessage);
		/* Destroy message and continue */
		rd_kafka_message_destroy(rkmessage);
		rkmessage = NULL;
	} while(1); /* loop broken inside */
done:
	/* Destroy message in case rkmessage-&gt;err was set */
	if(rkmessage != NULL) {
		rd_kafka_message_destroy(rkmessage);
	}
	return;
}



<a name="5"></a>/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;

	inst-&gt;brokers = NULL;
	inst-&gt;topic = NULL;
	inst-&gt;consumergroup = NULL;
	inst-&gt;pszBindRuleset = NULL;</b></font>
	inst-&gt;nConfParams = 0;
	inst-&gt;confParams = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;bReportErrs = 1; /* Fixed for now */
	inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
	inst-&gt;bIsConnected = 0;
	inst-&gt;bIsSubscribed = 0;
	/* Kafka objects */
	inst-&gt;conf = NULL;
	inst-&gt;rk = NULL;
	inst-&gt;topic_conf = NULL;
<a name="3"></a>	inst-&gt;partition = RD_KAFKA_PARTITION_UA;

	/* node created, let's add to config */
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}

/* this function checks instance parameters and does some required pre-processing
 */
static rsRetVal ATTR_NONNULL()</b></font>
checkInstance(instanceConf_t *const inst)
{
	DEFiRet;
	char kafkaErrMsg[1024];

	/* main kafka conf */
	inst-&gt;conf = rd_kafka_conf_new();
	if(inst-&gt;conf == NULL) {
		if(inst-&gt;bReportErrs) {
			LogError(0, RS_RET_KAFKA_ERROR,
				"imkafka: error creating kafka conf obj: %s\n",
				rd_kafka_err2str(rd_kafka_last_error()));
		}
		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
	}

#	ifdef DEBUG
	/* enable kafka debug output */
	if(rd_kafka_conf_set(inst-&gt;conf, "debug", RD_KAFKA_DEBUG_CONTEXTS,
		kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
		LogError(0, RS_RET_KAFKA_ERROR, "imkafka: error setting kafka debug option: %s\n", kafkaErrMsg);
		/* DO NOT ABORT IN THIS CASE! */
	}
#	endif

	/* Set custom configuration parameters */
	for(int i = 0 ; i &lt; inst-&gt;nConfParams ; ++i) {
		assert(inst-&gt;confParams+i != NULL); /* invariant: nConfParams MUST exist! */
		DBGPRINTF("imkafka: setting custom configuration parameter: %s:%s\n",
			inst-&gt;confParams[i].name,
			inst-&gt;confParams[i].val);
		if(rd_kafka_conf_set(inst-&gt;conf,
			inst-&gt;confParams[i].name,
			inst-&gt;confParams[i].val,
			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_PARAM_ERROR, "error setting custom configuration "
					"parameter '%s=%s': %s",
					inst-&gt;confParams[i].name,
					inst-&gt;confParams[i].val, kafkaErrMsg);
			} else {
				DBGPRINTF("imkafka: error setting custom configuration parameter '%s=%s': %s",
					inst-&gt;confParams[i].name,
					inst-&gt;confParams[i].val, kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_PARAM_ERROR);
		}
	}

	/* Topic configuration */
	inst-&gt;topic_conf = rd_kafka_topic_conf_new();

	/* Assign kafka group id */
	if (inst-&gt;consumergroup != NULL) {
		DBGPRINTF("imkafka: setting consumergroup: '%s'\n", inst-&gt;consumergroup);
		if (rd_kafka_conf_set(inst-&gt;conf, "group.id", (char*) inst-&gt;consumergroup,
			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_KAFKA_ERROR,
					"imkafka: error assigning consumergroup %s to "
					"kafka config: %s\n", inst-&gt;consumergroup,
					kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
		}


		/* Set default for auto offset reset */
		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, "auto.offset.reset",
			"smallest", kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_KAFKA_ERROR,
					"imkafka: error setting kafka auto.offset.reset on %s: %s\n",
					inst-&gt;consumergroup,
					kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
		}
		/* Consumer groups always use broker based offset storage */
		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, "offset.store.method",
			"broker", kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_KAFKA_ERROR,
					"imkafka: error setting kafka offset.store.method on %s: %s\n",
					inst-&gt;consumergroup,
					kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
		}

		/* Set default topic config for pattern-matched topics. */
		rd_kafka_conf_set_default_topic_conf(inst-&gt;conf, inst-&gt;topic_conf);
	}

	#if RD_KAFKA_VERSION &gt;= 0x00090001
		rd_kafka_conf_set_log_cb(inst-&gt;conf, kafkaLogger);
	#endif

	/* Create Kafka Consumer */
	inst-&gt;rk = rd_kafka_new(RD_KAFKA_CONSUMER, inst-&gt;conf,
				     kafkaErrMsg, sizeof(kafkaErrMsg));
	if(inst-&gt;rk == NULL) {
		if(inst-&gt;bReportErrs) {
			LogError(0, RS_RET_KAFKA_ERROR,
				"imkafka: error creating kafka handle: %s\n", kafkaErrMsg);
		}
		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
	}
	#if RD_KAFKA_VERSION &lt; 0x00090001
		rd_kafka_set_logger(inst-&gt;rk, kafkaLogger);
	#endif

	DBGPRINTF("imkafka: setting brokers: '%s'\n", inst-&gt;brokers);
	if(rd_kafka_brokers_add(inst-&gt;rk, (char*)inst-&gt;brokers) == 0) {
		if(inst-&gt;bReportErrs) {
			LogError(0, RS_RET_KAFKA_NO_VALID_BROKERS,
				"imkafka: no valid brokers specified: %s", inst-&gt;brokers);
		}
		ABORT_FINALIZE(RS_RET_KAFKA_NO_VALID_BROKERS);
	}

	/* Kafka Consumer is opened */
	inst-&gt;bIsConnected = 1;

finalize_it:
	if(iRet != RS_RET_OK) {
		if(inst-&gt;rk == NULL) {
			if(inst-&gt;conf != NULL) {
				rd_kafka_conf_destroy(inst-&gt;conf);
				inst-&gt;conf = NULL;
			}
		} else { /* inst-&gt;rk != NULL ! */
			rd_kafka_destroy(inst-&gt;rk);
			inst-&gt;rk = NULL;
		}
	}

	RETiRet;
}

/* function to generate an error message if the ruleset cannot be found */
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	if(inst-&gt;bReportErrs) {
		LogError(0, NO_ERRCODE, "imkafka: ruleset '%s' not found - "
			"using default ruleset instead",
			inst-&gt;pszBindRuleset);
	}
}


static rsRetVal ATTR_NONNULL(2)
addConsumer(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
{
	DEFiRet;
	rd_kafka_resp_err_t err;

	assert(inst != NULL);

	rd_kafka_topic_partition_list_t *topics = NULL;
	DBGPRINTF("imkafka: creating kafka consumer on %s/%s/%s\n",
		inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);

	/* Redirect rd_kafka_poll() to consumer_poll() */
	rd_kafka_poll_set_consumer(inst-&gt;rk);

	topics = rd_kafka_topic_partition_list_new(1);
	rd_kafka_topic_partition_list_add(topics, (const char*)inst-&gt;topic, inst-&gt;partition);
	DBGPRINTF("imkafka: Created topics(%d) for %s)\n",
		topics-&gt;cnt, inst-&gt;topic);
	if ((err = rd_kafka_subscribe(inst-&gt;rk, topics))) {
		/* Subscription failed */
		inst-&gt;bIsSubscribed = 0;
		LogError(0, RS_RET_KAFKA_ERROR, "imkafka: Failed to start consuming "
			"topics: %s\n", rd_kafka_err2str(err));
		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
	} else {
		DBGPRINTF("imkafka: Successfully subscribed to %s/%s/%s\n",
			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
		/* Subscription is working */
		inst-&gt;bIsSubscribed = 1;
	}
finalize_it:
	if(topics != NULL)
		rd_kafka_topic_partition_list_destroy(topics);
	RETiRet;
}

static rsRetVal ATTR_NONNULL()
processKafkaParam(char *const param,
	const char **const name,
	const char **const paramval)
{
	DEFiRet;
	char *val = strstr(param, "=");
	if(val == NULL) {
		LogError(0, RS_RET_PARAM_ERROR, "missing equal sign in "
				"parameter '%s'", param);
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	*val = '\0'; /* terminates name */
	++val; /* now points to begin of value */
	CHKmalloc(*name = strdup(param));
	CHKmalloc(*paramval = strdup(val));
finalize_it:
	RETiRet;
}

BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
<a name="2"></a>CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imkafka)\n");

<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("input param blk in imkafka:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));

	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "broker")) {
			es_str_t *es = es_newStr(128);</b></font>
			int bNeedComma = 0;
			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				if(bNeedComma)
					es_addChar(&amp;es, ',');
				es_addStr(&amp;es, pvals[i].val.d.ar-&gt;arr[j]);
				bNeedComma = 1;
			}
			inst-&gt;brokers = es_str2cstr(es, NULL);
			es_deleteStr(es);
		} else if(!strcmp(inppblk.descr[i].name, "confparam")) {
			inst-&gt;nConfParams = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(inst-&gt;confParams = malloc(sizeof(struct kafka_params)*inst-&gt;nConfParams));
			for(int j = 0; j &lt; inst-&gt;nConfParams; j++) {
				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				CHKiRet(processKafkaParam(cstr, &amp;inst-&gt;confParams[j].name,
								&amp;inst-&gt;confParams[j].val));
				free(cstr);
			}
		} else if(!strcmp(inppblk.descr[i].name, "topic")) {
			inst-&gt;topic = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "consumergroup")) {
<a name="4"></a>			inst-&gt;consumergroup = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "parsehostname")) {
			if (pvals[i].val.d.n) {
				inst-&gt;nMsgParsingFlags = NEEDS_PARSING | PARSE_HOSTNAME;
			} else {
				inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
			}
		} else {</b></font>
			dbgprintf("imkafka: program error, non-handled "
			  "param '%s'\n", inppblk.descr[i].name);
		}
	}

	if(inst-&gt;brokers == NULL) {
		CHKmalloc(inst-&gt;brokers = strdup("localhost:9092"));
		LogMsg(0, NO_ERRCODE, LOG_INFO, "imkafka: \"broker\" parameter not specified "
			"using default of localhost:9092 -- this may not be what you want!");
	}

	DBGPRINTF("imkafka: newInpIns brokers=%s, topic=%s, consumergroup=%s\n",
		inst-&gt;brokers, inst-&gt;topic, inst-&gt;consumergroup);

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst


BEGINbeginCnfLoad
<a name="1"></a>CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pModConf-&gt;pszBindRuleset = NULL;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imkafka: error processing module "
			"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for imkafka:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "ruleset")) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else {
			dbgprintf("imkafka: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	if(loadModConf-&gt;pszBindRuleset == NULL) {
		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
			loadModConf-&gt;pszBindRuleset = NULL;
		} else {
			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
		}
	}
finalize_it:
	free(cs.pszBindRuleset);
	cs.pszBindRuleset = NULL;
	loadModConf = NULL; /* done loading */
ENDendCnfLoad

BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
		}
		std_checkRuleset(pModConf, inst);
	}
finalize_it:
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
ENDactivateCnfPrePrivDrop

BEGINactivateCnf
CODESTARTactivateCnf
	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		iRet = checkInstance(inst);
	}
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;topic);
		free(inst-&gt;consumergroup);
		free(inst-&gt;brokers);
		free(inst-&gt;pszBindRuleset);
		for(int i = 0; i &lt; inst-&gt;nConfParams; i++) {
			free((void*)inst-&gt;confParams[i].name);
			free((void*)inst-&gt;confParams[i].val);
		}
		free((void*)inst-&gt;confParams);
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
	free(pModConf-&gt;pszBindRuleset);
ENDfreeCnf


/* Cleanup imkafka worker threads */
static void
shutdownKafkaWorkers(void)
{
	int i;
	instanceConf_t *inst;

	assert(kafkaWrkrInfo != NULL);

	DBGPRINTF("imkafka: waiting on imkafka workerthread termination\n");
	for(i = 0 ; i &lt; activeKafkaworkers ; ++i) {
		pthread_join(kafkaWrkrInfo[i].tid, NULL);
		DBGPRINTF("imkafka: Stopped worker %d\n", i);
	}
	free(kafkaWrkrInfo);
	kafkaWrkrInfo = NULL;

	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		DBGPRINTF("imkafka: stop consuming %s/%s/%s\n",
			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
		rd_kafka_consumer_close(inst-&gt;rk); /* Close the consumer, committing final offsets, etc. */
		rd_kafka_destroy(inst-&gt;rk); /* Destroy handle object */
		DBGPRINTF("imkafka: stopped consuming %s/%s/%s\n",
			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);

		#if RD_KAFKA_VERSION &lt; 0x00090001
		/* Wait for kafka being destroyed in old API */
		if (rd_kafka_wait_destroyed(10000) &lt; 0)	{
			DBGPRINTF("imkafka: error, rd_kafka_destroy did not finish after grace "
				"timeout (10s)!\n");
		} else {
			DBGPRINTF("imkafka: rd_kafka_destroy successfully finished\n");
		}
		#endif
	}
}


/* This function is called to gather input.  */
BEGINrunInput
	int i;
	instanceConf_t *inst;
CODESTARTrunInput
	DBGPRINTF("imkafka: runInput loop started ...\n");
	activeKafkaworkers = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if(inst-&gt;rk != NULL) {
			++activeKafkaworkers;
		}
	}

	if(activeKafkaworkers == 0) {
		LogError(0, RS_RET_ERR, "imkafka: no active inputs, input does "
			"not run - there should have been additional error "
			"messages given previously");
		ABORT_FINALIZE(RS_RET_ERR);
	}


	DBGPRINTF("imkafka: Starting %d imkafka workerthreads\n", activeKafkaworkers);
	kafkaWrkrInfo = calloc(activeKafkaworkers, sizeof(struct kafkaWrkrInfo_s));
	if (kafkaWrkrInfo == NULL) {
		LogError(errno, RS_RET_OUT_OF_MEMORY, "imkafka: worker-info array allocation failed.");
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}

	/* Start worker threads for each imkafka input source
	*/
	i = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		/* init worker info structure! */
		kafkaWrkrInfo[i].inst = inst; /* Set reference pointer */
		pthread_create(&amp;kafkaWrkrInfo[i].tid, &amp;wrkrThrdAttr, imkafkawrkr, &amp;(kafkaWrkrInfo[i]));
		i++;
	}

	while(glbl.GetGlobalInputTermState() == 0) {

		/* Note: the additional 10000ns wait is vitally important. It guards rsyslog
		 * against totally hogging the CPU if the users selects a polling interval
		 * of 0 seconds. It doesn't hurt any other valid scenario. So do not remove.
		 */
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(0, 100000);
	}
	DBGPRINTF("imkafka: terminating upon request of rsyslog core\n");

	/* we need to shutdown kafak worker threads here because this operation can
	 * potentially block (e.g. when no kafka broker is available!). If this
	 * happens in runInput, the rsyslog core can cancel our thread. However,
	 * in afterRun this is not possible, because the core does not assume it
	 * can block there. -- rgerhards, 2018-10-23
	 */
	shutdownKafkaWorkers();
finalize_it:
ENDrunInput


BEGINwillRun
CODESTARTwillRun
	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imkafka"), sizeof("imkafka") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun


BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);

ENDafterRun


BEGINmodExit
CODESTARTmodExit
	pthread_attr_destroy(&amp;wrkrThrdAttr);
	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	/* request objects we use */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	/* initialize "read-only" thread attributes */
	pthread_attr_init(&amp;wrkrThrdAttr);
	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);

	DBGPRINTF("imkafka %s using librdkafka version %s, 0x%x\n",
		VERSION, rd_kafka_version_str(), rd_kafka_version());
ENDmodInit

/*
*	Workerthread function for a single kafka consomer
 */
static void *
imkafkawrkr(void *myself)
{
	struct kafkaWrkrInfo_s *me = (struct kafkaWrkrInfo_s*) myself;
	DBGPRINTF("imkafka: started kafka consumer workerthread on %s/%s/%s\n",
		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);

	do {
		if(glbl.GetGlobalInputTermState() == 1)
			break; /* terminate input! */

		if(me-&gt;inst-&gt;rk == NULL) {
			continue;
		}

		// Try to add consumer only if connected! */
		if(me-&gt;inst-&gt;bIsConnected == 1 &amp;&amp; me-&gt;inst-&gt;bIsSubscribed == 0 ) {
			addConsumer(runModConf, me-&gt;inst);
		}
		if(me-&gt;inst-&gt;bIsSubscribed == 1 ) {
			msgConsume(me-&gt;inst);
		}
		/* Note: the additional 10000ns wait is vitally important. It guards rsyslog
		 * against totally hogging the CPU if the users selects a polling interval
		 * of 0 seconds. It doesn't hurt any other valid scenario. So do not remove.
		 * rgerhards, 2008-02-14
		 */
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(0, 100000);
	} while(glbl.GetGlobalInputTermState() == 0);

	DBGPRINTF("imkafka: stopped kafka consumer workerthread on %s/%s/%s\n",
		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
	return NULL;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imuxsock.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* imuxsock.c
 * This is the implementation of the Unix sockets input module.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * File begun on 2007-12-20 by RGerhards (extracted from syslogd.c)
 *
 * Copyright 2007-2019 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Rsyslog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rsyslog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rsyslog.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file "COPYING" in this distribution.
 */
#ifdef __sun
#define _XPG4_2
#endif
#include "config.h"
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;poll.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;sys/socket.h&gt;
#ifdef HAVE_LIBSYSTEMD
#	include &lt;systemd/sd-daemon.h&gt;
#endif
#if defined(__FreeBSD__)
	#include &lt;sys/param.h&gt;
#endif
#include "rsyslog.h"
#include "dirty.h"
#include "cfsysline.h"
#include "unicode-helper.h"
#include "module-template.h"
#include "srUtils.h"
#include "errmsg.h"
#include "net.h"
#include "glbl.h"
#include "msg.h"
#include "parser.h"
#include "prop.h"
#include "debug.h"
#include "ruleset.h"
#include "unlimited_select.h"
#include "statsobj.h"
#include "datetime.h"
#include "hashtable.h"
#include "ratelimit.h"


MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imuxsock")

/* defines */
#ifndef _PATH_LOG
#ifdef BSD
#define _PATH_LOG	"/var/run/log"
#else
#define _PATH_LOG	"/dev/log"
#endif
#endif
#ifndef SYSTEMD_JOURNAL
#define SYSTEMD_JOURNAL  "/run/systemd/journal"
#endif
#ifndef SYSTEMD_PATH_LOG
#define SYSTEMD_PATH_LOG SYSTEMD_JOURNAL "/syslog"
#endif
#define UNSET -1 /* to indicate a value has not been configured */

/* forward definitions */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

#if defined(_AIX)
#define ucred  ucred_t
#endif
/* emulate struct ucred for platforms that do not have it */
#ifndef HAVE_SCM_CREDENTIALS
struct ucred { int pid; uid_t uid; gid_t gid; };
#endif

/* handle some defines missing on more than one platform */
#ifndef SUN_LEN
#define SUN_LEN(su) \
	(sizeof(*(su)) - sizeof((su)-&gt;sun_path) + strlen((su)-&gt;sun_path))
#endif
/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(net)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(ruleset)


statsobj_t *modStats;
STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
STATSCOUNTER_DEF(ctrLostRatelimit, mutCtrLostRatelimit)
STATSCOUNTER_DEF(ctrNumRatelimiters, mutCtrNumRatelimiters)


/* a very simple "hash function" for process IDs - we simply use the
 * pid itself: it is quite expected that all pids may log some time, but
 * from a collision point of view it is likely that long-running daemons
 * start early and so will stay right in the top spots of the
 * collision list.
 */
static unsigned int
hash_from_key_fn(void *k)
{
	return((unsigned) *((pid_t*) k));
}

static int
key_equals_fn(void *key1, void *key2)
{
	return *((pid_t*) key1) == *((pid_t*) key2);
}


/* structure to describe a specific listener */
typedef struct lstn_s {
	uchar *sockName;	/* read-only after startup */
	prop_t *hostName;	/* host-name override - if set, use this instead of actual name */
	int fd;			/* read-only after startup */
	int flags;		/* should parser parse host name?  read-only after startup */
	int flowCtl;		/* flow control settings for this socket */
	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	ratelimit_t *dflt_ratelimiter;/*ratelimiter to apply if none else is to be used */
	intTiny ratelimitSev;	/* severity level (and below) for which rate-limiting shall apply */
	struct hashtable *ht;	/* our hashtable for rate-limiting */
	sbool bParseHost;	/* should parser parse host name?  read-only after startup */
	sbool bCreatePath;	/* auto-creation of socket directory? */
	sbool bUseCreds;	/* pull original creator credentials from socket */
	sbool bAnnotate;	/* annotate events with trusted properties */
	sbool bParseTrusted;	/* parse trusted properties */
	sbool bWritePid;	/* write original PID into tag */
	sbool bDiscardOwnMsgs;	/* discard messages that originated from ourselves */
	sbool bUseSysTimeStamp;	/* use timestamp from system (instead of from message) */
	sbool bUnlink;		/* unlink&amp;re-create socket at start and end of processing */
	sbool bUseSpecialParser;/* use "canned" log socket parser instead of parser chain? */
	ruleset_t *pRuleset;
} lstn_t;
static lstn_t *listeners;

static prop_t *pLocalHostIP = NULL;	/* there is only one global IP for all internally-generated messages */
static prop_t *pInputName = NULL;	/* our inputName currently is always "imuxsock", and this will hold it */
static int startIndexUxLocalSockets; /* process fd from that index on (used to
				* suppress local logging. rgerhards 2005-08-01
				* read-only after startup
				*/
static int nfd = 1; /* number of active unix sockets  (socket 0 is always reserved for the system
			socket, even if it is not enabled. */
static int sd_fds = 0;			/* number of systemd activated sockets */

#if (defined(__FreeBSD__) &amp;&amp; (__FreeBSD_version &gt;= 1200061))
	#define DFLT_bUseSpecialParser 0
#else
	#define DFLT_bUseSpecialParser 1
#endif
#define DFLT_bCreatePath 0
#define DFLT_ratelimitInterval 0
#define DFLT_ratelimitBurst 200
#define DFLT_ratelimitSeverity 1			/* do not rate-limit emergency messages */
/* config vars for the legacy config system */
static struct configSettings_s {
	int bOmitLocalLogging;
	uchar *pLogSockName;
	uchar *pLogHostName;		/* host name to use with this socket */
	int bUseFlowCtl;		/* use flow control or not (if yes, only LIGHT is used!) */
	int bUseFlowCtlSysSock;
	int bIgnoreTimestamp;		/* ignore timestamps present in the incoming message? */
	int bIgnoreTimestampSysSock;
	int bUseSysTimeStamp;		/* use timestamp from system (rather than from message) */
	int bUseSysTimeStampSysSock;	/* same, for system log socket */
	int bWritePid;			/* use credentials from recvmsg() and fixup PID in TAG */
	int bWritePidSysSock;		/* use credentials from recvmsg() and fixup PID in TAG */
	int bCreatePath;		/* auto-create socket path? */
	unsigned int ratelimitInterval;		/* interval in seconds, 0 = off */
	unsigned int ratelimitIntervalSysSock;
	unsigned int ratelimitBurst;		/* max nbr of messages in interval */
	unsigned int ratelimitBurstSysSock;
	int ratelimitSeverity;
	int ratelimitSeveritySysSock;
	int bAnnotate;			/* annotate trusted properties */
	int bAnnotateSysSock;		/* same, for system log socket */
	int bParseTrusted;		/* parse trusted properties */
} cs;

/* config vars for the v2 config system (rsyslog v6+) */
struct instanceConf_s {
	uchar *sockName;
	uchar *pLogHostName;		/* host name to use with this socket */
	sbool bUseFlowCtl;		/* use flow control or not (if yes, only LIGHT is used! */
	sbool bIgnoreTimestamp;		/* ignore timestamps present in the incoming message? */
	sbool bWritePid;		/* use credentials from recvmsg() and fixup PID in TAG */
	sbool bUseSysTimeStamp;		/* use timestamp from system (instead of from message) */
	int bCreatePath;		/* auto-create socket path? */
	unsigned int ratelimitInterval;		/* interval in seconds, 0 = off */
	unsigned int ratelimitBurst;		/* max nbr of messages in interval */
	int ratelimitSeverity;
	int bAnnotate;			/* annotate trusted properties */
	int bParseTrusted;		/* parse trusted properties */
	sbool bDiscardOwnMsgs;		/* discard messages that originated from our own pid? */
	sbool bUnlink;
	sbool bUseSpecialParser;
	sbool bParseHost;
	uchar *pszBindRuleset;		/* name of ruleset to bind to */
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	struct instanceConf_s *next;
};

struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
	uchar *pLogSockName;
	unsigned int ratelimitIntervalSysSock;
	unsigned int ratelimitBurstSysSock;
	int ratelimitSeveritySysSock;
	int bAnnotateSysSock;
	int bParseTrusted;
	int bUseSpecialParser;
	int bParseHost;
	sbool bIgnoreTimestamp;		/* ignore timestamps present in the incoming message? */
	sbool bUseFlowCtl;		/* use flow control or not (if yes, only LIGHT is used! */
	sbool bOmitLocalLogging;
	sbool bWritePidSysSock;
	sbool bUseSysTimeStamp;
	sbool bDiscardOwnMsgs;
	sbool configSetViaV2Method;
	sbool bUnlink;
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ "syssock.use", eCmdHdlrBinary, 0 },
	{ "syssock.name", eCmdHdlrGetWord, 0 },
	{ "syssock.unlink", eCmdHdlrBinary, 0 },
	{ "syssock.ignoretimestamp", eCmdHdlrBinary, 0 },
	{ "syssock.ignoreownmessages", eCmdHdlrBinary, 0 },
	{ "syssock.flowcontrol", eCmdHdlrBinary, 0 },
	{ "syssock.usesystimestamp", eCmdHdlrBinary, 0 },
	{ "syssock.annotate", eCmdHdlrBinary, 0 },
	{ "syssock.parsetrusted", eCmdHdlrBinary, 0 },
	{ "syssock.usespecialparser", eCmdHdlrBinary, 0 },
	{ "syssock.parsehostname", eCmdHdlrBinary, 0 },
<a name="0"></a>	{ "syssock.usepidfromsystem", eCmdHdlrBinary, 0 },
	{ "syssock.ratelimit.interval", eCmdHdlrInt, 0 },
	{ "syssock.ratelimit.burst", eCmdHdlrInt, 0 },
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "syssock.ratelimit.severity", eCmdHdlrInt, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ "socket", eCmdHdlrString, CNFPARAM_REQUIRED }, /* legacy: addunixlistensocket */
	{ "unlink", eCmdHdlrBinary, 0 },
	{ "createpath", eCmdHdlrBinary, 0 },
	{ "parsetrusted", eCmdHdlrBinary, 0 },
	{ "ignoreownmessages", eCmdHdlrBinary, 0 },
	{ "hostname", eCmdHdlrString, 0 },</b></font>
	{ "ignoretimestamp", eCmdHdlrBinary, 0 },
	{ "flowcontrol", eCmdHdlrBinary, 0 },
	{ "usesystimestamp", eCmdHdlrBinary, 0 },
	{ "annotate", eCmdHdlrBinary, 0 },
	{ "usespecialparser", eCmdHdlrBinary, 0 },
	{ "parsehostname", eCmdHdlrBinary, 0 },
	{ "usepidfromsystem", eCmdHdlrBinary, 0 },
	{ "ruleset", eCmdHdlrString, 0 },
	{ "ratelimit.interval", eCmdHdlrInt, 0 },
	{ "ratelimit.burst", eCmdHdlrInt, 0 },
	{ "ratelimit.severity", eCmdHdlrInt, 0 }
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

#include "im-helper.h" /* must be included AFTER the type definitions! */

static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */


<a name="5"></a>/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;sockName = NULL;
	inst-&gt;pLogHostName = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;ratelimitInterval = DFLT_ratelimitInterval;</b></font>
	inst-&gt;ratelimitBurst = DFLT_ratelimitBurst;
	inst-&gt;ratelimitSeverity = DFLT_ratelimitSeverity;
	inst-&gt;bUseFlowCtl = 0;
	inst-&gt;bUseSpecialParser = DFLT_bUseSpecialParser;
	inst-&gt;bParseHost = UNSET;
	inst-&gt;bIgnoreTimestamp = 1;
	inst-&gt;bCreatePath = DFLT_bCreatePath;
	inst-&gt;bUseSysTimeStamp = 1;
	inst-&gt;bWritePid = 0;
	inst-&gt;bAnnotate = 0;
	inst-&gt;bParseTrusted = 0;
	inst-&gt;bDiscardOwnMsgs = loadModConf-&gt;pConf-&gt;globals.bProcessInternalMessages;
	inst-&gt;bUnlink = 1;
<a name="3"></a>	inst-&gt;next = NULL;

	/* node created, let's add to config */
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}


/* This function is called when a new listen socket instance shall be added to
 * the current config object via the legacy config system. It just shuffles
 * all parameters to the listener in-memory instance.
 * rgerhards, 2011-05-12
 */
static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)</b></font>
{
	instanceConf_t *inst;
	DEFiRet;

	if(pNewVal == NULL || pNewVal[0] == '\0') {
		LogError(0, RS_RET_SOCKNAME_MISSING , "imuxsock: socket name must be specified, "
			        "but is not - listener not created\n");
		if(pNewVal != NULL)
			free(pNewVal);
		ABORT_FINALIZE(RS_RET_SOCKNAME_MISSING);
	}

	CHKiRet(createInstance(&amp;inst));
	inst-&gt;sockName = pNewVal;
	inst-&gt;ratelimitInterval = cs.ratelimitInterval;
	inst-&gt;pLogHostName = cs.pLogHostName;
	inst-&gt;ratelimitBurst = cs.ratelimitBurst;
	inst-&gt;ratelimitSeverity = cs.ratelimitSeverity;
	inst-&gt;bUseFlowCtl = cs.bUseFlowCtl;
	inst-&gt;bIgnoreTimestamp = cs.bIgnoreTimestamp;
	inst-&gt;bCreatePath = cs.bCreatePath;
	inst-&gt;bUseSysTimeStamp = cs.bUseSysTimeStamp;
	inst-&gt;bWritePid = cs.bWritePid;
	inst-&gt;bAnnotate = cs.bAnnotate;
	inst-&gt;bParseTrusted = cs.bParseTrusted;
	inst-&gt;bParseHost = UNSET;
	inst-&gt;next = NULL;

	/* reset hostname for next socket */
	cs.pLogHostName = NULL;

finalize_it:
	RETiRet;
}


/* add an additional listen socket.
 * added capability to specify hostname for socket -- rgerhards, 2008-08-01
 */
static rsRetVal
addListner(instanceConf_t *inst)
<a name="4"></a>{
	DEFiRet;

<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(inst-&gt;bParseHost == UNSET) {
		if(*inst-&gt;sockName == ':') {
			listeners[nfd].bParseHost = 1;
		} else {
			listeners[nfd].bParseHost = 0;
		}
	} else {</b></font>
		listeners[nfd].bParseHost = inst-&gt;bParseHost;
	}
	if(inst-&gt;pLogHostName == NULL) {
		listeners[nfd].hostName = NULL;
	} else {
		CHKiRet(prop.Construct(&amp;(listeners[nfd].hostName)));
		CHKiRet(prop.SetString(listeners[nfd].hostName, inst-&gt;pLogHostName, ustrlen(inst-&gt;pLogHostName)));
		CHKiRet(prop.ConstructFinalize(listeners[nfd].hostName));
	}
	if(inst-&gt;ratelimitInterval &gt; 0) {
		if((listeners[nfd].ht = create_hashtable(100, hash_from_key_fn, key_equals_fn,
			(void(*)(void*))ratelimitDestruct)) == NULL) {
			/* in this case, we simply turn off rate-limiting */
			DBGPRINTF("imuxsock: turning off rate limiting because we could not "
				  "create hash table\n");
			inst-&gt;ratelimitInterval = 0;
		}
	} else {
		listeners[nfd].ht = NULL;
	}
	listeners[nfd].ratelimitInterval = inst-&gt;ratelimitInterval;
	listeners[nfd].ratelimitBurst = inst-&gt;ratelimitBurst;
	listeners[nfd].ratelimitSev = inst-&gt;ratelimitSeverity;
	listeners[nfd].flowCtl = inst-&gt;bUseFlowCtl ? eFLOWCTL_LIGHT_DELAY : eFLOWCTL_NO_DELAY;
	listeners[nfd].flags = inst-&gt;bIgnoreTimestamp ? IGNDATE : NOFLAG;
	listeners[nfd].bCreatePath = inst-&gt;bCreatePath;
	listeners[nfd].sockName = ustrdup(inst-&gt;sockName);
	listeners[nfd].bUseCreds = (inst-&gt;bDiscardOwnMsgs || inst-&gt;bWritePid || inst-&gt;ratelimitInterval
	|| inst-&gt;bAnnotate || inst-&gt;bUseSysTimeStamp) ? 1 : 0;
	listeners[nfd].bAnnotate = inst-&gt;bAnnotate;
	listeners[nfd].bParseTrusted = inst-&gt;bParseTrusted;
	listeners[nfd].bDiscardOwnMsgs = inst-&gt;bDiscardOwnMsgs;
	listeners[nfd].bUnlink = inst-&gt;bUnlink;
	listeners[nfd].bWritePid = inst-&gt;bWritePid;
	listeners[nfd].bUseSysTimeStamp = inst-&gt;bUseSysTimeStamp;
	listeners[nfd].bUseSpecialParser = inst-&gt;bUseSpecialParser;
	listeners[nfd].pRuleset = inst-&gt;pBindRuleset;
	CHKiRet(ratelimitNew(&amp;listeners[nfd].dflt_ratelimiter, "imuxsock", NULL));
	ratelimitSetLinuxLike(listeners[nfd].dflt_ratelimiter,
			      listeners[nfd].ratelimitInterval,
			      listeners[nfd].ratelimitBurst);
	ratelimitSetSeverity(listeners[nfd].dflt_ratelimiter,
			     listeners[nfd].ratelimitSev);
	nfd++;

finalize_it:
	RETiRet;
}


static rsRetVal discardLogSockets(void)
{
	int i;

	/* Check whether the system socket is in use */
	if(startIndexUxLocalSockets == 0) {
		/* Clean up rate limiting data for the system socket */
		if(listeners[0].ht != NULL) {
			hashtable_destroy(listeners[0].ht, 1); /* 1 =&gt; free all values automatically */
		}
		ratelimitDestruct(listeners[0].dflt_ratelimiter);
	}

	/* Clean up all other sockets */
	for (i = 1; i &lt; nfd; i++) {
		if(listeners[i].sockName != NULL) {
			free(listeners[i].sockName);
			listeners[i].sockName = NULL;
		}
		if(listeners[i].hostName != NULL) {
			prop.Destruct(&amp;(listeners[i].hostName));
		}
		if(listeners[i].ht != NULL) {
			hashtable_destroy(listeners[i].ht, 1); /* 1 =&gt; free all values automatically */
		}
		ratelimitDestruct(listeners[i].dflt_ratelimiter);
	}

	return RS_RET_OK;
}


/* used to create a log socket if NOT passed in via systemd.
 */
/* note: the linux SUN_LEN macro uses a sizeof based on a NULL pointer. This
 * triggers UBSan warning. As such, we turn that warning off for the fuction.
 * As it is OS-provided, there is no way to solve it ourselves. The problem
 * may also exist on other platforms, we have just noticed it on Linux.
 */
#if defined(__clang__)
#pragma GCC diagnostic ignored "-Wunknown-attributes"
#endif
static rsRetVal
#if defined(__clang__)
__attribute__((no_sanitize("undefined")))
#endif
createLogSocket(lstn_t *pLstn)
{
	struct sockaddr_un sunx;
	DEFiRet;

	if(pLstn-&gt;bUnlink)
		unlink((char*)pLstn-&gt;sockName);
	memset(&amp;sunx, 0, sizeof(sunx));
	sunx.sun_family = AF_UNIX;
	if(pLstn-&gt;bCreatePath) {
		makeFileParentDirs((uchar*)pLstn-&gt;sockName, ustrlen(pLstn-&gt;sockName), 0755, -1, -1, 0);
	}
	strncpy(sunx.sun_path, (char*)pLstn-&gt;sockName, sizeof(sunx.sun_path));
	sunx.sun_path[sizeof(sunx.sun_path)-1] = '\0';
	pLstn-&gt;fd = socket(AF_UNIX, SOCK_DGRAM, 0);
	if(pLstn-&gt;fd &lt; 0 ) {
		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
	}
	if(bind(pLstn-&gt;fd, (struct sockaddr *) &amp;sunx, SUN_LEN(&amp;sunx)) &lt; 0) {
		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
	}
	if(chmod((char*)pLstn-&gt;sockName, 0666) &lt; 0) {
		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
	}
finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(errno, iRet, "cannot create '%s'", pLstn-&gt;sockName);
		if(pLstn-&gt;fd != -1) {
			close(pLstn-&gt;fd);
			pLstn-&gt;fd = -1;
		}
	}
	RETiRet;
}


static rsRetVal
openLogSocket(lstn_t *pLstn)
{
	DEFiRet;
#	ifdef HAVE_SCM_CREDENTIALS
	int one;
#	endif /* HAVE_SCM_CREDENTIALS */

	if(pLstn-&gt;sockName[0] == '\0')
		return -1;

	pLstn-&gt;fd = -1;

#ifdef HAVE_LIBSYSTEMD
	if (sd_fds &gt; 0) {
		/* Check if the current socket is a systemd activated one.
		 * If so, just use it.
		 */
		int fd;

		for (fd = SD_LISTEN_FDS_START; fd &lt; SD_LISTEN_FDS_START + sd_fds; fd++) {
			if( sd_is_socket_unix(fd, SOCK_DGRAM, -1, (const char*) pLstn-&gt;sockName, 0) == 1) {
				/* ok, it matches -- just use as is */
				pLstn-&gt;fd = fd;

				LogMsg(0, NO_ERRCODE, LOG_INFO,
					"imuxsock: Acquired UNIX socket '%s' (fd %d) from systemd.\n",
					pLstn-&gt;sockName, pLstn-&gt;fd);
				break;
			}
			/*
			 * otherwise it either didn't match *this* socket and
			 * we just continue to check the next one or there was
			 * an error and we will create a new socket below.
			 */
		}
	}
#endif

	if (pLstn-&gt;fd == -1) {
		CHKiRet(createLogSocket(pLstn));
		assert(pLstn-&gt;fd != -1); /* else createLogSocket() should have failed! */
	}

#	ifdef HAVE_SCM_CREDENTIALS
	if(pLstn-&gt;bUseCreds) {
		one = 1;
		if(setsockopt(pLstn-&gt;fd, SOL_SOCKET, SO_PASSCRED, &amp;one, (socklen_t) sizeof(one)) != 0) {
			LogError(errno, NO_ERRCODE, "set SO_PASSCRED failed on '%s'", pLstn-&gt;sockName);
			pLstn-&gt;bUseCreds = 0;
		}
// TODO: move to its own #if
		if(setsockopt(pLstn-&gt;fd, SOL_SOCKET, SO_TIMESTAMP, &amp;one, sizeof(one)) != 0) {
			LogError(errno, NO_ERRCODE, "set SO_TIMESTAMP failed on '%s'", pLstn-&gt;sockName);
		}
	}
#	else /* HAVE_SCM_CREDENTIALS */
	pLstn-&gt;bUseCreds = 0;
	pLstn-&gt;bAnnotate = 0;
#	endif /* HAVE_SCM_CREDENTIALS */

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pLstn-&gt;fd != -1) {
			close(pLstn-&gt;fd);
			pLstn-&gt;fd = -1;
		}
	}

	RETiRet;
}


/* find ratelimiter to use for this message. Currently, we use the
 * pid, but may change to cgroup later (probably via a config switch).
 * Returns NULL if not found or rate-limiting not activated for this
 * listener (the latter being a performance enhancement).
 */
static rsRetVal
findRatelimiter(lstn_t *pLstn, struct ucred *cred, ratelimit_t **prl)
{
	ratelimit_t *rl = NULL;
	int r;
	pid_t *keybuf;
	char pinfobuf[512];
	DEFiRet;

	if(cred == NULL)
		FINALIZE;
#if 0 // TODO: check deactivated?
	if(pLstn-&gt;ratelimitInterval == 0) {
		*prl = NULL;
		FINALIZE;
	}
#endif
	if(pLstn-&gt;ht == NULL) {
		*prl = NULL;
		FINALIZE;
	}

	rl = hashtable_search(pLstn-&gt;ht, &amp;cred-&gt;pid);
	if(rl == NULL) {
		/* we need to add a new ratelimiter, process not seen before! */
		DBGPRINTF("imuxsock: no ratelimiter for pid %lu, creating one\n",
			  (unsigned long) cred-&gt;pid);
		STATSCOUNTER_INC(ctrNumRatelimiters, mutCtrNumRatelimiters);
		/* read process name from system  */
		char procName[256]; /* enough for any sane process name  */
		snprintf(procName, sizeof(procName), "/proc/%lu/cmdline", (unsigned long) cred-&gt;pid);
		FILE *f = fopen(procName, "r");
		if (f) {
			size_t len;
			len = fread(procName, sizeof(char), 256, f);
			if (len &gt; 0) {
				snprintf(pinfobuf, sizeof(pinfobuf), "pid: %lu, name: %s",
					(unsigned long) cred-&gt;pid, procName);
			}
			fclose(f);
		}
		else {
			snprintf(pinfobuf, sizeof(pinfobuf), "pid: %lu",
				(unsigned long) cred-&gt;pid);
		}
		pinfobuf[sizeof(pinfobuf)-1] = '\0'; /* to be on safe side */
		CHKiRet(ratelimitNew(&amp;rl, "imuxsock", pinfobuf));
		ratelimitSetLinuxLike(rl, pLstn-&gt;ratelimitInterval, pLstn-&gt;ratelimitBurst);
		ratelimitSetSeverity(rl, pLstn-&gt;ratelimitSev);
		CHKmalloc(keybuf = malloc(sizeof(pid_t)));
		*keybuf = cred-&gt;pid;
		r = hashtable_insert(pLstn-&gt;ht, keybuf, rl);
		if(r == 0)
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}

	*prl = rl;
	rl = NULL;

finalize_it:
	if(rl != NULL)
		ratelimitDestruct(rl);
	if(*prl == NULL)
		*prl = pLstn-&gt;dflt_ratelimiter;
	RETiRet;
}


/* patch correct pid into tag. bufTAG MUST be CONF_TAG_MAXSIZE long!
 */
static void
fixPID(uchar *bufTAG, int *lenTag, struct ucred *cred)
{
	int i;
	char bufPID[16];
	int lenPID;

	if(cred == NULL)
		return;

	lenPID = snprintf(bufPID, sizeof(bufPID), "[%lu]:", (unsigned long) cred-&gt;pid);

	for(i = *lenTag ; i &gt;= 0  &amp;&amp; bufTAG[i] != '[' ; --i)
		/*JUST SKIP*/;

	if(i &lt; 0)
		i = *lenTag - 1; /* go right at end of TAG, pid was not present (-1 for ':') */

	if(i + lenPID &gt; CONF_TAG_MAXSIZE)
		return; /* do not touch, as things would break */

	memcpy(bufTAG + i, bufPID, lenPID);
	*lenTag = i + lenPID;
}


/* Get an "trusted property" from the system. Returns an empty string if the
 * property can not be obtained. Inspired by similiar functionality inside
 * journald. Currently works with Linux /proc filesystem, only.
 */
static rsRetVal
getTrustedProp(struct ucred *cred, const char *propName, uchar *buf, size_t lenBuf, int *lenProp)
{
	int fd;
	int i;
	int lenRead;
	char namebuf[1024];
	DEFiRet;

	if(snprintf(namebuf, sizeof(namebuf), "/proc/%lu/%s", (long unsigned) cred-&gt;pid,
		propName) &gt;= (int) sizeof(namebuf)) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	if((fd = open(namebuf, O_RDONLY)) == -1) {
		DBGPRINTF("error reading '%s'\n", namebuf);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if((lenRead = read(fd, buf, lenBuf - 1)) == -1) {
		DBGPRINTF("error reading file data for '%s'\n", namebuf);
		close(fd);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* we strip after the first \n */
	for(i = 0 ; i &lt; lenRead ; ++i) {
		if(buf[i] == '\n')
			break;
		else if(iscntrl(buf[i]))
			buf[i] = ' ';
	}
	buf[i] = '\0';
	*lenProp = i;

	close(fd);

finalize_it:
	RETiRet;
}


/* read the exe trusted property path (so far, /proc fs only)
 */
static rsRetVal
getTrustedExe(struct ucred *cred, uchar *buf, size_t lenBuf, int* lenProp)
{
	int lenRead;
	char namebuf[1024];
	DEFiRet;

	if(snprintf(namebuf, sizeof(namebuf), "/proc/%lu/exe", (long unsigned) cred-&gt;pid)
		&gt;= (int) sizeof(namebuf)) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	if((lenRead = readlink(namebuf, (char*)buf, lenBuf - 1)) == -1) {
		DBGPRINTF("error reading link '%s'\n", namebuf);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	buf[lenRead] = '\0';
	*lenProp = lenRead;

finalize_it:
	RETiRet;
}


/* copy a trusted property in escaped mode. That is, the property can contain
 * any character and so it must be properly quoted AND escaped.
 * It is assumed the output buffer is large enough. Returns the number of
 * characters added.
 */
static int
copyescaped(uchar *dstbuf, uchar *inbuf, int inlen)
{
	int iDst, iSrc;

	*dstbuf = '"';
	for(iDst=1, iSrc=0 ; iSrc &lt; inlen ; ++iDst, ++iSrc) {
		if(inbuf[iSrc] == '"' || inbuf[iSrc] == '\\') {
			dstbuf[iDst++] = '\\';
		}
		dstbuf[iDst] = inbuf[iSrc];
	}
	dstbuf[iDst++] = '"';
	return iDst;
}


/* submit received message to the queue engine
 * We now parse the message according to expected format so that we
 * can also mangle it if necessary.
 */
static rsRetVal
SubmitMsg(uchar *pRcv, int lenRcv, lstn_t *pLstn, struct ucred *cred, struct timeval *ts)
{
	smsg_t *pMsg = NULL;
	int lenMsg;
	int offs;
	int i;
	uchar *parse;
	syslog_pri_t pri;
	uchar bufParseTAG[CONF_TAG_MAXSIZE];
	struct syslogTime st;
	time_t tt;
	ratelimit_t *ratelimiter = NULL;
	struct syslogTime dummyTS;
	DEFiRet;

	if(pLstn-&gt;bDiscardOwnMsgs &amp;&amp; cred != NULL &amp;&amp; cred-&gt;pid == glblGetOurPid()) {
		DBGPRINTF("imuxsock: discarding message from our own pid\n");
		FINALIZE;
	}

	/* TODO: handle format errors?? */
	/* we need to parse the pri first, because we need the severity for
	 * rate-limiting as well.
	 */
	parse = pRcv;
	lenMsg = lenRcv;
	offs = 1; /* '&lt;' */

	parse++;
	pri = 0;
	while(offs &lt; lenMsg &amp;&amp; isdigit(*parse)) {
		pri = pri * 10 + *parse - '0';
		++parse;
		++offs;
	}

	findRatelimiter(pLstn, cred, &amp;ratelimiter); /* ignore error, better so than others... */

	if(ts == NULL) {
		datetime.getCurrTime(&amp;st, &amp;tt, TIME_IN_LOCALTIME);
	} else {
		datetime.timeval2syslogTime(ts, &amp;st, TIME_IN_LOCALTIME);
		tt = ts-&gt;tv_sec;
	}

#if 0 // TODO: think about stats counters (or wait for request...?)
	if(ratelimiter != NULL &amp;&amp; !withinRatelimit(ratelimiter, tt, cred-&gt;pid)) {
		STATSCOUNTER_INC(ctrLostRatelimit, mutCtrLostRatelimit);
		FINALIZE;
	}
#endif

	/* we now create our own message object and submit it to the queue */
	CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tt));

	/* created trusted properties */
	if(cred != NULL &amp;&amp; pLstn-&gt;bAnnotate) {
		uchar propBuf[1024];
		int lenProp;

		if (pLstn-&gt;bParseTrusted) {
			struct json_object *json, *jval;

#define CHKjson(operation, toBeFreed)					\
			if((operation) == NULL) {			\
				json_object_put(toBeFreed);		\
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);	\
			}

			CHKmalloc(json = json_object_new_object());
			/* create value string, create field, and add it */
			CHKjson(jval = json_object_new_int(cred-&gt;pid), json);
			json_object_object_add(json, "pid", jval);
			CHKjson(jval = json_object_new_int(cred-&gt;uid), json);
			json_object_object_add(json, "uid", jval);
			CHKjson(jval = json_object_new_int(cred-&gt;gid), json);
			json_object_object_add(json, "gid", jval);
			if(getTrustedProp(cred, "comm", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				CHKjson(jval = json_object_new_string((char*)propBuf), json);
				json_object_object_add(json, "appname", jval);
			}
			if(getTrustedExe(cred, propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				CHKjson(jval = json_object_new_string((char*)propBuf), json);
				json_object_object_add(json, "exe", jval);
			}
			if(getTrustedProp(cred, "cmdline", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				CHKjson(jval = json_object_new_string((char*)propBuf), json);
				json_object_object_add(json, "cmd", jval);
			}
#undef CHKjson

			/* as per lumberjack spec, these properties need to go into
			 * the CEE root.
			 */
			msgAddJSON(pMsg, (uchar*)"!", json, 0, 0);

			MsgSetRawMsg(pMsg, (char*)pRcv, lenRcv);
		} else {
			uchar msgbuf[8192];
			uchar *pmsgbuf = msgbuf;
			int toffs; /* offset for trusted properties */

			if((unsigned) (lenRcv + 4096) &gt;= sizeof(msgbuf)) {
				CHKmalloc(pmsgbuf = malloc(lenRcv+4096));
			}

			memcpy(pmsgbuf, pRcv, lenRcv);
			memcpy(pmsgbuf+lenRcv, " @[", 3);
			toffs = lenRcv + 3; /* next free location */
			lenProp = snprintf((char*)propBuf, sizeof(propBuf), "_PID=%lu _UID=%lu _GID=%lu",
				 		(long unsigned) cred-&gt;pid, (long unsigned) cred-&gt;uid,
						(long unsigned) cred-&gt;gid);
			memcpy(pmsgbuf+toffs, propBuf, lenProp);
			toffs = toffs + lenProp;

			if(getTrustedProp(cred, "comm", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				memcpy(pmsgbuf+toffs, " _COMM=", 7);
				memcpy(pmsgbuf+toffs+7, propBuf, lenProp);
				toffs = toffs + 7 + lenProp;
			}
			if(getTrustedExe(cred, propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				memcpy(pmsgbuf+toffs, " _EXE=", 6);
				memcpy(pmsgbuf+toffs+6, propBuf, lenProp);
				toffs = toffs + 6 + lenProp;
			}
			if(getTrustedProp(cred, "cmdline", propBuf, sizeof(propBuf), &amp;lenProp) == RS_RET_OK) {
				memcpy(pmsgbuf+toffs, " _CMDLINE=", 10);
				toffs = toffs + 10 +
					copyescaped(pmsgbuf+toffs+10, propBuf, lenProp);
			}

			/* finalize string */
			pmsgbuf[toffs] = ']';
			pmsgbuf[toffs+1] = '\0';

			MsgSetRawMsg(pMsg, (char*)pmsgbuf, toffs + 1);
			if (pmsgbuf != msgbuf) {
				free(pmsgbuf);
			}
		}
	} else {
		/* just add the unmodified message */
		MsgSetRawMsg(pMsg, (char*)pRcv, lenRcv);
	}

	MsgSetFlowControlType(pMsg, pLstn-&gt;flowCtl);
	MsgSetInputName(pMsg, pInputName);
	if(pLstn-&gt;bParseHost) {
		pMsg-&gt;msgFlags  = pLstn-&gt;flags | PARSE_HOSTNAME;
	} else {
		pMsg-&gt;msgFlags  = pLstn-&gt;flags;
	}

	if(pLstn-&gt;bUseSpecialParser) {
		/* this is the legacy "log socket" parser which was written on the assumption
		 * that the log socket format would be fixed. While many folks said so, it
		 * seems to be different in practice, and this is why we now have choices...
		 * rgerhards, 2015-03-03
		 */
		parser.SanitizeMsg(pMsg);
		lenMsg = pMsg-&gt;iLenRawMsg - offs; /* SanitizeMsg() may have changed the size */
		msgSetPRI(pMsg, pri);
		MsgSetAfterPRIOffs(pMsg, offs);

		parse++; lenMsg--; /* '&gt;' */
		if(ts == NULL) {
			if((pLstn-&gt;flags &amp; IGNDATE)) {
				/* in this case, we still need to find out if we have a valid
				 * datestamp or not .. and advance the parse pointer accordingly.
				 */
				if (datetime.ParseTIMESTAMP3339(&amp;dummyTS, &amp;parse, &amp;lenMsg) != RS_RET_OK) {
					datetime.ParseTIMESTAMP3164(&amp;dummyTS, &amp;parse, &amp;lenMsg,
					NO_PARSE3164_TZSTRING, NO_PERMIT_YEAR_AFTER_TIME);
				}
			} else {
				if(datetime.ParseTIMESTAMP3339(&amp;(pMsg-&gt;tTIMESTAMP), &amp;parse, &amp;lenMsg) != RS_RET_OK &amp;&amp;
				datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;parse, &amp;lenMsg,
				NO_PARSE3164_TZSTRING, NO_PERMIT_YEAR_AFTER_TIME) != RS_RET_OK) {
					DBGPRINTF("we have a problem, invalid timestamp in msg!\n");
				}
			}
		} else { /* if we pulled the time from the system, we need to update the message text */
			uchar *tmpParse = parse; /* just to check correctness of TS */
			if(datetime.ParseTIMESTAMP3339(&amp;dummyTS, &amp;tmpParse, &amp;lenMsg) == RS_RET_OK ||
		 	datetime.ParseTIMESTAMP3164(&amp;dummyTS, &amp;tmpParse, &amp;lenMsg, NO_PARSE3164_TZSTRING,
			NO_PERMIT_YEAR_AFTER_TIME) == RS_RET_OK) {
			/* We modify the message only if it contained a valid timestamp,
			otherwise we do not touch it at all. */
				datetime.formatTimestamp3164(&amp;st, (char*)parse, 0);
				parse[15] = ' '; /* re-write \0 from fromatTimestamp3164 by SP */
				/* update "counters" to reflect processed timestamp */
				parse += 16;
			}
		}

		/* pull tag */

		i = 0;
		while(lenMsg &gt; 0 &amp;&amp; *parse != ' ' &amp;&amp; i &lt; CONF_TAG_MAXSIZE - 1) {
			bufParseTAG[i++] = *parse++;
			--lenMsg;
		}
		bufParseTAG[i] = '\0';	/* terminate string */
		if(pLstn-&gt;bWritePid)
			fixPID(bufParseTAG, &amp;i, cred);
		MsgSetTAG(pMsg, bufParseTAG, i);
		MsgSetMSGoffs(pMsg, pMsg-&gt;iLenRawMsg - lenMsg);
	} else { /* we are configured to use regular parser chain */
		pMsg-&gt;msgFlags  |= NEEDS_PARSING;
	}

	MsgSetRcvFrom(pMsg, pLstn-&gt;hostName == NULL ? glbl.GetLocalHostNameProp() : pLstn-&gt;hostName);
	CHKiRet(MsgSetRcvFromIP(pMsg, pLocalHostIP));
	MsgSetRuleset(pMsg, pLstn-&gt;pRuleset);
	ratelimitAddMsg(ratelimiter, NULL, pMsg);
	STATSCOUNTER_INC(ctrSubmit, mutCtrSubmit);
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pMsg != NULL)
			msgDestruct(&amp;pMsg);
	}
	RETiRet;
}


/* This function receives data from a socket indicated to be ready
 * to receive and submits the message received for processing.
 * rgerhards, 2007-12-20
 * Interface changed so that this function is passed the array index
 * of the socket which is to be processed. This eases access to the
 * growing number of properties. -- rgerhards, 2008-08-01
 */
static rsRetVal readSocket(lstn_t *pLstn)
{
	DEFiRet;
	int iRcvd;
	int iMaxLine;
	struct msghdr msgh;
	struct iovec msgiov;
	struct ucred cred;
	struct timeval ts;
	int cred_set = 0;
	int ts_set = 0;
	uchar bufRcv[4096+1];
	uchar *pRcv = NULL; /* receive buffer */
#	ifdef HAVE_SCM_CREDENTIALS
	/* aux is a union rather than a direct char array to force alignment with cmsghdr */
	union {
		char buf[128];
		struct cmsghdr cm;
	} aux;
#	endif

	assert(pLstn-&gt;fd &gt;= 0);

	iMaxLine = glbl.GetMaxLine(runConf);

	/* we optimize performance: if iMaxLine is below 4K (which it is in almost all
	 * cases, we use a fixed buffer on the stack. Only if it is higher, heap memory
	 * is used. We could use alloca() to achive a similar aspect, but there are so
	 * many issues with alloca() that I do not want to take that route.
	 * rgerhards, 2008-09-02
	 */
	if((size_t) iMaxLine &lt; sizeof(bufRcv) - 1) {
		pRcv = bufRcv;
	} else {
		CHKmalloc(pRcv = (uchar*) malloc(iMaxLine + 1));
	}

	memset(&amp;msgh, 0, sizeof(msgh));
	memset(&amp;msgiov, 0, sizeof(msgiov));
#	ifdef HAVE_SCM_CREDENTIALS
	if(pLstn-&gt;bUseCreds) {
		memset(&amp;aux, 0, sizeof(aux));
		msgh.msg_control = &amp;aux;
		msgh.msg_controllen = sizeof(aux);
	}
#	endif
	msgiov.iov_base = (char*)pRcv;
	msgiov.iov_len = iMaxLine;
	msgh.msg_iov = &amp;msgiov;
	msgh.msg_iovlen = 1;
/*  AIXPORT : MSG_DONTWAIT not supported */
#if defined (_AIX)
#define MSG_DONTWAIT    MSG_NONBLOCK
#endif
	iRcvd = recvmsg(pLstn-&gt;fd, &amp;msgh, MSG_DONTWAIT);

	DBGPRINTF("Message from UNIX socket: #%d, size %d\n", pLstn-&gt;fd, (int) iRcvd);
	if(iRcvd &gt; 0) {
#		if defined(HAVE_SCM_CREDENTIALS) || defined(HAVE_SO_TIMESTAMP)
		if(pLstn-&gt;bUseCreds) {
			struct cmsghdr *cm;
			for(cm = CMSG_FIRSTHDR(&amp;msgh); cm; cm = CMSG_NXTHDR(&amp;msgh, cm)) {
#				ifdef HAVE_SCM_CREDENTIALS
				if(   pLstn-&gt;bUseCreds
				   &amp;&amp; cm-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cm-&gt;cmsg_type == SCM_CREDENTIALS) {
					memcpy(&amp;cred, CMSG_DATA(cm), sizeof(cred));
					cred_set = 1;
				}
#				endif /* HAVE_SCM_CREDENTIALS */
#				if HAVE_SO_TIMESTAMP
				if(   pLstn-&gt;bUseSysTimeStamp
				   &amp;&amp; cm-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cm-&gt;cmsg_type == SO_TIMESTAMP) {
					memcpy(&amp;ts, CMSG_DATA(cm), sizeof(ts));
					ts_set = 1;
				}
#				endif /* HAVE_SO_TIMESTAMP */
			}
		}
#		endif /* defined(HAVE_SCM_CREDENTIALS) || defined(HAVE_SO_TIMESTAMP) */
		CHKiRet(SubmitMsg(pRcv, iRcvd, pLstn, (cred_set ? &amp;cred : NULL), (ts_set ? &amp;ts : NULL)));
	} else if(iRcvd &lt; 0 &amp;&amp; errno != EINTR &amp;&amp; errno != EAGAIN) {
		char errStr[1024];
		rs_strerror_r(errno, errStr, sizeof(errStr));
		DBGPRINTF("UNIX socket error: %d = %s.\n", errno, errStr);
		LogError(errno, NO_ERRCODE, "imuxsock: recvfrom UNIX");
	}

finalize_it:
	if(pRcv != NULL &amp;&amp; (size_t) iMaxLine &gt;= sizeof(bufRcv) - 1)
		free(pRcv);

	RETiRet;
}


/* activate current listeners */
static rsRetVal
activateListeners(void)
{
	int actSocks;
	int i;
	DEFiRet;

	/* Initialize the system socket only if it's in use */
	if(startIndexUxLocalSockets == 0) {
		/* first apply some config settings */
		listeners[0].sockName = UCHAR_CONSTANT(_PATH_LOG);
		if(runModConf-&gt;pLogSockName != NULL) {
			listeners[0].sockName = runModConf-&gt;pLogSockName;
		}
#ifdef HAVE_LIBSYSTEMD
		else if(sd_booted()) {
			struct stat st;
			if(stat(SYSTEMD_PATH_LOG, &amp;st) != -1 &amp;&amp; S_ISSOCK(st.st_mode)) {
				listeners[0].sockName = (uchar*) SYSTEMD_PATH_LOG;
			}
		}
#endif
		if(runModConf-&gt;ratelimitIntervalSysSock &gt; 0) {
			if((listeners[0].ht = create_hashtable(100, hash_from_key_fn, key_equals_fn, NULL)) == NULL) {
				/* in this case, we simply turn of rate-limiting */
				LogError(0, NO_ERRCODE, "imuxsock: turning off rate limiting because "
					"we could not create hash table\n");
				runModConf-&gt;ratelimitIntervalSysSock = 0;
			}
		} else {
			listeners[0].ht = NULL;
		}
		listeners[0].fd = -1;
		listeners[0].pRuleset = NULL;
		listeners[0].hostName = NULL;
		listeners[0].bParseHost = 0;
		listeners[0].bCreatePath = 0;
		listeners[0].ratelimitInterval = runModConf-&gt;ratelimitIntervalSysSock;
		listeners[0].ratelimitBurst = runModConf-&gt;ratelimitBurstSysSock;
		listeners[0].ratelimitSev = runModConf-&gt;ratelimitSeveritySysSock;
		listeners[0].bUseCreds = (runModConf-&gt;bWritePidSysSock || runModConf-&gt;ratelimitIntervalSysSock
		|| runModConf-&gt;bAnnotateSysSock || runModConf-&gt;bDiscardOwnMsgs
		|| runModConf-&gt;bUseSysTimeStamp) ? 1 : 0;
		listeners[0].bWritePid = runModConf-&gt;bWritePidSysSock;
		listeners[0].bAnnotate = runModConf-&gt;bAnnotateSysSock;
		listeners[0].bParseTrusted = runModConf-&gt;bParseTrusted;
		listeners[0].bParseHost = runModConf-&gt;bParseHost;
		listeners[0].bUseSpecialParser = runModConf-&gt;bUseSpecialParser;
		listeners[0].bDiscardOwnMsgs = runModConf-&gt;bDiscardOwnMsgs;
		listeners[0].bUnlink = runModConf-&gt;bUnlink;
		listeners[0].bUseSysTimeStamp = runModConf-&gt;bUseSysTimeStamp;
		listeners[0].flags = runModConf-&gt;bIgnoreTimestamp ? IGNDATE : NOFLAG;
		listeners[0].flowCtl = runModConf-&gt;bUseFlowCtl ? eFLOWCTL_LIGHT_DELAY : eFLOWCTL_NO_DELAY;
		CHKiRet(ratelimitNew(&amp;listeners[0].dflt_ratelimiter, "imuxsock", NULL));
			ratelimitSetLinuxLike(listeners[0].dflt_ratelimiter,
			listeners[0].ratelimitInterval,
			listeners[0].ratelimitBurst);
		ratelimitSetSeverity(listeners[0].dflt_ratelimiter,listeners[0].ratelimitSev);
	}

#ifdef HAVE_LIBSYSTEMD
	sd_fds = sd_listen_fds(0);
	if(sd_fds &lt; 0) {
		LogError(-sd_fds, NO_ERRCODE, "imuxsock: Failed to acquire systemd socket");
		ABORT_FINALIZE(RS_RET_ERR_CRE_AFUX);
	}
#endif

	/* initialize and return if will run or not */
	actSocks = 0;
	for (i = startIndexUxLocalSockets ; i &lt; nfd ; i++) {
		if(openLogSocket(&amp;(listeners[i])) == RS_RET_OK) {
			++actSocks;
			DBGPRINTF("imuxsock: Opened UNIX socket '%s' (fd %d).\n",
				  listeners[i].sockName, listeners[i].fd);
		}
	}

	if(actSocks == 0) {
		LogError(0, RS_RET_ERR, "imuxsock does not run because we could not "
			"acquire any socket\n");
		ABORT_FINALIZE(RS_RET_ERR);
	}

finalize_it:
	RETiRet;
}



BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	/* init our settings */
	pModConf-&gt;pLogSockName = NULL;
	pModConf-&gt;bOmitLocalLogging = 0;
	pModConf-&gt;bIgnoreTimestamp = 1;
	pModConf-&gt;bUseFlowCtl = 0;
	pModConf-&gt;bUseSysTimeStamp = 1;
	pModConf-&gt;bWritePidSysSock = 0;
	pModConf-&gt;bAnnotateSysSock = 0;
	pModConf-&gt;bParseTrusted = 0;
	pModConf-&gt;bParseHost = UNSET;
	pModConf-&gt;bUseSpecialParser = DFLT_bUseSpecialParser;
	/* if we do not process internal messages, we will see messages
	 * from ourselves, and so we need to permit this.
	 */
	pModConf-&gt;bDiscardOwnMsgs = pConf-&gt;globals.bProcessInternalMessages;
	pModConf-&gt;bUnlink = 1;
	pModConf-&gt;ratelimitIntervalSysSock = DFLT_ratelimitInterval;
	pModConf-&gt;ratelimitBurstSysSock = DFLT_ratelimitBurst;
<a name="1"></a>	pModConf-&gt;ratelimitSeveritySysSock = DFLT_ratelimitSeverity;
	bLegacyCnfModGlobalsPermitted = 1;
	/* reset legacy config vars */
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	resetConfigVariables(NULL, NULL);
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for imuxsock:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "syssock.use")) {
			loadModConf-&gt;bOmitLocalLogging = ((int) pvals[i].val.d.n) ? 0 : 1;</b></font>
		} else if(!strcmp(modpblk.descr[i].name, "syssock.name")) {
			loadModConf-&gt;pLogSockName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ignoretimestamp")) {
			loadModConf-&gt;bIgnoreTimestamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ignoreownmessages")) {
			loadModConf-&gt;bDiscardOwnMsgs = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.unlink")) {
			loadModConf-&gt;bUnlink = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.flowcontrol")) {
			loadModConf-&gt;bUseFlowCtl = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.usesystimestamp")) {
			loadModConf-&gt;bUseSysTimeStamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.annotate")) {
			loadModConf-&gt;bAnnotateSysSock = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.parsetrusted")) {
			loadModConf-&gt;bParseTrusted = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.parsehostname")) {
			loadModConf-&gt;bParseHost = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.usespecialparser")) {
			loadModConf-&gt;bUseSpecialParser = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.usepidfromsystem")) {
			loadModConf-&gt;bWritePidSysSock = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ratelimit.interval")) {
			loadModConf-&gt;ratelimitIntervalSysSock = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ratelimit.burst")) {
			loadModConf-&gt;ratelimitBurstSysSock = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "syssock.ratelimit.severity")) {
			loadModConf-&gt;ratelimitSeveritySysSock = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("imuxsock: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}

	/* disable legacy module-global config directives */
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
<a name="2"></a>	DBGPRINTF("newInpInst (imuxsock)\n");

	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS,
			        "imuxsock: required parameter are missing\n");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("input param blk in imuxsock:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));

	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "socket")) {
			inst-&gt;sockName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "createpath")) {
			inst-&gt;bCreatePath = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "parsetrusted")) {
			inst-&gt;bParseTrusted = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ignoreownmessages")) {
			inst-&gt;bDiscardOwnMsgs = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "unlink")) {
			inst-&gt;bUnlink = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "hostname")) {
			inst-&gt;pLogHostName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ignoretimestamp")) {
			inst-&gt;bIgnoreTimestamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "flowcontrol")) {
			inst-&gt;bUseFlowCtl = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "usesystimestamp")) {
			inst-&gt;bUseSysTimeStamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "annotate")) {
			inst-&gt;bAnnotate = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "usepidfromsystem")) {
			inst-&gt;bWritePid = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "parsehostname")) {
			inst-&gt;bParseHost  = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "usespecialparser")) {
			inst-&gt;bUseSpecialParser  = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.interval")) {
			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.burst")) {
			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.severity")) {
			inst-&gt;ratelimitSeverity = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("imuxsock: program error, non-handled "
			  "param '%s'\n", inppblk.descr[i].name);
		}
	}
finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst


BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		/* persist module-specific settings from legacy config system */
		/* these are used to initialize the system log socket (listeners[0]) */
		loadModConf-&gt;bOmitLocalLogging = cs.bOmitLocalLogging;
		loadModConf-&gt;pLogSockName = cs.pLogSockName;
		loadModConf-&gt;bIgnoreTimestamp = cs.bIgnoreTimestampSysSock;
		loadModConf-&gt;bUseSysTimeStamp = cs.bUseSysTimeStampSysSock;
		loadModConf-&gt;bUseFlowCtl = cs.bUseFlowCtlSysSock;
		loadModConf-&gt;bAnnotateSysSock = cs.bAnnotateSysSock;
		loadModConf-&gt;bWritePidSysSock = cs.bWritePidSysSock;
		loadModConf-&gt;bParseTrusted = cs.bParseTrusted;
		loadModConf-&gt;ratelimitIntervalSysSock = cs.ratelimitIntervalSysSock;
		loadModConf-&gt;ratelimitBurstSysSock = cs.ratelimitBurstSysSock;
		loadModConf-&gt;ratelimitSeveritySysSock = cs.ratelimitSeveritySysSock;
	}

	loadModConf = NULL; /* done loading */
	/* free legacy config vars */
	free(cs.pLogHostName);
	cs.pLogSockName = NULL;
	cs.pLogHostName = NULL;
ENDendCnfLoad


/* function to generate error message if framework does not find requested ruleset */
static void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imuxsock: ruleset '%s' for socket %s not found - "
			"using default ruleset instead", inst-&gt;pszBindRuleset,
			inst-&gt;sockName);
}
BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
	instanceConf_t *inst;
	int nLstn;
	int i;
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
#	ifdef OS_SOLARIS
		/* under solaris, we must NEVER process the local log socket, because
		 * it is implemented there differently. If we used it, we would actually
		 * delete it and render the system partly unusable. So don't do that.
		 * rgerhards, 2010-03-26
		 */
		startIndexUxLocalSockets = 1;
#	else
		startIndexUxLocalSockets = runModConf-&gt;bOmitLocalLogging ? 1 : 0;
#	endif
	/* we first calculate the number of listeners so that we can
	 * appropriately size the listener array. Note that we will
	 * always allocate memory for the system log socket.
	 */
	nLstn = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		++nLstn;
	}
	if(nLstn &gt; 0 || startIndexUxLocalSockets == 0) {
		DBGPRINTF("imuxsock: allocating memory for %d listeners\n", nLstn);
		lstn_t *const listeners_new = realloc(listeners, (1+nLstn)*sizeof(lstn_t));
		CHKmalloc(listeners_new);
		listeners = listeners_new;
		for(i = 1 ; i &lt; nLstn ; ++i) {
			listeners[i].sockName = NULL;
			listeners[i].fd  = -1;
		}
		for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
			addListner(inst);
		}
		CHKiRet(activateListeners());
	}
finalize_it:
ENDactivateCnfPrePrivDrop


BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	free(pModConf-&gt;pLogSockName);
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;sockName);
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;pLogHostName);
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf


/* This function is called to gather input. */
BEGINrunInput
	int nfds;
	int i;
CODESTARTrunInput
	struct pollfd *const pollfds = calloc(nfd, sizeof(struct pollfd));
	CHKmalloc(pollfds);
	if(startIndexUxLocalSockets == 1 &amp;&amp; nfd == 1) {
		/* No sockets were configured, no reason to run. */
		ABORT_FINALIZE(RS_RET_OK);
	}
	if(startIndexUxLocalSockets == 1) {
		pollfds[0].fd = -1;
	}
	for (i = startIndexUxLocalSockets; i &lt; nfd; i++) {
		pollfds[i].fd = listeners[i].fd;
		pollfds[i].events = POLLIN;
	}

	/* this is an endless loop - it is terminated when the thread is
	 * signalled to do so.
	 */
	while(1) {
		DBGPRINTF("--------imuxsock calling poll() on %d fds\n", nfd);

		nfds = poll(pollfds, nfd, -1);
		if(glbl.GetGlobalInputTermState() == 1)
			break; /* terminate input! */

		if(nfds &lt; 0) {
			if(errno == EINTR) {
				DBGPRINTF("imuxsock: EINTR occurred\n");
			} else {
				LogMsg(errno, RS_RET_POLL_ERR, LOG_WARNING, "imuxsock: poll "
					"system call failed, may cause further troubles");
			}
			nfds = 0;
		}

		for (i = startIndexUxLocalSockets ; i &lt; nfd &amp;&amp; nfds &gt; 0; i++) {
			if(glbl.GetGlobalInputTermState() == 1)
				ABORT_FINALIZE(RS_RET_FORCE_TERM); /* terminate input! */
			if(pollfds[i].revents &amp; POLLIN) {
				readSocket(&amp;(listeners[i]));
				--nfds; /* indicate we have processed one */
			}
		}
	}

finalize_it:
	free(pollfds);
ENDrunInput


BEGINwillRun
CODESTARTwillRun
ENDwillRun


BEGINafterRun
	int i;
CODESTARTafterRun
	/* do cleanup here */
	if(startIndexUxLocalSockets == 1 &amp;&amp; nfd == 1) {
		/* No sockets were configured, no cleanup needed. */
		return RS_RET_OK;
	}

	/* Close the UNIX sockets. */
	for (i = 0; i &lt; nfd; i++)
		if (listeners[i].fd != -1)
			close(listeners[i].fd);

	/* Clean-up files. */
	for(i = startIndexUxLocalSockets; i &lt; nfd; i++)
		if (listeners[i].sockName &amp;&amp; listeners[i].fd != -1) {
			/* If systemd passed us a socket it is systemd's job to clean it up.
			 * Do not unlink it -- we will get same socket (node) from systemd
			 * e.g. on restart again.
			 */
			if (sd_fds &gt; 0
#			ifdef HAVE_LIBSYSTEMD
			    &amp;&amp; listeners[i].fd &gt;= SD_LISTEN_FDS_START &amp;&amp;
			       listeners[i].fd &lt;  SD_LISTEN_FDS_START + sd_fds
#			endif
			   )
				continue;

			if(listeners[i].bUnlink) {
				DBGPRINTF("imuxsock: unlinking unix socket file[%d] %s\n", i, listeners[i].sockName);
				unlink((char*) listeners[i].sockName);
			}
		}

	discardLogSockets();
	nfd = 1;
ENDafterRun


BEGINmodExit
CODESTARTmodExit
	free(listeners);
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);

	statsobj.Destruct(&amp;modStats);

	objRelease(parser, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	free(cs.pLogSockName);
	cs.pLogSockName = NULL;
	free(cs.pLogHostName);
	cs.bOmitLocalLogging = 0;
	cs.pLogHostName = NULL;
	cs.bIgnoreTimestamp = 1;
	cs.bIgnoreTimestampSysSock = 1;
	cs.bUseFlowCtl = 0;
	cs.bUseFlowCtlSysSock = 0;
	cs.bUseSysTimeStamp = 1;
	cs.bUseSysTimeStampSysSock = 1;
	cs.bWritePid = 0;
	cs.bWritePidSysSock = 0;
	cs.bAnnotate = 0;
	cs.bAnnotateSysSock = 0;
	cs.bParseTrusted = 0;
	cs.bCreatePath = DFLT_bCreatePath;
	cs.ratelimitInterval = DFLT_ratelimitInterval;
	cs.ratelimitIntervalSysSock = DFLT_ratelimitInterval;
	cs.ratelimitBurst = DFLT_ratelimitBurst;
	cs.ratelimitBurstSysSock = DFLT_ratelimitBurst;
	cs.ratelimitSeverity = DFLT_ratelimitSeverity;
	cs.ratelimitSeveritySysSock = DFLT_ratelimitSeverity;

	return RS_RET_OK;
}


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(net, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));

	DBGPRINTF("imuxsock version %s initializing\n", PACKAGE_VERSION);

	/* init legacy config vars */
	cs.pLogSockName = NULL;
	cs.pLogHostName = NULL;	/* host name to use with this socket */

	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imuxsock"), sizeof("imuxsock") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));

	/* right now, glbl does not permit per-instance IP address notation. As long as this
	 * is the case, it is OK to query the HostIP once here at this location. HOWEVER, the
	 * whole concept is not 100% clean and needs to be addressed on a higher layer.
	 * TODO / rgerhards, 2012-04-11
	 */
	pLocalHostIP = glbl.GetLocalHostIP();

	/* register config file handlers */
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketignoremsgtimestamp", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bIgnoreTimestamp, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensockethostname", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pLogHostName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketflowcontrol", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bUseFlowCtl, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketannotate", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bAnnotate, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketcreatepath", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bCreatePath, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketusesystimestamp", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bUseSysTimeStamp, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"addunixlistensocket", 0, eCmdHdlrGetWord,
		addInstance, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputunixlistensocketusepidfromsystem", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bWritePid, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imuxsockratelimitinterval", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitInterval, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imuxsockratelimitburst", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitBurst, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imuxsockratelimitseverity", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitSeverity, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
	/* the following one is a (dirty) trick: the system log socket is not added via
	 * an "addUnixListenSocket" config format. As such, it's properties can not be modified
	 * via $InputUnixListenSocket*". So we need to add a special directive
	 * for that. We should revisit all of that once we have the new config format...
	 * rgerhards, 2008-03-06
	 */
	CHKiRet(regCfSysLineHdlr2((uchar *)"omitlocallogging", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bOmitLocalLogging, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketname", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pLogSockName, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketignoremsgtimestamp", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bIgnoreTimestampSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketflowcontrol", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bUseFlowCtlSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogusesystimestamp", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bUseSysTimeStampSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogsocketannotate", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bAnnotateSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogparsetrusted", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bParseTrusted, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogusepidfromsystem", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bWritePidSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogratelimitinterval", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitIntervalSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogratelimitburst", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitBurstSysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"systemlogratelimitseverity", 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitSeveritySysSock, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));

	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&amp;modStats));
	CHKiRet(statsobj.SetName(modStats, UCHAR_CONSTANT("imuxsock")));
	CHKiRet(statsobj.SetOrigin(modStats, UCHAR_CONSTANT("imuxsock")));
	STATSCOUNTER_INIT(ctrSubmit, mutCtrSubmit);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("submitted"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrSubmit));
	STATSCOUNTER_INIT(ctrLostRatelimit, mutCtrLostRatelimit);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("ratelimit.discarded"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrLostRatelimit));
	STATSCOUNTER_INIT(ctrNumRatelimiters, mutCtrNumRatelimiters);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("ratelimit.numratelimiters"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrNumRatelimiters));
	CHKiRet(statsobj.ConstructFinalize(modStats));

ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
