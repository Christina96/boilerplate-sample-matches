
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 25.862068965517242%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_uarte.h</h3>
            <pre><code>1  #ifndef NRFX_UARTE_H__
2  #define NRFX_UARTE_H__
3  #include <nrfx.h>
4  #include <hal/nrf_uarte.h>
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  typedef struct
9  {
10      NRF_UARTE_Type * p_reg;        
11      uint8_t          drv_inst_idx; 
12  } nrfx_uarte_t;
13  #ifndef __NRFX_DOXYGEN__
14  enum {
15  #if NRFX_CHECK(NRFX_UARTE0_ENABLED)
16      NRFX_UARTE0_INST_IDX,
17  #endif
18  #if NRFX_CHECK(NRFX_UARTE1_ENABLED)
19      NRFX_UARTE1_INST_IDX,
20  #endif
21  #if NRFX_CHECK(NRFX_UARTE2_ENABLED)
22      NRFX_UARTE2_INST_IDX,
23  #endif
24  #if NRFX_CHECK(NRFX_UARTE3_ENABLED)
25      NRFX_UARTE3_INST_IDX,
26  #endif
27      NRFX_UARTE_ENABLED_COUNT
28  };
29  #endif
30  #define NRFX_UARTE_INSTANCE(id)                               \
31  {                                                             \
32      .p_reg        = NRFX_CONCAT_2(NRF_UARTE, id),             \
33      .drv_inst_idx = NRFX_CONCAT_3(NRFX_UARTE, id, _INST_IDX), \
34  }
35  typedef enum
36  {
37      NRFX_UARTE_EVT_TX_DONE, 
38      NRFX_UARTE_EVT_RX_DONE, 
39      NRFX_UARTE_EVT_ERROR,   
40  } nrfx_uarte_evt_type_t;
<span onclick='openModal()' class='match'>41  typedef struct
42  {
43      uint32_t             pseltxd;            
44      uint32_t             pselrxd;            
45      uint32_t             pselcts;            
46      uint32_t             pselrts;            
47      void *               p_context;          
48      nrf_uarte_baudrate_t baudrate;           
49      uint8_t              interrupt_priority; 
50      nrf_uarte_config_t   hal_cfg;            
51  } nrfx_uarte_config_t;
52  #if defined(UARTE_CONFIG_STOP_Msk) || defined(__NRFX_DOXYGEN__)
53      #define NRFX_UARTE_DEFAULT_EXTENDED_STOP_CONFIG   \
54          .stop = (nrf_uarte_stop_t)NRF_UARTE_STOP_ONE,
55  #else
56      #define NRFX_UARTE_DEFAULT_EXTENDED_STOP_CONFIG
57  #endif
58  #if defined(UARTE_CONFIG_PARITYTYPE_Msk) || defined(__NRFX_DOXYGEN__)
59      #define NRFX_UARTE_DEFAULT_EXTENDED_PARITYTYPE_CONFIG   \
60          .paritytype = NRF_UARTE_PARITYTYPE_EVEN,
61  #else
62      #define NRFX_UARTE_DEFAULT_EXTENDED_PARITYTYPE_CONFIG
63  #endif
64  #define NRFX_UARTE_DEFAULT_CONFIG(_pin_tx, _pin_rx)                                 \
65  {                                                                                   \
66      .pseltxd            = _pin_tx,                                                  \
67      .pselrxd            = _pin_rx,                                                  \
68      .pselcts            = NRF_UARTE_PSEL_DISCONNECTED,                              \
69      .pselrts            = NRF_UARTE_PSEL_DISCONNECTED,                              \
70      .p_context          = NULL,                                                     \
71      .baudrate           = NRF_UARTE_BAUDRATE_115200,                                \
72      .interrupt_priority = NRFX_UARTE_DEFAULT_CONFIG_IRQ_PRIORITY,                   \
73      .hal_cfg            = {                                                         \
74          .hwfc           = NRF_UARTE_HWFC_DISABLED,                                  \
75          .parity         = NRF_UARTE_PARITY_EXCLUDED,                                \
76          NRFX_UARTE_DEFAULT_EXTENDED_STOP_CONFIG                                     \
77          NRFX_UARTE_DEFAULT_EXTENDED_PARITYTYPE_CONFIG                               \
78      }                                                                               \
79  }
80  typedef struct
81  {
82      uint8_t * p_data; 
83      size_t    bytes;  
84  } nrfx_uarte_xfer_evt_t;
85  typedef struct
86  {
87      nrfx_uarte_xfer_evt_t rxtx;       
88      uint32_t              error_mask; 
89  } nrfx_uarte_error_evt_t;
90  typedef struct
91  {
</span>92      nrfx_uarte_evt_type_t type; 
93      union
94      {
95          nrfx_uarte_xfer_evt_t  rxtx;  
96          nrfx_uarte_error_evt_t error; 
97      } data;                           
98  } nrfx_uarte_event_t;
99  typedef void (*nrfx_uarte_event_handler_t)(nrfx_uarte_event_t const * p_event,
100                                             void *                     p_context);
101  nrfx_err_t nrfx_uarte_init(nrfx_uarte_t const *        p_instance,
102                             nrfx_uarte_config_t const * p_config,
103                             nrfx_uarte_event_handler_t  event_handler);
104  void nrfx_uarte_uninit(nrfx_uarte_t const * p_instance);
105  NRFX_STATIC_INLINE uint32_t nrfx_uarte_task_address_get(nrfx_uarte_t const * p_instance,
106                                                          nrf_uarte_task_t     task);
107  NRFX_STATIC_INLINE uint32_t nrfx_uarte_event_address_get(nrfx_uarte_t const * p_instance,
108                                                           nrf_uarte_event_t    event);
109  nrfx_err_t nrfx_uarte_tx(nrfx_uarte_t const * p_instance,
110                           uint8_t const *      p_data,
111                           size_t               length);
112  bool nrfx_uarte_tx_in_progress(nrfx_uarte_t const * p_instance);
113  void nrfx_uarte_tx_abort(nrfx_uarte_t const * p_instance);
114  nrfx_err_t nrfx_uarte_rx(nrfx_uarte_t const * p_instance,
115                           uint8_t *            p_data,
116                           size_t               length);
117  bool nrfx_uarte_rx_ready(nrfx_uarte_t const * p_instance);
118  void nrfx_uarte_rx_abort(nrfx_uarte_t const * p_instance);
119  uint32_t nrfx_uarte_errorsrc_get(nrfx_uarte_t const * p_instance);
120  #ifndef NRFX_DECLARE_ONLY
121  NRFX_STATIC_INLINE uint32_t nrfx_uarte_task_address_get(nrfx_uarte_t const * p_instance,
122                                                          nrf_uarte_task_t     task)
123  {
124      return nrf_uarte_task_address_get(p_instance->p_reg, task);
125  }
126  NRFX_STATIC_INLINE uint32_t nrfx_uarte_event_address_get(nrfx_uarte_t const * p_instance,
127                                                           nrf_uarte_event_t    event)
128  {
129      return nrf_uarte_event_address_get(p_instance->p_reg, event);
130  }
131  #endif 
132  void nrfx_uarte_0_irq_handler(void);
133  void nrfx_uarte_1_irq_handler(void);
134  void nrfx_uarte_2_irq_handler(void);
135  void nrfx_uarte_3_irq_handler(void);
136  #ifdef __cplusplus
137  }
138  #endif
139  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_power.h</h3>
            <pre><code>1  #ifndef NRFX_POWER_H__
2  #define NRFX_POWER_H__
3  #include <nrfx.h>
4  #include <hal/nrf_power.h>
5  #include <nrfx_power_clock.h>
6  #include "nrfx_power_compat.h"
7  #ifdef __cplusplus
8  extern "C" {
9  #endif
10  #if NRF_POWER_HAS_POFCON || NRFX_CHECK(NRF_REGULATORS_HAS_POFCON) || defined(__NRFX_DOXYGEN__)
11  #define NRFX_POWER_SUPPORTS_POFCON 1
12  #else
13  #define NRFX_POWER_SUPPORTS_POFCON 0
14  #endif
15  #if NRF_POWER_HAS_POFCON_VDDH || NRFX_CHECK(NRF_REGULATORS_HAS_POFCON_VDDH) || \
16      defined(__NRFX_DOXYGEN__)
17  #define NRFX_POWER_SUPPORTS_POFCON_VDDH 1
18  #else
19  #define NRFX_POWER_SUPPORTS_POFCON_VDDH 0
20  #endif
21  #if NRF_POWER_HAS_DCDCEN_VDDH || NRFX_CHECK(NRF_REGULATORS_HAS_DCDCEN_VDDH) || \
22      defined(__NRFX_DOXYGEN__)
23  #define NRFX_POWER_SUPPORTS_DCDCEN_VDDH 1
24  #else
25  #define NRFX_POWER_SUPPORTS_DCDCEN_VDDH 0
26  #endif
27  typedef enum
28  {
29      NRFX_POWER_MODE_CONSTLAT, &bsol;**< Constant latency mode */
30      NRFX_POWER_MODE_LOWPWR    &bsol;**< Low power mode        */
31  }nrfx_power_mode_t;
32  #if NRF_POWER_HAS_SLEEPEVT || defined(__NRFX_DOXYGEN__)
33  typedef enum
34  {
35      NRFX_POWER_SLEEP_EVT_ENTER, &bsol;**< CPU entered WFI/WFE sleep
36                                   *
37                                   * Keep in mind that if this interrupt is enabled,
38                                   * it means that CPU was waken up just after WFI by this interrupt.
39                                   */
40      NRFX_POWER_SLEEP_EVT_EXIT   &bsol;**< CPU exited WFI/WFE sleep */
41  }nrfx_power_sleep_evt_t;
42  #endif &bsol;* NRF_POWER_HAS_SLEEPEVT */
43  #if NRF_POWER_HAS_USBREG || defined(__NRFX_DOXYGEN__)
44  typedef enum
45  {
46      NRFX_POWER_USB_EVT_DETECTED, &bsol;**< USB power detected on the connector (plugged in). */
47      NRFX_POWER_USB_EVT_REMOVED,  &bsol;**< USB power removed from the connector. */
48      NRFX_POWER_USB_EVT_READY     &bsol;**< USB power regulator ready. */
49  }nrfx_power_usb_evt_t;
50  typedef enum
51  {
52      NRFX_POWER_USB_STATE_DISCONNECTED, &bsol;**< No power on USB lines detected. */
53      NRFX_POWER_USB_STATE_CONNECTED,    &bsol;**< The USB power is detected, but USB power regulator is not ready. */
54      NRFX_POWER_USB_STATE_READY         &bsol;**< From the power viewpoint, USB is ready for working. */
55  }nrfx_power_usb_state_t;
56  #endif 
57  typedef void (*nrfx_power_pofwarn_event_handler_t)(void);
58  #if NRF_POWER_HAS_SLEEPEVT || defined(__NRFX_DOXYGEN__)
59  typedef void (*nrfx_power_sleep_event_handler_t)(nrfx_power_sleep_evt_t event);
60  #endif
61  #if NRF_POWER_HAS_USBREG || defined(__NRFX_DOXYGEN__)
62  typedef void (*nrfx_power_usb_event_handler_t)(nrfx_power_usb_evt_t event);
63  #endif
<span onclick='openModal()' class='match'>64  typedef struct
65  {
66      bool dcdcen:1;
67  #if NRFX_POWER_SUPPORTS_DCDCEN_VDDH
68      bool dcdcenhv: 1;
69  #endif
70  }nrfx_power_config_t;
71  typedef struct
72  {
73      nrfx_power_pofwarn_event_handler_t handler; 
74  #if NRFX_POWER_SUPPORTS_POFCON
75      nrf_power_pof_thr_t                thr;     
76  #endif
77  #if NRFX_POWER_SUPPORTS_POFCON_VDDH
78      nrf_power_pof_thrvddh_t            thrvddh; 
79  #endif
80  }nrfx_power_pofwarn_config_t;
81  #if NRF_POWER_HAS_SLEEPEVT || defined(__NRFX_DOXYGEN__)
82  typedef struct
83  {
84      nrfx_power_sleep_event_handler_t handler;    
85      bool                             en_enter:1; 
86      bool                             en_exit :1; 
87  }nrfx_power_sleepevt_config_t;
88  #endif
89  #if NRF_POWER_HAS_USBREG || defined(__NRFX_DOXYGEN__)
90  typedef struct
91  {
</span>92      nrfx_power_usb_event_handler_t handler; 
93  }nrfx_power_usbevt_config_t;
94  #endif 
95  nrfx_power_pofwarn_event_handler_t nrfx_power_pof_handler_get(void);
96  #if NRF_POWER_HAS_USBREG || defined(__NRFX_DOXYGEN__)
97  nrfx_power_usb_event_handler_t nrfx_power_usb_handler_get(void);
98  #endif 
99  nrfx_err_t nrfx_power_init(nrfx_power_config_t const * p_config);
100  void nrfx_power_uninit(void);
101  #if NRFX_POWER_SUPPORTS_POFCON
102  void nrfx_power_pof_init(nrfx_power_pofwarn_config_t const * p_config);
103  void nrfx_power_pof_enable(nrfx_power_pofwarn_config_t const * p_config);
104  void nrfx_power_pof_disable(void);
105  void nrfx_power_pof_uninit(void);
106  #endif 
107  #if NRF_POWER_HAS_SLEEPEVT || defined(__NRFX_DOXYGEN__)
108  void nrfx_power_sleepevt_init(nrfx_power_sleepevt_config_t const * p_config);
109  void nrfx_power_sleepevt_enable(nrfx_power_sleepevt_config_t const * p_config);
110  void nrfx_power_sleepevt_disable(void);
111  void nrfx_power_sleepevt_uninit(void);
112  #endif &bsol;* NRF_POWER_HAS_SLEEPEVT */
113  #if NRF_POWER_HAS_USBREG || defined(__NRFX_DOXYGEN__)
114  void nrfx_power_usbevt_init(nrfx_power_usbevt_config_t const * p_config);
115  void nrfx_power_usbevt_enable(void);
116  void nrfx_power_usbevt_disable(void);
117  void nrfx_power_usbevt_uninit(void);
118  NRFX_STATIC_INLINE nrfx_power_usb_state_t nrfx_power_usbstatus_get(void);
119  #endif 
120  #ifndef NRFX_DECLARE_ONLY
121  #if NRF_POWER_HAS_USBREG
122  NRFX_STATIC_INLINE nrfx_power_usb_state_t nrfx_power_usbstatus_get(void)
123  {
124      uint32_t status = nrf_power_usbregstatus_get(NRF_POWER);
125      if(0 == (status & NRF_POWER_USBREGSTATUS_VBUSDETECT_MASK))
126      {
127          return NRFX_POWER_USB_STATE_DISCONNECTED;
128      }
129      if(0 == (status & NRF_POWER_USBREGSTATUS_OUTPUTRDY_MASK))
130      {
131          return NRFX_POWER_USB_STATE_CONNECTED;
132      }
133      return NRFX_POWER_USB_STATE_READY;
134  }
135  #endif 
136  #endif 
137  void nrfx_power_irq_handler(void);
138  #ifdef __cplusplus
139  }
140  #endif
141  #endif &bsol;* NRFX_POWER_H__ */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_uarte.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_power.h</div>
                </div>
                <div class="column column_space"><pre><code>41  typedef struct
42  {
43      uint32_t             pseltxd;            
44      uint32_t             pselrxd;            
45      uint32_t             pselcts;            
46      uint32_t             pselrts;            
47      void *               p_context;          
48      nrf_uarte_baudrate_t baudrate;           
49      uint8_t              interrupt_priority; 
50      nrf_uarte_config_t   hal_cfg;            
51  } nrfx_uarte_config_t;
52  #if defined(UARTE_CONFIG_STOP_Msk) || defined(__NRFX_DOXYGEN__)
53      #define NRFX_UARTE_DEFAULT_EXTENDED_STOP_CONFIG   \
54          .stop = (nrf_uarte_stop_t)NRF_UARTE_STOP_ONE,
55  #else
56      #define NRFX_UARTE_DEFAULT_EXTENDED_STOP_CONFIG
57  #endif
58  #if defined(UARTE_CONFIG_PARITYTYPE_Msk) || defined(__NRFX_DOXYGEN__)
59      #define NRFX_UARTE_DEFAULT_EXTENDED_PARITYTYPE_CONFIG   \
60          .paritytype = NRF_UARTE_PARITYTYPE_EVEN,
61  #else
62      #define NRFX_UARTE_DEFAULT_EXTENDED_PARITYTYPE_CONFIG
63  #endif
64  #define NRFX_UARTE_DEFAULT_CONFIG(_pin_tx, _pin_rx)                                 \
65  {                                                                                   \
66      .pseltxd            = _pin_tx,                                                  \
67      .pselrxd            = _pin_rx,                                                  \
68      .pselcts            = NRF_UARTE_PSEL_DISCONNECTED,                              \
69      .pselrts            = NRF_UARTE_PSEL_DISCONNECTED,                              \
70      .p_context          = NULL,                                                     \
71      .baudrate           = NRF_UARTE_BAUDRATE_115200,                                \
72      .interrupt_priority = NRFX_UARTE_DEFAULT_CONFIG_IRQ_PRIORITY,                   \
73      .hal_cfg            = {                                                         \
74          .hwfc           = NRF_UARTE_HWFC_DISABLED,                                  \
75          .parity         = NRF_UARTE_PARITY_EXCLUDED,                                \
76          NRFX_UARTE_DEFAULT_EXTENDED_STOP_CONFIG                                     \
77          NRFX_UARTE_DEFAULT_EXTENDED_PARITYTYPE_CONFIG                               \
78      }                                                                               \
79  }
80  typedef struct
81  {
82      uint8_t * p_data; 
83      size_t    bytes;  
84  } nrfx_uarte_xfer_evt_t;
85  typedef struct
86  {
87      nrfx_uarte_xfer_evt_t rxtx;       
88      uint32_t              error_mask; 
89  } nrfx_uarte_error_evt_t;
90  typedef struct
91  {
</pre></code></div>
                <div class="column column_space"><pre><code>64  typedef struct
65  {
66      bool dcdcen:1;
67  #if NRFX_POWER_SUPPORTS_DCDCEN_VDDH
68      bool dcdcenhv: 1;
69  #endif
70  }nrfx_power_config_t;
71  typedef struct
72  {
73      nrfx_power_pofwarn_event_handler_t handler; 
74  #if NRFX_POWER_SUPPORTS_POFCON
75      nrf_power_pof_thr_t                thr;     
76  #endif
77  #if NRFX_POWER_SUPPORTS_POFCON_VDDH
78      nrf_power_pof_thrvddh_t            thrvddh; 
79  #endif
80  }nrfx_power_pofwarn_config_t;
81  #if NRF_POWER_HAS_SLEEPEVT || defined(__NRFX_DOXYGEN__)
82  typedef struct
83  {
84      nrfx_power_sleep_event_handler_t handler;    
85      bool                             en_enter:1; 
86      bool                             en_exit :1; 
87  }nrfx_power_sleepevt_config_t;
88  #endif
89  #if NRF_POWER_HAS_USBREG || defined(__NRFX_DOXYGEN__)
90  typedef struct
91  {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    