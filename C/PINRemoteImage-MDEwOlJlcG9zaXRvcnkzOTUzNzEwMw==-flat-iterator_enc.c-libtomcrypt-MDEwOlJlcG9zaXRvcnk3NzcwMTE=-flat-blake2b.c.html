
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.307692307692308%, Tokens: 8</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-iterator_enc.c</h3>
            <pre><code>1  #include <string.h>
2  #include "src/enc/vp8i_enc.h"
3  static void InitLeft(VP8EncIterator* const it) {
4    it->y_left_[-1] = it->u_left_[-1] = it->v_left_[-1] =
5        (it->y_ > 0) ? 129 : 127;
6    memset(it->y_left_, 129, 16);
7    memset(it->u_left_, 129, 8);
8    memset(it->v_left_, 129, 8);
9    it->left_nz_[8] = 0;
10    if (it->top_derr_ != NULL) {
11      memset(&it->left_derr_, 0, sizeof(it->left_derr_));
12    }
13  }
14  static void InitTop(VP8EncIterator* const it) {
15    const VP8Encoder* const enc = it->enc_;
16    const size_t top_size = enc->mb_w_ * 16;
17    memset(enc->y_top_, 127, 2 * top_size);
18    memset(enc->nz_, 0, enc->mb_w_ * sizeof(*enc->nz_));
19    if (enc->top_derr_ != NULL) {
20      memset(enc->top_derr_, 0, enc->mb_w_ * sizeof(*enc->top_derr_));
21    }
22  }
23  void VP8IteratorSetRow(VP8EncIterator* const it, int y) {
24    VP8Encoder* const enc = it->enc_;
25    it->x_ = 0;
26    it->y_ = y;
27    it->bw_ = &enc->parts_[y & (enc->num_parts_ - 1)];
28    it->preds_ = enc->preds_ + y * 4 * enc->preds_w_;
29    it->nz_ = enc->nz_;
30    it->mb_ = enc->mb_info_ + y * enc->mb_w_;
31    it->y_top_ = enc->y_top_;
32    it->uv_top_ = enc->uv_top_;
33    InitLeft(it);
34  }
35  void VP8IteratorReset(VP8EncIterator* const it) {
36    VP8Encoder* const enc = it->enc_;
37    VP8IteratorSetRow(it, 0);
38    VP8IteratorSetCountDown(it, enc->mb_w_ * enc->mb_h_);  
39    InitTop(it);
40    memset(it->bit_count_, 0, sizeof(it->bit_count_));
41    it->do_trellis_ = 0;
42  }
43  void VP8IteratorSetCountDown(VP8EncIterator* const it, int count_down) {
44    it->count_down_ = it->count_down0_ = count_down;
45  }
46  int VP8IteratorIsDone(const VP8EncIterator* const it) {
47    return (it->count_down_ <= 0);
48  }
49  void VP8IteratorInit(VP8Encoder* const enc, VP8EncIterator* const it) {
50    it->enc_ = enc;
51    it->yuv_in_   = (uint8_t*)WEBP_ALIGN(it->yuv_mem_);
52    it->yuv_out_  = it->yuv_in_ + YUV_SIZE_ENC;
53    it->yuv_out2_ = it->yuv_out_ + YUV_SIZE_ENC;
54    it->yuv_p_    = it->yuv_out2_ + YUV_SIZE_ENC;
55    it->lf_stats_ = enc->lf_stats_;
56    it->percent0_ = enc->percent_;
57    it->y_left_ = (uint8_t*)WEBP_ALIGN(it->yuv_left_mem_ + 1);
58    it->u_left_ = it->y_left_ + 16 + 16;
59    it->v_left_ = it->u_left_ + 16;
60    it->top_derr_ = enc->top_derr_;
61    VP8IteratorReset(it);
62  }
63  int VP8IteratorProgress(const VP8EncIterator* const it, int delta) {
64    VP8Encoder* const enc = it->enc_;
65    if (delta && enc->pic_->progress_hook != NULL) {
66      const int done = it->count_down0_ - it->count_down_;
67      const int percent = (it->count_down0_ <= 0)
68                        ? it->percent0_
69                        : it->percent0_ + delta * done / it->count_down0_;
70      return WebPReportProgress(enc->pic_, percent, &enc->percent_);
71    }
72    return 1;
73  }
74  static WEBP_INLINE int MinSize(int a, int b) { return (a < b) ? a : b; }
75  static void ImportBlock(const uint8_t* src, int src_stride,
76                          uint8_t* dst, int w, int h, int size) {
77    int i;
78    for (i = 0; i < h; ++i) {
79      memcpy(dst, src, w);
80      if (w < size) {
81        memset(dst + w, dst[w - 1], size - w);
82      }
83      dst += BPS;
84      src += src_stride;
85    }
86    for (i = h; i < size; ++i) {
87      memcpy(dst, dst - BPS, size);
88      dst += BPS;
89    }
90  }
91  static void ImportLine(const uint8_t* src, int src_stride,
92                         uint8_t* dst, int len, int total_len) {
93    int i;
94    for (i = 0; i < len; ++i, src += src_stride) dst[i] = *src;
95    for (; i < total_len; ++i) dst[i] = dst[len - 1];
96  }
97  void VP8IteratorImport(VP8EncIterator* const it, uint8_t* const tmp_32) {
98    const VP8Encoder* const enc = it->enc_;
99    const int x = it->x_, y = it->y_;
100    const WebPPicture* const pic = enc->pic_;
101    const uint8_t* const ysrc = pic->y + (y * pic->y_stride  + x) * 16;
102    const uint8_t* const usrc = pic->u + (y * pic->uv_stride + x) * 8;
103    const uint8_t* const vsrc = pic->v + (y * pic->uv_stride + x) * 8;
104    const int w = MinSize(pic->width - x * 16, 16);
105    const int h = MinSize(pic->height - y * 16, 16);
106    const int uv_w = (w + 1) >> 1;
107    const int uv_h = (h + 1) >> 1;
108    ImportBlock(ysrc, pic->y_stride,  it->yuv_in_ + Y_OFF_ENC, w, h, 16);
109    ImportBlock(usrc, pic->uv_stride, it->yuv_in_ + U_OFF_ENC, uv_w, uv_h, 8);
110    ImportBlock(vsrc, pic->uv_stride, it->yuv_in_ + V_OFF_ENC, uv_w, uv_h, 8);
111    if (tmp_32 == NULL) return;
112    if (x == 0) {
113      InitLeft(it);
114    } else {
115      if (y == 0) {
116        it->y_left_[-1] = it->u_left_[-1] = it->v_left_[-1] = 127;
117      } else {
118        it->y_left_[-1] = ysrc[- 1 - pic->y_stride];
119        it->u_left_[-1] = usrc[- 1 - pic->uv_stride];
120        it->v_left_[-1] = vsrc[- 1 - pic->uv_stride];
121      }
122      ImportLine(ysrc - 1, pic->y_stride,  it->y_left_, h,   16);
123      ImportLine(usrc - 1, pic->uv_stride, it->u_left_, uv_h, 8);
124      ImportLine(vsrc - 1, pic->uv_stride, it->v_left_, uv_h, 8);
125    }
126    it->y_top_  = tmp_32 + 0;
127    it->uv_top_ = tmp_32 + 16;
128    if (y == 0) {
129      memset(tmp_32, 127, 32 * sizeof(*tmp_32));
130    } else {
131      ImportLine(ysrc - pic->y_stride,  1, tmp_32,          w,   16);
132      ImportLine(usrc - pic->uv_stride, 1, tmp_32 + 16,     uv_w, 8);
133      ImportLine(vsrc - pic->uv_stride, 1, tmp_32 + 16 + 8, uv_w, 8);
134    }
135  }
136  static void ExportBlock(const uint8_t* src, uint8_t* dst, int dst_stride,
137                          int w, int h) {
138    while (h-- > 0) {
139      memcpy(dst, src, w);
140      dst += dst_stride;
141      src += BPS;
142    }
143  }
144  void VP8IteratorExport(const VP8EncIterator* const it) {
145    const VP8Encoder* const enc = it->enc_;
146    if (enc->config_->show_compressed) {
147      const int x = it->x_, y = it->y_;
148      const uint8_t* const ysrc = it->yuv_out_ + Y_OFF_ENC;
149      const uint8_t* const usrc = it->yuv_out_ + U_OFF_ENC;
150      const uint8_t* const vsrc = it->yuv_out_ + V_OFF_ENC;
151      const WebPPicture* const pic = enc->pic_;
152      uint8_t* const ydst = pic->y + (y * pic->y_stride + x) * 16;
153      uint8_t* const udst = pic->u + (y * pic->uv_stride + x) * 8;
154      uint8_t* const vdst = pic->v + (y * pic->uv_stride + x) * 8;
155      int w = (pic->width - x * 16);
156      int h = (pic->height - y * 16);
157      if (w > 16) w = 16;
158      if (h > 16) h = 16;
159      ExportBlock(ysrc, ydst, pic->y_stride, w, h);
160      {   
161        const int uv_w = (w + 1) >> 1;
162        const int uv_h = (h + 1) >> 1;
163        ExportBlock(usrc, udst, pic->uv_stride, uv_w, uv_h);
164        ExportBlock(vsrc, vdst, pic->uv_stride, uv_w, uv_h);
165      }
166    }
167  }
168  #define BIT(nz, n) (!!((nz) & (1 << (n))))
169  void VP8IteratorNzToBytes(VP8EncIterator* const it) {
170    const int tnz = it->nz_[0], lnz = it->nz_[-1];
171    int* const top_nz = it->top_nz_;
172    int* const left_nz = it->left_nz_;
173    top_nz[0] = BIT(tnz, 12);
174    top_nz[1] = BIT(tnz, 13);
175    top_nz[2] = BIT(tnz, 14);
176    top_nz[3] = BIT(tnz, 15);
177    top_nz[4] = BIT(tnz, 18);
178    top_nz[5] = BIT(tnz, 19);
179    top_nz[6] = BIT(tnz, 22);
180    top_nz[7] = BIT(tnz, 23);
181    top_nz[8] = BIT(tnz, 24);
182    left_nz[0] = BIT(lnz,  3);
183    left_nz[1] = BIT(lnz,  7);
184    left_nz[2] = BIT(lnz, 11);
185    left_nz[3] = BIT(lnz, 15);
186    left_nz[4] = BIT(lnz, 17);
187    left_nz[5] = BIT(lnz, 19);
188    left_nz[6] = BIT(lnz, 21);
189    left_nz[7] = BIT(lnz, 23);
190  }
191  void VP8IteratorBytesToNz(VP8EncIterator* const it) {
192    uint32_t nz = 0;
193    const int* const top_nz = it->top_nz_;
194    const int* const left_nz = it->left_nz_;
195    nz |= (top_nz[0] << 12) | (top_nz[1] << 13);
196    nz |= (top_nz[2] << 14) | (top_nz[3] << 15);
197    nz |= (top_nz[4] << 18) | (top_nz[5] << 19);
198    nz |= (top_nz[6] << 22) | (top_nz[7] << 23);
199    nz |= (top_nz[8] << 24);  
200    nz |= (left_nz[0] << 3) | (left_nz[1] << 7);
201    nz |= (left_nz[2] << 11);
202    nz |= (left_nz[4] << 17) | (left_nz[6] << 21);
203    *it->nz_ = nz;
204  }
205  #undef BIT
206  void VP8IteratorSaveBoundary(VP8EncIterator* const it) {
207    VP8Encoder* const enc = it->enc_;
208    const int x = it->x_, y = it->y_;
209    const uint8_t* const ysrc = it->yuv_out_ + Y_OFF_ENC;
210    const uint8_t* const uvsrc = it->yuv_out_ + U_OFF_ENC;
211    if (x < enc->mb_w_ - 1) {   
212      int i;
213      for (i = 0; i < 16; ++i) {
214        it->y_left_[i] = ysrc[15 + i * BPS];
215      }
216      for (i = 0; i < 8; ++i) {
217        it->u_left_[i] = uvsrc[7 + i * BPS];
218        it->v_left_[i] = uvsrc[15 + i * BPS];
219      }
220      it->y_left_[-1] = it->y_top_[15];
221      it->u_left_[-1] = it->uv_top_[0 + 7];
222      it->v_left_[-1] = it->uv_top_[8 + 7];
223    }
224    if (y < enc->mb_h_ - 1) {  
225      memcpy(it->y_top_, ysrc + 15 * BPS, 16);
226      memcpy(it->uv_top_, uvsrc + 7 * BPS, 8 + 8);
227    }
228  }
229  int VP8IteratorNext(VP8EncIterator* const it) {
230    if (++it->x_ == it->enc_->mb_w_) {
231      VP8IteratorSetRow(it, ++it->y_);
232    } else {
233      it->preds_ += 4;
234      it->mb_ += 1;
235      it->nz_ += 1;
236      it->y_top_ += 16;
237      it->uv_top_ += 16;
238    }
239    return (0 < --it->count_down_);
240  }
241  void VP8SetIntra16Mode(const VP8EncIterator* const it, int mode) {
242    uint8_t* preds = it->preds_;
<span onclick='openModal()' class='match'>243    int y;
244    for (y = 0; y < 4; ++y) {
245      memset(preds, mode, 4);
246      preds += it->enc_->preds_w_;
247    }
248    it->mb_->type_ = 1;
</span>249  }
250  void VP8SetIntra4Mode(const VP8EncIterator* const it, const uint8_t* modes) {
251    uint8_t* preds = it->preds_;
252    int y;
253    for (y = 4; y > 0; --y) {
254      memcpy(preds, modes, 4 * sizeof(*modes));
255      preds += it->enc_->preds_w_;
256      modes += 4;
257    }
258    it->mb_->type_ = 0;
259  }
260  void VP8SetIntraUVMode(const VP8EncIterator* const it, int mode) {
261    it->mb_->uv_mode_ = mode;
262  }
263  void VP8SetSkip(const VP8EncIterator* const it, int skip) {
264    it->mb_->skip_ = skip;
265  }
266  void VP8SetSegment(const VP8EncIterator* const it, int segment) {
267    it->mb_->segment_ = segment;
268  }
269  static const uint8_t VP8TopLeftI4[16] = {
270    17, 21, 25, 29,
271    13, 17, 21, 25,
272    9,  13, 17, 21,
273    5,   9, 13, 17
274  };
275  void VP8IteratorStartI4(VP8EncIterator* const it) {
276    const VP8Encoder* const enc = it->enc_;
277    int i;
278    it->i4_ = 0;    
279    it->i4_top_ = it->i4_boundary_ + VP8TopLeftI4[0];
280    for (i = 0; i < 17; ++i) {    
281      it->i4_boundary_[i] = it->y_left_[15 - i];
282    }
283    for (i = 0; i < 16; ++i) {    
284      it->i4_boundary_[17 + i] = it->y_top_[i];
285    }
286    if (it->x_ < enc->mb_w_ - 1) {
287      for (i = 16; i < 16 + 4; ++i) {
288        it->i4_boundary_[17 + i] = it->y_top_[i];
289      }
290    } else {    
291      for (i = 16; i < 16 + 4; ++i) {
292        it->i4_boundary_[17 + i] = it->i4_boundary_[17 + 15];
293      }
294    }
295    VP8IteratorNzToBytes(it);  
296  }
297  int VP8IteratorRotateI4(VP8EncIterator* const it,
298                          const uint8_t* const yuv_out) {
299    const uint8_t* const blk = yuv_out + VP8Scan[it->i4_];
300    uint8_t* const top = it->i4_top_;
301    int i;
302    for (i = 0; i <= 3; ++i) {
303      top[-4 + i] = blk[i + 3 * BPS];   
304    }
305    if ((it->i4_ & 3) != 3) {  
306      for (i = 0; i <= 2; ++i) {        
307        top[i] = blk[3 + (2 - i) * BPS];
308      }
309    } else {  
310      for (i = 0; i <= 3; ++i) {
311        top[i] = top[i + 4];
312      }
313    }
314    ++it->i4_;
315    if (it->i4_ == 16) {    
316      return 0;
317    }
318    it->i4_top_ = it->i4_boundary_ + VP8TopLeftI4[it->i4_];
319    return 1;
320  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2b.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BLAKE2B
3  enum blake2b_constant {
4     BLAKE2B_BLOCKBYTES = 128,
5     BLAKE2B_OUTBYTES = 64,
6     BLAKE2B_KEYBYTES = 64,
7     BLAKE2B_SALTBYTES = 16,
8     BLAKE2B_PERSONALBYTES = 16,
9     BLAKE2B_PARAM_SIZE = 64
10  };
11  enum {
12     O_DIGEST_LENGTH = 0,
13     O_KEY_LENGTH = 1,
14     O_FANOUT = 2,
15     O_DEPTH = 3,
16     O_LEAF_LENGTH = 4,
17     O_NODE_OFFSET = 8,
18     O_XOF_LENGTH = 12,
19     O_NODE_DEPTH = 16,
20     O_INNER_LENGTH = 17,
21     O_RESERVED = 18,
22     O_SALT = 32,
23     O_PERSONAL = 48
24  };
25  const struct ltc_hash_descriptor blake2b_160_desc =
26  {
27      "blake2b-160",
28      25,
29      20,
30      128,
31      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 5 },
32      11,
33      &blake2b_160_init,
34      &blake2b_process,
35      &blake2b_done,
36      &blake2b_160_test,
37      NULL
38  };
39  const struct ltc_hash_descriptor blake2b_256_desc =
40  {
41      "blake2b-256",
42      26,
43      32,
44      128,
45      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 8 },
46      11,
47      &blake2b_256_init,
48      &blake2b_process,
49      &blake2b_done,
50      &blake2b_256_test,
51      NULL
52  };
53  const struct ltc_hash_descriptor blake2b_384_desc =
54  {
55      "blake2b-384",
56      27,
57      48,
58      128,
59      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 12 },
60      11,
61      &blake2b_384_init,
62      &blake2b_process,
63      &blake2b_done,
64      &blake2b_384_test,
65      NULL
66  };
67  const struct ltc_hash_descriptor blake2b_512_desc =
68  {
69      "blake2b-512",
70      28,
71      64,
72      128,
73      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 16 },
74      11,
75      &blake2b_512_init,
76      &blake2b_process,
77      &blake2b_done,
78      &blake2b_512_test,
79      NULL
80  };
81  static const ulong64 blake2b_IV[8] =
82  {
83    CONST64(0x6a09e667f3bcc908), CONST64(0xbb67ae8584caa73b),
84    CONST64(0x3c6ef372fe94f82b), CONST64(0xa54ff53a5f1d36f1),
85    CONST64(0x510e527fade682d1), CONST64(0x9b05688c2b3e6c1f),
86    CONST64(0x1f83d9abfb41bd6b), CONST64(0x5be0cd19137e2179)
87  };
88  static const unsigned char blake2b_sigma[12][16] =
89  {
90    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
91    { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,
92    { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,
93    {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,
94    {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,
95    {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,
96    { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,
97    { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,
98    {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,
99    { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,
100    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
101    { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }
102  };
103  static void s_blake2b_set_lastnode(hash_state *md) { md->blake2b.f[1] = CONST64(0xffffffffffffffff); }
104  static int s_blake2b_is_lastblock(const hash_state *md) { return md->blake2b.f[0] != 0; }
105  static void s_blake2b_set_lastblock(hash_state *md)
106  {
107     if (md->blake2b.last_node) {
108        s_blake2b_set_lastnode(md);
109     }
110     md->blake2b.f[0] = CONST64(0xffffffffffffffff);
111  }
112  static void s_blake2b_increment_counter(hash_state *md, ulong64 inc)
113  {
114     md->blake2b.t[0] += inc;
115     if (md->blake2b.t[0] < inc) md->blake2b.t[1]++;
116  }
117  static void s_blake2b_init0(hash_state *md)
118  {
119     unsigned long i;
120     XMEMSET(&md->blake2b, 0, sizeof(md->blake2b));
121     for (i = 0; i < 8; ++i) {
122        md->blake2b.h[i] = blake2b_IV[i];
123     }
124  }
125  static int s_blake2b_init_param(hash_state *md, const unsigned char *P)
126  {
<span onclick='openModal()' class='match'>127     unsigned long i;
128     s_blake2b_init0(md);
129     for (i = 0; i < 8; ++i) {
130        ulong64 tmp;
131        LOAD64L(tmp, P + i * 8);
132        md->blake2b.h[i] ^= tmp;
133     }
134     md->blake2b.outlen = P[O_DIGEST_LENGTH];
</span>135     return CRYPT_OK;
136  }
137  int blake2b_init(hash_state *md, unsigned long outlen, const unsigned char *key, unsigned long keylen)
138  {
139     unsigned char P[BLAKE2B_PARAM_SIZE];
140     int err;
141     LTC_ARGCHK(md != NULL);
142     if ((!outlen) || (outlen > BLAKE2B_OUTBYTES)) {
143        return CRYPT_INVALID_ARG;
144     }
145     if ((key && !keylen) || (keylen && !key) || (keylen > BLAKE2B_KEYBYTES)) {
146        return CRYPT_INVALID_ARG;
147     }
148     XMEMSET(P, 0, sizeof(P));
149     P[O_DIGEST_LENGTH] = (unsigned char)outlen;
150     P[O_KEY_LENGTH] = (unsigned char)keylen;
151     P[O_FANOUT] = 1;
152     P[O_DEPTH] = 1;
153     err = s_blake2b_init_param(md, P);
154     if (err != CRYPT_OK) return err;
155     if (key) {
156        unsigned char block[BLAKE2B_BLOCKBYTES];
157        XMEMSET(block, 0, BLAKE2B_BLOCKBYTES);
158        XMEMCPY(block, key, keylen);
159        blake2b_process(md, block, BLAKE2B_BLOCKBYTES);
160  #ifdef LTC_CLEAN_STACK
161        zeromem(block, sizeof(block));
162  #endif
163     }
164     return CRYPT_OK;
165  }
166  int blake2b_160_init(hash_state *md) { return blake2b_init(md, 20, NULL, 0); }
167  int blake2b_256_init(hash_state *md) { return blake2b_init(md, 32, NULL, 0); }
168  int blake2b_384_init(hash_state *md) { return blake2b_init(md, 48, NULL, 0); }
169  int blake2b_512_init(hash_state *md) { return blake2b_init(md, 64, NULL, 0); }
170  #define G(r, i, a, b, c, d)                                                                                            \
171     do {                                                                                                                \
172        a = a + b + m[blake2b_sigma[r][2 * i + 0]];                                                                      \
173        d = ROR64(d ^ a, 32);                                                                                            \
174        c = c + d;                                                                                                       \
175        b = ROR64(b ^ c, 24);                                                                                            \
176        a = a + b + m[blake2b_sigma[r][2 * i + 1]];                                                                      \
177        d = ROR64(d ^ a, 16);                                                                                            \
178        c = c + d;                                                                                                       \
179        b = ROR64(b ^ c, 63);                                                                                            \
180     } while (0)
181  #define ROUND(r)                                                                                                       \
182     do {                                                                                                                \
183        G(r, 0, v[0], v[4], v[8], v[12]);                                                                                \
184        G(r, 1, v[1], v[5], v[9], v[13]);                                                                                \
185        G(r, 2, v[2], v[6], v[10], v[14]);                                                                               \
186        G(r, 3, v[3], v[7], v[11], v[15]);                                                                               \
187        G(r, 4, v[0], v[5], v[10], v[15]);                                                                               \
188        G(r, 5, v[1], v[6], v[11], v[12]);                                                                               \
189        G(r, 6, v[2], v[7], v[8], v[13]);                                                                                \
190        G(r, 7, v[3], v[4], v[9], v[14]);                                                                                \
191     } while (0)
192  #ifdef LTC_CLEAN_STACK
193  static int ss_blake2b_compress(hash_state *md, const unsigned char *buf)
194  #else
195  static int s_blake2b_compress(hash_state *md, const unsigned char *buf)
196  #endif
197  {
198     ulong64 m[16];
199     ulong64 v[16];
200     unsigned long i;
201     for (i = 0; i < 16; ++i) {
202        LOAD64L(m[i], buf + i * sizeof(m[i]));
203     }
204     for (i = 0; i < 8; ++i) {
205        v[i] = md->blake2b.h[i];
206     }
207     v[8] = blake2b_IV[0];
208     v[9] = blake2b_IV[1];
209     v[10] = blake2b_IV[2];
210     v[11] = blake2b_IV[3];
211     v[12] = blake2b_IV[4] ^ md->blake2b.t[0];
212     v[13] = blake2b_IV[5] ^ md->blake2b.t[1];
213     v[14] = blake2b_IV[6] ^ md->blake2b.f[0];
214     v[15] = blake2b_IV[7] ^ md->blake2b.f[1];
215     ROUND(0);
216     ROUND(1);
217     ROUND(2);
218     ROUND(3);
219     ROUND(4);
220     ROUND(5);
221     ROUND(6);
222     ROUND(7);
223     ROUND(8);
224     ROUND(9);
225     ROUND(10);
226     ROUND(11);
227     for (i = 0; i < 8; ++i) {
228        md->blake2b.h[i] = md->blake2b.h[i] ^ v[i] ^ v[i + 8];
229     }
230     return CRYPT_OK;
231  }
232  #undef G
233  #undef ROUND
234  #ifdef LTC_CLEAN_STACK
235  static int s_blake2b_compress(hash_state *md, const unsigned char *buf)
236  {
237     int err;
238     err = ss_blake2b_compress(md, buf);
239     burn_stack(sizeof(ulong64) * 32 + sizeof(unsigned long));
240     return err;
241  }
242  #endif
243  int blake2b_process(hash_state *md, const unsigned char *in, unsigned long inlen)
244  {
245     LTC_ARGCHK(md != NULL);
246     LTC_ARGCHK(in != NULL);
247     if (md->blake2b.curlen > sizeof(md->blake2b.buf)) {
248        return CRYPT_INVALID_ARG;
249     }
250     if (inlen > 0) {
251        unsigned long left = md->blake2b.curlen;
252        unsigned long fill = BLAKE2B_BLOCKBYTES - left;
253        if (inlen > fill) {
254           md->blake2b.curlen = 0;
255           XMEMCPY(md->blake2b.buf + (left % sizeof(md->blake2b.buf)), in, fill); &bsol;* Fill buffer */
256           s_blake2b_increment_counter(md, BLAKE2B_BLOCKBYTES);
257           s_blake2b_compress(md, md->blake2b.buf); &bsol;* Compress */
258           in += fill;
259           inlen -= fill;
260           while (inlen > BLAKE2B_BLOCKBYTES) {
261              s_blake2b_increment_counter(md, BLAKE2B_BLOCKBYTES);
262              s_blake2b_compress(md, in);
263              in += BLAKE2B_BLOCKBYTES;
264              inlen -= BLAKE2B_BLOCKBYTES;
265           }
266        }
267        XMEMCPY(md->blake2b.buf + md->blake2b.curlen, in, inlen);
268        md->blake2b.curlen += inlen;
269     }
270     return CRYPT_OK;
271  }
272  int blake2b_done(hash_state *md, unsigned char *out)
273  {
274     unsigned char buffer[BLAKE2B_OUTBYTES] = { 0 };
275     unsigned long i;
276     LTC_ARGCHK(md != NULL);
277     LTC_ARGCHK(out != NULL);
278     if (s_blake2b_is_lastblock(md)) {
279        return CRYPT_ERROR;
280     }
281     s_blake2b_increment_counter(md, md->blake2b.curlen);
282     s_blake2b_set_lastblock(md);
283     XMEMSET(md->blake2b.buf + md->blake2b.curlen, 0, BLAKE2B_BLOCKBYTES - md->blake2b.curlen); &bsol;* Padding */
284     s_blake2b_compress(md, md->blake2b.buf);
285     for (i = 0; i < 8; ++i) { &bsol;* Output full hash to temp buffer */
286        STORE64L(md->blake2b.h[i], buffer + i * 8);
287     }
288     XMEMCPY(out, buffer, md->blake2b.outlen);
289     zeromem(md, sizeof(hash_state));
290  #ifdef LTC_CLEAN_STACK
291     zeromem(buffer, sizeof(buffer));
292  #endif
293     return CRYPT_OK;
294  }
295  int blake2b_512_test(void)
296  {
297  #ifndef LTC_TEST
298     return CRYPT_NOP;
299  #else
300     static const struct {
301        const char *msg;
302        unsigned char hash[64];
303    } tests[] = {
304      { "",
305        { 0x78, 0x6a, 0x02, 0xf7, 0x42, 0x01, 0x59, 0x03,
306          0xc6, 0xc6, 0xfd, 0x85, 0x25, 0x52, 0xd2, 0x72,
307          0x91, 0x2f, 0x47, 0x40, 0xe1, 0x58, 0x47, 0x61,
308          0x8a, 0x86, 0xe2, 0x17, 0xf7, 0x1f, 0x54, 0x19,
309          0xd2, 0x5e, 0x10, 0x31, 0xaf, 0xee, 0x58, 0x53,
310          0x13, 0x89, 0x64, 0x44, 0x93, 0x4e, 0xb0, 0x4b,
311          0x90, 0x3a, 0x68, 0x5b, 0x14, 0x48, 0xb7, 0x55,
312          0xd5, 0x6f, 0x70, 0x1a, 0xfe, 0x9b, 0xe2, 0xce } },
313      { "abc",
314        { 0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d,
315          0x6a, 0x27, 0x97, 0xb6, 0x9f, 0x12, 0xf6, 0xe9,
316          0x4c, 0x21, 0x2f, 0x14, 0x68, 0x5a, 0xc4, 0xb7,
317          0x4b, 0x12, 0xbb, 0x6f, 0xdb, 0xff, 0xa2, 0xd1,
318          0x7d, 0x87, 0xc5, 0x39, 0x2a, 0xab, 0x79, 0x2d,
319          0xc2, 0x52, 0xd5, 0xde, 0x45, 0x33, 0xcc, 0x95,
320          0x18, 0xd3, 0x8a, 0xa8, 0xdb, 0xf1, 0x92, 0x5a,
321          0xb9, 0x23, 0x86, 0xed, 0xd4, 0x00, 0x99, 0x23 } },
322      { NULL, { 0 } }
323    };
324     int i;
325     unsigned char tmp[64];
326     hash_state md;
327     for (i = 0; tests[i].msg != NULL; i++) {
328        blake2b_512_init(&md);
329        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
330        blake2b_done(&md, tmp);
331        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_512", i)) {
332           return CRYPT_FAIL_TESTVECTOR;
333        }
334     }
335     return CRYPT_OK;
336  #endif
337  }
338  int blake2b_384_test(void)
339  {
340  #ifndef LTC_TEST
341     return CRYPT_NOP;
342  #else
343     static const struct {
344        const char *msg;
345        unsigned char hash[48];
346    } tests[] = {
347      { "",
348        { 0xb3, 0x28, 0x11, 0x42, 0x33, 0x77, 0xf5, 0x2d,
349          0x78, 0x62, 0x28, 0x6e, 0xe1, 0xa7, 0x2e, 0xe5,
350          0x40, 0x52, 0x43, 0x80, 0xfd, 0xa1, 0x72, 0x4a,
351          0x6f, 0x25, 0xd7, 0x97, 0x8c, 0x6f, 0xd3, 0x24,
352          0x4a, 0x6c, 0xaf, 0x04, 0x98, 0x81, 0x26, 0x73,
353          0xc5, 0xe0, 0x5e, 0xf5, 0x83, 0x82, 0x51, 0x00 } },
354      { "abc",
355        { 0x6f, 0x56, 0xa8, 0x2c, 0x8e, 0x7e, 0xf5, 0x26,
356          0xdf, 0xe1, 0x82, 0xeb, 0x52, 0x12, 0xf7, 0xdb,
357          0x9d, 0xf1, 0x31, 0x7e, 0x57, 0x81, 0x5d, 0xbd,
358          0xa4, 0x60, 0x83, 0xfc, 0x30, 0xf5, 0x4e, 0xe6,
359          0xc6, 0x6b, 0xa8, 0x3b, 0xe6, 0x4b, 0x30, 0x2d,
360          0x7c, 0xba, 0x6c, 0xe1, 0x5b, 0xb5, 0x56, 0xf4 } },
361      { NULL, { 0 } }
362    };
363     int i;
364     unsigned char tmp[48];
365     hash_state md;
366     for (i = 0; tests[i].msg != NULL; i++) {
367        blake2b_384_init(&md);
368        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
369        blake2b_done(&md, tmp);
370        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_384", i)) {
371           return CRYPT_FAIL_TESTVECTOR;
372        }
373     }
374     return CRYPT_OK;
375  #endif
376  }
377  int blake2b_256_test(void)
378  {
379  #ifndef LTC_TEST
380     return CRYPT_NOP;
381  #else
382     static const struct {
383        const char *msg;
384        unsigned char hash[32];
385    } tests[] = {
386      { "",
387        { 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2,
388          0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1,
389          0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87,
390          0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8 } },
391      { "abc",
392        { 0xbd, 0xdd, 0x81, 0x3c, 0x63, 0x42, 0x39, 0x72,
393          0x31, 0x71, 0xef, 0x3f, 0xee, 0x98, 0x57, 0x9b,
394          0x94, 0x96, 0x4e, 0x3b, 0xb1, 0xcb, 0x3e, 0x42,
395          0x72, 0x62, 0xc8, 0xc0, 0x68, 0xd5, 0x23, 0x19 } },
396      { "12345678901234567890123456789012345678901234567890"
397        "12345678901234567890123456789012345678901234567890"
398        "12345678901234567890123456789012345678901234567890"
399        "12345678901234567890123456789012345678901234567890"
400        "12345678901234567890123456789012345678901234567890"
401        "12345678901234567890123456789012345678901234567890",
402        { 0x0f, 0x6e, 0x01, 0x8d, 0x38, 0xd6, 0x3f, 0x08,
403          0x4d, 0x58, 0xe3, 0x0c, 0x90, 0xfb, 0xa2, 0x41,
404          0x5f, 0xca, 0x17, 0xfa, 0x66, 0x26, 0x49, 0xf3,
405          0x8a, 0x30, 0x41, 0x7c, 0x57, 0xcd, 0xa8, 0x14 } },
406      { NULL, { 0 } }
407    };
408     int i;
409     unsigned char tmp[32];
410     hash_state md;
411     for (i = 0; tests[i].msg != NULL; i++) {
412        blake2b_256_init(&md);
413        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
414        blake2b_done(&md, tmp);
415        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_256", i)) {
416           return CRYPT_FAIL_TESTVECTOR;
417        }
418     }
419     return CRYPT_OK;
420  #endif
421  }
422  int blake2b_160_test(void)
423  {
424  #ifndef LTC_TEST
425     return CRYPT_NOP;
426  #else
427     static const struct {
428        const char *msg;
429        unsigned char hash[20];
430    } tests[] = {
431      { "",
432        { 0x33, 0x45, 0x52, 0x4a, 0xbf, 0x6b, 0xbe, 0x18,
433          0x09, 0x44, 0x92, 0x24, 0xb5, 0x97, 0x2c, 0x41,
434          0x79, 0x0b, 0x6c, 0xf2 } },
435      { "abc",
436        { 0x38, 0x42, 0x64, 0xf6, 0x76, 0xf3, 0x95, 0x36,
437          0x84, 0x05, 0x23, 0xf2, 0x84, 0x92, 0x1c, 0xdc,
438          0x68, 0xb6, 0x84, 0x6b } },
439      { NULL, { 0 } }
440    };
441     int i;
442     unsigned char tmp[20];
443     hash_state md;
444     for (i = 0; tests[i].msg != NULL; i++) {
445        blake2b_160_init(&md);
446        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
447        blake2b_done(&md, tmp);
448        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_160", i)) {
449           return CRYPT_FAIL_TESTVECTOR;
450        }
451     }
452     return CRYPT_OK;
453  #endif
454  }
455  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-iterator_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2b.c</div>
                </div>
                <div class="column column_space"><pre><code>243    int y;
244    for (y = 0; y < 4; ++y) {
245      memset(preds, mode, 4);
246      preds += it->enc_->preds_w_;
247    }
248    it->mb_->type_ = 1;
</pre></code></div>
                <div class="column column_space"><pre><code>127     unsigned long i;
128     s_blake2b_init0(md);
129     for (i = 0; i < 8; ++i) {
130        ulong64 tmp;
131        LOAD64L(tmp, P + i * 8);
132        md->blake2b.h[i] ^= tmp;
133     }
134     md->blake2b.outlen = P[O_DIGEST_LENGTH];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    