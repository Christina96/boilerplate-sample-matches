
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 49, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sentinel.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/Win32_Error.h&quot;
3  #endif
4  #include &quot;server.h&quot;
5  #ifndef _WIN32          
6  #include &quot;hiredis.h&quot;
7  #endif
8  #include &quot;async.h&quot;
9  #include &lt;ctype.h&gt;
10  #ifndef _WIN32
11  #include &lt;arpa/inet.h&gt;
12  #include &lt;sys/socket.h&gt;
13  #include &lt;sys/wait.h&gt;
14  #else
15  #include &lt;stdlib.h&gt;
16  #endif
17  #include &lt;fcntl.h&gt;
18  #ifdef _WIN32
19  #define strtoull _strtoui64
20  #endif
21  #ifndef _WIN32
22  extern char **environ;
23  #endif
24  #define REDIS_SENTINEL_PORT 26379
25  typedef struct sentinelAddr {
26      char *ip;
27      int port;
28  } sentinelAddr;
29  #define SRI_MASTER  (1&lt;&lt;0)
30  #define SRI_SLAVE   (1&lt;&lt;1)
31  #define SRI_SENTINEL (1&lt;&lt;2)
32  #define SRI_S_DOWN (1&lt;&lt;3)   &amp;bsol;* Subjectively down (no quorum). */
33  #define SRI_O_DOWN (1&lt;&lt;4)   &amp;bsol;* Objectively down (confirmed by others). */
34  #define SRI_MASTER_DOWN (1&lt;&lt;5) &amp;bsol;* A Sentinel with this flag set thinks that
35                                     its master is down. */
36  #define SRI_FAILOVER_IN_PROGRESS (1&lt;&lt;6) &amp;bsol;* Failover is in progress for
37                                             this master. */
38  #define SRI_PROMOTED (1&lt;&lt;7)            &amp;bsol;* Slave selected for promotion. */
39  #define SRI_RECONF_SENT (1&lt;&lt;8)     &amp;bsol;* SLAVEOF &lt;newmaster&gt; sent. */
40  #define SRI_RECONF_INPROG (1&lt;&lt;9)   &amp;bsol;* Slave synchronization in progress. */
41  #define SRI_RECONF_DONE (1&lt;&lt;10)     &amp;bsol;* Slave synchronized with new master. */
42  #define SRI_FORCE_FAILOVER (1&lt;&lt;11)  &amp;bsol;* Force failover with master up. */
43  #define SRI_SCRIPT_KILL_SENT (1&lt;&lt;12) &amp;bsol;* SCRIPT KILL already sent on -BUSY */
44  #define SENTINEL_INFO_PERIOD 10000
45  #define SENTINEL_PING_PERIOD 1000
46  #define SENTINEL_ASK_PERIOD 1000
47  #define SENTINEL_PUBLISH_PERIOD 2000
48  #define SENTINEL_DEFAULT_DOWN_AFTER 30000
49  #define SENTINEL_HELLO_CHANNEL &quot;__sentinel__:hello&quot;
50  #define SENTINEL_TILT_TRIGGER 2000
51  #define SENTINEL_TILT_PERIOD (SENTINEL_PING_PERIOD*30)
52  #define SENTINEL_DEFAULT_SLAVE_PRIORITY 100
53  #define SENTINEL_SLAVE_RECONF_TIMEOUT 10000
54  #define SENTINEL_DEFAULT_PARALLEL_SYNCS 1
55  #define SENTINEL_MIN_LINK_RECONNECT_PERIOD 15000
56  #define SENTINEL_DEFAULT_FAILOVER_TIMEOUT (60*3*1000)
57  #define SENTINEL_MAX_PENDING_COMMANDS 100
58  #define SENTINEL_ELECTION_TIMEOUT 10000
59  #define SENTINEL_MAX_DESYNC 1000
60  #define SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG 1
61  #define SENTINEL_FAILOVER_STATE_NONE 0  &amp;bsol;* No failover in progress. */
62  #define SENTINEL_FAILOVER_STATE_WAIT_START 1  &amp;bsol;* Wait for failover_start_time*/
63  #define SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 &amp;bsol;* Select slave to promote */
64  #define SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 &amp;bsol;* Slave -&gt; Master */
65  #define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 &amp;bsol;* Wait slave to change role */
66  #define SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 &amp;bsol;* SLAVEOF newmaster */
67  #define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 &amp;bsol;* Monitor promoted slave. */
68  #define SENTINEL_MASTER_LINK_STATUS_UP 0
69  #define SENTINEL_MASTER_LINK_STATUS_DOWN 1
70  #define SENTINEL_NO_FLAGS 0
71  #define SENTINEL_GENERATE_EVENT (1&lt;&lt;16)
72  #define SENTINEL_LEADER (1&lt;&lt;17)
73  #define SENTINEL_OBSERVER (1&lt;&lt;18)
74  #define SENTINEL_SCRIPT_NONE 0
75  #define SENTINEL_SCRIPT_RUNNING 1
76  #define SENTINEL_SCRIPT_MAX_QUEUE 256
77  #define SENTINEL_SCRIPT_MAX_RUNNING 16
78  #define SENTINEL_SCRIPT_MAX_RUNTIME 60000 &amp;bsol;* 60 seconds max exec time. */
79  #define SENTINEL_SCRIPT_MAX_RETRY 10
80  #define SENTINEL_SCRIPT_RETRY_DELAY 30000 &amp;bsol;* 30 seconds between retries. */
81  #define SENTINEL_SIMFAILURE_NONE 0
82  #define SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION (1&lt;&lt;0)
83  #define SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION (1&lt;&lt;1)
84  typedef struct instanceLink {
85      int refcount;          &amp;bsol;* Number of sentinelRedisInstance owners. */
86      int disconnected;      &amp;bsol;* Non-zero if we need to reconnect cc or pc. */
87      int pending_commands;  &amp;bsol;* Number of commands sent waiting for a reply. */
88      redisAsyncContext *cc; &amp;bsol;* Hiredis context for commands. */
89      redisAsyncContext *pc; &amp;bsol;* Hiredis context for Pub / Sub. */
90      mstime_t cc_conn_time; &amp;bsol;* cc connection time. */
91      mstime_t pc_conn_time; &amp;bsol;* pc connection time. */
92      mstime_t pc_last_activity; &amp;bsol;* Last time we received any message. */
93      mstime_t last_avail_time; &amp;bsol;* Last time the instance replied to ping with
94                                   a reply we consider valid. */
95      mstime_t act_ping_time;   &amp;bsol;* Time at which the last pending ping (no pong
96                                   received after it) was sent. This field is
97                                   set to 0 when a pong is received, and set again
98                                   to the current time if the value is 0 and a new
99                                   ping is sent. */
100      mstime_t last_ping_time;  &amp;bsol;* Time at which we sent the last ping. This is
101                                   only used to avoid sending too many pings
102                                   during failure. Idle time is computed using
103                                   the act_ping_time field. */
104      mstime_t last_pong_time;  &amp;bsol;* Last time the instance replied to ping,
105                                   whatever the reply was. That&#x27;s used to check
106                                   if the link is idle and must be reconnected. */
107      mstime_t last_reconn_time;  &amp;bsol;* Last reconnection attempt performed when
108                                     the link was down. */
109  } instanceLink;
110  typedef struct sentinelRedisInstance {
111      int flags;      &amp;bsol;* See SRI_... defines */
112      char *name;     &amp;bsol;* Master name from the point of view of this sentinel. */
113      char *runid;    &amp;bsol;* Run ID of this instance, or unique ID if is a Sentinel.*/
114      uint64_t config_epoch;  &amp;bsol;* Configuration epoch. */
115      sentinelAddr *addr; &amp;bsol;* Master host. */
116      instanceLink *link; &amp;bsol;* Link to the instance, may be shared for Sentinels. */
117      mstime_t last_pub_time;   &amp;bsol;* Last time we sent hello via Pub/Sub. */
118      mstime_t last_hello_time; &amp;bsol;* Only used if SRI_SENTINEL is set. Last time
119                                   we received a hello from this Sentinel
120                                   via Pub/Sub. */
121      mstime_t last_master_down_reply_time; &amp;bsol;* Time of last reply to
122                                               SENTINEL is-master-down command. */
123      mstime_t s_down_since_time; &amp;bsol;* Subjectively down since time. */
124      mstime_t o_down_since_time; &amp;bsol;* Objectively down since time. */
125      mstime_t down_after_period; &amp;bsol;* Consider it down after that period. */
126      mstime_t info_refresh;  &amp;bsol;* Time at which we received INFO output from it. */
127      dict *renamed_commands;     &amp;bsol;* Commands renamed in this instance:
128                                     Sentinel will use the alternative commands
129                                     mapped on this table to send things like
130                                     SLAVEOF, CONFING, INFO, ... */
131      int role_reported;
132      mstime_t role_reported_time;
133      mstime_t slave_conf_change_time; &amp;bsol;* Last time slave master addr changed. */
134      dict *sentinels;    &amp;bsol;* Other sentinels monitoring the same master. */
135      dict *slaves;       &amp;bsol;* Slaves for this master instance. */
136      unsigned int quorum;&amp;bsol;* Number of sentinels that need to agree on failure. */
137      int parallel_syncs; &amp;bsol;* How many slaves to reconfigure at same time. */
138      char *auth_pass;    &amp;bsol;* Password to use for AUTH against master &amp; slaves. */
139      mstime_t master_link_down_time; &amp;bsol;* Slave replication link down time. */
140      int slave_priority; &amp;bsol;* Slave priority according to its INFO output. */
141      mstime_t slave_reconf_sent_time; &amp;bsol;* Time at which we sent SLAVE OF &lt;new&gt; */
142      struct sentinelRedisInstance *master; &amp;bsol;* Master instance if it&#x27;s slave. */
143      char *slave_master_host;    &amp;bsol;* Master host as reported by INFO */
144      int slave_master_port;      &amp;bsol;* Master port as reported by INFO */
145      int slave_master_link_status; &amp;bsol;* Master link status as reported by INFO */
146      PORT_ULONGLONG slave_repl_offset; &amp;bsol;* Slave replication offset. */
147      char *leader;       &amp;bsol;* If this is a master instance, this is the runid of
148                             the Sentinel that should perform the failover. If
149                             this is a Sentinel, this is the runid of the Sentinel
150                             that this Sentinel voted as leader. */
151      uint64_t leader_epoch; &amp;bsol;* Epoch of the &#x27;leader&#x27; field. */
152      uint64_t failover_epoch; &amp;bsol;* Epoch of the currently started failover. */
153      int failover_state; &amp;bsol;* See SENTINEL_FAILOVER_STATE_* defines. */
154      mstime_t failover_state_change_time;
155      mstime_t failover_start_time;   &amp;bsol;* Last failover attempt start time. */
156      mstime_t failover_timeout;      &amp;bsol;* Max time to refresh failover state. */
157      mstime_t failover_delay_logged; &amp;bsol;* For what failover_start_time value we
158                                         logged the failover delay. */
159      struct sentinelRedisInstance *promoted_slave; &amp;bsol;* Promoted slave instance. */
160      char *notification_script;
161      char *client_reconfig_script;
162      sds info; &amp;bsol;* cached INFO output */
163  } sentinelRedisInstance;
164  struct sentinelState {
165      char myid[CONFIG_RUN_ID_SIZE+1]; &amp;bsol;* This sentinel ID. */
166      uint64_t current_epoch;         &amp;bsol;* Current epoch. */
167      dict *masters;      &amp;bsol;* Dictionary of master sentinelRedisInstances.
168                             Key is the instance name, value is the
169                             sentinelRedisInstance structure pointer. */
170      int tilt;           &amp;bsol;* Are we in TILT mode? */
171      int running_scripts;    &amp;bsol;* Number of scripts in execution right now. */
172      mstime_t tilt_start_time;       &amp;bsol;* When TITL started. */
173      mstime_t previous_time;         &amp;bsol;* Last time we ran the time handler. */
174      list *scripts_queue;            &amp;bsol;* Queue of user scripts to execute. */
175      char *announce_ip;  &amp;bsol;* IP addr that is gossiped to other sentinels if
176                             not NULL. */
177      int announce_port;  &amp;bsol;* Port that is gossiped to other sentinels if
178                             non zero. */
179      PORT_ULONG simfailure_flags; &amp;bsol;* Failures simulation. */
180      int deny_scripts_reconfig; &amp;bsol;* Allow SENTINEL SET ... to change script
181                                    paths at runtime? */
182  } sentinel;
183  typedef struct sentinelScriptJob {
184      int flags;              &amp;bsol;* Script job flags: SENTINEL_SCRIPT_* */
185      int retry_num;          &amp;bsol;* Number of times we tried to execute it. */
186      char **argv;            &amp;bsol;* Arguments to call the script. */
187      mstime_t start_time;    &amp;bsol;* Script execution time if the script is running,
188                                 otherwise 0 if we are allowed to retry the
189                                 execution at any time. If the script is not
190                                 running and it&#x27;s not 0, it means: do not run
191                                 before the specified time. */
192  #ifdef _WIN32
193      HANDLE hScriptProcess;  &amp;bsol;* handle of process executing script */
194  #endif
195      pid_t pid;              &amp;bsol;* Script execution pid. */
196  } sentinelScriptJob;
197  typedef struct redisAeEvents {
198      redisAsyncContext *context;
199      aeEventLoop *loop;
200      int fd;
201      int reading, writing;
202  } redisAeEvents;
203  static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
204      ((void)el); ((void)fd); ((void)mask);
205      redisAeEvents *e = (redisAeEvents*)privdata;
206      redisAsyncHandleRead(e-&gt;context);
207      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
208  }
209  #ifdef _WIN32
210  static void writeHandlerDone(aeEventLoop *el, int fd, void *privdata, int nwritten) {
211      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
212      redisAeEvents *e = (redisAeEvents *) req-&gt;client;
213      redisAsyncHandleWriteComplete(e-&gt;context, nwritten);
214  }
215  static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
216      redisAeEvents *e = (redisAeEvents*)privdata;
217      redisContext *c = &amp;(e-&gt;context-&gt;c);
218      int result;
219      ((void)el); ((void)fd); ((void)mask);
220      if (redisAsyncHandleWritePrep(e-&gt;context) == C_OK) {
221          result = WSIOCP_SocketSend((int) c-&gt;fd,
222                                     (char*) c-&gt;obuf,
223                                     (int) (sdslen(c-&gt;obuf)),
224                                     el,
225                                     e,
226                                     NULL,
227                                     writeHandlerDone);
228          if (result == SOCKET_ERROR &amp;&amp; errno != WSA_IO_PENDING) {
229              if (errno != EPIPE) {
230                  serverLog(LL_VERBOSE, &quot;Writing to socket %s (%d)\n&quot;, wsa_strerror(errno), errno);
231              }
232              return;
233          }
234      }
235  }
236  #else
237  static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
238      ((void)el); ((void)fd); ((void)mask);
239      redisAeEvents *e = (redisAeEvents*)privdata;
240      redisAsyncHandleWrite(e-&gt;context);
241  }
242  #endif
243  static void redisAeAddRead(void *privdata) {
244      redisAeEvents *e = (redisAeEvents*)privdata;
245      aeEventLoop *loop = e-&gt;loop;
246      if (!e-&gt;reading) {
247          e-&gt;reading = 1;
248          aeCreateFileEvent(loop,e-&gt;fd,AE_READABLE,redisAeReadEvent,e);
249      }
250  }
251  static void redisAeDelRead(void *privdata) {
252      redisAeEvents *e = (redisAeEvents*)privdata;
253      aeEventLoop *loop = e-&gt;loop;
254      if (e-&gt;reading) {
255          e-&gt;reading = 0;
256          aeDeleteFileEvent(loop,e-&gt;fd,AE_READABLE);
257      }
258  }
259  static void redisAeAddWrite(void *privdata) {
260      redisAeEvents *e = (redisAeEvents*)privdata;
261      aeEventLoop *loop = e-&gt;loop;
262      if (!e-&gt;writing) {
263          e-&gt;writing = 1;
264          aeCreateFileEvent(loop,e-&gt;fd,AE_WRITABLE,redisAeWriteEvent,e);
265      }
266  }
267  static void redisAeDelWrite(void *privdata) {
268      redisAeEvents *e = (redisAeEvents*)privdata;
269      aeEventLoop *loop = e-&gt;loop;
270      if (e-&gt;writing) {
271          e-&gt;writing = 0;
272          aeDeleteFileEvent(loop,e-&gt;fd,AE_WRITABLE);
273      }
274  }
275  static void redisAeCleanup(void *privdata) {
276      redisAeEvents *e = (redisAeEvents*)privdata;
277      redisAeDelRead(privdata);
278      redisAeDelWrite(privdata);
279      zfree(e);
280  }
281  static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
282      redisContext *c = &amp;(ac-&gt;c);
283      redisAeEvents *e;
284      if (ac-&gt;ev.data != NULL)
285          return C_ERR;
286      e = (redisAeEvents*)zmalloc(sizeof(*e));
287      e-&gt;context = ac;
288      e-&gt;loop = loop;
289      e-&gt;fd = c-&gt;fd;
290      e-&gt;reading = e-&gt;writing = 0;
291      ac-&gt;ev.addRead = redisAeAddRead;
292      ac-&gt;ev.delRead = redisAeDelRead;
293      ac-&gt;ev.addWrite = redisAeAddWrite;
294      ac-&gt;ev.delWrite = redisAeDelWrite;
295      ac-&gt;ev.cleanup = redisAeCleanup;
296      ac-&gt;ev.data = e;
297      return C_OK;
298  }
299  void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status);
300  void sentinelDisconnectCallback(const redisAsyncContext *c, int status);
301  void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata);
302  sentinelRedisInstance *sentinelGetMasterByName(char *name);
303  char *sentinelGetSubjectiveLeader(sentinelRedisInstance *master);
304  char *sentinelGetObjectiveLeader(sentinelRedisInstance *master);
305  int yesnotoi(char *s);
306  void instanceLinkConnectionError(const redisAsyncContext *c);
307  const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri);
308  void sentinelAbortFailover(sentinelRedisInstance *ri);
309  void sentinelEvent(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...);
310  sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master);
311  void sentinelScheduleScriptExecution(char *path, ...);
312  void sentinelStartFailover(sentinelRedisInstance *master);
313  void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata);
314  int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port);
315  char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch);
316  void sentinelFlushConfig(void);
317  void sentinelGenerateInitialMonitorEvents(void);
318  int sentinelSendPing(sentinelRedisInstance *ri);
319  int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master);
320  sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid);
321  void sentinelSimFailureCrash(void);
322  uint64_t dictSdsHash(const void *key);
323  uint64_t dictSdsCaseHash(const void *key);
324  int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
325  int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);
326  void releaseSentinelRedisInstance(sentinelRedisInstance *ri);
327  void dictInstancesValDestructor (void *privdata, void *obj) {
328      UNUSED(privdata);
329      releaseSentinelRedisInstance(obj);
330  }
331  dictType instancesDictType = {
332      dictSdsHash,               &amp;bsol;* hash function */
333      NULL,                      &amp;bsol;* key dup */
334      NULL,                      &amp;bsol;* val dup */
335      dictSdsKeyCompare,         &amp;bsol;* key compare */
336      NULL,                      &amp;bsol;* key destructor */
337      dictInstancesValDestructor &amp;bsol;* val destructor */
338  };
339  dictType leaderVotesDictType = {
340      dictSdsHash,               &amp;bsol;* hash function */
341      NULL,                      &amp;bsol;* key dup */
342      NULL,                      &amp;bsol;* val dup */
343      dictSdsKeyCompare,         &amp;bsol;* key compare */
344      NULL,                      &amp;bsol;* key destructor */
345      NULL                       &amp;bsol;* val destructor */
346  };
347  dictType renamedCommandsDictType = {
348      dictSdsCaseHash,           &amp;bsol;* hash function */
349      NULL,                      &amp;bsol;* key dup */
350      NULL,                      &amp;bsol;* val dup */
351      dictSdsKeyCaseCompare,     &amp;bsol;* key compare */
352      dictSdsDestructor,         &amp;bsol;* key destructor */
353      dictSdsDestructor          &amp;bsol;* val destructor */
354  };
355  void sentinelCommand(client *c);
356  void sentinelInfoCommand(client *c);
357  void sentinelSetCommand(client *c);
358  void sentinelPublishCommand(client *c);
359  void sentinelRoleCommand(client *c);
360  struct redisCommand sentinelcmds[] = {
361      {&quot;ping&quot;,pingCommand,1,&quot;&quot;,0,NULL,0,0,0,0,0},
362      {&quot;sentinel&quot;,sentinelCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0},
363      {&quot;subscribe&quot;,subscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0},
364      {&quot;unsubscribe&quot;,unsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
365      {&quot;psubscribe&quot;,psubscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0},
366      {&quot;punsubscribe&quot;,punsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
367      {&quot;publish&quot;,sentinelPublishCommand,3,&quot;&quot;,0,NULL,0,0,0,0,0},
368      {&quot;info&quot;,sentinelInfoCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
369      {&quot;role&quot;,sentinelRoleCommand,1,&quot;l&quot;,0,NULL,0,0,0,0,0},
370      {&quot;client&quot;,clientCommand,-2,&quot;rs&quot;,0,NULL,0,0,0,0,0},
371      {&quot;shutdown&quot;,shutdownCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
372      {&quot;auth&quot;,authCommand,2,&quot;sltF&quot;,0,NULL,0,0,0,0,0}
373  };
374  void initSentinelConfig(void) {
375      server.port = REDIS_SENTINEL_PORT;
376      server.protected_mode = 0; &amp;bsol;* Sentinel must be exposed. */
377  }
378  void initSentinel(void) {
379      unsigned int j;
380      dictEmpty(server.commands,NULL);
381      for (j = 0; j &lt; sizeof(sentinelcmds)/sizeof(sentinelcmds[0]); j++) {
382          int retval;
383          struct redisCommand *cmd = sentinelcmds+j;
384          retval = dictAdd(server.commands, sdsnew(cmd-&gt;name), cmd);
385          serverAssert(retval == DICT_OK);
386      }
387      sentinel.current_epoch = 0;
388      sentinel.masters = dictCreate(&amp;instancesDictType,NULL);
389      sentinel.tilt = 0;
390      sentinel.tilt_start_time = 0;
391      sentinel.previous_time = mstime();
392      sentinel.running_scripts = 0;
393      sentinel.scripts_queue = listCreate();
394      sentinel.announce_ip = NULL;
395      sentinel.announce_port = 0;
396      sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
397      sentinel.deny_scripts_reconfig = SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG;
398      memset(sentinel.myid,0,sizeof(sentinel.myid));
399  }
400  void sentinelIsRunning(void) {
401      int j;
402      if (server.configfile == NULL) {
403          serverLog(LL_WARNING,
404              &quot;Sentinel started without a config file. Exiting...&quot;);
405          exit(1);
406      } else if (access(server.configfile,W_OK) == -1) {
407          serverLog(LL_WARNING,
408              &quot;Sentinel config file %s is not writable: %s. Exiting...&quot;,
409              server.configfile, IF_WIN32(wsa_strerror(errno), strerror(errno)));
410          exit(1);
411      }
412      for (j = 0; j &lt; CONFIG_RUN_ID_SIZE; j++)
413          if (sentinel.myid[j] != 0) break;
414      if (j == CONFIG_RUN_ID_SIZE) {
415          getRandomHexChars(sentinel.myid,CONFIG_RUN_ID_SIZE);
416          sentinelFlushConfig();
417      }
418      serverLog(LL_WARNING,&quot;Sentinel ID is %s&quot;, sentinel.myid);
419      sentinelGenerateInitialMonitorEvents();
420  }
421  sentinelAddr *createSentinelAddr(char *hostname, int port) {
422      char ip[NET_IP_STR_LEN];
423      sentinelAddr *sa;
424      if (port &lt; 0 || port &gt; 65535) {
425          errno = EINVAL;
426          return NULL;
427      }
428      if (anetResolve(NULL,hostname,ip,sizeof(ip)) == ANET_ERR) {
429          errno = ENOENT;
430          return NULL;
431      }
432      sa = zmalloc(sizeof(*sa));
433      sa-&gt;ip = sdsnew(ip);
434      sa-&gt;port = port;
435      return sa;
436  }
437  sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
438      sentinelAddr *sa;
439      sa = zmalloc(sizeof(*sa));
440      sa-&gt;ip = sdsnew(src-&gt;ip);
441      sa-&gt;port = src-&gt;port;
442      return sa;
443  }
444  void releaseSentinelAddr(sentinelAddr *sa) {
445      sdsfree(sa-&gt;ip);
446      zfree(sa);
447  }
448  int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {
449      return a-&gt;port == b-&gt;port &amp;&amp; !strcasecmp(a-&gt;ip,b-&gt;ip);
450  }
451  void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
452                     const char *fmt, ...) {
453      va_list ap;
454      char msg[LOG_MAX_LEN];
455      robj *channel, *payload;
456      if (fmt[0] == &#x27;%&#x27; &amp;&amp; fmt[1] == &#x27;@&#x27;) {
457          sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ?
458                                           NULL : ri-&gt;master;
459          if (master) {
460              snprintf(msg, sizeof(msg), &quot;%s %s %s %d @ %s %s %d&quot;,
461                  sentinelRedisInstanceTypeStr(ri),
462                  ri-&gt;name, ri-&gt;addr-&gt;ip, ri-&gt;addr-&gt;port,
463                  master-&gt;name, master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port);
464          } else {
465              snprintf(msg, sizeof(msg), &quot;%s %s %s %d&quot;,
466                  sentinelRedisInstanceTypeStr(ri),
467                  ri-&gt;name, ri-&gt;addr-&gt;ip, ri-&gt;addr-&gt;port);
468          }
469          fmt += 2;
470      } else {
471          msg[0] = &#x27;\0&#x27;;
472      }
473      if (fmt[0] != &#x27;\0&#x27;) {
474          va_start(ap, fmt);
475          vsnprintf(msg+strlen(msg), sizeof(msg)-strlen(msg), fmt, ap);
476          va_end(ap);
477      }
478      if (level &gt;= server.verbosity)
479          serverLog(level,&quot;%s %s&quot;,type,msg);
480      if (level != LL_DEBUG) {
481          channel = createStringObject(type,strlen(type));
482          payload = createStringObject(msg,strlen(msg));
483          pubsubPublishMessage(channel,payload);
484          decrRefCount(channel);
485          decrRefCount(payload);
486      }
487      if (level == LL_WARNING &amp;&amp; ri != NULL) {
488          sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ?
489                                           ri : ri-&gt;master;
490          if (master &amp;&amp; master-&gt;notification_script) {
491              sentinelScheduleScriptExecution(master-&gt;notification_script,
492                  type,msg,NULL);
493          }
494      }
495  }
496  void sentinelGenerateInitialMonitorEvents(void) {
497      dictIterator *di;
498      dictEntry *de;
499      di = dictGetIterator(sentinel.masters);
500      while((de = dictNext(di)) != NULL) {
501          sentinelRedisInstance *ri = dictGetVal(de);
502          sentinelEvent(LL_WARNING,&quot;+monitor&quot;,ri,&quot;%@ quorum %d&quot;,ri-&gt;quorum);
503      }
504      dictReleaseIterator(di);
505  }
506  void sentinelReleaseScriptJob(sentinelScriptJob *sj) {
507      int j = 0;
508      while(sj-&gt;argv[j]) sdsfree(sj-&gt;argv[j++]);
509      zfree(sj-&gt;argv);
510      zfree(sj);
511  }
512  #define SENTINEL_SCRIPT_MAX_ARGS 16
513  void sentinelScheduleScriptExecution(char *path, ...) {
514      va_list ap;
515      char *argv[SENTINEL_SCRIPT_MAX_ARGS+1];
516      int argc = 1;
517      sentinelScriptJob *sj;
518      va_start(ap, path);
519      while(argc &lt; SENTINEL_SCRIPT_MAX_ARGS) {
520          argv[argc] = va_arg(ap,char*);
521          if (!argv[argc]) break;
522          argv[argc] = sdsnew(argv[argc]); &amp;bsol;* Copy the string. */
523          argc++;
524      }
525      va_end(ap);
526      argv[0] = sdsnew(path);
527      sj = zmalloc(sizeof(*sj));
528      sj-&gt;flags = SENTINEL_SCRIPT_NONE;
529      sj-&gt;retry_num = 0;
530      sj-&gt;argv = zmalloc(sizeof(char*)*(argc+1));
531      sj-&gt;start_time = 0;
532      WIN32_ONLY(sj-&gt;hScriptProcess = INVALID_HANDLE_VALUE;)
533      sj-&gt;pid = 0;
534      memcpy(sj-&gt;argv,argv,sizeof(char*)*(argc+1));
535      listAddNodeTail(sentinel.scripts_queue,sj);
536      if (listLength(sentinel.scripts_queue) &gt; SENTINEL_SCRIPT_MAX_QUEUE) {
537          listNode *ln;
538          listIter li;
539          listRewind(sentinel.scripts_queue,&amp;li);
540          while ((ln = listNext(&amp;li)) != NULL) {
541              sj = ln-&gt;value;
542              if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) continue;
543              listDelNode(sentinel.scripts_queue,ln);
544              sentinelReleaseScriptJob(sj);
545              break;
546          }
547          serverAssert(listLength(sentinel.scripts_queue) &lt;=
548                      SENTINEL_SCRIPT_MAX_QUEUE);
549      }
550  }
551  #ifndef _WIN32
552  listNode *sentinelGetScriptListNodeByPid(pid_t pid) {
553      listNode *ln;
554      listIter li;
555      listRewind(sentinel.scripts_queue,&amp;li);
556      while ((ln = listNext(&amp;li)) != NULL) {
557          sentinelScriptJob *sj = ln-&gt;value;
558          if ((sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) &amp;&amp; sj-&gt;pid == pid)
559              return ln;
560      }
561      return NULL;
562  }
563  #endif
564  void sentinelRunPendingScripts(void) {
565      listNode *ln;
566      listIter li;
567      mstime_t now = mstime();
568      listRewind(sentinel.scripts_queue,&amp;li);
569      while (sentinel.running_scripts &lt; SENTINEL_SCRIPT_MAX_RUNNING &amp;&amp;
570             (ln = listNext(&amp;li)) != NULL)
571      {
572          sentinelScriptJob *sj = ln-&gt;value;
573          POSIX_ONLY(pid_t pid;)
574          if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) continue;
575          if (sj-&gt;start_time &amp;&amp; sj-&gt;start_time &gt; now) continue;
576          sj-&gt;flags |= SENTINEL_SCRIPT_RUNNING;
577          sj-&gt;start_time = mstime();
578          sj-&gt;retry_num++;
579  #ifdef _WIN32
580          char args[1024];
581          int j = 0;
582          int pos = 0;
583          while (sj-&gt;argv[j]) {
584              if (j == 2) {
585                  memcpy(args + pos, &quot;\&quot;&quot;, 1);
586                  pos += 1;
587              }
588              int arglen = (int) strlen(sj-&gt;argv[j]);
589              memcpy(args + pos, sj-&gt;argv[j], arglen);
590              pos += arglen;
591              if (j == 2) {
592                  memcpy(args + pos, &quot;\&quot;\0&quot;, 2);
593                  break;
594              } else {
595                  memcpy(args + pos, &quot; &quot;, 1);
596                  pos += 1;
597                  j++;
598              }
599          }
600          PROCESS_INFORMATION pi;
601          STARTUPINFO si;
602          ZeroMemory(&amp;si, sizeof(si));
603          si.cb = sizeof(si);
604          if (TRUE == CreateProcessA(NULL, args, NULL, NULL, FALSE, 0,
605                                     NULL, NULL, &amp;si, &amp;pi)) {
606              sj-&gt;hScriptProcess = pi.hProcess;
607              sj-&gt;pid = pi.dwProcessId;
608              CloseHandle(pi.hThread);
609              sentinel.running_scripts++;
610              sentinelEvent(LL_DEBUG, &quot;+script-child&quot;, NULL, &quot;%Id&quot;, 
611                            (PORT_LONG) sj-&gt;pid);
612          } else {
613              sentinelEvent(LL_WARNING, &quot;-script-error&quot;, NULL,
614                  &quot;%s %d %d&quot;, sj-&gt;argv[0], 99, 0);
615              sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;
616              sj-&gt;pid = 0;
617              sj-&gt;hScriptProcess = INVALID_HANDLE_VALUE;
618          }
619  #else
620          pid = fork();
621          if (pid == -1) {
622              sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,
623                            &quot;%s %d %d&quot;, sj-&gt;argv[0], 99, 0);
624              sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;
625              sj-&gt;pid = 0;
626          } else if (pid == 0) {
627              execve(sj-&gt;argv[0],sj-&gt;argv,environ);
628              _exit(2); &amp;bsol;* Don&#x27;t retry execution. */
629          } else {
630              sentinel.running_scripts++;
631              sj-&gt;pid = pid;
632              sentinelEvent(LL_DEBUG,&quot;+script-child&quot;,NULL,&quot;%ld&quot;,(long)pid);
633          }
634  #endif
635      }
636  }
637  mstime_t sentinelScriptRetryDelay(int retry_num) {
638      mstime_t delay = SENTINEL_SCRIPT_RETRY_DELAY;
639      while (retry_num-- &gt; 1) delay *= 2;
640      return delay;
641  }
642  void sentinelCollectTerminatedScripts(void) {
643  #ifdef _WIN32
644      listNode *ln;
645      listIter li;
646      DWORD exitCode;
647      listRewind(sentinel.scripts_queue,&amp;li);
648      while (sentinel.running_scripts &lt; SENTINEL_SCRIPT_MAX_RUNNING &amp;&amp;
649             (ln = listNext(&amp;li)) != NULL) {
650          sentinelScriptJob *sj = ln-&gt;value;
651          if(sj-&gt;hScriptProcess == INVALID_HANDLE_VALUE)
652              continue;
653          if(WaitForSingleObject(sj-&gt;hScriptProcess,0) == WAIT_OBJECT_0) {
654              GetExitCodeProcess(sj-&gt;hScriptProcess,&amp;exitCode);
655              sentinelEvent(LL_DEBUG, &quot;-script-child&quot;, NULL, &quot;%Id %d %d&quot;,      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id*/
656                  (PORT_LONG) sj-&gt;pid, exitCode, 0);
657              CloseHandle(sj-&gt;hScriptProcess);
658              if (exitCode == 1 &amp;&amp; sj-&gt;retry_num != SENTINEL_SCRIPT_MAX_RETRY) {
659                  sj-&gt;hScriptProcess = INVALID_HANDLE_VALUE;
660                  sj-&gt;pid = 0;
661                  sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;
662                  sj-&gt;start_time = mstime() +
663                                   sentinelScriptRetryDelay(sj-&gt;retry_num);
664              } else {
665                  if (exitCode != 0) {
666                      sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,
667                                    &quot;%s %d&quot;, sj-&gt;argv[0], exitCode);
668                  }
669                  listDelNode(sentinel.scripts_queue,ln);
670                  sentinelReleaseScriptJob(sj);
671                  sentinel.running_scripts--;
672              }
673          }
674      }
675  #else
676      int statloc;
677      pid_t pid;
678      while ((pid = wait3(&amp;statloc,WNOHANG,NULL)) &gt; 0) {
679          int exitcode = WEXITSTATUS(statloc);
680          int bysignal = 0;
681          listNode *ln;
682          sentinelScriptJob *sj;
683          if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
684          sentinelEvent(LL_DEBUG,&quot;-script-child&quot;,NULL,&quot;%ld %d %d&quot;,
685              (long)pid, exitcode, bysignal);
686          ln = sentinelGetScriptListNodeByPid(pid);
687          if (ln == NULL) {
688              serverLog(LL_WARNING,&quot;wait3() returned a pid (%ld) we can&#x27;t find in our scripts execution queue!&quot;, (long)pid);
689              continue;
690          }
691          sj = ln-&gt;value;
692          if ((bysignal || exitcode == 1) &amp;&amp;
693              sj-&gt;retry_num != SENTINEL_SCRIPT_MAX_RETRY)
694          {
695              sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;
696              sj-&gt;pid = 0;
697              sj-&gt;start_time = mstime() +
698                               sentinelScriptRetryDelay(sj-&gt;retry_num);
699          } else {
700              if (bysignal || exitcode != 0) {
701                  sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,
702                                &quot;%s %d %d&quot;, sj-&gt;argv[0], bysignal, exitcode);
703              }
704              listDelNode(sentinel.scripts_queue,ln);
705              sentinelReleaseScriptJob(sj);
706              sentinel.running_scripts--;
707          }
708      }
709  #endif
710  }
711  void sentinelKillTimedoutScripts(void) {
712      listNode *ln;
713      listIter li;
714      mstime_t now = mstime();
715      listRewind(sentinel.scripts_queue,&amp;li);
716      while ((ln = listNext(&amp;li)) != NULL) {
717          sentinelScriptJob *sj = ln-&gt;value;
718          if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING &amp;&amp;
719              (now - sj-&gt;start_time) &gt; SENTINEL_SCRIPT_MAX_RUNTIME)
720          {
721              sentinelEvent(LL_WARNING,&quot;-script-timeout&quot;,NULL,&quot;%s %Id&quot;,        WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id*/
722                  sj-&gt;argv[0], (PORT_LONG)sj-&gt;pid);
723  #ifdef _WIN32
724              TerminateProcess(sj-&gt;hScriptProcess,1);
725  #else
726              kill(sj-&gt;pid,SIGKILL);
727  #endif
728          }
729      }
730  }
731  void sentinelPendingScriptsCommand(client *c) {
732      listNode *ln;
733      listIter li;
734      addReplyMultiBulkLen(c,listLength(sentinel.scripts_queue));
735      listRewind(sentinel.scripts_queue,&amp;li);
736      while ((ln = listNext(&amp;li)) != NULL) {
737          sentinelScriptJob *sj = ln-&gt;value;
738          int j = 0;
739          addReplyMultiBulkLen(c,10);
740          addReplyBulkCString(c,&quot;argv&quot;);
741          while (sj-&gt;argv[j]) j++;
742          addReplyMultiBulkLen(c,j);
743          j = 0;
744          while (sj-&gt;argv[j]) addReplyBulkCString(c,sj-&gt;argv[j++]);
745          addReplyBulkCString(c,&quot;flags&quot;);
746          addReplyBulkCString(c,
747              (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) ? &quot;running&quot; : &quot;scheduled&quot;);
748          addReplyBulkCString(c,&quot;pid&quot;);
749          addReplyBulkLongLong(c,sj-&gt;pid);
750          if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) {
751              addReplyBulkCString(c,&quot;run-time&quot;);
752              addReplyBulkLongLong(c,mstime() - sj-&gt;start_time);
753          } else {
754              mstime_t delay = sj-&gt;start_time ? (sj-&gt;start_time-mstime()) : 0;
755              if (delay &lt; 0) delay = 0;
756              addReplyBulkCString(c,&quot;run-delay&quot;);
757              addReplyBulkLongLong(c,delay);
758          }
759          addReplyBulkCString(c,&quot;retry-num&quot;);
760          addReplyBulkLongLong(c,sj-&gt;retry_num);
761      }
762  }
763  void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {
764      char fromport[32], toport[32];
765      if (master-&gt;client_reconfig_script == NULL) return;
766      ll2string(fromport,sizeof(fromport),from-&gt;port);
767      ll2string(toport,sizeof(toport),to-&gt;port);
768      sentinelScheduleScriptExecution(master-&gt;client_reconfig_script,
769          master-&gt;name,
770          (role == SENTINEL_LEADER) ? &quot;leader&quot; : &quot;observer&quot;,
771          state, from-&gt;ip, fromport, to-&gt;ip, toport, NULL);
772  }
773  instanceLink *createInstanceLink(void) {
774      instanceLink *link = zmalloc(sizeof(*link));
775      link-&gt;refcount = 1;
776      link-&gt;disconnected = 1;
777      link-&gt;pending_commands = 0;
778      link-&gt;cc = NULL;
779      link-&gt;pc = NULL;
780      link-&gt;cc_conn_time = 0;
781      link-&gt;pc_conn_time = 0;
782      link-&gt;last_reconn_time = 0;
783      link-&gt;pc_last_activity = 0;
784      link-&gt;act_ping_time = mstime();
785      link-&gt;last_ping_time = 0;
786      link-&gt;last_avail_time = mstime();
787      link-&gt;last_pong_time = mstime();
788      return link;
789  }
790  void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
791      if (c == NULL) return;
792      if (link-&gt;cc == c) {
793          link-&gt;cc = NULL;
794          link-&gt;pending_commands = 0;
795      }
796      if (link-&gt;pc == c) link-&gt;pc = NULL;
797      c-&gt;data = NULL;
798      link-&gt;disconnected = 1;
799      redisAsyncFree(c);
800  }
801  instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
802  {
803      serverAssert(link-&gt;refcount &gt; 0);
804      link-&gt;refcount--;
805      if (link-&gt;refcount != 0) {
806          if (ri &amp;&amp; ri-&gt;link-&gt;cc) {
807              redisCallback *cb;
808              redisCallbackList *callbacks = &amp;link-&gt;cc-&gt;replies;
809              cb = callbacks-&gt;head;
810              while(cb) {
811                  if (cb-&gt;privdata == ri) {
812                      cb-&gt;fn = sentinelDiscardReplyCallback;
813                      cb-&gt;privdata = NULL; &amp;bsol;* Not strictly needed. */
814                  }
815                  cb = cb-&gt;next;
816              }
817          }
818          return link; &amp;bsol;* Other active users. */
819      }
820      instanceLinkCloseConnection(link,link-&gt;cc);
821      instanceLinkCloseConnection(link,link-&gt;pc);
822      zfree(link);
823      return NULL;
824  }
825  int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
826      serverAssert(ri-&gt;flags &amp; SRI_SENTINEL);
827      dictIterator *di;
828      dictEntry *de;
829      if (ri-&gt;runid == NULL) return C_ERR; &amp;bsol;* No way to identify it. */
830      if (ri-&gt;link-&gt;refcount &gt; 1) return C_ERR; &amp;bsol;* Already shared. */
831      di = dictGetIterator(sentinel.masters);
832      while((de = dictNext(di)) != NULL) {
833          sentinelRedisInstance *master = dictGetVal(de), *match;
834          if (master == ri-&gt;master) continue;
835          match = getSentinelRedisInstanceByAddrAndRunID(master-&gt;sentinels,
836                                                         NULL,0,ri-&gt;runid);
837          if (match == NULL) continue; &amp;bsol;* No match. */
838          if (match == ri) continue; &amp;bsol;* Should never happen but... safer. */
839          releaseInstanceLink(ri-&gt;link,NULL);
840          ri-&gt;link = match-&gt;link;
841          match-&gt;link-&gt;refcount++;
842          dictReleaseIterator(di);
843          return C_OK;
844      }
845      dictReleaseIterator(di);
846      return C_ERR;
847  }
848  int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
849      serverAssert(ri-&gt;flags &amp; SRI_SENTINEL);
850      dictIterator *di;
851      dictEntry *de;
852      int reconfigured = 0;
853      di = dictGetIterator(sentinel.masters);
854      while((de = dictNext(di)) != NULL) {
855          sentinelRedisInstance *master = dictGetVal(de), *match;
856          match = getSentinelRedisInstanceByAddrAndRunID(master-&gt;sentinels,
857                                                         NULL,0,ri-&gt;runid);
858          if (match == NULL) continue;
859          if (match-&gt;link-&gt;cc != NULL)
860              instanceLinkCloseConnection(match-&gt;link,match-&gt;link-&gt;cc);
861          if (match-&gt;link-&gt;pc != NULL)
862              instanceLinkCloseConnection(match-&gt;link,match-&gt;link-&gt;pc);
863          if (match == ri) continue; &amp;bsol;* Address already updated for it. */
864          releaseSentinelAddr(match-&gt;addr);
865          match-&gt;addr = dupSentinelAddr(ri-&gt;addr);
866          reconfigured++;
867      }
868      dictReleaseIterator(di);
869      if (reconfigured)
870          sentinelEvent(LL_NOTICE,&quot;+sentinel-address-update&quot;, ri,
871                      &quot;%@ %d additional matching instances&quot;, reconfigured);
872      return reconfigured;
873  }
874  void instanceLinkConnectionError(const redisAsyncContext *c) {
875      instanceLink *link = c-&gt;data;
876      int pubsub;
877      if (!link) return;
878      pubsub = (link-&gt;pc == c);
879      if (pubsub)
880          link-&gt;pc = NULL;
881      else
882          link-&gt;cc = NULL;
883      link-&gt;disconnected = 1;
884  }
885  void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {
886      if (status != C_OK) instanceLinkConnectionError(c);
887  }
888  void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
889      UNUSED(status);
890      instanceLinkConnectionError(c);
891  }
892  sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {
893      sentinelRedisInstance *ri;
894      sentinelAddr *addr;
895      dict *table = NULL;
896      char slavename[NET_PEER_ID_LEN], *sdsname;
897      serverAssert(flags &amp; (SRI_MASTER|SRI_SLAVE|SRI_SENTINEL));
898      serverAssert((flags &amp; SRI_MASTER) || master != NULL);
899      addr = createSentinelAddr(hostname,port);
900      if (addr == NULL) return NULL;
901      if (flags &amp; SRI_SLAVE) {
902          anetFormatAddr(slavename, sizeof(slavename), hostname, port);
903          name = slavename;
904      }
905      if (flags &amp; SRI_MASTER) table = sentinel.masters;
906      else if (flags &amp; SRI_SLAVE) table = master-&gt;slaves;
907      else if (flags &amp; SRI_SENTINEL) table = master-&gt;sentinels;
908      sdsname = sdsnew(name);
909      if (dictFind(table,sdsname)) {
910          releaseSentinelAddr(addr);
911          sdsfree(sdsname);
912          errno = EBUSY;
913          return NULL;
914      }
915      ri = zmalloc(sizeof(*ri));
916      ri-&gt;flags = flags;
917      ri-&gt;name = sdsname;
918      ri-&gt;runid = NULL;
919      ri-&gt;config_epoch = 0;
920      ri-&gt;addr = addr;
921      ri-&gt;link = createInstanceLink();
922      ri-&gt;last_pub_time = mstime();
923      ri-&gt;last_hello_time = mstime();
924      ri-&gt;last_master_down_reply_time = mstime();
925      ri-&gt;s_down_since_time = 0;
926      ri-&gt;o_down_since_time = 0;
927      ri-&gt;down_after_period = master ? master-&gt;down_after_period :
928                              SENTINEL_DEFAULT_DOWN_AFTER;
929      ri-&gt;master_link_down_time = 0;
930      ri-&gt;auth_pass = NULL;
931      ri-&gt;slave_priority = SENTINEL_DEFAULT_SLAVE_PRIORITY;
932      ri-&gt;slave_reconf_sent_time = 0;
933      ri-&gt;slave_master_host = NULL;
934      ri-&gt;slave_master_port = 0;
935      ri-&gt;slave_master_link_status = SENTINEL_MASTER_LINK_STATUS_DOWN;
936      ri-&gt;slave_repl_offset = 0;
937      ri-&gt;sentinels = dictCreate(&amp;instancesDictType,NULL);
938      ri-&gt;quorum = quorum;
939      ri-&gt;parallel_syncs = SENTINEL_DEFAULT_PARALLEL_SYNCS;
940      ri-&gt;master = master;
941      ri-&gt;slaves = dictCreate(&amp;instancesDictType,NULL);
942      ri-&gt;info_refresh = 0;
943      ri-&gt;renamed_commands = dictCreate(&amp;renamedCommandsDictType,NULL);
944      ri-&gt;leader = NULL;
945      ri-&gt;leader_epoch = 0;
946      ri-&gt;failover_epoch = 0;
947      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_NONE;
948      ri-&gt;failover_state_change_time = 0;
949      ri-&gt;failover_start_time = 0;
950      ri-&gt;failover_timeout = SENTINEL_DEFAULT_FAILOVER_TIMEOUT;
951      ri-&gt;failover_delay_logged = 0;
952      ri-&gt;promoted_slave = NULL;
953      ri-&gt;notification_script = NULL;
954      ri-&gt;client_reconfig_script = NULL;
955      ri-&gt;info = NULL;
956      ri-&gt;role_reported = ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE);
957      ri-&gt;role_reported_time = mstime();
958      ri-&gt;slave_conf_change_time = mstime();
959      dictAdd(table, ri-&gt;name, ri);
960      return ri;
961  }
962  void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {
963      dictRelease(ri-&gt;sentinels);
964      dictRelease(ri-&gt;slaves);
965      releaseInstanceLink(ri-&gt;link,ri);
966      sdsfree(ri-&gt;name);
967      sdsfree(ri-&gt;runid);
968      sdsfree(ri-&gt;notification_script);
969      sdsfree(ri-&gt;client_reconfig_script);
970      sdsfree(ri-&gt;slave_master_host);
971      sdsfree(ri-&gt;leader);
972      sdsfree(ri-&gt;auth_pass);
973      sdsfree(ri-&gt;info);
974      releaseSentinelAddr(ri-&gt;addr);
975      dictRelease(ri-&gt;renamed_commands);
976      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp; (ri-&gt;flags &amp; SRI_PROMOTED) &amp;&amp; ri-&gt;master)
977          ri-&gt;master-&gt;promoted_slave = NULL;
978      zfree(ri);
979  }
980  sentinelRedisInstance *sentinelRedisInstanceLookupSlave(
981                  sentinelRedisInstance *ri, char *ip, int port)
982  {
983      sds key;
984      sentinelRedisInstance *slave;
985      char buf[NET_PEER_ID_LEN];
986      serverAssert(ri-&gt;flags &amp; SRI_MASTER);
987      anetFormatAddr(buf,sizeof(buf),ip,port);
988      key = sdsnew(buf);
989      slave = dictFetchValue(ri-&gt;slaves,key);
990      sdsfree(key);
991      return slave;
992  }
993  const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri) {
994      if (ri-&gt;flags &amp; SRI_MASTER) return &quot;master&quot;;
995      else if (ri-&gt;flags &amp; SRI_SLAVE) return &quot;slave&quot;;
996      else if (ri-&gt;flags &amp; SRI_SENTINEL) return &quot;sentinel&quot;;
997      else return &quot;unknown&quot;;
998  }
999  int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid) {
1000      dictIterator *di;
1001      dictEntry *de;
1002      int removed = 0;
1003      if (runid == NULL) return 0;
1004      di = dictGetSafeIterator(master-&gt;sentinels);
1005      while((de = dictNext(di)) != NULL) {
1006          sentinelRedisInstance *ri = dictGetVal(de);
1007          if (ri-&gt;runid &amp;&amp; strcmp(ri-&gt;runid,runid) == 0) {
1008              dictDelete(master-&gt;sentinels,ri-&gt;name);
1009              removed++;
1010          }
1011      }
1012      dictReleaseIterator(di);
1013      return removed;
1014  }
1015  sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid) {
1016      dictIterator *di;
1017      dictEntry *de;
1018      sentinelRedisInstance *instance = NULL;
1019      serverAssert(ip || runid);   &amp;bsol;* User must pass at least one search param. */
1020      di = dictGetIterator(instances);
1021      while((de = dictNext(di)) != NULL) {
1022          sentinelRedisInstance *ri = dictGetVal(de);
1023          if (runid &amp;&amp; !ri-&gt;runid) continue;
1024          if ((runid == NULL || strcmp(ri-&gt;runid, runid) == 0) &amp;&amp;
1025              (ip == NULL || (strcmp(ri-&gt;addr-&gt;ip, ip) == 0 &amp;&amp;
1026                              ri-&gt;addr-&gt;port == port)))
1027          {
1028              instance = ri;
1029              break;
1030          }
1031      }
1032      dictReleaseIterator(di);
1033      return instance;
1034  }
1035  sentinelRedisInstance *sentinelGetMasterByName(char *name) {
1036      sentinelRedisInstance *ri;
1037      sds sdsname = sdsnew(name);
1038      ri = dictFetchValue(sentinel.masters,sdsname);
1039      sdsfree(sdsname);
1040      return ri;
1041  }
1042  void sentinelAddFlagsToDictOfRedisInstances(dict *instances, int flags) {
1043      dictIterator *di;
1044      dictEntry *de;
1045      di = dictGetIterator(instances);
1046      while((de = dictNext(di)) != NULL) {
1047          sentinelRedisInstance *ri = dictGetVal(de);
1048          ri-&gt;flags |= flags;
1049      }
1050      dictReleaseIterator(di);
1051  }
1052  void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {
1053      dictIterator *di;
1054      dictEntry *de;
1055      di = dictGetIterator(instances);
1056      while((de = dictNext(di)) != NULL) {
1057          sentinelRedisInstance *ri = dictGetVal(de);
1058          ri-&gt;flags &amp;= ~flags;
1059      }
1060      dictReleaseIterator(di);
1061  }
1062  #define SENTINEL_RESET_NO_SENTINELS (1&lt;&lt;0)
1063  void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
1064      serverAssert(ri-&gt;flags &amp; SRI_MASTER);
1065      dictRelease(ri-&gt;slaves);
1066      ri-&gt;slaves = dictCreate(&amp;instancesDictType,NULL);
1067      if (!(flags &amp; SENTINEL_RESET_NO_SENTINELS)) {
1068          dictRelease(ri-&gt;sentinels);
1069          ri-&gt;sentinels = dictCreate(&amp;instancesDictType,NULL);
1070      }
1071      instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;cc);
1072      instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;pc);
1073      ri-&gt;flags &amp;= SRI_MASTER;
1074      if (ri-&gt;leader) {
1075          sdsfree(ri-&gt;leader);
1076          ri-&gt;leader = NULL;
1077      }
1078      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_NONE;
1079      ri-&gt;failover_state_change_time = 0;
1080      ri-&gt;failover_start_time = 0; &amp;bsol;* We can failover again ASAP. */
1081      ri-&gt;promoted_slave = NULL;
1082      sdsfree(ri-&gt;runid);
1083      sdsfree(ri-&gt;slave_master_host);
1084      ri-&gt;runid = NULL;
1085      ri-&gt;slave_master_host = NULL;
1086      ri-&gt;link-&gt;act_ping_time = mstime();
1087      ri-&gt;link-&gt;last_ping_time = 0;
1088      ri-&gt;link-&gt;last_avail_time = mstime();
1089      ri-&gt;link-&gt;last_pong_time = mstime();
1090      ri-&gt;role_reported_time = mstime();
1091      ri-&gt;role_reported = SRI_MASTER;
1092      if (flags &amp; SENTINEL_GENERATE_EVENT)
1093          sentinelEvent(LL_WARNING,&quot;+reset-master&quot;,ri,&quot;%@&quot;);
1094  }
1095  int sentinelResetMastersByPattern(char *pattern, int flags) {
1096      dictIterator *di;
1097      dictEntry *de;
1098      int reset = 0;
1099      di = dictGetIterator(sentinel.masters);
1100      while((de = dictNext(di)) != NULL) {
1101          sentinelRedisInstance *ri = dictGetVal(de);
1102          if (ri-&gt;name) {
1103              if (stringmatch(pattern,ri-&gt;name,0)) {
1104                  sentinelResetMaster(ri,flags);
1105                  reset++;
1106              }
1107          }
1108      }
1109      dictReleaseIterator(di);
1110      return reset;
1111  }
1112  int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip, int port) {
1113      sentinelAddr *oldaddr, *newaddr;
1114      sentinelAddr **slaves = NULL;
1115      int numslaves = 0, j;
1116      dictIterator *di;
1117      dictEntry *de;
1118      newaddr = createSentinelAddr(ip,port);
1119      if (newaddr == NULL) return C_ERR;
1120      di = dictGetIterator(master-&gt;slaves);
1121      while((de = dictNext(di)) != NULL) {
1122          sentinelRedisInstance *slave = dictGetVal(de);
1123          if (sentinelAddrIsEqual(slave-&gt;addr,newaddr)) continue;
1124          slaves = zrealloc(slaves,sizeof(sentinelAddr*)*(numslaves+1));
1125          slaves[numslaves++] = createSentinelAddr(slave-&gt;addr-&gt;ip,
1126                                                   slave-&gt;addr-&gt;port);
1127      }
1128      dictReleaseIterator(di);
1129      if (!sentinelAddrIsEqual(newaddr,master-&gt;addr)) {
1130          slaves = zrealloc(slaves,sizeof(sentinelAddr*)*(numslaves+1));
1131          slaves[numslaves++] = createSentinelAddr(master-&gt;addr-&gt;ip,
1132                                                   master-&gt;addr-&gt;port);
1133      }
1134      sentinelResetMaster(master,SENTINEL_RESET_NO_SENTINELS);
1135      oldaddr = master-&gt;addr;
1136      master-&gt;addr = newaddr;
1137      master-&gt;o_down_since_time = 0;
1138      master-&gt;s_down_since_time = 0;
1139      for (j = 0; j &lt; numslaves; j++) {
1140          sentinelRedisInstance *slave;
1141          slave = createSentinelRedisInstance(NULL,SRI_SLAVE,slaves[j]-&gt;ip,
1142                      slaves[j]-&gt;port, master-&gt;quorum, master);
1143          releaseSentinelAddr(slaves[j]);
1144          if (slave) sentinelEvent(LL_NOTICE,&quot;+slave&quot;,slave,&quot;%@&quot;);
1145      }
1146      zfree(slaves);
1147      releaseSentinelAddr(oldaddr);
1148      sentinelFlushConfig();
1149      return C_OK;
1150  }
1151  int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {
1152      mstime_t most_recent;
1153      most_recent = ri-&gt;s_down_since_time;
1154      if (ri-&gt;o_down_since_time &gt; most_recent)
1155          most_recent = ri-&gt;o_down_since_time;
1156      return most_recent == 0 || (mstime() - most_recent) &gt; ms;
1157  }
1158  sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {
1159      if ((master-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) &amp;&amp;
1160          master-&gt;promoted_slave &amp;&amp;
1161          master-&gt;failover_state &gt;= SENTINEL_FAILOVER_STATE_RECONF_SLAVES)
1162      {
1163          return master-&gt;promoted_slave-&gt;addr;
1164      } else {
1165          return master-&gt;addr;
1166      }
1167  }
1168  void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {
1169      dictIterator *di;
1170      dictEntry *de;
1171      int j;
1172      dict *d[] = {master-&gt;slaves, master-&gt;sentinels, NULL};
1173      for (j = 0; d[j]; j++) {
1174          di = dictGetIterator(d[j]);
1175          while((de = dictNext(di)) != NULL) {
1176              sentinelRedisInstance *ri = dictGetVal(de);
1177              ri-&gt;down_after_period = master-&gt;down_after_period;
1178          }
1179          dictReleaseIterator(di);
1180      }
1181  }
1182  char *sentinelGetInstanceTypeString(sentinelRedisInstance *ri) {
1183      if (ri-&gt;flags &amp; SRI_MASTER) return &quot;master&quot;;
1184      else if (ri-&gt;flags &amp; SRI_SLAVE) return &quot;slave&quot;;
1185      else if (ri-&gt;flags &amp; SRI_SENTINEL) return &quot;sentinel&quot;;
1186      else return &quot;unknown&quot;;
1187  }
1188  char *sentinelInstanceMapCommand(sentinelRedisInstance *ri, char *command) {
1189      sds sc = sdsnew(command);
1190      if (ri-&gt;master) ri = ri-&gt;master;
1191      char *retval = dictFetchValue(ri-&gt;renamed_commands, sc);
1192      sdsfree(sc);
1193      return retval ? retval : command;
1194  }
1195  char *sentinelHandleConfiguration(char **argv, int argc) {
1196      sentinelRedisInstance *ri;
1197      if (!strcasecmp(argv[0],&quot;monitor&quot;) &amp;&amp; argc == 5) {
1198          int quorum = atoi(argv[4]);
1199          if (quorum &lt;= 0) return &quot;Quorum must be 1 or greater.&quot;;
1200          if (createSentinelRedisInstance(argv[1],SRI_MASTER,argv[2],
1201                                          atoi(argv[3]),quorum,NULL) == NULL)
1202          {
1203              switch(errno) {
1204              case EBUSY: return &quot;Duplicated master name.&quot;;
1205              case ENOENT: return &quot;Can&#x27;t resolve master instance hostname.&quot;;
1206              case EINVAL: return &quot;Invalid port number&quot;;
1207              }
1208          }
1209      } else if (!strcasecmp(argv[0],&quot;down-after-milliseconds&quot;) &amp;&amp; argc == 3) {
1210          ri = sentinelGetMasterByName(argv[1]);
1211          if (!ri) return &quot;No such master with specified name.&quot;;
1212          ri-&gt;down_after_period = atoi(argv[2]);
1213          if (ri-&gt;down_after_period &lt;= 0)
1214              return &quot;negative or zero time parameter.&quot;;
1215          sentinelPropagateDownAfterPeriod(ri);
1216      } else if (!strcasecmp(argv[0],&quot;failover-timeout&quot;) &amp;&amp; argc == 3) {
1217          ri = sentinelGetMasterByName(argv[1]);
1218          if (!ri) return &quot;No such master with specified name.&quot;;
1219          ri-&gt;failover_timeout = atoi(argv[2]);
1220          if (ri-&gt;failover_timeout &lt;= 0)
1221              return &quot;negative or zero time parameter.&quot;;
1222     } else if (!strcasecmp(argv[0],&quot;parallel-syncs&quot;) &amp;&amp; argc == 3) {
1223          ri = sentinelGetMasterByName(argv[1]);
1224          if (!ri) return &quot;No such master with specified name.&quot;;
1225          ri-&gt;parallel_syncs = atoi(argv[2]);
1226     } else if (!strcasecmp(argv[0],&quot;notification-script&quot;) &amp;&amp; argc == 3) {
1227          ri = sentinelGetMasterByName(argv[1]);
1228          if (!ri) return &quot;No such master with specified name.&quot;;
1229          if (access(argv[2],X_OK) == -1)
1230              return &quot;Notification script seems non existing or non executable.&quot;;
1231          ri-&gt;notification_script = sdsnew(argv[2]);
1232     } else if (!strcasecmp(argv[0],&quot;client-reconfig-script&quot;) &amp;&amp; argc == 3) {
1233          ri = sentinelGetMasterByName(argv[1]);
1234          if (!ri) return &quot;No such master with specified name.&quot;;
1235          if (access(argv[2],X_OK) == -1)
1236              return &quot;Client reconfiguration script seems non existing or &quot;
1237                     &quot;non executable.&quot;;
1238          ri-&gt;client_reconfig_script = sdsnew(argv[2]);
1239     } else if (!strcasecmp(argv[0],&quot;auth-pass&quot;) &amp;&amp; argc == 3) {
1240          ri = sentinelGetMasterByName(argv[1]);
1241          if (!ri) return &quot;No such master with specified name.&quot;;
1242          ri-&gt;auth_pass = sdsnew(argv[2]);
1243      } else if (!strcasecmp(argv[0],&quot;current-epoch&quot;) &amp;&amp; argc == 2) {
1244          PORT_ULONGLONG current_epoch = strtoull(argv[1],NULL,10);
1245          if (current_epoch &gt; sentinel.current_epoch)
1246              sentinel.current_epoch = current_epoch;
1247      } else if (!strcasecmp(argv[0],&quot;myid&quot;) &amp;&amp; argc == 2) {
1248          if (strlen(argv[1]) != CONFIG_RUN_ID_SIZE)
1249              return &quot;Malformed Sentinel id in myid option.&quot;;
1250          memcpy(sentinel.myid,argv[1],CONFIG_RUN_ID_SIZE);
1251      } else if (!strcasecmp(argv[0],&quot;config-epoch&quot;) &amp;&amp; argc == 3) {
1252          ri = sentinelGetMasterByName(argv[1]);
1253          if (!ri) return &quot;No such master with specified name.&quot;;
1254          ri-&gt;config_epoch = strtoull(argv[2],NULL,10);
1255          if (ri-&gt;config_epoch &gt; sentinel.current_epoch)
1256              sentinel.current_epoch = ri-&gt;config_epoch;
1257      } else if (!strcasecmp(argv[0],&quot;leader-epoch&quot;) &amp;&amp; argc == 3) {
1258          ri = sentinelGetMasterByName(argv[1]);
1259          if (!ri) return &quot;No such master with specified name.&quot;;
1260          ri-&gt;leader_epoch = strtoull(argv[2],NULL,10);
1261      } else if ((!strcasecmp(argv[0],&quot;known-slave&quot;) ||
1262                  !strcasecmp(argv[0],&quot;known-replica&quot;)) &amp;&amp; argc == 4)
1263      {
1264          sentinelRedisInstance *slave;
1265          ri = sentinelGetMasterByName(argv[1]);
1266          if (!ri) return &quot;No such master with specified name.&quot;;
1267          if ((slave = createSentinelRedisInstance(NULL,SRI_SLAVE,argv[2],
1268                      atoi(argv[3]), ri-&gt;quorum, ri)) == NULL)
1269          {
1270              return &quot;Wrong hostname or port for replica.&quot;;
1271          }
1272      } else if (!strcasecmp(argv[0],&quot;known-sentinel&quot;) &amp;&amp;
1273                 (argc == 4 || argc == 5)) {
1274          sentinelRedisInstance *si;
1275          if (argc == 5) { &amp;bsol;* Ignore the old form without runid. */
1276              ri = sentinelGetMasterByName(argv[1]);
1277              if (!ri) return &quot;No such master with specified name.&quot;;
1278              if ((si = createSentinelRedisInstance(argv[4],SRI_SENTINEL,argv[2],
1279                          atoi(argv[3]), ri-&gt;quorum, ri)) == NULL)
1280              {
1281                  return &quot;Wrong hostname or port for sentinel.&quot;;
1282              }
1283              si-&gt;runid = sdsnew(argv[4]);
1284              sentinelTryConnectionSharing(si);
1285          }
1286      } else if (!strcasecmp(argv[0],&quot;rename-command&quot;) &amp;&amp; argc == 4) {
1287          ri = sentinelGetMasterByName(argv[1]);
1288          if (!ri) return &quot;No such master with specified name.&quot;;
1289          sds oldcmd = sdsnew(argv[2]);
1290          sds newcmd = sdsnew(argv[3]);
1291          if (dictAdd(ri-&gt;renamed_commands,oldcmd,newcmd) != DICT_OK) {
1292              sdsfree(oldcmd);
1293              sdsfree(newcmd);
1294              return &quot;Same command renamed multiple times with rename-command.&quot;;
1295          }
1296      } else if (!strcasecmp(argv[0],&quot;announce-ip&quot;) &amp;&amp; argc == 2) {
1297          if (strlen(argv[1]))
1298              sentinel.announce_ip = sdsnew(argv[1]);
1299      } else if (!strcasecmp(argv[0],&quot;announce-port&quot;) &amp;&amp; argc == 2) {
1300          sentinel.announce_port = atoi(argv[1]);
1301      } else if (!strcasecmp(argv[0],&quot;deny-scripts-reconfig&quot;) &amp;&amp; argc == 2) {
1302          if ((sentinel.deny_scripts_reconfig = yesnotoi(argv[1])) == -1) {
1303              return &quot;Please specify yes or no for the &quot;
1304                     &quot;deny-scripts-reconfig options.&quot;;
1305          }
1306      } else {
1307          return &quot;Unrecognized sentinel configuration statement.&quot;;
1308      }
1309      return NULL;
1310  }
1311  void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
1312      dictIterator *di, *di2;
1313      dictEntry *de;
1314      sds line;
1315      line = sdscatprintf(sdsempty(), &quot;sentinel myid %s&quot;, sentinel.myid);
1316      rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1317      line = sdscatprintf(sdsempty(), &quot;sentinel deny-scripts-reconfig %s&quot;,
1318          sentinel.deny_scripts_reconfig ? &quot;yes&quot; : &quot;no&quot;);
1319      rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,
1320          sentinel.deny_scripts_reconfig != SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG);
1321      di = dictGetIterator(sentinel.masters);
1322      while((de = dictNext(di)) != NULL) {
1323          sentinelRedisInstance *master, *ri;
1324          sentinelAddr *master_addr;
1325          master = dictGetVal(de);
1326          master_addr = sentinelGetCurrentMasterAddress(master);
1327          line = sdscatprintf(sdsempty(),&quot;sentinel monitor %s %s %d %d&quot;,
1328              master-&gt;name, master_addr-&gt;ip, master_addr-&gt;port,
1329              master-&gt;quorum);
1330          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1331          if (master-&gt;down_after_period != SENTINEL_DEFAULT_DOWN_AFTER) {
1332              line = sdscatprintf(sdsempty(),
1333                  &quot;sentinel down-after-milliseconds %s %Id&quot;,                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id*/
1334                  master-&gt;name, (PORT_LONG) master-&gt;down_after_period);
1335              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1336          }
1337          if (master-&gt;failover_timeout != SENTINEL_DEFAULT_FAILOVER_TIMEOUT) {
1338              line = sdscatprintf(sdsempty(),
1339                  &quot;sentinel failover-timeout %s %Id&quot;,                             WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id*/
1340                  master-&gt;name, (PORT_LONG) master-&gt;failover_timeout);
1341              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1342          }
1343          if (master-&gt;parallel_syncs != SENTINEL_DEFAULT_PARALLEL_SYNCS) {
1344              line = sdscatprintf(sdsempty(),
1345                  &quot;sentinel parallel-syncs %s %d&quot;,
1346                  master-&gt;name, master-&gt;parallel_syncs);
1347              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1348          }
1349          if (master-&gt;notification_script) {
1350              line = sdscatprintf(sdsempty(),
1351                  &quot;sentinel notification-script %s %s&quot;,
1352                  master-&gt;name, master-&gt;notification_script);
1353              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1354          }
1355          if (master-&gt;client_reconfig_script) {
1356              line = sdscatprintf(sdsempty(),
1357                  &quot;sentinel client-reconfig-script %s %s&quot;,
1358                  master-&gt;name, master-&gt;client_reconfig_script);
1359              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1360          }
1361          if (master-&gt;auth_pass) {
1362              line = sdscatprintf(sdsempty(),
1363                  &quot;sentinel auth-pass %s %s&quot;,
1364                  master-&gt;name, master-&gt;auth_pass);
1365              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1366          }
1367          line = sdscatprintf(sdsempty(),
1368              &quot;sentinel config-epoch %s %llu&quot;,
1369              master-&gt;name, (PORT_ULONGLONG) master-&gt;config_epoch);
1370          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1371          line = sdscatprintf(sdsempty(),
1372              &quot;sentinel leader-epoch %s %llu&quot;,
1373              master-&gt;name, (PORT_ULONGLONG) master-&gt;leader_epoch);
1374          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1375          di2 = dictGetIterator(master-&gt;slaves);
1376          while((de = dictNext(di2)) != NULL) {
1377              sentinelAddr *slave_addr;
1378              ri = dictGetVal(de);
1379              slave_addr = ri-&gt;addr;
1380              if (sentinelAddrIsEqual(slave_addr,master_addr))
1381                  slave_addr = master-&gt;addr;
1382              line = sdscatprintf(sdsempty(),
1383                  &quot;sentinel known-replica %s %s %d&quot;,
1384                  master-&gt;name, slave_addr-&gt;ip, slave_addr-&gt;port);
1385              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1386          }
1387          dictReleaseIterator(di2);
1388          di2 = dictGetIterator(master-&gt;sentinels);
1389          while((de = dictNext(di2)) != NULL) {
1390              ri = dictGetVal(de);
1391              if (ri-&gt;runid == NULL) continue;
1392              line = sdscatprintf(sdsempty(),
1393                  &quot;sentinel known-sentinel %s %s %d %s&quot;,
1394                  master-&gt;name, ri-&gt;addr-&gt;ip, ri-&gt;addr-&gt;port, ri-&gt;runid);
1395              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1396          }
1397          dictReleaseIterator(di2);
1398          di2 = dictGetIterator(master-&gt;renamed_commands);
1399          while((de = dictNext(di2)) != NULL) {
1400              sds oldname = dictGetKey(de);
1401              sds newname = dictGetVal(de);
1402              line = sdscatprintf(sdsempty(),
1403                  &quot;sentinel rename-command %s %s %s&quot;,
1404                  master-&gt;name, oldname, newname);
1405              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1406          }
1407          dictReleaseIterator(di2);
1408      }
1409      line = sdscatprintf(sdsempty(),
1410          &quot;sentinel current-epoch %llu&quot;, (PORT_ULONGLONG) sentinel.current_epoch);
1411      rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1412      if (sentinel.announce_ip) {
1413          line = sdsnew(&quot;sentinel announce-ip &quot;);
1414          line = sdscatrepr(line, sentinel.announce_ip, sdslen(sentinel.announce_ip));
1415          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1416      }
1417      if (sentinel.announce_port) {
1418          line = sdscatprintf(sdsempty(),&quot;sentinel announce-port %d&quot;,
1419                              sentinel.announce_port);
1420          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1421      }
1422      dictReleaseIterator(di);
1423  }
1424  void sentinelFlushConfig(void) {
1425      int fd = -1;
1426      int saved_hz = server.hz;
1427      int rewrite_status;
1428      server.hz = CONFIG_DEFAULT_HZ;
1429      rewrite_status = rewriteConfig(server.configfile);
1430      server.hz = saved_hz;
1431      if (rewrite_status == -1) goto werr;
1432      if ((fd = open(server.configfile,O_RDONLY,IF_WIN32(_S_IREAD|_S_IWRITE,0644))) == -1) goto werr;
1433      POSIX_ONLY(if (fsync(fd) == -1) goto werr;)
1434      if (close(fd) == EOF) goto werr;
1435      return;
1436  werr:
1437      if (fd != -1) close(fd);
1438      serverLog(LL_WARNING,&quot;WARNING: Sentinel was not able to save the new configuration on disk!!!: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1439  }
1440  void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
1441      char *auth_pass = NULL;
1442      if (ri-&gt;flags &amp; SRI_MASTER) {
1443          auth_pass = ri-&gt;auth_pass;
1444      } else if (ri-&gt;flags &amp; SRI_SLAVE) {
1445          auth_pass = ri-&gt;master-&gt;auth_pass;
1446      } else if (ri-&gt;flags &amp; SRI_SENTINEL) {
1447          if (server.requirepass) auth_pass = server.requirepass;
1448      }
1449      if (auth_pass) {
1450          if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri, &quot;%s %s&quot;,
1451              sentinelInstanceMapCommand(ri,&quot;AUTH&quot;),
1452              auth_pass) == C_OK) ri-&gt;link-&gt;pending_commands++;
1453      }
1454  }
1455  void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {
1456      char name[64];
1457      snprintf(name,sizeof(name),&quot;sentinel-%.8s-%s&quot;,sentinel.myid,type);
1458      if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri,
1459          &quot;%s SETNAME %s&quot;,
1460          sentinelInstanceMapCommand(ri,&quot;CLIENT&quot;),
1461          name) == C_OK)
1462      {
1463          ri-&gt;link-&gt;pending_commands++;
1464      }
1465  }
1466  void sentinelReconnectInstance(sentinelRedisInstance *ri) {
1467      if (ri-&gt;link-&gt;disconnected == 0) return;
1468      if (ri-&gt;addr-&gt;port == 0) return; &amp;bsol;* port == 0 means invalid address. */
1469      instanceLink *link = ri-&gt;link;
1470      mstime_t now = mstime();
1471      if (now - ri-&gt;link-&gt;last_reconn_time &lt; SENTINEL_PING_PERIOD) return;
1472      ri-&gt;link-&gt;last_reconn_time = now;
1473      if (link-&gt;cc == NULL) {
1474          link-&gt;cc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port,NET_FIRST_BIND_ADDR);
1475          if (link-&gt;cc-&gt;err) {
1476              sentinelEvent(LL_DEBUG,&quot;-cmd-link-reconnection&quot;,ri,&quot;%@ #%s&quot;,
1477                  link-&gt;cc-&gt;errstr);
1478              instanceLinkCloseConnection(link,link-&gt;cc);
1479          } else {
1480              link-&gt;pending_commands = 0;
1481              link-&gt;cc_conn_time = mstime();
1482              link-&gt;cc-&gt;data = link;
<span onclick='openModal()' class='match'>1483              redisAeAttach(server.el,link-&gt;cc);
1484              redisAsyncSetConnectCallback(link-&gt;cc,
1485                      sentinelLinkEstablishedCallback);
1486              redisAsyncSetDisconnectCallback(link-&gt;cc,
1487                      sentinelDisconnectCallback);
1488              sentinelSendAuthIfNeeded(ri,link-&gt;cc);
1489              sentinelSetClientName(ri,link-&gt;cc,&quot;cmd&quot;);
1490              sentinelSendPing(ri);
</span>1491          }
1492      }
1493      if ((ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) &amp;&amp; link-&gt;pc == NULL) {
1494          link-&gt;pc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port,NET_FIRST_BIND_ADDR);
1495          if (link-&gt;pc-&gt;err) {
1496              sentinelEvent(LL_DEBUG,&quot;-pubsub-link-reconnection&quot;,ri,&quot;%@ #%s&quot;,
1497                  link-&gt;pc-&gt;errstr);
1498              instanceLinkCloseConnection(link,link-&gt;pc);
1499          } else {
1500              int retval;
1501              link-&gt;pc_conn_time = mstime();
1502              link-&gt;pc-&gt;data = link;
1503              redisAeAttach(server.el,link-&gt;pc);
1504              redisAsyncSetConnectCallback(link-&gt;pc,
1505                      sentinelLinkEstablishedCallback);
1506              redisAsyncSetDisconnectCallback(link-&gt;pc,
1507                      sentinelDisconnectCallback);
1508              sentinelSendAuthIfNeeded(ri,link-&gt;pc);
1509              sentinelSetClientName(ri,link-&gt;pc,&quot;pubsub&quot;);
1510              retval = redisAsyncCommand(link-&gt;pc,
1511                  sentinelReceiveHelloMessages, ri, &quot;%s %s&quot;,
1512                  sentinelInstanceMapCommand(ri,&quot;SUBSCRIBE&quot;),
1513                  SENTINEL_HELLO_CHANNEL);
1514              if (retval != C_OK) {
1515                  instanceLinkCloseConnection(link,link-&gt;pc);
1516                  return;
1517              }
1518          }
1519      }
1520      if (link-&gt;cc &amp;&amp; (ri-&gt;flags &amp; SRI_SENTINEL || link-&gt;pc))
1521          link-&gt;disconnected = 0;
1522  }
1523  int sentinelMasterLooksSane(sentinelRedisInstance *master) {
1524      return
1525          master-&gt;flags &amp; SRI_MASTER &amp;&amp;
1526          master-&gt;role_reported == SRI_MASTER &amp;&amp;
1527          (master-&gt;flags &amp; (SRI_S_DOWN|SRI_O_DOWN)) == 0 &amp;&amp;
1528          (mstime() - master-&gt;info_refresh) &lt; SENTINEL_INFO_PERIOD*2;
1529  }
1530  void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
1531      sds *lines;
1532      int numlines, j;
1533      int role = 0;
1534      sdsfree(ri-&gt;info);
1535      ri-&gt;info = sdsnew(info);
1536      ri-&gt;master_link_down_time = 0;
1537      lines = sdssplitlen(info,(int)strlen(info),&quot;\r\n&quot;,2,&amp;numlines);             WIN_PORT_FIX &amp;bsol;* cast (int) */
1538      for (j = 0; j &lt; numlines; j++) {
1539          sentinelRedisInstance *slave;
1540          sds l = lines[j];
1541          if (sdslen(l) &gt;= 47 &amp;&amp; !memcmp(l,&quot;run_id:&quot;,7)) {
1542              if (ri-&gt;runid == NULL) {
1543                  ri-&gt;runid = sdsnewlen(l+7,40);
1544              } else {
1545                  if (strncmp(ri-&gt;runid,l+7,40) != 0) {
1546                      sentinelEvent(LL_NOTICE,&quot;+reboot&quot;,ri,&quot;%@&quot;);
1547                      sdsfree(ri-&gt;runid);
1548                      ri-&gt;runid = sdsnewlen(l+7,40);
1549                  }
1550              }
1551          }
1552          if ((ri-&gt;flags &amp; SRI_MASTER) &amp;&amp;
1553              sdslen(l) &gt;= 7 &amp;&amp;
1554              !memcmp(l,&quot;slave&quot;,5) &amp;&amp; isdigit(l[5]))
1555          {
1556              char *ip, *port, *end;
1557              if (strstr(l,&quot;ip=&quot;) == NULL) {
1558                  ip = strchr(l,&#x27;:&#x27;); if (!ip) continue;
1559                  ip++; &amp;bsol;* Now ip points to start of ip address. */
1560                  port = strchr(ip,&#x27;,&#x27;); if (!port) continue;
1561                  *port = &#x27;\0&#x27;; &amp;bsol;* nul term for easy access. */
1562                  port++; &amp;bsol;* Now port points to start of port number. */
1563                  end = strchr(port,&#x27;,&#x27;); if (!end) continue;
1564                  *end = &#x27;\0&#x27;; &amp;bsol;* nul term for easy access. */
1565              } else {
1566                  ip = strstr(l,&quot;ip=&quot;); if (!ip) continue;
1567                  ip += 3; &amp;bsol;* Now ip points to start of ip address. */
1568                  port = strstr(l,&quot;port=&quot;); if (!port) continue;
1569                  port += 5; &amp;bsol;* Now port points to start of port number. */
1570                  end = strchr(ip,&#x27;,&#x27;); if (end) *end = &#x27;\0&#x27;;
1571                  end = strchr(port,&#x27;,&#x27;); if (end) *end = &#x27;\0&#x27;;
1572              }
1573              if (sentinelRedisInstanceLookupSlave(ri,ip,atoi(port)) == NULL) {
1574                  if ((slave = createSentinelRedisInstance(NULL,SRI_SLAVE,ip,
1575                              atoi(port), ri-&gt;quorum, ri)) != NULL)
1576                  {
1577                      sentinelEvent(LL_NOTICE,&quot;+slave&quot;,slave,&quot;%@&quot;);
1578                      sentinelFlushConfig();
1579                  }
1580              }
1581          }
1582          if (sdslen(l) &gt;= 32 &amp;&amp;
1583              !memcmp(l,&quot;master_link_down_since_seconds&quot;,30))
1584          {
1585              ri-&gt;master_link_down_time = strtoll(l+31,NULL,10)*1000;
1586          }
1587          if (!memcmp(l,&quot;role:master&quot;,11)) role = SRI_MASTER;
1588          else if (!memcmp(l,&quot;role:slave&quot;,10)) role = SRI_SLAVE;
1589          if (role == SRI_SLAVE) {
1590              if (sdslen(l) &gt;= 12 &amp;&amp; !memcmp(l,&quot;master_host:&quot;,12)) {
1591                  if (ri-&gt;slave_master_host == NULL ||
1592                      strcasecmp(l+12,ri-&gt;slave_master_host))
1593                  {
1594                      sdsfree(ri-&gt;slave_master_host);
1595                      ri-&gt;slave_master_host = sdsnew(l+12);
1596                      ri-&gt;slave_conf_change_time = mstime();
1597                  }
1598              }
1599              if (sdslen(l) &gt;= 12 &amp;&amp; !memcmp(l,&quot;master_port:&quot;,12)) {
1600                  int slave_master_port = atoi(l+12);
1601                  if (ri-&gt;slave_master_port != slave_master_port) {
1602                      ri-&gt;slave_master_port = slave_master_port;
1603                      ri-&gt;slave_conf_change_time = mstime();
1604                  }
1605              }
1606              if (sdslen(l) &gt;= 19 &amp;&amp; !memcmp(l,&quot;master_link_status:&quot;,19)) {
1607                  ri-&gt;slave_master_link_status =
1608                      (strcasecmp(l+19,&quot;up&quot;) == 0) ?
1609                      SENTINEL_MASTER_LINK_STATUS_UP :
1610                      SENTINEL_MASTER_LINK_STATUS_DOWN;
1611              }
1612              if (sdslen(l) &gt;= 15 &amp;&amp; !memcmp(l,&quot;slave_priority:&quot;,15))
1613                  ri-&gt;slave_priority = atoi(l+15);
1614              if (sdslen(l) &gt;= 18 &amp;&amp; !memcmp(l,&quot;slave_repl_offset:&quot;,18))
1615                  ri-&gt;slave_repl_offset = strtoull(l+18,NULL,10);
1616          }
1617      }
1618      ri-&gt;info_refresh = mstime();
1619      sdsfreesplitres(lines,numlines);
1620      if (role != ri-&gt;role_reported) {
1621          ri-&gt;role_reported_time = mstime();
1622          ri-&gt;role_reported = role;
1623          if (role == SRI_SLAVE) ri-&gt;slave_conf_change_time = mstime();
1624          sentinelEvent(LL_VERBOSE,
1625              ((ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) == role) ?
1626              &quot;+role-change&quot; : &quot;-role-change&quot;,
1627              ri, &quot;%@ new reported role is %s&quot;,
1628              role == SRI_MASTER ? &quot;master&quot; : &quot;slave&quot;,
1629              ri-&gt;flags &amp; SRI_MASTER ? &quot;master&quot; : &quot;slave&quot;);
1630      }
1631      if (sentinel.tilt) return;
1632      if ((ri-&gt;flags &amp; SRI_MASTER) &amp;&amp; role == SRI_SLAVE) {
1633      }
1634      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp; role == SRI_MASTER) {
1635          if ((ri-&gt;flags &amp; SRI_PROMOTED) &amp;&amp;
1636              (ri-&gt;master-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) &amp;&amp;
1637              (ri-&gt;master-&gt;failover_state ==
1638                  SENTINEL_FAILOVER_STATE_WAIT_PROMOTION))
1639          {
1640              ri-&gt;master-&gt;config_epoch = ri-&gt;master-&gt;failover_epoch;
1641              ri-&gt;master-&gt;failover_state = SENTINEL_FAILOVER_STATE_RECONF_SLAVES;
1642              ri-&gt;master-&gt;failover_state_change_time = mstime();
1643              sentinelFlushConfig();
1644              sentinelEvent(LL_WARNING,&quot;+promoted-slave&quot;,ri,&quot;%@&quot;);
1645              if (sentinel.simfailure_flags &amp;
1646                  SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION)
1647                  sentinelSimFailureCrash();
1648              sentinelEvent(LL_WARNING,&quot;+failover-state-reconf-slaves&quot;,
1649                  ri-&gt;master,&quot;%@&quot;);
1650              sentinelCallClientReconfScript(ri-&gt;master,SENTINEL_LEADER,
1651                  &quot;start&quot;,ri-&gt;master-&gt;addr,ri-&gt;addr);
1652              sentinelForceHelloUpdateForMaster(ri-&gt;master);
1653          } else {
1654              mstime_t wait_time = SENTINEL_PUBLISH_PERIOD*4;
1655              if (!(ri-&gt;flags &amp; SRI_PROMOTED) &amp;&amp;
1656                   sentinelMasterLooksSane(ri-&gt;master) &amp;&amp;
1657                   sentinelRedisInstanceNoDownFor(ri,wait_time) &amp;&amp;
1658                   mstime() - ri-&gt;role_reported_time &gt; wait_time)
1659              {
1660                  int retval = sentinelSendSlaveOf(ri,
1661                          ri-&gt;master-&gt;addr-&gt;ip,
1662                          ri-&gt;master-&gt;addr-&gt;port);
1663                  if (retval == C_OK)
1664                      sentinelEvent(LL_NOTICE,&quot;+convert-to-slave&quot;,ri,&quot;%@&quot;);
1665              }
1666          }
1667      }
1668      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp;
1669          role == SRI_SLAVE &amp;&amp;
1670          (ri-&gt;slave_master_port != ri-&gt;master-&gt;addr-&gt;port ||
1671           strcasecmp(ri-&gt;slave_master_host,ri-&gt;master-&gt;addr-&gt;ip)))
1672      {
1673          mstime_t wait_time = ri-&gt;master-&gt;failover_timeout;
1674          if (sentinelMasterLooksSane(ri-&gt;master) &amp;&amp;
1675              sentinelRedisInstanceNoDownFor(ri,wait_time) &amp;&amp;
1676              mstime() - ri-&gt;slave_conf_change_time &gt; wait_time)
1677          {
1678              int retval = sentinelSendSlaveOf(ri,
1679                      ri-&gt;master-&gt;addr-&gt;ip,
1680                      ri-&gt;master-&gt;addr-&gt;port);
1681              if (retval == C_OK)
1682                  sentinelEvent(LL_NOTICE,&quot;+fix-slave-config&quot;,ri,&quot;%@&quot;);
1683          }
1684      }
1685      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp; role == SRI_SLAVE &amp;&amp;
1686          (ri-&gt;flags &amp; (SRI_RECONF_SENT|SRI_RECONF_INPROG)))
1687      {
1688          if ((ri-&gt;flags &amp; SRI_RECONF_SENT) &amp;&amp;
1689              ri-&gt;slave_master_host &amp;&amp;
1690              strcmp(ri-&gt;slave_master_host,
1691                      ri-&gt;master-&gt;promoted_slave-&gt;addr-&gt;ip) == 0 &amp;&amp;
1692              ri-&gt;slave_master_port == ri-&gt;master-&gt;promoted_slave-&gt;addr-&gt;port)
1693          {
1694              ri-&gt;flags &amp;= ~SRI_RECONF_SENT;
1695              ri-&gt;flags |= SRI_RECONF_INPROG;
1696              sentinelEvent(LL_NOTICE,&quot;+slave-reconf-inprog&quot;,ri,&quot;%@&quot;);
1697          }
1698          if ((ri-&gt;flags &amp; SRI_RECONF_INPROG) &amp;&amp;
1699              ri-&gt;slave_master_link_status == SENTINEL_MASTER_LINK_STATUS_UP)
1700          {
1701              ri-&gt;flags &amp;= ~SRI_RECONF_INPROG;
1702              ri-&gt;flags |= SRI_RECONF_DONE;
1703              sentinelEvent(LL_NOTICE,&quot;+slave-reconf-done&quot;,ri,&quot;%@&quot;);
1704          }
1705      }
1706  }
1707  void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
1708      sentinelRedisInstance *ri = privdata;
1709      instanceLink *link = c-&gt;data;
1710      redisReply *r;
1711      if (!reply || !link) return;
1712      link-&gt;pending_commands--;
1713      r = reply;
1714      if (r-&gt;type == REDIS_REPLY_STRING)
1715          sentinelRefreshInstanceInfo(ri,r-&gt;str);
1716  }
1717  void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
1718      instanceLink *link = c-&gt;data;
1719      UNUSED(reply);
1720      UNUSED(privdata);
1721      if (link) link-&gt;pending_commands--;
1722  }
1723  void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
1724      sentinelRedisInstance *ri = privdata;
1725      instanceLink *link = c-&gt;data;
1726      redisReply *r;
1727      if (!reply || !link) return;
1728      link-&gt;pending_commands--;
1729      r = reply;
1730      if (r-&gt;type == REDIS_REPLY_STATUS ||
1731          r-&gt;type == REDIS_REPLY_ERROR) {
1732          if (strncmp(r-&gt;str,&quot;PONG&quot;,4) == 0 ||
1733              strncmp(r-&gt;str,&quot;LOADING&quot;,7) == 0 ||
1734              strncmp(r-&gt;str,&quot;MASTERDOWN&quot;,10) == 0)
1735          {
1736              link-&gt;last_avail_time = mstime();
1737              link-&gt;act_ping_time = 0; &amp;bsol;* Flag the pong as received. */
1738          } else {
1739              if (strncmp(r-&gt;str,&quot;BUSY&quot;,4) == 0 &amp;&amp;
1740                  (ri-&gt;flags &amp; SRI_S_DOWN) &amp;&amp;
1741                  !(ri-&gt;flags &amp; SRI_SCRIPT_KILL_SENT))
1742              {
1743                  if (redisAsyncCommand(ri-&gt;link-&gt;cc,
1744                          sentinelDiscardReplyCallback, ri,
1745                          &quot;%s KILL&quot;,
1746                          sentinelInstanceMapCommand(ri,&quot;SCRIPT&quot;)) == C_OK)
1747                  {
1748                      ri-&gt;link-&gt;pending_commands++;
1749                  }
1750                  ri-&gt;flags |= SRI_SCRIPT_KILL_SENT;
1751              }
1752          }
1753      }
1754      link-&gt;last_pong_time = mstime();
1755  }
1756  void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
1757      sentinelRedisInstance *ri = privdata;
1758      instanceLink *link = c-&gt;data;
1759      redisReply *r;
1760      if (!reply || !link) return;
1761      link-&gt;pending_commands--;
1762      r = reply;
1763      if (r-&gt;type != REDIS_REPLY_ERROR)
1764          ri-&gt;last_pub_time = mstime();
1765  }
1766  void sentinelProcessHelloMessage(char *hello, int hello_len) {
1767      int numtokens, port, removed, master_port;
1768      uint64_t current_epoch, master_config_epoch;
1769      char **token = sdssplitlen(hello, hello_len, &quot;,&quot;, 1, &amp;numtokens);
1770      sentinelRedisInstance *si, *master;
1771      if (numtokens == 8) {
1772          master = sentinelGetMasterByName(token[4]);
1773          if (!master) goto cleanup; &amp;bsol;* Unknown master, skip the message. */
1774          port = atoi(token[1]);
1775          master_port = atoi(token[6]);
1776          si = getSentinelRedisInstanceByAddrAndRunID(
1777                          master-&gt;sentinels,token[0],port,token[2]);
1778          current_epoch = strtoull(token[3],NULL,10);
1779          master_config_epoch = strtoull(token[7],NULL,10);
1780          if (!si) {
1781              removed = removeMatchingSentinelFromMaster(master,token[2]);
1782              if (removed) {
1783                  sentinelEvent(LL_NOTICE,&quot;+sentinel-address-switch&quot;,master,
1784                      &quot;%@ ip %s port %d for %s&quot;, token[0],port,token[2]);
1785              } else {
1786                  sentinelRedisInstance *other =
1787                      getSentinelRedisInstanceByAddrAndRunID(
1788                          master-&gt;sentinels, token[0],port,NULL);
1789                  if (other) {
1790                      sentinelEvent(LL_NOTICE,&quot;+sentinel-invalid-addr&quot;,other,&quot;%@&quot;);
1791                      other-&gt;addr-&gt;port = 0; &amp;bsol;* It means: invalid address. */
1792                      sentinelUpdateSentinelAddressInAllMasters(other);
1793                  }
1794              }
1795              si = createSentinelRedisInstance(token[2],SRI_SENTINEL,
1796                              token[0],port,master-&gt;quorum,master);
1797              if (si) {
1798                  if (!removed) sentinelEvent(LL_NOTICE,&quot;+sentinel&quot;,si,&quot;%@&quot;);
1799                  si-&gt;runid = sdsnew(token[2]);
1800                  sentinelTryConnectionSharing(si);
1801                  if (removed) sentinelUpdateSentinelAddressInAllMasters(si);
1802                  sentinelFlushConfig();
1803              }
1804          }
1805          if (current_epoch &gt; sentinel.current_epoch) {
1806              sentinel.current_epoch = current_epoch;
1807              sentinelFlushConfig();
1808              sentinelEvent(LL_WARNING,&quot;+new-epoch&quot;,master,&quot;%llu&quot;,
1809                  (PORT_ULONGLONG) sentinel.current_epoch);
1810          }
1811          if (si &amp;&amp; master-&gt;config_epoch &lt; master_config_epoch) {
1812              master-&gt;config_epoch = master_config_epoch;
1813              if (master_port != master-&gt;addr-&gt;port ||
1814                  strcmp(master-&gt;addr-&gt;ip, token[5]))
1815              {
1816                  sentinelAddr *old_addr;
1817                  sentinelEvent(LL_WARNING,&quot;+config-update-from&quot;,si,&quot;%@&quot;);
1818                  sentinelEvent(LL_WARNING,&quot;+switch-master&quot;,
1819                      master,&quot;%s %s %d %s %d&quot;,
1820                      master-&gt;name,
1821                      master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port,
1822                      token[5], master_port);
1823                  old_addr = dupSentinelAddr(master-&gt;addr);
1824                  sentinelResetMasterAndChangeAddress(master, token[5], master_port);
1825                  sentinelCallClientReconfScript(master,
1826                      SENTINEL_OBSERVER,&quot;start&quot;,
1827                      old_addr,master-&gt;addr);
1828                  releaseSentinelAddr(old_addr);
1829              }
1830          }
1831          if (si) si-&gt;last_hello_time = mstime();
1832      }
1833  cleanup:
1834      sdsfreesplitres(token,numtokens);
1835  }
1836  void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {
1837      sentinelRedisInstance *ri = privdata;
1838      redisReply *r;
1839      UNUSED(c);
1840      if (!reply || !ri) return;
1841      r = reply;
1842      ri-&gt;link-&gt;pc_last_activity = mstime();
1843      if (r-&gt;type != REDIS_REPLY_ARRAY ||
1844          r-&gt;elements != 3 ||
1845          r-&gt;element[0]-&gt;type != REDIS_REPLY_STRING ||
1846          r-&gt;element[1]-&gt;type != REDIS_REPLY_STRING ||
1847          r-&gt;element[2]-&gt;type != REDIS_REPLY_STRING ||
1848          strcmp(r-&gt;element[0]-&gt;str,&quot;message&quot;) != 0) return;
1849      if (strstr(r-&gt;element[2]-&gt;str,sentinel.myid) != NULL) return;
1850      sentinelProcessHelloMessage(r-&gt;element[2]-&gt;str, r-&gt;element[2]-&gt;len);
1851  }
1852  int sentinelSendHello(sentinelRedisInstance *ri) {
1853      char ip[NET_IP_STR_LEN];
1854      char payload[NET_IP_STR_LEN+1024];
1855      int retval;
1856      char *announce_ip;
1857      int announce_port;
1858      sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ? ri : ri-&gt;master;
1859      sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);
1860      if (ri-&gt;link-&gt;disconnected) return C_ERR;
1861      if (sentinel.announce_ip) {
1862          announce_ip = sentinel.announce_ip;
1863      } else {
1864          if (anetSockName(ri-&gt;link-&gt;cc-&gt;c.fd,ip,sizeof(ip),NULL) == -1)
1865              return C_ERR;
1866          announce_ip = ip;
1867      }
1868      announce_port = sentinel.announce_port ?
1869                      sentinel.announce_port : server.port;
1870      snprintf(payload,sizeof(payload),
1871          &quot;%s,%d,%s,%llu,&quot; &amp;bsol;* Info about this sentinel. */
1872          &quot;%s,%s,%d,%llu&quot;, &amp;bsol;* Info about current master. */
1873          announce_ip, announce_port, sentinel.myid,
1874          (PORT_ULONGLONG) sentinel.current_epoch,
1875          master-&gt;name,master_addr-&gt;ip,master_addr-&gt;port,
1876          (PORT_ULONGLONG) master-&gt;config_epoch);
1877      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
1878          sentinelPublishReplyCallback, ri, &quot;%s %s %s&quot;,
1879          sentinelInstanceMapCommand(ri,&quot;PUBLISH&quot;),
1880          SENTINEL_HELLO_CHANNEL,payload);
1881      if (retval != C_OK) return C_ERR;
1882      ri-&gt;link-&gt;pending_commands++;
1883      return C_OK;
1884  }
1885  void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
1886      dictIterator *di;
1887      dictEntry *de;
1888      di = dictGetSafeIterator(instances);
1889      while((de = dictNext(di)) != NULL) {
1890          sentinelRedisInstance *ri = dictGetVal(de);
1891          if (ri-&gt;last_pub_time &gt;= (SENTINEL_PUBLISH_PERIOD+1))
1892              ri-&gt;last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
1893      }
1894      dictReleaseIterator(di);
1895  }
1896  int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {
1897      if (!(master-&gt;flags &amp; SRI_MASTER)) return C_ERR;
1898      if (master-&gt;last_pub_time &gt;= (SENTINEL_PUBLISH_PERIOD+1))
1899          master-&gt;last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
1900      sentinelForceHelloUpdateDictOfRedisInstances(master-&gt;sentinels);
1901      sentinelForceHelloUpdateDictOfRedisInstances(master-&gt;slaves);
1902      return C_OK;
1903  }
1904  int sentinelSendPing(sentinelRedisInstance *ri) {
1905      int retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
1906          sentinelPingReplyCallback, ri, &quot;%s&quot;,
1907          sentinelInstanceMapCommand(ri,&quot;PING&quot;));
1908      if (retval == C_OK) {
1909          ri-&gt;link-&gt;pending_commands++;
1910          ri-&gt;link-&gt;last_ping_time = mstime();
1911          if (ri-&gt;link-&gt;act_ping_time == 0)
1912              ri-&gt;link-&gt;act_ping_time = ri-&gt;link-&gt;last_ping_time;
1913          return 1;
1914      } else {
1915          return 0;
1916      }
1917  }
1918  void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
1919      mstime_t now = mstime();
1920      mstime_t info_period, ping_period;
1921      int retval;
1922      if (ri-&gt;link-&gt;disconnected) return;
1923      if (ri-&gt;link-&gt;pending_commands &gt;=
1924          SENTINEL_MAX_PENDING_COMMANDS * ri-&gt;link-&gt;refcount) return;
1925      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp;
1926          ((ri-&gt;master-&gt;flags &amp; (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS)) ||
1927           (ri-&gt;master_link_down_time != 0)))
1928      {
1929          info_period = 1000;
1930      } else {
1931          info_period = SENTINEL_INFO_PERIOD;
1932      }
1933      ping_period = ri-&gt;down_after_period;
1934      if (ping_period &gt; SENTINEL_PING_PERIOD) ping_period = SENTINEL_PING_PERIOD;
1935      if ((ri-&gt;flags &amp; SRI_SENTINEL) == 0 &amp;&amp;
1936          (ri-&gt;info_refresh == 0 ||
1937          (now - ri-&gt;info_refresh) &gt; info_period))
1938      {
1939          retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
1940              sentinelInfoReplyCallback, ri, &quot;%s&quot;,
1941              sentinelInstanceMapCommand(ri,&quot;INFO&quot;));
1942          if (retval == C_OK) ri-&gt;link-&gt;pending_commands++;
1943      }
1944      if ((now - ri-&gt;link-&gt;last_pong_time) &gt; ping_period &amp;&amp;
1945                 (now - ri-&gt;link-&gt;last_ping_time) &gt; ping_period/2) {
1946          sentinelSendPing(ri);
1947      }
1948      if ((now - ri-&gt;last_pub_time) &gt; SENTINEL_PUBLISH_PERIOD) {
1949          sentinelSendHello(ri);
1950      }
1951  }
1952  const char *sentinelFailoverStateStr(int state) {
1953      switch(state) {
1954      case SENTINEL_FAILOVER_STATE_NONE: return &quot;none&quot;;
1955      case SENTINEL_FAILOVER_STATE_WAIT_START: return &quot;wait_start&quot;;
1956      case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: return &quot;select_slave&quot;;
1957      case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: return &quot;send_slaveof_noone&quot;;
1958      case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: return &quot;wait_promotion&quot;;
1959      case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: return &quot;reconf_slaves&quot;;
1960      case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return &quot;update_config&quot;;
1961      default: return &quot;unknown&quot;;
1962      }
1963  }
1964  void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {
1965      char *flags = sdsempty();
1966      void *mbl;
1967      int fields = 0;
1968      mbl = addDeferredMultiBulkLength(c);
1969      addReplyBulkCString(c,&quot;name&quot;);
1970      addReplyBulkCString(c,ri-&gt;name);
1971      fields++;
1972      addReplyBulkCString(c,&quot;ip&quot;);
1973      addReplyBulkCString(c,ri-&gt;addr-&gt;ip);
1974      fields++;
1975      addReplyBulkCString(c,&quot;port&quot;);
1976      addReplyBulkLongLong(c,ri-&gt;addr-&gt;port);
1977      fields++;
1978      addReplyBulkCString(c,&quot;runid&quot;);
1979      addReplyBulkCString(c,ri-&gt;runid ? ri-&gt;runid : &quot;&quot;);
1980      fields++;
1981      addReplyBulkCString(c,&quot;flags&quot;);
1982      if (ri-&gt;flags &amp; SRI_S_DOWN) flags = sdscat(flags,&quot;s_down,&quot;);
1983      if (ri-&gt;flags &amp; SRI_O_DOWN) flags = sdscat(flags,&quot;o_down,&quot;);
1984      if (ri-&gt;flags &amp; SRI_MASTER) flags = sdscat(flags,&quot;master,&quot;);
1985      if (ri-&gt;flags &amp; SRI_SLAVE) flags = sdscat(flags,&quot;slave,&quot;);
1986      if (ri-&gt;flags &amp; SRI_SENTINEL) flags = sdscat(flags,&quot;sentinel,&quot;);
1987      if (ri-&gt;link-&gt;disconnected) flags = sdscat(flags,&quot;disconnected,&quot;);
1988      if (ri-&gt;flags &amp; SRI_MASTER_DOWN) flags = sdscat(flags,&quot;master_down,&quot;);
1989      if (ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS)
1990          flags = sdscat(flags,&quot;failover_in_progress,&quot;);
1991      if (ri-&gt;flags &amp; SRI_PROMOTED) flags = sdscat(flags,&quot;promoted,&quot;);
1992      if (ri-&gt;flags &amp; SRI_RECONF_SENT) flags = sdscat(flags,&quot;reconf_sent,&quot;);
1993      if (ri-&gt;flags &amp; SRI_RECONF_INPROG) flags = sdscat(flags,&quot;reconf_inprog,&quot;);
1994      if (ri-&gt;flags &amp; SRI_RECONF_DONE) flags = sdscat(flags,&quot;reconf_done,&quot;);
1995      if (sdslen(flags) != 0) sdsrange(flags,0,-2); &amp;bsol;* remove last &quot;,&quot; */
1996      addReplyBulkCString(c,flags);
1997      sdsfree(flags);
1998      fields++;
1999      addReplyBulkCString(c,&quot;link-pending-commands&quot;);
2000      addReplyBulkLongLong(c,ri-&gt;link-&gt;pending_commands);
2001      fields++;
2002      addReplyBulkCString(c,&quot;link-refcount&quot;);
2003      addReplyBulkLongLong(c,ri-&gt;link-&gt;refcount);
2004      fields++;
2005      if (ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) {
2006          addReplyBulkCString(c,&quot;failover-state&quot;);
2007          addReplyBulkCString(c,(char*)sentinelFailoverStateStr(ri-&gt;failover_state));
2008          fields++;
2009      }
2010      addReplyBulkCString(c,&quot;last-ping-sent&quot;);
2011      addReplyBulkLongLong(c,
2012          ri-&gt;link-&gt;act_ping_time ? (mstime() - ri-&gt;link-&gt;act_ping_time) : 0);
2013      fields++;
2014      addReplyBulkCString(c,&quot;last-ok-ping-reply&quot;);
2015      addReplyBulkLongLong(c,mstime() - ri-&gt;link-&gt;last_avail_time);
2016      fields++;
2017      addReplyBulkCString(c,&quot;last-ping-reply&quot;);
2018      addReplyBulkLongLong(c,mstime() - ri-&gt;link-&gt;last_pong_time);
2019      fields++;
2020      if (ri-&gt;flags &amp; SRI_S_DOWN) {
2021          addReplyBulkCString(c,&quot;s-down-time&quot;);
2022          addReplyBulkLongLong(c,mstime()-ri-&gt;s_down_since_time);
2023          fields++;
2024      }
2025      if (ri-&gt;flags &amp; SRI_O_DOWN) {
2026          addReplyBulkCString(c,&quot;o-down-time&quot;);
2027          addReplyBulkLongLong(c,mstime()-ri-&gt;o_down_since_time);
2028          fields++;
2029      }
2030      addReplyBulkCString(c,&quot;down-after-milliseconds&quot;);
2031      addReplyBulkLongLong(c,ri-&gt;down_after_period);
2032      fields++;
2033      if (ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) {
2034          addReplyBulkCString(c,&quot;info-refresh&quot;);
2035          addReplyBulkLongLong(c,mstime() - ri-&gt;info_refresh);
2036          fields++;
2037          addReplyBulkCString(c,&quot;role-reported&quot;);
2038          addReplyBulkCString(c, (ri-&gt;role_reported == SRI_MASTER) ? &quot;master&quot; :
2039                                                                     &quot;slave&quot;);
2040          fields++;
2041          addReplyBulkCString(c,&quot;role-reported-time&quot;);
2042          addReplyBulkLongLong(c,mstime() - ri-&gt;role_reported_time);
2043          fields++;
2044      }
2045      if (ri-&gt;flags &amp; SRI_MASTER) {
2046          addReplyBulkCString(c,&quot;config-epoch&quot;);
2047          addReplyBulkLongLong(c,ri-&gt;config_epoch);
2048          fields++;
2049          addReplyBulkCString(c,&quot;num-slaves&quot;);
2050          addReplyBulkLongLong(c,dictSize(ri-&gt;slaves));
2051          fields++;
2052          addReplyBulkCString(c,&quot;num-other-sentinels&quot;);
2053          addReplyBulkLongLong(c,dictSize(ri-&gt;sentinels));
2054          fields++;
2055          addReplyBulkCString(c,&quot;quorum&quot;);
2056          addReplyBulkLongLong(c,ri-&gt;quorum);
2057          fields++;
2058          addReplyBulkCString(c,&quot;failover-timeout&quot;);
2059          addReplyBulkLongLong(c,ri-&gt;failover_timeout);
2060          fields++;
2061          addReplyBulkCString(c,&quot;parallel-syncs&quot;);
2062          addReplyBulkLongLong(c,ri-&gt;parallel_syncs);
2063          fields++;
2064          if (ri-&gt;notification_script) {
2065              addReplyBulkCString(c,&quot;notification-script&quot;);
2066              addReplyBulkCString(c,ri-&gt;notification_script);
2067              fields++;
2068          }
2069          if (ri-&gt;client_reconfig_script) {
2070              addReplyBulkCString(c,&quot;client-reconfig-script&quot;);
2071              addReplyBulkCString(c,ri-&gt;client_reconfig_script);
2072              fields++;
2073          }
2074      }
2075      if (ri-&gt;flags &amp; SRI_SLAVE) {
2076          addReplyBulkCString(c,&quot;master-link-down-time&quot;);
2077          addReplyBulkLongLong(c,ri-&gt;master_link_down_time);
2078          fields++;
2079          addReplyBulkCString(c,&quot;master-link-status&quot;);
2080          addReplyBulkCString(c,
2081              (ri-&gt;slave_master_link_status == SENTINEL_MASTER_LINK_STATUS_UP) ?
2082              &quot;ok&quot; : &quot;err&quot;);
2083          fields++;
2084          addReplyBulkCString(c,&quot;master-host&quot;);
2085          addReplyBulkCString(c,
2086              ri-&gt;slave_master_host ? ri-&gt;slave_master_host : &quot;?&quot;);
2087          fields++;
2088          addReplyBulkCString(c,&quot;master-port&quot;);
2089          addReplyBulkLongLong(c,ri-&gt;slave_master_port);
2090          fields++;
2091          addReplyBulkCString(c,&quot;slave-priority&quot;);
2092          addReplyBulkLongLong(c,ri-&gt;slave_priority);
2093          fields++;
2094          addReplyBulkCString(c,&quot;slave-repl-offset&quot;);
2095          addReplyBulkLongLong(c,ri-&gt;slave_repl_offset);
2096          fields++;
2097      }
2098      if (ri-&gt;flags &amp; SRI_SENTINEL) {
2099          addReplyBulkCString(c,&quot;last-hello-message&quot;);
2100          addReplyBulkLongLong(c,mstime() - ri-&gt;last_hello_time);
2101          fields++;
2102          addReplyBulkCString(c,&quot;voted-leader&quot;);
2103          addReplyBulkCString(c,ri-&gt;leader ? ri-&gt;leader : &quot;?&quot;);
2104          fields++;
2105          addReplyBulkCString(c,&quot;voted-leader-epoch&quot;);
2106          addReplyBulkLongLong(c,ri-&gt;leader_epoch);
2107          fields++;
2108      }
2109      setDeferredMultiBulkLength(c,mbl,fields*2);
2110  }
2111  void addReplyDictOfRedisInstances(client *c, dict *instances) {
2112      dictIterator *di;
2113      dictEntry *de;
2114      di = dictGetIterator(instances);
2115      addReplyMultiBulkLen(c,(PORT_LONG)dictSize(instances));                   WIN_PORT_FIX &amp;bsol;* cast (PORT_LONG) */
2116      while((de = dictNext(di)) != NULL) {
2117          sentinelRedisInstance *ri = dictGetVal(de);
2118          addReplySentinelRedisInstance(c,ri);
2119      }
2120      dictReleaseIterator(di);
2121  }
2122  sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,
2123                          robj *name)
2124  {
2125      sentinelRedisInstance *ri;
2126      ri = dictFetchValue(sentinel.masters,name-&gt;ptr);
2127      if (!ri) {
2128          addReplyError(c,&quot;No such master with that name&quot;);
2129          return NULL;
2130      }
2131      return ri;
2132  }
2133  #define SENTINEL_ISQR_OK 0
2134  #define SENTINEL_ISQR_NOQUORUM (1&lt;&lt;0)
2135  #define SENTINEL_ISQR_NOAUTH (1&lt;&lt;1)
2136  int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {
2137      dictIterator *di;
2138      dictEntry *de;
2139      int usable = 1; &amp;bsol;* Number of usable Sentinels. Init to 1 to count myself. */
2140      int result = SENTINEL_ISQR_OK;
2141      int voters = (int)dictSize(master-&gt;sentinels)+1; &amp;bsol;* Known Sentinels + myself. */ WIN_PORT_FIX &amp;bsol;* cast (int) */
2142      di = dictGetIterator(master-&gt;sentinels);
2143      while((de = dictNext(di)) != NULL) {
2144          sentinelRedisInstance *ri = dictGetVal(de);
2145          if (ri-&gt;flags &amp; (SRI_S_DOWN|SRI_O_DOWN)) continue;
2146          usable++;
2147      }
2148      dictReleaseIterator(di);
2149      if (usable &lt; (int)master-&gt;quorum) result |= SENTINEL_ISQR_NOQUORUM;
2150      if (usable &lt; voters/2+1) result |= SENTINEL_ISQR_NOAUTH;
2151      if (usableptr) *usableptr = usable;
2152      return result;
2153  }
2154  void sentinelCommand(client *c) {
2155      if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;masters&quot;)) {
2156          if (c-&gt;argc != 2) goto numargserr;
2157          addReplyDictOfRedisInstances(c,sentinel.masters);
2158      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;master&quot;)) {
2159          sentinelRedisInstance *ri;
2160          if (c-&gt;argc != 3) goto numargserr;
2161          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2]))
2162              == NULL) return;
2163          addReplySentinelRedisInstance(c,ri);
2164      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;slaves&quot;) ||
2165                 !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;replicas&quot;))
2166      {
2167          sentinelRedisInstance *ri;
2168          if (c-&gt;argc != 3) goto numargserr;
2169          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2])) == NULL)
2170              return;
2171          addReplyDictOfRedisInstances(c,ri-&gt;slaves);
2172      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;sentinels&quot;)) {
2173          sentinelRedisInstance *ri;
2174          if (c-&gt;argc != 3) goto numargserr;
2175          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2])) == NULL)
2176              return;
2177          addReplyDictOfRedisInstances(c,ri-&gt;sentinels);
2178      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;is-master-down-by-addr&quot;)) {
2179          sentinelRedisInstance *ri;
2180          PORT_LONGLONG req_epoch;
2181          uint64_t leader_epoch = 0;
2182          char *leader = NULL;
2183          PORT_LONG port;
2184          int isdown = 0;
2185          if (c-&gt;argc != 6) goto numargserr;
2186          if (getLongFromObjectOrReply(c,c-&gt;argv[3],&amp;port,NULL) != C_OK ||
2187              getLongLongFromObjectOrReply(c,c-&gt;argv[4],&amp;req_epoch,NULL)
2188                                                                != C_OK)
2189              return;
2190          ri = getSentinelRedisInstanceByAddrAndRunID(sentinel.masters,
2191              c-&gt;argv[2]-&gt;ptr,(int)port,NULL);                                 WIN_PORT_FIX &amp;bsol;* cast (int) */
2192          if (!sentinel.tilt &amp;&amp; ri &amp;&amp; (ri-&gt;flags &amp; SRI_S_DOWN) &amp;&amp;
2193                                      (ri-&gt;flags &amp; SRI_MASTER))
2194              isdown = 1;
2195          if (ri &amp;&amp; ri-&gt;flags &amp; SRI_MASTER &amp;&amp; strcasecmp(c-&gt;argv[5]-&gt;ptr,&quot;*&quot;)) {
2196              leader = sentinelVoteLeader(ri,(uint64_t)req_epoch,
2197                                              c-&gt;argv[5]-&gt;ptr,
2198                                              &amp;leader_epoch);
2199          }
2200          addReplyMultiBulkLen(c,3);
2201          addReply(c, isdown ? shared.cone : shared.czero);
2202          addReplyBulkCString(c, leader ? leader : &quot;*&quot;);
2203          addReplyLongLong(c, (PORT_LONGLONG)leader_epoch);
2204          if (leader) sdsfree(leader);
2205      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;reset&quot;)) {
2206          if (c-&gt;argc != 3) goto numargserr;
2207          addReplyLongLong(c,sentinelResetMastersByPattern(c-&gt;argv[2]-&gt;ptr,SENTINEL_GENERATE_EVENT));
2208      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;get-master-addr-by-name&quot;)) {
2209          sentinelRedisInstance *ri;
2210          if (c-&gt;argc != 3) goto numargserr;
2211          ri = sentinelGetMasterByName(c-&gt;argv[2]-&gt;ptr);
2212          if (ri == NULL) {
2213              addReply(c,shared.nullmultibulk);
2214          } else {
2215              sentinelAddr *addr = sentinelGetCurrentMasterAddress(ri);
2216              addReplyMultiBulkLen(c,2);
2217              addReplyBulkCString(c,addr-&gt;ip);
2218              addReplyBulkLongLong(c,addr-&gt;port);
2219          }
2220      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;failover&quot;)) {
2221          sentinelRedisInstance *ri;
2222          if (c-&gt;argc != 3) goto numargserr;
2223          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2])) == NULL)
2224              return;
2225          if (ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) {
2226              addReplySds(c,sdsnew(&quot;-INPROG Failover already in progress\r\n&quot;));
2227              return;
2228          }
2229          if (sentinelSelectSlave(ri) == NULL) {
2230              addReplySds(c,sdsnew(&quot;-NOGOODSLAVE No suitable replica to promote\r\n&quot;));
2231              return;
2232          }
2233          serverLog(LL_WARNING,&quot;Executing user requested FAILOVER of &#x27;%s&#x27;&quot;,
2234              ri-&gt;name);
2235          sentinelStartFailover(ri);
2236          ri-&gt;flags |= SRI_FORCE_FAILOVER;
2237          addReply(c,shared.ok);
2238      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;pending-scripts&quot;)) {
2239          if (c-&gt;argc != 2) goto numargserr;
2240          sentinelPendingScriptsCommand(c);
2241      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;monitor&quot;)) {
2242          sentinelRedisInstance *ri;
2243          PORT_LONG quorum, port;
2244          char ip[NET_IP_STR_LEN];
2245          if (c-&gt;argc != 6) goto numargserr;
2246          if (getLongFromObjectOrReply(c,c-&gt;argv[5],&amp;quorum,&quot;Invalid quorum&quot;)
2247              != C_OK) return;
2248          if (getLongFromObjectOrReply(c,c-&gt;argv[4],&amp;port,&quot;Invalid port&quot;)
2249              != C_OK) return;
2250          if (quorum &lt;= 0) {
2251              addReplyError(c, &quot;Quorum must be 1 or greater.&quot;);
2252              return;
2253          }
2254          if (anetResolveIP(NULL,c-&gt;argv[3]-&gt;ptr,ip,sizeof(ip)) == ANET_ERR) {
2255              addReplyError(c,&quot;Invalid IP address specified&quot;);
2256              return;
2257          }
2258          ri = createSentinelRedisInstance(c-&gt;argv[2]-&gt;ptr,SRI_MASTER,
2259                  c-&gt;argv[3]-&gt;ptr,(int)port,(int)quorum,NULL);                    WIN_PORT_FIX &amp;bsol;* cast (int) */
2260          if (ri == NULL) {
2261              switch(errno) {
2262              case EBUSY:
2263                  addReplyError(c,&quot;Duplicated master name&quot;);
2264                  break;
2265              case EINVAL:
2266                  addReplyError(c,&quot;Invalid port number&quot;);
2267                  break;
2268              default:
2269                  addReplyError(c,&quot;Unspecified error adding the instance&quot;);
2270                  break;
2271              }
2272          } else {
2273              sentinelFlushConfig();
2274              sentinelEvent(LL_WARNING,&quot;+monitor&quot;,ri,&quot;%@ quorum %d&quot;,ri-&gt;quorum);
2275              addReply(c,shared.ok);
2276          }
2277      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;flushconfig&quot;)) {
2278          if (c-&gt;argc != 2) goto numargserr;
2279          sentinelFlushConfig();
2280          addReply(c,shared.ok);
2281          return;
2282      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;remove&quot;)) {
2283          sentinelRedisInstance *ri;
2284          if (c-&gt;argc != 3) goto numargserr;
2285          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2]))
2286              == NULL) return;
2287          sentinelEvent(LL_WARNING,&quot;-monitor&quot;,ri,&quot;%@&quot;);
2288          dictDelete(sentinel.masters,c-&gt;argv[2]-&gt;ptr);
2289          sentinelFlushConfig();
2290          addReply(c,shared.ok);
2291      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;ckquorum&quot;)) {
2292          sentinelRedisInstance *ri;
2293          int usable;
2294          if (c-&gt;argc != 3) goto numargserr;
2295          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2]))
2296              == NULL) return;
2297          int result = sentinelIsQuorumReachable(ri,&amp;usable);
2298          if (result == SENTINEL_ISQR_OK) {
2299              addReplySds(c, sdscatfmt(sdsempty(),
2300                  &quot;+OK %i usable Sentinels. Quorum and failover authorization &quot;
2301                  &quot;can be reached\r\n&quot;,usable));
2302          } else {
2303              sds e = sdscatfmt(sdsempty(),
2304                  &quot;-NOQUORUM %i usable Sentinels. &quot;,usable);
2305              if (result &amp; SENTINEL_ISQR_NOQUORUM)
2306                  e = sdscat(e,&quot;Not enough available Sentinels to reach the&quot;
2307                               &quot; specified quorum for this master&quot;);
2308              if (result &amp; SENTINEL_ISQR_NOAUTH) {
2309                  if (result &amp; SENTINEL_ISQR_NOQUORUM) e = sdscat(e,&quot;. &quot;);
2310                  e = sdscat(e, &quot;Not enough available Sentinels to reach the&quot;
2311                                &quot; majority and authorize a failover&quot;);
2312              }
2313              e = sdscat(e,&quot;\r\n&quot;);
2314              addReplySds(c,e);
2315          }
2316      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;set&quot;)) {
2317          if (c-&gt;argc &lt; 3) goto numargserr;
2318          sentinelSetCommand(c);
2319      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;info-cache&quot;)) {
2320          if (c-&gt;argc &lt; 2) goto numargserr;
2321          mstime_t now = mstime();
2322          dictType copy_keeper = instancesDictType;
2323          copy_keeper.valDestructor = NULL;
2324          dict *masters_local = sentinel.masters;
2325          if (c-&gt;argc &gt; 2) {
2326              masters_local = dictCreate(&amp;copy_keeper, NULL);
2327              for (int i = 2; i &lt; c-&gt;argc; i++) {
2328                  sentinelRedisInstance *ri;
2329                  ri = sentinelGetMasterByName(c-&gt;argv[i]-&gt;ptr);
2330                  if (!ri) continue; &amp;bsol;* ignore non-existing names */
2331                  dictAdd(masters_local, ri-&gt;name, ri);
2332              }
2333          }
2334          addReplyMultiBulkLen(c,dictSize(masters_local) * 2);
2335          dictIterator  *di;
2336          dictEntry *de;
2337          di = dictGetIterator(masters_local);
2338          while ((de = dictNext(di)) != NULL) {
2339              sentinelRedisInstance *ri = dictGetVal(de);
2340              addReplyBulkCBuffer(c,ri-&gt;name,strlen(ri-&gt;name));
2341              addReplyMultiBulkLen(c,dictSize(ri-&gt;slaves) + 1); &amp;bsol;* +1 for self */
2342              addReplyMultiBulkLen(c,2);
2343              addReplyLongLong(c, now - ri-&gt;info_refresh);
2344              if (ri-&gt;info)
2345                  addReplyBulkCBuffer(c,ri-&gt;info,sdslen(ri-&gt;info));
2346              else
2347                  addReply(c,shared.nullbulk);
2348              dictIterator *sdi;
2349              dictEntry *sde;
2350              sdi = dictGetIterator(ri-&gt;slaves);
2351              while ((sde = dictNext(sdi)) != NULL) {
2352                  sentinelRedisInstance *sri = dictGetVal(sde);
2353                  addReplyMultiBulkLen(c,2);
2354                  addReplyLongLong(c, now - sri-&gt;info_refresh);
2355                  if (sri-&gt;info)
2356                      addReplyBulkCBuffer(c,sri-&gt;info,sdslen(sri-&gt;info));
2357                  else
2358                      addReply(c,shared.nullbulk);
2359              }
2360              dictReleaseIterator(sdi);
2361          }
2362          dictReleaseIterator(di);
2363          if (masters_local != sentinel.masters) dictRelease(masters_local);
2364      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;simulate-failure&quot;)) {
2365          int j;
2366          sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
2367          for (j = 2; j &lt; c-&gt;argc; j++) {
2368              if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;crash-after-election&quot;)) {
2369                  sentinel.simfailure_flags |=
2370                      SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION;
2371                  serverLog(LL_WARNING,&quot;Failure simulation: this Sentinel &quot;
2372                      &quot;will crash after being successfully elected as failover &quot;
2373                      &quot;leader&quot;);
2374              } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;crash-after-promotion&quot;)) {
2375                  sentinel.simfailure_flags |=
2376                      SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION;
2377                  serverLog(LL_WARNING,&quot;Failure simulation: this Sentinel &quot;
2378                      &quot;will crash after promoting the selected replica to master&quot;);
2379              } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;help&quot;)) {
2380                  addReplyMultiBulkLen(c,2);
2381                  addReplyBulkCString(c,&quot;crash-after-election&quot;);
2382                  addReplyBulkCString(c,&quot;crash-after-promotion&quot;);
2383              } else {
2384                  addReplyError(c,&quot;Unknown failure simulation specified&quot;);
2385                  return;
2386              }
2387          }
2388          addReply(c,shared.ok);
2389      } else {
2390          addReplyErrorFormat(c,&quot;Unknown sentinel subcommand &#x27;%s&#x27;&quot;,
2391                                 (char*)c-&gt;argv[1]-&gt;ptr);
2392      }
2393      return;
2394  numargserr:
2395      addReplyErrorFormat(c,&quot;Wrong number of arguments for &#x27;sentinel %s&#x27;&quot;,
2396                            (char*)c-&gt;argv[1]-&gt;ptr);
2397  }
2398  #define info_section_from_redis(section_name) do { \
2399      if (defsections || allsections || !strcasecmp(section,section_name)) { \
2400          sds redissection; \
2401          if (sections++) info = sdscat(info,&quot;\r\n&quot;); \
2402          redissection = genRedisInfoString(section_name); \
2403          info = sdscatlen(info,redissection,sdslen(redissection)); \
2404          sdsfree(redissection); \
2405      } \
2406  } while(0)
2407  void sentinelInfoCommand(client *c) {
2408      if (c-&gt;argc &gt; 2) {
2409          addReply(c,shared.syntaxerr);
2410          return;
2411      }
2412      int defsections = 0, allsections = 0;
2413      char *section = c-&gt;argc == 2 ? c-&gt;argv[1]-&gt;ptr : NULL;
2414      if (section) {
2415          allsections = !strcasecmp(section,&quot;all&quot;);
2416          defsections = !strcasecmp(section,&quot;default&quot;);
2417      } else {
2418          defsections = 1;
2419      }
2420      int sections = 0;
2421      sds info = sdsempty();
2422      info_section_from_redis(&quot;server&quot;);
2423      info_section_from_redis(&quot;clients&quot;);
2424      info_section_from_redis(&quot;cpu&quot;);
2425      info_section_from_redis(&quot;stats&quot;);
2426      if (defsections || allsections || !strcasecmp(section,&quot;sentinel&quot;)) {
2427          dictIterator *di;
2428          dictEntry *de;
2429          int master_id = 0;
2430          if (sections++) info = sdscat(info,&quot;\r\n&quot;);
2431          info = sdscatprintf(info,
2432              &quot;# Sentinel\r\n&quot;
2433              &quot;sentinel_masters:%Iu\r\n&quot;                                          WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
2434              &quot;sentinel_tilt:%d\r\n&quot;
2435              &quot;sentinel_running_scripts:%d\r\n&quot;
2436              &quot;sentinel_scripts_queue_length:%Id\r\n&quot;                             WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
2437              &quot;sentinel_simulate_failure_flags:%Iu\r\n&quot;,                          WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
2438              dictSize(sentinel.masters),
2439              sentinel.tilt,
2440              sentinel.running_scripts,
2441              listLength(sentinel.scripts_queue),
2442              sentinel.simfailure_flags);
2443          di = dictGetIterator(sentinel.masters);
2444          while((de = dictNext(di)) != NULL) {
2445              sentinelRedisInstance *ri = dictGetVal(de);
2446              char *status = &quot;ok&quot;;
2447              if (ri-&gt;flags &amp; SRI_O_DOWN) status = &quot;odown&quot;;
2448              else if (ri-&gt;flags &amp; SRI_S_DOWN) status = &quot;sdown&quot;;
2449              info = sdscatprintf(info,
2450                  &quot;master%d:name=%s,status=%s,address=%s:%d,&quot;
2451                  &quot;slaves=%Iu,sentinels=%Iu\r\n&quot;,                                 WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
2452                  master_id++, ri-&gt;name, status,
2453                  ri-&gt;addr-&gt;ip, ri-&gt;addr-&gt;port,
2454                  dictSize(ri-&gt;slaves),
2455                  dictSize(ri-&gt;sentinels)+1);
2456          }
2457          dictReleaseIterator(di);
2458      }
2459      addReplyBulkSds(c, info);
2460  }
2461  void sentinelRoleCommand(client *c) {
2462      dictIterator *di;
2463      dictEntry *de;
2464      addReplyMultiBulkLen(c,2);
2465      addReplyBulkCBuffer(c,&quot;sentinel&quot;,8);
2466      addReplyMultiBulkLen(c,(PORT_LONG)dictSize(sentinel.masters));
2467      di = dictGetIterator(sentinel.masters);
2468      while((de = dictNext(di)) != NULL) {
2469          sentinelRedisInstance *ri = dictGetVal(de);
2470          addReplyBulkCString(c,ri-&gt;name);
2471      }
2472      dictReleaseIterator(di);
2473  }
2474  void sentinelSetCommand(client *c) {
2475      sentinelRedisInstance *ri;
2476      int j, changes = 0;
2477      int badarg = 0; &amp;bsol;* Bad argument position for error reporting. */
2478      char *option;
2479      if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2]))
2480          == NULL) return;
2481      for (j = 3; j &lt; c-&gt;argc; j++) {
2482          int moreargs = (c-&gt;argc-1) - j;
2483          option = c-&gt;argv[j]-&gt;ptr;
2484          PORT_LONGLONG ll;
2485          int old_j = j; &amp;bsol;* Used to know what to log as an event. */
2486          if (!strcasecmp(option,&quot;down-after-milliseconds&quot;) &amp;&amp; moreargs &gt; 0) {
2487              robj *o = c-&gt;argv[++j];
2488              if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt;= 0) {
2489                  badarg = j;
2490                  goto badfmt;
2491              }
2492              ri-&gt;down_after_period = ll;
2493              sentinelPropagateDownAfterPeriod(ri);
2494              changes++;
2495          } else if (!strcasecmp(option,&quot;failover-timeout&quot;) &amp;&amp; moreargs &gt; 0) {
2496              robj *o = c-&gt;argv[++j];
2497              if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt;= 0) {
2498                  badarg = j;
2499                  goto badfmt;
2500              }
2501              ri-&gt;failover_timeout = ll;
2502              changes++;
2503          } else if (!strcasecmp(option,&quot;parallel-syncs&quot;) &amp;&amp; moreargs &gt; 0) {
2504              robj *o = c-&gt;argv[++j];
2505              if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt;= 0) {
2506                  badarg = j;
2507                  goto badfmt;
2508              }
2509              ri-&gt;parallel_syncs = ll;
2510              changes++;
2511          } else if (!strcasecmp(option,&quot;notification-script&quot;) &amp;&amp; moreargs &gt; 0) {
2512              char *value = c-&gt;argv[++j]-&gt;ptr;
2513              if (sentinel.deny_scripts_reconfig) {
2514                  addReplyError(c,
2515                      &quot;Reconfiguration of scripts path is denied for &quot;
2516                      &quot;security reasons. Check the deny-scripts-reconfig &quot;
2517                      &quot;configuration directive in your Sentinel configuration&quot;);
2518                  return;
2519              }
2520              if (strlen(value) &amp;&amp; access(value,X_OK) == -1) {
2521                  addReplyError(c,
2522                      &quot;Notification script seems non existing or non executable&quot;);
2523                  if (changes) sentinelFlushConfig();
2524                  return;
2525              }
2526              sdsfree(ri-&gt;notification_script);
2527              ri-&gt;notification_script = strlen(value) ? sdsnew(value) : NULL;
2528              changes++;
2529          } else if (!strcasecmp(option,&quot;client-reconfig-script&quot;) &amp;&amp; moreargs &gt; 0) {
2530              char *value = c-&gt;argv[++j]-&gt;ptr;
2531              if (sentinel.deny_scripts_reconfig) {
2532                  addReplyError(c,
2533                      &quot;Reconfiguration of scripts path is denied for &quot;
2534                      &quot;security reasons. Check the deny-scripts-reconfig &quot;
2535                      &quot;configuration directive in your Sentinel configuration&quot;);
2536                  return;
2537              }
2538              if (strlen(value) &amp;&amp; access(value,X_OK) == -1) {
2539                  addReplyError(c,
2540                      &quot;Client reconfiguration script seems non existing or &quot;
2541                      &quot;non executable&quot;);
2542                  if (changes) sentinelFlushConfig();
2543                  return;
2544              }
2545              sdsfree(ri-&gt;client_reconfig_script);
2546              ri-&gt;client_reconfig_script = strlen(value) ? sdsnew(value) : NULL;
2547              changes++;
2548          } else if (!strcasecmp(option,&quot;auth-pass&quot;) &amp;&amp; moreargs &gt; 0) {
2549              char *value = c-&gt;argv[++j]-&gt;ptr;
2550              sdsfree(ri-&gt;auth_pass);
2551              ri-&gt;auth_pass = strlen(value) ? sdsnew(value) : NULL;
2552              changes++;
2553          } else if (!strcasecmp(option,&quot;quorum&quot;) &amp;&amp; moreargs &gt; 0) {
2554              robj *o = c-&gt;argv[++j];
2555              if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt;= 0) {
2556                  badarg = j;
2557                  goto badfmt;
2558              }
2559              ri-&gt;quorum = ll;
2560              changes++;
2561          } else if (!strcasecmp(option,&quot;rename-command&quot;) &amp;&amp; moreargs &gt; 1) {
2562              sds oldname = c-&gt;argv[++j]-&gt;ptr;
2563              sds newname = c-&gt;argv[++j]-&gt;ptr;
2564              if ((sdslen(oldname) == 0) || (sdslen(newname) == 0)) {
2565                  badarg = sdslen(newname) ? j-1 : j;
2566                  goto badfmt;
2567              }
2568              dictDelete(ri-&gt;renamed_commands,oldname);
2569              if (!dictSdsKeyCaseCompare(NULL,oldname,newname)) {
2570                  oldname = sdsdup(oldname);
2571                  newname = sdsdup(newname);
2572                  dictAdd(ri-&gt;renamed_commands,oldname,newname);
2573              }
2574              changes++;
2575          } else {
2576              addReplyErrorFormat(c,&quot;Unknown option or number of arguments for &quot;
2577                                    &quot;SENTINEL SET &#x27;%s&#x27;&quot;, option);
2578              if (changes) sentinelFlushConfig();
2579              return;
2580          }
2581          int numargs = j-old_j+1;
2582          switch(numargs) {
2583          case 2:
2584              sentinelEvent(LL_WARNING,&quot;+set&quot;,ri,&quot;%@ %s %s&quot;,c-&gt;argv[old_j]-&gt;ptr,
2585                                                            c-&gt;argv[old_j+1]-&gt;ptr);
2586              break;
2587          case 3:
2588              sentinelEvent(LL_WARNING,&quot;+set&quot;,ri,&quot;%@ %s %s %s&quot;,c-&gt;argv[old_j]-&gt;ptr,
2589                                                               c-&gt;argv[old_j+1]-&gt;ptr,
2590                                                               c-&gt;argv[old_j+2]-&gt;ptr);
2591              break;
2592          default:
2593              sentinelEvent(LL_WARNING,&quot;+set&quot;,ri,&quot;%@ %s&quot;,c-&gt;argv[old_j]-&gt;ptr);
2594              break;
2595          }
2596      }
2597      if (changes) sentinelFlushConfig();
2598      addReply(c,shared.ok);
2599      return;
2600  badfmt: &amp;bsol;* Bad format errors */
2601      if (changes) sentinelFlushConfig();
2602      addReplyErrorFormat(c,&quot;Invalid argument &#x27;%s&#x27; for SENTINEL SET &#x27;%s&#x27;&quot;,
2603          (char*)c-&gt;argv[badarg]-&gt;ptr,option);
2604  }
2605  void sentinelPublishCommand(client *c) {
2606      if (strcmp(c-&gt;argv[1]-&gt;ptr,SENTINEL_HELLO_CHANNEL)) {
2607          addReplyError(c, &quot;Only HELLO messages are accepted by Sentinel instances.&quot;);
2608          return;
2609      }
2610      sentinelProcessHelloMessage(c-&gt;argv[2]-&gt;ptr,(int)sdslen(c-&gt;argv[2]-&gt;ptr));  WIN_PORT_FIX &amp;bsol;* cast (int) */
2611      addReplyLongLong(c,1);
2612  }
2613  void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
2614      mstime_t elapsed = 0;
2615      if (ri-&gt;link-&gt;act_ping_time)
2616          elapsed = mstime() - ri-&gt;link-&gt;act_ping_time;
2617      else if (ri-&gt;link-&gt;disconnected)
2618          elapsed = mstime() - ri-&gt;link-&gt;last_avail_time;
2619      if (ri-&gt;link-&gt;cc &amp;&amp;
2620          (mstime() - ri-&gt;link-&gt;cc_conn_time) &gt;
2621          SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp;
2622          ri-&gt;link-&gt;act_ping_time != 0 &amp;&amp; &amp;bsol;* There is a pending ping... */
2623          (mstime() - ri-&gt;link-&gt;act_ping_time) &gt; (ri-&gt;down_after_period/2) &amp;&amp;
2624          (mstime() - ri-&gt;link-&gt;last_pong_time) &gt; (ri-&gt;down_after_period/2))
2625      {
2626          instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;cc);
2627      }
2628      if (ri-&gt;link-&gt;pc &amp;&amp;
2629          (mstime() - ri-&gt;link-&gt;pc_conn_time) &gt;
2630           SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp;
2631          (mstime() - ri-&gt;link-&gt;pc_last_activity) &gt; (SENTINEL_PUBLISH_PERIOD*3))
2632      {
2633          instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;pc);
2634      }
2635      if (elapsed &gt; ri-&gt;down_after_period ||
2636          (ri-&gt;flags &amp; SRI_MASTER &amp;&amp;
2637           ri-&gt;role_reported == SRI_SLAVE &amp;&amp;
2638           mstime() - ri-&gt;role_reported_time &gt;
2639            (ri-&gt;down_after_period+SENTINEL_INFO_PERIOD*2)))
2640      {
2641          if ((ri-&gt;flags &amp; SRI_S_DOWN) == 0) {
2642              sentinelEvent(LL_WARNING,&quot;+sdown&quot;,ri,&quot;%@&quot;);
2643              ri-&gt;s_down_since_time = mstime();
2644              ri-&gt;flags |= SRI_S_DOWN;
2645          }
2646      } else {
2647          if (ri-&gt;flags &amp; SRI_S_DOWN) {
2648              sentinelEvent(LL_WARNING,&quot;-sdown&quot;,ri,&quot;%@&quot;);
2649              ri-&gt;flags &amp;= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);
2650          }
2651      }
2652  }
2653  void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
2654      dictIterator *di;
2655      dictEntry *de;
2656      unsigned int quorum = 0, odown = 0;
2657      if (master-&gt;flags &amp; SRI_S_DOWN) {
2658          quorum = 1; &amp;bsol;* the current sentinel. */
2659          di = dictGetIterator(master-&gt;sentinels);
2660          while((de = dictNext(di)) != NULL) {
2661              sentinelRedisInstance *ri = dictGetVal(de);
2662              if (ri-&gt;flags &amp; SRI_MASTER_DOWN) quorum++;
2663          }
2664          dictReleaseIterator(di);
2665          if (quorum &gt;= master-&gt;quorum) odown = 1;
2666      }
2667      if (odown) {
2668          if ((master-&gt;flags &amp; SRI_O_DOWN) == 0) {
2669              sentinelEvent(LL_WARNING,&quot;+odown&quot;,master,&quot;%@ #quorum %d/%d&quot;,
2670                  quorum, master-&gt;quorum);
2671              master-&gt;flags |= SRI_O_DOWN;
2672              master-&gt;o_down_since_time = mstime();
2673          }
2674      } else {
2675          if (master-&gt;flags &amp; SRI_O_DOWN) {
2676              sentinelEvent(LL_WARNING,&quot;-odown&quot;,master,&quot;%@&quot;);
2677              master-&gt;flags &amp;= ~SRI_O_DOWN;
2678          }
2679      }
2680  }
2681  void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {
2682      sentinelRedisInstance *ri = privdata;
2683      instanceLink *link = c-&gt;data;
2684      redisReply *r;
2685      if (!reply || !link) return;
2686      link-&gt;pending_commands--;
2687      r = reply;
2688      if (r-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; r-&gt;elements == 3 &amp;&amp;
2689          r-&gt;element[0]-&gt;type == REDIS_REPLY_INTEGER &amp;&amp;
2690          r-&gt;element[1]-&gt;type == REDIS_REPLY_STRING &amp;&amp;
2691          r-&gt;element[2]-&gt;type == REDIS_REPLY_INTEGER)
2692      {
2693          ri-&gt;last_master_down_reply_time = mstime();
2694          if (r-&gt;element[0]-&gt;integer == 1) {
2695              ri-&gt;flags |= SRI_MASTER_DOWN;
2696          } else {
2697              ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;
2698          }
2699          if (strcmp(r-&gt;element[1]-&gt;str,&quot;*&quot;)) {
2700              sdsfree(ri-&gt;leader);
2701              if ((PORT_LONGLONG)ri-&gt;leader_epoch != r-&gt;element[2]-&gt;integer)
2702                  serverLog(LL_WARNING,
2703                      &quot;%s voted for %s %llu&quot;, ri-&gt;name,
2704                      r-&gt;element[1]-&gt;str,
2705                      (PORT_ULONGLONG) r-&gt;element[2]-&gt;integer);
2706              ri-&gt;leader = sdsnew(r-&gt;element[1]-&gt;str);
2707              ri-&gt;leader_epoch = r-&gt;element[2]-&gt;integer;
2708          }
2709      }
2710  }
2711  #define SENTINEL_ASK_FORCED (1&lt;&lt;0)
2712  void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {
2713      dictIterator *di;
2714      dictEntry *de;
2715      di = dictGetIterator(master-&gt;sentinels);
2716      while((de = dictNext(di)) != NULL) {
2717          sentinelRedisInstance *ri = dictGetVal(de);
2718          mstime_t elapsed = mstime() - ri-&gt;last_master_down_reply_time;
2719          char port[32];
2720          int retval;
2721          if (elapsed &gt; SENTINEL_ASK_PERIOD*5) {
2722              ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;
2723              sdsfree(ri-&gt;leader);
2724              ri-&gt;leader = NULL;
2725          }
2726          if ((master-&gt;flags &amp; SRI_S_DOWN) == 0) continue;
2727          if (ri-&gt;link-&gt;disconnected) continue;
2728          if (!(flags &amp; SENTINEL_ASK_FORCED) &amp;&amp;
2729              mstime() - ri-&gt;last_master_down_reply_time &lt; SENTINEL_ASK_PERIOD)
2730              continue;
2731          ll2string(port,sizeof(port),master-&gt;addr-&gt;port);
2732          retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2733                      sentinelReceiveIsMasterDownReply, ri,
2734                      &quot;%s is-master-down-by-addr %s %s %llu %s&quot;,
2735                      sentinelInstanceMapCommand(ri,&quot;SENTINEL&quot;),
2736                      master-&gt;addr-&gt;ip, port,
2737                      sentinel.current_epoch,
2738                      (master-&gt;failover_state &gt; SENTINEL_FAILOVER_STATE_NONE) ?
2739                      sentinel.myid : &quot;*&quot;);
2740          if (retval == C_OK) ri-&gt;link-&gt;pending_commands++;
2741      }
2742      dictReleaseIterator(di);
2743  }
2744  void sentinelSimFailureCrash(void) {
2745      serverLog(LL_WARNING,
2746          &quot;Sentinel CRASH because of SENTINEL simulate-failure&quot;);
2747      exit(99);
2748  }
2749  char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {
2750      if (req_epoch &gt; sentinel.current_epoch) {
2751          sentinel.current_epoch = req_epoch;
2752          sentinelFlushConfig();
2753          sentinelEvent(LL_WARNING,&quot;+new-epoch&quot;,master,&quot;%llu&quot;,
2754              (PORT_ULONGLONG) sentinel.current_epoch);
2755      }
2756      if (master-&gt;leader_epoch &lt; req_epoch &amp;&amp; sentinel.current_epoch &lt;= req_epoch)
2757      {
2758          sdsfree(master-&gt;leader);
2759          master-&gt;leader = sdsnew(req_runid);
2760          master-&gt;leader_epoch = sentinel.current_epoch;
2761          sentinelFlushConfig();
2762          sentinelEvent(LL_WARNING,&quot;+vote-for-leader&quot;,master,&quot;%s %llu&quot;,
2763              master-&gt;leader, (PORT_ULONGLONG) master-&gt;leader_epoch);
2764          if (strcasecmp(master-&gt;leader,sentinel.myid))
2765              master-&gt;failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
2766      }
2767      *leader_epoch = master-&gt;leader_epoch;
2768      return master-&gt;leader ? sdsnew(master-&gt;leader) : NULL;
2769  }
2770  struct sentinelLeader {
2771      char *runid;
2772      PORT_ULONG votes;
2773  };
2774  int sentinelLeaderIncr(dict *counters, char *runid) {
2775      dictEntry *existing, *de;
2776      uint64_t oldval;
2777      de = dictAddRaw(counters,runid,&amp;existing);
2778      if (existing) {
2779          oldval = dictGetUnsignedIntegerVal(existing);
2780          dictSetUnsignedIntegerVal(existing,oldval+1);
2781          return (int)oldval+1;                                                   WIN_PORT_FIX &amp;bsol;* cast (int) */
2782      } else {
2783          serverAssert(de != NULL);
2784          dictSetUnsignedIntegerVal(de,1);
2785          return 1;
2786      }
2787  }
2788  char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
2789      dict *counters;
2790      dictIterator *di;
2791      dictEntry *de;
2792      unsigned int voters = 0, voters_quorum;
2793      char *myvote;
2794      char *winner = NULL;
2795      uint64_t leader_epoch;
2796      uint64_t max_votes = 0;
2797      serverAssert(master-&gt;flags &amp; (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));
2798      counters = dictCreate(&amp;leaderVotesDictType,NULL);
2799      voters = (unsigned int)dictSize(master-&gt;sentinels)+1; &amp;bsol;* All the other sentinels and me.*/  WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
2800      di = dictGetIterator(master-&gt;sentinels);
2801      while((de = dictNext(di)) != NULL) {
2802          sentinelRedisInstance *ri = dictGetVal(de);
2803          if (ri-&gt;leader != NULL &amp;&amp; ri-&gt;leader_epoch == sentinel.current_epoch)
2804              sentinelLeaderIncr(counters,ri-&gt;leader);
2805      }
2806      dictReleaseIterator(di);
2807      di = dictGetIterator(counters);
2808      while((de = dictNext(di)) != NULL) {
2809          uint64_t votes = dictGetUnsignedIntegerVal(de);
2810          if (votes &gt; max_votes) {
2811              max_votes = votes;
2812              winner = dictGetKey(de);
2813          }
2814      }
2815      dictReleaseIterator(di);
2816      if (winner)
2817          myvote = sentinelVoteLeader(master,epoch,winner,&amp;leader_epoch);
2818      else
2819          myvote = sentinelVoteLeader(master,epoch,sentinel.myid,&amp;leader_epoch);
2820      if (myvote &amp;&amp; leader_epoch == epoch) {
2821          uint64_t votes = sentinelLeaderIncr(counters,myvote);
2822          if (votes &gt; max_votes) {
2823              max_votes = votes;
2824              winner = myvote;
2825          }
2826      }
2827      voters_quorum = voters/2+1;
2828      if (winner &amp;&amp; (max_votes &lt; voters_quorum || max_votes &lt; master-&gt;quorum))
2829          winner = NULL;
2830      winner = winner ? sdsnew(winner) : NULL;
2831      sdsfree(myvote);
2832      dictRelease(counters);
2833      return winner;
2834  }
2835  int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {
2836      char portstr[32];
2837      int retval;
2838      ll2string(portstr,sizeof(portstr),port);
2839      if (host == NULL) {
2840          host = &quot;NO&quot;;
2841          memcpy(portstr,&quot;ONE&quot;,4);
2842      }
2843      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2844          sentinelDiscardReplyCallback, ri, &quot;%s&quot;,
2845          sentinelInstanceMapCommand(ri,&quot;MULTI&quot;));
2846      if (retval == C_ERR) return retval;
2847      ri-&gt;link-&gt;pending_commands++;
2848      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2849          sentinelDiscardReplyCallback, ri, &quot;%s %s %s&quot;,
2850          sentinelInstanceMapCommand(ri,&quot;SLAVEOF&quot;),
2851          host, portstr);
2852      if (retval == C_ERR) return retval;
2853      ri-&gt;link-&gt;pending_commands++;
2854      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2855          sentinelDiscardReplyCallback, ri, &quot;%s REWRITE&quot;,
2856          sentinelInstanceMapCommand(ri,&quot;CONFIG&quot;));
2857      if (retval == C_ERR) return retval;
2858      ri-&gt;link-&gt;pending_commands++;
2859      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2860          sentinelDiscardReplyCallback, ri, &quot;%s KILL TYPE normal&quot;,
2861          sentinelInstanceMapCommand(ri,&quot;CLIENT&quot;));
2862      if (retval == C_ERR) return retval;
2863      ri-&gt;link-&gt;pending_commands++;
2864      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2865          sentinelDiscardReplyCallback, ri, &quot;%s&quot;,
2866          sentinelInstanceMapCommand(ri,&quot;EXEC&quot;));
2867      if (retval == C_ERR) return retval;
2868      ri-&gt;link-&gt;pending_commands++;
2869      return C_OK;
2870  }
2871  void sentinelStartFailover(sentinelRedisInstance *master) {
2872      serverAssert(master-&gt;flags &amp; SRI_MASTER);
2873      master-&gt;failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
2874      master-&gt;flags |= SRI_FAILOVER_IN_PROGRESS;
2875      master-&gt;failover_epoch = ++sentinel.current_epoch;
2876      sentinelEvent(LL_WARNING,&quot;+new-epoch&quot;,master,&quot;%llu&quot;,
2877          (PORT_ULONGLONG) sentinel.current_epoch);
2878      sentinelEvent(LL_WARNING,&quot;+try-failover&quot;,master,&quot;%@&quot;);
2879      master-&gt;failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
2880      master-&gt;failover_state_change_time = mstime();
2881  }
2882  int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
2883      if (!(master-&gt;flags &amp; SRI_O_DOWN)) return 0;
2884      if (master-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) return 0;
2885      if (mstime() - master-&gt;failover_start_time &lt;
2886          master-&gt;failover_timeout*2)
2887      {
2888          if (master-&gt;failover_delay_logged != master-&gt;failover_start_time) {
2889              time_t clock = (master-&gt;failover_start_time +
2890                              master-&gt;failover_timeout*2) / 1000;
2891              char ctimebuf[26];
2892              ctime_r(&amp;clock,ctimebuf);
2893              ctimebuf[24] = &#x27;\0&#x27;; &amp;bsol;* Remove newline. */
2894              master-&gt;failover_delay_logged = master-&gt;failover_start_time;
2895              serverLog(LL_WARNING,
2896                  &quot;Next failover delay: I will not start a failover before %s&quot;,
2897                  ctimebuf);
2898          }
2899          return 0;
2900      }
2901      sentinelStartFailover(master);
2902      return 1;
2903  }
2904  int compareSlavesForPromotion(const void *a, const void *b) {
2905      sentinelRedisInstance **sa = (sentinelRedisInstance **)a,
2906                            **sb = (sentinelRedisInstance **)b;
2907      char *sa_runid, *sb_runid;
2908      if ((*sa)-&gt;slave_priority != (*sb)-&gt;slave_priority)
2909          return (*sa)-&gt;slave_priority - (*sb)-&gt;slave_priority;
2910      if ((*sa)-&gt;slave_repl_offset &gt; (*sb)-&gt;slave_repl_offset) {
2911          return -1; &amp;bsol;* a &lt; b */
2912      } else if ((*sa)-&gt;slave_repl_offset &lt; (*sb)-&gt;slave_repl_offset) {
2913          return 1; &amp;bsol;* a &gt; b */
2914      }
2915      sa_runid = (*sa)-&gt;runid;
2916      sb_runid = (*sb)-&gt;runid;
2917      if (sa_runid == NULL &amp;&amp; sb_runid == NULL) return 0;
2918      else if (sa_runid == NULL) return 1;  &amp;bsol;* a &gt; b */
2919      else if (sb_runid == NULL) return -1; &amp;bsol;* a &lt; b */
2920      return strcasecmp(sa_runid, sb_runid);
2921  }
2922  sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
2923      sentinelRedisInstance **instance =
2924          zmalloc(sizeof(instance[0])*dictSize(master-&gt;slaves));
2925      sentinelRedisInstance *selected = NULL;
2926      int instances = 0;
2927      dictIterator *di;
2928      dictEntry *de;
2929      mstime_t max_master_down_time = 0;
2930      if (master-&gt;flags &amp; SRI_S_DOWN)
2931          max_master_down_time += mstime() - master-&gt;s_down_since_time;
2932      max_master_down_time += master-&gt;down_after_period * 10;
2933      di = dictGetIterator(master-&gt;slaves);
2934      while((de = dictNext(di)) != NULL) {
2935          sentinelRedisInstance *slave = dictGetVal(de);
2936          mstime_t info_validity_time;
2937          if (slave-&gt;flags &amp; (SRI_S_DOWN|SRI_O_DOWN)) continue;
2938          if (slave-&gt;link-&gt;disconnected) continue;
2939          if (mstime() - slave-&gt;link-&gt;last_avail_time &gt; SENTINEL_PING_PERIOD*5) continue;
2940          if (slave-&gt;slave_priority == 0) continue;
2941          if (master-&gt;flags &amp; SRI_S_DOWN)
2942              info_validity_time = SENTINEL_PING_PERIOD*5;
2943          else
2944              info_validity_time = SENTINEL_INFO_PERIOD*3;
2945          if (mstime() - slave-&gt;info_refresh &gt; info_validity_time) continue;
2946          if (slave-&gt;master_link_down_time &gt; max_master_down_time) continue;
2947          instance[instances++] = slave;
2948      }
2949      dictReleaseIterator(di);
2950      if (instances) {
2951          qsort(instance,instances,sizeof(sentinelRedisInstance*),
2952              compareSlavesForPromotion);
2953          selected = instance[0];
2954      }
2955      zfree(instance);
2956      return selected;
2957  }
2958  void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
2959      char *leader;
2960      int isleader;
2961      leader = sentinelGetLeader(ri, ri-&gt;failover_epoch);
2962      isleader = leader &amp;&amp; strcasecmp(leader,sentinel.myid) == 0;
2963      sdsfree(leader);
2964      if (!isleader &amp;&amp; !(ri-&gt;flags &amp; SRI_FORCE_FAILOVER)) {
2965          int election_timeout = SENTINEL_ELECTION_TIMEOUT;
2966          if (election_timeout &gt; ri-&gt;failover_timeout)
2967              election_timeout = (int)ri-&gt;failover_timeout;                       WIN_PORT_FIX &amp;bsol;* cast (int) */
2968          if (mstime() - ri-&gt;failover_start_time &gt; election_timeout) {
2969              sentinelEvent(LL_WARNING,&quot;-failover-abort-not-elected&quot;,ri,&quot;%@&quot;);
2970              sentinelAbortFailover(ri);
2971          }
2972          return;
2973      }
2974      sentinelEvent(LL_WARNING,&quot;+elected-leader&quot;,ri,&quot;%@&quot;);
2975      if (sentinel.simfailure_flags &amp; SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION)
2976          sentinelSimFailureCrash();
2977      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;
2978      ri-&gt;failover_state_change_time = mstime();
2979      sentinelEvent(LL_WARNING,&quot;+failover-state-select-slave&quot;,ri,&quot;%@&quot;);
2980  }
2981  void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
2982      sentinelRedisInstance *slave = sentinelSelectSlave(ri);
2983      if (slave == NULL) {
2984          sentinelEvent(LL_WARNING,&quot;-failover-abort-no-good-slave&quot;,ri,&quot;%@&quot;);
2985          sentinelAbortFailover(ri);
2986      } else {
2987          sentinelEvent(LL_WARNING,&quot;+selected-slave&quot;,slave,&quot;%@&quot;);
2988          slave-&gt;flags |= SRI_PROMOTED;
2989          ri-&gt;promoted_slave = slave;
2990          ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE;
2991          ri-&gt;failover_state_change_time = mstime();
2992          sentinelEvent(LL_NOTICE,&quot;+failover-state-send-slaveof-noone&quot;,
2993              slave, &quot;%@&quot;);
2994      }
2995  }
2996  void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
2997      int retval;
2998      if (ri-&gt;promoted_slave-&gt;link-&gt;disconnected) {
2999          if (mstime() - ri-&gt;failover_state_change_time &gt; ri-&gt;failover_timeout) {
3000              sentinelEvent(LL_WARNING,&quot;-failover-abort-slave-timeout&quot;,ri,&quot;%@&quot;);
3001              sentinelAbortFailover(ri);
3002          }
3003          return;
3004      }
3005      retval = sentinelSendSlaveOf(ri-&gt;promoted_slave,NULL,0);
3006      if (retval != C_OK) return;
3007      sentinelEvent(LL_NOTICE, &quot;+failover-state-wait-promotion&quot;,
3008          ri-&gt;promoted_slave,&quot;%@&quot;);
3009      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_WAIT_PROMOTION;
3010      ri-&gt;failover_state_change_time = mstime();
3011  }
3012  void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
3013      if (mstime() - ri-&gt;failover_state_change_time &gt; ri-&gt;failover_timeout) {
3014          sentinelEvent(LL_WARNING,&quot;-failover-abort-slave-timeout&quot;,ri,&quot;%@&quot;);
3015          sentinelAbortFailover(ri);
3016      }
3017  }
3018  void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
3019      int not_reconfigured = 0, timeout = 0;
3020      dictIterator *di;
3021      dictEntry *de;
3022      mstime_t elapsed = mstime() - master-&gt;failover_state_change_time;
3023      if (master-&gt;promoted_slave == NULL ||
3024          master-&gt;promoted_slave-&gt;flags &amp; SRI_S_DOWN) return;
3025      di = dictGetIterator(master-&gt;slaves);
3026      while((de = dictNext(di)) != NULL) {
3027          sentinelRedisInstance *slave = dictGetVal(de);
3028          if (slave-&gt;flags &amp; (SRI_PROMOTED|SRI_RECONF_DONE)) continue;
3029          if (slave-&gt;flags &amp; SRI_S_DOWN) continue;
3030          not_reconfigured++;
3031      }
3032      dictReleaseIterator(di);
3033      if (elapsed &gt; master-&gt;failover_timeout) {
3034          not_reconfigured = 0;
3035          timeout = 1;
3036          sentinelEvent(LL_WARNING,&quot;+failover-end-for-timeout&quot;,master,&quot;%@&quot;);
3037      }
3038      if (not_reconfigured == 0) {
3039          sentinelEvent(LL_WARNING,&quot;+failover-end&quot;,master,&quot;%@&quot;);
3040          master-&gt;failover_state = SENTINEL_FAILOVER_STATE_UPDATE_CONFIG;
3041          master-&gt;failover_state_change_time = mstime();
3042      }
3043      if (timeout) {
3044          dictIterator *di;
3045          dictEntry *de;
3046          di = dictGetIterator(master-&gt;slaves);
3047          while((de = dictNext(di)) != NULL) {
3048              sentinelRedisInstance *slave = dictGetVal(de);
3049              int retval;
3050              if (slave-&gt;flags &amp; (SRI_PROMOTED|SRI_RECONF_DONE|SRI_RECONF_SENT)) continue;
3051              if (slave-&gt;link-&gt;disconnected) continue;
3052              retval = sentinelSendSlaveOf(slave,
3053                      master-&gt;promoted_slave-&gt;addr-&gt;ip,
3054                      master-&gt;promoted_slave-&gt;addr-&gt;port);
3055              if (retval == C_OK) {
3056                  sentinelEvent(LL_NOTICE,&quot;+slave-reconf-sent-be&quot;,slave,&quot;%@&quot;);
3057                  slave-&gt;flags |= SRI_RECONF_SENT;
3058              }
3059          }
3060          dictReleaseIterator(di);
3061      }
3062  }
3063  void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {
3064      dictIterator *di;
3065      dictEntry *de;
3066      int in_progress = 0;
3067      di = dictGetIterator(master-&gt;slaves);
3068      while((de = dictNext(di)) != NULL) {
3069          sentinelRedisInstance *slave = dictGetVal(de);
3070          if (slave-&gt;flags &amp; (SRI_RECONF_SENT|SRI_RECONF_INPROG))
3071              in_progress++;
3072      }
3073      dictReleaseIterator(di);
3074      di = dictGetIterator(master-&gt;slaves);
3075      while(in_progress &lt; master-&gt;parallel_syncs &amp;&amp;
3076            (de = dictNext(di)) != NULL)
3077      {
3078          sentinelRedisInstance *slave = dictGetVal(de);
3079          int retval;
3080          if (slave-&gt;flags &amp; (SRI_PROMOTED|SRI_RECONF_DONE)) continue;
3081          if ((slave-&gt;flags &amp; SRI_RECONF_SENT) &amp;&amp;
3082              (mstime() - slave-&gt;slave_reconf_sent_time) &gt;
3083              SENTINEL_SLAVE_RECONF_TIMEOUT)
3084          {
3085              sentinelEvent(LL_NOTICE,&quot;-slave-reconf-sent-timeout&quot;,slave,&quot;%@&quot;);
3086              slave-&gt;flags &amp;= ~SRI_RECONF_SENT;
3087              slave-&gt;flags |= SRI_RECONF_DONE;
3088          }
3089          if (slave-&gt;flags &amp; (SRI_RECONF_SENT|SRI_RECONF_INPROG)) continue;
3090          if (slave-&gt;link-&gt;disconnected) continue;
3091          retval = sentinelSendSlaveOf(slave,
3092                  master-&gt;promoted_slave-&gt;addr-&gt;ip,
3093                  master-&gt;promoted_slave-&gt;addr-&gt;port);
3094          if (retval == C_OK) {
3095              slave-&gt;flags |= SRI_RECONF_SENT;
3096              slave-&gt;slave_reconf_sent_time = mstime();
3097              sentinelEvent(LL_NOTICE,&quot;+slave-reconf-sent&quot;,slave,&quot;%@&quot;);
3098              in_progress++;
3099          }
3100      }
3101      dictReleaseIterator(di);
3102      sentinelFailoverDetectEnd(master);
3103  }
3104  void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
3105      sentinelRedisInstance *ref = master-&gt;promoted_slave ?
3106                                   master-&gt;promoted_slave : master;
3107      sentinelEvent(LL_WARNING,&quot;+switch-master&quot;,master,&quot;%s %s %d %s %d&quot;,
3108          master-&gt;name, master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port,
3109          ref-&gt;addr-&gt;ip, ref-&gt;addr-&gt;port);
3110      sentinelResetMasterAndChangeAddress(master,ref-&gt;addr-&gt;ip,ref-&gt;addr-&gt;port);
3111  }
3112  void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
3113      serverAssert(ri-&gt;flags &amp; SRI_MASTER);
3114      if (!(ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS)) return;
3115      switch(ri-&gt;failover_state) {
3116          case SENTINEL_FAILOVER_STATE_WAIT_START:
3117              sentinelFailoverWaitStart(ri);
3118              break;
3119          case SENTINEL_FAILOVER_STATE_SELECT_SLAVE:
3120              sentinelFailoverSelectSlave(ri);
3121              break;
3122          case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:
3123              sentinelFailoverSendSlaveOfNoOne(ri);
3124              break;
3125          case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:
3126              sentinelFailoverWaitPromotion(ri);
3127              break;
3128          case SENTINEL_FAILOVER_STATE_RECONF_SLAVES:
3129              sentinelFailoverReconfNextSlave(ri);
3130              break;
3131      }
3132  }
3133  void sentinelAbortFailover(sentinelRedisInstance *ri) {
3134      serverAssert(ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS);
3135      serverAssert(ri-&gt;failover_state &lt;= SENTINEL_FAILOVER_STATE_WAIT_PROMOTION);
3136      ri-&gt;flags &amp;= ~(SRI_FAILOVER_IN_PROGRESS|SRI_FORCE_FAILOVER);
3137      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_NONE;
3138      ri-&gt;failover_state_change_time = mstime();
3139      if (ri-&gt;promoted_slave) {
3140          ri-&gt;promoted_slave-&gt;flags &amp;= ~SRI_PROMOTED;
3141          ri-&gt;promoted_slave = NULL;
3142      }
3143  }
3144  void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
3145      sentinelReconnectInstance(ri);
3146      sentinelSendPeriodicCommands(ri);
3147      if (sentinel.tilt) {
3148          if (mstime()-sentinel.tilt_start_time &lt; SENTINEL_TILT_PERIOD) return;
3149          sentinel.tilt = 0;
3150          sentinelEvent(LL_WARNING,&quot;-tilt&quot;,NULL,&quot;#tilt mode exited&quot;);
3151      }
3152      sentinelCheckSubjectivelyDown(ri);
3153      if (ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) {
3154      }
3155      if (ri-&gt;flags &amp; SRI_MASTER) {
3156          sentinelCheckObjectivelyDown(ri);
3157          if (sentinelStartFailoverIfNeeded(ri))
3158              sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);
3159          sentinelFailoverStateMachine(ri);
3160          sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);
3161      }
3162  }
3163  void sentinelHandleDictOfRedisInstances(dict *instances) {
3164      dictIterator *di;
3165      dictEntry *de;
3166      sentinelRedisInstance *switch_to_promoted = NULL;
3167      di = dictGetIterator(instances);
3168      while((de = dictNext(di)) != NULL) {
3169          sentinelRedisInstance *ri = dictGetVal(de);
3170          sentinelHandleRedisInstance(ri);
3171          if (ri-&gt;flags &amp; SRI_MASTER) {
3172              sentinelHandleDictOfRedisInstances(ri-&gt;slaves);
3173              sentinelHandleDictOfRedisInstances(ri-&gt;sentinels);
3174              if (ri-&gt;failover_state == SENTINEL_FAILOVER_STATE_UPDATE_CONFIG) {
3175                  switch_to_promoted = ri;
3176              }
3177          }
3178      }
3179      if (switch_to_promoted)
3180          sentinelFailoverSwitchToPromotedSlave(switch_to_promoted);
3181      dictReleaseIterator(di);
3182  }
3183  void sentinelCheckTiltCondition(void) {
3184      mstime_t now = mstime();
3185      mstime_t delta = now - sentinel.previous_time;
3186      if (delta &lt; 0 || delta &gt; SENTINEL_TILT_TRIGGER) {
3187          sentinel.tilt = 1;
3188          sentinel.tilt_start_time = mstime();
3189          sentinelEvent(LL_WARNING,&quot;+tilt&quot;,NULL,&quot;#tilt mode entered&quot;);
3190      }
3191      sentinel.previous_time = mstime();
3192  }
3193  void sentinelTimer(void) {
3194      sentinelCheckTiltCondition();
3195      sentinelHandleDictOfRedisInstances(sentinel.masters);
3196      sentinelRunPendingScripts();
3197      sentinelCollectTerminatedScripts();
3198      sentinelKillTimedoutScripts();
3199      server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;
3200  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sentinel.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/Win32_Error.h&quot;
3  #endif
4  #include &quot;server.h&quot;
5  #ifndef _WIN32          
6  #include &quot;hiredis.h&quot;
7  #endif
8  #include &quot;async.h&quot;
9  #include &lt;ctype.h&gt;
10  #ifndef _WIN32
11  #include &lt;arpa/inet.h&gt;
12  #include &lt;sys/socket.h&gt;
13  #include &lt;sys/wait.h&gt;
14  #else
15  #include &lt;stdlib.h&gt;
16  #endif
17  #include &lt;fcntl.h&gt;
18  #ifdef _WIN32
19  #define strtoull _strtoui64
20  #endif
21  #ifndef _WIN32
22  extern char **environ;
23  #endif
24  #define REDIS_SENTINEL_PORT 26379
25  typedef struct sentinelAddr {
26      char *ip;
27      int port;
28  } sentinelAddr;
29  #define SRI_MASTER  (1&lt;&lt;0)
30  #define SRI_SLAVE   (1&lt;&lt;1)
31  #define SRI_SENTINEL (1&lt;&lt;2)
32  #define SRI_S_DOWN (1&lt;&lt;3)   &amp;bsol;* Subjectively down (no quorum). */
33  #define SRI_O_DOWN (1&lt;&lt;4)   &amp;bsol;* Objectively down (confirmed by others). */
34  #define SRI_MASTER_DOWN (1&lt;&lt;5) &amp;bsol;* A Sentinel with this flag set thinks that
35                                     its master is down. */
36  #define SRI_FAILOVER_IN_PROGRESS (1&lt;&lt;6) &amp;bsol;* Failover is in progress for
37                                             this master. */
38  #define SRI_PROMOTED (1&lt;&lt;7)            &amp;bsol;* Slave selected for promotion. */
39  #define SRI_RECONF_SENT (1&lt;&lt;8)     &amp;bsol;* SLAVEOF &lt;newmaster&gt; sent. */
40  #define SRI_RECONF_INPROG (1&lt;&lt;9)   &amp;bsol;* Slave synchronization in progress. */
41  #define SRI_RECONF_DONE (1&lt;&lt;10)     &amp;bsol;* Slave synchronized with new master. */
42  #define SRI_FORCE_FAILOVER (1&lt;&lt;11)  &amp;bsol;* Force failover with master up. */
43  #define SRI_SCRIPT_KILL_SENT (1&lt;&lt;12) &amp;bsol;* SCRIPT KILL already sent on -BUSY */
44  #define SENTINEL_INFO_PERIOD 10000
45  #define SENTINEL_PING_PERIOD 1000
46  #define SENTINEL_ASK_PERIOD 1000
47  #define SENTINEL_PUBLISH_PERIOD 2000
48  #define SENTINEL_DEFAULT_DOWN_AFTER 30000
49  #define SENTINEL_HELLO_CHANNEL &quot;__sentinel__:hello&quot;
50  #define SENTINEL_TILT_TRIGGER 2000
51  #define SENTINEL_TILT_PERIOD (SENTINEL_PING_PERIOD*30)
52  #define SENTINEL_DEFAULT_SLAVE_PRIORITY 100
53  #define SENTINEL_SLAVE_RECONF_TIMEOUT 10000
54  #define SENTINEL_DEFAULT_PARALLEL_SYNCS 1
55  #define SENTINEL_MIN_LINK_RECONNECT_PERIOD 15000
56  #define SENTINEL_DEFAULT_FAILOVER_TIMEOUT (60*3*1000)
57  #define SENTINEL_MAX_PENDING_COMMANDS 100
58  #define SENTINEL_ELECTION_TIMEOUT 10000
59  #define SENTINEL_MAX_DESYNC 1000
60  #define SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG 1
61  #define SENTINEL_FAILOVER_STATE_NONE 0  &amp;bsol;* No failover in progress. */
62  #define SENTINEL_FAILOVER_STATE_WAIT_START 1  &amp;bsol;* Wait for failover_start_time*/
63  #define SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 &amp;bsol;* Select slave to promote */
64  #define SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 &amp;bsol;* Slave -&gt; Master */
65  #define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 &amp;bsol;* Wait slave to change role */
66  #define SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 &amp;bsol;* SLAVEOF newmaster */
67  #define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 &amp;bsol;* Monitor promoted slave. */
68  #define SENTINEL_MASTER_LINK_STATUS_UP 0
69  #define SENTINEL_MASTER_LINK_STATUS_DOWN 1
70  #define SENTINEL_NO_FLAGS 0
71  #define SENTINEL_GENERATE_EVENT (1&lt;&lt;16)
72  #define SENTINEL_LEADER (1&lt;&lt;17)
73  #define SENTINEL_OBSERVER (1&lt;&lt;18)
74  #define SENTINEL_SCRIPT_NONE 0
75  #define SENTINEL_SCRIPT_RUNNING 1
76  #define SENTINEL_SCRIPT_MAX_QUEUE 256
77  #define SENTINEL_SCRIPT_MAX_RUNNING 16
78  #define SENTINEL_SCRIPT_MAX_RUNTIME 60000 &amp;bsol;* 60 seconds max exec time. */
79  #define SENTINEL_SCRIPT_MAX_RETRY 10
80  #define SENTINEL_SCRIPT_RETRY_DELAY 30000 &amp;bsol;* 30 seconds between retries. */
81  #define SENTINEL_SIMFAILURE_NONE 0
82  #define SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION (1&lt;&lt;0)
83  #define SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION (1&lt;&lt;1)
84  typedef struct instanceLink {
85      int refcount;          &amp;bsol;* Number of sentinelRedisInstance owners. */
86      int disconnected;      &amp;bsol;* Non-zero if we need to reconnect cc or pc. */
87      int pending_commands;  &amp;bsol;* Number of commands sent waiting for a reply. */
88      redisAsyncContext *cc; &amp;bsol;* Hiredis context for commands. */
89      redisAsyncContext *pc; &amp;bsol;* Hiredis context for Pub / Sub. */
90      mstime_t cc_conn_time; &amp;bsol;* cc connection time. */
91      mstime_t pc_conn_time; &amp;bsol;* pc connection time. */
92      mstime_t pc_last_activity; &amp;bsol;* Last time we received any message. */
93      mstime_t last_avail_time; &amp;bsol;* Last time the instance replied to ping with
94                                   a reply we consider valid. */
95      mstime_t act_ping_time;   &amp;bsol;* Time at which the last pending ping (no pong
96                                   received after it) was sent. This field is
97                                   set to 0 when a pong is received, and set again
98                                   to the current time if the value is 0 and a new
99                                   ping is sent. */
100      mstime_t last_ping_time;  &amp;bsol;* Time at which we sent the last ping. This is
101                                   only used to avoid sending too many pings
102                                   during failure. Idle time is computed using
103                                   the act_ping_time field. */
104      mstime_t last_pong_time;  &amp;bsol;* Last time the instance replied to ping,
105                                   whatever the reply was. That&#x27;s used to check
106                                   if the link is idle and must be reconnected. */
107      mstime_t last_reconn_time;  &amp;bsol;* Last reconnection attempt performed when
108                                     the link was down. */
109  } instanceLink;
110  typedef struct sentinelRedisInstance {
111      int flags;      &amp;bsol;* See SRI_... defines */
112      char *name;     &amp;bsol;* Master name from the point of view of this sentinel. */
113      char *runid;    &amp;bsol;* Run ID of this instance, or unique ID if is a Sentinel.*/
114      uint64_t config_epoch;  &amp;bsol;* Configuration epoch. */
115      sentinelAddr *addr; &amp;bsol;* Master host. */
116      instanceLink *link; &amp;bsol;* Link to the instance, may be shared for Sentinels. */
117      mstime_t last_pub_time;   &amp;bsol;* Last time we sent hello via Pub/Sub. */
118      mstime_t last_hello_time; &amp;bsol;* Only used if SRI_SENTINEL is set. Last time
119                                   we received a hello from this Sentinel
120                                   via Pub/Sub. */
121      mstime_t last_master_down_reply_time; &amp;bsol;* Time of last reply to
122                                               SENTINEL is-master-down command. */
123      mstime_t s_down_since_time; &amp;bsol;* Subjectively down since time. */
124      mstime_t o_down_since_time; &amp;bsol;* Objectively down since time. */
125      mstime_t down_after_period; &amp;bsol;* Consider it down after that period. */
126      mstime_t info_refresh;  &amp;bsol;* Time at which we received INFO output from it. */
127      dict *renamed_commands;     &amp;bsol;* Commands renamed in this instance:
128                                     Sentinel will use the alternative commands
129                                     mapped on this table to send things like
130                                     SLAVEOF, CONFING, INFO, ... */
131      int role_reported;
132      mstime_t role_reported_time;
133      mstime_t slave_conf_change_time; &amp;bsol;* Last time slave master addr changed. */
134      dict *sentinels;    &amp;bsol;* Other sentinels monitoring the same master. */
135      dict *slaves;       &amp;bsol;* Slaves for this master instance. */
136      unsigned int quorum;&amp;bsol;* Number of sentinels that need to agree on failure. */
137      int parallel_syncs; &amp;bsol;* How many slaves to reconfigure at same time. */
138      char *auth_pass;    &amp;bsol;* Password to use for AUTH against master &amp; slaves. */
139      mstime_t master_link_down_time; &amp;bsol;* Slave replication link down time. */
140      int slave_priority; &amp;bsol;* Slave priority according to its INFO output. */
141      mstime_t slave_reconf_sent_time; &amp;bsol;* Time at which we sent SLAVE OF &lt;new&gt; */
142      struct sentinelRedisInstance *master; &amp;bsol;* Master instance if it&#x27;s slave. */
143      char *slave_master_host;    &amp;bsol;* Master host as reported by INFO */
144      int slave_master_port;      &amp;bsol;* Master port as reported by INFO */
145      int slave_master_link_status; &amp;bsol;* Master link status as reported by INFO */
146      PORT_ULONGLONG slave_repl_offset; &amp;bsol;* Slave replication offset. */
147      char *leader;       &amp;bsol;* If this is a master instance, this is the runid of
148                             the Sentinel that should perform the failover. If
149                             this is a Sentinel, this is the runid of the Sentinel
150                             that this Sentinel voted as leader. */
151      uint64_t leader_epoch; &amp;bsol;* Epoch of the &#x27;leader&#x27; field. */
152      uint64_t failover_epoch; &amp;bsol;* Epoch of the currently started failover. */
153      int failover_state; &amp;bsol;* See SENTINEL_FAILOVER_STATE_* defines. */
154      mstime_t failover_state_change_time;
155      mstime_t failover_start_time;   &amp;bsol;* Last failover attempt start time. */
156      mstime_t failover_timeout;      &amp;bsol;* Max time to refresh failover state. */
157      mstime_t failover_delay_logged; &amp;bsol;* For what failover_start_time value we
158                                         logged the failover delay. */
159      struct sentinelRedisInstance *promoted_slave; &amp;bsol;* Promoted slave instance. */
160      char *notification_script;
161      char *client_reconfig_script;
162      sds info; &amp;bsol;* cached INFO output */
163  } sentinelRedisInstance;
164  struct sentinelState {
165      char myid[CONFIG_RUN_ID_SIZE+1]; &amp;bsol;* This sentinel ID. */
166      uint64_t current_epoch;         &amp;bsol;* Current epoch. */
167      dict *masters;      &amp;bsol;* Dictionary of master sentinelRedisInstances.
168                             Key is the instance name, value is the
169                             sentinelRedisInstance structure pointer. */
170      int tilt;           &amp;bsol;* Are we in TILT mode? */
171      int running_scripts;    &amp;bsol;* Number of scripts in execution right now. */
172      mstime_t tilt_start_time;       &amp;bsol;* When TITL started. */
173      mstime_t previous_time;         &amp;bsol;* Last time we ran the time handler. */
174      list *scripts_queue;            &amp;bsol;* Queue of user scripts to execute. */
175      char *announce_ip;  &amp;bsol;* IP addr that is gossiped to other sentinels if
176                             not NULL. */
177      int announce_port;  &amp;bsol;* Port that is gossiped to other sentinels if
178                             non zero. */
179      PORT_ULONG simfailure_flags; &amp;bsol;* Failures simulation. */
180      int deny_scripts_reconfig; &amp;bsol;* Allow SENTINEL SET ... to change script
181                                    paths at runtime? */
182  } sentinel;
183  typedef struct sentinelScriptJob {
184      int flags;              &amp;bsol;* Script job flags: SENTINEL_SCRIPT_* */
185      int retry_num;          &amp;bsol;* Number of times we tried to execute it. */
186      char **argv;            &amp;bsol;* Arguments to call the script. */
187      mstime_t start_time;    &amp;bsol;* Script execution time if the script is running,
188                                 otherwise 0 if we are allowed to retry the
189                                 execution at any time. If the script is not
190                                 running and it&#x27;s not 0, it means: do not run
191                                 before the specified time. */
192  #ifdef _WIN32
193      HANDLE hScriptProcess;  &amp;bsol;* handle of process executing script */
194  #endif
195      pid_t pid;              &amp;bsol;* Script execution pid. */
196  } sentinelScriptJob;
197  typedef struct redisAeEvents {
198      redisAsyncContext *context;
199      aeEventLoop *loop;
200      int fd;
201      int reading, writing;
202  } redisAeEvents;
203  static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
204      ((void)el); ((void)fd); ((void)mask);
205      redisAeEvents *e = (redisAeEvents*)privdata;
206      redisAsyncHandleRead(e-&gt;context);
207      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
208  }
209  #ifdef _WIN32
210  static void writeHandlerDone(aeEventLoop *el, int fd, void *privdata, int nwritten) {
211      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
212      redisAeEvents *e = (redisAeEvents *) req-&gt;client;
213      redisAsyncHandleWriteComplete(e-&gt;context, nwritten);
214  }
215  static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
216      redisAeEvents *e = (redisAeEvents*)privdata;
217      redisContext *c = &amp;(e-&gt;context-&gt;c);
218      int result;
219      ((void)el); ((void)fd); ((void)mask);
220      if (redisAsyncHandleWritePrep(e-&gt;context) == C_OK) {
221          result = WSIOCP_SocketSend((int) c-&gt;fd,
222                                     (char*) c-&gt;obuf,
223                                     (int) (sdslen(c-&gt;obuf)),
224                                     el,
225                                     e,
226                                     NULL,
227                                     writeHandlerDone);
228          if (result == SOCKET_ERROR &amp;&amp; errno != WSA_IO_PENDING) {
229              if (errno != EPIPE) {
230                  serverLog(LL_VERBOSE, &quot;Writing to socket %s (%d)\n&quot;, wsa_strerror(errno), errno);
231              }
232              return;
233          }
234      }
235  }
236  #else
237  static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
238      ((void)el); ((void)fd); ((void)mask);
239      redisAeEvents *e = (redisAeEvents*)privdata;
240      redisAsyncHandleWrite(e-&gt;context);
241  }
242  #endif
243  static void redisAeAddRead(void *privdata) {
244      redisAeEvents *e = (redisAeEvents*)privdata;
245      aeEventLoop *loop = e-&gt;loop;
246      if (!e-&gt;reading) {
247          e-&gt;reading = 1;
248          aeCreateFileEvent(loop,e-&gt;fd,AE_READABLE,redisAeReadEvent,e);
249      }
250  }
251  static void redisAeDelRead(void *privdata) {
252      redisAeEvents *e = (redisAeEvents*)privdata;
253      aeEventLoop *loop = e-&gt;loop;
254      if (e-&gt;reading) {
255          e-&gt;reading = 0;
256          aeDeleteFileEvent(loop,e-&gt;fd,AE_READABLE);
257      }
258  }
259  static void redisAeAddWrite(void *privdata) {
260      redisAeEvents *e = (redisAeEvents*)privdata;
261      aeEventLoop *loop = e-&gt;loop;
262      if (!e-&gt;writing) {
263          e-&gt;writing = 1;
264          aeCreateFileEvent(loop,e-&gt;fd,AE_WRITABLE,redisAeWriteEvent,e);
265      }
266  }
267  static void redisAeDelWrite(void *privdata) {
268      redisAeEvents *e = (redisAeEvents*)privdata;
269      aeEventLoop *loop = e-&gt;loop;
270      if (e-&gt;writing) {
271          e-&gt;writing = 0;
272          aeDeleteFileEvent(loop,e-&gt;fd,AE_WRITABLE);
273      }
274  }
275  static void redisAeCleanup(void *privdata) {
276      redisAeEvents *e = (redisAeEvents*)privdata;
277      redisAeDelRead(privdata);
278      redisAeDelWrite(privdata);
279      zfree(e);
280  }
281  static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
282      redisContext *c = &amp;(ac-&gt;c);
283      redisAeEvents *e;
284      if (ac-&gt;ev.data != NULL)
285          return C_ERR;
286      e = (redisAeEvents*)zmalloc(sizeof(*e));
287      e-&gt;context = ac;
288      e-&gt;loop = loop;
289      e-&gt;fd = c-&gt;fd;
290      e-&gt;reading = e-&gt;writing = 0;
291      ac-&gt;ev.addRead = redisAeAddRead;
292      ac-&gt;ev.delRead = redisAeDelRead;
293      ac-&gt;ev.addWrite = redisAeAddWrite;
294      ac-&gt;ev.delWrite = redisAeDelWrite;
295      ac-&gt;ev.cleanup = redisAeCleanup;
296      ac-&gt;ev.data = e;
297      return C_OK;
298  }
299  void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status);
300  void sentinelDisconnectCallback(const redisAsyncContext *c, int status);
301  void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata);
302  sentinelRedisInstance *sentinelGetMasterByName(char *name);
303  char *sentinelGetSubjectiveLeader(sentinelRedisInstance *master);
304  char *sentinelGetObjectiveLeader(sentinelRedisInstance *master);
305  int yesnotoi(char *s);
306  void instanceLinkConnectionError(const redisAsyncContext *c);
307  const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri);
308  void sentinelAbortFailover(sentinelRedisInstance *ri);
309  void sentinelEvent(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...);
310  sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master);
311  void sentinelScheduleScriptExecution(char *path, ...);
312  void sentinelStartFailover(sentinelRedisInstance *master);
313  void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata);
314  int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port);
315  char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch);
316  void sentinelFlushConfig(void);
317  void sentinelGenerateInitialMonitorEvents(void);
318  int sentinelSendPing(sentinelRedisInstance *ri);
319  int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master);
320  sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid);
321  void sentinelSimFailureCrash(void);
322  uint64_t dictSdsHash(const void *key);
323  uint64_t dictSdsCaseHash(const void *key);
324  int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
325  int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);
326  void releaseSentinelRedisInstance(sentinelRedisInstance *ri);
327  void dictInstancesValDestructor (void *privdata, void *obj) {
328      UNUSED(privdata);
329      releaseSentinelRedisInstance(obj);
330  }
331  dictType instancesDictType = {
332      dictSdsHash,               &amp;bsol;* hash function */
333      NULL,                      &amp;bsol;* key dup */
334      NULL,                      &amp;bsol;* val dup */
335      dictSdsKeyCompare,         &amp;bsol;* key compare */
336      NULL,                      &amp;bsol;* key destructor */
337      dictInstancesValDestructor &amp;bsol;* val destructor */
338  };
339  dictType leaderVotesDictType = {
340      dictSdsHash,               &amp;bsol;* hash function */
341      NULL,                      &amp;bsol;* key dup */
342      NULL,                      &amp;bsol;* val dup */
343      dictSdsKeyCompare,         &amp;bsol;* key compare */
344      NULL,                      &amp;bsol;* key destructor */
345      NULL                       &amp;bsol;* val destructor */
346  };
347  dictType renamedCommandsDictType = {
348      dictSdsCaseHash,           &amp;bsol;* hash function */
349      NULL,                      &amp;bsol;* key dup */
350      NULL,                      &amp;bsol;* val dup */
351      dictSdsKeyCaseCompare,     &amp;bsol;* key compare */
352      dictSdsDestructor,         &amp;bsol;* key destructor */
353      dictSdsDestructor          &amp;bsol;* val destructor */
354  };
355  void sentinelCommand(client *c);
356  void sentinelInfoCommand(client *c);
357  void sentinelSetCommand(client *c);
358  void sentinelPublishCommand(client *c);
359  void sentinelRoleCommand(client *c);
360  struct redisCommand sentinelcmds[] = {
361      {&quot;ping&quot;,pingCommand,1,&quot;&quot;,0,NULL,0,0,0,0,0},
362      {&quot;sentinel&quot;,sentinelCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0},
363      {&quot;subscribe&quot;,subscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0},
364      {&quot;unsubscribe&quot;,unsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
365      {&quot;psubscribe&quot;,psubscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0},
366      {&quot;punsubscribe&quot;,punsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
367      {&quot;publish&quot;,sentinelPublishCommand,3,&quot;&quot;,0,NULL,0,0,0,0,0},
368      {&quot;info&quot;,sentinelInfoCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
369      {&quot;role&quot;,sentinelRoleCommand,1,&quot;l&quot;,0,NULL,0,0,0,0,0},
370      {&quot;client&quot;,clientCommand,-2,&quot;rs&quot;,0,NULL,0,0,0,0,0},
371      {&quot;shutdown&quot;,shutdownCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
372      {&quot;auth&quot;,authCommand,2,&quot;sltF&quot;,0,NULL,0,0,0,0,0}
373  };
374  void initSentinelConfig(void) {
375      server.port = REDIS_SENTINEL_PORT;
376      server.protected_mode = 0; &amp;bsol;* Sentinel must be exposed. */
377  }
378  void initSentinel(void) {
379      unsigned int j;
380      dictEmpty(server.commands,NULL);
381      for (j = 0; j &lt; sizeof(sentinelcmds)/sizeof(sentinelcmds[0]); j++) {
382          int retval;
383          struct redisCommand *cmd = sentinelcmds+j;
384          retval = dictAdd(server.commands, sdsnew(cmd-&gt;name), cmd);
385          serverAssert(retval == DICT_OK);
386      }
387      sentinel.current_epoch = 0;
388      sentinel.masters = dictCreate(&amp;instancesDictType,NULL);
389      sentinel.tilt = 0;
390      sentinel.tilt_start_time = 0;
391      sentinel.previous_time = mstime();
392      sentinel.running_scripts = 0;
393      sentinel.scripts_queue = listCreate();
394      sentinel.announce_ip = NULL;
395      sentinel.announce_port = 0;
396      sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
397      sentinel.deny_scripts_reconfig = SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG;
398      memset(sentinel.myid,0,sizeof(sentinel.myid));
399  }
400  void sentinelIsRunning(void) {
401      int j;
402      if (server.configfile == NULL) {
403          serverLog(LL_WARNING,
404              &quot;Sentinel started without a config file. Exiting...&quot;);
405          exit(1);
406      } else if (access(server.configfile,W_OK) == -1) {
407          serverLog(LL_WARNING,
408              &quot;Sentinel config file %s is not writable: %s. Exiting...&quot;,
409              server.configfile, IF_WIN32(wsa_strerror(errno), strerror(errno)));
410          exit(1);
411      }
412      for (j = 0; j &lt; CONFIG_RUN_ID_SIZE; j++)
413          if (sentinel.myid[j] != 0) break;
414      if (j == CONFIG_RUN_ID_SIZE) {
415          getRandomHexChars(sentinel.myid,CONFIG_RUN_ID_SIZE);
416          sentinelFlushConfig();
417      }
418      serverLog(LL_WARNING,&quot;Sentinel ID is %s&quot;, sentinel.myid);
419      sentinelGenerateInitialMonitorEvents();
420  }
421  sentinelAddr *createSentinelAddr(char *hostname, int port) {
422      char ip[NET_IP_STR_LEN];
423      sentinelAddr *sa;
424      if (port &lt; 0 || port &gt; 65535) {
425          errno = EINVAL;
426          return NULL;
427      }
428      if (anetResolve(NULL,hostname,ip,sizeof(ip)) == ANET_ERR) {
429          errno = ENOENT;
430          return NULL;
431      }
432      sa = zmalloc(sizeof(*sa));
433      sa-&gt;ip = sdsnew(ip);
434      sa-&gt;port = port;
435      return sa;
436  }
437  sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
438      sentinelAddr *sa;
439      sa = zmalloc(sizeof(*sa));
440      sa-&gt;ip = sdsnew(src-&gt;ip);
441      sa-&gt;port = src-&gt;port;
442      return sa;
443  }
444  void releaseSentinelAddr(sentinelAddr *sa) {
445      sdsfree(sa-&gt;ip);
446      zfree(sa);
447  }
448  int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {
449      return a-&gt;port == b-&gt;port &amp;&amp; !strcasecmp(a-&gt;ip,b-&gt;ip);
450  }
451  void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
452                     const char *fmt, ...) {
453      va_list ap;
454      char msg[LOG_MAX_LEN];
455      robj *channel, *payload;
456      if (fmt[0] == &#x27;%&#x27; &amp;&amp; fmt[1] == &#x27;@&#x27;) {
457          sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ?
458                                           NULL : ri-&gt;master;
459          if (master) {
460              snprintf(msg, sizeof(msg), &quot;%s %s %s %d @ %s %s %d&quot;,
461                  sentinelRedisInstanceTypeStr(ri),
462                  ri-&gt;name, ri-&gt;addr-&gt;ip, ri-&gt;addr-&gt;port,
463                  master-&gt;name, master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port);
464          } else {
465              snprintf(msg, sizeof(msg), &quot;%s %s %s %d&quot;,
466                  sentinelRedisInstanceTypeStr(ri),
467                  ri-&gt;name, ri-&gt;addr-&gt;ip, ri-&gt;addr-&gt;port);
468          }
469          fmt += 2;
470      } else {
471          msg[0] = &#x27;\0&#x27;;
472      }
473      if (fmt[0] != &#x27;\0&#x27;) {
474          va_start(ap, fmt);
475          vsnprintf(msg+strlen(msg), sizeof(msg)-strlen(msg), fmt, ap);
476          va_end(ap);
477      }
478      if (level &gt;= server.verbosity)
479          serverLog(level,&quot;%s %s&quot;,type,msg);
480      if (level != LL_DEBUG) {
481          channel = createStringObject(type,strlen(type));
482          payload = createStringObject(msg,strlen(msg));
483          pubsubPublishMessage(channel,payload);
484          decrRefCount(channel);
485          decrRefCount(payload);
486      }
487      if (level == LL_WARNING &amp;&amp; ri != NULL) {
488          sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ?
489                                           ri : ri-&gt;master;
490          if (master &amp;&amp; master-&gt;notification_script) {
491              sentinelScheduleScriptExecution(master-&gt;notification_script,
492                  type,msg,NULL);
493          }
494      }
495  }
496  void sentinelGenerateInitialMonitorEvents(void) {
497      dictIterator *di;
498      dictEntry *de;
499      di = dictGetIterator(sentinel.masters);
500      while((de = dictNext(di)) != NULL) {
501          sentinelRedisInstance *ri = dictGetVal(de);
502          sentinelEvent(LL_WARNING,&quot;+monitor&quot;,ri,&quot;%@ quorum %d&quot;,ri-&gt;quorum);
503      }
504      dictReleaseIterator(di);
505  }
506  void sentinelReleaseScriptJob(sentinelScriptJob *sj) {
507      int j = 0;
508      while(sj-&gt;argv[j]) sdsfree(sj-&gt;argv[j++]);
509      zfree(sj-&gt;argv);
510      zfree(sj);
511  }
512  #define SENTINEL_SCRIPT_MAX_ARGS 16
513  void sentinelScheduleScriptExecution(char *path, ...) {
514      va_list ap;
515      char *argv[SENTINEL_SCRIPT_MAX_ARGS+1];
516      int argc = 1;
517      sentinelScriptJob *sj;
518      va_start(ap, path);
519      while(argc &lt; SENTINEL_SCRIPT_MAX_ARGS) {
520          argv[argc] = va_arg(ap,char*);
521          if (!argv[argc]) break;
522          argv[argc] = sdsnew(argv[argc]); &amp;bsol;* Copy the string. */
523          argc++;
524      }
525      va_end(ap);
526      argv[0] = sdsnew(path);
527      sj = zmalloc(sizeof(*sj));
528      sj-&gt;flags = SENTINEL_SCRIPT_NONE;
529      sj-&gt;retry_num = 0;
530      sj-&gt;argv = zmalloc(sizeof(char*)*(argc+1));
531      sj-&gt;start_time = 0;
532      WIN32_ONLY(sj-&gt;hScriptProcess = INVALID_HANDLE_VALUE;)
533      sj-&gt;pid = 0;
534      memcpy(sj-&gt;argv,argv,sizeof(char*)*(argc+1));
535      listAddNodeTail(sentinel.scripts_queue,sj);
536      if (listLength(sentinel.scripts_queue) &gt; SENTINEL_SCRIPT_MAX_QUEUE) {
537          listNode *ln;
538          listIter li;
539          listRewind(sentinel.scripts_queue,&amp;li);
540          while ((ln = listNext(&amp;li)) != NULL) {
541              sj = ln-&gt;value;
542              if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) continue;
543              listDelNode(sentinel.scripts_queue,ln);
544              sentinelReleaseScriptJob(sj);
545              break;
546          }
547          serverAssert(listLength(sentinel.scripts_queue) &lt;=
548                      SENTINEL_SCRIPT_MAX_QUEUE);
549      }
550  }
551  #ifndef _WIN32
552  listNode *sentinelGetScriptListNodeByPid(pid_t pid) {
553      listNode *ln;
554      listIter li;
555      listRewind(sentinel.scripts_queue,&amp;li);
556      while ((ln = listNext(&amp;li)) != NULL) {
557          sentinelScriptJob *sj = ln-&gt;value;
558          if ((sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) &amp;&amp; sj-&gt;pid == pid)
559              return ln;
560      }
561      return NULL;
562  }
563  #endif
564  void sentinelRunPendingScripts(void) {
565      listNode *ln;
566      listIter li;
567      mstime_t now = mstime();
568      listRewind(sentinel.scripts_queue,&amp;li);
569      while (sentinel.running_scripts &lt; SENTINEL_SCRIPT_MAX_RUNNING &amp;&amp;
570             (ln = listNext(&amp;li)) != NULL)
571      {
572          sentinelScriptJob *sj = ln-&gt;value;
573          POSIX_ONLY(pid_t pid;)
574          if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) continue;
575          if (sj-&gt;start_time &amp;&amp; sj-&gt;start_time &gt; now) continue;
576          sj-&gt;flags |= SENTINEL_SCRIPT_RUNNING;
577          sj-&gt;start_time = mstime();
578          sj-&gt;retry_num++;
579  #ifdef _WIN32
580          char args[1024];
581          int j = 0;
582          int pos = 0;
583          while (sj-&gt;argv[j]) {
584              if (j == 2) {
585                  memcpy(args + pos, &quot;\&quot;&quot;, 1);
586                  pos += 1;
587              }
588              int arglen = (int) strlen(sj-&gt;argv[j]);
589              memcpy(args + pos, sj-&gt;argv[j], arglen);
590              pos += arglen;
591              if (j == 2) {
592                  memcpy(args + pos, &quot;\&quot;\0&quot;, 2);
593                  break;
594              } else {
595                  memcpy(args + pos, &quot; &quot;, 1);
596                  pos += 1;
597                  j++;
598              }
599          }
600          PROCESS_INFORMATION pi;
601          STARTUPINFO si;
602          ZeroMemory(&amp;si, sizeof(si));
603          si.cb = sizeof(si);
604          if (TRUE == CreateProcessA(NULL, args, NULL, NULL, FALSE, 0,
605                                     NULL, NULL, &amp;si, &amp;pi)) {
606              sj-&gt;hScriptProcess = pi.hProcess;
607              sj-&gt;pid = pi.dwProcessId;
608              CloseHandle(pi.hThread);
609              sentinel.running_scripts++;
610              sentinelEvent(LL_DEBUG, &quot;+script-child&quot;, NULL, &quot;%Id&quot;, 
611                            (PORT_LONG) sj-&gt;pid);
612          } else {
613              sentinelEvent(LL_WARNING, &quot;-script-error&quot;, NULL,
614                  &quot;%s %d %d&quot;, sj-&gt;argv[0], 99, 0);
615              sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;
616              sj-&gt;pid = 0;
617              sj-&gt;hScriptProcess = INVALID_HANDLE_VALUE;
618          }
619  #else
620          pid = fork();
621          if (pid == -1) {
622              sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,
623                            &quot;%s %d %d&quot;, sj-&gt;argv[0], 99, 0);
624              sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;
625              sj-&gt;pid = 0;
626          } else if (pid == 0) {
627              execve(sj-&gt;argv[0],sj-&gt;argv,environ);
628              _exit(2); &amp;bsol;* Don&#x27;t retry execution. */
629          } else {
630              sentinel.running_scripts++;
631              sj-&gt;pid = pid;
632              sentinelEvent(LL_DEBUG,&quot;+script-child&quot;,NULL,&quot;%ld&quot;,(long)pid);
633          }
634  #endif
635      }
636  }
637  mstime_t sentinelScriptRetryDelay(int retry_num) {
638      mstime_t delay = SENTINEL_SCRIPT_RETRY_DELAY;
639      while (retry_num-- &gt; 1) delay *= 2;
640      return delay;
641  }
642  void sentinelCollectTerminatedScripts(void) {
643  #ifdef _WIN32
644      listNode *ln;
645      listIter li;
646      DWORD exitCode;
647      listRewind(sentinel.scripts_queue,&amp;li);
648      while (sentinel.running_scripts &lt; SENTINEL_SCRIPT_MAX_RUNNING &amp;&amp;
649             (ln = listNext(&amp;li)) != NULL) {
650          sentinelScriptJob *sj = ln-&gt;value;
651          if(sj-&gt;hScriptProcess == INVALID_HANDLE_VALUE)
652              continue;
653          if(WaitForSingleObject(sj-&gt;hScriptProcess,0) == WAIT_OBJECT_0) {
654              GetExitCodeProcess(sj-&gt;hScriptProcess,&amp;exitCode);
655              sentinelEvent(LL_DEBUG, &quot;-script-child&quot;, NULL, &quot;%Id %d %d&quot;,      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id*/
656                  (PORT_LONG) sj-&gt;pid, exitCode, 0);
657              CloseHandle(sj-&gt;hScriptProcess);
658              if (exitCode == 1 &amp;&amp; sj-&gt;retry_num != SENTINEL_SCRIPT_MAX_RETRY) {
659                  sj-&gt;hScriptProcess = INVALID_HANDLE_VALUE;
660                  sj-&gt;pid = 0;
661                  sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;
662                  sj-&gt;start_time = mstime() +
663                                   sentinelScriptRetryDelay(sj-&gt;retry_num);
664              } else {
665                  if (exitCode != 0) {
666                      sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,
667                                    &quot;%s %d&quot;, sj-&gt;argv[0], exitCode);
668                  }
669                  listDelNode(sentinel.scripts_queue,ln);
670                  sentinelReleaseScriptJob(sj);
671                  sentinel.running_scripts--;
672              }
673          }
674      }
675  #else
676      int statloc;
677      pid_t pid;
678      while ((pid = wait3(&amp;statloc,WNOHANG,NULL)) &gt; 0) {
679          int exitcode = WEXITSTATUS(statloc);
680          int bysignal = 0;
681          listNode *ln;
682          sentinelScriptJob *sj;
683          if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
684          sentinelEvent(LL_DEBUG,&quot;-script-child&quot;,NULL,&quot;%ld %d %d&quot;,
685              (long)pid, exitcode, bysignal);
686          ln = sentinelGetScriptListNodeByPid(pid);
687          if (ln == NULL) {
688              serverLog(LL_WARNING,&quot;wait3() returned a pid (%ld) we can&#x27;t find in our scripts execution queue!&quot;, (long)pid);
689              continue;
690          }
691          sj = ln-&gt;value;
692          if ((bysignal || exitcode == 1) &amp;&amp;
693              sj-&gt;retry_num != SENTINEL_SCRIPT_MAX_RETRY)
694          {
695              sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;
696              sj-&gt;pid = 0;
697              sj-&gt;start_time = mstime() +
698                               sentinelScriptRetryDelay(sj-&gt;retry_num);
699          } else {
700              if (bysignal || exitcode != 0) {
701                  sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,
702                                &quot;%s %d %d&quot;, sj-&gt;argv[0], bysignal, exitcode);
703              }
704              listDelNode(sentinel.scripts_queue,ln);
705              sentinelReleaseScriptJob(sj);
706              sentinel.running_scripts--;
707          }
708      }
709  #endif
710  }
711  void sentinelKillTimedoutScripts(void) {
712      listNode *ln;
713      listIter li;
714      mstime_t now = mstime();
715      listRewind(sentinel.scripts_queue,&amp;li);
716      while ((ln = listNext(&amp;li)) != NULL) {
717          sentinelScriptJob *sj = ln-&gt;value;
718          if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING &amp;&amp;
719              (now - sj-&gt;start_time) &gt; SENTINEL_SCRIPT_MAX_RUNTIME)
720          {
721              sentinelEvent(LL_WARNING,&quot;-script-timeout&quot;,NULL,&quot;%s %Id&quot;,        WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id*/
722                  sj-&gt;argv[0], (PORT_LONG)sj-&gt;pid);
723  #ifdef _WIN32
724              TerminateProcess(sj-&gt;hScriptProcess,1);
725  #else
726              kill(sj-&gt;pid,SIGKILL);
727  #endif
728          }
729      }
730  }
731  void sentinelPendingScriptsCommand(client *c) {
732      listNode *ln;
733      listIter li;
734      addReplyMultiBulkLen(c,listLength(sentinel.scripts_queue));
735      listRewind(sentinel.scripts_queue,&amp;li);
736      while ((ln = listNext(&amp;li)) != NULL) {
737          sentinelScriptJob *sj = ln-&gt;value;
738          int j = 0;
739          addReplyMultiBulkLen(c,10);
740          addReplyBulkCString(c,&quot;argv&quot;);
741          while (sj-&gt;argv[j]) j++;
742          addReplyMultiBulkLen(c,j);
743          j = 0;
744          while (sj-&gt;argv[j]) addReplyBulkCString(c,sj-&gt;argv[j++]);
745          addReplyBulkCString(c,&quot;flags&quot;);
746          addReplyBulkCString(c,
747              (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) ? &quot;running&quot; : &quot;scheduled&quot;);
748          addReplyBulkCString(c,&quot;pid&quot;);
749          addReplyBulkLongLong(c,sj-&gt;pid);
750          if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) {
751              addReplyBulkCString(c,&quot;run-time&quot;);
752              addReplyBulkLongLong(c,mstime() - sj-&gt;start_time);
753          } else {
754              mstime_t delay = sj-&gt;start_time ? (sj-&gt;start_time-mstime()) : 0;
755              if (delay &lt; 0) delay = 0;
756              addReplyBulkCString(c,&quot;run-delay&quot;);
757              addReplyBulkLongLong(c,delay);
758          }
759          addReplyBulkCString(c,&quot;retry-num&quot;);
760          addReplyBulkLongLong(c,sj-&gt;retry_num);
761      }
762  }
763  void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {
764      char fromport[32], toport[32];
765      if (master-&gt;client_reconfig_script == NULL) return;
766      ll2string(fromport,sizeof(fromport),from-&gt;port);
767      ll2string(toport,sizeof(toport),to-&gt;port);
768      sentinelScheduleScriptExecution(master-&gt;client_reconfig_script,
769          master-&gt;name,
770          (role == SENTINEL_LEADER) ? &quot;leader&quot; : &quot;observer&quot;,
771          state, from-&gt;ip, fromport, to-&gt;ip, toport, NULL);
772  }
773  instanceLink *createInstanceLink(void) {
774      instanceLink *link = zmalloc(sizeof(*link));
775      link-&gt;refcount = 1;
776      link-&gt;disconnected = 1;
777      link-&gt;pending_commands = 0;
778      link-&gt;cc = NULL;
779      link-&gt;pc = NULL;
780      link-&gt;cc_conn_time = 0;
781      link-&gt;pc_conn_time = 0;
782      link-&gt;last_reconn_time = 0;
783      link-&gt;pc_last_activity = 0;
784      link-&gt;act_ping_time = mstime();
785      link-&gt;last_ping_time = 0;
786      link-&gt;last_avail_time = mstime();
787      link-&gt;last_pong_time = mstime();
788      return link;
789  }
790  void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
791      if (c == NULL) return;
792      if (link-&gt;cc == c) {
793          link-&gt;cc = NULL;
794          link-&gt;pending_commands = 0;
795      }
796      if (link-&gt;pc == c) link-&gt;pc = NULL;
797      c-&gt;data = NULL;
798      link-&gt;disconnected = 1;
799      redisAsyncFree(c);
800  }
801  instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
802  {
803      serverAssert(link-&gt;refcount &gt; 0);
804      link-&gt;refcount--;
805      if (link-&gt;refcount != 0) {
806          if (ri &amp;&amp; ri-&gt;link-&gt;cc) {
807              redisCallback *cb;
808              redisCallbackList *callbacks = &amp;link-&gt;cc-&gt;replies;
809              cb = callbacks-&gt;head;
810              while(cb) {
811                  if (cb-&gt;privdata == ri) {
812                      cb-&gt;fn = sentinelDiscardReplyCallback;
813                      cb-&gt;privdata = NULL; &amp;bsol;* Not strictly needed. */
814                  }
815                  cb = cb-&gt;next;
816              }
817          }
818          return link; &amp;bsol;* Other active users. */
819      }
820      instanceLinkCloseConnection(link,link-&gt;cc);
821      instanceLinkCloseConnection(link,link-&gt;pc);
822      zfree(link);
823      return NULL;
824  }
825  int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
826      serverAssert(ri-&gt;flags &amp; SRI_SENTINEL);
827      dictIterator *di;
828      dictEntry *de;
829      if (ri-&gt;runid == NULL) return C_ERR; &amp;bsol;* No way to identify it. */
830      if (ri-&gt;link-&gt;refcount &gt; 1) return C_ERR; &amp;bsol;* Already shared. */
831      di = dictGetIterator(sentinel.masters);
832      while((de = dictNext(di)) != NULL) {
833          sentinelRedisInstance *master = dictGetVal(de), *match;
834          if (master == ri-&gt;master) continue;
835          match = getSentinelRedisInstanceByAddrAndRunID(master-&gt;sentinels,
836                                                         NULL,0,ri-&gt;runid);
837          if (match == NULL) continue; &amp;bsol;* No match. */
838          if (match == ri) continue; &amp;bsol;* Should never happen but... safer. */
839          releaseInstanceLink(ri-&gt;link,NULL);
840          ri-&gt;link = match-&gt;link;
841          match-&gt;link-&gt;refcount++;
842          dictReleaseIterator(di);
843          return C_OK;
844      }
845      dictReleaseIterator(di);
846      return C_ERR;
847  }
848  int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
849      serverAssert(ri-&gt;flags &amp; SRI_SENTINEL);
850      dictIterator *di;
851      dictEntry *de;
852      int reconfigured = 0;
853      di = dictGetIterator(sentinel.masters);
854      while((de = dictNext(di)) != NULL) {
855          sentinelRedisInstance *master = dictGetVal(de), *match;
856          match = getSentinelRedisInstanceByAddrAndRunID(master-&gt;sentinels,
857                                                         NULL,0,ri-&gt;runid);
858          if (match == NULL) continue;
859          if (match-&gt;link-&gt;cc != NULL)
860              instanceLinkCloseConnection(match-&gt;link,match-&gt;link-&gt;cc);
861          if (match-&gt;link-&gt;pc != NULL)
862              instanceLinkCloseConnection(match-&gt;link,match-&gt;link-&gt;pc);
863          if (match == ri) continue; &amp;bsol;* Address already updated for it. */
864          releaseSentinelAddr(match-&gt;addr);
865          match-&gt;addr = dupSentinelAddr(ri-&gt;addr);
866          reconfigured++;
867      }
868      dictReleaseIterator(di);
869      if (reconfigured)
870          sentinelEvent(LL_NOTICE,&quot;+sentinel-address-update&quot;, ri,
871                      &quot;%@ %d additional matching instances&quot;, reconfigured);
872      return reconfigured;
873  }
874  void instanceLinkConnectionError(const redisAsyncContext *c) {
875      instanceLink *link = c-&gt;data;
876      int pubsub;
877      if (!link) return;
878      pubsub = (link-&gt;pc == c);
879      if (pubsub)
880          link-&gt;pc = NULL;
881      else
882          link-&gt;cc = NULL;
883      link-&gt;disconnected = 1;
884  }
885  void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {
886      if (status != C_OK) instanceLinkConnectionError(c);
887  }
888  void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
889      UNUSED(status);
890      instanceLinkConnectionError(c);
891  }
892  sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {
893      sentinelRedisInstance *ri;
894      sentinelAddr *addr;
895      dict *table = NULL;
896      char slavename[NET_PEER_ID_LEN], *sdsname;
897      serverAssert(flags &amp; (SRI_MASTER|SRI_SLAVE|SRI_SENTINEL));
898      serverAssert((flags &amp; SRI_MASTER) || master != NULL);
899      addr = createSentinelAddr(hostname,port);
900      if (addr == NULL) return NULL;
901      if (flags &amp; SRI_SLAVE) {
902          anetFormatAddr(slavename, sizeof(slavename), hostname, port);
903          name = slavename;
904      }
905      if (flags &amp; SRI_MASTER) table = sentinel.masters;
906      else if (flags &amp; SRI_SLAVE) table = master-&gt;slaves;
907      else if (flags &amp; SRI_SENTINEL) table = master-&gt;sentinels;
908      sdsname = sdsnew(name);
909      if (dictFind(table,sdsname)) {
910          releaseSentinelAddr(addr);
911          sdsfree(sdsname);
912          errno = EBUSY;
913          return NULL;
914      }
915      ri = zmalloc(sizeof(*ri));
916      ri-&gt;flags = flags;
917      ri-&gt;name = sdsname;
918      ri-&gt;runid = NULL;
919      ri-&gt;config_epoch = 0;
920      ri-&gt;addr = addr;
921      ri-&gt;link = createInstanceLink();
922      ri-&gt;last_pub_time = mstime();
923      ri-&gt;last_hello_time = mstime();
924      ri-&gt;last_master_down_reply_time = mstime();
925      ri-&gt;s_down_since_time = 0;
926      ri-&gt;o_down_since_time = 0;
927      ri-&gt;down_after_period = master ? master-&gt;down_after_period :
928                              SENTINEL_DEFAULT_DOWN_AFTER;
929      ri-&gt;master_link_down_time = 0;
930      ri-&gt;auth_pass = NULL;
931      ri-&gt;slave_priority = SENTINEL_DEFAULT_SLAVE_PRIORITY;
932      ri-&gt;slave_reconf_sent_time = 0;
933      ri-&gt;slave_master_host = NULL;
934      ri-&gt;slave_master_port = 0;
935      ri-&gt;slave_master_link_status = SENTINEL_MASTER_LINK_STATUS_DOWN;
936      ri-&gt;slave_repl_offset = 0;
937      ri-&gt;sentinels = dictCreate(&amp;instancesDictType,NULL);
938      ri-&gt;quorum = quorum;
939      ri-&gt;parallel_syncs = SENTINEL_DEFAULT_PARALLEL_SYNCS;
940      ri-&gt;master = master;
941      ri-&gt;slaves = dictCreate(&amp;instancesDictType,NULL);
942      ri-&gt;info_refresh = 0;
943      ri-&gt;renamed_commands = dictCreate(&amp;renamedCommandsDictType,NULL);
944      ri-&gt;leader = NULL;
945      ri-&gt;leader_epoch = 0;
946      ri-&gt;failover_epoch = 0;
947      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_NONE;
948      ri-&gt;failover_state_change_time = 0;
949      ri-&gt;failover_start_time = 0;
950      ri-&gt;failover_timeout = SENTINEL_DEFAULT_FAILOVER_TIMEOUT;
951      ri-&gt;failover_delay_logged = 0;
952      ri-&gt;promoted_slave = NULL;
953      ri-&gt;notification_script = NULL;
954      ri-&gt;client_reconfig_script = NULL;
955      ri-&gt;info = NULL;
956      ri-&gt;role_reported = ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE);
957      ri-&gt;role_reported_time = mstime();
958      ri-&gt;slave_conf_change_time = mstime();
959      dictAdd(table, ri-&gt;name, ri);
960      return ri;
961  }
962  void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {
963      dictRelease(ri-&gt;sentinels);
964      dictRelease(ri-&gt;slaves);
965      releaseInstanceLink(ri-&gt;link,ri);
966      sdsfree(ri-&gt;name);
967      sdsfree(ri-&gt;runid);
968      sdsfree(ri-&gt;notification_script);
969      sdsfree(ri-&gt;client_reconfig_script);
970      sdsfree(ri-&gt;slave_master_host);
971      sdsfree(ri-&gt;leader);
972      sdsfree(ri-&gt;auth_pass);
973      sdsfree(ri-&gt;info);
974      releaseSentinelAddr(ri-&gt;addr);
975      dictRelease(ri-&gt;renamed_commands);
976      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp; (ri-&gt;flags &amp; SRI_PROMOTED) &amp;&amp; ri-&gt;master)
977          ri-&gt;master-&gt;promoted_slave = NULL;
978      zfree(ri);
979  }
980  sentinelRedisInstance *sentinelRedisInstanceLookupSlave(
981                  sentinelRedisInstance *ri, char *ip, int port)
982  {
983      sds key;
984      sentinelRedisInstance *slave;
985      char buf[NET_PEER_ID_LEN];
986      serverAssert(ri-&gt;flags &amp; SRI_MASTER);
987      anetFormatAddr(buf,sizeof(buf),ip,port);
988      key = sdsnew(buf);
989      slave = dictFetchValue(ri-&gt;slaves,key);
990      sdsfree(key);
991      return slave;
992  }
993  const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri) {
994      if (ri-&gt;flags &amp; SRI_MASTER) return &quot;master&quot;;
995      else if (ri-&gt;flags &amp; SRI_SLAVE) return &quot;slave&quot;;
996      else if (ri-&gt;flags &amp; SRI_SENTINEL) return &quot;sentinel&quot;;
997      else return &quot;unknown&quot;;
998  }
999  int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid) {
1000      dictIterator *di;
1001      dictEntry *de;
1002      int removed = 0;
1003      if (runid == NULL) return 0;
1004      di = dictGetSafeIterator(master-&gt;sentinels);
1005      while((de = dictNext(di)) != NULL) {
1006          sentinelRedisInstance *ri = dictGetVal(de);
1007          if (ri-&gt;runid &amp;&amp; strcmp(ri-&gt;runid,runid) == 0) {
1008              dictDelete(master-&gt;sentinels,ri-&gt;name);
1009              removed++;
1010          }
1011      }
1012      dictReleaseIterator(di);
1013      return removed;
1014  }
1015  sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid) {
1016      dictIterator *di;
1017      dictEntry *de;
1018      sentinelRedisInstance *instance = NULL;
1019      serverAssert(ip || runid);   &amp;bsol;* User must pass at least one search param. */
1020      di = dictGetIterator(instances);
1021      while((de = dictNext(di)) != NULL) {
1022          sentinelRedisInstance *ri = dictGetVal(de);
1023          if (runid &amp;&amp; !ri-&gt;runid) continue;
1024          if ((runid == NULL || strcmp(ri-&gt;runid, runid) == 0) &amp;&amp;
1025              (ip == NULL || (strcmp(ri-&gt;addr-&gt;ip, ip) == 0 &amp;&amp;
1026                              ri-&gt;addr-&gt;port == port)))
1027          {
1028              instance = ri;
1029              break;
1030          }
1031      }
1032      dictReleaseIterator(di);
1033      return instance;
1034  }
1035  sentinelRedisInstance *sentinelGetMasterByName(char *name) {
1036      sentinelRedisInstance *ri;
1037      sds sdsname = sdsnew(name);
1038      ri = dictFetchValue(sentinel.masters,sdsname);
1039      sdsfree(sdsname);
1040      return ri;
1041  }
1042  void sentinelAddFlagsToDictOfRedisInstances(dict *instances, int flags) {
1043      dictIterator *di;
1044      dictEntry *de;
1045      di = dictGetIterator(instances);
1046      while((de = dictNext(di)) != NULL) {
1047          sentinelRedisInstance *ri = dictGetVal(de);
1048          ri-&gt;flags |= flags;
1049      }
1050      dictReleaseIterator(di);
1051  }
1052  void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {
1053      dictIterator *di;
1054      dictEntry *de;
1055      di = dictGetIterator(instances);
1056      while((de = dictNext(di)) != NULL) {
1057          sentinelRedisInstance *ri = dictGetVal(de);
1058          ri-&gt;flags &amp;= ~flags;
1059      }
1060      dictReleaseIterator(di);
1061  }
1062  #define SENTINEL_RESET_NO_SENTINELS (1&lt;&lt;0)
1063  void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
1064      serverAssert(ri-&gt;flags &amp; SRI_MASTER);
1065      dictRelease(ri-&gt;slaves);
1066      ri-&gt;slaves = dictCreate(&amp;instancesDictType,NULL);
1067      if (!(flags &amp; SENTINEL_RESET_NO_SENTINELS)) {
1068          dictRelease(ri-&gt;sentinels);
1069          ri-&gt;sentinels = dictCreate(&amp;instancesDictType,NULL);
1070      }
1071      instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;cc);
1072      instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;pc);
1073      ri-&gt;flags &amp;= SRI_MASTER;
1074      if (ri-&gt;leader) {
1075          sdsfree(ri-&gt;leader);
1076          ri-&gt;leader = NULL;
1077      }
1078      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_NONE;
1079      ri-&gt;failover_state_change_time = 0;
1080      ri-&gt;failover_start_time = 0; &amp;bsol;* We can failover again ASAP. */
1081      ri-&gt;promoted_slave = NULL;
1082      sdsfree(ri-&gt;runid);
1083      sdsfree(ri-&gt;slave_master_host);
1084      ri-&gt;runid = NULL;
1085      ri-&gt;slave_master_host = NULL;
1086      ri-&gt;link-&gt;act_ping_time = mstime();
1087      ri-&gt;link-&gt;last_ping_time = 0;
1088      ri-&gt;link-&gt;last_avail_time = mstime();
1089      ri-&gt;link-&gt;last_pong_time = mstime();
1090      ri-&gt;role_reported_time = mstime();
1091      ri-&gt;role_reported = SRI_MASTER;
1092      if (flags &amp; SENTINEL_GENERATE_EVENT)
1093          sentinelEvent(LL_WARNING,&quot;+reset-master&quot;,ri,&quot;%@&quot;);
1094  }
1095  int sentinelResetMastersByPattern(char *pattern, int flags) {
1096      dictIterator *di;
1097      dictEntry *de;
1098      int reset = 0;
1099      di = dictGetIterator(sentinel.masters);
1100      while((de = dictNext(di)) != NULL) {
1101          sentinelRedisInstance *ri = dictGetVal(de);
1102          if (ri-&gt;name) {
1103              if (stringmatch(pattern,ri-&gt;name,0)) {
1104                  sentinelResetMaster(ri,flags);
1105                  reset++;
1106              }
1107          }
1108      }
1109      dictReleaseIterator(di);
1110      return reset;
1111  }
1112  int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip, int port) {
1113      sentinelAddr *oldaddr, *newaddr;
1114      sentinelAddr **slaves = NULL;
1115      int numslaves = 0, j;
1116      dictIterator *di;
1117      dictEntry *de;
1118      newaddr = createSentinelAddr(ip,port);
1119      if (newaddr == NULL) return C_ERR;
1120      di = dictGetIterator(master-&gt;slaves);
1121      while((de = dictNext(di)) != NULL) {
1122          sentinelRedisInstance *slave = dictGetVal(de);
1123          if (sentinelAddrIsEqual(slave-&gt;addr,newaddr)) continue;
1124          slaves = zrealloc(slaves,sizeof(sentinelAddr*)*(numslaves+1));
1125          slaves[numslaves++] = createSentinelAddr(slave-&gt;addr-&gt;ip,
1126                                                   slave-&gt;addr-&gt;port);
1127      }
1128      dictReleaseIterator(di);
1129      if (!sentinelAddrIsEqual(newaddr,master-&gt;addr)) {
1130          slaves = zrealloc(slaves,sizeof(sentinelAddr*)*(numslaves+1));
1131          slaves[numslaves++] = createSentinelAddr(master-&gt;addr-&gt;ip,
1132                                                   master-&gt;addr-&gt;port);
1133      }
1134      sentinelResetMaster(master,SENTINEL_RESET_NO_SENTINELS);
1135      oldaddr = master-&gt;addr;
1136      master-&gt;addr = newaddr;
1137      master-&gt;o_down_since_time = 0;
1138      master-&gt;s_down_since_time = 0;
1139      for (j = 0; j &lt; numslaves; j++) {
1140          sentinelRedisInstance *slave;
1141          slave = createSentinelRedisInstance(NULL,SRI_SLAVE,slaves[j]-&gt;ip,
1142                      slaves[j]-&gt;port, master-&gt;quorum, master);
1143          releaseSentinelAddr(slaves[j]);
1144          if (slave) sentinelEvent(LL_NOTICE,&quot;+slave&quot;,slave,&quot;%@&quot;);
1145      }
1146      zfree(slaves);
1147      releaseSentinelAddr(oldaddr);
1148      sentinelFlushConfig();
1149      return C_OK;
1150  }
1151  int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {
1152      mstime_t most_recent;
1153      most_recent = ri-&gt;s_down_since_time;
1154      if (ri-&gt;o_down_since_time &gt; most_recent)
1155          most_recent = ri-&gt;o_down_since_time;
1156      return most_recent == 0 || (mstime() - most_recent) &gt; ms;
1157  }
1158  sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {
1159      if ((master-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) &amp;&amp;
1160          master-&gt;promoted_slave &amp;&amp;
1161          master-&gt;failover_state &gt;= SENTINEL_FAILOVER_STATE_RECONF_SLAVES)
1162      {
1163          return master-&gt;promoted_slave-&gt;addr;
1164      } else {
1165          return master-&gt;addr;
1166      }
1167  }
1168  void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {
1169      dictIterator *di;
1170      dictEntry *de;
1171      int j;
1172      dict *d[] = {master-&gt;slaves, master-&gt;sentinels, NULL};
1173      for (j = 0; d[j]; j++) {
1174          di = dictGetIterator(d[j]);
1175          while((de = dictNext(di)) != NULL) {
1176              sentinelRedisInstance *ri = dictGetVal(de);
1177              ri-&gt;down_after_period = master-&gt;down_after_period;
1178          }
1179          dictReleaseIterator(di);
1180      }
1181  }
1182  char *sentinelGetInstanceTypeString(sentinelRedisInstance *ri) {
1183      if (ri-&gt;flags &amp; SRI_MASTER) return &quot;master&quot;;
1184      else if (ri-&gt;flags &amp; SRI_SLAVE) return &quot;slave&quot;;
1185      else if (ri-&gt;flags &amp; SRI_SENTINEL) return &quot;sentinel&quot;;
1186      else return &quot;unknown&quot;;
1187  }
1188  char *sentinelInstanceMapCommand(sentinelRedisInstance *ri, char *command) {
1189      sds sc = sdsnew(command);
1190      if (ri-&gt;master) ri = ri-&gt;master;
1191      char *retval = dictFetchValue(ri-&gt;renamed_commands, sc);
1192      sdsfree(sc);
1193      return retval ? retval : command;
1194  }
1195  char *sentinelHandleConfiguration(char **argv, int argc) {
1196      sentinelRedisInstance *ri;
1197      if (!strcasecmp(argv[0],&quot;monitor&quot;) &amp;&amp; argc == 5) {
1198          int quorum = atoi(argv[4]);
1199          if (quorum &lt;= 0) return &quot;Quorum must be 1 or greater.&quot;;
1200          if (createSentinelRedisInstance(argv[1],SRI_MASTER,argv[2],
1201                                          atoi(argv[3]),quorum,NULL) == NULL)
1202          {
1203              switch(errno) {
1204              case EBUSY: return &quot;Duplicated master name.&quot;;
1205              case ENOENT: return &quot;Can&#x27;t resolve master instance hostname.&quot;;
1206              case EINVAL: return &quot;Invalid port number&quot;;
1207              }
1208          }
1209      } else if (!strcasecmp(argv[0],&quot;down-after-milliseconds&quot;) &amp;&amp; argc == 3) {
1210          ri = sentinelGetMasterByName(argv[1]);
1211          if (!ri) return &quot;No such master with specified name.&quot;;
1212          ri-&gt;down_after_period = atoi(argv[2]);
1213          if (ri-&gt;down_after_period &lt;= 0)
1214              return &quot;negative or zero time parameter.&quot;;
1215          sentinelPropagateDownAfterPeriod(ri);
1216      } else if (!strcasecmp(argv[0],&quot;failover-timeout&quot;) &amp;&amp; argc == 3) {
1217          ri = sentinelGetMasterByName(argv[1]);
1218          if (!ri) return &quot;No such master with specified name.&quot;;
1219          ri-&gt;failover_timeout = atoi(argv[2]);
1220          if (ri-&gt;failover_timeout &lt;= 0)
1221              return &quot;negative or zero time parameter.&quot;;
1222     } else if (!strcasecmp(argv[0],&quot;parallel-syncs&quot;) &amp;&amp; argc == 3) {
1223          ri = sentinelGetMasterByName(argv[1]);
1224          if (!ri) return &quot;No such master with specified name.&quot;;
1225          ri-&gt;parallel_syncs = atoi(argv[2]);
1226     } else if (!strcasecmp(argv[0],&quot;notification-script&quot;) &amp;&amp; argc == 3) {
1227          ri = sentinelGetMasterByName(argv[1]);
1228          if (!ri) return &quot;No such master with specified name.&quot;;
1229          if (access(argv[2],X_OK) == -1)
1230              return &quot;Notification script seems non existing or non executable.&quot;;
1231          ri-&gt;notification_script = sdsnew(argv[2]);
1232     } else if (!strcasecmp(argv[0],&quot;client-reconfig-script&quot;) &amp;&amp; argc == 3) {
1233          ri = sentinelGetMasterByName(argv[1]);
1234          if (!ri) return &quot;No such master with specified name.&quot;;
1235          if (access(argv[2],X_OK) == -1)
1236              return &quot;Client reconfiguration script seems non existing or &quot;
1237                     &quot;non executable.&quot;;
1238          ri-&gt;client_reconfig_script = sdsnew(argv[2]);
1239     } else if (!strcasecmp(argv[0],&quot;auth-pass&quot;) &amp;&amp; argc == 3) {
1240          ri = sentinelGetMasterByName(argv[1]);
1241          if (!ri) return &quot;No such master with specified name.&quot;;
1242          ri-&gt;auth_pass = sdsnew(argv[2]);
1243      } else if (!strcasecmp(argv[0],&quot;current-epoch&quot;) &amp;&amp; argc == 2) {
1244          PORT_ULONGLONG current_epoch = strtoull(argv[1],NULL,10);
1245          if (current_epoch &gt; sentinel.current_epoch)
1246              sentinel.current_epoch = current_epoch;
1247      } else if (!strcasecmp(argv[0],&quot;myid&quot;) &amp;&amp; argc == 2) {
1248          if (strlen(argv[1]) != CONFIG_RUN_ID_SIZE)
1249              return &quot;Malformed Sentinel id in myid option.&quot;;
1250          memcpy(sentinel.myid,argv[1],CONFIG_RUN_ID_SIZE);
1251      } else if (!strcasecmp(argv[0],&quot;config-epoch&quot;) &amp;&amp; argc == 3) {
1252          ri = sentinelGetMasterByName(argv[1]);
1253          if (!ri) return &quot;No such master with specified name.&quot;;
1254          ri-&gt;config_epoch = strtoull(argv[2],NULL,10);
1255          if (ri-&gt;config_epoch &gt; sentinel.current_epoch)
1256              sentinel.current_epoch = ri-&gt;config_epoch;
1257      } else if (!strcasecmp(argv[0],&quot;leader-epoch&quot;) &amp;&amp; argc == 3) {
1258          ri = sentinelGetMasterByName(argv[1]);
1259          if (!ri) return &quot;No such master with specified name.&quot;;
1260          ri-&gt;leader_epoch = strtoull(argv[2],NULL,10);
1261      } else if ((!strcasecmp(argv[0],&quot;known-slave&quot;) ||
1262                  !strcasecmp(argv[0],&quot;known-replica&quot;)) &amp;&amp; argc == 4)
1263      {
1264          sentinelRedisInstance *slave;
1265          ri = sentinelGetMasterByName(argv[1]);
1266          if (!ri) return &quot;No such master with specified name.&quot;;
1267          if ((slave = createSentinelRedisInstance(NULL,SRI_SLAVE,argv[2],
1268                      atoi(argv[3]), ri-&gt;quorum, ri)) == NULL)
1269          {
1270              return &quot;Wrong hostname or port for replica.&quot;;
1271          }
1272      } else if (!strcasecmp(argv[0],&quot;known-sentinel&quot;) &amp;&amp;
1273                 (argc == 4 || argc == 5)) {
1274          sentinelRedisInstance *si;
1275          if (argc == 5) { &amp;bsol;* Ignore the old form without runid. */
1276              ri = sentinelGetMasterByName(argv[1]);
1277              if (!ri) return &quot;No such master with specified name.&quot;;
1278              if ((si = createSentinelRedisInstance(argv[4],SRI_SENTINEL,argv[2],
1279                          atoi(argv[3]), ri-&gt;quorum, ri)) == NULL)
1280              {
1281                  return &quot;Wrong hostname or port for sentinel.&quot;;
1282              }
1283              si-&gt;runid = sdsnew(argv[4]);
1284              sentinelTryConnectionSharing(si);
1285          }
1286      } else if (!strcasecmp(argv[0],&quot;rename-command&quot;) &amp;&amp; argc == 4) {
1287          ri = sentinelGetMasterByName(argv[1]);
1288          if (!ri) return &quot;No such master with specified name.&quot;;
1289          sds oldcmd = sdsnew(argv[2]);
1290          sds newcmd = sdsnew(argv[3]);
1291          if (dictAdd(ri-&gt;renamed_commands,oldcmd,newcmd) != DICT_OK) {
1292              sdsfree(oldcmd);
1293              sdsfree(newcmd);
1294              return &quot;Same command renamed multiple times with rename-command.&quot;;
1295          }
1296      } else if (!strcasecmp(argv[0],&quot;announce-ip&quot;) &amp;&amp; argc == 2) {
1297          if (strlen(argv[1]))
1298              sentinel.announce_ip = sdsnew(argv[1]);
1299      } else if (!strcasecmp(argv[0],&quot;announce-port&quot;) &amp;&amp; argc == 2) {
1300          sentinel.announce_port = atoi(argv[1]);
1301      } else if (!strcasecmp(argv[0],&quot;deny-scripts-reconfig&quot;) &amp;&amp; argc == 2) {
1302          if ((sentinel.deny_scripts_reconfig = yesnotoi(argv[1])) == -1) {
1303              return &quot;Please specify yes or no for the &quot;
1304                     &quot;deny-scripts-reconfig options.&quot;;
1305          }
1306      } else {
1307          return &quot;Unrecognized sentinel configuration statement.&quot;;
1308      }
1309      return NULL;
1310  }
1311  void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
1312      dictIterator *di, *di2;
1313      dictEntry *de;
1314      sds line;
1315      line = sdscatprintf(sdsempty(), &quot;sentinel myid %s&quot;, sentinel.myid);
1316      rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1317      line = sdscatprintf(sdsempty(), &quot;sentinel deny-scripts-reconfig %s&quot;,
1318          sentinel.deny_scripts_reconfig ? &quot;yes&quot; : &quot;no&quot;);
1319      rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,
1320          sentinel.deny_scripts_reconfig != SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG);
1321      di = dictGetIterator(sentinel.masters);
1322      while((de = dictNext(di)) != NULL) {
1323          sentinelRedisInstance *master, *ri;
1324          sentinelAddr *master_addr;
1325          master = dictGetVal(de);
1326          master_addr = sentinelGetCurrentMasterAddress(master);
1327          line = sdscatprintf(sdsempty(),&quot;sentinel monitor %s %s %d %d&quot;,
1328              master-&gt;name, master_addr-&gt;ip, master_addr-&gt;port,
1329              master-&gt;quorum);
1330          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1331          if (master-&gt;down_after_period != SENTINEL_DEFAULT_DOWN_AFTER) {
1332              line = sdscatprintf(sdsempty(),
1333                  &quot;sentinel down-after-milliseconds %s %Id&quot;,                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id*/
1334                  master-&gt;name, (PORT_LONG) master-&gt;down_after_period);
1335              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1336          }
1337          if (master-&gt;failover_timeout != SENTINEL_DEFAULT_FAILOVER_TIMEOUT) {
1338              line = sdscatprintf(sdsempty(),
1339                  &quot;sentinel failover-timeout %s %Id&quot;,                             WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id*/
1340                  master-&gt;name, (PORT_LONG) master-&gt;failover_timeout);
1341              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1342          }
1343          if (master-&gt;parallel_syncs != SENTINEL_DEFAULT_PARALLEL_SYNCS) {
1344              line = sdscatprintf(sdsempty(),
1345                  &quot;sentinel parallel-syncs %s %d&quot;,
1346                  master-&gt;name, master-&gt;parallel_syncs);
1347              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1348          }
1349          if (master-&gt;notification_script) {
1350              line = sdscatprintf(sdsempty(),
1351                  &quot;sentinel notification-script %s %s&quot;,
1352                  master-&gt;name, master-&gt;notification_script);
1353              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1354          }
1355          if (master-&gt;client_reconfig_script) {
1356              line = sdscatprintf(sdsempty(),
1357                  &quot;sentinel client-reconfig-script %s %s&quot;,
1358                  master-&gt;name, master-&gt;client_reconfig_script);
1359              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1360          }
1361          if (master-&gt;auth_pass) {
1362              line = sdscatprintf(sdsempty(),
1363                  &quot;sentinel auth-pass %s %s&quot;,
1364                  master-&gt;name, master-&gt;auth_pass);
1365              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1366          }
1367          line = sdscatprintf(sdsempty(),
1368              &quot;sentinel config-epoch %s %llu&quot;,
1369              master-&gt;name, (PORT_ULONGLONG) master-&gt;config_epoch);
1370          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1371          line = sdscatprintf(sdsempty(),
1372              &quot;sentinel leader-epoch %s %llu&quot;,
1373              master-&gt;name, (PORT_ULONGLONG) master-&gt;leader_epoch);
1374          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1375          di2 = dictGetIterator(master-&gt;slaves);
1376          while((de = dictNext(di2)) != NULL) {
1377              sentinelAddr *slave_addr;
1378              ri = dictGetVal(de);
1379              slave_addr = ri-&gt;addr;
1380              if (sentinelAddrIsEqual(slave_addr,master_addr))
1381                  slave_addr = master-&gt;addr;
1382              line = sdscatprintf(sdsempty(),
1383                  &quot;sentinel known-replica %s %s %d&quot;,
1384                  master-&gt;name, slave_addr-&gt;ip, slave_addr-&gt;port);
1385              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1386          }
1387          dictReleaseIterator(di2);
1388          di2 = dictGetIterator(master-&gt;sentinels);
1389          while((de = dictNext(di2)) != NULL) {
1390              ri = dictGetVal(de);
1391              if (ri-&gt;runid == NULL) continue;
1392              line = sdscatprintf(sdsempty(),
1393                  &quot;sentinel known-sentinel %s %s %d %s&quot;,
1394                  master-&gt;name, ri-&gt;addr-&gt;ip, ri-&gt;addr-&gt;port, ri-&gt;runid);
1395              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1396          }
1397          dictReleaseIterator(di2);
1398          di2 = dictGetIterator(master-&gt;renamed_commands);
1399          while((de = dictNext(di2)) != NULL) {
1400              sds oldname = dictGetKey(de);
1401              sds newname = dictGetVal(de);
1402              line = sdscatprintf(sdsempty(),
1403                  &quot;sentinel rename-command %s %s %s&quot;,
1404                  master-&gt;name, oldname, newname);
1405              rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1406          }
1407          dictReleaseIterator(di2);
1408      }
1409      line = sdscatprintf(sdsempty(),
1410          &quot;sentinel current-epoch %llu&quot;, (PORT_ULONGLONG) sentinel.current_epoch);
1411      rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1412      if (sentinel.announce_ip) {
1413          line = sdsnew(&quot;sentinel announce-ip &quot;);
1414          line = sdscatrepr(line, sentinel.announce_ip, sdslen(sentinel.announce_ip));
1415          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1416      }
1417      if (sentinel.announce_port) {
1418          line = sdscatprintf(sdsempty(),&quot;sentinel announce-port %d&quot;,
1419                              sentinel.announce_port);
1420          rewriteConfigRewriteLine(state,&quot;sentinel&quot;,line,1);
1421      }
1422      dictReleaseIterator(di);
1423  }
1424  void sentinelFlushConfig(void) {
1425      int fd = -1;
1426      int saved_hz = server.hz;
1427      int rewrite_status;
1428      server.hz = CONFIG_DEFAULT_HZ;
1429      rewrite_status = rewriteConfig(server.configfile);
1430      server.hz = saved_hz;
1431      if (rewrite_status == -1) goto werr;
1432      if ((fd = open(server.configfile,O_RDONLY,IF_WIN32(_S_IREAD|_S_IWRITE,0644))) == -1) goto werr;
1433      POSIX_ONLY(if (fsync(fd) == -1) goto werr;)
1434      if (close(fd) == EOF) goto werr;
1435      return;
1436  werr:
1437      if (fd != -1) close(fd);
1438      serverLog(LL_WARNING,&quot;WARNING: Sentinel was not able to save the new configuration on disk!!!: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1439  }
1440  void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
1441      char *auth_pass = NULL;
1442      if (ri-&gt;flags &amp; SRI_MASTER) {
1443          auth_pass = ri-&gt;auth_pass;
1444      } else if (ri-&gt;flags &amp; SRI_SLAVE) {
1445          auth_pass = ri-&gt;master-&gt;auth_pass;
1446      } else if (ri-&gt;flags &amp; SRI_SENTINEL) {
1447          if (server.requirepass) auth_pass = server.requirepass;
1448      }
1449      if (auth_pass) {
1450          if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri, &quot;%s %s&quot;,
1451              sentinelInstanceMapCommand(ri,&quot;AUTH&quot;),
1452              auth_pass) == C_OK) ri-&gt;link-&gt;pending_commands++;
1453      }
1454  }
1455  void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {
1456      char name[64];
1457      snprintf(name,sizeof(name),&quot;sentinel-%.8s-%s&quot;,sentinel.myid,type);
1458      if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri,
1459          &quot;%s SETNAME %s&quot;,
1460          sentinelInstanceMapCommand(ri,&quot;CLIENT&quot;),
1461          name) == C_OK)
1462      {
1463          ri-&gt;link-&gt;pending_commands++;
1464      }
1465  }
1466  void sentinelReconnectInstance(sentinelRedisInstance *ri) {
1467      if (ri-&gt;link-&gt;disconnected == 0) return;
1468      if (ri-&gt;addr-&gt;port == 0) return; &amp;bsol;* port == 0 means invalid address. */
1469      instanceLink *link = ri-&gt;link;
1470      mstime_t now = mstime();
1471      if (now - ri-&gt;link-&gt;last_reconn_time &lt; SENTINEL_PING_PERIOD) return;
1472      ri-&gt;link-&gt;last_reconn_time = now;
1473      if (link-&gt;cc == NULL) {
1474          link-&gt;cc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port,NET_FIRST_BIND_ADDR);
1475          if (link-&gt;cc-&gt;err) {
1476              sentinelEvent(LL_DEBUG,&quot;-cmd-link-reconnection&quot;,ri,&quot;%@ #%s&quot;,
1477                  link-&gt;cc-&gt;errstr);
1478              instanceLinkCloseConnection(link,link-&gt;cc);
1479          } else {
1480              link-&gt;pending_commands = 0;
1481              link-&gt;cc_conn_time = mstime();
1482              link-&gt;cc-&gt;data = link;
1483              redisAeAttach(server.el,link-&gt;cc);
1484              redisAsyncSetConnectCallback(link-&gt;cc,
1485                      sentinelLinkEstablishedCallback);
1486              redisAsyncSetDisconnectCallback(link-&gt;cc,
1487                      sentinelDisconnectCallback);
1488              sentinelSendAuthIfNeeded(ri,link-&gt;cc);
1489              sentinelSetClientName(ri,link-&gt;cc,&quot;cmd&quot;);
1490              sentinelSendPing(ri);
1491          }
1492      }
1493      if ((ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) &amp;&amp; link-&gt;pc == NULL) {
1494          link-&gt;pc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port,NET_FIRST_BIND_ADDR);
1495          if (link-&gt;pc-&gt;err) {
1496              sentinelEvent(LL_DEBUG,&quot;-pubsub-link-reconnection&quot;,ri,&quot;%@ #%s&quot;,
1497                  link-&gt;pc-&gt;errstr);
1498              instanceLinkCloseConnection(link,link-&gt;pc);
1499          } else {
1500              int retval;
1501              link-&gt;pc_conn_time = mstime();
1502              link-&gt;pc-&gt;data = link;
<span onclick='openModal()' class='match'>1503              redisAeAttach(server.el,link-&gt;pc);
1504              redisAsyncSetConnectCallback(link-&gt;pc,
1505                      sentinelLinkEstablishedCallback);
1506              redisAsyncSetDisconnectCallback(link-&gt;pc,
1507                      sentinelDisconnectCallback);
1508              sentinelSendAuthIfNeeded(ri,link-&gt;pc);
1509              sentinelSetClientName(ri,link-&gt;pc,&quot;pubsub&quot;);
1510              retval = redisAsyncCommand(link-&gt;pc,
</span>1511                  sentinelReceiveHelloMessages, ri, &quot;%s %s&quot;,
1512                  sentinelInstanceMapCommand(ri,&quot;SUBSCRIBE&quot;),
1513                  SENTINEL_HELLO_CHANNEL);
1514              if (retval != C_OK) {
1515                  instanceLinkCloseConnection(link,link-&gt;pc);
1516                  return;
1517              }
1518          }
1519      }
1520      if (link-&gt;cc &amp;&amp; (ri-&gt;flags &amp; SRI_SENTINEL || link-&gt;pc))
1521          link-&gt;disconnected = 0;
1522  }
1523  int sentinelMasterLooksSane(sentinelRedisInstance *master) {
1524      return
1525          master-&gt;flags &amp; SRI_MASTER &amp;&amp;
1526          master-&gt;role_reported == SRI_MASTER &amp;&amp;
1527          (master-&gt;flags &amp; (SRI_S_DOWN|SRI_O_DOWN)) == 0 &amp;&amp;
1528          (mstime() - master-&gt;info_refresh) &lt; SENTINEL_INFO_PERIOD*2;
1529  }
1530  void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
1531      sds *lines;
1532      int numlines, j;
1533      int role = 0;
1534      sdsfree(ri-&gt;info);
1535      ri-&gt;info = sdsnew(info);
1536      ri-&gt;master_link_down_time = 0;
1537      lines = sdssplitlen(info,(int)strlen(info),&quot;\r\n&quot;,2,&amp;numlines);             WIN_PORT_FIX &amp;bsol;* cast (int) */
1538      for (j = 0; j &lt; numlines; j++) {
1539          sentinelRedisInstance *slave;
1540          sds l = lines[j];
1541          if (sdslen(l) &gt;= 47 &amp;&amp; !memcmp(l,&quot;run_id:&quot;,7)) {
1542              if (ri-&gt;runid == NULL) {
1543                  ri-&gt;runid = sdsnewlen(l+7,40);
1544              } else {
1545                  if (strncmp(ri-&gt;runid,l+7,40) != 0) {
1546                      sentinelEvent(LL_NOTICE,&quot;+reboot&quot;,ri,&quot;%@&quot;);
1547                      sdsfree(ri-&gt;runid);
1548                      ri-&gt;runid = sdsnewlen(l+7,40);
1549                  }
1550              }
1551          }
1552          if ((ri-&gt;flags &amp; SRI_MASTER) &amp;&amp;
1553              sdslen(l) &gt;= 7 &amp;&amp;
1554              !memcmp(l,&quot;slave&quot;,5) &amp;&amp; isdigit(l[5]))
1555          {
1556              char *ip, *port, *end;
1557              if (strstr(l,&quot;ip=&quot;) == NULL) {
1558                  ip = strchr(l,&#x27;:&#x27;); if (!ip) continue;
1559                  ip++; &amp;bsol;* Now ip points to start of ip address. */
1560                  port = strchr(ip,&#x27;,&#x27;); if (!port) continue;
1561                  *port = &#x27;\0&#x27;; &amp;bsol;* nul term for easy access. */
1562                  port++; &amp;bsol;* Now port points to start of port number. */
1563                  end = strchr(port,&#x27;,&#x27;); if (!end) continue;
1564                  *end = &#x27;\0&#x27;; &amp;bsol;* nul term for easy access. */
1565              } else {
1566                  ip = strstr(l,&quot;ip=&quot;); if (!ip) continue;
1567                  ip += 3; &amp;bsol;* Now ip points to start of ip address. */
1568                  port = strstr(l,&quot;port=&quot;); if (!port) continue;
1569                  port += 5; &amp;bsol;* Now port points to start of port number. */
1570                  end = strchr(ip,&#x27;,&#x27;); if (end) *end = &#x27;\0&#x27;;
1571                  end = strchr(port,&#x27;,&#x27;); if (end) *end = &#x27;\0&#x27;;
1572              }
1573              if (sentinelRedisInstanceLookupSlave(ri,ip,atoi(port)) == NULL) {
1574                  if ((slave = createSentinelRedisInstance(NULL,SRI_SLAVE,ip,
1575                              atoi(port), ri-&gt;quorum, ri)) != NULL)
1576                  {
1577                      sentinelEvent(LL_NOTICE,&quot;+slave&quot;,slave,&quot;%@&quot;);
1578                      sentinelFlushConfig();
1579                  }
1580              }
1581          }
1582          if (sdslen(l) &gt;= 32 &amp;&amp;
1583              !memcmp(l,&quot;master_link_down_since_seconds&quot;,30))
1584          {
1585              ri-&gt;master_link_down_time = strtoll(l+31,NULL,10)*1000;
1586          }
1587          if (!memcmp(l,&quot;role:master&quot;,11)) role = SRI_MASTER;
1588          else if (!memcmp(l,&quot;role:slave&quot;,10)) role = SRI_SLAVE;
1589          if (role == SRI_SLAVE) {
1590              if (sdslen(l) &gt;= 12 &amp;&amp; !memcmp(l,&quot;master_host:&quot;,12)) {
1591                  if (ri-&gt;slave_master_host == NULL ||
1592                      strcasecmp(l+12,ri-&gt;slave_master_host))
1593                  {
1594                      sdsfree(ri-&gt;slave_master_host);
1595                      ri-&gt;slave_master_host = sdsnew(l+12);
1596                      ri-&gt;slave_conf_change_time = mstime();
1597                  }
1598              }
1599              if (sdslen(l) &gt;= 12 &amp;&amp; !memcmp(l,&quot;master_port:&quot;,12)) {
1600                  int slave_master_port = atoi(l+12);
1601                  if (ri-&gt;slave_master_port != slave_master_port) {
1602                      ri-&gt;slave_master_port = slave_master_port;
1603                      ri-&gt;slave_conf_change_time = mstime();
1604                  }
1605              }
1606              if (sdslen(l) &gt;= 19 &amp;&amp; !memcmp(l,&quot;master_link_status:&quot;,19)) {
1607                  ri-&gt;slave_master_link_status =
1608                      (strcasecmp(l+19,&quot;up&quot;) == 0) ?
1609                      SENTINEL_MASTER_LINK_STATUS_UP :
1610                      SENTINEL_MASTER_LINK_STATUS_DOWN;
1611              }
1612              if (sdslen(l) &gt;= 15 &amp;&amp; !memcmp(l,&quot;slave_priority:&quot;,15))
1613                  ri-&gt;slave_priority = atoi(l+15);
1614              if (sdslen(l) &gt;= 18 &amp;&amp; !memcmp(l,&quot;slave_repl_offset:&quot;,18))
1615                  ri-&gt;slave_repl_offset = strtoull(l+18,NULL,10);
1616          }
1617      }
1618      ri-&gt;info_refresh = mstime();
1619      sdsfreesplitres(lines,numlines);
1620      if (role != ri-&gt;role_reported) {
1621          ri-&gt;role_reported_time = mstime();
1622          ri-&gt;role_reported = role;
1623          if (role == SRI_SLAVE) ri-&gt;slave_conf_change_time = mstime();
1624          sentinelEvent(LL_VERBOSE,
1625              ((ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) == role) ?
1626              &quot;+role-change&quot; : &quot;-role-change&quot;,
1627              ri, &quot;%@ new reported role is %s&quot;,
1628              role == SRI_MASTER ? &quot;master&quot; : &quot;slave&quot;,
1629              ri-&gt;flags &amp; SRI_MASTER ? &quot;master&quot; : &quot;slave&quot;);
1630      }
1631      if (sentinel.tilt) return;
1632      if ((ri-&gt;flags &amp; SRI_MASTER) &amp;&amp; role == SRI_SLAVE) {
1633      }
1634      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp; role == SRI_MASTER) {
1635          if ((ri-&gt;flags &amp; SRI_PROMOTED) &amp;&amp;
1636              (ri-&gt;master-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) &amp;&amp;
1637              (ri-&gt;master-&gt;failover_state ==
1638                  SENTINEL_FAILOVER_STATE_WAIT_PROMOTION))
1639          {
1640              ri-&gt;master-&gt;config_epoch = ri-&gt;master-&gt;failover_epoch;
1641              ri-&gt;master-&gt;failover_state = SENTINEL_FAILOVER_STATE_RECONF_SLAVES;
1642              ri-&gt;master-&gt;failover_state_change_time = mstime();
1643              sentinelFlushConfig();
1644              sentinelEvent(LL_WARNING,&quot;+promoted-slave&quot;,ri,&quot;%@&quot;);
1645              if (sentinel.simfailure_flags &amp;
1646                  SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION)
1647                  sentinelSimFailureCrash();
1648              sentinelEvent(LL_WARNING,&quot;+failover-state-reconf-slaves&quot;,
1649                  ri-&gt;master,&quot;%@&quot;);
1650              sentinelCallClientReconfScript(ri-&gt;master,SENTINEL_LEADER,
1651                  &quot;start&quot;,ri-&gt;master-&gt;addr,ri-&gt;addr);
1652              sentinelForceHelloUpdateForMaster(ri-&gt;master);
1653          } else {
1654              mstime_t wait_time = SENTINEL_PUBLISH_PERIOD*4;
1655              if (!(ri-&gt;flags &amp; SRI_PROMOTED) &amp;&amp;
1656                   sentinelMasterLooksSane(ri-&gt;master) &amp;&amp;
1657                   sentinelRedisInstanceNoDownFor(ri,wait_time) &amp;&amp;
1658                   mstime() - ri-&gt;role_reported_time &gt; wait_time)
1659              {
1660                  int retval = sentinelSendSlaveOf(ri,
1661                          ri-&gt;master-&gt;addr-&gt;ip,
1662                          ri-&gt;master-&gt;addr-&gt;port);
1663                  if (retval == C_OK)
1664                      sentinelEvent(LL_NOTICE,&quot;+convert-to-slave&quot;,ri,&quot;%@&quot;);
1665              }
1666          }
1667      }
1668      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp;
1669          role == SRI_SLAVE &amp;&amp;
1670          (ri-&gt;slave_master_port != ri-&gt;master-&gt;addr-&gt;port ||
1671           strcasecmp(ri-&gt;slave_master_host,ri-&gt;master-&gt;addr-&gt;ip)))
1672      {
1673          mstime_t wait_time = ri-&gt;master-&gt;failover_timeout;
1674          if (sentinelMasterLooksSane(ri-&gt;master) &amp;&amp;
1675              sentinelRedisInstanceNoDownFor(ri,wait_time) &amp;&amp;
1676              mstime() - ri-&gt;slave_conf_change_time &gt; wait_time)
1677          {
1678              int retval = sentinelSendSlaveOf(ri,
1679                      ri-&gt;master-&gt;addr-&gt;ip,
1680                      ri-&gt;master-&gt;addr-&gt;port);
1681              if (retval == C_OK)
1682                  sentinelEvent(LL_NOTICE,&quot;+fix-slave-config&quot;,ri,&quot;%@&quot;);
1683          }
1684      }
1685      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp; role == SRI_SLAVE &amp;&amp;
1686          (ri-&gt;flags &amp; (SRI_RECONF_SENT|SRI_RECONF_INPROG)))
1687      {
1688          if ((ri-&gt;flags &amp; SRI_RECONF_SENT) &amp;&amp;
1689              ri-&gt;slave_master_host &amp;&amp;
1690              strcmp(ri-&gt;slave_master_host,
1691                      ri-&gt;master-&gt;promoted_slave-&gt;addr-&gt;ip) == 0 &amp;&amp;
1692              ri-&gt;slave_master_port == ri-&gt;master-&gt;promoted_slave-&gt;addr-&gt;port)
1693          {
1694              ri-&gt;flags &amp;= ~SRI_RECONF_SENT;
1695              ri-&gt;flags |= SRI_RECONF_INPROG;
1696              sentinelEvent(LL_NOTICE,&quot;+slave-reconf-inprog&quot;,ri,&quot;%@&quot;);
1697          }
1698          if ((ri-&gt;flags &amp; SRI_RECONF_INPROG) &amp;&amp;
1699              ri-&gt;slave_master_link_status == SENTINEL_MASTER_LINK_STATUS_UP)
1700          {
1701              ri-&gt;flags &amp;= ~SRI_RECONF_INPROG;
1702              ri-&gt;flags |= SRI_RECONF_DONE;
1703              sentinelEvent(LL_NOTICE,&quot;+slave-reconf-done&quot;,ri,&quot;%@&quot;);
1704          }
1705      }
1706  }
1707  void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
1708      sentinelRedisInstance *ri = privdata;
1709      instanceLink *link = c-&gt;data;
1710      redisReply *r;
1711      if (!reply || !link) return;
1712      link-&gt;pending_commands--;
1713      r = reply;
1714      if (r-&gt;type == REDIS_REPLY_STRING)
1715          sentinelRefreshInstanceInfo(ri,r-&gt;str);
1716  }
1717  void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
1718      instanceLink *link = c-&gt;data;
1719      UNUSED(reply);
1720      UNUSED(privdata);
1721      if (link) link-&gt;pending_commands--;
1722  }
1723  void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
1724      sentinelRedisInstance *ri = privdata;
1725      instanceLink *link = c-&gt;data;
1726      redisReply *r;
1727      if (!reply || !link) return;
1728      link-&gt;pending_commands--;
1729      r = reply;
1730      if (r-&gt;type == REDIS_REPLY_STATUS ||
1731          r-&gt;type == REDIS_REPLY_ERROR) {
1732          if (strncmp(r-&gt;str,&quot;PONG&quot;,4) == 0 ||
1733              strncmp(r-&gt;str,&quot;LOADING&quot;,7) == 0 ||
1734              strncmp(r-&gt;str,&quot;MASTERDOWN&quot;,10) == 0)
1735          {
1736              link-&gt;last_avail_time = mstime();
1737              link-&gt;act_ping_time = 0; &amp;bsol;* Flag the pong as received. */
1738          } else {
1739              if (strncmp(r-&gt;str,&quot;BUSY&quot;,4) == 0 &amp;&amp;
1740                  (ri-&gt;flags &amp; SRI_S_DOWN) &amp;&amp;
1741                  !(ri-&gt;flags &amp; SRI_SCRIPT_KILL_SENT))
1742              {
1743                  if (redisAsyncCommand(ri-&gt;link-&gt;cc,
1744                          sentinelDiscardReplyCallback, ri,
1745                          &quot;%s KILL&quot;,
1746                          sentinelInstanceMapCommand(ri,&quot;SCRIPT&quot;)) == C_OK)
1747                  {
1748                      ri-&gt;link-&gt;pending_commands++;
1749                  }
1750                  ri-&gt;flags |= SRI_SCRIPT_KILL_SENT;
1751              }
1752          }
1753      }
1754      link-&gt;last_pong_time = mstime();
1755  }
1756  void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
1757      sentinelRedisInstance *ri = privdata;
1758      instanceLink *link = c-&gt;data;
1759      redisReply *r;
1760      if (!reply || !link) return;
1761      link-&gt;pending_commands--;
1762      r = reply;
1763      if (r-&gt;type != REDIS_REPLY_ERROR)
1764          ri-&gt;last_pub_time = mstime();
1765  }
1766  void sentinelProcessHelloMessage(char *hello, int hello_len) {
1767      int numtokens, port, removed, master_port;
1768      uint64_t current_epoch, master_config_epoch;
1769      char **token = sdssplitlen(hello, hello_len, &quot;,&quot;, 1, &amp;numtokens);
1770      sentinelRedisInstance *si, *master;
1771      if (numtokens == 8) {
1772          master = sentinelGetMasterByName(token[4]);
1773          if (!master) goto cleanup; &amp;bsol;* Unknown master, skip the message. */
1774          port = atoi(token[1]);
1775          master_port = atoi(token[6]);
1776          si = getSentinelRedisInstanceByAddrAndRunID(
1777                          master-&gt;sentinels,token[0],port,token[2]);
1778          current_epoch = strtoull(token[3],NULL,10);
1779          master_config_epoch = strtoull(token[7],NULL,10);
1780          if (!si) {
1781              removed = removeMatchingSentinelFromMaster(master,token[2]);
1782              if (removed) {
1783                  sentinelEvent(LL_NOTICE,&quot;+sentinel-address-switch&quot;,master,
1784                      &quot;%@ ip %s port %d for %s&quot;, token[0],port,token[2]);
1785              } else {
1786                  sentinelRedisInstance *other =
1787                      getSentinelRedisInstanceByAddrAndRunID(
1788                          master-&gt;sentinels, token[0],port,NULL);
1789                  if (other) {
1790                      sentinelEvent(LL_NOTICE,&quot;+sentinel-invalid-addr&quot;,other,&quot;%@&quot;);
1791                      other-&gt;addr-&gt;port = 0; &amp;bsol;* It means: invalid address. */
1792                      sentinelUpdateSentinelAddressInAllMasters(other);
1793                  }
1794              }
1795              si = createSentinelRedisInstance(token[2],SRI_SENTINEL,
1796                              token[0],port,master-&gt;quorum,master);
1797              if (si) {
1798                  if (!removed) sentinelEvent(LL_NOTICE,&quot;+sentinel&quot;,si,&quot;%@&quot;);
1799                  si-&gt;runid = sdsnew(token[2]);
1800                  sentinelTryConnectionSharing(si);
1801                  if (removed) sentinelUpdateSentinelAddressInAllMasters(si);
1802                  sentinelFlushConfig();
1803              }
1804          }
1805          if (current_epoch &gt; sentinel.current_epoch) {
1806              sentinel.current_epoch = current_epoch;
1807              sentinelFlushConfig();
1808              sentinelEvent(LL_WARNING,&quot;+new-epoch&quot;,master,&quot;%llu&quot;,
1809                  (PORT_ULONGLONG) sentinel.current_epoch);
1810          }
1811          if (si &amp;&amp; master-&gt;config_epoch &lt; master_config_epoch) {
1812              master-&gt;config_epoch = master_config_epoch;
1813              if (master_port != master-&gt;addr-&gt;port ||
1814                  strcmp(master-&gt;addr-&gt;ip, token[5]))
1815              {
1816                  sentinelAddr *old_addr;
1817                  sentinelEvent(LL_WARNING,&quot;+config-update-from&quot;,si,&quot;%@&quot;);
1818                  sentinelEvent(LL_WARNING,&quot;+switch-master&quot;,
1819                      master,&quot;%s %s %d %s %d&quot;,
1820                      master-&gt;name,
1821                      master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port,
1822                      token[5], master_port);
1823                  old_addr = dupSentinelAddr(master-&gt;addr);
1824                  sentinelResetMasterAndChangeAddress(master, token[5], master_port);
1825                  sentinelCallClientReconfScript(master,
1826                      SENTINEL_OBSERVER,&quot;start&quot;,
1827                      old_addr,master-&gt;addr);
1828                  releaseSentinelAddr(old_addr);
1829              }
1830          }
1831          if (si) si-&gt;last_hello_time = mstime();
1832      }
1833  cleanup:
1834      sdsfreesplitres(token,numtokens);
1835  }
1836  void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {
1837      sentinelRedisInstance *ri = privdata;
1838      redisReply *r;
1839      UNUSED(c);
1840      if (!reply || !ri) return;
1841      r = reply;
1842      ri-&gt;link-&gt;pc_last_activity = mstime();
1843      if (r-&gt;type != REDIS_REPLY_ARRAY ||
1844          r-&gt;elements != 3 ||
1845          r-&gt;element[0]-&gt;type != REDIS_REPLY_STRING ||
1846          r-&gt;element[1]-&gt;type != REDIS_REPLY_STRING ||
1847          r-&gt;element[2]-&gt;type != REDIS_REPLY_STRING ||
1848          strcmp(r-&gt;element[0]-&gt;str,&quot;message&quot;) != 0) return;
1849      if (strstr(r-&gt;element[2]-&gt;str,sentinel.myid) != NULL) return;
1850      sentinelProcessHelloMessage(r-&gt;element[2]-&gt;str, r-&gt;element[2]-&gt;len);
1851  }
1852  int sentinelSendHello(sentinelRedisInstance *ri) {
1853      char ip[NET_IP_STR_LEN];
1854      char payload[NET_IP_STR_LEN+1024];
1855      int retval;
1856      char *announce_ip;
1857      int announce_port;
1858      sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ? ri : ri-&gt;master;
1859      sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);
1860      if (ri-&gt;link-&gt;disconnected) return C_ERR;
1861      if (sentinel.announce_ip) {
1862          announce_ip = sentinel.announce_ip;
1863      } else {
1864          if (anetSockName(ri-&gt;link-&gt;cc-&gt;c.fd,ip,sizeof(ip),NULL) == -1)
1865              return C_ERR;
1866          announce_ip = ip;
1867      }
1868      announce_port = sentinel.announce_port ?
1869                      sentinel.announce_port : server.port;
1870      snprintf(payload,sizeof(payload),
1871          &quot;%s,%d,%s,%llu,&quot; &amp;bsol;* Info about this sentinel. */
1872          &quot;%s,%s,%d,%llu&quot;, &amp;bsol;* Info about current master. */
1873          announce_ip, announce_port, sentinel.myid,
1874          (PORT_ULONGLONG) sentinel.current_epoch,
1875          master-&gt;name,master_addr-&gt;ip,master_addr-&gt;port,
1876          (PORT_ULONGLONG) master-&gt;config_epoch);
1877      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
1878          sentinelPublishReplyCallback, ri, &quot;%s %s %s&quot;,
1879          sentinelInstanceMapCommand(ri,&quot;PUBLISH&quot;),
1880          SENTINEL_HELLO_CHANNEL,payload);
1881      if (retval != C_OK) return C_ERR;
1882      ri-&gt;link-&gt;pending_commands++;
1883      return C_OK;
1884  }
1885  void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
1886      dictIterator *di;
1887      dictEntry *de;
1888      di = dictGetSafeIterator(instances);
1889      while((de = dictNext(di)) != NULL) {
1890          sentinelRedisInstance *ri = dictGetVal(de);
1891          if (ri-&gt;last_pub_time &gt;= (SENTINEL_PUBLISH_PERIOD+1))
1892              ri-&gt;last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
1893      }
1894      dictReleaseIterator(di);
1895  }
1896  int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {
1897      if (!(master-&gt;flags &amp; SRI_MASTER)) return C_ERR;
1898      if (master-&gt;last_pub_time &gt;= (SENTINEL_PUBLISH_PERIOD+1))
1899          master-&gt;last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
1900      sentinelForceHelloUpdateDictOfRedisInstances(master-&gt;sentinels);
1901      sentinelForceHelloUpdateDictOfRedisInstances(master-&gt;slaves);
1902      return C_OK;
1903  }
1904  int sentinelSendPing(sentinelRedisInstance *ri) {
1905      int retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
1906          sentinelPingReplyCallback, ri, &quot;%s&quot;,
1907          sentinelInstanceMapCommand(ri,&quot;PING&quot;));
1908      if (retval == C_OK) {
1909          ri-&gt;link-&gt;pending_commands++;
1910          ri-&gt;link-&gt;last_ping_time = mstime();
1911          if (ri-&gt;link-&gt;act_ping_time == 0)
1912              ri-&gt;link-&gt;act_ping_time = ri-&gt;link-&gt;last_ping_time;
1913          return 1;
1914      } else {
1915          return 0;
1916      }
1917  }
1918  void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
1919      mstime_t now = mstime();
1920      mstime_t info_period, ping_period;
1921      int retval;
1922      if (ri-&gt;link-&gt;disconnected) return;
1923      if (ri-&gt;link-&gt;pending_commands &gt;=
1924          SENTINEL_MAX_PENDING_COMMANDS * ri-&gt;link-&gt;refcount) return;
1925      if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp;
1926          ((ri-&gt;master-&gt;flags &amp; (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS)) ||
1927           (ri-&gt;master_link_down_time != 0)))
1928      {
1929          info_period = 1000;
1930      } else {
1931          info_period = SENTINEL_INFO_PERIOD;
1932      }
1933      ping_period = ri-&gt;down_after_period;
1934      if (ping_period &gt; SENTINEL_PING_PERIOD) ping_period = SENTINEL_PING_PERIOD;
1935      if ((ri-&gt;flags &amp; SRI_SENTINEL) == 0 &amp;&amp;
1936          (ri-&gt;info_refresh == 0 ||
1937          (now - ri-&gt;info_refresh) &gt; info_period))
1938      {
1939          retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
1940              sentinelInfoReplyCallback, ri, &quot;%s&quot;,
1941              sentinelInstanceMapCommand(ri,&quot;INFO&quot;));
1942          if (retval == C_OK) ri-&gt;link-&gt;pending_commands++;
1943      }
1944      if ((now - ri-&gt;link-&gt;last_pong_time) &gt; ping_period &amp;&amp;
1945                 (now - ri-&gt;link-&gt;last_ping_time) &gt; ping_period/2) {
1946          sentinelSendPing(ri);
1947      }
1948      if ((now - ri-&gt;last_pub_time) &gt; SENTINEL_PUBLISH_PERIOD) {
1949          sentinelSendHello(ri);
1950      }
1951  }
1952  const char *sentinelFailoverStateStr(int state) {
1953      switch(state) {
1954      case SENTINEL_FAILOVER_STATE_NONE: return &quot;none&quot;;
1955      case SENTINEL_FAILOVER_STATE_WAIT_START: return &quot;wait_start&quot;;
1956      case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: return &quot;select_slave&quot;;
1957      case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: return &quot;send_slaveof_noone&quot;;
1958      case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: return &quot;wait_promotion&quot;;
1959      case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: return &quot;reconf_slaves&quot;;
1960      case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return &quot;update_config&quot;;
1961      default: return &quot;unknown&quot;;
1962      }
1963  }
1964  void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {
1965      char *flags = sdsempty();
1966      void *mbl;
1967      int fields = 0;
1968      mbl = addDeferredMultiBulkLength(c);
1969      addReplyBulkCString(c,&quot;name&quot;);
1970      addReplyBulkCString(c,ri-&gt;name);
1971      fields++;
1972      addReplyBulkCString(c,&quot;ip&quot;);
1973      addReplyBulkCString(c,ri-&gt;addr-&gt;ip);
1974      fields++;
1975      addReplyBulkCString(c,&quot;port&quot;);
1976      addReplyBulkLongLong(c,ri-&gt;addr-&gt;port);
1977      fields++;
1978      addReplyBulkCString(c,&quot;runid&quot;);
1979      addReplyBulkCString(c,ri-&gt;runid ? ri-&gt;runid : &quot;&quot;);
1980      fields++;
1981      addReplyBulkCString(c,&quot;flags&quot;);
1982      if (ri-&gt;flags &amp; SRI_S_DOWN) flags = sdscat(flags,&quot;s_down,&quot;);
1983      if (ri-&gt;flags &amp; SRI_O_DOWN) flags = sdscat(flags,&quot;o_down,&quot;);
1984      if (ri-&gt;flags &amp; SRI_MASTER) flags = sdscat(flags,&quot;master,&quot;);
1985      if (ri-&gt;flags &amp; SRI_SLAVE) flags = sdscat(flags,&quot;slave,&quot;);
1986      if (ri-&gt;flags &amp; SRI_SENTINEL) flags = sdscat(flags,&quot;sentinel,&quot;);
1987      if (ri-&gt;link-&gt;disconnected) flags = sdscat(flags,&quot;disconnected,&quot;);
1988      if (ri-&gt;flags &amp; SRI_MASTER_DOWN) flags = sdscat(flags,&quot;master_down,&quot;);
1989      if (ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS)
1990          flags = sdscat(flags,&quot;failover_in_progress,&quot;);
1991      if (ri-&gt;flags &amp; SRI_PROMOTED) flags = sdscat(flags,&quot;promoted,&quot;);
1992      if (ri-&gt;flags &amp; SRI_RECONF_SENT) flags = sdscat(flags,&quot;reconf_sent,&quot;);
1993      if (ri-&gt;flags &amp; SRI_RECONF_INPROG) flags = sdscat(flags,&quot;reconf_inprog,&quot;);
1994      if (ri-&gt;flags &amp; SRI_RECONF_DONE) flags = sdscat(flags,&quot;reconf_done,&quot;);
1995      if (sdslen(flags) != 0) sdsrange(flags,0,-2); &amp;bsol;* remove last &quot;,&quot; */
1996      addReplyBulkCString(c,flags);
1997      sdsfree(flags);
1998      fields++;
1999      addReplyBulkCString(c,&quot;link-pending-commands&quot;);
2000      addReplyBulkLongLong(c,ri-&gt;link-&gt;pending_commands);
2001      fields++;
2002      addReplyBulkCString(c,&quot;link-refcount&quot;);
2003      addReplyBulkLongLong(c,ri-&gt;link-&gt;refcount);
2004      fields++;
2005      if (ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) {
2006          addReplyBulkCString(c,&quot;failover-state&quot;);
2007          addReplyBulkCString(c,(char*)sentinelFailoverStateStr(ri-&gt;failover_state));
2008          fields++;
2009      }
2010      addReplyBulkCString(c,&quot;last-ping-sent&quot;);
2011      addReplyBulkLongLong(c,
2012          ri-&gt;link-&gt;act_ping_time ? (mstime() - ri-&gt;link-&gt;act_ping_time) : 0);
2013      fields++;
2014      addReplyBulkCString(c,&quot;last-ok-ping-reply&quot;);
2015      addReplyBulkLongLong(c,mstime() - ri-&gt;link-&gt;last_avail_time);
2016      fields++;
2017      addReplyBulkCString(c,&quot;last-ping-reply&quot;);
2018      addReplyBulkLongLong(c,mstime() - ri-&gt;link-&gt;last_pong_time);
2019      fields++;
2020      if (ri-&gt;flags &amp; SRI_S_DOWN) {
2021          addReplyBulkCString(c,&quot;s-down-time&quot;);
2022          addReplyBulkLongLong(c,mstime()-ri-&gt;s_down_since_time);
2023          fields++;
2024      }
2025      if (ri-&gt;flags &amp; SRI_O_DOWN) {
2026          addReplyBulkCString(c,&quot;o-down-time&quot;);
2027          addReplyBulkLongLong(c,mstime()-ri-&gt;o_down_since_time);
2028          fields++;
2029      }
2030      addReplyBulkCString(c,&quot;down-after-milliseconds&quot;);
2031      addReplyBulkLongLong(c,ri-&gt;down_after_period);
2032      fields++;
2033      if (ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) {
2034          addReplyBulkCString(c,&quot;info-refresh&quot;);
2035          addReplyBulkLongLong(c,mstime() - ri-&gt;info_refresh);
2036          fields++;
2037          addReplyBulkCString(c,&quot;role-reported&quot;);
2038          addReplyBulkCString(c, (ri-&gt;role_reported == SRI_MASTER) ? &quot;master&quot; :
2039                                                                     &quot;slave&quot;);
2040          fields++;
2041          addReplyBulkCString(c,&quot;role-reported-time&quot;);
2042          addReplyBulkLongLong(c,mstime() - ri-&gt;role_reported_time);
2043          fields++;
2044      }
2045      if (ri-&gt;flags &amp; SRI_MASTER) {
2046          addReplyBulkCString(c,&quot;config-epoch&quot;);
2047          addReplyBulkLongLong(c,ri-&gt;config_epoch);
2048          fields++;
2049          addReplyBulkCString(c,&quot;num-slaves&quot;);
2050          addReplyBulkLongLong(c,dictSize(ri-&gt;slaves));
2051          fields++;
2052          addReplyBulkCString(c,&quot;num-other-sentinels&quot;);
2053          addReplyBulkLongLong(c,dictSize(ri-&gt;sentinels));
2054          fields++;
2055          addReplyBulkCString(c,&quot;quorum&quot;);
2056          addReplyBulkLongLong(c,ri-&gt;quorum);
2057          fields++;
2058          addReplyBulkCString(c,&quot;failover-timeout&quot;);
2059          addReplyBulkLongLong(c,ri-&gt;failover_timeout);
2060          fields++;
2061          addReplyBulkCString(c,&quot;parallel-syncs&quot;);
2062          addReplyBulkLongLong(c,ri-&gt;parallel_syncs);
2063          fields++;
2064          if (ri-&gt;notification_script) {
2065              addReplyBulkCString(c,&quot;notification-script&quot;);
2066              addReplyBulkCString(c,ri-&gt;notification_script);
2067              fields++;
2068          }
2069          if (ri-&gt;client_reconfig_script) {
2070              addReplyBulkCString(c,&quot;client-reconfig-script&quot;);
2071              addReplyBulkCString(c,ri-&gt;client_reconfig_script);
2072              fields++;
2073          }
2074      }
2075      if (ri-&gt;flags &amp; SRI_SLAVE) {
2076          addReplyBulkCString(c,&quot;master-link-down-time&quot;);
2077          addReplyBulkLongLong(c,ri-&gt;master_link_down_time);
2078          fields++;
2079          addReplyBulkCString(c,&quot;master-link-status&quot;);
2080          addReplyBulkCString(c,
2081              (ri-&gt;slave_master_link_status == SENTINEL_MASTER_LINK_STATUS_UP) ?
2082              &quot;ok&quot; : &quot;err&quot;);
2083          fields++;
2084          addReplyBulkCString(c,&quot;master-host&quot;);
2085          addReplyBulkCString(c,
2086              ri-&gt;slave_master_host ? ri-&gt;slave_master_host : &quot;?&quot;);
2087          fields++;
2088          addReplyBulkCString(c,&quot;master-port&quot;);
2089          addReplyBulkLongLong(c,ri-&gt;slave_master_port);
2090          fields++;
2091          addReplyBulkCString(c,&quot;slave-priority&quot;);
2092          addReplyBulkLongLong(c,ri-&gt;slave_priority);
2093          fields++;
2094          addReplyBulkCString(c,&quot;slave-repl-offset&quot;);
2095          addReplyBulkLongLong(c,ri-&gt;slave_repl_offset);
2096          fields++;
2097      }
2098      if (ri-&gt;flags &amp; SRI_SENTINEL) {
2099          addReplyBulkCString(c,&quot;last-hello-message&quot;);
2100          addReplyBulkLongLong(c,mstime() - ri-&gt;last_hello_time);
2101          fields++;
2102          addReplyBulkCString(c,&quot;voted-leader&quot;);
2103          addReplyBulkCString(c,ri-&gt;leader ? ri-&gt;leader : &quot;?&quot;);
2104          fields++;
2105          addReplyBulkCString(c,&quot;voted-leader-epoch&quot;);
2106          addReplyBulkLongLong(c,ri-&gt;leader_epoch);
2107          fields++;
2108      }
2109      setDeferredMultiBulkLength(c,mbl,fields*2);
2110  }
2111  void addReplyDictOfRedisInstances(client *c, dict *instances) {
2112      dictIterator *di;
2113      dictEntry *de;
2114      di = dictGetIterator(instances);
2115      addReplyMultiBulkLen(c,(PORT_LONG)dictSize(instances));                   WIN_PORT_FIX &amp;bsol;* cast (PORT_LONG) */
2116      while((de = dictNext(di)) != NULL) {
2117          sentinelRedisInstance *ri = dictGetVal(de);
2118          addReplySentinelRedisInstance(c,ri);
2119      }
2120      dictReleaseIterator(di);
2121  }
2122  sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,
2123                          robj *name)
2124  {
2125      sentinelRedisInstance *ri;
2126      ri = dictFetchValue(sentinel.masters,name-&gt;ptr);
2127      if (!ri) {
2128          addReplyError(c,&quot;No such master with that name&quot;);
2129          return NULL;
2130      }
2131      return ri;
2132  }
2133  #define SENTINEL_ISQR_OK 0
2134  #define SENTINEL_ISQR_NOQUORUM (1&lt;&lt;0)
2135  #define SENTINEL_ISQR_NOAUTH (1&lt;&lt;1)
2136  int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {
2137      dictIterator *di;
2138      dictEntry *de;
2139      int usable = 1; &amp;bsol;* Number of usable Sentinels. Init to 1 to count myself. */
2140      int result = SENTINEL_ISQR_OK;
2141      int voters = (int)dictSize(master-&gt;sentinels)+1; &amp;bsol;* Known Sentinels + myself. */ WIN_PORT_FIX &amp;bsol;* cast (int) */
2142      di = dictGetIterator(master-&gt;sentinels);
2143      while((de = dictNext(di)) != NULL) {
2144          sentinelRedisInstance *ri = dictGetVal(de);
2145          if (ri-&gt;flags &amp; (SRI_S_DOWN|SRI_O_DOWN)) continue;
2146          usable++;
2147      }
2148      dictReleaseIterator(di);
2149      if (usable &lt; (int)master-&gt;quorum) result |= SENTINEL_ISQR_NOQUORUM;
2150      if (usable &lt; voters/2+1) result |= SENTINEL_ISQR_NOAUTH;
2151      if (usableptr) *usableptr = usable;
2152      return result;
2153  }
2154  void sentinelCommand(client *c) {
2155      if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;masters&quot;)) {
2156          if (c-&gt;argc != 2) goto numargserr;
2157          addReplyDictOfRedisInstances(c,sentinel.masters);
2158      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;master&quot;)) {
2159          sentinelRedisInstance *ri;
2160          if (c-&gt;argc != 3) goto numargserr;
2161          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2]))
2162              == NULL) return;
2163          addReplySentinelRedisInstance(c,ri);
2164      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;slaves&quot;) ||
2165                 !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;replicas&quot;))
2166      {
2167          sentinelRedisInstance *ri;
2168          if (c-&gt;argc != 3) goto numargserr;
2169          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2])) == NULL)
2170              return;
2171          addReplyDictOfRedisInstances(c,ri-&gt;slaves);
2172      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;sentinels&quot;)) {
2173          sentinelRedisInstance *ri;
2174          if (c-&gt;argc != 3) goto numargserr;
2175          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2])) == NULL)
2176              return;
2177          addReplyDictOfRedisInstances(c,ri-&gt;sentinels);
2178      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;is-master-down-by-addr&quot;)) {
2179          sentinelRedisInstance *ri;
2180          PORT_LONGLONG req_epoch;
2181          uint64_t leader_epoch = 0;
2182          char *leader = NULL;
2183          PORT_LONG port;
2184          int isdown = 0;
2185          if (c-&gt;argc != 6) goto numargserr;
2186          if (getLongFromObjectOrReply(c,c-&gt;argv[3],&amp;port,NULL) != C_OK ||
2187              getLongLongFromObjectOrReply(c,c-&gt;argv[4],&amp;req_epoch,NULL)
2188                                                                != C_OK)
2189              return;
2190          ri = getSentinelRedisInstanceByAddrAndRunID(sentinel.masters,
2191              c-&gt;argv[2]-&gt;ptr,(int)port,NULL);                                 WIN_PORT_FIX &amp;bsol;* cast (int) */
2192          if (!sentinel.tilt &amp;&amp; ri &amp;&amp; (ri-&gt;flags &amp; SRI_S_DOWN) &amp;&amp;
2193                                      (ri-&gt;flags &amp; SRI_MASTER))
2194              isdown = 1;
2195          if (ri &amp;&amp; ri-&gt;flags &amp; SRI_MASTER &amp;&amp; strcasecmp(c-&gt;argv[5]-&gt;ptr,&quot;*&quot;)) {
2196              leader = sentinelVoteLeader(ri,(uint64_t)req_epoch,
2197                                              c-&gt;argv[5]-&gt;ptr,
2198                                              &amp;leader_epoch);
2199          }
2200          addReplyMultiBulkLen(c,3);
2201          addReply(c, isdown ? shared.cone : shared.czero);
2202          addReplyBulkCString(c, leader ? leader : &quot;*&quot;);
2203          addReplyLongLong(c, (PORT_LONGLONG)leader_epoch);
2204          if (leader) sdsfree(leader);
2205      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;reset&quot;)) {
2206          if (c-&gt;argc != 3) goto numargserr;
2207          addReplyLongLong(c,sentinelResetMastersByPattern(c-&gt;argv[2]-&gt;ptr,SENTINEL_GENERATE_EVENT));
2208      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;get-master-addr-by-name&quot;)) {
2209          sentinelRedisInstance *ri;
2210          if (c-&gt;argc != 3) goto numargserr;
2211          ri = sentinelGetMasterByName(c-&gt;argv[2]-&gt;ptr);
2212          if (ri == NULL) {
2213              addReply(c,shared.nullmultibulk);
2214          } else {
2215              sentinelAddr *addr = sentinelGetCurrentMasterAddress(ri);
2216              addReplyMultiBulkLen(c,2);
2217              addReplyBulkCString(c,addr-&gt;ip);
2218              addReplyBulkLongLong(c,addr-&gt;port);
2219          }
2220      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;failover&quot;)) {
2221          sentinelRedisInstance *ri;
2222          if (c-&gt;argc != 3) goto numargserr;
2223          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2])) == NULL)
2224              return;
2225          if (ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) {
2226              addReplySds(c,sdsnew(&quot;-INPROG Failover already in progress\r\n&quot;));
2227              return;
2228          }
2229          if (sentinelSelectSlave(ri) == NULL) {
2230              addReplySds(c,sdsnew(&quot;-NOGOODSLAVE No suitable replica to promote\r\n&quot;));
2231              return;
2232          }
2233          serverLog(LL_WARNING,&quot;Executing user requested FAILOVER of &#x27;%s&#x27;&quot;,
2234              ri-&gt;name);
2235          sentinelStartFailover(ri);
2236          ri-&gt;flags |= SRI_FORCE_FAILOVER;
2237          addReply(c,shared.ok);
2238      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;pending-scripts&quot;)) {
2239          if (c-&gt;argc != 2) goto numargserr;
2240          sentinelPendingScriptsCommand(c);
2241      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;monitor&quot;)) {
2242          sentinelRedisInstance *ri;
2243          PORT_LONG quorum, port;
2244          char ip[NET_IP_STR_LEN];
2245          if (c-&gt;argc != 6) goto numargserr;
2246          if (getLongFromObjectOrReply(c,c-&gt;argv[5],&amp;quorum,&quot;Invalid quorum&quot;)
2247              != C_OK) return;
2248          if (getLongFromObjectOrReply(c,c-&gt;argv[4],&amp;port,&quot;Invalid port&quot;)
2249              != C_OK) return;
2250          if (quorum &lt;= 0) {
2251              addReplyError(c, &quot;Quorum must be 1 or greater.&quot;);
2252              return;
2253          }
2254          if (anetResolveIP(NULL,c-&gt;argv[3]-&gt;ptr,ip,sizeof(ip)) == ANET_ERR) {
2255              addReplyError(c,&quot;Invalid IP address specified&quot;);
2256              return;
2257          }
2258          ri = createSentinelRedisInstance(c-&gt;argv[2]-&gt;ptr,SRI_MASTER,
2259                  c-&gt;argv[3]-&gt;ptr,(int)port,(int)quorum,NULL);                    WIN_PORT_FIX &amp;bsol;* cast (int) */
2260          if (ri == NULL) {
2261              switch(errno) {
2262              case EBUSY:
2263                  addReplyError(c,&quot;Duplicated master name&quot;);
2264                  break;
2265              case EINVAL:
2266                  addReplyError(c,&quot;Invalid port number&quot;);
2267                  break;
2268              default:
2269                  addReplyError(c,&quot;Unspecified error adding the instance&quot;);
2270                  break;
2271              }
2272          } else {
2273              sentinelFlushConfig();
2274              sentinelEvent(LL_WARNING,&quot;+monitor&quot;,ri,&quot;%@ quorum %d&quot;,ri-&gt;quorum);
2275              addReply(c,shared.ok);
2276          }
2277      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;flushconfig&quot;)) {
2278          if (c-&gt;argc != 2) goto numargserr;
2279          sentinelFlushConfig();
2280          addReply(c,shared.ok);
2281          return;
2282      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;remove&quot;)) {
2283          sentinelRedisInstance *ri;
2284          if (c-&gt;argc != 3) goto numargserr;
2285          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2]))
2286              == NULL) return;
2287          sentinelEvent(LL_WARNING,&quot;-monitor&quot;,ri,&quot;%@&quot;);
2288          dictDelete(sentinel.masters,c-&gt;argv[2]-&gt;ptr);
2289          sentinelFlushConfig();
2290          addReply(c,shared.ok);
2291      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;ckquorum&quot;)) {
2292          sentinelRedisInstance *ri;
2293          int usable;
2294          if (c-&gt;argc != 3) goto numargserr;
2295          if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2]))
2296              == NULL) return;
2297          int result = sentinelIsQuorumReachable(ri,&amp;usable);
2298          if (result == SENTINEL_ISQR_OK) {
2299              addReplySds(c, sdscatfmt(sdsempty(),
2300                  &quot;+OK %i usable Sentinels. Quorum and failover authorization &quot;
2301                  &quot;can be reached\r\n&quot;,usable));
2302          } else {
2303              sds e = sdscatfmt(sdsempty(),
2304                  &quot;-NOQUORUM %i usable Sentinels. &quot;,usable);
2305              if (result &amp; SENTINEL_ISQR_NOQUORUM)
2306                  e = sdscat(e,&quot;Not enough available Sentinels to reach the&quot;
2307                               &quot; specified quorum for this master&quot;);
2308              if (result &amp; SENTINEL_ISQR_NOAUTH) {
2309                  if (result &amp; SENTINEL_ISQR_NOQUORUM) e = sdscat(e,&quot;. &quot;);
2310                  e = sdscat(e, &quot;Not enough available Sentinels to reach the&quot;
2311                                &quot; majority and authorize a failover&quot;);
2312              }
2313              e = sdscat(e,&quot;\r\n&quot;);
2314              addReplySds(c,e);
2315          }
2316      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;set&quot;)) {
2317          if (c-&gt;argc &lt; 3) goto numargserr;
2318          sentinelSetCommand(c);
2319      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;info-cache&quot;)) {
2320          if (c-&gt;argc &lt; 2) goto numargserr;
2321          mstime_t now = mstime();
2322          dictType copy_keeper = instancesDictType;
2323          copy_keeper.valDestructor = NULL;
2324          dict *masters_local = sentinel.masters;
2325          if (c-&gt;argc &gt; 2) {
2326              masters_local = dictCreate(&amp;copy_keeper, NULL);
2327              for (int i = 2; i &lt; c-&gt;argc; i++) {
2328                  sentinelRedisInstance *ri;
2329                  ri = sentinelGetMasterByName(c-&gt;argv[i]-&gt;ptr);
2330                  if (!ri) continue; &amp;bsol;* ignore non-existing names */
2331                  dictAdd(masters_local, ri-&gt;name, ri);
2332              }
2333          }
2334          addReplyMultiBulkLen(c,dictSize(masters_local) * 2);
2335          dictIterator  *di;
2336          dictEntry *de;
2337          di = dictGetIterator(masters_local);
2338          while ((de = dictNext(di)) != NULL) {
2339              sentinelRedisInstance *ri = dictGetVal(de);
2340              addReplyBulkCBuffer(c,ri-&gt;name,strlen(ri-&gt;name));
2341              addReplyMultiBulkLen(c,dictSize(ri-&gt;slaves) + 1); &amp;bsol;* +1 for self */
2342              addReplyMultiBulkLen(c,2);
2343              addReplyLongLong(c, now - ri-&gt;info_refresh);
2344              if (ri-&gt;info)
2345                  addReplyBulkCBuffer(c,ri-&gt;info,sdslen(ri-&gt;info));
2346              else
2347                  addReply(c,shared.nullbulk);
2348              dictIterator *sdi;
2349              dictEntry *sde;
2350              sdi = dictGetIterator(ri-&gt;slaves);
2351              while ((sde = dictNext(sdi)) != NULL) {
2352                  sentinelRedisInstance *sri = dictGetVal(sde);
2353                  addReplyMultiBulkLen(c,2);
2354                  addReplyLongLong(c, now - sri-&gt;info_refresh);
2355                  if (sri-&gt;info)
2356                      addReplyBulkCBuffer(c,sri-&gt;info,sdslen(sri-&gt;info));
2357                  else
2358                      addReply(c,shared.nullbulk);
2359              }
2360              dictReleaseIterator(sdi);
2361          }
2362          dictReleaseIterator(di);
2363          if (masters_local != sentinel.masters) dictRelease(masters_local);
2364      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;simulate-failure&quot;)) {
2365          int j;
2366          sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
2367          for (j = 2; j &lt; c-&gt;argc; j++) {
2368              if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;crash-after-election&quot;)) {
2369                  sentinel.simfailure_flags |=
2370                      SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION;
2371                  serverLog(LL_WARNING,&quot;Failure simulation: this Sentinel &quot;
2372                      &quot;will crash after being successfully elected as failover &quot;
2373                      &quot;leader&quot;);
2374              } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;crash-after-promotion&quot;)) {
2375                  sentinel.simfailure_flags |=
2376                      SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION;
2377                  serverLog(LL_WARNING,&quot;Failure simulation: this Sentinel &quot;
2378                      &quot;will crash after promoting the selected replica to master&quot;);
2379              } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;help&quot;)) {
2380                  addReplyMultiBulkLen(c,2);
2381                  addReplyBulkCString(c,&quot;crash-after-election&quot;);
2382                  addReplyBulkCString(c,&quot;crash-after-promotion&quot;);
2383              } else {
2384                  addReplyError(c,&quot;Unknown failure simulation specified&quot;);
2385                  return;
2386              }
2387          }
2388          addReply(c,shared.ok);
2389      } else {
2390          addReplyErrorFormat(c,&quot;Unknown sentinel subcommand &#x27;%s&#x27;&quot;,
2391                                 (char*)c-&gt;argv[1]-&gt;ptr);
2392      }
2393      return;
2394  numargserr:
2395      addReplyErrorFormat(c,&quot;Wrong number of arguments for &#x27;sentinel %s&#x27;&quot;,
2396                            (char*)c-&gt;argv[1]-&gt;ptr);
2397  }
2398  #define info_section_from_redis(section_name) do { \
2399      if (defsections || allsections || !strcasecmp(section,section_name)) { \
2400          sds redissection; \
2401          if (sections++) info = sdscat(info,&quot;\r\n&quot;); \
2402          redissection = genRedisInfoString(section_name); \
2403          info = sdscatlen(info,redissection,sdslen(redissection)); \
2404          sdsfree(redissection); \
2405      } \
2406  } while(0)
2407  void sentinelInfoCommand(client *c) {
2408      if (c-&gt;argc &gt; 2) {
2409          addReply(c,shared.syntaxerr);
2410          return;
2411      }
2412      int defsections = 0, allsections = 0;
2413      char *section = c-&gt;argc == 2 ? c-&gt;argv[1]-&gt;ptr : NULL;
2414      if (section) {
2415          allsections = !strcasecmp(section,&quot;all&quot;);
2416          defsections = !strcasecmp(section,&quot;default&quot;);
2417      } else {
2418          defsections = 1;
2419      }
2420      int sections = 0;
2421      sds info = sdsempty();
2422      info_section_from_redis(&quot;server&quot;);
2423      info_section_from_redis(&quot;clients&quot;);
2424      info_section_from_redis(&quot;cpu&quot;);
2425      info_section_from_redis(&quot;stats&quot;);
2426      if (defsections || allsections || !strcasecmp(section,&quot;sentinel&quot;)) {
2427          dictIterator *di;
2428          dictEntry *de;
2429          int master_id = 0;
2430          if (sections++) info = sdscat(info,&quot;\r\n&quot;);
2431          info = sdscatprintf(info,
2432              &quot;# Sentinel\r\n&quot;
2433              &quot;sentinel_masters:%Iu\r\n&quot;                                          WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
2434              &quot;sentinel_tilt:%d\r\n&quot;
2435              &quot;sentinel_running_scripts:%d\r\n&quot;
2436              &quot;sentinel_scripts_queue_length:%Id\r\n&quot;                             WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
2437              &quot;sentinel_simulate_failure_flags:%Iu\r\n&quot;,                          WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
2438              dictSize(sentinel.masters),
2439              sentinel.tilt,
2440              sentinel.running_scripts,
2441              listLength(sentinel.scripts_queue),
2442              sentinel.simfailure_flags);
2443          di = dictGetIterator(sentinel.masters);
2444          while((de = dictNext(di)) != NULL) {
2445              sentinelRedisInstance *ri = dictGetVal(de);
2446              char *status = &quot;ok&quot;;
2447              if (ri-&gt;flags &amp; SRI_O_DOWN) status = &quot;odown&quot;;
2448              else if (ri-&gt;flags &amp; SRI_S_DOWN) status = &quot;sdown&quot;;
2449              info = sdscatprintf(info,
2450                  &quot;master%d:name=%s,status=%s,address=%s:%d,&quot;
2451                  &quot;slaves=%Iu,sentinels=%Iu\r\n&quot;,                                 WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
2452                  master_id++, ri-&gt;name, status,
2453                  ri-&gt;addr-&gt;ip, ri-&gt;addr-&gt;port,
2454                  dictSize(ri-&gt;slaves),
2455                  dictSize(ri-&gt;sentinels)+1);
2456          }
2457          dictReleaseIterator(di);
2458      }
2459      addReplyBulkSds(c, info);
2460  }
2461  void sentinelRoleCommand(client *c) {
2462      dictIterator *di;
2463      dictEntry *de;
2464      addReplyMultiBulkLen(c,2);
2465      addReplyBulkCBuffer(c,&quot;sentinel&quot;,8);
2466      addReplyMultiBulkLen(c,(PORT_LONG)dictSize(sentinel.masters));
2467      di = dictGetIterator(sentinel.masters);
2468      while((de = dictNext(di)) != NULL) {
2469          sentinelRedisInstance *ri = dictGetVal(de);
2470          addReplyBulkCString(c,ri-&gt;name);
2471      }
2472      dictReleaseIterator(di);
2473  }
2474  void sentinelSetCommand(client *c) {
2475      sentinelRedisInstance *ri;
2476      int j, changes = 0;
2477      int badarg = 0; &amp;bsol;* Bad argument position for error reporting. */
2478      char *option;
2479      if ((ri = sentinelGetMasterByNameOrReplyError(c,c-&gt;argv[2]))
2480          == NULL) return;
2481      for (j = 3; j &lt; c-&gt;argc; j++) {
2482          int moreargs = (c-&gt;argc-1) - j;
2483          option = c-&gt;argv[j]-&gt;ptr;
2484          PORT_LONGLONG ll;
2485          int old_j = j; &amp;bsol;* Used to know what to log as an event. */
2486          if (!strcasecmp(option,&quot;down-after-milliseconds&quot;) &amp;&amp; moreargs &gt; 0) {
2487              robj *o = c-&gt;argv[++j];
2488              if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt;= 0) {
2489                  badarg = j;
2490                  goto badfmt;
2491              }
2492              ri-&gt;down_after_period = ll;
2493              sentinelPropagateDownAfterPeriod(ri);
2494              changes++;
2495          } else if (!strcasecmp(option,&quot;failover-timeout&quot;) &amp;&amp; moreargs &gt; 0) {
2496              robj *o = c-&gt;argv[++j];
2497              if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt;= 0) {
2498                  badarg = j;
2499                  goto badfmt;
2500              }
2501              ri-&gt;failover_timeout = ll;
2502              changes++;
2503          } else if (!strcasecmp(option,&quot;parallel-syncs&quot;) &amp;&amp; moreargs &gt; 0) {
2504              robj *o = c-&gt;argv[++j];
2505              if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt;= 0) {
2506                  badarg = j;
2507                  goto badfmt;
2508              }
2509              ri-&gt;parallel_syncs = ll;
2510              changes++;
2511          } else if (!strcasecmp(option,&quot;notification-script&quot;) &amp;&amp; moreargs &gt; 0) {
2512              char *value = c-&gt;argv[++j]-&gt;ptr;
2513              if (sentinel.deny_scripts_reconfig) {
2514                  addReplyError(c,
2515                      &quot;Reconfiguration of scripts path is denied for &quot;
2516                      &quot;security reasons. Check the deny-scripts-reconfig &quot;
2517                      &quot;configuration directive in your Sentinel configuration&quot;);
2518                  return;
2519              }
2520              if (strlen(value) &amp;&amp; access(value,X_OK) == -1) {
2521                  addReplyError(c,
2522                      &quot;Notification script seems non existing or non executable&quot;);
2523                  if (changes) sentinelFlushConfig();
2524                  return;
2525              }
2526              sdsfree(ri-&gt;notification_script);
2527              ri-&gt;notification_script = strlen(value) ? sdsnew(value) : NULL;
2528              changes++;
2529          } else if (!strcasecmp(option,&quot;client-reconfig-script&quot;) &amp;&amp; moreargs &gt; 0) {
2530              char *value = c-&gt;argv[++j]-&gt;ptr;
2531              if (sentinel.deny_scripts_reconfig) {
2532                  addReplyError(c,
2533                      &quot;Reconfiguration of scripts path is denied for &quot;
2534                      &quot;security reasons. Check the deny-scripts-reconfig &quot;
2535                      &quot;configuration directive in your Sentinel configuration&quot;);
2536                  return;
2537              }
2538              if (strlen(value) &amp;&amp; access(value,X_OK) == -1) {
2539                  addReplyError(c,
2540                      &quot;Client reconfiguration script seems non existing or &quot;
2541                      &quot;non executable&quot;);
2542                  if (changes) sentinelFlushConfig();
2543                  return;
2544              }
2545              sdsfree(ri-&gt;client_reconfig_script);
2546              ri-&gt;client_reconfig_script = strlen(value) ? sdsnew(value) : NULL;
2547              changes++;
2548          } else if (!strcasecmp(option,&quot;auth-pass&quot;) &amp;&amp; moreargs &gt; 0) {
2549              char *value = c-&gt;argv[++j]-&gt;ptr;
2550              sdsfree(ri-&gt;auth_pass);
2551              ri-&gt;auth_pass = strlen(value) ? sdsnew(value) : NULL;
2552              changes++;
2553          } else if (!strcasecmp(option,&quot;quorum&quot;) &amp;&amp; moreargs &gt; 0) {
2554              robj *o = c-&gt;argv[++j];
2555              if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt;= 0) {
2556                  badarg = j;
2557                  goto badfmt;
2558              }
2559              ri-&gt;quorum = ll;
2560              changes++;
2561          } else if (!strcasecmp(option,&quot;rename-command&quot;) &amp;&amp; moreargs &gt; 1) {
2562              sds oldname = c-&gt;argv[++j]-&gt;ptr;
2563              sds newname = c-&gt;argv[++j]-&gt;ptr;
2564              if ((sdslen(oldname) == 0) || (sdslen(newname) == 0)) {
2565                  badarg = sdslen(newname) ? j-1 : j;
2566                  goto badfmt;
2567              }
2568              dictDelete(ri-&gt;renamed_commands,oldname);
2569              if (!dictSdsKeyCaseCompare(NULL,oldname,newname)) {
2570                  oldname = sdsdup(oldname);
2571                  newname = sdsdup(newname);
2572                  dictAdd(ri-&gt;renamed_commands,oldname,newname);
2573              }
2574              changes++;
2575          } else {
2576              addReplyErrorFormat(c,&quot;Unknown option or number of arguments for &quot;
2577                                    &quot;SENTINEL SET &#x27;%s&#x27;&quot;, option);
2578              if (changes) sentinelFlushConfig();
2579              return;
2580          }
2581          int numargs = j-old_j+1;
2582          switch(numargs) {
2583          case 2:
2584              sentinelEvent(LL_WARNING,&quot;+set&quot;,ri,&quot;%@ %s %s&quot;,c-&gt;argv[old_j]-&gt;ptr,
2585                                                            c-&gt;argv[old_j+1]-&gt;ptr);
2586              break;
2587          case 3:
2588              sentinelEvent(LL_WARNING,&quot;+set&quot;,ri,&quot;%@ %s %s %s&quot;,c-&gt;argv[old_j]-&gt;ptr,
2589                                                               c-&gt;argv[old_j+1]-&gt;ptr,
2590                                                               c-&gt;argv[old_j+2]-&gt;ptr);
2591              break;
2592          default:
2593              sentinelEvent(LL_WARNING,&quot;+set&quot;,ri,&quot;%@ %s&quot;,c-&gt;argv[old_j]-&gt;ptr);
2594              break;
2595          }
2596      }
2597      if (changes) sentinelFlushConfig();
2598      addReply(c,shared.ok);
2599      return;
2600  badfmt: &amp;bsol;* Bad format errors */
2601      if (changes) sentinelFlushConfig();
2602      addReplyErrorFormat(c,&quot;Invalid argument &#x27;%s&#x27; for SENTINEL SET &#x27;%s&#x27;&quot;,
2603          (char*)c-&gt;argv[badarg]-&gt;ptr,option);
2604  }
2605  void sentinelPublishCommand(client *c) {
2606      if (strcmp(c-&gt;argv[1]-&gt;ptr,SENTINEL_HELLO_CHANNEL)) {
2607          addReplyError(c, &quot;Only HELLO messages are accepted by Sentinel instances.&quot;);
2608          return;
2609      }
2610      sentinelProcessHelloMessage(c-&gt;argv[2]-&gt;ptr,(int)sdslen(c-&gt;argv[2]-&gt;ptr));  WIN_PORT_FIX &amp;bsol;* cast (int) */
2611      addReplyLongLong(c,1);
2612  }
2613  void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
2614      mstime_t elapsed = 0;
2615      if (ri-&gt;link-&gt;act_ping_time)
2616          elapsed = mstime() - ri-&gt;link-&gt;act_ping_time;
2617      else if (ri-&gt;link-&gt;disconnected)
2618          elapsed = mstime() - ri-&gt;link-&gt;last_avail_time;
2619      if (ri-&gt;link-&gt;cc &amp;&amp;
2620          (mstime() - ri-&gt;link-&gt;cc_conn_time) &gt;
2621          SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp;
2622          ri-&gt;link-&gt;act_ping_time != 0 &amp;&amp; &amp;bsol;* There is a pending ping... */
2623          (mstime() - ri-&gt;link-&gt;act_ping_time) &gt; (ri-&gt;down_after_period/2) &amp;&amp;
2624          (mstime() - ri-&gt;link-&gt;last_pong_time) &gt; (ri-&gt;down_after_period/2))
2625      {
2626          instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;cc);
2627      }
2628      if (ri-&gt;link-&gt;pc &amp;&amp;
2629          (mstime() - ri-&gt;link-&gt;pc_conn_time) &gt;
2630           SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp;
2631          (mstime() - ri-&gt;link-&gt;pc_last_activity) &gt; (SENTINEL_PUBLISH_PERIOD*3))
2632      {
2633          instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;pc);
2634      }
2635      if (elapsed &gt; ri-&gt;down_after_period ||
2636          (ri-&gt;flags &amp; SRI_MASTER &amp;&amp;
2637           ri-&gt;role_reported == SRI_SLAVE &amp;&amp;
2638           mstime() - ri-&gt;role_reported_time &gt;
2639            (ri-&gt;down_after_period+SENTINEL_INFO_PERIOD*2)))
2640      {
2641          if ((ri-&gt;flags &amp; SRI_S_DOWN) == 0) {
2642              sentinelEvent(LL_WARNING,&quot;+sdown&quot;,ri,&quot;%@&quot;);
2643              ri-&gt;s_down_since_time = mstime();
2644              ri-&gt;flags |= SRI_S_DOWN;
2645          }
2646      } else {
2647          if (ri-&gt;flags &amp; SRI_S_DOWN) {
2648              sentinelEvent(LL_WARNING,&quot;-sdown&quot;,ri,&quot;%@&quot;);
2649              ri-&gt;flags &amp;= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);
2650          }
2651      }
2652  }
2653  void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
2654      dictIterator *di;
2655      dictEntry *de;
2656      unsigned int quorum = 0, odown = 0;
2657      if (master-&gt;flags &amp; SRI_S_DOWN) {
2658          quorum = 1; &amp;bsol;* the current sentinel. */
2659          di = dictGetIterator(master-&gt;sentinels);
2660          while((de = dictNext(di)) != NULL) {
2661              sentinelRedisInstance *ri = dictGetVal(de);
2662              if (ri-&gt;flags &amp; SRI_MASTER_DOWN) quorum++;
2663          }
2664          dictReleaseIterator(di);
2665          if (quorum &gt;= master-&gt;quorum) odown = 1;
2666      }
2667      if (odown) {
2668          if ((master-&gt;flags &amp; SRI_O_DOWN) == 0) {
2669              sentinelEvent(LL_WARNING,&quot;+odown&quot;,master,&quot;%@ #quorum %d/%d&quot;,
2670                  quorum, master-&gt;quorum);
2671              master-&gt;flags |= SRI_O_DOWN;
2672              master-&gt;o_down_since_time = mstime();
2673          }
2674      } else {
2675          if (master-&gt;flags &amp; SRI_O_DOWN) {
2676              sentinelEvent(LL_WARNING,&quot;-odown&quot;,master,&quot;%@&quot;);
2677              master-&gt;flags &amp;= ~SRI_O_DOWN;
2678          }
2679      }
2680  }
2681  void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {
2682      sentinelRedisInstance *ri = privdata;
2683      instanceLink *link = c-&gt;data;
2684      redisReply *r;
2685      if (!reply || !link) return;
2686      link-&gt;pending_commands--;
2687      r = reply;
2688      if (r-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; r-&gt;elements == 3 &amp;&amp;
2689          r-&gt;element[0]-&gt;type == REDIS_REPLY_INTEGER &amp;&amp;
2690          r-&gt;element[1]-&gt;type == REDIS_REPLY_STRING &amp;&amp;
2691          r-&gt;element[2]-&gt;type == REDIS_REPLY_INTEGER)
2692      {
2693          ri-&gt;last_master_down_reply_time = mstime();
2694          if (r-&gt;element[0]-&gt;integer == 1) {
2695              ri-&gt;flags |= SRI_MASTER_DOWN;
2696          } else {
2697              ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;
2698          }
2699          if (strcmp(r-&gt;element[1]-&gt;str,&quot;*&quot;)) {
2700              sdsfree(ri-&gt;leader);
2701              if ((PORT_LONGLONG)ri-&gt;leader_epoch != r-&gt;element[2]-&gt;integer)
2702                  serverLog(LL_WARNING,
2703                      &quot;%s voted for %s %llu&quot;, ri-&gt;name,
2704                      r-&gt;element[1]-&gt;str,
2705                      (PORT_ULONGLONG) r-&gt;element[2]-&gt;integer);
2706              ri-&gt;leader = sdsnew(r-&gt;element[1]-&gt;str);
2707              ri-&gt;leader_epoch = r-&gt;element[2]-&gt;integer;
2708          }
2709      }
2710  }
2711  #define SENTINEL_ASK_FORCED (1&lt;&lt;0)
2712  void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {
2713      dictIterator *di;
2714      dictEntry *de;
2715      di = dictGetIterator(master-&gt;sentinels);
2716      while((de = dictNext(di)) != NULL) {
2717          sentinelRedisInstance *ri = dictGetVal(de);
2718          mstime_t elapsed = mstime() - ri-&gt;last_master_down_reply_time;
2719          char port[32];
2720          int retval;
2721          if (elapsed &gt; SENTINEL_ASK_PERIOD*5) {
2722              ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;
2723              sdsfree(ri-&gt;leader);
2724              ri-&gt;leader = NULL;
2725          }
2726          if ((master-&gt;flags &amp; SRI_S_DOWN) == 0) continue;
2727          if (ri-&gt;link-&gt;disconnected) continue;
2728          if (!(flags &amp; SENTINEL_ASK_FORCED) &amp;&amp;
2729              mstime() - ri-&gt;last_master_down_reply_time &lt; SENTINEL_ASK_PERIOD)
2730              continue;
2731          ll2string(port,sizeof(port),master-&gt;addr-&gt;port);
2732          retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2733                      sentinelReceiveIsMasterDownReply, ri,
2734                      &quot;%s is-master-down-by-addr %s %s %llu %s&quot;,
2735                      sentinelInstanceMapCommand(ri,&quot;SENTINEL&quot;),
2736                      master-&gt;addr-&gt;ip, port,
2737                      sentinel.current_epoch,
2738                      (master-&gt;failover_state &gt; SENTINEL_FAILOVER_STATE_NONE) ?
2739                      sentinel.myid : &quot;*&quot;);
2740          if (retval == C_OK) ri-&gt;link-&gt;pending_commands++;
2741      }
2742      dictReleaseIterator(di);
2743  }
2744  void sentinelSimFailureCrash(void) {
2745      serverLog(LL_WARNING,
2746          &quot;Sentinel CRASH because of SENTINEL simulate-failure&quot;);
2747      exit(99);
2748  }
2749  char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {
2750      if (req_epoch &gt; sentinel.current_epoch) {
2751          sentinel.current_epoch = req_epoch;
2752          sentinelFlushConfig();
2753          sentinelEvent(LL_WARNING,&quot;+new-epoch&quot;,master,&quot;%llu&quot;,
2754              (PORT_ULONGLONG) sentinel.current_epoch);
2755      }
2756      if (master-&gt;leader_epoch &lt; req_epoch &amp;&amp; sentinel.current_epoch &lt;= req_epoch)
2757      {
2758          sdsfree(master-&gt;leader);
2759          master-&gt;leader = sdsnew(req_runid);
2760          master-&gt;leader_epoch = sentinel.current_epoch;
2761          sentinelFlushConfig();
2762          sentinelEvent(LL_WARNING,&quot;+vote-for-leader&quot;,master,&quot;%s %llu&quot;,
2763              master-&gt;leader, (PORT_ULONGLONG) master-&gt;leader_epoch);
2764          if (strcasecmp(master-&gt;leader,sentinel.myid))
2765              master-&gt;failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
2766      }
2767      *leader_epoch = master-&gt;leader_epoch;
2768      return master-&gt;leader ? sdsnew(master-&gt;leader) : NULL;
2769  }
2770  struct sentinelLeader {
2771      char *runid;
2772      PORT_ULONG votes;
2773  };
2774  int sentinelLeaderIncr(dict *counters, char *runid) {
2775      dictEntry *existing, *de;
2776      uint64_t oldval;
2777      de = dictAddRaw(counters,runid,&amp;existing);
2778      if (existing) {
2779          oldval = dictGetUnsignedIntegerVal(existing);
2780          dictSetUnsignedIntegerVal(existing,oldval+1);
2781          return (int)oldval+1;                                                   WIN_PORT_FIX &amp;bsol;* cast (int) */
2782      } else {
2783          serverAssert(de != NULL);
2784          dictSetUnsignedIntegerVal(de,1);
2785          return 1;
2786      }
2787  }
2788  char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
2789      dict *counters;
2790      dictIterator *di;
2791      dictEntry *de;
2792      unsigned int voters = 0, voters_quorum;
2793      char *myvote;
2794      char *winner = NULL;
2795      uint64_t leader_epoch;
2796      uint64_t max_votes = 0;
2797      serverAssert(master-&gt;flags &amp; (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));
2798      counters = dictCreate(&amp;leaderVotesDictType,NULL);
2799      voters = (unsigned int)dictSize(master-&gt;sentinels)+1; &amp;bsol;* All the other sentinels and me.*/  WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
2800      di = dictGetIterator(master-&gt;sentinels);
2801      while((de = dictNext(di)) != NULL) {
2802          sentinelRedisInstance *ri = dictGetVal(de);
2803          if (ri-&gt;leader != NULL &amp;&amp; ri-&gt;leader_epoch == sentinel.current_epoch)
2804              sentinelLeaderIncr(counters,ri-&gt;leader);
2805      }
2806      dictReleaseIterator(di);
2807      di = dictGetIterator(counters);
2808      while((de = dictNext(di)) != NULL) {
2809          uint64_t votes = dictGetUnsignedIntegerVal(de);
2810          if (votes &gt; max_votes) {
2811              max_votes = votes;
2812              winner = dictGetKey(de);
2813          }
2814      }
2815      dictReleaseIterator(di);
2816      if (winner)
2817          myvote = sentinelVoteLeader(master,epoch,winner,&amp;leader_epoch);
2818      else
2819          myvote = sentinelVoteLeader(master,epoch,sentinel.myid,&amp;leader_epoch);
2820      if (myvote &amp;&amp; leader_epoch == epoch) {
2821          uint64_t votes = sentinelLeaderIncr(counters,myvote);
2822          if (votes &gt; max_votes) {
2823              max_votes = votes;
2824              winner = myvote;
2825          }
2826      }
2827      voters_quorum = voters/2+1;
2828      if (winner &amp;&amp; (max_votes &lt; voters_quorum || max_votes &lt; master-&gt;quorum))
2829          winner = NULL;
2830      winner = winner ? sdsnew(winner) : NULL;
2831      sdsfree(myvote);
2832      dictRelease(counters);
2833      return winner;
2834  }
2835  int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {
2836      char portstr[32];
2837      int retval;
2838      ll2string(portstr,sizeof(portstr),port);
2839      if (host == NULL) {
2840          host = &quot;NO&quot;;
2841          memcpy(portstr,&quot;ONE&quot;,4);
2842      }
2843      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2844          sentinelDiscardReplyCallback, ri, &quot;%s&quot;,
2845          sentinelInstanceMapCommand(ri,&quot;MULTI&quot;));
2846      if (retval == C_ERR) return retval;
2847      ri-&gt;link-&gt;pending_commands++;
2848      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2849          sentinelDiscardReplyCallback, ri, &quot;%s %s %s&quot;,
2850          sentinelInstanceMapCommand(ri,&quot;SLAVEOF&quot;),
2851          host, portstr);
2852      if (retval == C_ERR) return retval;
2853      ri-&gt;link-&gt;pending_commands++;
2854      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2855          sentinelDiscardReplyCallback, ri, &quot;%s REWRITE&quot;,
2856          sentinelInstanceMapCommand(ri,&quot;CONFIG&quot;));
2857      if (retval == C_ERR) return retval;
2858      ri-&gt;link-&gt;pending_commands++;
2859      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2860          sentinelDiscardReplyCallback, ri, &quot;%s KILL TYPE normal&quot;,
2861          sentinelInstanceMapCommand(ri,&quot;CLIENT&quot;));
2862      if (retval == C_ERR) return retval;
2863      ri-&gt;link-&gt;pending_commands++;
2864      retval = redisAsyncCommand(ri-&gt;link-&gt;cc,
2865          sentinelDiscardReplyCallback, ri, &quot;%s&quot;,
2866          sentinelInstanceMapCommand(ri,&quot;EXEC&quot;));
2867      if (retval == C_ERR) return retval;
2868      ri-&gt;link-&gt;pending_commands++;
2869      return C_OK;
2870  }
2871  void sentinelStartFailover(sentinelRedisInstance *master) {
2872      serverAssert(master-&gt;flags &amp; SRI_MASTER);
2873      master-&gt;failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
2874      master-&gt;flags |= SRI_FAILOVER_IN_PROGRESS;
2875      master-&gt;failover_epoch = ++sentinel.current_epoch;
2876      sentinelEvent(LL_WARNING,&quot;+new-epoch&quot;,master,&quot;%llu&quot;,
2877          (PORT_ULONGLONG) sentinel.current_epoch);
2878      sentinelEvent(LL_WARNING,&quot;+try-failover&quot;,master,&quot;%@&quot;);
2879      master-&gt;failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
2880      master-&gt;failover_state_change_time = mstime();
2881  }
2882  int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
2883      if (!(master-&gt;flags &amp; SRI_O_DOWN)) return 0;
2884      if (master-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) return 0;
2885      if (mstime() - master-&gt;failover_start_time &lt;
2886          master-&gt;failover_timeout*2)
2887      {
2888          if (master-&gt;failover_delay_logged != master-&gt;failover_start_time) {
2889              time_t clock = (master-&gt;failover_start_time +
2890                              master-&gt;failover_timeout*2) / 1000;
2891              char ctimebuf[26];
2892              ctime_r(&amp;clock,ctimebuf);
2893              ctimebuf[24] = &#x27;\0&#x27;; &amp;bsol;* Remove newline. */
2894              master-&gt;failover_delay_logged = master-&gt;failover_start_time;
2895              serverLog(LL_WARNING,
2896                  &quot;Next failover delay: I will not start a failover before %s&quot;,
2897                  ctimebuf);
2898          }
2899          return 0;
2900      }
2901      sentinelStartFailover(master);
2902      return 1;
2903  }
2904  int compareSlavesForPromotion(const void *a, const void *b) {
2905      sentinelRedisInstance **sa = (sentinelRedisInstance **)a,
2906                            **sb = (sentinelRedisInstance **)b;
2907      char *sa_runid, *sb_runid;
2908      if ((*sa)-&gt;slave_priority != (*sb)-&gt;slave_priority)
2909          return (*sa)-&gt;slave_priority - (*sb)-&gt;slave_priority;
2910      if ((*sa)-&gt;slave_repl_offset &gt; (*sb)-&gt;slave_repl_offset) {
2911          return -1; &amp;bsol;* a &lt; b */
2912      } else if ((*sa)-&gt;slave_repl_offset &lt; (*sb)-&gt;slave_repl_offset) {
2913          return 1; &amp;bsol;* a &gt; b */
2914      }
2915      sa_runid = (*sa)-&gt;runid;
2916      sb_runid = (*sb)-&gt;runid;
2917      if (sa_runid == NULL &amp;&amp; sb_runid == NULL) return 0;
2918      else if (sa_runid == NULL) return 1;  &amp;bsol;* a &gt; b */
2919      else if (sb_runid == NULL) return -1; &amp;bsol;* a &lt; b */
2920      return strcasecmp(sa_runid, sb_runid);
2921  }
2922  sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
2923      sentinelRedisInstance **instance =
2924          zmalloc(sizeof(instance[0])*dictSize(master-&gt;slaves));
2925      sentinelRedisInstance *selected = NULL;
2926      int instances = 0;
2927      dictIterator *di;
2928      dictEntry *de;
2929      mstime_t max_master_down_time = 0;
2930      if (master-&gt;flags &amp; SRI_S_DOWN)
2931          max_master_down_time += mstime() - master-&gt;s_down_since_time;
2932      max_master_down_time += master-&gt;down_after_period * 10;
2933      di = dictGetIterator(master-&gt;slaves);
2934      while((de = dictNext(di)) != NULL) {
2935          sentinelRedisInstance *slave = dictGetVal(de);
2936          mstime_t info_validity_time;
2937          if (slave-&gt;flags &amp; (SRI_S_DOWN|SRI_O_DOWN)) continue;
2938          if (slave-&gt;link-&gt;disconnected) continue;
2939          if (mstime() - slave-&gt;link-&gt;last_avail_time &gt; SENTINEL_PING_PERIOD*5) continue;
2940          if (slave-&gt;slave_priority == 0) continue;
2941          if (master-&gt;flags &amp; SRI_S_DOWN)
2942              info_validity_time = SENTINEL_PING_PERIOD*5;
2943          else
2944              info_validity_time = SENTINEL_INFO_PERIOD*3;
2945          if (mstime() - slave-&gt;info_refresh &gt; info_validity_time) continue;
2946          if (slave-&gt;master_link_down_time &gt; max_master_down_time) continue;
2947          instance[instances++] = slave;
2948      }
2949      dictReleaseIterator(di);
2950      if (instances) {
2951          qsort(instance,instances,sizeof(sentinelRedisInstance*),
2952              compareSlavesForPromotion);
2953          selected = instance[0];
2954      }
2955      zfree(instance);
2956      return selected;
2957  }
2958  void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
2959      char *leader;
2960      int isleader;
2961      leader = sentinelGetLeader(ri, ri-&gt;failover_epoch);
2962      isleader = leader &amp;&amp; strcasecmp(leader,sentinel.myid) == 0;
2963      sdsfree(leader);
2964      if (!isleader &amp;&amp; !(ri-&gt;flags &amp; SRI_FORCE_FAILOVER)) {
2965          int election_timeout = SENTINEL_ELECTION_TIMEOUT;
2966          if (election_timeout &gt; ri-&gt;failover_timeout)
2967              election_timeout = (int)ri-&gt;failover_timeout;                       WIN_PORT_FIX &amp;bsol;* cast (int) */
2968          if (mstime() - ri-&gt;failover_start_time &gt; election_timeout) {
2969              sentinelEvent(LL_WARNING,&quot;-failover-abort-not-elected&quot;,ri,&quot;%@&quot;);
2970              sentinelAbortFailover(ri);
2971          }
2972          return;
2973      }
2974      sentinelEvent(LL_WARNING,&quot;+elected-leader&quot;,ri,&quot;%@&quot;);
2975      if (sentinel.simfailure_flags &amp; SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION)
2976          sentinelSimFailureCrash();
2977      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;
2978      ri-&gt;failover_state_change_time = mstime();
2979      sentinelEvent(LL_WARNING,&quot;+failover-state-select-slave&quot;,ri,&quot;%@&quot;);
2980  }
2981  void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
2982      sentinelRedisInstance *slave = sentinelSelectSlave(ri);
2983      if (slave == NULL) {
2984          sentinelEvent(LL_WARNING,&quot;-failover-abort-no-good-slave&quot;,ri,&quot;%@&quot;);
2985          sentinelAbortFailover(ri);
2986      } else {
2987          sentinelEvent(LL_WARNING,&quot;+selected-slave&quot;,slave,&quot;%@&quot;);
2988          slave-&gt;flags |= SRI_PROMOTED;
2989          ri-&gt;promoted_slave = slave;
2990          ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE;
2991          ri-&gt;failover_state_change_time = mstime();
2992          sentinelEvent(LL_NOTICE,&quot;+failover-state-send-slaveof-noone&quot;,
2993              slave, &quot;%@&quot;);
2994      }
2995  }
2996  void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
2997      int retval;
2998      if (ri-&gt;promoted_slave-&gt;link-&gt;disconnected) {
2999          if (mstime() - ri-&gt;failover_state_change_time &gt; ri-&gt;failover_timeout) {
3000              sentinelEvent(LL_WARNING,&quot;-failover-abort-slave-timeout&quot;,ri,&quot;%@&quot;);
3001              sentinelAbortFailover(ri);
3002          }
3003          return;
3004      }
3005      retval = sentinelSendSlaveOf(ri-&gt;promoted_slave,NULL,0);
3006      if (retval != C_OK) return;
3007      sentinelEvent(LL_NOTICE, &quot;+failover-state-wait-promotion&quot;,
3008          ri-&gt;promoted_slave,&quot;%@&quot;);
3009      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_WAIT_PROMOTION;
3010      ri-&gt;failover_state_change_time = mstime();
3011  }
3012  void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
3013      if (mstime() - ri-&gt;failover_state_change_time &gt; ri-&gt;failover_timeout) {
3014          sentinelEvent(LL_WARNING,&quot;-failover-abort-slave-timeout&quot;,ri,&quot;%@&quot;);
3015          sentinelAbortFailover(ri);
3016      }
3017  }
3018  void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
3019      int not_reconfigured = 0, timeout = 0;
3020      dictIterator *di;
3021      dictEntry *de;
3022      mstime_t elapsed = mstime() - master-&gt;failover_state_change_time;
3023      if (master-&gt;promoted_slave == NULL ||
3024          master-&gt;promoted_slave-&gt;flags &amp; SRI_S_DOWN) return;
3025      di = dictGetIterator(master-&gt;slaves);
3026      while((de = dictNext(di)) != NULL) {
3027          sentinelRedisInstance *slave = dictGetVal(de);
3028          if (slave-&gt;flags &amp; (SRI_PROMOTED|SRI_RECONF_DONE)) continue;
3029          if (slave-&gt;flags &amp; SRI_S_DOWN) continue;
3030          not_reconfigured++;
3031      }
3032      dictReleaseIterator(di);
3033      if (elapsed &gt; master-&gt;failover_timeout) {
3034          not_reconfigured = 0;
3035          timeout = 1;
3036          sentinelEvent(LL_WARNING,&quot;+failover-end-for-timeout&quot;,master,&quot;%@&quot;);
3037      }
3038      if (not_reconfigured == 0) {
3039          sentinelEvent(LL_WARNING,&quot;+failover-end&quot;,master,&quot;%@&quot;);
3040          master-&gt;failover_state = SENTINEL_FAILOVER_STATE_UPDATE_CONFIG;
3041          master-&gt;failover_state_change_time = mstime();
3042      }
3043      if (timeout) {
3044          dictIterator *di;
3045          dictEntry *de;
3046          di = dictGetIterator(master-&gt;slaves);
3047          while((de = dictNext(di)) != NULL) {
3048              sentinelRedisInstance *slave = dictGetVal(de);
3049              int retval;
3050              if (slave-&gt;flags &amp; (SRI_PROMOTED|SRI_RECONF_DONE|SRI_RECONF_SENT)) continue;
3051              if (slave-&gt;link-&gt;disconnected) continue;
3052              retval = sentinelSendSlaveOf(slave,
3053                      master-&gt;promoted_slave-&gt;addr-&gt;ip,
3054                      master-&gt;promoted_slave-&gt;addr-&gt;port);
3055              if (retval == C_OK) {
3056                  sentinelEvent(LL_NOTICE,&quot;+slave-reconf-sent-be&quot;,slave,&quot;%@&quot;);
3057                  slave-&gt;flags |= SRI_RECONF_SENT;
3058              }
3059          }
3060          dictReleaseIterator(di);
3061      }
3062  }
3063  void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {
3064      dictIterator *di;
3065      dictEntry *de;
3066      int in_progress = 0;
3067      di = dictGetIterator(master-&gt;slaves);
3068      while((de = dictNext(di)) != NULL) {
3069          sentinelRedisInstance *slave = dictGetVal(de);
3070          if (slave-&gt;flags &amp; (SRI_RECONF_SENT|SRI_RECONF_INPROG))
3071              in_progress++;
3072      }
3073      dictReleaseIterator(di);
3074      di = dictGetIterator(master-&gt;slaves);
3075      while(in_progress &lt; master-&gt;parallel_syncs &amp;&amp;
3076            (de = dictNext(di)) != NULL)
3077      {
3078          sentinelRedisInstance *slave = dictGetVal(de);
3079          int retval;
3080          if (slave-&gt;flags &amp; (SRI_PROMOTED|SRI_RECONF_DONE)) continue;
3081          if ((slave-&gt;flags &amp; SRI_RECONF_SENT) &amp;&amp;
3082              (mstime() - slave-&gt;slave_reconf_sent_time) &gt;
3083              SENTINEL_SLAVE_RECONF_TIMEOUT)
3084          {
3085              sentinelEvent(LL_NOTICE,&quot;-slave-reconf-sent-timeout&quot;,slave,&quot;%@&quot;);
3086              slave-&gt;flags &amp;= ~SRI_RECONF_SENT;
3087              slave-&gt;flags |= SRI_RECONF_DONE;
3088          }
3089          if (slave-&gt;flags &amp; (SRI_RECONF_SENT|SRI_RECONF_INPROG)) continue;
3090          if (slave-&gt;link-&gt;disconnected) continue;
3091          retval = sentinelSendSlaveOf(slave,
3092                  master-&gt;promoted_slave-&gt;addr-&gt;ip,
3093                  master-&gt;promoted_slave-&gt;addr-&gt;port);
3094          if (retval == C_OK) {
3095              slave-&gt;flags |= SRI_RECONF_SENT;
3096              slave-&gt;slave_reconf_sent_time = mstime();
3097              sentinelEvent(LL_NOTICE,&quot;+slave-reconf-sent&quot;,slave,&quot;%@&quot;);
3098              in_progress++;
3099          }
3100      }
3101      dictReleaseIterator(di);
3102      sentinelFailoverDetectEnd(master);
3103  }
3104  void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
3105      sentinelRedisInstance *ref = master-&gt;promoted_slave ?
3106                                   master-&gt;promoted_slave : master;
3107      sentinelEvent(LL_WARNING,&quot;+switch-master&quot;,master,&quot;%s %s %d %s %d&quot;,
3108          master-&gt;name, master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port,
3109          ref-&gt;addr-&gt;ip, ref-&gt;addr-&gt;port);
3110      sentinelResetMasterAndChangeAddress(master,ref-&gt;addr-&gt;ip,ref-&gt;addr-&gt;port);
3111  }
3112  void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
3113      serverAssert(ri-&gt;flags &amp; SRI_MASTER);
3114      if (!(ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS)) return;
3115      switch(ri-&gt;failover_state) {
3116          case SENTINEL_FAILOVER_STATE_WAIT_START:
3117              sentinelFailoverWaitStart(ri);
3118              break;
3119          case SENTINEL_FAILOVER_STATE_SELECT_SLAVE:
3120              sentinelFailoverSelectSlave(ri);
3121              break;
3122          case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:
3123              sentinelFailoverSendSlaveOfNoOne(ri);
3124              break;
3125          case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:
3126              sentinelFailoverWaitPromotion(ri);
3127              break;
3128          case SENTINEL_FAILOVER_STATE_RECONF_SLAVES:
3129              sentinelFailoverReconfNextSlave(ri);
3130              break;
3131      }
3132  }
3133  void sentinelAbortFailover(sentinelRedisInstance *ri) {
3134      serverAssert(ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS);
3135      serverAssert(ri-&gt;failover_state &lt;= SENTINEL_FAILOVER_STATE_WAIT_PROMOTION);
3136      ri-&gt;flags &amp;= ~(SRI_FAILOVER_IN_PROGRESS|SRI_FORCE_FAILOVER);
3137      ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_NONE;
3138      ri-&gt;failover_state_change_time = mstime();
3139      if (ri-&gt;promoted_slave) {
3140          ri-&gt;promoted_slave-&gt;flags &amp;= ~SRI_PROMOTED;
3141          ri-&gt;promoted_slave = NULL;
3142      }
3143  }
3144  void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
3145      sentinelReconnectInstance(ri);
3146      sentinelSendPeriodicCommands(ri);
3147      if (sentinel.tilt) {
3148          if (mstime()-sentinel.tilt_start_time &lt; SENTINEL_TILT_PERIOD) return;
3149          sentinel.tilt = 0;
3150          sentinelEvent(LL_WARNING,&quot;-tilt&quot;,NULL,&quot;#tilt mode exited&quot;);
3151      }
3152      sentinelCheckSubjectivelyDown(ri);
3153      if (ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) {
3154      }
3155      if (ri-&gt;flags &amp; SRI_MASTER) {
3156          sentinelCheckObjectivelyDown(ri);
3157          if (sentinelStartFailoverIfNeeded(ri))
3158              sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);
3159          sentinelFailoverStateMachine(ri);
3160          sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);
3161      }
3162  }
3163  void sentinelHandleDictOfRedisInstances(dict *instances) {
3164      dictIterator *di;
3165      dictEntry *de;
3166      sentinelRedisInstance *switch_to_promoted = NULL;
3167      di = dictGetIterator(instances);
3168      while((de = dictNext(di)) != NULL) {
3169          sentinelRedisInstance *ri = dictGetVal(de);
3170          sentinelHandleRedisInstance(ri);
3171          if (ri-&gt;flags &amp; SRI_MASTER) {
3172              sentinelHandleDictOfRedisInstances(ri-&gt;slaves);
3173              sentinelHandleDictOfRedisInstances(ri-&gt;sentinels);
3174              if (ri-&gt;failover_state == SENTINEL_FAILOVER_STATE_UPDATE_CONFIG) {
3175                  switch_to_promoted = ri;
3176              }
3177          }
3178      }
3179      if (switch_to_promoted)
3180          sentinelFailoverSwitchToPromotedSlave(switch_to_promoted);
3181      dictReleaseIterator(di);
3182  }
3183  void sentinelCheckTiltCondition(void) {
3184      mstime_t now = mstime();
3185      mstime_t delta = now - sentinel.previous_time;
3186      if (delta &lt; 0 || delta &gt; SENTINEL_TILT_TRIGGER) {
3187          sentinel.tilt = 1;
3188          sentinel.tilt_start_time = mstime();
3189          sentinelEvent(LL_WARNING,&quot;+tilt&quot;,NULL,&quot;#tilt mode entered&quot;);
3190      }
3191      sentinel.previous_time = mstime();
3192  }
3193  void sentinelTimer(void) {
3194      sentinelCheckTiltCondition();
3195      sentinelHandleDictOfRedisInstances(sentinel.masters);
3196      sentinelRunPendingScripts();
3197      sentinelCollectTerminatedScripts();
3198      sentinelKillTimedoutScripts();
3199      server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;
3200  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sentinel.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sentinel.c</div>
                </div>
                <div class="column column_space"><pre><code>1483              redisAeAttach(server.el,link-&gt;cc);
1484              redisAsyncSetConnectCallback(link-&gt;cc,
1485                      sentinelLinkEstablishedCallback);
1486              redisAsyncSetDisconnectCallback(link-&gt;cc,
1487                      sentinelDisconnectCallback);
1488              sentinelSendAuthIfNeeded(ri,link-&gt;cc);
1489              sentinelSetClientName(ri,link-&gt;cc,&quot;cmd&quot;);
1490              sentinelSendPing(ri);
</pre></code></div>
                <div class="column column_space"><pre><code>1503              redisAeAttach(server.el,link-&gt;pc);
1504              redisAsyncSetConnectCallback(link-&gt;pc,
1505                      sentinelLinkEstablishedCallback);
1506              redisAsyncSetDisconnectCallback(link-&gt;pc,
1507                      sentinelDisconnectCallback);
1508              sentinelSendAuthIfNeeded(ri,link-&gt;pc);
1509              sentinelSetClientName(ri,link-&gt;pc,&quot;pubsub&quot;);
1510              retval = redisAsyncCommand(link-&gt;pc,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    