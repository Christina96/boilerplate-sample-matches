
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.726027397260275%, Tokens: 11</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2.c</h3>
            <pre><code>1  #include "dft/dft.h"
2  typedef struct {
3       solver super;
4       int spltrnk;
5       const int *buddies;
6       size_t nbuddies;
7  } S;
8  typedef struct {
9       plan_dft super;
10       plan *cld1, *cld2;
11       const S *solver;
12  } P;
13  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
14  {
15       const P *ego = (const P *) ego_;
16       plan_dft *cld1, *cld2;
17       cld1 = (plan_dft *) ego->cld1;
18       cld1->apply(ego->cld1, ri, ii, ro, io);
19       cld2 = (plan_dft *) ego->cld2;
20       cld2->apply(ego->cld2, ro, io, ro, io);
21  }
22  static void awake(plan *ego_, enum wakefulness wakefulness)
23  {
24       P *ego = (P *) ego_;
25       X(plan_awake)(ego->cld1, wakefulness);
26       X(plan_awake)(ego->cld2, wakefulness);
<span onclick='openModal()' class='match'>27  }
28  static void destroy(plan *ego_)
29  {
30       P *ego = (P *) ego_;
31       X(plan_destroy_internal)(ego->cld2);
32       X(plan_destroy_internal)(ego->cld1);
33  }
34  static void print(const plan *ego_, printer *p)
35  {
36       const P *ego = (const P *) ego_;
</span>37       const S *s = ego->solver;
38       p->print(p, "(dft-rank>=2/%d%(%p%)%(%p%))",
39  	      s->spltrnk, ego->cld1, ego->cld2);
40  }
41  static int picksplit(const S *ego, const tensor *sz, int *rp)
42  {
43       A(sz->rnk > 1); &bsol;* cannot split rnk <= 1 */
44       if (!X(pickdim)(ego->spltrnk, ego->buddies, ego->nbuddies, sz, 1, rp))
45  	  return 0;
46       *rp += 1; &bsol;* convert from dim. index to rank */
47       if (*rp >= sz->rnk) &bsol;* split must reduce rank */
48  	  return 0;
49       return 1;
50  }
51  static int applicable0(const solver *ego_, const problem *p_, int *rp)
52  {
53       const problem_dft *p = (const problem_dft *) p_;
54       const S *ego = (const S *)ego_;
55       return (1
56  	     && FINITE_RNK(p->sz->rnk) && FINITE_RNK(p->vecsz->rnk)
57  	     && p->sz->rnk >= 2
58  	     && picksplit(ego, p->sz, rp)
59  	  );
60  }
61  static int applicable(const solver *ego_, const problem *p_, 
62  		      const planner *plnr, int *rp)
63  {
64       const S *ego = (const S *)ego_;
65       const problem_dft *p = (const problem_dft *) p_;
66       if (!applicable0(ego_, p_, rp)) return 0;
67       if (NO_RANK_SPLITSP(plnr) && (ego->spltrnk != ego->buddies[0])) return 0;
68       if (NO_UGLYP(plnr))
69  	  if (p->vecsz->rnk > 0 &&
70  	      X(tensor_min_stride)(p->vecsz) > X(tensor_max_index)(p->sz))
71  	       return 0;
72       return 1;
73  }
74  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
75  {
76       const S *ego = (const S *) ego_;
77       const problem_dft *p;
78       P *pln;
79       plan *cld1 = 0, *cld2 = 0;
80       tensor *sz1, *sz2, *vecszi, *sz2i;
81       int spltrnk;
82       static const plan_adt padt = {
83  	  X(dft_solve), awake, print, destroy
84       };
85       if (!applicable(ego_, p_, plnr, &spltrnk))
86            return (plan *) 0;
87       p = (const problem_dft *) p_;
88       X(tensor_split)(p->sz, &sz1, spltrnk, &sz2);
89       vecszi = X(tensor_copy_inplace)(p->vecsz, INPLACE_OS);
90       sz2i = X(tensor_copy_inplace)(sz2, INPLACE_OS);
91       cld1 = X(mkplan_d)(plnr, 
92  			X(mkproblem_dft_d)(X(tensor_copy)(sz2),
93  					   X(tensor_append)(p->vecsz, sz1),
94  					   p->ri, p->ii, p->ro, p->io));
95       if (!cld1) goto nada;
96       cld2 = X(mkplan_d)(plnr, 
97  			X(mkproblem_dft_d)(
98  			     X(tensor_copy_inplace)(sz1, INPLACE_OS),
99  			     X(tensor_append)(vecszi, sz2i),
100  			     p->ro, p->io, p->ro, p->io));
101       if (!cld2) goto nada;
102       pln = MKPLAN_DFT(P, &padt, apply);
103       pln->cld1 = cld1;
104       pln->cld2 = cld2;
105       pln->solver = ego;
106       X(ops_add)(&cld1->ops, &cld2->ops, &pln->super.super.ops);
107       X(tensor_destroy4)(sz1, sz2, vecszi, sz2i);
108       return &(pln->super.super);
109   nada:
110       X(plan_destroy_internal)(cld2);
111       X(plan_destroy_internal)(cld1);
112       X(tensor_destroy4)(sz1, sz2, vecszi, sz2i);
113       return (plan *) 0;
114  }
115  static solver *mksolver(int spltrnk, const int *buddies, size_t nbuddies)
116  {
117       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
118       S *slv = MKSOLVER(S, &sadt);
119       slv->spltrnk = spltrnk;
120       slv->buddies = buddies;
121       slv->nbuddies = nbuddies;
122       return &(slv->super);
123  }
124  void X(dft_rank_geq2_register)(planner *p)
125  {
126       static const int buddies[] = { 1, 0, -2 };
127       size_t i;
128       for (i = 0; i < NELEM(buddies); ++i)
129            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
130  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-bluestein.c</h3>
            <pre><code>1  #include "dft/dft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_dft super;
7       INT n;     &bsol;* problem size */
8       INT nb;    &bsol;* size of convolution */
9       R *w;      &bsol;* lambda k . exp(2*pi*i*k^2/(2*n)) */
10       R *W;      &bsol;* DFT(w) */
11       plan *cldf;
12       INT is, os;
13  } P;
14  static void bluestein_sequence(enum wakefulness wakefulness, INT n, R *w)
15  {
16       INT k, ksq, n2 = 2 * n;
17       triggen *t = X(mktriggen)(wakefulness, n2);
18       ksq = 0;
19       for (k = 0; k < n; ++k) {
20  	  t->cexp(t, ksq, w+2*k);
21            ksq += 2*k + 1; while (ksq > n2) ksq -= n2;
22       }
23       X(triggen_destroy)(t);
24  }
25  static void mktwiddle(enum wakefulness wakefulness, P *p)
26  {
27       INT i;
28       INT n = p->n, nb = p->nb;
29       R *w, *W;
30       E nbf = (E)nb;
31       p->w = w = (R *) MALLOC(2 * n * sizeof(R), TWIDDLES);
32       p->W = W = (R *) MALLOC(2 * nb * sizeof(R), TWIDDLES);
33       bluestein_sequence(wakefulness, n, w);
34       for (i = 0; i < nb; ++i)
35            W[2*i] = W[2*i+1] = K(0.0);
36       W[0] = w[0] / nbf;
37       W[1] = w[1] / nbf;
38       for (i = 1; i < n; ++i) {
39            W[2*i] = W[2*(nb-i)] = w[2*i] / nbf;
40            W[2*i+1] = W[2*(nb-i)+1] = w[2*i+1] / nbf;
41       }
42       {
43            plan_dft *cldf = (plan_dft *)p->cldf;
44            cldf->apply(p->cldf, W, W+1, W, W+1);
45       }
46  }
47  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
48  {
49       const P *ego = (const P *) ego_;
50       INT i, n = ego->n, nb = ego->nb, is = ego->is, os = ego->os;
51       R *w = ego->w, *W = ego->W;
52       R *b = (R *) MALLOC(2 * nb * sizeof(R), BUFFERS);
53       for (i = 0; i < n; ++i) {
54  	  E xr = ri[i*is], xi = ii[i*is];
55            E wr = w[2*i], wi = w[2*i+1];
56            b[2*i] = xr * wr + xi * wi;
57            b[2*i+1] = xi * wr - xr * wi;
58       }
59       for (; i < nb; ++i) b[2*i] = b[2*i+1] = K(0.0);
60       {
61            plan_dft *cldf = (plan_dft *)ego->cldf;
62            cldf->apply(ego->cldf, b, b+1, b, b+1);
63       }
64       for (i = 0; i < nb; ++i) {
65  	  E xr = b[2*i], xi = b[2*i+1];
66            E wr = W[2*i], wi = W[2*i+1];
67            b[2*i] = xi * wr + xr * wi;
68            b[2*i+1] = xr * wr - xi * wi;
69       }
70       {
71            plan_dft *cldf = (plan_dft *)ego->cldf;
72            cldf->apply(ego->cldf, b, b+1, b, b+1);
73       }
74       for (i = 0; i < n; ++i) {
75  	  E xi = b[2*i], xr = b[2*i+1];
76            E wr = w[2*i], wi = w[2*i+1];
77            ro[i*os] = xr * wr + xi * wi;
78            io[i*os] = xi * wr - xr * wi;
79       }
80       X(ifree)(b);	  
81  }
82  static void awake(plan *ego_, enum wakefulness wakefulness)
83  {
84       P *ego = (P *) ego_;
85       X(plan_awake)(ego->cldf, wakefulness);
86       switch (wakefulness) {
87  	 case SLEEPY:
88  	      X(ifree0)(ego->w); ego->w = 0;
89  	      X(ifree0)(ego->W); ego->W = 0;
90  	      break;
91  	 default:
92  	      A(!ego->w);
93  	      mktwiddle(wakefulness, ego);
94  	      break;
95       }
96  }
97  static int applicable(const solver *ego, const problem *p_, 
98  		      const planner *plnr)
99  {
100       const problem_dft *p = (const problem_dft *) p_;
101       UNUSED(ego);
102       return (1
103  	     && p->sz->rnk == 1
104  	     && p->vecsz->rnk == 0
105  	     && X(is_prime)(p->sz->dims[0].n)
106  	     && p->sz->dims[0].n > 16
107  	     && CIMPLIES(NO_SLOWP(plnr), p->sz->dims[0].n > BLUESTEIN_MAX_SLOW)
108  	  );
<span onclick='openModal()' class='match'>109  }
110  static void destroy(plan *ego_)
111  {
112       P *ego = (P *) ego_;
113       X(plan_destroy_internal)(ego->cldf);
114  }
115  static void print(const plan *ego_, printer *p)
116  {
117       const P *ego = (const P *)ego_;
</span>118       p->print(p, "(dft-bluestein-%D/%D%(%p%))",
119                ego->n, ego->nb, ego->cldf);
120  }
121  static INT choose_transform_size(INT minsz)
122  {
123       while (!X(factors_into_small_primes)(minsz))
124  	  ++minsz;
125       return minsz;
126  }
127  static plan *mkplan(const solver *ego, const problem *p_, planner *plnr)
128  {
129       const problem_dft *p = (const problem_dft *) p_;
130       P *pln;
131       INT n, nb;
132       plan *cldf = 0;
133       R *buf = (R *) 0;
134       static const plan_adt padt = {
135  	  X(dft_solve), awake, print, destroy
136       };
137       if (!applicable(ego, p_, plnr))
138  	  return (plan *) 0;
139       n = p->sz->dims[0].n;
140       nb = choose_transform_size(2 * n - 1);
141       buf = (R *) MALLOC(2 * nb * sizeof(R), BUFFERS);
142       cldf = X(mkplan_f_d)(plnr, 
143  			  X(mkproblem_dft_d)(X(mktensor_1d)(nb, 2, 2),
144  					     X(mktensor_1d)(1, 0, 0),
145  					     buf, buf+1, 
146  					     buf, buf+1),
147  			  NO_SLOW, 0, 0);
148       if (!cldf) goto nada;
149       X(ifree)(buf);
150       pln = MKPLAN_DFT(P, &padt, apply);
151       pln->n = n;
152       pln->nb = nb;
153       pln->w = 0;
154       pln->W = 0;
155       pln->cldf = cldf;
156       pln->is = p->sz->dims[0].is;
157       pln->os = p->sz->dims[0].os;
158       X(ops_add)(&cldf->ops, &cldf->ops, &pln->super.super.ops);
159       pln->super.super.ops.add += 4 * n + 2 * nb;
160       pln->super.super.ops.mul += 8 * n + 4 * nb;
161       pln->super.super.ops.other += 6 * (n + nb);
162       return &(pln->super.super);
163   nada:
164       X(ifree0)(buf);
165       X(plan_destroy_internal)(cldf);
166       return (plan *)0;
167  }
168  static solver *mksolver(void)
169  {
170       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
171       S *slv = MKSOLVER(S, &sadt);
172       return &(slv->super);
173  }
174  void X(dft_bluestein_register)(planner *p)
175  {
176       REGISTER_SOLVER(p, mksolver());
177  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-bluestein.c</div>
                </div>
                <div class="column column_space"><pre><code>27  }
28  static void destroy(plan *ego_)
29  {
30       P *ego = (P *) ego_;
31       X(plan_destroy_internal)(ego->cld2);
32       X(plan_destroy_internal)(ego->cld1);
33  }
34  static void print(const plan *ego_, printer *p)
35  {
36       const P *ego = (const P *) ego_;
</pre></code></div>
                <div class="column column_space"><pre><code>109  }
110  static void destroy(plan *ego_)
111  {
112       P *ego = (P *) ego_;
113       X(plan_destroy_internal)(ego->cldf);
114  }
115  static void print(const plan *ego_, printer *p)
116  {
117       const P *ego = (const P *)ego_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    