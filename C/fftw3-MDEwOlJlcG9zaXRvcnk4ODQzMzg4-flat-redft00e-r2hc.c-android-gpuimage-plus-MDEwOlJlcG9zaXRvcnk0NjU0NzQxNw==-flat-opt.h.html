
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.157043879907621%, Tokens: 9</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-redft00e-r2hc.c</h3>
            <pre><code>1  #include "reodft/reodft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft super;
7       plan *cld;
8       twid *td;
9       INT is, os;
10       INT n;
11       INT vl;
12       INT ivs, ovs;
13  } P;
14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       INT is = ego->is, os = ego->os;
18       INT i, n = ego->n;
19       INT iv, vl = ego->vl;
20       INT ivs = ego->ivs, ovs = ego->ovs;
21       R *W = ego->td->W;
22       R *buf;
23       E csum;
24       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
25       for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {
26  	  buf[0] = I[0] + I[is * n];
27  	  csum = I[0] - I[is * n];
<span onclick='openModal()' class='match'>28  	  for (i = 1; i < n - i; ++i) {
29  	       E a, b, apb, amb;
30  	       a = I[is * i];
31  	       b = I[is * (n - i)];
32  	       csum += W[2*i] * (amb = K(2.0)*(a - b));
33  	       amb = W[2*i+1] * amb;
34  	       apb = (a + b);
35  	       buf[i] = apb - amb;
36  	       buf[n - i] = apb + amb;
</span>37  	  }
38  	  if (i == n - i) {
39  	       buf[i] = K(2.0) * I[is * i];
40  	  }
41  	  {
42  	       plan_rdft *cld = (plan_rdft *) ego->cld;
43  	       cld->apply((plan *) cld, buf, buf);
44  	  }
45  	  O[0] = buf[0];
46  	  O[os] = csum;
47  	  for (i = 1; i + i < n; ++i) {
48  	       INT k = i + i;
49  	       O[os * k] = buf[i];
50  	       O[os * (k + 1)] = O[os * (k - 1)] - buf[n - i];
51  	  }
52  	  if (i + i == n) {
53  	       O[os * n] = buf[i];
54  	  }
55       }
56       X(ifree)(buf);
57  }
58  static void awake(plan *ego_, enum wakefulness wakefulness)
59  {
60       P *ego = (P *) ego_;
61       static const tw_instr redft00e_tw[] = {
62            { TW_COS, 0, 1 },
63            { TW_SIN, 0, 1 },
64            { TW_NEXT, 1, 0 }
65       };
66       X(plan_awake)(ego->cld, wakefulness);
67       X(twiddle_awake)(wakefulness,
68  		      &ego->td, redft00e_tw, 2*ego->n, 1, (ego->n+1)/2);
69  }
70  static void destroy(plan *ego_)
71  {
72       P *ego = (P *) ego_;
73       X(plan_destroy_internal)(ego->cld);
74  }
75  static void print(const plan *ego_, printer *p)
76  {
77       const P *ego = (const P *) ego_;
78       p->print(p, "(redft00e-r2hc-%D%v%(%p%))", ego->n + 1, ego->vl, ego->cld);
79  }
80  static int applicable0(const solver *ego_, const problem *p_)
81  {
82       const problem_rdft *p = (const problem_rdft *) p_;
83       UNUSED(ego_);
84       return (1
85  	     && p->sz->rnk == 1
86  	     && p->vecsz->rnk <= 1
87  	     && p->kind[0] == REDFT00
88  	     && p->sz->dims[0].n > 1  &bsol;* n == 1 is not well-defined */
89  	  );
90  }
91  static int applicable(const solver *ego, const problem *p, const planner *plnr)
92  {
93       return (!NO_SLOWP(plnr) && applicable0(ego, p));
94  }
95  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
96  {
97       P *pln;
98       const problem_rdft *p;
99       plan *cld;
100       R *buf;
101       INT n;
102       opcnt ops;
103       static const plan_adt padt = {
104  	  X(rdft_solve), awake, print, destroy
105       };
106       if (!applicable(ego_, p_, plnr))
107            return (plan *)0;
108       p = (const problem_rdft *) p_;
109       n = p->sz->dims[0].n - 1;
110       A(n > 0);
111       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
112       cld = X(mkplan_d)(plnr, X(mkproblem_rdft_1_d)(X(mktensor_1d)(n, 1, 1), 
113  						   X(mktensor_0d)(), 
114  						   buf, buf, R2HC));
115       X(ifree)(buf);
116       if (!cld)
117            return (plan *)0;
118       pln = MKPLAN_RDFT(P, &padt, apply);
119       pln->n = n;
120       pln->is = p->sz->dims[0].is;
121       pln->os = p->sz->dims[0].os;
122       pln->cld = cld;
123       pln->td = 0;
124       X(tensor_tornk1)(p->vecsz, &pln->vl, &pln->ivs, &pln->ovs);
125       X(ops_zero)(&ops);
126       ops.other = 8 + (n-1)/2 * 11 + (1 - n % 2) * 5;
127       ops.add = 2 + (n-1)/2 * 5;
128       ops.mul = (n-1)/2 * 3 + (1 - n % 2) * 1;
129       X(ops_zero)(&pln->super.super.ops);
130       X(ops_madd2)(pln->vl, &ops, &pln->super.super.ops);
131       X(ops_madd2)(pln->vl, &cld->ops, &pln->super.super.ops);
132       return &(pln->super.super);
133  }
134  static solver *mksolver(void)
135  {
136       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
137       S *slv = MKSOLVER(S, &sadt);
138       return &(slv->super);
139  }
140  void X(redft00e_r2hc_register)(planner *p)
141  {
142       REGISTER_SOLVER(p, mksolver());
143  }
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-opt.h</h3>
            <pre><code>1  #ifndef AVUTIL_OPT_H
2  #define AVUTIL_OPT_H
3  #include "rational.h"
4  #include "avutil.h"
5  #include "dict.h"
6  #include "log.h"
7  #include "pixfmt.h"
8  #include "samplefmt.h"
9  #include "version.h"
<span onclick='openModal()' class='match'>10  enum AVOptionType{
11      AV_OPT_TYPE_FLAGS,
12      AV_OPT_TYPE_INT,
13      AV_OPT_TYPE_INT64,
14      AV_OPT_TYPE_DOUBLE,
15      AV_OPT_TYPE_FLOAT,
16      AV_OPT_TYPE_STRING,
17      AV_OPT_TYPE_RATIONAL,
18      AV_OPT_TYPE_BINARY,  
19      AV_OPT_TYPE_DICT,
20      AV_OPT_TYPE_UINT64,
21      AV_OPT_TYPE_CONST = 128,
22      AV_OPT_TYPE_IMAGE_SIZE = MKBETAG('S','I','Z','E'), 
23      AV_OPT_TYPE_PIXEL_FMT  = MKBETAG('P','F','M','T'),
24      AV_OPT_TYPE_SAMPLE_FMT = MKBETAG('S','F','M','T'),
25      AV_OPT_TYPE_VIDEO_RATE = MKBETAG('V','R','A','T'), 
26      AV_OPT_TYPE_DURATION   = MKBETAG('D','U','R',' '),
27      AV_OPT_TYPE_COLOR      = MKBETAG('C','O','L','R'),
28      AV_OPT_TYPE_CHANNEL_LAYOUT = MKBETAG('C','H','L','A'),
</span>29      AV_OPT_TYPE_BOOL           = MKBETAG('B','O','O','L'),
30  };
31  typedef struct AVOption {
32      const char *name;
33      const char *help;
34      int offset;
35      enum AVOptionType type;
36      union {
37          int64_t i64;
38          double dbl;
39          const char *str;
40          AVRational q;
41      } default_val;
42      double min;                 
43      double max;                 
44      int flags;
45  #define AV_OPT_FLAG_ENCODING_PARAM  1   
46  #define AV_OPT_FLAG_DECODING_PARAM  2   
47  #if FF_API_OPT_TYPE_METADATA
48  #define AV_OPT_FLAG_METADATA        4   
49  #endif
50  #define AV_OPT_FLAG_AUDIO_PARAM     8
51  #define AV_OPT_FLAG_VIDEO_PARAM     16
52  #define AV_OPT_FLAG_SUBTITLE_PARAM  32
53  #define AV_OPT_FLAG_EXPORT          64
54  #define AV_OPT_FLAG_READONLY        128
55  #define AV_OPT_FLAG_FILTERING_PARAM (1<<16) 
56      const char *unit;
57  } AVOption;
58  typedef struct AVOptionRange {
59      const char *str;
60      double value_min, value_max;
61      double component_min, component_max;
62      int is_range;
63  } AVOptionRange;
64  typedef struct AVOptionRanges {
65      AVOptionRange **range;
66      int nb_ranges;
67      int nb_components;
68  } AVOptionRanges;
69  int av_opt_show2(void *obj, void *av_log_obj, int req_flags, int rej_flags);
70  void av_opt_set_defaults(void *s);
71  void av_opt_set_defaults2(void *s, int mask, int flags);
72  int av_set_options_string(void *ctx, const char *opts,
73                            const char *key_val_sep, const char *pairs_sep);
74  int av_opt_set_from_string(void *ctx, const char *opts,
75                             const char *const *shorthand,
76                             const char *key_val_sep, const char *pairs_sep);
77  void av_opt_free(void *obj);
78  int av_opt_flag_is_set(void *obj, const char *field_name, const char *flag_name);
79  int av_opt_set_dict(void *obj, struct AVDictionary **options);
80  int av_opt_set_dict2(void *obj, struct AVDictionary **options, int search_flags);
81  int av_opt_get_key_value(const char **ropts,
82                           const char *key_val_sep, const char *pairs_sep,
83                           unsigned flags,
84                           char **rkey, char **rval);
85  enum {
86      AV_OPT_FLAG_IMPLICIT_KEY = 1,
87  };
88  int av_opt_eval_flags (void *obj, const AVOption *o, const char *val, int        *flags_out);
89  int av_opt_eval_int   (void *obj, const AVOption *o, const char *val, int        *int_out);
90  int av_opt_eval_int64 (void *obj, const AVOption *o, const char *val, int64_t    *int64_out);
91  int av_opt_eval_float (void *obj, const AVOption *o, const char *val, float      *float_out);
92  int av_opt_eval_double(void *obj, const AVOption *o, const char *val, double     *double_out);
93  int av_opt_eval_q     (void *obj, const AVOption *o, const char *val, AVRational *q_out);
94  #define AV_OPT_SEARCH_CHILDREN   (1 << 0) &bsol;**< Search in possible children of the
95                                                 given object first. */
96  #define AV_OPT_SEARCH_FAKE_OBJ   (1 << 1)
97  #define AV_OPT_ALLOW_NULL (1 << 2)
98  #define AV_OPT_MULTI_COMPONENT_RANGE (1 << 12)
99  const AVOption *av_opt_find(void *obj, const char *name, const char *unit,
100                              int opt_flags, int search_flags);
101  const AVOption *av_opt_find2(void *obj, const char *name, const char *unit,
102                               int opt_flags, int search_flags, void **target_obj);
103  const AVOption *av_opt_next(const void *obj, const AVOption *prev);
104  void *av_opt_child_next(void *obj, void *prev);
105  const AVClass *av_opt_child_class_next(const AVClass *parent, const AVClass *prev);
106  int av_opt_set         (void *obj, const char *name, const char *val, int search_flags);
107  int av_opt_set_int     (void *obj, const char *name, int64_t     val, int search_flags);
108  int av_opt_set_double  (void *obj, const char *name, double      val, int search_flags);
109  int av_opt_set_q       (void *obj, const char *name, AVRational  val, int search_flags);
110  int av_opt_set_bin     (void *obj, const char *name, const uint8_t *val, int size, int search_flags);
111  int av_opt_set_image_size(void *obj, const char *name, int w, int h, int search_flags);
112  int av_opt_set_pixel_fmt (void *obj, const char *name, enum AVPixelFormat fmt, int search_flags);
113  int av_opt_set_sample_fmt(void *obj, const char *name, enum AVSampleFormat fmt, int search_flags);
114  int av_opt_set_video_rate(void *obj, const char *name, AVRational val, int search_flags);
115  int av_opt_set_channel_layout(void *obj, const char *name, int64_t ch_layout, int search_flags);
116  int av_opt_set_dict_val(void *obj, const char *name, const AVDictionary *val, int search_flags);
117  #define av_opt_set_int_list(obj, name, val, term, flags) \
118      (av_int_list_length(val, term) > INT_MAX / sizeof(*(val)) ? \
119       AVERROR(EINVAL) : \
120       av_opt_set_bin(obj, name, (const uint8_t *)(val), \
121                      av_int_list_length(val, term) * sizeof(*(val)), flags))
122  int av_opt_get         (void *obj, const char *name, int search_flags, uint8_t   **out_val);
123  int av_opt_get_int     (void *obj, const char *name, int search_flags, int64_t    *out_val);
124  int av_opt_get_double  (void *obj, const char *name, int search_flags, double     *out_val);
125  int av_opt_get_q       (void *obj, const char *name, int search_flags, AVRational *out_val);
126  int av_opt_get_image_size(void *obj, const char *name, int search_flags, int *w_out, int *h_out);
127  int av_opt_get_pixel_fmt (void *obj, const char *name, int search_flags, enum AVPixelFormat *out_fmt);
128  int av_opt_get_sample_fmt(void *obj, const char *name, int search_flags, enum AVSampleFormat *out_fmt);
129  int av_opt_get_video_rate(void *obj, const char *name, int search_flags, AVRational *out_val);
130  int av_opt_get_channel_layout(void *obj, const char *name, int search_flags, int64_t *ch_layout);
131  int av_opt_get_dict_val(void *obj, const char *name, int search_flags, AVDictionary **out_val);
132  void *av_opt_ptr(const AVClass *avclass, void *obj, const char *name);
133  void av_opt_freep_ranges(AVOptionRanges **ranges);
134  int av_opt_query_ranges(AVOptionRanges **, void *obj, const char *key, int flags);
135  int av_opt_copy(void *dest, const void *src);
136  int av_opt_query_ranges_default(AVOptionRanges **, void *obj, const char *key, int flags);
137  int av_opt_is_set_to_default(void *obj, const AVOption *o);
138  int av_opt_is_set_to_default_by_name(void *obj, const char *name, int search_flags);
139  #define AV_OPT_SERIALIZE_SKIP_DEFAULTS              0x00000001  
140  #define AV_OPT_SERIALIZE_OPT_FLAGS_EXACT            0x00000002  
141  int av_opt_serialize(void *obj, int opt_flags, int flags, char **buffer,
142                       const char key_val_sep, const char pairs_sep);
143  #endif &bsol;* AVUTIL_OPT_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-redft00e-r2hc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-opt.h</div>
                </div>
                <div class="column column_space"><pre><code>28  	  for (i = 1; i < n - i; ++i) {
29  	       E a, b, apb, amb;
30  	       a = I[is * i];
31  	       b = I[is * (n - i)];
32  	       csum += W[2*i] * (amb = K(2.0)*(a - b));
33  	       amb = W[2*i+1] * amb;
34  	       apb = (a + b);
35  	       buf[i] = apb - amb;
36  	       buf[n - i] = apb + amb;
</pre></code></div>
                <div class="column column_space"><pre><code>10  enum AVOptionType{
11      AV_OPT_TYPE_FLAGS,
12      AV_OPT_TYPE_INT,
13      AV_OPT_TYPE_INT64,
14      AV_OPT_TYPE_DOUBLE,
15      AV_OPT_TYPE_FLOAT,
16      AV_OPT_TYPE_STRING,
17      AV_OPT_TYPE_RATIONAL,
18      AV_OPT_TYPE_BINARY,  
19      AV_OPT_TYPE_DICT,
20      AV_OPT_TYPE_UINT64,
21      AV_OPT_TYPE_CONST = 128,
22      AV_OPT_TYPE_IMAGE_SIZE = MKBETAG('S','I','Z','E'), 
23      AV_OPT_TYPE_PIXEL_FMT  = MKBETAG('P','F','M','T'),
24      AV_OPT_TYPE_SAMPLE_FMT = MKBETAG('S','F','M','T'),
25      AV_OPT_TYPE_VIDEO_RATE = MKBETAG('V','R','A','T'), 
26      AV_OPT_TYPE_DURATION   = MKBETAG('D','U','R',' '),
27      AV_OPT_TYPE_COLOR      = MKBETAG('C','O','L','R'),
28      AV_OPT_TYPE_CHANNEL_LAYOUT = MKBETAG('C','H','L','A'),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    