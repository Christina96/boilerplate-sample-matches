
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 101, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds_38.h</h3>
            <pre><code>1  #ifndef __SDS_H
2  #define __SDS_H
3  #define SDS_MAX_PREALLOC (1024*1024)
4  extern const char *SDS_NOINIT;
5  #ifdef _WIN32
6  #include "Win32_Interop/Win32_Portability.h"
7  #include "Win32_Interop/win32_types.h"
8  #endif
9  #include <sys/types.h>
10  #include <stdarg.h>
11  #include <stdint.h>
12  typedef char *sds;
13  #ifdef _WIN32
14  #define PACK( __Declaration__ ) __pragma( pack(push, 1) ) __Declaration__ __pragma( pack(pop) )
15  PACK(
16  struct sdshdr5{
17      unsigned char flags; &bsol;* 3 lsb of type, and 5 msb of string length */
18      char buf[];
19  };)
20  PACK(
21  struct sdshdr8 {
22      uint8_t len; &bsol;* used */
23      uint8_t alloc; &bsol;* excluding the header and null terminator */
24      unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
25      char buf[];
26  };)
27  PACK(
28  struct sdshdr16 {
29      uint16_t len; &bsol;* used */
30      uint16_t alloc; &bsol;* excluding the header and null terminator */
31      unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
32      char buf[];
33  };)
34  PACK(
35  struct sdshdr32 {
36      uint32_t len; &bsol;* used */
37      uint32_t alloc; &bsol;* excluding the header and null terminator */
38      unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
39      char buf[];
40  };)
41  PACK(
42  struct sdshdr64 {
43      uint64_t len; &bsol;* used */
44      uint64_t alloc; &bsol;* excluding the header and null terminator */
45      unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
46      char buf[];
47  };)
48  #else
49  struct __attribute__ ((__packed__)) sdshdr5 {
50      unsigned char flags; &bsol;* 3 lsb of type, and 5 msb of string length */
51      char buf[];
52  };
53  struct __attribute__ ((__packed__)) sdshdr8 {
54      uint8_t len; &bsol;* used */
55      uint8_t alloc; &bsol;* excluding the header and null terminator */
56      unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
57      char buf[];
58  };
59  struct __attribute__ ((__packed__)) sdshdr16 {
60      uint16_t len; &bsol;* used */
61      uint16_t alloc; &bsol;* excluding the header and null terminator */
62      unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
63      char buf[];
64  };
65  struct __attribute__ ((__packed__)) sdshdr32 {
66      uint32_t len; &bsol;* used */
67      uint32_t alloc; &bsol;* excluding the header and null terminator */
68      unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
69      char buf[];
70  };
71  struct __attribute__ ((__packed__)) sdshdr64 {
72      uint64_t len; &bsol;* used */
73      uint64_t alloc; &bsol;* excluding the header and null terminator */
74      unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
75      char buf[];
76  };
77  #endif
78  #define SDS_TYPE_5  0
79  #define SDS_TYPE_8  1
80  #define SDS_TYPE_16 2
81  #define SDS_TYPE_32 3
82  #define SDS_TYPE_64 4
83  #define SDS_TYPE_MASK 7
84  #define SDS_TYPE_BITS 3
85  #define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));
86  #define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
87  #define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)
88  static inline size_t sdslen(const sds s) {
89      unsigned char flags = s[-1];
90      switch(flags&SDS_TYPE_MASK) {
91          case SDS_TYPE_5:
92              return SDS_TYPE_5_LEN(flags);
93          case SDS_TYPE_8:
94              return SDS_HDR(8,s)->len;
95          case SDS_TYPE_16:
96              return SDS_HDR(16,s)->len;
97          case SDS_TYPE_32:
98              return SDS_HDR(32,s)->len;
99          case SDS_TYPE_64:
100              return SDS_HDR(64,s)->len;
101      }
102      return 0;
103  }
104  static inline size_t sdsavail(const sds s) {
105      unsigned char flags = s[-1];
106      switch(flags&SDS_TYPE_MASK) {
107          case SDS_TYPE_5: {
108              return 0;
109          }
110          case SDS_TYPE_8: {
111              SDS_HDR_VAR(8,s);
112              return sh->alloc - sh->len;
113          }
114          case SDS_TYPE_16: {
115              SDS_HDR_VAR(16,s);
116              return sh->alloc - sh->len;
117          }
118          case SDS_TYPE_32: {
119              SDS_HDR_VAR(32,s);
120              return sh->alloc - sh->len;
121          }
122          case SDS_TYPE_64: {
123              SDS_HDR_VAR(64,s);
124              return sh->alloc - sh->len;
125          }
126      }
127      return 0;
128  }
129  static inline void sdssetlen(sds s, size_t newlen) {
130      unsigned char flags = s[-1];
131      switch(flags&SDS_TYPE_MASK) {
132          case SDS_TYPE_5:
133              {
134                  unsigned char *fp = ((unsigned char*)s)-1;
135                  *fp = SDS_TYPE_5 | (unsigned char)(newlen << SDS_TYPE_BITS);    WIN_PORT_FIX &bsol;* cast (unsigned char) */
136              }
137              break;
138          case SDS_TYPE_8:
139              SDS_HDR(8,s)->len = (uint8_t)newlen;                                WIN_PORT_FIX &bsol;* cast (uint8_t) */
140              break;
141          case SDS_TYPE_16:
142              SDS_HDR(16,s)->len = (uint16_t)newlen;                              WIN_PORT_FIX &bsol;* cast (uint16_t) */
143              break;
144          case SDS_TYPE_32:
145              SDS_HDR(32,s)->len = (uint32_t)newlen;                              WIN_PORT_FIX &bsol;* cast (uint32_t) */
146              break;
147          case SDS_TYPE_64:
148              SDS_HDR(64,s)->len = newlen;
149              break;
150      }
151  }
152  static inline void sdsinclen(sds s, size_t inc) {
153      unsigned char flags = s[-1];
154      switch(flags&SDS_TYPE_MASK) {
155          case SDS_TYPE_5:
156              {
157                  unsigned char *fp = ((unsigned char*)s)-1;
158                  unsigned char newlen = (unsigned char)(SDS_TYPE_5_LEN(flags)+inc); WIN_PORT_FIX &bsol;* cast (unsigned char) */
159                  *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
160              }
161              break;
162          case SDS_TYPE_8:
163              SDS_HDR(8,s)->len += (uint8_t)inc;                                  WIN_PORT_FIX &bsol;* cast (uint8_t) */
164              break;
165          case SDS_TYPE_16:
166              SDS_HDR(16,s)->len += (uint16_t)inc;                                WIN_PORT_FIX &bsol;* cast (uint16_t) */
167              break;
168          case SDS_TYPE_32:
169              SDS_HDR(32,s)->len += (uint32_t)inc;                                WIN_PORT_FIX &bsol;* cast (uint32_t) */
170              break;
171          case SDS_TYPE_64:
172              SDS_HDR(64,s)->len += inc;
173              break;
174      }
175  }
176  static inline size_t sdsalloc(const sds s) {
177      unsigned char flags = s[-1];
178      switch(flags&SDS_TYPE_MASK) {
179          case SDS_TYPE_5:
180              return SDS_TYPE_5_LEN(flags);
181          case SDS_TYPE_8:
182              return SDS_HDR(8,s)->alloc;
183          case SDS_TYPE_16:
184              return SDS_HDR(16,s)->alloc;
185          case SDS_TYPE_32:
186              return SDS_HDR(32,s)->alloc;
187          case SDS_TYPE_64:
188              return SDS_HDR(64,s)->alloc;
189      }
190      return 0;
191  }
192  static inline void sdssetalloc(sds s, size_t newlen) {
193      unsigned char flags = s[-1];
194      switch(flags&SDS_TYPE_MASK) {
195          case SDS_TYPE_5:
196              break;
197          case SDS_TYPE_8:
198              SDS_HDR(8,s)->alloc = (uint8_t)newlen;                              WIN_PORT_FIX &bsol;* cast (uint8_t) */
199              break;
200          case SDS_TYPE_16:
201              SDS_HDR(16,s)->alloc = (uint16_t)newlen;                            WIN_PORT_FIX &bsol;* cast (uint16_t) */
202              break;
203          case SDS_TYPE_32:
204              SDS_HDR(32,s)->alloc = (uint32_t)newlen;                            WIN_PORT_FIX &bsol;* cast (uint32_t) */
205              break;
206          case SDS_TYPE_64:
207              SDS_HDR(64,s)->alloc = newlen;
208              break;
209      }
210  }
211  sds sdsnewlen(const void *init, size_t initlen);
212  sds sdsnew(const char *init);
213  sds sdsempty(void);
214  sds sdsdup(const sds s);
215  void sdsfree(sds s);
216  sds sdsgrowzero(sds s, size_t len);
217  sds sdscatlen(sds s, const void *t, size_t len);
218  sds sdscat(sds s, const char *t);
219  sds sdscatsds(sds s, const sds t);
220  sds sdscpylen(sds s, const char *t, size_t len);
221  sds sdscpy(sds s, const char *t);
222  sds sdscatvprintf(sds s, const char *fmt, va_list ap);
223  #ifdef __GNUC__
224  sds sdscatprintf(sds s, const char *fmt, ...)
225      __attribute__((format(printf, 2, 3)));
226  #else
227  sds sdscatprintf(sds s, const char *fmt, ...);
228  #endif
229  sds sdscatfmt(sds s, char const *fmt, ...);
230  sds sdstrim(sds s, const char *cset);
231  void sdsrange(sds s, ssize_t start, ssize_t end);
232  void sdsupdatelen(sds s);
233  void sdsclear(sds s);
234  int sdscmp(const sds s1, const sds s2);
235  sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count);
236  void sdsfreesplitres(sds *tokens, int count);
237  void sdstolower(sds s);
238  void sdstoupper(sds s);
<span onclick='openModal()' class='match'>239  sds sdsfromlonglong(PORT_LONGLONG value);
240  sds sdscatrepr(sds s, const char *p, size_t len);
241  sds *sdssplitargs(const char *line, int *argc);
242  sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);
243  sds sdsjoin(char **argv, int argc, char *sep);
244  sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);
245  sds sdsMakeRoomFor(sds s, size_t addlen);
246  void sdsIncrLen(sds s, ssize_t incr);
</span>247  sds sdsRemoveFreeSpace(sds s);
248  size_t sdsAllocSize(sds s);
249  void *sdsAllocPtr(sds s);
250  void *sds_malloc(size_t size);
251  void *sds_realloc(void *ptr, size_t size);
252  void sds_free(void *ptr);
253  #ifdef REDIS_TEST
254  int sdsTest(int argc, char *argv[]);
255  #endif
256  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds.h</h3>
            <pre><code>1  #ifndef __SDS_H
2  #define __SDS_H
3  #define SDS_MAX_PREALLOC (1024*1024)
4  #ifdef _WIN32
5  #include "../../src/Win32_Interop/Win32_Portability.h"
6  #include "../../src/Win32_Interop/win32_types_hiredis.h"
7  #endif
8  #include <sys/types.h>
9  #include <stdarg.h>
10  #include <stdint.h>
11  typedef char *sds;
12  #ifdef _WIN32
13  #define PACK( __Declaration__ ) __pragma( pack(push, 1) ) __Declaration__ __pragma( pack(pop) )
14  PACK(
15  	struct sdshdr5 {
16  	unsigned char flags; &bsol;* 3 lsb of type, and 5 msb of string length */
17  	char buf[];
18  };)
19  PACK(
20  	struct sdshdr8 {
21  	uint8_t len; &bsol;* used */
22  	uint8_t alloc; &bsol;* excluding the header and null terminator */
23  	unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
24  	char buf[];
25  };)
26  PACK(
27  	struct sdshdr16 {
28  	uint16_t len; &bsol;* used */
29  	uint16_t alloc; &bsol;* excluding the header and null terminator */
30  	unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
31  	char buf[];
32  };)
33  PACK(
34  	struct sdshdr32 {
35  	uint32_t len; &bsol;* used */
36  	uint32_t alloc; &bsol;* excluding the header and null terminator */
37  	unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
38  	char buf[];
39  };)
40  PACK(
41  	struct sdshdr64 {
42  	uint64_t len; &bsol;* used */
43  	uint64_t alloc; &bsol;* excluding the header and null terminator */
44  	unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
45  	char buf[];
46  };)
47  #else
48  struct __attribute__((__packed__)) sdshdr5 {
49  	unsigned char flags; &bsol;* 3 lsb of type, and 5 msb of string length */
50  	char buf[];
51  };
52  struct __attribute__((__packed__)) sdshdr8 {
53  	uint8_t len; &bsol;* used */
54  	uint8_t alloc; &bsol;* excluding the header and null terminator */
55  	unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
56  	char buf[];
57  };
58  struct __attribute__((__packed__)) sdshdr16 {
59  	uint16_t len; &bsol;* used */
60  	uint16_t alloc; &bsol;* excluding the header and null terminator */
61  	unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
62  	char buf[];
63  };
64  struct __attribute__((__packed__)) sdshdr32 {
65  	uint32_t len; &bsol;* used */
66  	uint32_t alloc; &bsol;* excluding the header and null terminator */
67  	unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
68  	char buf[];
69  };
70  struct __attribute__((__packed__)) sdshdr64 {
71  	uint64_t len; &bsol;* used */
72  	uint64_t alloc; &bsol;* excluding the header and null terminator */
73  	unsigned char flags; &bsol;* 3 lsb of type, 5 unused bits */
74  	char buf[];
75  };
76  #endif
77  #define SDS_TYPE_5  0
78  #define SDS_TYPE_8  1
79  #define SDS_TYPE_16 2
80  #define SDS_TYPE_32 3
81  #define SDS_TYPE_64 4
82  #define SDS_TYPE_MASK 7
83  #define SDS_TYPE_BITS 3
84  #define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)));
85  #define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
86  #define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)
87  #ifdef _WIN32
88  #define inline __inline
89  #endif
90  static inline size_t sdslen(const sds s) {
91  	unsigned char flags = s[-1];
92  	switch (flags&SDS_TYPE_MASK) {
93  	case SDS_TYPE_5:
94  		return SDS_TYPE_5_LEN(flags);
95  	case SDS_TYPE_8:
96  		return SDS_HDR(8, s)->len;
97  	case SDS_TYPE_16:
98  		return SDS_HDR(16, s)->len;
99  	case SDS_TYPE_32:
100  		return SDS_HDR(32, s)->len;
101  	case SDS_TYPE_64:
102  		return SDS_HDR(64, s)->len;
103  	}
104  	return 0;
105  }
106  static inline size_t sdsavail(const sds s) {
107  	unsigned char flags = s[-1];
108  	switch (flags&SDS_TYPE_MASK) {
109  	case SDS_TYPE_5: {
110  		return 0;
111  	}
112  	case SDS_TYPE_8: {
113  		SDS_HDR_VAR(8, s);
114  		return sh->alloc - sh->len;
115  	}
116  	case SDS_TYPE_16: {
117  		SDS_HDR_VAR(16, s);
118  		return sh->alloc - sh->len;
119  	}
120  	case SDS_TYPE_32: {
121  		SDS_HDR_VAR(32, s);
122  		return sh->alloc - sh->len;
123  	}
124  	case SDS_TYPE_64: {
125  		SDS_HDR_VAR(64, s);
126  		return sh->alloc - sh->len;
127  	}
128  	}
129  	return 0;
130  }
131  static inline void sdssetlen(sds s, size_t newlen) {
132  	unsigned char flags = s[-1];
133  	switch (flags&SDS_TYPE_MASK) {
134  	case SDS_TYPE_5:
135  	{
136  		unsigned char *fp = ((unsigned char*)s) - 1;
137  		*fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
138  	}
139  	break;
140  	case SDS_TYPE_8:
141  		SDS_HDR(8, s)->len = newlen;
142  		break;
143  	case SDS_TYPE_16:
144  		SDS_HDR(16, s)->len = newlen;
145  		break;
146  	case SDS_TYPE_32:
147  		SDS_HDR(32, s)->len = newlen;
148  		break;
149  	case SDS_TYPE_64:
150  		SDS_HDR(64, s)->len = newlen;
151  		break;
152  	}
153  }
154  static inline void sdsinclen(sds s, size_t inc) {
155  	unsigned char flags = s[-1];
156  	switch (flags&SDS_TYPE_MASK) {
157  	case SDS_TYPE_5:
158  	{
159  		unsigned char *fp = ((unsigned char*)s) - 1;
160  		unsigned char newlen = SDS_TYPE_5_LEN(flags) + inc;
161  		*fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
162  	}
163  	break;
164  	case SDS_TYPE_8:
165  		SDS_HDR(8, s)->len += inc;
166  		break;
167  	case SDS_TYPE_16:
168  		SDS_HDR(16, s)->len += inc;
169  		break;
170  	case SDS_TYPE_32:
171  		SDS_HDR(32, s)->len += inc;
172  		break;
173  	case SDS_TYPE_64:
174  		SDS_HDR(64, s)->len += inc;
175  		break;
176  	}
177  }
178  static inline size_t sdsalloc(const sds s) {
179  	unsigned char flags = s[-1];
180  	switch (flags&SDS_TYPE_MASK) {
181  	case SDS_TYPE_5:
182  		return SDS_TYPE_5_LEN(flags);
183  	case SDS_TYPE_8:
184  		return SDS_HDR(8, s)->alloc;
185  	case SDS_TYPE_16:
186  		return SDS_HDR(16, s)->alloc;
187  	case SDS_TYPE_32:
188  		return SDS_HDR(32, s)->alloc;
189  	case SDS_TYPE_64:
190  		return SDS_HDR(64, s)->alloc;
191  	}
192  	return 0;
193  }
194  static inline void sdssetalloc(sds s, size_t newlen) {
195  	unsigned char flags = s[-1];
196  	switch (flags&SDS_TYPE_MASK) {
197  	case SDS_TYPE_5:
198  		break;
199  	case SDS_TYPE_8:
200  		SDS_HDR(8, s)->alloc = newlen;
201  		break;
202  	case SDS_TYPE_16:
203  		SDS_HDR(16, s)->alloc = newlen;
204  		break;
205  	case SDS_TYPE_32:
206  		SDS_HDR(32, s)->alloc = newlen;
207  		break;
208  	case SDS_TYPE_64:
209  		SDS_HDR(64, s)->alloc = newlen;
210  		break;
211  	}
212  }
213  sds sdsnewlen(const void *init, size_t initlen);
214  sds sdsnew(const char *init);
215  sds sdsempty(void);
216  sds sdsdup(const sds s);
217  void sdsfree(sds s);
218  sds sdsgrowzero(sds s, size_t len);
219  sds sdscatlen(sds s, const void *t, size_t len);
220  sds sdscat(sds s, const char *t);
221  sds sdscatsds(sds s, const sds t);
222  sds sdscpylen(sds s, const char *t, size_t len);
223  sds sdscpy(sds s, const char *t);
224  sds sdscatvprintf(sds s, const char *fmt, va_list ap);
225  #ifdef __GNUC__
226  sds sdscatprintf(sds s, const char *fmt, ...)
227  __attribute__((format(printf, 2, 3)));
228  #else
229  sds sdscatprintf(sds s, const char *fmt, ...);
230  #endif
231  sds sdscatfmt(sds s, char const *fmt, ...);
232  sds sdstrim(sds s, const char *cset);
233  void sdsrange(sds s, int start, int end);
234  void sdsupdatelen(sds s);
235  void sdsclear(sds s);
236  int sdscmp(const sds s1, const sds s2);
237  sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);
238  void sdsfreesplitres(sds *tokens, int count);
239  void sdstolower(sds s);
240  void sdstoupper(sds s);
<span onclick='openModal()' class='match'>241  sds sdsfromlonglong(PORT_LONGLONG value);
242  sds sdscatrepr(sds s, const char *p, size_t len);
243  sds *sdssplitargs(const char *line, int *argc);
244  sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);
245  sds sdsjoin(char **argv, int argc, char *sep);
246  sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);
247  sds sdsMakeRoomFor(sds s, size_t addlen);
248  void sdsIncrLen(sds s, int incr);
</span>249  sds sdsRemoveFreeSpace(sds s);
250  size_t sdsAllocSize(sds s);
251  void *sdsAllocPtr(sds s);
252  void *sds_malloc(size_t size);
253  void *sds_realloc(void *ptr, size_t size);
254  void sds_free(void *ptr);
255  #ifdef REDIS_TEST
256  int sdsTest(int argc, char *argv[]);
257  #endif
258  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds_38.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds.h</div>
                </div>
                <div class="column column_space"><pre><code>239  sds sdsfromlonglong(PORT_LONGLONG value);
240  sds sdscatrepr(sds s, const char *p, size_t len);
241  sds *sdssplitargs(const char *line, int *argc);
242  sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);
243  sds sdsjoin(char **argv, int argc, char *sep);
244  sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);
245  sds sdsMakeRoomFor(sds s, size_t addlen);
246  void sdsIncrLen(sds s, ssize_t incr);
</pre></code></div>
                <div class="column column_space"><pre><code>241  sds sdsfromlonglong(PORT_LONGLONG value);
242  sds sdscatrepr(sds s, const char *p, size_t len);
243  sds *sdssplitargs(const char *line, int *argc);
244  sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);
245  sds sdsjoin(char **argv, int argc, char *sep);
246  sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);
247  sds sdsMakeRoomFor(sds s, size_t addlen);
248  void sdsIncrLen(sds s, int incr);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    