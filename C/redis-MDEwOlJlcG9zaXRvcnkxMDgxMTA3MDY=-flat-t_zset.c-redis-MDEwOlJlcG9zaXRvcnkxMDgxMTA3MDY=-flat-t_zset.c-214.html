
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 171, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_zset.c</h3>
            <pre><code>1  #include &quot;server.h&quot;
2  #include &lt;math.h&gt;
3  #ifdef _WIN32
4  #define bzero(b,len) (memset((b), &#x27;\0&#x27;, (len)), (void) 0)
5  #endif
6  int zslLexValueGteMin(sds value, zlexrangespec *spec);
7  int zslLexValueLteMax(sds value, zlexrangespec *spec);
8  zskiplistNode *zslCreateNode(int level, double score, sds ele) {
9      zskiplistNode *zn =
10          zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
11      zn-&gt;score = score;
12      zn-&gt;ele = ele;
13      return zn;
14  }
15  zskiplist *zslCreate(void) {
16      int j;
17      zskiplist *zsl;
18      zsl = zmalloc(sizeof(*zsl));
19      zsl-&gt;level = 1;
20      zsl-&gt;length = 0;
21      zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
22      for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) {
23          zsl-&gt;header-&gt;level[j].forward = NULL;
24          zsl-&gt;header-&gt;level[j].span = 0;
25      }
26      zsl-&gt;header-&gt;backward = NULL;
27      zsl-&gt;tail = NULL;
28      return zsl;
29  }
30  void zslFreeNode(zskiplistNode *node) {
31      sdsfree(node-&gt;ele);
32      zfree(node);
33  }
34  void zslFree(zskiplist *zsl) {
35      zskiplistNode *node = zsl-&gt;header-&gt;level[0].forward, *next;
36      zfree(zsl-&gt;header);
37      while(node) {
38          next = node-&gt;level[0].forward;
39          zslFreeNode(node);
40          node = next;
41      }
42      zfree(zsl);
43  }
44  int zslRandomLevel(void) {
45      int level = 1;
46      while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))
47          level += 1;
48      return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
49  }
50  zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
51      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
52      unsigned int rank[ZSKIPLIST_MAXLEVEL];
53      int i, level;
54      serverAssert(!isnan(score));
55      x = zsl-&gt;header;
56      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
57          rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];
58          while (x-&gt;level[i].forward &amp;&amp;
59                  (x-&gt;level[i].forward-&gt;score &lt; score ||
60                      (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
61                      sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
62          {
63              rank[i] += x-&gt;level[i].span;
64              x = x-&gt;level[i].forward;
65          }
66          update[i] = x;
67      }
68      level = zslRandomLevel();
69      if (level &gt; zsl-&gt;level) {
70          for (i = zsl-&gt;level; i &lt; level; i++) {
71              rank[i] = 0;
72              update[i] = zsl-&gt;header;
73              update[i]-&gt;level[i].span = zsl-&gt;length;
74          }
75          zsl-&gt;level = level;
76      }
77      x = zslCreateNode(level,score,ele);
78      for (i = 0; i &lt; level; i++) {
79          x-&gt;level[i].forward = update[i]-&gt;level[i].forward;
80          update[i]-&gt;level[i].forward = x;
81          x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);
82          update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;
83      }
84      for (i = level; i &lt; zsl-&gt;level; i++) {
85          update[i]-&gt;level[i].span++;
86      }
87      x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];
88      if (x-&gt;level[0].forward)
89          x-&gt;level[0].forward-&gt;backward = x;
90      else
91          zsl-&gt;tail = x;
92      zsl-&gt;length++;
93      return x;
94  }
95  void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
96      int i;
97      for (i = 0; i &lt; zsl-&gt;level; i++) {
98          if (update[i]-&gt;level[i].forward == x) {
99              update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;
100              update[i]-&gt;level[i].forward = x-&gt;level[i].forward;
101          } else {
102              update[i]-&gt;level[i].span -= 1;
103          }
104      }
105      if (x-&gt;level[0].forward) {
106          x-&gt;level[0].forward-&gt;backward = x-&gt;backward;
107      } else {
108          zsl-&gt;tail = x-&gt;backward;
109      }
110      while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)
111          zsl-&gt;level--;
112      zsl-&gt;length--;
113  }
114  int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
115      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
116      int i;
117      x = zsl-&gt;header;
118      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
119          while (x-&gt;level[i].forward &amp;&amp;
120                  (x-&gt;level[i].forward-&gt;score &lt; score ||
121                      (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
122                       sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
123          {
124              x = x-&gt;level[i].forward;
125          }
126          update[i] = x;
127      }
128      x = x-&gt;level[0].forward;
129      if (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
130          zslDeleteNode(zsl, x, update);
131          if (!node)
132              zslFreeNode(x);
133          else
134              *node = x;
135          return 1;
136      }
137      return 0; &amp;bsol;* not found */
138  }
139  zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {
140      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
141      int i;
142      x = zsl-&gt;header;
143      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
144          while (x-&gt;level[i].forward &amp;&amp;
145                  (x-&gt;level[i].forward-&gt;score &lt; curscore ||
146                      (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;
147                       sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
148          {
149              x = x-&gt;level[i].forward;
150          }
151          update[i] = x;
152      }
153      x = x-&gt;level[0].forward;
154      serverAssert(x &amp;&amp; curscore == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0);
155      if ((x-&gt;backward == NULL || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;
156          (x-&gt;level[0].forward == NULL || x-&gt;level[0].forward-&gt;score &gt; newscore))
157      {
158          x-&gt;score = newscore;
159          return x;
160      }
161      zslDeleteNode(zsl, x, update);
162      zskiplistNode *newnode = zslInsert(zsl,newscore,x-&gt;ele);
163      x-&gt;ele = NULL;
164      zslFreeNode(x);
165      return newnode;
166  }
167  int zslValueGteMin(double value, zrangespec *spec) {
168      return spec-&gt;minex ? (value &gt; spec-&gt;min) : (value &gt;= spec-&gt;min);
169  }
170  int zslValueLteMax(double value, zrangespec *spec) {
171      return spec-&gt;maxex ? (value &lt; spec-&gt;max) : (value &lt;= spec-&gt;max);
172  }
173  int zslIsInRange(zskiplist *zsl, zrangespec *range) {
174      zskiplistNode *x;
175      if (range-&gt;min &gt; range-&gt;max ||
176              (range-&gt;min == range-&gt;max &amp;&amp; (range-&gt;minex || range-&gt;maxex)))
177          return 0;
178      x = zsl-&gt;tail;
179      if (x == NULL || !zslValueGteMin(x-&gt;score,range))
180          return 0;
181      x = zsl-&gt;header-&gt;level[0].forward;
182      if (x == NULL || !zslValueLteMax(x-&gt;score,range))
183          return 0;
184      return 1;
185  }
186  zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
187      zskiplistNode *x;
188      int i;
189      if (!zslIsInRange(zsl,range)) return NULL;
190      x = zsl-&gt;header;
191      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
192          while (x-&gt;level[i].forward &amp;&amp;
193              !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))
<span onclick='openModal()' class='match'>194                  x = x-&gt;level[i].forward;
195      }
196      x = x-&gt;level[0].forward;
197      serverAssert(x != NULL);
198      if (!zslValueLteMax(x-&gt;score,range)) return NULL;
199      return x;
200  }
201  zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
202      zskiplistNode *x;
203      int i;
204      if (!zslIsInRange(zsl,range)) return NULL;
205      x = zsl-&gt;header;
206      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
207          while (x-&gt;level[i].forward &amp;&amp;
208              zslValueLteMax(x-&gt;level[i].forward-&gt;score,range))
209                  x = x-&gt;level[i].forward;
210      }
211      serverAssert(x != NULL);
212      if (!zslValueGteMin(x-&gt;score,range)) return NULL;
213      return x;
214  }
215  PORT_ULONG zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
</span>216      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
217      PORT_ULONG removed = 0;
218      int i;
219      x = zsl-&gt;header;
220      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
221          while (x-&gt;level[i].forward &amp;&amp; (range-&gt;minex ?
222              x-&gt;level[i].forward-&gt;score &lt;= range-&gt;min :
223              x-&gt;level[i].forward-&gt;score &lt; range-&gt;min))
224                  x = x-&gt;level[i].forward;
225          update[i] = x;
226      }
227      x = x-&gt;level[0].forward;
228      while (x &amp;&amp;
229             (range-&gt;maxex ? x-&gt;score &lt; range-&gt;max : x-&gt;score &lt;= range-&gt;max))
230      {
231          zskiplistNode *next = x-&gt;level[0].forward;
232          zslDeleteNode(zsl,x,update);
233          dictDelete(dict,x-&gt;ele);
234          zslFreeNode(x); &amp;bsol;* Here is where x-&gt;ele is actually released. */
235          removed++;
236          x = next;
237      }
238      return removed;
239  }
240  PORT_ULONG zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {
241      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
242      PORT_ULONG removed = 0;
243      int i;
244      x = zsl-&gt;header;
245      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
246          while (x-&gt;level[i].forward &amp;&amp;
247              !zslLexValueGteMin(x-&gt;level[i].forward-&gt;ele,range))
248                  x = x-&gt;level[i].forward;
249          update[i] = x;
250      }
251      x = x-&gt;level[0].forward;
252      while (x &amp;&amp; zslLexValueLteMax(x-&gt;ele,range)) {
253          zskiplistNode *next = x-&gt;level[0].forward;
254          zslDeleteNode(zsl,x,update);
255          dictDelete(dict,x-&gt;ele);
256          zslFreeNode(x); &amp;bsol;* Here is where x-&gt;ele is actually released. */
257          removed++;
258          x = next;
259      }
260      return removed;
261  }
262  PORT_ULONG zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {
263      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
264      PORT_ULONG traversed = 0, removed = 0;
265      int i;
266      x = zsl-&gt;header;
267      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
268          while (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt; start) {
269              traversed += x-&gt;level[i].span;
270              x = x-&gt;level[i].forward;
271          }
272          update[i] = x;
273      }
274      traversed++;
275      x = x-&gt;level[0].forward;
276      while (x &amp;&amp; traversed &lt;= end) {
277          zskiplistNode *next = x-&gt;level[0].forward;
278          zslDeleteNode(zsl,x,update);
279          dictDelete(dict,x-&gt;ele);
280          zslFreeNode(x);
281          removed++;
282          traversed++;
283          x = next;
284      }
285      return removed;
286  }
287  PORT_ULONG zslGetRank(zskiplist *zsl, double score, sds ele) {
288      zskiplistNode *x;
289      PORT_ULONG rank = 0;
290      int i;
291      x = zsl-&gt;header;
292      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
293          while (x-&gt;level[i].forward &amp;&amp;
294              (x-&gt;level[i].forward-&gt;score &lt; score ||
295                  (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
296                  sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= 0))) {
297              rank += x-&gt;level[i].span;
298              x = x-&gt;level[i].forward;
299          }
300          if (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
301              return rank;
302          }
303      }
304      return 0;
305  }
306  zskiplistNode* zslGetElementByRank(zskiplist *zsl, PORT_ULONG rank) {
307      zskiplistNode *x;
308      PORT_ULONG traversed = 0;
309      int i;
310      x = zsl-&gt;header;
311      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
312          while (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)
313          {
314              traversed += x-&gt;level[i].span;
315              x = x-&gt;level[i].forward;
316          }
317          if (traversed == rank) {
318              return x;
319          }
320      }
321      return NULL;
322  }
323  static int zslParseRange(robj *min, robj *max, zrangespec *spec) {
324      char *eptr;
325      spec-&gt;minex = spec-&gt;maxex = 0;
326      if (min-&gt;encoding == OBJ_ENCODING_INT) {
327          spec-&gt;min = (PORT_LONG)min-&gt;ptr;
328      } else {
329          if (((char*)min-&gt;ptr)[0] == &#x27;(&#x27;) {
330              spec-&gt;min = strtod((char*)min-&gt;ptr+1,&amp;eptr);
331              if (eptr[0] != &#x27;\0&#x27; || isnan(spec-&gt;min)) return C_ERR;
332              spec-&gt;minex = 1;
333          } else {
334              spec-&gt;min = strtod((char*)min-&gt;ptr,&amp;eptr);
335              if (eptr[0] != &#x27;\0&#x27; || isnan(spec-&gt;min)) return C_ERR;
336          }
337      }
338      if (max-&gt;encoding == OBJ_ENCODING_INT) {
339          spec-&gt;max = (PORT_LONG)max-&gt;ptr;
340      } else {
341          if (((char*)max-&gt;ptr)[0] == &#x27;(&#x27;) {
342              spec-&gt;max = strtod((char*)max-&gt;ptr+1,&amp;eptr);
343              if (eptr[0] != &#x27;\0&#x27; || isnan(spec-&gt;max)) return C_ERR;
344              spec-&gt;maxex = 1;
345          } else {
346              spec-&gt;max = strtod((char*)max-&gt;ptr,&amp;eptr);
347              if (eptr[0] != &#x27;\0&#x27; || isnan(spec-&gt;max)) return C_ERR;
348          }
349      }
350      return C_OK;
351  }
352  int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
353      char *c = item-&gt;ptr;
354      switch(c[0]) {
355      case &#x27;+&#x27;:
356          if (c[1] != &#x27;\0&#x27;) return C_ERR;
357          *ex = 1;
358          *dest = shared.maxstring;
359          return C_OK;
360      case &#x27;-&#x27;:
361          if (c[1] != &#x27;\0&#x27;) return C_ERR;
362          *ex = 1;
363          *dest = shared.minstring;
364          return C_OK;
365      case &#x27;(&#x27;:
366          *ex = 1;
367          *dest = sdsnewlen(c+1,sdslen(c)-1);
368          return C_OK;
369      case &#x27;[&#x27;:
370          *ex = 0;
371          *dest = sdsnewlen(c+1,sdslen(c)-1);
372          return C_OK;
373      default:
374          return C_ERR;
375      }
376  }
377  void zslFreeLexRange(zlexrangespec *spec) {
378      if (spec-&gt;min != shared.minstring &amp;&amp;
379          spec-&gt;min != shared.maxstring) sdsfree(spec-&gt;min);
380      if (spec-&gt;max != shared.minstring &amp;&amp;
381          spec-&gt;max != shared.maxstring) sdsfree(spec-&gt;max);
382  }
383  int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
384      if (min-&gt;encoding == OBJ_ENCODING_INT ||
385          max-&gt;encoding == OBJ_ENCODING_INT) return C_ERR;
386      spec-&gt;min = spec-&gt;max = NULL;
387      if (zslParseLexRangeItem(min, &amp;spec-&gt;min, &amp;spec-&gt;minex) == C_ERR ||
388          zslParseLexRangeItem(max, &amp;spec-&gt;max, &amp;spec-&gt;maxex) == C_ERR) {
389          zslFreeLexRange(spec);
390          return C_ERR;
391      } else {
392          return C_OK;
393      }
394  }
395  int sdscmplex(sds a, sds b) {
396      if (a == b) return 0;
397      if (a == shared.minstring || b == shared.maxstring) return -1;
398      if (a == shared.maxstring || b == shared.minstring) return 1;
399      return sdscmp(a,b);
400  }
401  int zslLexValueGteMin(sds value, zlexrangespec *spec) {
402      return spec-&gt;minex ?
403          (sdscmplex(value,spec-&gt;min) &gt; 0) :
404          (sdscmplex(value,spec-&gt;min) &gt;= 0);
405  }
406  int zslLexValueLteMax(sds value, zlexrangespec *spec) {
407      return spec-&gt;maxex ?
408          (sdscmplex(value,spec-&gt;max) &lt; 0) :
409          (sdscmplex(value,spec-&gt;max) &lt;= 0);
410  }
411  int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
412      zskiplistNode *x;
413      int cmp = sdscmplex(range-&gt;min,range-&gt;max);
414      if (cmp &gt; 0 || (cmp == 0 &amp;&amp; (range-&gt;minex || range-&gt;maxex)))
415          return 0;
416      x = zsl-&gt;tail;
417      if (x == NULL || !zslLexValueGteMin(x-&gt;ele,range))
418          return 0;
419      x = zsl-&gt;header-&gt;level[0].forward;
420      if (x == NULL || !zslLexValueLteMax(x-&gt;ele,range))
421          return 0;
422      return 1;
423  }
424  zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
425      zskiplistNode *x;
426      int i;
427      if (!zslIsInLexRange(zsl,range)) return NULL;
428      x = zsl-&gt;header;
429      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
430          while (x-&gt;level[i].forward &amp;&amp;
431              !zslLexValueGteMin(x-&gt;level[i].forward-&gt;ele,range))
432                  x = x-&gt;level[i].forward;
433      }
434      x = x-&gt;level[0].forward;
435      serverAssert(x != NULL);
436      if (!zslLexValueLteMax(x-&gt;ele,range)) return NULL;
437      return x;
438  }
439  zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
440      zskiplistNode *x;
441      int i;
442      if (!zslIsInLexRange(zsl,range)) return NULL;
443      x = zsl-&gt;header;
444      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
445          while (x-&gt;level[i].forward &amp;&amp;
446              zslLexValueLteMax(x-&gt;level[i].forward-&gt;ele,range))
447                  x = x-&gt;level[i].forward;
448      }
449      serverAssert(x != NULL);
450      if (!zslLexValueGteMin(x-&gt;ele,range)) return NULL;
451      return x;
452  }
453  double zzlGetScore(unsigned char *sptr) {
454      unsigned char *vstr;
455      unsigned int vlen;
456      PORT_LONGLONG vlong;
457      char buf[128];
458      double score;
459      serverAssert(sptr != NULL);
460      serverAssert(ziplistGet(sptr,&amp;vstr,&amp;vlen,&amp;vlong));
461      if (vstr) {
462          memcpy(buf,vstr,vlen);
463          buf[vlen] = &#x27;\0&#x27;;
464          score = strtod(buf,NULL);
465      } else {
466          score = (double)vlong;                                                  WIN_PORT_FIX &amp;bsol;* cast (double) */
467      }
468      return score;
469  }
470  sds ziplistGetObject(unsigned char *sptr) {
471      unsigned char *vstr;
472      unsigned int vlen;
473      PORT_LONGLONG vlong;
474      serverAssert(sptr != NULL);
475      serverAssert(ziplistGet(sptr,&amp;vstr,&amp;vlen,&amp;vlong));
476      if (vstr) {
477          return sdsnewlen((char*)vstr,vlen);
478      } else {
479          return sdsfromlonglong(vlong);
480      }
481  }
482  int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {
483      unsigned char *vstr;
484      unsigned int vlen;
485      PORT_LONGLONG vlong;
486      unsigned char vbuf[32];
487      int minlen, cmp;
488      serverAssert(ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
489      if (vstr == NULL) {
490          vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);
491          vstr = vbuf;
492      }
493      minlen = (vlen &lt; clen) ? vlen : clen;
494      cmp = memcmp(vstr,cstr,minlen);
495      if (cmp == 0) return vlen-clen;
496      return cmp;
497  }
498  unsigned int zzlLength(unsigned char *zl) {
499      return ziplistLen(zl)/2;
500  }
501  void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
502      unsigned char *l_eptr, *l_sptr;                                             WIN_PORT_FIX &amp;bsol;* compiler error: _sptr -&gt; l_sptr */
503      serverAssert(*eptr != NULL &amp;&amp; *sptr != NULL);
504      l_eptr = ziplistNext(zl, *sptr);
505      if (l_eptr != NULL) {
506          l_sptr = ziplistNext(zl, l_eptr);
507          serverAssert(l_sptr != NULL);
508      } else {
509          l_sptr = NULL;
510      }
511      *eptr = l_eptr;
512      *sptr = l_sptr;
513  }
514  void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
515      unsigned char *l_eptr, *l_sptr;                                             WIN_PORT_FIX &amp;bsol;* compiler error: _sptr -&gt; l_sptr */
516      serverAssert(*eptr != NULL &amp;&amp; *sptr != NULL);
517      l_sptr = ziplistPrev(zl, *eptr);
518      if (l_sptr != NULL) {
519          l_eptr = ziplistPrev(zl, l_sptr);
520          serverAssert(l_eptr != NULL);
521      } else {
522          l_eptr = NULL;
523      }
524      *eptr = l_eptr;
525      *sptr = l_sptr;
526  }
527  int zzlIsInRange(unsigned char *zl, zrangespec *range) {
528      unsigned char *p;
529      double score;
530      if (range-&gt;min &gt; range-&gt;max ||
531              (range-&gt;min == range-&gt;max &amp;&amp; (range-&gt;minex || range-&gt;maxex)))
532          return 0;
533      p = ziplistIndex(zl,-1); &amp;bsol;* Last score. */
534      if (p == NULL) return 0; &amp;bsol;* Empty sorted set */
535      score = zzlGetScore(p);
536      if (!zslValueGteMin(score,range))
537          return 0;
538      p = ziplistIndex(zl,1); &amp;bsol;* First score. */
539      serverAssert(p != NULL);
540      score = zzlGetScore(p);
541      if (!zslValueLteMax(score,range))
542          return 0;
543      return 1;
544  }
545  unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
546      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
547      double score;
548      if (!zzlIsInRange(zl,range)) return NULL;
549      while (eptr != NULL) {
550          sptr = ziplistNext(zl,eptr);
551          serverAssert(sptr != NULL);
552          score = zzlGetScore(sptr);
553          if (zslValueGteMin(score,range)) {
554              if (zslValueLteMax(score,range))
555                  return eptr;
556              return NULL;
557          }
558          eptr = ziplistNext(zl,sptr);
559      }
560      return NULL;
561  }
562  unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
563      unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
564      double score;
565      if (!zzlIsInRange(zl,range)) return NULL;
566      while (eptr != NULL) {
567          sptr = ziplistNext(zl,eptr);
568          serverAssert(sptr != NULL);
569          score = zzlGetScore(sptr);
570          if (zslValueLteMax(score,range)) {
571              if (zslValueGteMin(score,range))
572                  return eptr;
573              return NULL;
574          }
575          sptr = ziplistPrev(zl,eptr);
576          if (sptr != NULL)
577              serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
578          else
579              eptr = NULL;
580      }
581      return NULL;
582  }
583  int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
584      sds value = ziplistGetObject(p);
585      int res = zslLexValueGteMin(value,spec);
586      sdsfree(value);
587      return res;
588  }
589  int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
590      sds value = ziplistGetObject(p);
591      int res = zslLexValueLteMax(value,spec);
592      sdsfree(value);
593      return res;
594  }
595  int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
596      unsigned char *p;
597      int cmp = sdscmplex(range-&gt;min,range-&gt;max);
598      if (cmp &gt; 0 || (cmp == 0 &amp;&amp; (range-&gt;minex || range-&gt;maxex)))
599          return 0;
600      p = ziplistIndex(zl,-2); &amp;bsol;* Last element. */
601      if (p == NULL) return 0;
602      if (!zzlLexValueGteMin(p,range))
603          return 0;
604      p = ziplistIndex(zl,0); &amp;bsol;* First element. */
605      serverAssert(p != NULL);
606      if (!zzlLexValueLteMax(p,range))
607          return 0;
608      return 1;
609  }
610  unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
611      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
612      if (!zzlIsInLexRange(zl,range)) return NULL;
613      while (eptr != NULL) {
614          if (zzlLexValueGteMin(eptr,range)) {
615              if (zzlLexValueLteMax(eptr,range))
616                  return eptr;
617              return NULL;
618          }
619          sptr = ziplistNext(zl,eptr); &amp;bsol;* This element score. Skip it. */
620          serverAssert(sptr != NULL);
621          eptr = ziplistNext(zl,sptr); &amp;bsol;* Next element. */
622      }
623      return NULL;
624  }
625  unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
626      unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
627      if (!zzlIsInLexRange(zl,range)) return NULL;
628      while (eptr != NULL) {
629          if (zzlLexValueLteMax(eptr,range)) {
630              if (zzlLexValueGteMin(eptr,range))
631                  return eptr;
632              return NULL;
633          }
634          sptr = ziplistPrev(zl,eptr);
635          if (sptr != NULL)
636              serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
637          else
638              eptr = NULL;
639      }
640      return NULL;
641  }
642  unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {
643      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
644      while (eptr != NULL) {
645          sptr = ziplistNext(zl,eptr);
646          serverAssert(sptr != NULL);
647          if (ziplistCompare(eptr,(unsigned char*)ele,(unsigned int)sdslen(ele))) {     WIN_PORT_FIX &amp;bsol;* unsigned int */
648              if (score != NULL) *score = zzlGetScore(sptr);
649              return eptr;
650          }
651          eptr = ziplistNext(zl,sptr);
652      }
653      return NULL;
654  }
655  unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
656      unsigned char *p = eptr;
657      zl = ziplistDelete(zl,&amp;p);
658      zl = ziplistDelete(zl,&amp;p);
659      return zl;
660  }
661  unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {
662      unsigned char *sptr;
663      char scorebuf[128];
664      int scorelen;
665      size_t offset;
666      scorelen = d2string(scorebuf,sizeof(scorebuf),score);
667      if (eptr == NULL) {
668          zl = ziplistPush(zl,(unsigned char*)ele,(unsigned int)sdslen(ele),ZIPLIST_TAIL); WIN_PORT_FIX &amp;bsol;* unsigned int */
669          zl = ziplistPush(zl,(unsigned char*)scorebuf,scorelen,ZIPLIST_TAIL);
670      } else {
671          offset = eptr-zl;
672          zl = ziplistInsert(zl,eptr,(unsigned char*)ele,(unsigned int)sdslen(ele));    WIN_PORT_FIX &amp;bsol;* unsigned int */
673          eptr = zl+offset;
674          serverAssert((sptr = ziplistNext(zl,eptr)) != NULL);
675          zl = ziplistInsert(zl,sptr,(unsigned char*)scorebuf,scorelen);
676      }
677      return zl;
678  }
679  unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
680      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
681      double s;
682      while (eptr != NULL) {
683          sptr = ziplistNext(zl,eptr);
684          serverAssert(sptr != NULL);
685          s = zzlGetScore(sptr);
686          if (s &gt; score) {
687              zl = zzlInsertAt(zl,eptr,ele,score);
688              break;
689          } else if (s == score) {
690              if (zzlCompareElements(eptr,(unsigned char*)ele,(unsigned int)sdslen(ele)) &gt; 0) { WIN_PORT_FIX &amp;bsol;* unsigned int */
691                  zl = zzlInsertAt(zl,eptr,ele,score);
692                  break;
693              }
694          }
695          eptr = ziplistNext(zl,sptr);
696      }
697      if (eptr == NULL)
698          zl = zzlInsertAt(zl,NULL,ele,score);
699      return zl;
700  }
701  unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, PORT_ULONG *deleted) {
702      unsigned char *eptr, *sptr;
703      double score;
704      PORT_ULONG num = 0;
705      if (deleted != NULL) *deleted = 0;
706      eptr = zzlFirstInRange(zl,range);
707      if (eptr == NULL) return zl;
708      while ((sptr = ziplistNext(zl,eptr)) != NULL) {
709          score = zzlGetScore(sptr);
710          if (zslValueLteMax(score,range)) {
711              zl = ziplistDelete(zl,&amp;eptr);
712              zl = ziplistDelete(zl,&amp;eptr);
713              num++;
714          } else {
715              break;
716          }
717      }
718      if (deleted != NULL) *deleted = num;
719      return zl;
720  }
721  unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, PORT_ULONG *deleted) {
722      unsigned char *eptr, *sptr;
723      PORT_ULONG num = 0;
724      if (deleted != NULL) *deleted = 0;
725      eptr = zzlFirstInLexRange(zl,range);
726      if (eptr == NULL) return zl;
727      while ((sptr = ziplistNext(zl,eptr)) != NULL) {
728          if (zzlLexValueLteMax(eptr,range)) {
729              zl = ziplistDelete(zl,&amp;eptr);
730              zl = ziplistDelete(zl,&amp;eptr);
731              num++;
732          } else {
733              break;
734          }
735      }
736      if (deleted != NULL) *deleted = num;
737      return zl;
738  }
739  unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, PORT_ULONG *deleted) {
740      unsigned int num = (end-start)+1;
741      if (deleted) *deleted = num;
742      zl = ziplistDeleteRange(zl,2*(start-1),2*num);
743      return zl;
744  }
745  PORT_ULONG zsetLength(const robj *zobj) {
746      PORT_ULONG length = 0;
747      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
748          length = zzlLength(zobj-&gt;ptr);
749      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
750          length = (PORT_ULONG) ((const zset*)zobj-&gt;ptr)-&gt;zsl-&gt;length;                         WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONG) */
751      } else {
752          serverPanic(&quot;Unknown sorted set encoding&quot;);
753      }
754      return length;
755  }
756  void zsetConvert(robj *zobj, int encoding) {
757      zset *zs;
758      zskiplistNode *node, *next;
759      sds ele;
760      double score;
761      if (zobj-&gt;encoding == encoding) return;
762      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
763          unsigned char *zl = zobj-&gt;ptr;
764          unsigned char *eptr, *sptr;
765          unsigned char *vstr;
766          unsigned int vlen;
767          PORT_LONGLONG vlong;
768          if (encoding != OBJ_ENCODING_SKIPLIST)
769              serverPanic(&quot;Unknown target encoding&quot;);
770          zs = zmalloc(sizeof(*zs));
771          zs-&gt;dict = dictCreate(&amp;zsetDictType,NULL);
772          zs-&gt;zsl = zslCreate();
773          eptr = ziplistIndex(zl,0);
774          serverAssertWithInfo(NULL,zobj,eptr != NULL);
775          sptr = ziplistNext(zl,eptr);
776          serverAssertWithInfo(NULL,zobj,sptr != NULL);
777          while (eptr != NULL) {
778              score = zzlGetScore(sptr);
779              serverAssertWithInfo(NULL,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
780              if (vstr == NULL)
781                  ele = sdsfromlonglong(vlong);
782              else
783                  ele = sdsnewlen((char*)vstr,vlen);
784              node = zslInsert(zs-&gt;zsl,score,ele);
785              serverAssert(dictAdd(zs-&gt;dict,ele,&amp;node-&gt;score) == DICT_OK);
786              zzlNext(zl,&amp;eptr,&amp;sptr);
787          }
788          zfree(zobj-&gt;ptr);
789          zobj-&gt;ptr = zs;
790          zobj-&gt;encoding = OBJ_ENCODING_SKIPLIST;
791      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
792          unsigned char *zl = ziplistNew();
793          if (encoding != OBJ_ENCODING_ZIPLIST)
794              serverPanic(&quot;Unknown target encoding&quot;);
795          zs = zobj-&gt;ptr;
796          dictRelease(zs-&gt;dict);
797          node = zs-&gt;zsl-&gt;header-&gt;level[0].forward;
798          zfree(zs-&gt;zsl-&gt;header);
799          zfree(zs-&gt;zsl);
800          while (node) {
801              zl = zzlInsertAt(zl,NULL,node-&gt;ele,node-&gt;score);
802              next = node-&gt;level[0].forward;
803              zslFreeNode(node);
804              node = next;
805          }
806          zfree(zs);
807          zobj-&gt;ptr = zl;
808          zobj-&gt;encoding = OBJ_ENCODING_ZIPLIST;
809      } else {
810          serverPanic(&quot;Unknown sorted set encoding&quot;);
811      }
812  }
813  void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {
814      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) return;
815      zset *zset = zobj-&gt;ptr;
816      if (zset-&gt;zsl-&gt;length &lt;= server.zset_max_ziplist_entries &amp;&amp;
817          maxelelen &lt;= server.zset_max_ziplist_value)
818              zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);
819  }
820  int zsetScore(robj *zobj, sds member, double *score) {
821      if (!zobj || !member) return C_ERR;
822      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
823          if (zzlFind(zobj-&gt;ptr, member, score) == NULL) return C_ERR;
824      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
825          zset *zs = zobj-&gt;ptr;
826          dictEntry *de = dictFind(zs-&gt;dict, member);
827          if (de == NULL) return C_ERR;
828          *score = *(double*)dictGetVal(de);
829      } else {
830          serverPanic(&quot;Unknown sorted set encoding&quot;);
831      }
832      return C_OK;
833  }
834  int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore) {
835      int incr = (*flags &amp; ZADD_INCR) != 0;
836      int nx = (*flags &amp; ZADD_NX) != 0;
837      int xx = (*flags &amp; ZADD_XX) != 0;
838      *flags = 0; &amp;bsol;* We&#x27;ll return our response flags. */
839      double curscore;
840      if (isnan(score)) {
841          *flags = ZADD_NAN;
842          return 0;
843      }
844      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
845          unsigned char *eptr;
846          if ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != NULL) {
847              if (nx) {
848                  *flags |= ZADD_NOP;
849                  return 1;
850              }
851              if (incr) {
852                  score += curscore;
853                  if (isnan(score)) {
854                      *flags |= ZADD_NAN;
855                      return 0;
856                  }
857                  if (newscore) *newscore = score;
858              }
859              if (score != curscore) {
860                  zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);
861                  zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);
862                  *flags |= ZADD_UPDATED;
863              }
864              return 1;
865          } else if (!xx) {
866              zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);
867              if (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries ||
868                  sdslen(ele) &gt; server.zset_max_ziplist_value)
869                  zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
870              if (newscore) *newscore = score;
871              *flags |= ZADD_ADDED;
872              return 1;
873          } else {
874              *flags |= ZADD_NOP;
875              return 1;
876          }
877      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
878          zset *zs = zobj-&gt;ptr;
879          zskiplistNode *znode;
880          dictEntry *de;
881          de = dictFind(zs-&gt;dict,ele);
882          if (de != NULL) {
883              if (nx) {
884                  *flags |= ZADD_NOP;
885                  return 1;
886              }
887              curscore = *(double*)dictGetVal(de);
888              if (incr) {
889                  score += curscore;
890                  if (isnan(score)) {
891                      *flags |= ZADD_NAN;
892                      return 0;
893                  }
894                  if (newscore) *newscore = score;
895              }
896              if (score != curscore) {
897                  znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score);
898                  dictGetVal(de) = &amp;znode-&gt;score; &amp;bsol;* Update score ptr. */
899                  *flags |= ZADD_UPDATED;
900              }
901              return 1;
902          } else if (!xx) {
903              ele = sdsdup(ele);
904              znode = zslInsert(zs-&gt;zsl,score,ele);
905              serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);
906              *flags |= ZADD_ADDED;
907              if (newscore) *newscore = score;
908              return 1;
909          } else {
910              *flags |= ZADD_NOP;
911              return 1;
912          }
913      } else {
914          serverPanic(&quot;Unknown sorted set encoding&quot;);
915      }
916      return 0; &amp;bsol;* Never reached. */
917  }
918  int zsetDel(robj *zobj, sds ele) {
919      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
920          unsigned char *eptr;
921          if ((eptr = zzlFind(zobj-&gt;ptr,ele,NULL)) != NULL) {
922              zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);
923              return 1;
924          }
925      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
926          zset *zs = zobj-&gt;ptr;
927          dictEntry *de;
928          double score;
929          de = dictUnlink(zs-&gt;dict,ele);
930          if (de != NULL) {
931              score = *(double*)dictGetVal(de);
932              dictFreeUnlinkedEntry(zs-&gt;dict,de);
933              int retval = zslDelete(zs-&gt;zsl,score,ele,NULL);
934              serverAssert(retval);
935              if (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);
936              return 1;
937          }
938      } else {
939          serverPanic(&quot;Unknown sorted set encoding&quot;);
940      }
941      return 0; &amp;bsol;* No such element found. */
942  }
943  PORT_LONG zsetRank(robj *zobj, sds ele, int reverse) {
944      PORT_ULONG llen;
945      PORT_ULONG rank;
946      llen = zsetLength(zobj);
947      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
948          unsigned char *zl = zobj-&gt;ptr;
949          unsigned char *eptr, *sptr;
950          eptr = ziplistIndex(zl,0);
951          serverAssert(eptr != NULL);
952          sptr = ziplistNext(zl,eptr);
953          serverAssert(sptr != NULL);
954          rank = 1;
955          while(eptr != NULL) {
956              if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele)))
957                  break;
958              rank++;
959              zzlNext(zl,&amp;eptr,&amp;sptr);
960          }
961          if (eptr != NULL) {
962              if (reverse)
963                  return llen-rank;
964              else
965                  return rank-1;
966          } else {
967              return -1;
968          }
969      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
970          zset *zs = zobj-&gt;ptr;
971          zskiplist *zsl = zs-&gt;zsl;
972          dictEntry *de;
973          double score;
974          de = dictFind(zs-&gt;dict,ele);
975          if (de != NULL) {
976              score = *(double*)dictGetVal(de);
977              rank = zslGetRank(zsl,score,ele);
978              serverAssert(rank != 0);
979              if (reverse)
980                  return llen-rank;
981              else
982                  return rank-1;
983          } else {
984              return -1;
985          }
986      } else {
987          serverPanic(&quot;Unknown sorted set encoding&quot;);
988      }
989  }
990  void zaddGenericCommand(client *c, int flags) {
991      static char *nanerr = &quot;resulting score is not a number (NaN)&quot;;
992      robj *key = c-&gt;argv[1];
993      robj *zobj;
994      sds ele;
995      double score = 0, *scores = NULL;
996      int j, elements;
997      int scoreidx = 0;
998      int added = 0;      &amp;bsol;* Number of new elements added. */
999      int updated = 0;    &amp;bsol;* Number of elements with updated score. */
1000      int processed = 0;  &amp;bsol;* Number of elements processed, may remain zero with
1001                             options like XX. */
1002      scoreidx = 2;
1003      while(scoreidx &lt; c-&gt;argc) {
1004          char *opt = c-&gt;argv[scoreidx]-&gt;ptr;
1005          if (!strcasecmp(opt,&quot;nx&quot;)) flags |= ZADD_NX;
1006          else if (!strcasecmp(opt,&quot;xx&quot;)) flags |= ZADD_XX;
1007          else if (!strcasecmp(opt,&quot;ch&quot;)) flags |= ZADD_CH;
1008          else if (!strcasecmp(opt,&quot;incr&quot;)) flags |= ZADD_INCR;
1009          else break;
1010          scoreidx++;
1011      }
1012      int incr = (flags &amp; ZADD_INCR) != 0;
1013      int nx = (flags &amp; ZADD_NX) != 0;
1014      int xx = (flags &amp; ZADD_XX) != 0;
1015      int ch = (flags &amp; ZADD_CH) != 0;
1016      elements = c-&gt;argc-scoreidx;
1017      if (elements % 2 || !elements) {
1018          addReply(c,shared.syntaxerr);
1019          return;
1020      }
1021      elements /= 2; &amp;bsol;* Now this holds the number of score-element pairs. */
1022      if (nx &amp;&amp; xx) {
1023          addReplyError(c,
1024              &quot;XX and NX options at the same time are not compatible&quot;);
1025          return;
1026      }
1027      if (incr &amp;&amp; elements &gt; 1) {
1028          addReplyError(c,
1029              &quot;INCR option supports a single increment-element pair&quot;);
1030          return;
1031      }
1032      scores = zmalloc(sizeof(double)*elements);
1033      for (j = 0; j &lt; elements; j++) {
1034          if (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*2],&amp;scores[j],NULL)
1035              != C_OK) goto cleanup;
1036      }
1037      zobj = lookupKeyWrite(c-&gt;db,key);
1038      if (zobj == NULL) {
1039          if (xx) goto reply_to_client; &amp;bsol;* No key + XX option: nothing to do. */
1040          if (server.zset_max_ziplist_entries == 0 ||
1041              server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+1]-&gt;ptr))
1042          {
1043              zobj = createZsetObject();
1044          } else {
1045              zobj = createZsetZiplistObject();
1046          }
1047          dbAdd(c-&gt;db,key,zobj);
1048      } else {
1049          if (zobj-&gt;type != OBJ_ZSET) {
1050              addReply(c,shared.wrongtypeerr);
1051              goto cleanup;
1052          }
1053      }
1054      for (j = 0; j &lt; elements; j++) {
1055          double newscore;
1056          score = scores[j];
1057          int retflags = flags;
1058          ele = c-&gt;argv[scoreidx+1+j*2]-&gt;ptr;
1059          int retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);
1060          if (retval == 0) {
1061              addReplyError(c,nanerr);
1062              goto cleanup;
1063          }
1064          if (retflags &amp; ZADD_ADDED) added++;
1065          if (retflags &amp; ZADD_UPDATED) updated++;
1066          if (!(retflags &amp; ZADD_NOP)) processed++;
1067          score = newscore;
1068      }
1069      server.dirty += (added+updated);
1070  reply_to_client:
1071      if (incr) { &amp;bsol;* ZINCRBY or INCR option. */
1072          if (processed)
1073              addReplyDouble(c,score);
1074          else
1075              addReply(c,shared.nullbulk);
1076      } else { &amp;bsol;* ZADD. */
1077          addReplyLongLong(c,ch ? added+updated : added);
1078      }
1079  cleanup:
1080      zfree(scores);
1081      if (added || updated) {
1082          signalModifiedKey(c-&gt;db,key);
1083          notifyKeyspaceEvent(NOTIFY_ZSET,
1084              incr ? &quot;zincr&quot; : &quot;zadd&quot;, key, c-&gt;db-&gt;id);
1085      }
1086  }
1087  void zaddCommand(client *c) {
1088      zaddGenericCommand(c,ZADD_NONE);
1089  }
1090  void zincrbyCommand(client *c) {
1091      zaddGenericCommand(c,ZADD_INCR);
1092  }
1093  void zremCommand(client *c) {
1094      robj *key = c-&gt;argv[1];
1095      robj *zobj;
1096      int deleted = 0, keyremoved = 0, j;
1097      if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
1098          checkType(c,zobj,OBJ_ZSET)) return;
1099      for (j = 2; j &lt; c-&gt;argc; j++) {
1100          if (zsetDel(zobj,c-&gt;argv[j]-&gt;ptr)) deleted++;
1101          if (zsetLength(zobj) == 0) {
1102              dbDelete(c-&gt;db,key);
1103              keyremoved = 1;
1104              break;
1105          }
1106      }
1107      if (deleted) {
1108          notifyKeyspaceEvent(NOTIFY_ZSET,&quot;zrem&quot;,key,c-&gt;db-&gt;id);
1109          if (keyremoved)
1110              notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,key,c-&gt;db-&gt;id);
1111          signalModifiedKey(c-&gt;db,key);
1112          server.dirty += deleted;
1113      }
1114      addReplyLongLong(c,deleted);
1115  }
1116  #define ZRANGE_RANK 0
1117  #define ZRANGE_SCORE 1
1118  #define ZRANGE_LEX 2
1119  void zremrangeGenericCommand(client *c, int rangetype) {
1120      robj *key = c-&gt;argv[1];
1121      robj *zobj;
1122      int keyremoved = 0;
1123      PORT_ULONG deleted = 0;
1124      zrangespec range;
1125      zlexrangespec lexrange;
1126      PORT_LONG start, end, llen;
1127      if (rangetype == ZRANGE_RANK) {
1128          if ((getLongFromObjectOrReply(c,c-&gt;argv[2],&amp;start,NULL) != C_OK) ||
1129              (getLongFromObjectOrReply(c,c-&gt;argv[3],&amp;end,NULL) != C_OK))
1130              return;
1131      } else if (rangetype == ZRANGE_SCORE) {
1132          if (zslParseRange(c-&gt;argv[2],c-&gt;argv[3],&amp;range) != C_OK) {
1133              addReplyError(c,&quot;min or max is not a float&quot;);
1134              return;
1135          }
1136      } else if (rangetype == ZRANGE_LEX) {
1137          if (zslParseLexRange(c-&gt;argv[2],c-&gt;argv[3],&amp;lexrange) != C_OK) {
1138              addReplyError(c,&quot;min or max not valid string range item&quot;);
1139              return;
1140          }
1141      }
1142      if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
1143          checkType(c,zobj,OBJ_ZSET)) goto cleanup;
1144      if (rangetype == ZRANGE_RANK) {
1145          llen = zsetLength(zobj);
1146          if (start &lt; 0) start = llen+start;
1147          if (end &lt; 0) end = llen+end;
1148          if (start &lt; 0) start = 0;
1149          if (start &gt; end || start &gt;= llen) {
1150              addReply(c,shared.czero);
1151              goto cleanup;
1152          }
1153          if (end &gt;= llen) end = llen-1;
1154      }
1155      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1156          switch(rangetype) {
1157          case ZRANGE_RANK:
1158              zobj-&gt;ptr = zzlDeleteRangeByRank(zobj-&gt;ptr,(int)start+1,(int)end+1,&amp;deleted);   WIN_PORT_FIX &amp;bsol;* cast (int), cast (int) */
1159              break;
1160          case ZRANGE_SCORE:
1161              zobj-&gt;ptr = zzlDeleteRangeByScore(zobj-&gt;ptr,&amp;range,&amp;deleted);
1162              break;
1163          case ZRANGE_LEX:
1164              zobj-&gt;ptr = zzlDeleteRangeByLex(zobj-&gt;ptr,&amp;lexrange,&amp;deleted);
1165              break;
1166          }
1167          if (zzlLength(zobj-&gt;ptr) == 0) {
1168              dbDelete(c-&gt;db,key);
1169              keyremoved = 1;
1170          }
1171      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1172          zset *zs = zobj-&gt;ptr;
1173          switch(rangetype) {
1174          case ZRANGE_RANK:
1175              deleted = zslDeleteRangeByRank(zs-&gt;zsl,(int)start+1,(int)end+1,zs-&gt;dict);   WIN_PORT_FIX &amp;bsol;* cast (int), cast (int) */
1176              break;
1177          case ZRANGE_SCORE:
1178              deleted = zslDeleteRangeByScore(zs-&gt;zsl,&amp;range,zs-&gt;dict);
1179              break;
1180          case ZRANGE_LEX:
1181              deleted = zslDeleteRangeByLex(zs-&gt;zsl,&amp;lexrange,zs-&gt;dict);
1182              break;
1183          }
1184          if (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);
1185          if (dictSize(zs-&gt;dict) == 0) {
1186              dbDelete(c-&gt;db,key);
1187              keyremoved = 1;
1188          }
1189      } else {
1190          serverPanic(&quot;Unknown sorted set encoding&quot;);
1191      }
1192      if (deleted) {
1193          char *event[3] = {&quot;zremrangebyrank&quot;,&quot;zremrangebyscore&quot;,&quot;zremrangebylex&quot;};
1194          signalModifiedKey(c-&gt;db,key);
1195          notifyKeyspaceEvent(NOTIFY_ZSET,event[rangetype],key,c-&gt;db-&gt;id);
1196          if (keyremoved)
1197              notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,key,c-&gt;db-&gt;id);
1198      }
1199      server.dirty += deleted;
1200      addReplyLongLong(c,deleted);
1201  cleanup:
1202      if (rangetype == ZRANGE_LEX) zslFreeLexRange(&amp;lexrange);
1203  }
1204  void zremrangebyrankCommand(client *c) {
1205      zremrangeGenericCommand(c,ZRANGE_RANK);
1206  }
1207  void zremrangebyscoreCommand(client *c) {
1208      zremrangeGenericCommand(c,ZRANGE_SCORE);
1209  }
1210  void zremrangebylexCommand(client *c) {
1211      zremrangeGenericCommand(c,ZRANGE_LEX);
1212  }
1213  typedef struct {
1214      robj *subject;
1215      int type; &amp;bsol;* Set, sorted set */
1216      int encoding;
1217      double weight;
1218      union {
1219          union _iterset {
1220              struct {
1221                  intset *is;
1222                  int ii;
1223              } is;
1224              struct {
1225                  dict *dict;
1226                  dictIterator *di;
1227                  dictEntry *de;
1228              } ht;
1229          } set;
1230          union _iterzset {
1231              struct {
1232                  unsigned char *zl;
1233                  unsigned char *eptr, *sptr;
1234              } zl;
1235              struct {
1236                  zset *zs;
1237                  zskiplistNode *node;
1238              } sl;
1239          } zset;
1240      } iter;
1241  } zsetopsrc;
1242  #define OPVAL_DIRTY_SDS 1
1243  #define OPVAL_DIRTY_LL 2
1244  #define OPVAL_VALID_LL 4
1245  typedef struct {
1246      int flags;
1247      unsigned char _buf[32]; &amp;bsol;* Private buffer. */
1248      sds ele;
1249      unsigned char *estr;
1250      unsigned int elen;
1251      PORT_LONGLONG ell;
1252      double score;
1253  } zsetopval;
1254  typedef union _iterset iterset;
1255  typedef union _iterzset iterzset;
1256  void zuiInitIterator(zsetopsrc *op) {
1257      if (op-&gt;subject == NULL)
1258          return;
1259      if (op-&gt;type == OBJ_SET) {
1260          iterset *it = &amp;op-&gt;iter.set;
1261          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1262              it-&gt;is.is = op-&gt;subject-&gt;ptr;
1263              it-&gt;is.ii = 0;
1264          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1265              it-&gt;ht.dict = op-&gt;subject-&gt;ptr;
1266              it-&gt;ht.di = dictGetIterator(op-&gt;subject-&gt;ptr);
1267              it-&gt;ht.de = dictNext(it-&gt;ht.di);
1268          } else {
1269              serverPanic(&quot;Unknown set encoding&quot;);
1270          }
1271      } else if (op-&gt;type == OBJ_ZSET) {
1272          iterzset *it = &amp;op-&gt;iter.zset;
1273          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1274              it-&gt;zl.zl = op-&gt;subject-&gt;ptr;
1275              it-&gt;zl.eptr = ziplistIndex(it-&gt;zl.zl,0);
1276              if (it-&gt;zl.eptr != NULL) {
1277                  it-&gt;zl.sptr = ziplistNext(it-&gt;zl.zl,it-&gt;zl.eptr);
1278                  serverAssert(it-&gt;zl.sptr != NULL);
1279              }
1280          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1281              it-&gt;sl.zs = op-&gt;subject-&gt;ptr;
1282              it-&gt;sl.node = it-&gt;sl.zs-&gt;zsl-&gt;header-&gt;level[0].forward;
1283          } else {
1284              serverPanic(&quot;Unknown sorted set encoding&quot;);
1285          }
1286      } else {
1287          serverPanic(&quot;Unsupported type&quot;);
1288      }
1289  }
1290  void zuiClearIterator(zsetopsrc *op) {
1291      if (op-&gt;subject == NULL)
1292          return;
1293      if (op-&gt;type == OBJ_SET) {
1294          iterset *it = &amp;op-&gt;iter.set;
1295          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1296              UNUSED(it); &amp;bsol;* skip */
1297          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1298              dictReleaseIterator(it-&gt;ht.di);
1299          } else {
1300              serverPanic(&quot;Unknown set encoding&quot;);
1301          }
1302      } else if (op-&gt;type == OBJ_ZSET) {
1303          iterzset *it = &amp;op-&gt;iter.zset;
1304          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1305              UNUSED(it); &amp;bsol;* skip */
1306          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1307              UNUSED(it); &amp;bsol;* skip */
1308          } else {
1309              serverPanic(&quot;Unknown sorted set encoding&quot;);
1310          }
1311      } else {
1312          serverPanic(&quot;Unsupported type&quot;);
1313      }
1314  }
1315  PORT_ULONG zuiLength(zsetopsrc *op) {
1316      if (op-&gt;subject == NULL)
1317          return 0;
1318      if (op-&gt;type == OBJ_SET) {
1319          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1320              return intsetLen(op-&gt;subject-&gt;ptr);
1321          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1322              dict *ht = op-&gt;subject-&gt;ptr;
1323              return dictSize(ht);
1324          } else {
1325              serverPanic(&quot;Unknown set encoding&quot;);
1326          }
1327      } else if (op-&gt;type == OBJ_ZSET) {
1328          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1329              return zzlLength(op-&gt;subject-&gt;ptr);
1330          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1331              zset *zs = op-&gt;subject-&gt;ptr;
1332              return zs-&gt;zsl-&gt;length;
1333          } else {
1334              serverPanic(&quot;Unknown sorted set encoding&quot;);
1335          }
1336      } else {
1337          serverPanic(&quot;Unsupported type&quot;);
1338      }
1339  }
1340  int zuiNext(zsetopsrc *op, zsetopval *val) {
1341      if (op-&gt;subject == NULL)
1342          return 0;
1343      if (val-&gt;flags &amp; OPVAL_DIRTY_SDS)
1344          sdsfree(val-&gt;ele);
1345      memset(val,0,sizeof(zsetopval));
1346      if (op-&gt;type == OBJ_SET) {
1347          iterset *it = &amp;op-&gt;iter.set;
1348          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1349              int64_t ell;
1350              if (!intsetGet(it-&gt;is.is,it-&gt;is.ii,&amp;ell))
1351                  return 0;
1352              val-&gt;ell = ell;
1353              val-&gt;score = 1.0;
1354              it-&gt;is.ii++;
1355          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1356              if (it-&gt;ht.de == NULL)
1357                  return 0;
1358              val-&gt;ele = dictGetKey(it-&gt;ht.de);
1359              val-&gt;score = 1.0;
1360              it-&gt;ht.de = dictNext(it-&gt;ht.di);
1361          } else {
1362              serverPanic(&quot;Unknown set encoding&quot;);
1363          }
1364      } else if (op-&gt;type == OBJ_ZSET) {
1365          iterzset *it = &amp;op-&gt;iter.zset;
1366          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1367              if (it-&gt;zl.eptr == NULL || it-&gt;zl.sptr == NULL)
1368                  return 0;
1369              serverAssert(ziplistGet(it-&gt;zl.eptr,&amp;val-&gt;estr,&amp;val-&gt;elen,&amp;val-&gt;ell));
1370              val-&gt;score = zzlGetScore(it-&gt;zl.sptr);
1371              zzlNext(it-&gt;zl.zl,&amp;it-&gt;zl.eptr,&amp;it-&gt;zl.sptr);
1372          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1373              if (it-&gt;sl.node == NULL)
1374                  return 0;
1375              val-&gt;ele = it-&gt;sl.node-&gt;ele;
1376              val-&gt;score = it-&gt;sl.node-&gt;score;
1377              it-&gt;sl.node = it-&gt;sl.node-&gt;level[0].forward;
1378          } else {
1379              serverPanic(&quot;Unknown sorted set encoding&quot;);
1380          }
1381      } else {
1382          serverPanic(&quot;Unsupported type&quot;);
1383      }
1384      return 1;
1385  }
1386  int zuiLongLongFromValue(zsetopval *val) {
1387      if (!(val-&gt;flags &amp; OPVAL_DIRTY_LL)) {
1388          val-&gt;flags |= OPVAL_DIRTY_LL;
1389          if (val-&gt;ele != NULL) {
1390              if (string2ll(val-&gt;ele,sdslen(val-&gt;ele),&amp;val-&gt;ell))
1391                  val-&gt;flags |= OPVAL_VALID_LL;
1392          } else if (val-&gt;estr != NULL) {
1393              if (string2ll((char*)val-&gt;estr,val-&gt;elen,&amp;val-&gt;ell))
1394                  val-&gt;flags |= OPVAL_VALID_LL;
1395          } else {
1396              val-&gt;flags |= OPVAL_VALID_LL;
1397          }
1398      }
1399      return val-&gt;flags &amp; OPVAL_VALID_LL;
1400  }
1401  sds zuiSdsFromValue(zsetopval *val) {
1402      if (val-&gt;ele == NULL) {
1403          if (val-&gt;estr != NULL) {
1404              val-&gt;ele = sdsnewlen((char*)val-&gt;estr,val-&gt;elen);
1405          } else {
1406              val-&gt;ele = sdsfromlonglong(val-&gt;ell);
1407          }
1408          val-&gt;flags |= OPVAL_DIRTY_SDS;
1409      }
1410      return val-&gt;ele;
1411  }
1412  sds zuiNewSdsFromValue(zsetopval *val) {
1413      if (val-&gt;flags &amp; OPVAL_DIRTY_SDS) {
1414          sds ele = val-&gt;ele;
1415          val-&gt;flags &amp;= ~OPVAL_DIRTY_SDS;
1416          val-&gt;ele = NULL;
1417          return ele;
1418      } else if (val-&gt;ele) {
1419          return sdsdup(val-&gt;ele);
1420      } else if (val-&gt;estr) {
1421          return sdsnewlen((char*)val-&gt;estr,val-&gt;elen);
1422      } else {
1423          return sdsfromlonglong(val-&gt;ell);
1424      }
1425  }
1426  int zuiBufferFromValue(zsetopval *val) {
1427      if (val-&gt;estr == NULL) {
1428          if (val-&gt;ele != NULL) {
1429              val-&gt;elen = sdslen(val-&gt;ele);
1430              val-&gt;estr = (unsigned char*)val-&gt;ele;
1431          } else {
1432              val-&gt;elen = ll2string((char*)val-&gt;_buf,sizeof(val-&gt;_buf),val-&gt;ell);
1433              val-&gt;estr = val-&gt;_buf;
1434          }
1435      }
1436      return 1;
1437  }
1438  int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
1439      if (op-&gt;subject == NULL)
1440          return 0;
1441      if (op-&gt;type == OBJ_SET) {
1442          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1443              if (zuiLongLongFromValue(val) &amp;&amp;
1444                  intsetFind(op-&gt;subject-&gt;ptr,val-&gt;ell))
1445              {
1446                  *score = 1.0;
1447                  return 1;
1448              } else {
1449                  return 0;
1450              }
1451          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1452              dict *ht = op-&gt;subject-&gt;ptr;
1453              zuiSdsFromValue(val);
1454              if (dictFind(ht,val-&gt;ele) != NULL) {
1455                  *score = 1.0;
1456                  return 1;
1457              } else {
1458                  return 0;
1459              }
1460          } else {
1461              serverPanic(&quot;Unknown set encoding&quot;);
1462          }
1463      } else if (op-&gt;type == OBJ_ZSET) {
1464          zuiSdsFromValue(val);
1465          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1466              if (zzlFind(op-&gt;subject-&gt;ptr,val-&gt;ele,score) != NULL) {
1467                  return 1;
1468              } else {
1469                  return 0;
1470              }
1471          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1472              zset *zs = op-&gt;subject-&gt;ptr;
1473              dictEntry *de;
1474              if ((de = dictFind(zs-&gt;dict,val-&gt;ele)) != NULL) {
1475                  *score = *(double*)dictGetVal(de);
1476                  return 1;
1477              } else {
1478                  return 0;
1479              }
1480          } else {
1481              serverPanic(&quot;Unknown sorted set encoding&quot;);
1482          }
1483      } else {
1484          serverPanic(&quot;Unsupported type&quot;);
1485      }
1486  }
1487  int zuiCompareByCardinality(const void *s1, const void *s2) {
1488      PORT_ULONG first = zuiLength((zsetopsrc*)s1);
1489      PORT_ULONG second = zuiLength((zsetopsrc*)s2);
1490      if (first &gt; second) return 1;
1491      if (first &lt; second) return -1;
1492      return 0;
1493  }
1494  #define REDIS_AGGR_SUM 1
1495  #define REDIS_AGGR_MIN 2
1496  #define REDIS_AGGR_MAX 3
1497  #define zunionInterDictValue(_e) (dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))
1498  inline static void zunionInterAggregate(double *target, double val, int aggregate) {
1499      if (aggregate == REDIS_AGGR_SUM) {
1500          *target = *target + val;
1501          if (isnan(*target)) *target = 0.0;
1502      } else if (aggregate == REDIS_AGGR_MIN) {
1503          *target = val &lt; *target ? val : *target;
1504      } else if (aggregate == REDIS_AGGR_MAX) {
1505          *target = val &gt; *target ? val : *target;
1506      } else {
1507          serverPanic(&quot;Unknown ZUNION/INTER aggregate type&quot;);
1508      }
1509  }
1510  uint64_t dictSdsHash(const void *key);
1511  int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
1512  dictType setAccumulatorDictType = {
1513      dictSdsHash,               &amp;bsol;* hash function */
1514      NULL,                      &amp;bsol;* key dup */
1515      NULL,                      &amp;bsol;* val dup */
1516      dictSdsKeyCompare,         &amp;bsol;* key compare */
1517      NULL,                      &amp;bsol;* key destructor */
1518      NULL                       &amp;bsol;* val destructor */
1519  };
1520  void zunionInterGenericCommand(client *c, robj *dstkey, int op) {
1521      int i, j;
1522      PORT_LONG setnum;
1523      int aggregate = REDIS_AGGR_SUM;
1524      zsetopsrc *src;
1525      zsetopval zval;
1526      sds tmp;
1527      size_t maxelelen = 0;
1528      robj *dstobj;
1529      zset *dstzset;
1530      zskiplistNode *znode;
1531      int touched = 0;
1532      if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;setnum, NULL) != C_OK))
1533          return;
1534      if (setnum &lt; 1) {
1535          addReplyError(c,
1536              &quot;at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE&quot;);
1537          return;
1538      }
1539      if (setnum &gt; c-&gt;argc-3) {
1540          addReply(c,shared.syntaxerr);
1541          return;
1542      }
1543      src = zcalloc(sizeof(zsetopsrc) * setnum);
1544      for (i = 0, j = 3; i &lt; setnum; i++, j++) {
1545          robj *obj = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);
1546          if (obj != NULL) {
1547              if (obj-&gt;type != OBJ_ZSET &amp;&amp; obj-&gt;type != OBJ_SET) {
1548                  zfree(src);
1549                  addReply(c,shared.wrongtypeerr);
1550                  return;
1551              }
1552              src[i].subject = obj;
1553              src[i].type = obj-&gt;type;
1554              src[i].encoding = obj-&gt;encoding;
1555          } else {
1556              src[i].subject = NULL;
1557          }
1558          src[i].weight = 1.0;
1559      }
1560      if (j &lt; c-&gt;argc) {
1561          int remaining = c-&gt;argc - j;
1562          while (remaining) {
1563              if (remaining &gt;= (setnum + 1) &amp;&amp;
1564                  !strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;weights&quot;))
1565              {
1566                  j++; remaining--;
1567                  for (i = 0; i &lt; setnum; i++, j++, remaining--) {
1568                      if (getDoubleFromObjectOrReply(c,c-&gt;argv[j],&amp;src[i].weight,
1569                              &quot;weight value is not a float&quot;) != C_OK)
1570                      {
1571                          zfree(src);
1572                          return;
1573                      }
1574                  }
1575              } else if (remaining &gt;= 2 &amp;&amp;
1576                         !strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;aggregate&quot;))
1577              {
1578                  j++; remaining--;
1579                  if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;sum&quot;)) {
1580                      aggregate = REDIS_AGGR_SUM;
1581                  } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;min&quot;)) {
1582                      aggregate = REDIS_AGGR_MIN;
1583                  } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;max&quot;)) {
1584                      aggregate = REDIS_AGGR_MAX;
1585                  } else {
1586                      zfree(src);
1587                      addReply(c,shared.syntaxerr);
1588                      return;
1589                  }
1590                  j++; remaining--;
1591              } else {
1592                  zfree(src);
1593                  addReply(c,shared.syntaxerr);
1594                  return;
1595              }
1596          }
1597      }
1598      qsort(src,setnum,sizeof(zsetopsrc),zuiCompareByCardinality);
1599      dstobj = createZsetObject();
1600      dstzset = dstobj-&gt;ptr;
1601      memset(&amp;zval, 0, sizeof(zval));
1602      if (op == SET_OP_INTER) {
1603          if (zuiLength(&amp;src[0]) &gt; 0) {
1604              zuiInitIterator(&amp;src[0]);
1605              while (zuiNext(&amp;src[0],&amp;zval)) {
1606                  double score, value;
1607                  score = src[0].weight * zval.score;
1608                  if (isnan(score)) score = 0;
1609                  for (j = 1; j &lt; setnum; j++) {
1610                      if (src[j].subject == src[0].subject) {
1611                          value = zval.score*src[j].weight;
1612                          zunionInterAggregate(&amp;score,value,aggregate);
1613                      } else if (zuiFind(&amp;src[j],&amp;zval,&amp;value)) {
1614                          value *= src[j].weight;
1615                          zunionInterAggregate(&amp;score,value,aggregate);
1616                      } else {
1617                          break;
1618                      }
1619                  }
1620                  if (j == setnum) {
1621                      tmp = zuiNewSdsFromValue(&amp;zval);
1622                      znode = zslInsert(dstzset-&gt;zsl,score,tmp);
1623                      dictAdd(dstzset-&gt;dict,tmp,&amp;znode-&gt;score);
1624                      if (sdslen(tmp) &gt; maxelelen) maxelelen = sdslen(tmp);
1625                  }
1626              }
1627              zuiClearIterator(&amp;src[0]);
1628          }
1629      } else if (op == SET_OP_UNION) {
1630          dict *accumulator = dictCreate(&amp;setAccumulatorDictType,NULL);
1631          dictIterator *di;
1632          dictEntry *de, *existing;
1633          double score;
1634          if (setnum) {
1635              dictExpand(accumulator,zuiLength(&amp;src[setnum-1]));
1636          }
1637          for (i = 0; i &lt; setnum; i++) {
1638              if (zuiLength(&amp;src[i]) == 0) continue;
1639              zuiInitIterator(&amp;src[i]);
1640              while (zuiNext(&amp;src[i],&amp;zval)) {
1641                  score = src[i].weight * zval.score;
1642                  if (isnan(score)) score = 0;
1643                  de = dictAddRaw(accumulator,zuiSdsFromValue(&amp;zval),&amp;existing);
1644                  if (!existing) {
1645                      tmp = zuiNewSdsFromValue(&amp;zval);
1646                       if (sdslen(tmp) &gt; maxelelen) maxelelen = sdslen(tmp);
1647                      dictSetKey(accumulator, de, tmp);
1648                      dictSetDoubleVal(de,score);
1649                  } else {
1650                      zunionInterAggregate(&amp;existing-&gt;v.d,score,aggregate);
1651                  }
1652              }
1653              zuiClearIterator(&amp;src[i]);
1654          }
1655          di = dictGetIterator(accumulator);
1656          dictExpand(dstzset-&gt;dict,dictSize(accumulator));
1657          while((de = dictNext(di)) != NULL) {
1658              sds ele = dictGetKey(de);
1659              score = dictGetDoubleVal(de);
1660              znode = zslInsert(dstzset-&gt;zsl,score,ele);
1661              dictAdd(dstzset-&gt;dict,ele,&amp;znode-&gt;score);
1662          }
1663          dictReleaseIterator(di);
1664          dictRelease(accumulator);
1665      } else {
1666          serverPanic(&quot;Unknown operator&quot;);
1667      }
1668      if (dbDelete(c-&gt;db,dstkey))
1669          touched = 1;
1670      if (dstzset-&gt;zsl-&gt;length) {
1671          zsetConvertToZiplistIfNeeded(dstobj,maxelelen);
1672          dbAdd(c-&gt;db,dstkey,dstobj);
1673          addReplyLongLong(c,zsetLength(dstobj));
1674          signalModifiedKey(c-&gt;db,dstkey);
1675          notifyKeyspaceEvent(NOTIFY_ZSET,
1676              (op == SET_OP_UNION) ? &quot;zunionstore&quot; : &quot;zinterstore&quot;,
1677              dstkey,c-&gt;db-&gt;id);
1678          server.dirty++;
1679      } else {
1680          decrRefCount(dstobj);
1681          addReply(c,shared.czero);
1682          if (touched) {
1683              signalModifiedKey(c-&gt;db,dstkey);
1684              notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,dstkey,c-&gt;db-&gt;id);
1685              server.dirty++;
1686          }
1687      }
1688      zfree(src);
1689  }
1690  void zunionstoreCommand(client *c) {
1691      zunionInterGenericCommand(c,c-&gt;argv[1], SET_OP_UNION);
1692  }
1693  void zinterstoreCommand(client *c) {
1694      zunionInterGenericCommand(c,c-&gt;argv[1], SET_OP_INTER);
1695  }
1696  void zrangeGenericCommand(client *c, int reverse) {
1697      robj *key = c-&gt;argv[1];
1698      robj *zobj;
1699      int withscores = 0;
1700      PORT_LONG start;
1701      PORT_LONG end;
1702      PORT_LONG llen;
1703      PORT_LONG rangelen;
1704      if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;start, NULL) != C_OK) ||
1705          (getLongFromObjectOrReply(c, c-&gt;argv[3], &amp;end, NULL) != C_OK)) return;
1706      if (c-&gt;argc == 5 &amp;&amp; !strcasecmp(c-&gt;argv[4]-&gt;ptr,&quot;withscores&quot;)) {
1707          withscores = 1;
1708      } else if (c-&gt;argc &gt;= 5) {
1709          addReply(c,shared.syntaxerr);
1710          return;
1711      }
1712      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL
1713           || checkType(c,zobj,OBJ_ZSET)) return;
1714      llen = zsetLength(zobj);
1715      if (start &lt; 0) start = llen+start;
1716      if (end &lt; 0) end = llen+end;
1717      if (start &lt; 0) start = 0;
1718      if (start &gt; end || start &gt;= llen) {
1719          addReply(c,shared.emptymultibulk);
1720          return;
1721      }
1722      if (end &gt;= llen) end = llen-1;
1723      rangelen = (int)(end-start)+1;                                              WIN_PORT_FIX &amp;bsol;* cast (int) */
1724      addReplyMultiBulkLen(c, withscores ? (rangelen*2) : rangelen);
1725      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1726          unsigned char *zl = zobj-&gt;ptr;
1727          unsigned char *eptr, *sptr;
1728          unsigned char *vstr;
1729          unsigned int vlen;
1730          PORT_LONGLONG vlong;
1731          if (reverse)
1732              eptr = ziplistIndex(zl,(int)(-2-(2*start)));                        WIN_PORT_FIX &amp;bsol;* cast (int) */
1733          else
1734              eptr = ziplistIndex(zl,(int)(2*start));                             WIN_PORT_FIX &amp;bsol;* cast (int) */
1735          serverAssertWithInfo(c,zobj,eptr != NULL);
1736          sptr = ziplistNext(zl,eptr);
1737          while (rangelen--) {
1738              serverAssertWithInfo(c,zobj,eptr != NULL &amp;&amp; sptr != NULL);
1739              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
1740              if (vstr == NULL)
1741                  addReplyBulkLongLong(c,vlong);
1742              else
1743                  addReplyBulkCBuffer(c,vstr,vlen);
1744              if (withscores)
1745                  addReplyDouble(c,zzlGetScore(sptr));
1746              if (reverse)
1747                  zzlPrev(zl,&amp;eptr,&amp;sptr);
1748              else
1749                  zzlNext(zl,&amp;eptr,&amp;sptr);
1750          }
1751      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1752          zset *zs = zobj-&gt;ptr;
1753          zskiplist *zsl = zs-&gt;zsl;
1754          zskiplistNode *ln;
1755          sds ele;
1756          if (reverse) {
1757              ln = zsl-&gt;tail;
1758              if (start &gt; 0)
1759                  ln = zslGetElementByRank(zsl,llen-start);
1760          } else {
1761              ln = zsl-&gt;header-&gt;level[0].forward;
1762              if (start &gt; 0)
1763                  ln = zslGetElementByRank(zsl,start+1);
1764          }
1765          while(rangelen--) {
1766              serverAssertWithInfo(c,zobj,ln != NULL);
1767              ele = ln-&gt;ele;
1768              addReplyBulkCBuffer(c,ele,sdslen(ele));
1769              if (withscores)
1770                  addReplyDouble(c,ln-&gt;score);
1771              ln = reverse ? ln-&gt;backward : ln-&gt;level[0].forward;
1772          }
1773      } else {
1774          serverPanic(&quot;Unknown sorted set encoding&quot;);
1775      }
1776  }
1777  void zrangeCommand(client *c) {
1778      zrangeGenericCommand(c,0);
1779  }
1780  void zrevrangeCommand(client *c) {
1781      zrangeGenericCommand(c,1);
1782  }
1783  void genericZrangebyscoreCommand(client *c, int reverse) {
1784      zrangespec range;
1785      robj *key = c-&gt;argv[1];
1786      robj *zobj;
1787      PORT_LONG offset = 0, limit = -1;
1788      int withscores = 0;
1789      PORT_ULONG rangelen = 0;
1790      void *replylen = NULL;
1791      int minidx, maxidx;
1792      if (reverse) {
1793          maxidx = 2; minidx = 3;
1794      } else {
1795          minidx = 2; maxidx = 3;
1796      }
1797      if (zslParseRange(c-&gt;argv[minidx],c-&gt;argv[maxidx],&amp;range) != C_OK) {
1798          addReplyError(c,&quot;min or max is not a float&quot;);
1799          return;
1800      }
1801      if (c-&gt;argc &gt; 4) {
1802          int remaining = c-&gt;argc - 4;
1803          int pos = 4;
1804          while (remaining) {
1805              if (remaining &gt;= 1 &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,&quot;withscores&quot;)) {
1806                  pos++; remaining--;
1807                  withscores = 1;
1808              } else if (remaining &gt;= 3 &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,&quot;limit&quot;)) {
1809                  if ((getLongFromObjectOrReply(c, c-&gt;argv[pos+1], &amp;offset, NULL)
1810                          != C_OK) ||
1811                      (getLongFromObjectOrReply(c, c-&gt;argv[pos+2], &amp;limit, NULL)
1812                          != C_OK))
1813                  {
1814                      return;
1815                  }
1816                  pos += 3; remaining -= 3;
1817              } else {
1818                  addReply(c,shared.syntaxerr);
1819                  return;
1820              }
1821          }
1822      }
1823      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
1824          checkType(c,zobj,OBJ_ZSET)) return;
1825      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1826          unsigned char *zl = zobj-&gt;ptr;
1827          unsigned char *eptr, *sptr;
1828          unsigned char *vstr;
1829          unsigned int vlen;
1830          PORT_LONGLONG vlong;
1831          double score;
1832          if (reverse) {
1833              eptr = zzlLastInRange(zl,&amp;range);
1834          } else {
1835              eptr = zzlFirstInRange(zl,&amp;range);
1836          }
1837          if (eptr == NULL) {
1838              addReply(c, shared.emptymultibulk);
1839              return;
1840          }
1841          serverAssertWithInfo(c,zobj,eptr != NULL);
1842          sptr = ziplistNext(zl,eptr);
1843          replylen = addDeferredMultiBulkLength(c);
1844          while (eptr &amp;&amp; offset--) {
1845              if (reverse) {
1846                  zzlPrev(zl,&amp;eptr,&amp;sptr);
1847              } else {
1848                  zzlNext(zl,&amp;eptr,&amp;sptr);
1849              }
1850          }
1851          while (eptr &amp;&amp; limit--) {
1852              score = zzlGetScore(sptr);
1853              if (reverse) {
1854                  if (!zslValueGteMin(score,&amp;range)) break;
1855              } else {
1856                  if (!zslValueLteMax(score,&amp;range)) break;
1857              }
1858              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
1859              rangelen++;
1860              if (vstr == NULL) {
1861                  addReplyBulkLongLong(c,vlong);
1862              } else {
1863                  addReplyBulkCBuffer(c,vstr,vlen);
1864              }
1865              if (withscores) {
1866                  addReplyDouble(c,score);
1867              }
1868              if (reverse) {
1869                  zzlPrev(zl,&amp;eptr,&amp;sptr);
1870              } else {
1871                  zzlNext(zl,&amp;eptr,&amp;sptr);
1872              }
1873          }
1874      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1875          zset *zs = zobj-&gt;ptr;
1876          zskiplist *zsl = zs-&gt;zsl;
1877          zskiplistNode *ln;
1878          if (reverse) {
1879              ln = zslLastInRange(zsl,&amp;range);
1880          } else {
1881              ln = zslFirstInRange(zsl,&amp;range);
1882          }
1883          if (ln == NULL) {
1884              addReply(c, shared.emptymultibulk);
1885              return;
1886          }
1887          replylen = addDeferredMultiBulkLength(c);
1888          while (ln &amp;&amp; offset--) {
1889              if (reverse) {
1890                  ln = ln-&gt;backward;
1891              } else {
1892                  ln = ln-&gt;level[0].forward;
1893              }
1894          }
1895          while (ln &amp;&amp; limit--) {
1896              if (reverse) {
1897                  if (!zslValueGteMin(ln-&gt;score,&amp;range)) break;
1898              } else {
1899                  if (!zslValueLteMax(ln-&gt;score,&amp;range)) break;
1900              }
1901              rangelen++;
1902              addReplyBulkCBuffer(c,ln-&gt;ele,sdslen(ln-&gt;ele));
1903              if (withscores) {
1904                  addReplyDouble(c,ln-&gt;score);
1905              }
1906              if (reverse) {
1907                  ln = ln-&gt;backward;
1908              } else {
1909                  ln = ln-&gt;level[0].forward;
1910              }
1911          }
1912      } else {
1913          serverPanic(&quot;Unknown sorted set encoding&quot;);
1914      }
1915      if (withscores) {
1916          rangelen *= 2;
1917      }
1918      setDeferredMultiBulkLength(c, replylen, rangelen);
1919  }
1920  void zrangebyscoreCommand(client *c) {
1921      genericZrangebyscoreCommand(c,0);
1922  }
1923  void zrevrangebyscoreCommand(client *c) {
1924      genericZrangebyscoreCommand(c,1);
1925  }
1926  void zcountCommand(client *c) {
1927      robj *key = c-&gt;argv[1];
1928      robj *zobj;
1929      zrangespec range;
1930      PORT_ULONG count = 0;
1931      if (zslParseRange(c-&gt;argv[2],c-&gt;argv[3],&amp;range) != C_OK) {
1932          addReplyError(c,&quot;min or max is not a float&quot;);
1933          return;
1934      }
1935      if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
1936          checkType(c, zobj, OBJ_ZSET)) return;
1937      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1938          unsigned char *zl = zobj-&gt;ptr;
1939          unsigned char *eptr, *sptr;
1940          double score;
1941          eptr = zzlFirstInRange(zl,&amp;range);
1942          if (eptr == NULL) {
1943              addReply(c, shared.czero);
1944              return;
1945          }
1946          sptr = ziplistNext(zl,eptr);
1947          score = zzlGetScore(sptr);
1948          serverAssertWithInfo(c,zobj,zslValueLteMax(score,&amp;range));
1949          while (eptr) {
1950              score = zzlGetScore(sptr);
1951              if (!zslValueLteMax(score,&amp;range)) {
1952                  break;
1953              } else {
1954                  count++;
1955                  zzlNext(zl,&amp;eptr,&amp;sptr);
1956              }
1957          }
1958      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1959          zset *zs = zobj-&gt;ptr;
1960          zskiplist *zsl = zs-&gt;zsl;
1961          zskiplistNode *zn;
1962          PORT_ULONG rank;
1963          zn = zslFirstInRange(zsl, &amp;range);
1964          if (zn != NULL) {
1965              rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);
1966              count = (int)(zsl-&gt;length - (rank - 1));                            WIN_PORT_FIX &amp;bsol;* cast (int) */
1967              zn = zslLastInRange(zsl, &amp;range);
1968              if (zn != NULL) {
1969                  rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);
1970                  count -= (int)(zsl-&gt;length - rank);                             WIN_PORT_FIX &amp;bsol;* cast (int) */
1971              }
1972          }
1973      } else {
1974          serverPanic(&quot;Unknown sorted set encoding&quot;);
1975      }
1976      addReplyLongLong(c, count);
1977  }
1978  void zlexcountCommand(client *c) {
1979      robj *key = c-&gt;argv[1];
1980      robj *zobj;
1981      zlexrangespec range;
1982      PORT_ULONG count = 0;
1983      if (zslParseLexRange(c-&gt;argv[2],c-&gt;argv[3],&amp;range) != C_OK) {
1984          addReplyError(c,&quot;min or max not valid string range item&quot;);
1985          return;
1986      }
1987      if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
1988          checkType(c, zobj, OBJ_ZSET))
1989      {
1990          zslFreeLexRange(&amp;range);
1991          return;
1992      }
1993      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1994          unsigned char *zl = zobj-&gt;ptr;
1995          unsigned char *eptr, *sptr;
1996          eptr = zzlFirstInLexRange(zl,&amp;range);
1997          if (eptr == NULL) {
1998              zslFreeLexRange(&amp;range);
1999              addReply(c, shared.czero);
2000              return;
2001          }
2002          sptr = ziplistNext(zl,eptr);
2003          serverAssertWithInfo(c,zobj,zzlLexValueLteMax(eptr,&amp;range));
2004          while (eptr) {
2005              if (!zzlLexValueLteMax(eptr,&amp;range)) {
2006                  break;
2007              } else {
2008                  count++;
2009                  zzlNext(zl,&amp;eptr,&amp;sptr);
2010              }
2011          }
2012      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
2013          zset *zs = zobj-&gt;ptr;
2014          zskiplist *zsl = zs-&gt;zsl;
2015          zskiplistNode *zn;
2016          PORT_ULONG rank;
2017          zn = zslFirstInLexRange(zsl, &amp;range);
2018          if (zn != NULL) {
2019              rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);
2020              count = (int)(zsl-&gt;length - (rank - 1));                            WIN_PORT_FIX &amp;bsol;* cast (int) */
2021              zn = zslLastInLexRange(zsl, &amp;range);
2022              if (zn != NULL) {
2023                  rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);
2024                  count -= (int)(zsl-&gt;length - rank);                             WIN_PORT_FIX &amp;bsol;* cast (int) */
2025              }
2026          }
2027      } else {
2028          serverPanic(&quot;Unknown sorted set encoding&quot;);
2029      }
2030      zslFreeLexRange(&amp;range);
2031      addReplyLongLong(c, count);
2032  }
2033  void genericZrangebylexCommand(client *c, int reverse) {
2034      zlexrangespec range;
2035      robj *key = c-&gt;argv[1];
2036      robj *zobj;
2037      PORT_LONG offset = 0, limit = -1;
2038      PORT_ULONG rangelen = 0;
2039      void *replylen = NULL;
2040      int minidx, maxidx;
2041      if (reverse) {
2042          maxidx = 2; minidx = 3;
2043      } else {
2044          minidx = 2; maxidx = 3;
2045      }
2046      if (zslParseLexRange(c-&gt;argv[minidx],c-&gt;argv[maxidx],&amp;range) != C_OK) {
2047          addReplyError(c,&quot;min or max not valid string range item&quot;);
2048          return;
2049      }
2050      if (c-&gt;argc &gt; 4) {
2051          int remaining = c-&gt;argc - 4;
2052          int pos = 4;
2053          while (remaining) {
2054              if (remaining &gt;= 3 &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,&quot;limit&quot;)) {
2055                  if ((getLongFromObjectOrReply(c, c-&gt;argv[pos+1], &amp;offset, NULL) != C_OK) ||
2056                      (getLongFromObjectOrReply(c, c-&gt;argv[pos+2], &amp;limit, NULL) != C_OK)) {
2057                      zslFreeLexRange(&amp;range);
2058                      return;
2059                  }
2060                  pos += 3; remaining -= 3;
2061              } else {
2062                  zslFreeLexRange(&amp;range);
2063                  addReply(c,shared.syntaxerr);
2064                  return;
2065              }
2066          }
2067      }
2068      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
2069          checkType(c,zobj,OBJ_ZSET))
2070      {
2071          zslFreeLexRange(&amp;range);
2072          return;
2073      }
2074      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
2075          unsigned char *zl = zobj-&gt;ptr;
2076          unsigned char *eptr, *sptr;
2077          unsigned char *vstr;
2078          unsigned int vlen;
2079          PORT_LONGLONG vlong;
2080          if (reverse) {
2081              eptr = zzlLastInLexRange(zl,&amp;range);
2082          } else {
2083              eptr = zzlFirstInLexRange(zl,&amp;range);
2084          }
2085          if (eptr == NULL) {
2086              addReply(c, shared.emptymultibulk);
2087              zslFreeLexRange(&amp;range);
2088              return;
2089          }
2090          serverAssertWithInfo(c,zobj,eptr != NULL);
2091          sptr = ziplistNext(zl,eptr);
2092          replylen = addDeferredMultiBulkLength(c);
2093          while (eptr &amp;&amp; offset--) {
2094              if (reverse) {
2095                  zzlPrev(zl,&amp;eptr,&amp;sptr);
2096              } else {
2097                  zzlNext(zl,&amp;eptr,&amp;sptr);
2098              }
2099          }
2100          while (eptr &amp;&amp; limit--) {
2101              if (reverse) {
2102                  if (!zzlLexValueGteMin(eptr,&amp;range)) break;
2103              } else {
2104                  if (!zzlLexValueLteMax(eptr,&amp;range)) break;
2105              }
2106              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
2107              rangelen++;
2108              if (vstr == NULL) {
2109                  addReplyBulkLongLong(c,vlong);
2110              } else {
2111                  addReplyBulkCBuffer(c,vstr,vlen);
2112              }
2113              if (reverse) {
2114                  zzlPrev(zl,&amp;eptr,&amp;sptr);
2115              } else {
2116                  zzlNext(zl,&amp;eptr,&amp;sptr);
2117              }
2118          }
2119      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
2120          zset *zs = zobj-&gt;ptr;
2121          zskiplist *zsl = zs-&gt;zsl;
2122          zskiplistNode *ln;
2123          if (reverse) {
2124              ln = zslLastInLexRange(zsl,&amp;range);
2125          } else {
2126              ln = zslFirstInLexRange(zsl,&amp;range);
2127          }
2128          if (ln == NULL) {
2129              addReply(c, shared.emptymultibulk);
2130              zslFreeLexRange(&amp;range);
2131              return;
2132          }
2133          replylen = addDeferredMultiBulkLength(c);
2134          while (ln &amp;&amp; offset--) {
2135              if (reverse) {
2136                  ln = ln-&gt;backward;
2137              } else {
2138                  ln = ln-&gt;level[0].forward;
2139              }
2140          }
2141          while (ln &amp;&amp; limit--) {
2142              if (reverse) {
2143                  if (!zslLexValueGteMin(ln-&gt;ele,&amp;range)) break;
2144              } else {
2145                  if (!zslLexValueLteMax(ln-&gt;ele,&amp;range)) break;
2146              }
2147              rangelen++;
2148              addReplyBulkCBuffer(c,ln-&gt;ele,sdslen(ln-&gt;ele));
2149              if (reverse) {
2150                  ln = ln-&gt;backward;
2151              } else {
2152                  ln = ln-&gt;level[0].forward;
2153              }
2154          }
2155      } else {
2156          serverPanic(&quot;Unknown sorted set encoding&quot;);
2157      }
2158      zslFreeLexRange(&amp;range);
2159      setDeferredMultiBulkLength(c, replylen, rangelen);
2160  }
2161  void zrangebylexCommand(client *c) {
2162      genericZrangebylexCommand(c,0);
2163  }
2164  void zrevrangebylexCommand(client *c) {
2165      genericZrangebylexCommand(c,1);
2166  }
2167  void zcardCommand(client *c) {
2168      robj *key = c-&gt;argv[1];
2169      robj *zobj;
2170      if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
2171          checkType(c,zobj,OBJ_ZSET)) return;
2172      addReplyLongLong(c,zsetLength(zobj));
2173  }
2174  void zscoreCommand(client *c) {
2175      robj *key = c-&gt;argv[1];
2176      robj *zobj;
2177      double score;
2178      if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
2179          checkType(c,zobj,OBJ_ZSET)) return;
2180      if (zsetScore(zobj,c-&gt;argv[2]-&gt;ptr,&amp;score) == C_ERR) {
2181          addReply(c,shared.nullbulk);
2182      } else {
2183          addReplyDouble(c,score);
2184      }
2185  }
2186  void zrankGenericCommand(client *c, int reverse) {
2187      robj *key = c-&gt;argv[1];
2188      robj *ele = c-&gt;argv[2];
2189      robj *zobj;
2190      PORT_LONG rank;
2191      if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
2192          checkType(c,zobj,OBJ_ZSET)) return;
2193      serverAssertWithInfo(c,ele,sdsEncodedObject(ele));
2194      rank = zsetRank(zobj,ele-&gt;ptr,reverse);
2195      if (rank &gt;= 0) {
2196          addReplyLongLong(c,rank);
2197      } else {
2198          addReply(c,shared.nullbulk);
2199      }
2200  }
2201  void zrankCommand(client *c) {
2202      zrankGenericCommand(c, 0);
2203  }
2204  void zrevrankCommand(client *c) {
2205      zrankGenericCommand(c, 1);
2206  }
2207  void zscanCommand(client *c) {
2208      robj *o;
2209      PORT_ULONG cursor;
2210      if (parseScanCursorOrReply(c,c-&gt;argv[2],&amp;cursor) == C_ERR) return;
2211      if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.emptyscan)) == NULL ||
2212          checkType(c,o,OBJ_ZSET)) return;
2213      scanGenericCommand(c,o,cursor);
2214  }
2215  void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg) {
2216      int idx;
2217      robj *key = NULL;
2218      robj *zobj = NULL;
2219      sds ele;
2220      double score;
2221      PORT_LONG count = 1;
2222      if (countarg) {
2223          if (getLongFromObjectOrReply(c,countarg,&amp;count,NULL) != C_OK)
2224              return;
2225          if (count &lt;= 0) {
2226              addReply(c,shared.emptymultibulk);
2227              return;
2228          }
2229      }
2230      idx = 0;
2231      while (idx &lt; keyc) {
2232          key = keyv[idx++];
2233          zobj = lookupKeyWrite(c-&gt;db,key);
2234          if (!zobj) continue;
2235          if (checkType(c,zobj,OBJ_ZSET)) return;
2236          break;
2237      }
2238      if (!zobj) {
2239          addReply(c,shared.emptymultibulk);
2240          return;
2241      }
2242      void *arraylen_ptr = addDeferredMultiBulkLength(c);
2243      PORT_LONG arraylen = 0;
2244      if (emitkey) addReplyBulk(c,key);
2245      do {
2246          if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
2247              unsigned char *zl = zobj-&gt;ptr;
2248              unsigned char *eptr, *sptr;
2249              unsigned char *vstr;
2250              unsigned int vlen;
2251              PORT_LONGLONG vlong;
2252              eptr = ziplistIndex(zl,where == ZSET_MAX ? -2 : 0);
2253              serverAssertWithInfo(c,zobj,eptr != NULL);
2254              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
2255              if (vstr == NULL)
2256                  ele = sdsfromlonglong(vlong);
2257              else
2258                  ele = sdsnewlen(vstr,vlen);
2259              sptr = ziplistNext(zl,eptr);
2260              serverAssertWithInfo(c,zobj,sptr != NULL);
2261              score = zzlGetScore(sptr);
2262          } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
2263              zset *zs = zobj-&gt;ptr;
2264              zskiplist *zsl = zs-&gt;zsl;
2265              zskiplistNode *zln;
2266              zln = (where == ZSET_MAX ? zsl-&gt;tail :
2267                                         zsl-&gt;header-&gt;level[0].forward);
2268              serverAssertWithInfo(c,zobj,zln != NULL);
2269              ele = sdsdup(zln-&gt;ele);
2270              score = zln-&gt;score;
2271          } else {
2272              serverPanic(&quot;Unknown sorted set encoding&quot;);
2273          }
2274          serverAssertWithInfo(c,zobj,zsetDel(zobj,ele));
2275          server.dirty++;
2276          if (arraylen == 0) { &amp;bsol;* Do this only for the first iteration. */
2277              char *events[2] = {&quot;zpopmin&quot;,&quot;zpopmax&quot;};
2278              notifyKeyspaceEvent(NOTIFY_ZSET,events[where],key,c-&gt;db-&gt;id);
2279              signalModifiedKey(c-&gt;db,key);
2280          }
2281          addReplyBulkCBuffer(c,ele,sdslen(ele));
2282          addReplyDouble(c,score);
2283          sdsfree(ele);
2284          arraylen += 2;
2285          if (zsetLength(zobj) == 0) {
2286              dbDelete(c-&gt;db,key);
2287              notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,key,c-&gt;db-&gt;id);
2288              break;
2289          }
2290      } while(--count);
2291      setDeferredMultiBulkLength(c,arraylen_ptr,arraylen + (emitkey != 0));
2292  }
2293  void zpopminCommand(client *c) {
2294      if (c-&gt;argc &gt; 3) {
2295          addReply(c,shared.syntaxerr);
2296          return;
2297      }
2298      genericZpopCommand(c,&amp;c-&gt;argv[1],1,ZSET_MIN,0,
2299          c-&gt;argc == 3 ? c-&gt;argv[2] : NULL);
2300  }
2301  void zpopmaxCommand(client *c) {
2302      if (c-&gt;argc &gt; 3) {
2303          addReply(c,shared.syntaxerr);
2304          return;
2305      }
2306      genericZpopCommand(c,&amp;c-&gt;argv[1],1,ZSET_MAX,0,
2307          c-&gt;argc == 3 ? c-&gt;argv[2] : NULL);
2308  }
2309  void blockingGenericZpopCommand(client *c, int where) {
2310      robj *o;
2311      mstime_t timeout;
2312      int j;
2313      if (getTimeoutFromObjectOrReply(c,c-&gt;argv[c-&gt;argc-1],&amp;timeout,UNIT_SECONDS)
2314          != C_OK) return;
2315      for (j = 1; j &lt; c-&gt;argc-1; j++) {
2316          o = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);
2317          if (o != NULL) {
2318              if (o-&gt;type != OBJ_ZSET) {
2319                  addReply(c,shared.wrongtypeerr);
2320                  return;
2321              } else {
2322                  if (zsetLength(o) != 0) {
2323                      genericZpopCommand(c,&amp;c-&gt;argv[j],1,where,1,NULL);
2324                      rewriteClientCommandVector(c,2,
2325                          where == ZSET_MAX ? shared.zpopmax : shared.zpopmin,
2326                          c-&gt;argv[j]);
2327                      return;
2328                  }
2329              }
2330          }
2331      }
2332      if (c-&gt;flags &amp; CLIENT_MULTI) {
2333          addReply(c,shared.nullmultibulk);
2334          return;
2335      }
2336      blockForKeys(c,BLOCKED_ZSET,c-&gt;argv + 1,c-&gt;argc - 2,timeout,NULL,NULL);
2337  }
2338  void bzpopminCommand(client *c) {
2339      blockingGenericZpopCommand(c,ZSET_MIN);
2340  }
2341  void bzpopmaxCommand(client *c) {
2342      blockingGenericZpopCommand(c,ZSET_MAX);
2343  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_zset.c</h3>
            <pre><code>1  #include &quot;server.h&quot;
2  #include &lt;math.h&gt;
3  #ifdef _WIN32
4  #define bzero(b,len) (memset((b), &#x27;\0&#x27;, (len)), (void) 0)
5  #endif
6  int zslLexValueGteMin(sds value, zlexrangespec *spec);
7  int zslLexValueLteMax(sds value, zlexrangespec *spec);
8  zskiplistNode *zslCreateNode(int level, double score, sds ele) {
9      zskiplistNode *zn =
10          zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
11      zn-&gt;score = score;
12      zn-&gt;ele = ele;
13      return zn;
14  }
15  zskiplist *zslCreate(void) {
16      int j;
17      zskiplist *zsl;
18      zsl = zmalloc(sizeof(*zsl));
19      zsl-&gt;level = 1;
20      zsl-&gt;length = 0;
21      zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
22      for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) {
23          zsl-&gt;header-&gt;level[j].forward = NULL;
24          zsl-&gt;header-&gt;level[j].span = 0;
25      }
26      zsl-&gt;header-&gt;backward = NULL;
27      zsl-&gt;tail = NULL;
28      return zsl;
29  }
30  void zslFreeNode(zskiplistNode *node) {
31      sdsfree(node-&gt;ele);
32      zfree(node);
33  }
34  void zslFree(zskiplist *zsl) {
35      zskiplistNode *node = zsl-&gt;header-&gt;level[0].forward, *next;
36      zfree(zsl-&gt;header);
37      while(node) {
38          next = node-&gt;level[0].forward;
39          zslFreeNode(node);
40          node = next;
41      }
42      zfree(zsl);
43  }
44  int zslRandomLevel(void) {
45      int level = 1;
46      while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))
47          level += 1;
48      return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
49  }
50  zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
51      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
52      unsigned int rank[ZSKIPLIST_MAXLEVEL];
53      int i, level;
54      serverAssert(!isnan(score));
55      x = zsl-&gt;header;
56      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
57          rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];
58          while (x-&gt;level[i].forward &amp;&amp;
59                  (x-&gt;level[i].forward-&gt;score &lt; score ||
60                      (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
61                      sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
62          {
63              rank[i] += x-&gt;level[i].span;
64              x = x-&gt;level[i].forward;
65          }
66          update[i] = x;
67      }
68      level = zslRandomLevel();
69      if (level &gt; zsl-&gt;level) {
70          for (i = zsl-&gt;level; i &lt; level; i++) {
71              rank[i] = 0;
72              update[i] = zsl-&gt;header;
73              update[i]-&gt;level[i].span = zsl-&gt;length;
74          }
75          zsl-&gt;level = level;
76      }
77      x = zslCreateNode(level,score,ele);
78      for (i = 0; i &lt; level; i++) {
79          x-&gt;level[i].forward = update[i]-&gt;level[i].forward;
80          update[i]-&gt;level[i].forward = x;
81          x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);
82          update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;
83      }
84      for (i = level; i &lt; zsl-&gt;level; i++) {
85          update[i]-&gt;level[i].span++;
86      }
87      x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];
88      if (x-&gt;level[0].forward)
89          x-&gt;level[0].forward-&gt;backward = x;
90      else
91          zsl-&gt;tail = x;
92      zsl-&gt;length++;
93      return x;
94  }
95  void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
96      int i;
97      for (i = 0; i &lt; zsl-&gt;level; i++) {
98          if (update[i]-&gt;level[i].forward == x) {
99              update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;
100              update[i]-&gt;level[i].forward = x-&gt;level[i].forward;
101          } else {
102              update[i]-&gt;level[i].span -= 1;
103          }
104      }
105      if (x-&gt;level[0].forward) {
106          x-&gt;level[0].forward-&gt;backward = x-&gt;backward;
107      } else {
108          zsl-&gt;tail = x-&gt;backward;
109      }
110      while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)
111          zsl-&gt;level--;
112      zsl-&gt;length--;
113  }
114  int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
115      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
116      int i;
117      x = zsl-&gt;header;
118      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
119          while (x-&gt;level[i].forward &amp;&amp;
120                  (x-&gt;level[i].forward-&gt;score &lt; score ||
121                      (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
122                       sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
123          {
124              x = x-&gt;level[i].forward;
125          }
126          update[i] = x;
127      }
128      x = x-&gt;level[0].forward;
129      if (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
130          zslDeleteNode(zsl, x, update);
131          if (!node)
132              zslFreeNode(x);
133          else
134              *node = x;
135          return 1;
136      }
137      return 0; &amp;bsol;* not found */
138  }
139  zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {
140      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
141      int i;
142      x = zsl-&gt;header;
143      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
144          while (x-&gt;level[i].forward &amp;&amp;
145                  (x-&gt;level[i].forward-&gt;score &lt; curscore ||
146                      (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;
147                       sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
148          {
149              x = x-&gt;level[i].forward;
150          }
151          update[i] = x;
152      }
153      x = x-&gt;level[0].forward;
154      serverAssert(x &amp;&amp; curscore == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0);
155      if ((x-&gt;backward == NULL || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;
156          (x-&gt;level[0].forward == NULL || x-&gt;level[0].forward-&gt;score &gt; newscore))
157      {
158          x-&gt;score = newscore;
159          return x;
160      }
161      zslDeleteNode(zsl, x, update);
162      zskiplistNode *newnode = zslInsert(zsl,newscore,x-&gt;ele);
163      x-&gt;ele = NULL;
164      zslFreeNode(x);
165      return newnode;
166  }
167  int zslValueGteMin(double value, zrangespec *spec) {
168      return spec-&gt;minex ? (value &gt; spec-&gt;min) : (value &gt;= spec-&gt;min);
169  }
170  int zslValueLteMax(double value, zrangespec *spec) {
171      return spec-&gt;maxex ? (value &lt; spec-&gt;max) : (value &lt;= spec-&gt;max);
172  }
173  int zslIsInRange(zskiplist *zsl, zrangespec *range) {
174      zskiplistNode *x;
175      if (range-&gt;min &gt; range-&gt;max ||
176              (range-&gt;min == range-&gt;max &amp;&amp; (range-&gt;minex || range-&gt;maxex)))
177          return 0;
178      x = zsl-&gt;tail;
179      if (x == NULL || !zslValueGteMin(x-&gt;score,range))
180          return 0;
181      x = zsl-&gt;header-&gt;level[0].forward;
182      if (x == NULL || !zslValueLteMax(x-&gt;score,range))
183          return 0;
184      return 1;
185  }
186  zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
187      zskiplistNode *x;
188      int i;
189      if (!zslIsInRange(zsl,range)) return NULL;
190      x = zsl-&gt;header;
191      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
192          while (x-&gt;level[i].forward &amp;&amp;
193              !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))
194                  x = x-&gt;level[i].forward;
195      }
196      x = x-&gt;level[0].forward;
197      serverAssert(x != NULL);
198      if (!zslValueLteMax(x-&gt;score,range)) return NULL;
199      return x;
200  }
201  zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
202      zskiplistNode *x;
203      int i;
204      if (!zslIsInRange(zsl,range)) return NULL;
205      x = zsl-&gt;header;
206      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
207          while (x-&gt;level[i].forward &amp;&amp;
208              zslValueLteMax(x-&gt;level[i].forward-&gt;score,range))
209                  x = x-&gt;level[i].forward;
210      }
211      serverAssert(x != NULL);
212      if (!zslValueGteMin(x-&gt;score,range)) return NULL;
213      return x;
214  }
215  PORT_ULONG zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
216      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
217      PORT_ULONG removed = 0;
218      int i;
219      x = zsl-&gt;header;
220      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
221          while (x-&gt;level[i].forward &amp;&amp; (range-&gt;minex ?
222              x-&gt;level[i].forward-&gt;score &lt;= range-&gt;min :
223              x-&gt;level[i].forward-&gt;score &lt; range-&gt;min))
224                  x = x-&gt;level[i].forward;
225          update[i] = x;
226      }
227      x = x-&gt;level[0].forward;
228      while (x &amp;&amp;
229             (range-&gt;maxex ? x-&gt;score &lt; range-&gt;max : x-&gt;score &lt;= range-&gt;max))
230      {
231          zskiplistNode *next = x-&gt;level[0].forward;
232          zslDeleteNode(zsl,x,update);
233          dictDelete(dict,x-&gt;ele);
234          zslFreeNode(x); &amp;bsol;* Here is where x-&gt;ele is actually released. */
235          removed++;
236          x = next;
237      }
238      return removed;
239  }
240  PORT_ULONG zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {
241      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
242      PORT_ULONG removed = 0;
243      int i;
244      x = zsl-&gt;header;
245      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
246          while (x-&gt;level[i].forward &amp;&amp;
247              !zslLexValueGteMin(x-&gt;level[i].forward-&gt;ele,range))
248                  x = x-&gt;level[i].forward;
249          update[i] = x;
250      }
251      x = x-&gt;level[0].forward;
252      while (x &amp;&amp; zslLexValueLteMax(x-&gt;ele,range)) {
253          zskiplistNode *next = x-&gt;level[0].forward;
254          zslDeleteNode(zsl,x,update);
255          dictDelete(dict,x-&gt;ele);
256          zslFreeNode(x); &amp;bsol;* Here is where x-&gt;ele is actually released. */
257          removed++;
258          x = next;
259      }
260      return removed;
261  }
262  PORT_ULONG zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {
263      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
264      PORT_ULONG traversed = 0, removed = 0;
265      int i;
266      x = zsl-&gt;header;
267      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
268          while (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt; start) {
269              traversed += x-&gt;level[i].span;
270              x = x-&gt;level[i].forward;
271          }
272          update[i] = x;
273      }
274      traversed++;
275      x = x-&gt;level[0].forward;
276      while (x &amp;&amp; traversed &lt;= end) {
277          zskiplistNode *next = x-&gt;level[0].forward;
278          zslDeleteNode(zsl,x,update);
279          dictDelete(dict,x-&gt;ele);
280          zslFreeNode(x);
281          removed++;
282          traversed++;
283          x = next;
284      }
285      return removed;
286  }
287  PORT_ULONG zslGetRank(zskiplist *zsl, double score, sds ele) {
288      zskiplistNode *x;
289      PORT_ULONG rank = 0;
290      int i;
291      x = zsl-&gt;header;
292      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
293          while (x-&gt;level[i].forward &amp;&amp;
294              (x-&gt;level[i].forward-&gt;score &lt; score ||
295                  (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
296                  sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= 0))) {
297              rank += x-&gt;level[i].span;
298              x = x-&gt;level[i].forward;
299          }
300          if (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
301              return rank;
302          }
303      }
304      return 0;
305  }
306  zskiplistNode* zslGetElementByRank(zskiplist *zsl, PORT_ULONG rank) {
307      zskiplistNode *x;
308      PORT_ULONG traversed = 0;
309      int i;
310      x = zsl-&gt;header;
311      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
312          while (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)
313          {
314              traversed += x-&gt;level[i].span;
315              x = x-&gt;level[i].forward;
316          }
317          if (traversed == rank) {
318              return x;
319          }
320      }
321      return NULL;
322  }
323  static int zslParseRange(robj *min, robj *max, zrangespec *spec) {
324      char *eptr;
325      spec-&gt;minex = spec-&gt;maxex = 0;
326      if (min-&gt;encoding == OBJ_ENCODING_INT) {
327          spec-&gt;min = (PORT_LONG)min-&gt;ptr;
328      } else {
329          if (((char*)min-&gt;ptr)[0] == &#x27;(&#x27;) {
330              spec-&gt;min = strtod((char*)min-&gt;ptr+1,&amp;eptr);
331              if (eptr[0] != &#x27;\0&#x27; || isnan(spec-&gt;min)) return C_ERR;
332              spec-&gt;minex = 1;
333          } else {
334              spec-&gt;min = strtod((char*)min-&gt;ptr,&amp;eptr);
335              if (eptr[0] != &#x27;\0&#x27; || isnan(spec-&gt;min)) return C_ERR;
336          }
337      }
338      if (max-&gt;encoding == OBJ_ENCODING_INT) {
339          spec-&gt;max = (PORT_LONG)max-&gt;ptr;
340      } else {
341          if (((char*)max-&gt;ptr)[0] == &#x27;(&#x27;) {
342              spec-&gt;max = strtod((char*)max-&gt;ptr+1,&amp;eptr);
343              if (eptr[0] != &#x27;\0&#x27; || isnan(spec-&gt;max)) return C_ERR;
344              spec-&gt;maxex = 1;
345          } else {
346              spec-&gt;max = strtod((char*)max-&gt;ptr,&amp;eptr);
347              if (eptr[0] != &#x27;\0&#x27; || isnan(spec-&gt;max)) return C_ERR;
348          }
349      }
350      return C_OK;
351  }
352  int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
353      char *c = item-&gt;ptr;
354      switch(c[0]) {
355      case &#x27;+&#x27;:
356          if (c[1] != &#x27;\0&#x27;) return C_ERR;
357          *ex = 1;
358          *dest = shared.maxstring;
359          return C_OK;
360      case &#x27;-&#x27;:
361          if (c[1] != &#x27;\0&#x27;) return C_ERR;
362          *ex = 1;
363          *dest = shared.minstring;
364          return C_OK;
365      case &#x27;(&#x27;:
366          *ex = 1;
367          *dest = sdsnewlen(c+1,sdslen(c)-1);
368          return C_OK;
369      case &#x27;[&#x27;:
370          *ex = 0;
371          *dest = sdsnewlen(c+1,sdslen(c)-1);
372          return C_OK;
373      default:
374          return C_ERR;
375      }
376  }
377  void zslFreeLexRange(zlexrangespec *spec) {
378      if (spec-&gt;min != shared.minstring &amp;&amp;
379          spec-&gt;min != shared.maxstring) sdsfree(spec-&gt;min);
380      if (spec-&gt;max != shared.minstring &amp;&amp;
381          spec-&gt;max != shared.maxstring) sdsfree(spec-&gt;max);
382  }
383  int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
384      if (min-&gt;encoding == OBJ_ENCODING_INT ||
385          max-&gt;encoding == OBJ_ENCODING_INT) return C_ERR;
386      spec-&gt;min = spec-&gt;max = NULL;
387      if (zslParseLexRangeItem(min, &amp;spec-&gt;min, &amp;spec-&gt;minex) == C_ERR ||
388          zslParseLexRangeItem(max, &amp;spec-&gt;max, &amp;spec-&gt;maxex) == C_ERR) {
389          zslFreeLexRange(spec);
390          return C_ERR;
391      } else {
392          return C_OK;
393      }
394  }
395  int sdscmplex(sds a, sds b) {
396      if (a == b) return 0;
397      if (a == shared.minstring || b == shared.maxstring) return -1;
398      if (a == shared.maxstring || b == shared.minstring) return 1;
399      return sdscmp(a,b);
400  }
401  int zslLexValueGteMin(sds value, zlexrangespec *spec) {
402      return spec-&gt;minex ?
403          (sdscmplex(value,spec-&gt;min) &gt; 0) :
404          (sdscmplex(value,spec-&gt;min) &gt;= 0);
405  }
406  int zslLexValueLteMax(sds value, zlexrangespec *spec) {
407      return spec-&gt;maxex ?
408          (sdscmplex(value,spec-&gt;max) &lt; 0) :
409          (sdscmplex(value,spec-&gt;max) &lt;= 0);
410  }
411  int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
412      zskiplistNode *x;
413      int cmp = sdscmplex(range-&gt;min,range-&gt;max);
414      if (cmp &gt; 0 || (cmp == 0 &amp;&amp; (range-&gt;minex || range-&gt;maxex)))
415          return 0;
416      x = zsl-&gt;tail;
417      if (x == NULL || !zslLexValueGteMin(x-&gt;ele,range))
418          return 0;
419      x = zsl-&gt;header-&gt;level[0].forward;
420      if (x == NULL || !zslLexValueLteMax(x-&gt;ele,range))
421          return 0;
422      return 1;
423  }
424  zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
425      zskiplistNode *x;
426      int i;
427      if (!zslIsInLexRange(zsl,range)) return NULL;
428      x = zsl-&gt;header;
429      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
430          while (x-&gt;level[i].forward &amp;&amp;
431              !zslLexValueGteMin(x-&gt;level[i].forward-&gt;ele,range))
<span onclick='openModal()' class='match'>432                  x = x-&gt;level[i].forward;
433      }
434      x = x-&gt;level[0].forward;
435      serverAssert(x != NULL);
436      if (!zslLexValueLteMax(x-&gt;ele,range)) return NULL;
437      return x;
438  }
439  zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
440      zskiplistNode *x;
441      int i;
442      if (!zslIsInLexRange(zsl,range)) return NULL;
443      x = zsl-&gt;header;
444      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
445          while (x-&gt;level[i].forward &amp;&amp;
446              zslLexValueLteMax(x-&gt;level[i].forward-&gt;ele,range))
447                  x = x-&gt;level[i].forward;
448      }
449      serverAssert(x != NULL);
450      if (!zslLexValueGteMin(x-&gt;ele,range)) return NULL;
451      return x;
452  }
453  double zzlGetScore(unsigned char *sptr) {
</span>454      unsigned char *vstr;
455      unsigned int vlen;
456      PORT_LONGLONG vlong;
457      char buf[128];
458      double score;
459      serverAssert(sptr != NULL);
460      serverAssert(ziplistGet(sptr,&amp;vstr,&amp;vlen,&amp;vlong));
461      if (vstr) {
462          memcpy(buf,vstr,vlen);
463          buf[vlen] = &#x27;\0&#x27;;
464          score = strtod(buf,NULL);
465      } else {
466          score = (double)vlong;                                                  WIN_PORT_FIX &amp;bsol;* cast (double) */
467      }
468      return score;
469  }
470  sds ziplistGetObject(unsigned char *sptr) {
471      unsigned char *vstr;
472      unsigned int vlen;
473      PORT_LONGLONG vlong;
474      serverAssert(sptr != NULL);
475      serverAssert(ziplistGet(sptr,&amp;vstr,&amp;vlen,&amp;vlong));
476      if (vstr) {
477          return sdsnewlen((char*)vstr,vlen);
478      } else {
479          return sdsfromlonglong(vlong);
480      }
481  }
482  int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {
483      unsigned char *vstr;
484      unsigned int vlen;
485      PORT_LONGLONG vlong;
486      unsigned char vbuf[32];
487      int minlen, cmp;
488      serverAssert(ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
489      if (vstr == NULL) {
490          vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);
491          vstr = vbuf;
492      }
493      minlen = (vlen &lt; clen) ? vlen : clen;
494      cmp = memcmp(vstr,cstr,minlen);
495      if (cmp == 0) return vlen-clen;
496      return cmp;
497  }
498  unsigned int zzlLength(unsigned char *zl) {
499      return ziplistLen(zl)/2;
500  }
501  void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
502      unsigned char *l_eptr, *l_sptr;                                             WIN_PORT_FIX &amp;bsol;* compiler error: _sptr -&gt; l_sptr */
503      serverAssert(*eptr != NULL &amp;&amp; *sptr != NULL);
504      l_eptr = ziplistNext(zl, *sptr);
505      if (l_eptr != NULL) {
506          l_sptr = ziplistNext(zl, l_eptr);
507          serverAssert(l_sptr != NULL);
508      } else {
509          l_sptr = NULL;
510      }
511      *eptr = l_eptr;
512      *sptr = l_sptr;
513  }
514  void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
515      unsigned char *l_eptr, *l_sptr;                                             WIN_PORT_FIX &amp;bsol;* compiler error: _sptr -&gt; l_sptr */
516      serverAssert(*eptr != NULL &amp;&amp; *sptr != NULL);
517      l_sptr = ziplistPrev(zl, *eptr);
518      if (l_sptr != NULL) {
519          l_eptr = ziplistPrev(zl, l_sptr);
520          serverAssert(l_eptr != NULL);
521      } else {
522          l_eptr = NULL;
523      }
524      *eptr = l_eptr;
525      *sptr = l_sptr;
526  }
527  int zzlIsInRange(unsigned char *zl, zrangespec *range) {
528      unsigned char *p;
529      double score;
530      if (range-&gt;min &gt; range-&gt;max ||
531              (range-&gt;min == range-&gt;max &amp;&amp; (range-&gt;minex || range-&gt;maxex)))
532          return 0;
533      p = ziplistIndex(zl,-1); &amp;bsol;* Last score. */
534      if (p == NULL) return 0; &amp;bsol;* Empty sorted set */
535      score = zzlGetScore(p);
536      if (!zslValueGteMin(score,range))
537          return 0;
538      p = ziplistIndex(zl,1); &amp;bsol;* First score. */
539      serverAssert(p != NULL);
540      score = zzlGetScore(p);
541      if (!zslValueLteMax(score,range))
542          return 0;
543      return 1;
544  }
545  unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
546      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
547      double score;
548      if (!zzlIsInRange(zl,range)) return NULL;
549      while (eptr != NULL) {
550          sptr = ziplistNext(zl,eptr);
551          serverAssert(sptr != NULL);
552          score = zzlGetScore(sptr);
553          if (zslValueGteMin(score,range)) {
554              if (zslValueLteMax(score,range))
555                  return eptr;
556              return NULL;
557          }
558          eptr = ziplistNext(zl,sptr);
559      }
560      return NULL;
561  }
562  unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
563      unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
564      double score;
565      if (!zzlIsInRange(zl,range)) return NULL;
566      while (eptr != NULL) {
567          sptr = ziplistNext(zl,eptr);
568          serverAssert(sptr != NULL);
569          score = zzlGetScore(sptr);
570          if (zslValueLteMax(score,range)) {
571              if (zslValueGteMin(score,range))
572                  return eptr;
573              return NULL;
574          }
575          sptr = ziplistPrev(zl,eptr);
576          if (sptr != NULL)
577              serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
578          else
579              eptr = NULL;
580      }
581      return NULL;
582  }
583  int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
584      sds value = ziplistGetObject(p);
585      int res = zslLexValueGteMin(value,spec);
586      sdsfree(value);
587      return res;
588  }
589  int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
590      sds value = ziplistGetObject(p);
591      int res = zslLexValueLteMax(value,spec);
592      sdsfree(value);
593      return res;
594  }
595  int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
596      unsigned char *p;
597      int cmp = sdscmplex(range-&gt;min,range-&gt;max);
598      if (cmp &gt; 0 || (cmp == 0 &amp;&amp; (range-&gt;minex || range-&gt;maxex)))
599          return 0;
600      p = ziplistIndex(zl,-2); &amp;bsol;* Last element. */
601      if (p == NULL) return 0;
602      if (!zzlLexValueGteMin(p,range))
603          return 0;
604      p = ziplistIndex(zl,0); &amp;bsol;* First element. */
605      serverAssert(p != NULL);
606      if (!zzlLexValueLteMax(p,range))
607          return 0;
608      return 1;
609  }
610  unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
611      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
612      if (!zzlIsInLexRange(zl,range)) return NULL;
613      while (eptr != NULL) {
614          if (zzlLexValueGteMin(eptr,range)) {
615              if (zzlLexValueLteMax(eptr,range))
616                  return eptr;
617              return NULL;
618          }
619          sptr = ziplistNext(zl,eptr); &amp;bsol;* This element score. Skip it. */
620          serverAssert(sptr != NULL);
621          eptr = ziplistNext(zl,sptr); &amp;bsol;* Next element. */
622      }
623      return NULL;
624  }
625  unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
626      unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
627      if (!zzlIsInLexRange(zl,range)) return NULL;
628      while (eptr != NULL) {
629          if (zzlLexValueLteMax(eptr,range)) {
630              if (zzlLexValueGteMin(eptr,range))
631                  return eptr;
632              return NULL;
633          }
634          sptr = ziplistPrev(zl,eptr);
635          if (sptr != NULL)
636              serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
637          else
638              eptr = NULL;
639      }
640      return NULL;
641  }
642  unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {
643      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
644      while (eptr != NULL) {
645          sptr = ziplistNext(zl,eptr);
646          serverAssert(sptr != NULL);
647          if (ziplistCompare(eptr,(unsigned char*)ele,(unsigned int)sdslen(ele))) {     WIN_PORT_FIX &amp;bsol;* unsigned int */
648              if (score != NULL) *score = zzlGetScore(sptr);
649              return eptr;
650          }
651          eptr = ziplistNext(zl,sptr);
652      }
653      return NULL;
654  }
655  unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
656      unsigned char *p = eptr;
657      zl = ziplistDelete(zl,&amp;p);
658      zl = ziplistDelete(zl,&amp;p);
659      return zl;
660  }
661  unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {
662      unsigned char *sptr;
663      char scorebuf[128];
664      int scorelen;
665      size_t offset;
666      scorelen = d2string(scorebuf,sizeof(scorebuf),score);
667      if (eptr == NULL) {
668          zl = ziplistPush(zl,(unsigned char*)ele,(unsigned int)sdslen(ele),ZIPLIST_TAIL); WIN_PORT_FIX &amp;bsol;* unsigned int */
669          zl = ziplistPush(zl,(unsigned char*)scorebuf,scorelen,ZIPLIST_TAIL);
670      } else {
671          offset = eptr-zl;
672          zl = ziplistInsert(zl,eptr,(unsigned char*)ele,(unsigned int)sdslen(ele));    WIN_PORT_FIX &amp;bsol;* unsigned int */
673          eptr = zl+offset;
674          serverAssert((sptr = ziplistNext(zl,eptr)) != NULL);
675          zl = ziplistInsert(zl,sptr,(unsigned char*)scorebuf,scorelen);
676      }
677      return zl;
678  }
679  unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
680      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
681      double s;
682      while (eptr != NULL) {
683          sptr = ziplistNext(zl,eptr);
684          serverAssert(sptr != NULL);
685          s = zzlGetScore(sptr);
686          if (s &gt; score) {
687              zl = zzlInsertAt(zl,eptr,ele,score);
688              break;
689          } else if (s == score) {
690              if (zzlCompareElements(eptr,(unsigned char*)ele,(unsigned int)sdslen(ele)) &gt; 0) { WIN_PORT_FIX &amp;bsol;* unsigned int */
691                  zl = zzlInsertAt(zl,eptr,ele,score);
692                  break;
693              }
694          }
695          eptr = ziplistNext(zl,sptr);
696      }
697      if (eptr == NULL)
698          zl = zzlInsertAt(zl,NULL,ele,score);
699      return zl;
700  }
701  unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, PORT_ULONG *deleted) {
702      unsigned char *eptr, *sptr;
703      double score;
704      PORT_ULONG num = 0;
705      if (deleted != NULL) *deleted = 0;
706      eptr = zzlFirstInRange(zl,range);
707      if (eptr == NULL) return zl;
708      while ((sptr = ziplistNext(zl,eptr)) != NULL) {
709          score = zzlGetScore(sptr);
710          if (zslValueLteMax(score,range)) {
711              zl = ziplistDelete(zl,&amp;eptr);
712              zl = ziplistDelete(zl,&amp;eptr);
713              num++;
714          } else {
715              break;
716          }
717      }
718      if (deleted != NULL) *deleted = num;
719      return zl;
720  }
721  unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, PORT_ULONG *deleted) {
722      unsigned char *eptr, *sptr;
723      PORT_ULONG num = 0;
724      if (deleted != NULL) *deleted = 0;
725      eptr = zzlFirstInLexRange(zl,range);
726      if (eptr == NULL) return zl;
727      while ((sptr = ziplistNext(zl,eptr)) != NULL) {
728          if (zzlLexValueLteMax(eptr,range)) {
729              zl = ziplistDelete(zl,&amp;eptr);
730              zl = ziplistDelete(zl,&amp;eptr);
731              num++;
732          } else {
733              break;
734          }
735      }
736      if (deleted != NULL) *deleted = num;
737      return zl;
738  }
739  unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, PORT_ULONG *deleted) {
740      unsigned int num = (end-start)+1;
741      if (deleted) *deleted = num;
742      zl = ziplistDeleteRange(zl,2*(start-1),2*num);
743      return zl;
744  }
745  PORT_ULONG zsetLength(const robj *zobj) {
746      PORT_ULONG length = 0;
747      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
748          length = zzlLength(zobj-&gt;ptr);
749      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
750          length = (PORT_ULONG) ((const zset*)zobj-&gt;ptr)-&gt;zsl-&gt;length;                         WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONG) */
751      } else {
752          serverPanic(&quot;Unknown sorted set encoding&quot;);
753      }
754      return length;
755  }
756  void zsetConvert(robj *zobj, int encoding) {
757      zset *zs;
758      zskiplistNode *node, *next;
759      sds ele;
760      double score;
761      if (zobj-&gt;encoding == encoding) return;
762      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
763          unsigned char *zl = zobj-&gt;ptr;
764          unsigned char *eptr, *sptr;
765          unsigned char *vstr;
766          unsigned int vlen;
767          PORT_LONGLONG vlong;
768          if (encoding != OBJ_ENCODING_SKIPLIST)
769              serverPanic(&quot;Unknown target encoding&quot;);
770          zs = zmalloc(sizeof(*zs));
771          zs-&gt;dict = dictCreate(&amp;zsetDictType,NULL);
772          zs-&gt;zsl = zslCreate();
773          eptr = ziplistIndex(zl,0);
774          serverAssertWithInfo(NULL,zobj,eptr != NULL);
775          sptr = ziplistNext(zl,eptr);
776          serverAssertWithInfo(NULL,zobj,sptr != NULL);
777          while (eptr != NULL) {
778              score = zzlGetScore(sptr);
779              serverAssertWithInfo(NULL,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
780              if (vstr == NULL)
781                  ele = sdsfromlonglong(vlong);
782              else
783                  ele = sdsnewlen((char*)vstr,vlen);
784              node = zslInsert(zs-&gt;zsl,score,ele);
785              serverAssert(dictAdd(zs-&gt;dict,ele,&amp;node-&gt;score) == DICT_OK);
786              zzlNext(zl,&amp;eptr,&amp;sptr);
787          }
788          zfree(zobj-&gt;ptr);
789          zobj-&gt;ptr = zs;
790          zobj-&gt;encoding = OBJ_ENCODING_SKIPLIST;
791      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
792          unsigned char *zl = ziplistNew();
793          if (encoding != OBJ_ENCODING_ZIPLIST)
794              serverPanic(&quot;Unknown target encoding&quot;);
795          zs = zobj-&gt;ptr;
796          dictRelease(zs-&gt;dict);
797          node = zs-&gt;zsl-&gt;header-&gt;level[0].forward;
798          zfree(zs-&gt;zsl-&gt;header);
799          zfree(zs-&gt;zsl);
800          while (node) {
801              zl = zzlInsertAt(zl,NULL,node-&gt;ele,node-&gt;score);
802              next = node-&gt;level[0].forward;
803              zslFreeNode(node);
804              node = next;
805          }
806          zfree(zs);
807          zobj-&gt;ptr = zl;
808          zobj-&gt;encoding = OBJ_ENCODING_ZIPLIST;
809      } else {
810          serverPanic(&quot;Unknown sorted set encoding&quot;);
811      }
812  }
813  void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {
814      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) return;
815      zset *zset = zobj-&gt;ptr;
816      if (zset-&gt;zsl-&gt;length &lt;= server.zset_max_ziplist_entries &amp;&amp;
817          maxelelen &lt;= server.zset_max_ziplist_value)
818              zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);
819  }
820  int zsetScore(robj *zobj, sds member, double *score) {
821      if (!zobj || !member) return C_ERR;
822      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
823          if (zzlFind(zobj-&gt;ptr, member, score) == NULL) return C_ERR;
824      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
825          zset *zs = zobj-&gt;ptr;
826          dictEntry *de = dictFind(zs-&gt;dict, member);
827          if (de == NULL) return C_ERR;
828          *score = *(double*)dictGetVal(de);
829      } else {
830          serverPanic(&quot;Unknown sorted set encoding&quot;);
831      }
832      return C_OK;
833  }
834  int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore) {
835      int incr = (*flags &amp; ZADD_INCR) != 0;
836      int nx = (*flags &amp; ZADD_NX) != 0;
837      int xx = (*flags &amp; ZADD_XX) != 0;
838      *flags = 0; &amp;bsol;* We&#x27;ll return our response flags. */
839      double curscore;
840      if (isnan(score)) {
841          *flags = ZADD_NAN;
842          return 0;
843      }
844      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
845          unsigned char *eptr;
846          if ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != NULL) {
847              if (nx) {
848                  *flags |= ZADD_NOP;
849                  return 1;
850              }
851              if (incr) {
852                  score += curscore;
853                  if (isnan(score)) {
854                      *flags |= ZADD_NAN;
855                      return 0;
856                  }
857                  if (newscore) *newscore = score;
858              }
859              if (score != curscore) {
860                  zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);
861                  zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);
862                  *flags |= ZADD_UPDATED;
863              }
864              return 1;
865          } else if (!xx) {
866              zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);
867              if (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries ||
868                  sdslen(ele) &gt; server.zset_max_ziplist_value)
869                  zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
870              if (newscore) *newscore = score;
871              *flags |= ZADD_ADDED;
872              return 1;
873          } else {
874              *flags |= ZADD_NOP;
875              return 1;
876          }
877      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
878          zset *zs = zobj-&gt;ptr;
879          zskiplistNode *znode;
880          dictEntry *de;
881          de = dictFind(zs-&gt;dict,ele);
882          if (de != NULL) {
883              if (nx) {
884                  *flags |= ZADD_NOP;
885                  return 1;
886              }
887              curscore = *(double*)dictGetVal(de);
888              if (incr) {
889                  score += curscore;
890                  if (isnan(score)) {
891                      *flags |= ZADD_NAN;
892                      return 0;
893                  }
894                  if (newscore) *newscore = score;
895              }
896              if (score != curscore) {
897                  znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score);
898                  dictGetVal(de) = &amp;znode-&gt;score; &amp;bsol;* Update score ptr. */
899                  *flags |= ZADD_UPDATED;
900              }
901              return 1;
902          } else if (!xx) {
903              ele = sdsdup(ele);
904              znode = zslInsert(zs-&gt;zsl,score,ele);
905              serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);
906              *flags |= ZADD_ADDED;
907              if (newscore) *newscore = score;
908              return 1;
909          } else {
910              *flags |= ZADD_NOP;
911              return 1;
912          }
913      } else {
914          serverPanic(&quot;Unknown sorted set encoding&quot;);
915      }
916      return 0; &amp;bsol;* Never reached. */
917  }
918  int zsetDel(robj *zobj, sds ele) {
919      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
920          unsigned char *eptr;
921          if ((eptr = zzlFind(zobj-&gt;ptr,ele,NULL)) != NULL) {
922              zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);
923              return 1;
924          }
925      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
926          zset *zs = zobj-&gt;ptr;
927          dictEntry *de;
928          double score;
929          de = dictUnlink(zs-&gt;dict,ele);
930          if (de != NULL) {
931              score = *(double*)dictGetVal(de);
932              dictFreeUnlinkedEntry(zs-&gt;dict,de);
933              int retval = zslDelete(zs-&gt;zsl,score,ele,NULL);
934              serverAssert(retval);
935              if (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);
936              return 1;
937          }
938      } else {
939          serverPanic(&quot;Unknown sorted set encoding&quot;);
940      }
941      return 0; &amp;bsol;* No such element found. */
942  }
943  PORT_LONG zsetRank(robj *zobj, sds ele, int reverse) {
944      PORT_ULONG llen;
945      PORT_ULONG rank;
946      llen = zsetLength(zobj);
947      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
948          unsigned char *zl = zobj-&gt;ptr;
949          unsigned char *eptr, *sptr;
950          eptr = ziplistIndex(zl,0);
951          serverAssert(eptr != NULL);
952          sptr = ziplistNext(zl,eptr);
953          serverAssert(sptr != NULL);
954          rank = 1;
955          while(eptr != NULL) {
956              if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele)))
957                  break;
958              rank++;
959              zzlNext(zl,&amp;eptr,&amp;sptr);
960          }
961          if (eptr != NULL) {
962              if (reverse)
963                  return llen-rank;
964              else
965                  return rank-1;
966          } else {
967              return -1;
968          }
969      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
970          zset *zs = zobj-&gt;ptr;
971          zskiplist *zsl = zs-&gt;zsl;
972          dictEntry *de;
973          double score;
974          de = dictFind(zs-&gt;dict,ele);
975          if (de != NULL) {
976              score = *(double*)dictGetVal(de);
977              rank = zslGetRank(zsl,score,ele);
978              serverAssert(rank != 0);
979              if (reverse)
980                  return llen-rank;
981              else
982                  return rank-1;
983          } else {
984              return -1;
985          }
986      } else {
987          serverPanic(&quot;Unknown sorted set encoding&quot;);
988      }
989  }
990  void zaddGenericCommand(client *c, int flags) {
991      static char *nanerr = &quot;resulting score is not a number (NaN)&quot;;
992      robj *key = c-&gt;argv[1];
993      robj *zobj;
994      sds ele;
995      double score = 0, *scores = NULL;
996      int j, elements;
997      int scoreidx = 0;
998      int added = 0;      &amp;bsol;* Number of new elements added. */
999      int updated = 0;    &amp;bsol;* Number of elements with updated score. */
1000      int processed = 0;  &amp;bsol;* Number of elements processed, may remain zero with
1001                             options like XX. */
1002      scoreidx = 2;
1003      while(scoreidx &lt; c-&gt;argc) {
1004          char *opt = c-&gt;argv[scoreidx]-&gt;ptr;
1005          if (!strcasecmp(opt,&quot;nx&quot;)) flags |= ZADD_NX;
1006          else if (!strcasecmp(opt,&quot;xx&quot;)) flags |= ZADD_XX;
1007          else if (!strcasecmp(opt,&quot;ch&quot;)) flags |= ZADD_CH;
1008          else if (!strcasecmp(opt,&quot;incr&quot;)) flags |= ZADD_INCR;
1009          else break;
1010          scoreidx++;
1011      }
1012      int incr = (flags &amp; ZADD_INCR) != 0;
1013      int nx = (flags &amp; ZADD_NX) != 0;
1014      int xx = (flags &amp; ZADD_XX) != 0;
1015      int ch = (flags &amp; ZADD_CH) != 0;
1016      elements = c-&gt;argc-scoreidx;
1017      if (elements % 2 || !elements) {
1018          addReply(c,shared.syntaxerr);
1019          return;
1020      }
1021      elements /= 2; &amp;bsol;* Now this holds the number of score-element pairs. */
1022      if (nx &amp;&amp; xx) {
1023          addReplyError(c,
1024              &quot;XX and NX options at the same time are not compatible&quot;);
1025          return;
1026      }
1027      if (incr &amp;&amp; elements &gt; 1) {
1028          addReplyError(c,
1029              &quot;INCR option supports a single increment-element pair&quot;);
1030          return;
1031      }
1032      scores = zmalloc(sizeof(double)*elements);
1033      for (j = 0; j &lt; elements; j++) {
1034          if (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*2],&amp;scores[j],NULL)
1035              != C_OK) goto cleanup;
1036      }
1037      zobj = lookupKeyWrite(c-&gt;db,key);
1038      if (zobj == NULL) {
1039          if (xx) goto reply_to_client; &amp;bsol;* No key + XX option: nothing to do. */
1040          if (server.zset_max_ziplist_entries == 0 ||
1041              server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+1]-&gt;ptr))
1042          {
1043              zobj = createZsetObject();
1044          } else {
1045              zobj = createZsetZiplistObject();
1046          }
1047          dbAdd(c-&gt;db,key,zobj);
1048      } else {
1049          if (zobj-&gt;type != OBJ_ZSET) {
1050              addReply(c,shared.wrongtypeerr);
1051              goto cleanup;
1052          }
1053      }
1054      for (j = 0; j &lt; elements; j++) {
1055          double newscore;
1056          score = scores[j];
1057          int retflags = flags;
1058          ele = c-&gt;argv[scoreidx+1+j*2]-&gt;ptr;
1059          int retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);
1060          if (retval == 0) {
1061              addReplyError(c,nanerr);
1062              goto cleanup;
1063          }
1064          if (retflags &amp; ZADD_ADDED) added++;
1065          if (retflags &amp; ZADD_UPDATED) updated++;
1066          if (!(retflags &amp; ZADD_NOP)) processed++;
1067          score = newscore;
1068      }
1069      server.dirty += (added+updated);
1070  reply_to_client:
1071      if (incr) { &amp;bsol;* ZINCRBY or INCR option. */
1072          if (processed)
1073              addReplyDouble(c,score);
1074          else
1075              addReply(c,shared.nullbulk);
1076      } else { &amp;bsol;* ZADD. */
1077          addReplyLongLong(c,ch ? added+updated : added);
1078      }
1079  cleanup:
1080      zfree(scores);
1081      if (added || updated) {
1082          signalModifiedKey(c-&gt;db,key);
1083          notifyKeyspaceEvent(NOTIFY_ZSET,
1084              incr ? &quot;zincr&quot; : &quot;zadd&quot;, key, c-&gt;db-&gt;id);
1085      }
1086  }
1087  void zaddCommand(client *c) {
1088      zaddGenericCommand(c,ZADD_NONE);
1089  }
1090  void zincrbyCommand(client *c) {
1091      zaddGenericCommand(c,ZADD_INCR);
1092  }
1093  void zremCommand(client *c) {
1094      robj *key = c-&gt;argv[1];
1095      robj *zobj;
1096      int deleted = 0, keyremoved = 0, j;
1097      if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
1098          checkType(c,zobj,OBJ_ZSET)) return;
1099      for (j = 2; j &lt; c-&gt;argc; j++) {
1100          if (zsetDel(zobj,c-&gt;argv[j]-&gt;ptr)) deleted++;
1101          if (zsetLength(zobj) == 0) {
1102              dbDelete(c-&gt;db,key);
1103              keyremoved = 1;
1104              break;
1105          }
1106      }
1107      if (deleted) {
1108          notifyKeyspaceEvent(NOTIFY_ZSET,&quot;zrem&quot;,key,c-&gt;db-&gt;id);
1109          if (keyremoved)
1110              notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,key,c-&gt;db-&gt;id);
1111          signalModifiedKey(c-&gt;db,key);
1112          server.dirty += deleted;
1113      }
1114      addReplyLongLong(c,deleted);
1115  }
1116  #define ZRANGE_RANK 0
1117  #define ZRANGE_SCORE 1
1118  #define ZRANGE_LEX 2
1119  void zremrangeGenericCommand(client *c, int rangetype) {
1120      robj *key = c-&gt;argv[1];
1121      robj *zobj;
1122      int keyremoved = 0;
1123      PORT_ULONG deleted = 0;
1124      zrangespec range;
1125      zlexrangespec lexrange;
1126      PORT_LONG start, end, llen;
1127      if (rangetype == ZRANGE_RANK) {
1128          if ((getLongFromObjectOrReply(c,c-&gt;argv[2],&amp;start,NULL) != C_OK) ||
1129              (getLongFromObjectOrReply(c,c-&gt;argv[3],&amp;end,NULL) != C_OK))
1130              return;
1131      } else if (rangetype == ZRANGE_SCORE) {
1132          if (zslParseRange(c-&gt;argv[2],c-&gt;argv[3],&amp;range) != C_OK) {
1133              addReplyError(c,&quot;min or max is not a float&quot;);
1134              return;
1135          }
1136      } else if (rangetype == ZRANGE_LEX) {
1137          if (zslParseLexRange(c-&gt;argv[2],c-&gt;argv[3],&amp;lexrange) != C_OK) {
1138              addReplyError(c,&quot;min or max not valid string range item&quot;);
1139              return;
1140          }
1141      }
1142      if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
1143          checkType(c,zobj,OBJ_ZSET)) goto cleanup;
1144      if (rangetype == ZRANGE_RANK) {
1145          llen = zsetLength(zobj);
1146          if (start &lt; 0) start = llen+start;
1147          if (end &lt; 0) end = llen+end;
1148          if (start &lt; 0) start = 0;
1149          if (start &gt; end || start &gt;= llen) {
1150              addReply(c,shared.czero);
1151              goto cleanup;
1152          }
1153          if (end &gt;= llen) end = llen-1;
1154      }
1155      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1156          switch(rangetype) {
1157          case ZRANGE_RANK:
1158              zobj-&gt;ptr = zzlDeleteRangeByRank(zobj-&gt;ptr,(int)start+1,(int)end+1,&amp;deleted);   WIN_PORT_FIX &amp;bsol;* cast (int), cast (int) */
1159              break;
1160          case ZRANGE_SCORE:
1161              zobj-&gt;ptr = zzlDeleteRangeByScore(zobj-&gt;ptr,&amp;range,&amp;deleted);
1162              break;
1163          case ZRANGE_LEX:
1164              zobj-&gt;ptr = zzlDeleteRangeByLex(zobj-&gt;ptr,&amp;lexrange,&amp;deleted);
1165              break;
1166          }
1167          if (zzlLength(zobj-&gt;ptr) == 0) {
1168              dbDelete(c-&gt;db,key);
1169              keyremoved = 1;
1170          }
1171      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1172          zset *zs = zobj-&gt;ptr;
1173          switch(rangetype) {
1174          case ZRANGE_RANK:
1175              deleted = zslDeleteRangeByRank(zs-&gt;zsl,(int)start+1,(int)end+1,zs-&gt;dict);   WIN_PORT_FIX &amp;bsol;* cast (int), cast (int) */
1176              break;
1177          case ZRANGE_SCORE:
1178              deleted = zslDeleteRangeByScore(zs-&gt;zsl,&amp;range,zs-&gt;dict);
1179              break;
1180          case ZRANGE_LEX:
1181              deleted = zslDeleteRangeByLex(zs-&gt;zsl,&amp;lexrange,zs-&gt;dict);
1182              break;
1183          }
1184          if (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);
1185          if (dictSize(zs-&gt;dict) == 0) {
1186              dbDelete(c-&gt;db,key);
1187              keyremoved = 1;
1188          }
1189      } else {
1190          serverPanic(&quot;Unknown sorted set encoding&quot;);
1191      }
1192      if (deleted) {
1193          char *event[3] = {&quot;zremrangebyrank&quot;,&quot;zremrangebyscore&quot;,&quot;zremrangebylex&quot;};
1194          signalModifiedKey(c-&gt;db,key);
1195          notifyKeyspaceEvent(NOTIFY_ZSET,event[rangetype],key,c-&gt;db-&gt;id);
1196          if (keyremoved)
1197              notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,key,c-&gt;db-&gt;id);
1198      }
1199      server.dirty += deleted;
1200      addReplyLongLong(c,deleted);
1201  cleanup:
1202      if (rangetype == ZRANGE_LEX) zslFreeLexRange(&amp;lexrange);
1203  }
1204  void zremrangebyrankCommand(client *c) {
1205      zremrangeGenericCommand(c,ZRANGE_RANK);
1206  }
1207  void zremrangebyscoreCommand(client *c) {
1208      zremrangeGenericCommand(c,ZRANGE_SCORE);
1209  }
1210  void zremrangebylexCommand(client *c) {
1211      zremrangeGenericCommand(c,ZRANGE_LEX);
1212  }
1213  typedef struct {
1214      robj *subject;
1215      int type; &amp;bsol;* Set, sorted set */
1216      int encoding;
1217      double weight;
1218      union {
1219          union _iterset {
1220              struct {
1221                  intset *is;
1222                  int ii;
1223              } is;
1224              struct {
1225                  dict *dict;
1226                  dictIterator *di;
1227                  dictEntry *de;
1228              } ht;
1229          } set;
1230          union _iterzset {
1231              struct {
1232                  unsigned char *zl;
1233                  unsigned char *eptr, *sptr;
1234              } zl;
1235              struct {
1236                  zset *zs;
1237                  zskiplistNode *node;
1238              } sl;
1239          } zset;
1240      } iter;
1241  } zsetopsrc;
1242  #define OPVAL_DIRTY_SDS 1
1243  #define OPVAL_DIRTY_LL 2
1244  #define OPVAL_VALID_LL 4
1245  typedef struct {
1246      int flags;
1247      unsigned char _buf[32]; &amp;bsol;* Private buffer. */
1248      sds ele;
1249      unsigned char *estr;
1250      unsigned int elen;
1251      PORT_LONGLONG ell;
1252      double score;
1253  } zsetopval;
1254  typedef union _iterset iterset;
1255  typedef union _iterzset iterzset;
1256  void zuiInitIterator(zsetopsrc *op) {
1257      if (op-&gt;subject == NULL)
1258          return;
1259      if (op-&gt;type == OBJ_SET) {
1260          iterset *it = &amp;op-&gt;iter.set;
1261          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1262              it-&gt;is.is = op-&gt;subject-&gt;ptr;
1263              it-&gt;is.ii = 0;
1264          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1265              it-&gt;ht.dict = op-&gt;subject-&gt;ptr;
1266              it-&gt;ht.di = dictGetIterator(op-&gt;subject-&gt;ptr);
1267              it-&gt;ht.de = dictNext(it-&gt;ht.di);
1268          } else {
1269              serverPanic(&quot;Unknown set encoding&quot;);
1270          }
1271      } else if (op-&gt;type == OBJ_ZSET) {
1272          iterzset *it = &amp;op-&gt;iter.zset;
1273          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1274              it-&gt;zl.zl = op-&gt;subject-&gt;ptr;
1275              it-&gt;zl.eptr = ziplistIndex(it-&gt;zl.zl,0);
1276              if (it-&gt;zl.eptr != NULL) {
1277                  it-&gt;zl.sptr = ziplistNext(it-&gt;zl.zl,it-&gt;zl.eptr);
1278                  serverAssert(it-&gt;zl.sptr != NULL);
1279              }
1280          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1281              it-&gt;sl.zs = op-&gt;subject-&gt;ptr;
1282              it-&gt;sl.node = it-&gt;sl.zs-&gt;zsl-&gt;header-&gt;level[0].forward;
1283          } else {
1284              serverPanic(&quot;Unknown sorted set encoding&quot;);
1285          }
1286      } else {
1287          serverPanic(&quot;Unsupported type&quot;);
1288      }
1289  }
1290  void zuiClearIterator(zsetopsrc *op) {
1291      if (op-&gt;subject == NULL)
1292          return;
1293      if (op-&gt;type == OBJ_SET) {
1294          iterset *it = &amp;op-&gt;iter.set;
1295          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1296              UNUSED(it); &amp;bsol;* skip */
1297          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1298              dictReleaseIterator(it-&gt;ht.di);
1299          } else {
1300              serverPanic(&quot;Unknown set encoding&quot;);
1301          }
1302      } else if (op-&gt;type == OBJ_ZSET) {
1303          iterzset *it = &amp;op-&gt;iter.zset;
1304          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1305              UNUSED(it); &amp;bsol;* skip */
1306          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1307              UNUSED(it); &amp;bsol;* skip */
1308          } else {
1309              serverPanic(&quot;Unknown sorted set encoding&quot;);
1310          }
1311      } else {
1312          serverPanic(&quot;Unsupported type&quot;);
1313      }
1314  }
1315  PORT_ULONG zuiLength(zsetopsrc *op) {
1316      if (op-&gt;subject == NULL)
1317          return 0;
1318      if (op-&gt;type == OBJ_SET) {
1319          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1320              return intsetLen(op-&gt;subject-&gt;ptr);
1321          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1322              dict *ht = op-&gt;subject-&gt;ptr;
1323              return dictSize(ht);
1324          } else {
1325              serverPanic(&quot;Unknown set encoding&quot;);
1326          }
1327      } else if (op-&gt;type == OBJ_ZSET) {
1328          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1329              return zzlLength(op-&gt;subject-&gt;ptr);
1330          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1331              zset *zs = op-&gt;subject-&gt;ptr;
1332              return zs-&gt;zsl-&gt;length;
1333          } else {
1334              serverPanic(&quot;Unknown sorted set encoding&quot;);
1335          }
1336      } else {
1337          serverPanic(&quot;Unsupported type&quot;);
1338      }
1339  }
1340  int zuiNext(zsetopsrc *op, zsetopval *val) {
1341      if (op-&gt;subject == NULL)
1342          return 0;
1343      if (val-&gt;flags &amp; OPVAL_DIRTY_SDS)
1344          sdsfree(val-&gt;ele);
1345      memset(val,0,sizeof(zsetopval));
1346      if (op-&gt;type == OBJ_SET) {
1347          iterset *it = &amp;op-&gt;iter.set;
1348          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1349              int64_t ell;
1350              if (!intsetGet(it-&gt;is.is,it-&gt;is.ii,&amp;ell))
1351                  return 0;
1352              val-&gt;ell = ell;
1353              val-&gt;score = 1.0;
1354              it-&gt;is.ii++;
1355          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1356              if (it-&gt;ht.de == NULL)
1357                  return 0;
1358              val-&gt;ele = dictGetKey(it-&gt;ht.de);
1359              val-&gt;score = 1.0;
1360              it-&gt;ht.de = dictNext(it-&gt;ht.di);
1361          } else {
1362              serverPanic(&quot;Unknown set encoding&quot;);
1363          }
1364      } else if (op-&gt;type == OBJ_ZSET) {
1365          iterzset *it = &amp;op-&gt;iter.zset;
1366          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1367              if (it-&gt;zl.eptr == NULL || it-&gt;zl.sptr == NULL)
1368                  return 0;
1369              serverAssert(ziplistGet(it-&gt;zl.eptr,&amp;val-&gt;estr,&amp;val-&gt;elen,&amp;val-&gt;ell));
1370              val-&gt;score = zzlGetScore(it-&gt;zl.sptr);
1371              zzlNext(it-&gt;zl.zl,&amp;it-&gt;zl.eptr,&amp;it-&gt;zl.sptr);
1372          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1373              if (it-&gt;sl.node == NULL)
1374                  return 0;
1375              val-&gt;ele = it-&gt;sl.node-&gt;ele;
1376              val-&gt;score = it-&gt;sl.node-&gt;score;
1377              it-&gt;sl.node = it-&gt;sl.node-&gt;level[0].forward;
1378          } else {
1379              serverPanic(&quot;Unknown sorted set encoding&quot;);
1380          }
1381      } else {
1382          serverPanic(&quot;Unsupported type&quot;);
1383      }
1384      return 1;
1385  }
1386  int zuiLongLongFromValue(zsetopval *val) {
1387      if (!(val-&gt;flags &amp; OPVAL_DIRTY_LL)) {
1388          val-&gt;flags |= OPVAL_DIRTY_LL;
1389          if (val-&gt;ele != NULL) {
1390              if (string2ll(val-&gt;ele,sdslen(val-&gt;ele),&amp;val-&gt;ell))
1391                  val-&gt;flags |= OPVAL_VALID_LL;
1392          } else if (val-&gt;estr != NULL) {
1393              if (string2ll((char*)val-&gt;estr,val-&gt;elen,&amp;val-&gt;ell))
1394                  val-&gt;flags |= OPVAL_VALID_LL;
1395          } else {
1396              val-&gt;flags |= OPVAL_VALID_LL;
1397          }
1398      }
1399      return val-&gt;flags &amp; OPVAL_VALID_LL;
1400  }
1401  sds zuiSdsFromValue(zsetopval *val) {
1402      if (val-&gt;ele == NULL) {
1403          if (val-&gt;estr != NULL) {
1404              val-&gt;ele = sdsnewlen((char*)val-&gt;estr,val-&gt;elen);
1405          } else {
1406              val-&gt;ele = sdsfromlonglong(val-&gt;ell);
1407          }
1408          val-&gt;flags |= OPVAL_DIRTY_SDS;
1409      }
1410      return val-&gt;ele;
1411  }
1412  sds zuiNewSdsFromValue(zsetopval *val) {
1413      if (val-&gt;flags &amp; OPVAL_DIRTY_SDS) {
1414          sds ele = val-&gt;ele;
1415          val-&gt;flags &amp;= ~OPVAL_DIRTY_SDS;
1416          val-&gt;ele = NULL;
1417          return ele;
1418      } else if (val-&gt;ele) {
1419          return sdsdup(val-&gt;ele);
1420      } else if (val-&gt;estr) {
1421          return sdsnewlen((char*)val-&gt;estr,val-&gt;elen);
1422      } else {
1423          return sdsfromlonglong(val-&gt;ell);
1424      }
1425  }
1426  int zuiBufferFromValue(zsetopval *val) {
1427      if (val-&gt;estr == NULL) {
1428          if (val-&gt;ele != NULL) {
1429              val-&gt;elen = sdslen(val-&gt;ele);
1430              val-&gt;estr = (unsigned char*)val-&gt;ele;
1431          } else {
1432              val-&gt;elen = ll2string((char*)val-&gt;_buf,sizeof(val-&gt;_buf),val-&gt;ell);
1433              val-&gt;estr = val-&gt;_buf;
1434          }
1435      }
1436      return 1;
1437  }
1438  int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
1439      if (op-&gt;subject == NULL)
1440          return 0;
1441      if (op-&gt;type == OBJ_SET) {
1442          if (op-&gt;encoding == OBJ_ENCODING_INTSET) {
1443              if (zuiLongLongFromValue(val) &amp;&amp;
1444                  intsetFind(op-&gt;subject-&gt;ptr,val-&gt;ell))
1445              {
1446                  *score = 1.0;
1447                  return 1;
1448              } else {
1449                  return 0;
1450              }
1451          } else if (op-&gt;encoding == OBJ_ENCODING_HT) {
1452              dict *ht = op-&gt;subject-&gt;ptr;
1453              zuiSdsFromValue(val);
1454              if (dictFind(ht,val-&gt;ele) != NULL) {
1455                  *score = 1.0;
1456                  return 1;
1457              } else {
1458                  return 0;
1459              }
1460          } else {
1461              serverPanic(&quot;Unknown set encoding&quot;);
1462          }
1463      } else if (op-&gt;type == OBJ_ZSET) {
1464          zuiSdsFromValue(val);
1465          if (op-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1466              if (zzlFind(op-&gt;subject-&gt;ptr,val-&gt;ele,score) != NULL) {
1467                  return 1;
1468              } else {
1469                  return 0;
1470              }
1471          } else if (op-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1472              zset *zs = op-&gt;subject-&gt;ptr;
1473              dictEntry *de;
1474              if ((de = dictFind(zs-&gt;dict,val-&gt;ele)) != NULL) {
1475                  *score = *(double*)dictGetVal(de);
1476                  return 1;
1477              } else {
1478                  return 0;
1479              }
1480          } else {
1481              serverPanic(&quot;Unknown sorted set encoding&quot;);
1482          }
1483      } else {
1484          serverPanic(&quot;Unsupported type&quot;);
1485      }
1486  }
1487  int zuiCompareByCardinality(const void *s1, const void *s2) {
1488      PORT_ULONG first = zuiLength((zsetopsrc*)s1);
1489      PORT_ULONG second = zuiLength((zsetopsrc*)s2);
1490      if (first &gt; second) return 1;
1491      if (first &lt; second) return -1;
1492      return 0;
1493  }
1494  #define REDIS_AGGR_SUM 1
1495  #define REDIS_AGGR_MIN 2
1496  #define REDIS_AGGR_MAX 3
1497  #define zunionInterDictValue(_e) (dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))
1498  inline static void zunionInterAggregate(double *target, double val, int aggregate) {
1499      if (aggregate == REDIS_AGGR_SUM) {
1500          *target = *target + val;
1501          if (isnan(*target)) *target = 0.0;
1502      } else if (aggregate == REDIS_AGGR_MIN) {
1503          *target = val &lt; *target ? val : *target;
1504      } else if (aggregate == REDIS_AGGR_MAX) {
1505          *target = val &gt; *target ? val : *target;
1506      } else {
1507          serverPanic(&quot;Unknown ZUNION/INTER aggregate type&quot;);
1508      }
1509  }
1510  uint64_t dictSdsHash(const void *key);
1511  int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
1512  dictType setAccumulatorDictType = {
1513      dictSdsHash,               &amp;bsol;* hash function */
1514      NULL,                      &amp;bsol;* key dup */
1515      NULL,                      &amp;bsol;* val dup */
1516      dictSdsKeyCompare,         &amp;bsol;* key compare */
1517      NULL,                      &amp;bsol;* key destructor */
1518      NULL                       &amp;bsol;* val destructor */
1519  };
1520  void zunionInterGenericCommand(client *c, robj *dstkey, int op) {
1521      int i, j;
1522      PORT_LONG setnum;
1523      int aggregate = REDIS_AGGR_SUM;
1524      zsetopsrc *src;
1525      zsetopval zval;
1526      sds tmp;
1527      size_t maxelelen = 0;
1528      robj *dstobj;
1529      zset *dstzset;
1530      zskiplistNode *znode;
1531      int touched = 0;
1532      if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;setnum, NULL) != C_OK))
1533          return;
1534      if (setnum &lt; 1) {
1535          addReplyError(c,
1536              &quot;at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE&quot;);
1537          return;
1538      }
1539      if (setnum &gt; c-&gt;argc-3) {
1540          addReply(c,shared.syntaxerr);
1541          return;
1542      }
1543      src = zcalloc(sizeof(zsetopsrc) * setnum);
1544      for (i = 0, j = 3; i &lt; setnum; i++, j++) {
1545          robj *obj = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);
1546          if (obj != NULL) {
1547              if (obj-&gt;type != OBJ_ZSET &amp;&amp; obj-&gt;type != OBJ_SET) {
1548                  zfree(src);
1549                  addReply(c,shared.wrongtypeerr);
1550                  return;
1551              }
1552              src[i].subject = obj;
1553              src[i].type = obj-&gt;type;
1554              src[i].encoding = obj-&gt;encoding;
1555          } else {
1556              src[i].subject = NULL;
1557          }
1558          src[i].weight = 1.0;
1559      }
1560      if (j &lt; c-&gt;argc) {
1561          int remaining = c-&gt;argc - j;
1562          while (remaining) {
1563              if (remaining &gt;= (setnum + 1) &amp;&amp;
1564                  !strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;weights&quot;))
1565              {
1566                  j++; remaining--;
1567                  for (i = 0; i &lt; setnum; i++, j++, remaining--) {
1568                      if (getDoubleFromObjectOrReply(c,c-&gt;argv[j],&amp;src[i].weight,
1569                              &quot;weight value is not a float&quot;) != C_OK)
1570                      {
1571                          zfree(src);
1572                          return;
1573                      }
1574                  }
1575              } else if (remaining &gt;= 2 &amp;&amp;
1576                         !strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;aggregate&quot;))
1577              {
1578                  j++; remaining--;
1579                  if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;sum&quot;)) {
1580                      aggregate = REDIS_AGGR_SUM;
1581                  } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;min&quot;)) {
1582                      aggregate = REDIS_AGGR_MIN;
1583                  } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;max&quot;)) {
1584                      aggregate = REDIS_AGGR_MAX;
1585                  } else {
1586                      zfree(src);
1587                      addReply(c,shared.syntaxerr);
1588                      return;
1589                  }
1590                  j++; remaining--;
1591              } else {
1592                  zfree(src);
1593                  addReply(c,shared.syntaxerr);
1594                  return;
1595              }
1596          }
1597      }
1598      qsort(src,setnum,sizeof(zsetopsrc),zuiCompareByCardinality);
1599      dstobj = createZsetObject();
1600      dstzset = dstobj-&gt;ptr;
1601      memset(&amp;zval, 0, sizeof(zval));
1602      if (op == SET_OP_INTER) {
1603          if (zuiLength(&amp;src[0]) &gt; 0) {
1604              zuiInitIterator(&amp;src[0]);
1605              while (zuiNext(&amp;src[0],&amp;zval)) {
1606                  double score, value;
1607                  score = src[0].weight * zval.score;
1608                  if (isnan(score)) score = 0;
1609                  for (j = 1; j &lt; setnum; j++) {
1610                      if (src[j].subject == src[0].subject) {
1611                          value = zval.score*src[j].weight;
1612                          zunionInterAggregate(&amp;score,value,aggregate);
1613                      } else if (zuiFind(&amp;src[j],&amp;zval,&amp;value)) {
1614                          value *= src[j].weight;
1615                          zunionInterAggregate(&amp;score,value,aggregate);
1616                      } else {
1617                          break;
1618                      }
1619                  }
1620                  if (j == setnum) {
1621                      tmp = zuiNewSdsFromValue(&amp;zval);
1622                      znode = zslInsert(dstzset-&gt;zsl,score,tmp);
1623                      dictAdd(dstzset-&gt;dict,tmp,&amp;znode-&gt;score);
1624                      if (sdslen(tmp) &gt; maxelelen) maxelelen = sdslen(tmp);
1625                  }
1626              }
1627              zuiClearIterator(&amp;src[0]);
1628          }
1629      } else if (op == SET_OP_UNION) {
1630          dict *accumulator = dictCreate(&amp;setAccumulatorDictType,NULL);
1631          dictIterator *di;
1632          dictEntry *de, *existing;
1633          double score;
1634          if (setnum) {
1635              dictExpand(accumulator,zuiLength(&amp;src[setnum-1]));
1636          }
1637          for (i = 0; i &lt; setnum; i++) {
1638              if (zuiLength(&amp;src[i]) == 0) continue;
1639              zuiInitIterator(&amp;src[i]);
1640              while (zuiNext(&amp;src[i],&amp;zval)) {
1641                  score = src[i].weight * zval.score;
1642                  if (isnan(score)) score = 0;
1643                  de = dictAddRaw(accumulator,zuiSdsFromValue(&amp;zval),&amp;existing);
1644                  if (!existing) {
1645                      tmp = zuiNewSdsFromValue(&amp;zval);
1646                       if (sdslen(tmp) &gt; maxelelen) maxelelen = sdslen(tmp);
1647                      dictSetKey(accumulator, de, tmp);
1648                      dictSetDoubleVal(de,score);
1649                  } else {
1650                      zunionInterAggregate(&amp;existing-&gt;v.d,score,aggregate);
1651                  }
1652              }
1653              zuiClearIterator(&amp;src[i]);
1654          }
1655          di = dictGetIterator(accumulator);
1656          dictExpand(dstzset-&gt;dict,dictSize(accumulator));
1657          while((de = dictNext(di)) != NULL) {
1658              sds ele = dictGetKey(de);
1659              score = dictGetDoubleVal(de);
1660              znode = zslInsert(dstzset-&gt;zsl,score,ele);
1661              dictAdd(dstzset-&gt;dict,ele,&amp;znode-&gt;score);
1662          }
1663          dictReleaseIterator(di);
1664          dictRelease(accumulator);
1665      } else {
1666          serverPanic(&quot;Unknown operator&quot;);
1667      }
1668      if (dbDelete(c-&gt;db,dstkey))
1669          touched = 1;
1670      if (dstzset-&gt;zsl-&gt;length) {
1671          zsetConvertToZiplistIfNeeded(dstobj,maxelelen);
1672          dbAdd(c-&gt;db,dstkey,dstobj);
1673          addReplyLongLong(c,zsetLength(dstobj));
1674          signalModifiedKey(c-&gt;db,dstkey);
1675          notifyKeyspaceEvent(NOTIFY_ZSET,
1676              (op == SET_OP_UNION) ? &quot;zunionstore&quot; : &quot;zinterstore&quot;,
1677              dstkey,c-&gt;db-&gt;id);
1678          server.dirty++;
1679      } else {
1680          decrRefCount(dstobj);
1681          addReply(c,shared.czero);
1682          if (touched) {
1683              signalModifiedKey(c-&gt;db,dstkey);
1684              notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,dstkey,c-&gt;db-&gt;id);
1685              server.dirty++;
1686          }
1687      }
1688      zfree(src);
1689  }
1690  void zunionstoreCommand(client *c) {
1691      zunionInterGenericCommand(c,c-&gt;argv[1], SET_OP_UNION);
1692  }
1693  void zinterstoreCommand(client *c) {
1694      zunionInterGenericCommand(c,c-&gt;argv[1], SET_OP_INTER);
1695  }
1696  void zrangeGenericCommand(client *c, int reverse) {
1697      robj *key = c-&gt;argv[1];
1698      robj *zobj;
1699      int withscores = 0;
1700      PORT_LONG start;
1701      PORT_LONG end;
1702      PORT_LONG llen;
1703      PORT_LONG rangelen;
1704      if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;start, NULL) != C_OK) ||
1705          (getLongFromObjectOrReply(c, c-&gt;argv[3], &amp;end, NULL) != C_OK)) return;
1706      if (c-&gt;argc == 5 &amp;&amp; !strcasecmp(c-&gt;argv[4]-&gt;ptr,&quot;withscores&quot;)) {
1707          withscores = 1;
1708      } else if (c-&gt;argc &gt;= 5) {
1709          addReply(c,shared.syntaxerr);
1710          return;
1711      }
1712      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL
1713           || checkType(c,zobj,OBJ_ZSET)) return;
1714      llen = zsetLength(zobj);
1715      if (start &lt; 0) start = llen+start;
1716      if (end &lt; 0) end = llen+end;
1717      if (start &lt; 0) start = 0;
1718      if (start &gt; end || start &gt;= llen) {
1719          addReply(c,shared.emptymultibulk);
1720          return;
1721      }
1722      if (end &gt;= llen) end = llen-1;
1723      rangelen = (int)(end-start)+1;                                              WIN_PORT_FIX &amp;bsol;* cast (int) */
1724      addReplyMultiBulkLen(c, withscores ? (rangelen*2) : rangelen);
1725      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1726          unsigned char *zl = zobj-&gt;ptr;
1727          unsigned char *eptr, *sptr;
1728          unsigned char *vstr;
1729          unsigned int vlen;
1730          PORT_LONGLONG vlong;
1731          if (reverse)
1732              eptr = ziplistIndex(zl,(int)(-2-(2*start)));                        WIN_PORT_FIX &amp;bsol;* cast (int) */
1733          else
1734              eptr = ziplistIndex(zl,(int)(2*start));                             WIN_PORT_FIX &amp;bsol;* cast (int) */
1735          serverAssertWithInfo(c,zobj,eptr != NULL);
1736          sptr = ziplistNext(zl,eptr);
1737          while (rangelen--) {
1738              serverAssertWithInfo(c,zobj,eptr != NULL &amp;&amp; sptr != NULL);
1739              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
1740              if (vstr == NULL)
1741                  addReplyBulkLongLong(c,vlong);
1742              else
1743                  addReplyBulkCBuffer(c,vstr,vlen);
1744              if (withscores)
1745                  addReplyDouble(c,zzlGetScore(sptr));
1746              if (reverse)
1747                  zzlPrev(zl,&amp;eptr,&amp;sptr);
1748              else
1749                  zzlNext(zl,&amp;eptr,&amp;sptr);
1750          }
1751      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1752          zset *zs = zobj-&gt;ptr;
1753          zskiplist *zsl = zs-&gt;zsl;
1754          zskiplistNode *ln;
1755          sds ele;
1756          if (reverse) {
1757              ln = zsl-&gt;tail;
1758              if (start &gt; 0)
1759                  ln = zslGetElementByRank(zsl,llen-start);
1760          } else {
1761              ln = zsl-&gt;header-&gt;level[0].forward;
1762              if (start &gt; 0)
1763                  ln = zslGetElementByRank(zsl,start+1);
1764          }
1765          while(rangelen--) {
1766              serverAssertWithInfo(c,zobj,ln != NULL);
1767              ele = ln-&gt;ele;
1768              addReplyBulkCBuffer(c,ele,sdslen(ele));
1769              if (withscores)
1770                  addReplyDouble(c,ln-&gt;score);
1771              ln = reverse ? ln-&gt;backward : ln-&gt;level[0].forward;
1772          }
1773      } else {
1774          serverPanic(&quot;Unknown sorted set encoding&quot;);
1775      }
1776  }
1777  void zrangeCommand(client *c) {
1778      zrangeGenericCommand(c,0);
1779  }
1780  void zrevrangeCommand(client *c) {
1781      zrangeGenericCommand(c,1);
1782  }
1783  void genericZrangebyscoreCommand(client *c, int reverse) {
1784      zrangespec range;
1785      robj *key = c-&gt;argv[1];
1786      robj *zobj;
1787      PORT_LONG offset = 0, limit = -1;
1788      int withscores = 0;
1789      PORT_ULONG rangelen = 0;
1790      void *replylen = NULL;
1791      int minidx, maxidx;
1792      if (reverse) {
1793          maxidx = 2; minidx = 3;
1794      } else {
1795          minidx = 2; maxidx = 3;
1796      }
1797      if (zslParseRange(c-&gt;argv[minidx],c-&gt;argv[maxidx],&amp;range) != C_OK) {
1798          addReplyError(c,&quot;min or max is not a float&quot;);
1799          return;
1800      }
1801      if (c-&gt;argc &gt; 4) {
1802          int remaining = c-&gt;argc - 4;
1803          int pos = 4;
1804          while (remaining) {
1805              if (remaining &gt;= 1 &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,&quot;withscores&quot;)) {
1806                  pos++; remaining--;
1807                  withscores = 1;
1808              } else if (remaining &gt;= 3 &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,&quot;limit&quot;)) {
1809                  if ((getLongFromObjectOrReply(c, c-&gt;argv[pos+1], &amp;offset, NULL)
1810                          != C_OK) ||
1811                      (getLongFromObjectOrReply(c, c-&gt;argv[pos+2], &amp;limit, NULL)
1812                          != C_OK))
1813                  {
1814                      return;
1815                  }
1816                  pos += 3; remaining -= 3;
1817              } else {
1818                  addReply(c,shared.syntaxerr);
1819                  return;
1820              }
1821          }
1822      }
1823      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
1824          checkType(c,zobj,OBJ_ZSET)) return;
1825      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1826          unsigned char *zl = zobj-&gt;ptr;
1827          unsigned char *eptr, *sptr;
1828          unsigned char *vstr;
1829          unsigned int vlen;
1830          PORT_LONGLONG vlong;
1831          double score;
1832          if (reverse) {
1833              eptr = zzlLastInRange(zl,&amp;range);
1834          } else {
1835              eptr = zzlFirstInRange(zl,&amp;range);
1836          }
1837          if (eptr == NULL) {
1838              addReply(c, shared.emptymultibulk);
1839              return;
1840          }
1841          serverAssertWithInfo(c,zobj,eptr != NULL);
1842          sptr = ziplistNext(zl,eptr);
1843          replylen = addDeferredMultiBulkLength(c);
1844          while (eptr &amp;&amp; offset--) {
1845              if (reverse) {
1846                  zzlPrev(zl,&amp;eptr,&amp;sptr);
1847              } else {
1848                  zzlNext(zl,&amp;eptr,&amp;sptr);
1849              }
1850          }
1851          while (eptr &amp;&amp; limit--) {
1852              score = zzlGetScore(sptr);
1853              if (reverse) {
1854                  if (!zslValueGteMin(score,&amp;range)) break;
1855              } else {
1856                  if (!zslValueLteMax(score,&amp;range)) break;
1857              }
1858              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
1859              rangelen++;
1860              if (vstr == NULL) {
1861                  addReplyBulkLongLong(c,vlong);
1862              } else {
1863                  addReplyBulkCBuffer(c,vstr,vlen);
1864              }
1865              if (withscores) {
1866                  addReplyDouble(c,score);
1867              }
1868              if (reverse) {
1869                  zzlPrev(zl,&amp;eptr,&amp;sptr);
1870              } else {
1871                  zzlNext(zl,&amp;eptr,&amp;sptr);
1872              }
1873          }
1874      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1875          zset *zs = zobj-&gt;ptr;
1876          zskiplist *zsl = zs-&gt;zsl;
1877          zskiplistNode *ln;
1878          if (reverse) {
1879              ln = zslLastInRange(zsl,&amp;range);
1880          } else {
1881              ln = zslFirstInRange(zsl,&amp;range);
1882          }
1883          if (ln == NULL) {
1884              addReply(c, shared.emptymultibulk);
1885              return;
1886          }
1887          replylen = addDeferredMultiBulkLength(c);
1888          while (ln &amp;&amp; offset--) {
1889              if (reverse) {
1890                  ln = ln-&gt;backward;
1891              } else {
1892                  ln = ln-&gt;level[0].forward;
1893              }
1894          }
1895          while (ln &amp;&amp; limit--) {
1896              if (reverse) {
1897                  if (!zslValueGteMin(ln-&gt;score,&amp;range)) break;
1898              } else {
1899                  if (!zslValueLteMax(ln-&gt;score,&amp;range)) break;
1900              }
1901              rangelen++;
1902              addReplyBulkCBuffer(c,ln-&gt;ele,sdslen(ln-&gt;ele));
1903              if (withscores) {
1904                  addReplyDouble(c,ln-&gt;score);
1905              }
1906              if (reverse) {
1907                  ln = ln-&gt;backward;
1908              } else {
1909                  ln = ln-&gt;level[0].forward;
1910              }
1911          }
1912      } else {
1913          serverPanic(&quot;Unknown sorted set encoding&quot;);
1914      }
1915      if (withscores) {
1916          rangelen *= 2;
1917      }
1918      setDeferredMultiBulkLength(c, replylen, rangelen);
1919  }
1920  void zrangebyscoreCommand(client *c) {
1921      genericZrangebyscoreCommand(c,0);
1922  }
1923  void zrevrangebyscoreCommand(client *c) {
1924      genericZrangebyscoreCommand(c,1);
1925  }
1926  void zcountCommand(client *c) {
1927      robj *key = c-&gt;argv[1];
1928      robj *zobj;
1929      zrangespec range;
1930      PORT_ULONG count = 0;
1931      if (zslParseRange(c-&gt;argv[2],c-&gt;argv[3],&amp;range) != C_OK) {
1932          addReplyError(c,&quot;min or max is not a float&quot;);
1933          return;
1934      }
1935      if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
1936          checkType(c, zobj, OBJ_ZSET)) return;
1937      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1938          unsigned char *zl = zobj-&gt;ptr;
1939          unsigned char *eptr, *sptr;
1940          double score;
1941          eptr = zzlFirstInRange(zl,&amp;range);
1942          if (eptr == NULL) {
1943              addReply(c, shared.czero);
1944              return;
1945          }
1946          sptr = ziplistNext(zl,eptr);
1947          score = zzlGetScore(sptr);
1948          serverAssertWithInfo(c,zobj,zslValueLteMax(score,&amp;range));
1949          while (eptr) {
1950              score = zzlGetScore(sptr);
1951              if (!zslValueLteMax(score,&amp;range)) {
1952                  break;
1953              } else {
1954                  count++;
1955                  zzlNext(zl,&amp;eptr,&amp;sptr);
1956              }
1957          }
1958      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1959          zset *zs = zobj-&gt;ptr;
1960          zskiplist *zsl = zs-&gt;zsl;
1961          zskiplistNode *zn;
1962          PORT_ULONG rank;
1963          zn = zslFirstInRange(zsl, &amp;range);
1964          if (zn != NULL) {
1965              rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);
1966              count = (int)(zsl-&gt;length - (rank - 1));                            WIN_PORT_FIX &amp;bsol;* cast (int) */
1967              zn = zslLastInRange(zsl, &amp;range);
1968              if (zn != NULL) {
1969                  rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);
1970                  count -= (int)(zsl-&gt;length - rank);                             WIN_PORT_FIX &amp;bsol;* cast (int) */
1971              }
1972          }
1973      } else {
1974          serverPanic(&quot;Unknown sorted set encoding&quot;);
1975      }
1976      addReplyLongLong(c, count);
1977  }
1978  void zlexcountCommand(client *c) {
1979      robj *key = c-&gt;argv[1];
1980      robj *zobj;
1981      zlexrangespec range;
1982      PORT_ULONG count = 0;
1983      if (zslParseLexRange(c-&gt;argv[2],c-&gt;argv[3],&amp;range) != C_OK) {
1984          addReplyError(c,&quot;min or max not valid string range item&quot;);
1985          return;
1986      }
1987      if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
1988          checkType(c, zobj, OBJ_ZSET))
1989      {
1990          zslFreeLexRange(&amp;range);
1991          return;
1992      }
1993      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1994          unsigned char *zl = zobj-&gt;ptr;
1995          unsigned char *eptr, *sptr;
1996          eptr = zzlFirstInLexRange(zl,&amp;range);
1997          if (eptr == NULL) {
1998              zslFreeLexRange(&amp;range);
1999              addReply(c, shared.czero);
2000              return;
2001          }
2002          sptr = ziplistNext(zl,eptr);
2003          serverAssertWithInfo(c,zobj,zzlLexValueLteMax(eptr,&amp;range));
2004          while (eptr) {
2005              if (!zzlLexValueLteMax(eptr,&amp;range)) {
2006                  break;
2007              } else {
2008                  count++;
2009                  zzlNext(zl,&amp;eptr,&amp;sptr);
2010              }
2011          }
2012      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
2013          zset *zs = zobj-&gt;ptr;
2014          zskiplist *zsl = zs-&gt;zsl;
2015          zskiplistNode *zn;
2016          PORT_ULONG rank;
2017          zn = zslFirstInLexRange(zsl, &amp;range);
2018          if (zn != NULL) {
2019              rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);
2020              count = (int)(zsl-&gt;length - (rank - 1));                            WIN_PORT_FIX &amp;bsol;* cast (int) */
2021              zn = zslLastInLexRange(zsl, &amp;range);
2022              if (zn != NULL) {
2023                  rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);
2024                  count -= (int)(zsl-&gt;length - rank);                             WIN_PORT_FIX &amp;bsol;* cast (int) */
2025              }
2026          }
2027      } else {
2028          serverPanic(&quot;Unknown sorted set encoding&quot;);
2029      }
2030      zslFreeLexRange(&amp;range);
2031      addReplyLongLong(c, count);
2032  }
2033  void genericZrangebylexCommand(client *c, int reverse) {
2034      zlexrangespec range;
2035      robj *key = c-&gt;argv[1];
2036      robj *zobj;
2037      PORT_LONG offset = 0, limit = -1;
2038      PORT_ULONG rangelen = 0;
2039      void *replylen = NULL;
2040      int minidx, maxidx;
2041      if (reverse) {
2042          maxidx = 2; minidx = 3;
2043      } else {
2044          minidx = 2; maxidx = 3;
2045      }
2046      if (zslParseLexRange(c-&gt;argv[minidx],c-&gt;argv[maxidx],&amp;range) != C_OK) {
2047          addReplyError(c,&quot;min or max not valid string range item&quot;);
2048          return;
2049      }
2050      if (c-&gt;argc &gt; 4) {
2051          int remaining = c-&gt;argc - 4;
2052          int pos = 4;
2053          while (remaining) {
2054              if (remaining &gt;= 3 &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,&quot;limit&quot;)) {
2055                  if ((getLongFromObjectOrReply(c, c-&gt;argv[pos+1], &amp;offset, NULL) != C_OK) ||
2056                      (getLongFromObjectOrReply(c, c-&gt;argv[pos+2], &amp;limit, NULL) != C_OK)) {
2057                      zslFreeLexRange(&amp;range);
2058                      return;
2059                  }
2060                  pos += 3; remaining -= 3;
2061              } else {
2062                  zslFreeLexRange(&amp;range);
2063                  addReply(c,shared.syntaxerr);
2064                  return;
2065              }
2066          }
2067      }
2068      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
2069          checkType(c,zobj,OBJ_ZSET))
2070      {
2071          zslFreeLexRange(&amp;range);
2072          return;
2073      }
2074      if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
2075          unsigned char *zl = zobj-&gt;ptr;
2076          unsigned char *eptr, *sptr;
2077          unsigned char *vstr;
2078          unsigned int vlen;
2079          PORT_LONGLONG vlong;
2080          if (reverse) {
2081              eptr = zzlLastInLexRange(zl,&amp;range);
2082          } else {
2083              eptr = zzlFirstInLexRange(zl,&amp;range);
2084          }
2085          if (eptr == NULL) {
2086              addReply(c, shared.emptymultibulk);
2087              zslFreeLexRange(&amp;range);
2088              return;
2089          }
2090          serverAssertWithInfo(c,zobj,eptr != NULL);
2091          sptr = ziplistNext(zl,eptr);
2092          replylen = addDeferredMultiBulkLength(c);
2093          while (eptr &amp;&amp; offset--) {
2094              if (reverse) {
2095                  zzlPrev(zl,&amp;eptr,&amp;sptr);
2096              } else {
2097                  zzlNext(zl,&amp;eptr,&amp;sptr);
2098              }
2099          }
2100          while (eptr &amp;&amp; limit--) {
2101              if (reverse) {
2102                  if (!zzlLexValueGteMin(eptr,&amp;range)) break;
2103              } else {
2104                  if (!zzlLexValueLteMax(eptr,&amp;range)) break;
2105              }
2106              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
2107              rangelen++;
2108              if (vstr == NULL) {
2109                  addReplyBulkLongLong(c,vlong);
2110              } else {
2111                  addReplyBulkCBuffer(c,vstr,vlen);
2112              }
2113              if (reverse) {
2114                  zzlPrev(zl,&amp;eptr,&amp;sptr);
2115              } else {
2116                  zzlNext(zl,&amp;eptr,&amp;sptr);
2117              }
2118          }
2119      } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
2120          zset *zs = zobj-&gt;ptr;
2121          zskiplist *zsl = zs-&gt;zsl;
2122          zskiplistNode *ln;
2123          if (reverse) {
2124              ln = zslLastInLexRange(zsl,&amp;range);
2125          } else {
2126              ln = zslFirstInLexRange(zsl,&amp;range);
2127          }
2128          if (ln == NULL) {
2129              addReply(c, shared.emptymultibulk);
2130              zslFreeLexRange(&amp;range);
2131              return;
2132          }
2133          replylen = addDeferredMultiBulkLength(c);
2134          while (ln &amp;&amp; offset--) {
2135              if (reverse) {
2136                  ln = ln-&gt;backward;
2137              } else {
2138                  ln = ln-&gt;level[0].forward;
2139              }
2140          }
2141          while (ln &amp;&amp; limit--) {
2142              if (reverse) {
2143                  if (!zslLexValueGteMin(ln-&gt;ele,&amp;range)) break;
2144              } else {
2145                  if (!zslLexValueLteMax(ln-&gt;ele,&amp;range)) break;
2146              }
2147              rangelen++;
2148              addReplyBulkCBuffer(c,ln-&gt;ele,sdslen(ln-&gt;ele));
2149              if (reverse) {
2150                  ln = ln-&gt;backward;
2151              } else {
2152                  ln = ln-&gt;level[0].forward;
2153              }
2154          }
2155      } else {
2156          serverPanic(&quot;Unknown sorted set encoding&quot;);
2157      }
2158      zslFreeLexRange(&amp;range);
2159      setDeferredMultiBulkLength(c, replylen, rangelen);
2160  }
2161  void zrangebylexCommand(client *c) {
2162      genericZrangebylexCommand(c,0);
2163  }
2164  void zrevrangebylexCommand(client *c) {
2165      genericZrangebylexCommand(c,1);
2166  }
2167  void zcardCommand(client *c) {
2168      robj *key = c-&gt;argv[1];
2169      robj *zobj;
2170      if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
2171          checkType(c,zobj,OBJ_ZSET)) return;
2172      addReplyLongLong(c,zsetLength(zobj));
2173  }
2174  void zscoreCommand(client *c) {
2175      robj *key = c-&gt;argv[1];
2176      robj *zobj;
2177      double score;
2178      if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
2179          checkType(c,zobj,OBJ_ZSET)) return;
2180      if (zsetScore(zobj,c-&gt;argv[2]-&gt;ptr,&amp;score) == C_ERR) {
2181          addReply(c,shared.nullbulk);
2182      } else {
2183          addReplyDouble(c,score);
2184      }
2185  }
2186  void zrankGenericCommand(client *c, int reverse) {
2187      robj *key = c-&gt;argv[1];
2188      robj *ele = c-&gt;argv[2];
2189      robj *zobj;
2190      PORT_LONG rank;
2191      if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
2192          checkType(c,zobj,OBJ_ZSET)) return;
2193      serverAssertWithInfo(c,ele,sdsEncodedObject(ele));
2194      rank = zsetRank(zobj,ele-&gt;ptr,reverse);
2195      if (rank &gt;= 0) {
2196          addReplyLongLong(c,rank);
2197      } else {
2198          addReply(c,shared.nullbulk);
2199      }
2200  }
2201  void zrankCommand(client *c) {
2202      zrankGenericCommand(c, 0);
2203  }
2204  void zrevrankCommand(client *c) {
2205      zrankGenericCommand(c, 1);
2206  }
2207  void zscanCommand(client *c) {
2208      robj *o;
2209      PORT_ULONG cursor;
2210      if (parseScanCursorOrReply(c,c-&gt;argv[2],&amp;cursor) == C_ERR) return;
2211      if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.emptyscan)) == NULL ||
2212          checkType(c,o,OBJ_ZSET)) return;
2213      scanGenericCommand(c,o,cursor);
2214  }
2215  void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg) {
2216      int idx;
2217      robj *key = NULL;
2218      robj *zobj = NULL;
2219      sds ele;
2220      double score;
2221      PORT_LONG count = 1;
2222      if (countarg) {
2223          if (getLongFromObjectOrReply(c,countarg,&amp;count,NULL) != C_OK)
2224              return;
2225          if (count &lt;= 0) {
2226              addReply(c,shared.emptymultibulk);
2227              return;
2228          }
2229      }
2230      idx = 0;
2231      while (idx &lt; keyc) {
2232          key = keyv[idx++];
2233          zobj = lookupKeyWrite(c-&gt;db,key);
2234          if (!zobj) continue;
2235          if (checkType(c,zobj,OBJ_ZSET)) return;
2236          break;
2237      }
2238      if (!zobj) {
2239          addReply(c,shared.emptymultibulk);
2240          return;
2241      }
2242      void *arraylen_ptr = addDeferredMultiBulkLength(c);
2243      PORT_LONG arraylen = 0;
2244      if (emitkey) addReplyBulk(c,key);
2245      do {
2246          if (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
2247              unsigned char *zl = zobj-&gt;ptr;
2248              unsigned char *eptr, *sptr;
2249              unsigned char *vstr;
2250              unsigned int vlen;
2251              PORT_LONGLONG vlong;
2252              eptr = ziplistIndex(zl,where == ZSET_MAX ? -2 : 0);
2253              serverAssertWithInfo(c,zobj,eptr != NULL);
2254              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));
2255              if (vstr == NULL)
2256                  ele = sdsfromlonglong(vlong);
2257              else
2258                  ele = sdsnewlen(vstr,vlen);
2259              sptr = ziplistNext(zl,eptr);
2260              serverAssertWithInfo(c,zobj,sptr != NULL);
2261              score = zzlGetScore(sptr);
2262          } else if (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
2263              zset *zs = zobj-&gt;ptr;
2264              zskiplist *zsl = zs-&gt;zsl;
2265              zskiplistNode *zln;
2266              zln = (where == ZSET_MAX ? zsl-&gt;tail :
2267                                         zsl-&gt;header-&gt;level[0].forward);
2268              serverAssertWithInfo(c,zobj,zln != NULL);
2269              ele = sdsdup(zln-&gt;ele);
2270              score = zln-&gt;score;
2271          } else {
2272              serverPanic(&quot;Unknown sorted set encoding&quot;);
2273          }
2274          serverAssertWithInfo(c,zobj,zsetDel(zobj,ele));
2275          server.dirty++;
2276          if (arraylen == 0) { &amp;bsol;* Do this only for the first iteration. */
2277              char *events[2] = {&quot;zpopmin&quot;,&quot;zpopmax&quot;};
2278              notifyKeyspaceEvent(NOTIFY_ZSET,events[where],key,c-&gt;db-&gt;id);
2279              signalModifiedKey(c-&gt;db,key);
2280          }
2281          addReplyBulkCBuffer(c,ele,sdslen(ele));
2282          addReplyDouble(c,score);
2283          sdsfree(ele);
2284          arraylen += 2;
2285          if (zsetLength(zobj) == 0) {
2286              dbDelete(c-&gt;db,key);
2287              notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,key,c-&gt;db-&gt;id);
2288              break;
2289          }
2290      } while(--count);
2291      setDeferredMultiBulkLength(c,arraylen_ptr,arraylen + (emitkey != 0));
2292  }
2293  void zpopminCommand(client *c) {
2294      if (c-&gt;argc &gt; 3) {
2295          addReply(c,shared.syntaxerr);
2296          return;
2297      }
2298      genericZpopCommand(c,&amp;c-&gt;argv[1],1,ZSET_MIN,0,
2299          c-&gt;argc == 3 ? c-&gt;argv[2] : NULL);
2300  }
2301  void zpopmaxCommand(client *c) {
2302      if (c-&gt;argc &gt; 3) {
2303          addReply(c,shared.syntaxerr);
2304          return;
2305      }
2306      genericZpopCommand(c,&amp;c-&gt;argv[1],1,ZSET_MAX,0,
2307          c-&gt;argc == 3 ? c-&gt;argv[2] : NULL);
2308  }
2309  void blockingGenericZpopCommand(client *c, int where) {
2310      robj *o;
2311      mstime_t timeout;
2312      int j;
2313      if (getTimeoutFromObjectOrReply(c,c-&gt;argv[c-&gt;argc-1],&amp;timeout,UNIT_SECONDS)
2314          != C_OK) return;
2315      for (j = 1; j &lt; c-&gt;argc-1; j++) {
2316          o = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);
2317          if (o != NULL) {
2318              if (o-&gt;type != OBJ_ZSET) {
2319                  addReply(c,shared.wrongtypeerr);
2320                  return;
2321              } else {
2322                  if (zsetLength(o) != 0) {
2323                      genericZpopCommand(c,&amp;c-&gt;argv[j],1,where,1,NULL);
2324                      rewriteClientCommandVector(c,2,
2325                          where == ZSET_MAX ? shared.zpopmax : shared.zpopmin,
2326                          c-&gt;argv[j]);
2327                      return;
2328                  }
2329              }
2330          }
2331      }
2332      if (c-&gt;flags &amp; CLIENT_MULTI) {
2333          addReply(c,shared.nullmultibulk);
2334          return;
2335      }
2336      blockForKeys(c,BLOCKED_ZSET,c-&gt;argv + 1,c-&gt;argc - 2,timeout,NULL,NULL);
2337  }
2338  void bzpopminCommand(client *c) {
2339      blockingGenericZpopCommand(c,ZSET_MIN);
2340  }
2341  void bzpopmaxCommand(client *c) {
2342      blockingGenericZpopCommand(c,ZSET_MAX);
2343  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_zset.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_zset.c</div>
                </div>
                <div class="column column_space"><pre><code>194                  x = x-&gt;level[i].forward;
195      }
196      x = x-&gt;level[0].forward;
197      serverAssert(x != NULL);
198      if (!zslValueLteMax(x-&gt;score,range)) return NULL;
199      return x;
200  }
201  zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
202      zskiplistNode *x;
203      int i;
204      if (!zslIsInRange(zsl,range)) return NULL;
205      x = zsl-&gt;header;
206      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
207          while (x-&gt;level[i].forward &amp;&amp;
208              zslValueLteMax(x-&gt;level[i].forward-&gt;score,range))
209                  x = x-&gt;level[i].forward;
210      }
211      serverAssert(x != NULL);
212      if (!zslValueGteMin(x-&gt;score,range)) return NULL;
213      return x;
214  }
215  PORT_ULONG zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
</pre></code></div>
                <div class="column column_space"><pre><code>432                  x = x-&gt;level[i].forward;
433      }
434      x = x-&gt;level[0].forward;
435      serverAssert(x != NULL);
436      if (!zslLexValueLteMax(x-&gt;ele,range)) return NULL;
437      return x;
438  }
439  zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
440      zskiplistNode *x;
441      int i;
442      if (!zslIsInLexRange(zsl,range)) return NULL;
443      x = zsl-&gt;header;
444      for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
445          while (x-&gt;level[i].forward &amp;&amp;
446              zslLexValueLteMax(x-&gt;level[i].forward-&gt;ele,range))
447                  x = x-&gt;level[i].forward;
448      }
449      serverAssert(x != NULL);
450      if (!zslLexValueGteMin(x-&gt;ele,range)) return NULL;
451      return x;
452  }
453  double zzlGetScore(unsigned char *sptr) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    