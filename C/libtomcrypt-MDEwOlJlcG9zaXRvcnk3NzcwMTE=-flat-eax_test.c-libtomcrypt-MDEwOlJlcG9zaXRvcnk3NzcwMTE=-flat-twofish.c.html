
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 18.265895953757223%, Tokens: 18</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-eax_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_EAX_MODE
3  int eax_test(void)
4  {
5  #ifndef LTC_TEST
6     return CRYPT_NOP;
7  #else
8     static const struct {
9         int               keylen,
10                         noncelen,
11                        headerlen,
12                           msglen;
13         unsigned char        key[MAXBLOCKSIZE],
14                            nonce[MAXBLOCKSIZE],
15                           header[MAXBLOCKSIZE],
16                        plaintext[MAXBLOCKSIZE],
17                       ciphertext[MAXBLOCKSIZE],
18                              tag[MAXBLOCKSIZE];
19     } tests[] = {
20  {
21     16, 0, 0, 0,
22     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
23       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
24     { 0 },
25     { 0 },
26     { 0 },
27     { 0 },
28     { 0x9a, 0xd0, 0x7e, 0x7d, 0xbf, 0xf3, 0x01, 0xf5,
29       0x05, 0xde, 0x59, 0x6b, 0x96, 0x15, 0xdf, 0xff }
30  },
31  {
32     16, 16, 0, 0,
33     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
34       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
35     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
36       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
<span onclick='openModal()' class='match'>37     { 0 },
38     { 0 },
39     { 0 },
40     { 0x1c, 0xe1, 0x0d, 0x3e, 0xff, 0xd4, 0xca, 0xdb,
41       0xe2, 0xe4, 0x4b, 0x58, 0xd6, 0x0a, 0xb9, 0xec }
42  },
43  {
44     16, 0, 16, 0,
45     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
46       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
47     { 0 },
48     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
49       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
50     { 0 },
</span>51     { 0 },
52     { 0x3a, 0x69, 0x8f, 0x7a, 0x27, 0x0e, 0x51, 0xb0,
53       0xf6, 0x5b, 0x3d, 0x3e, 0x47, 0x19, 0x3c, 0xff }
54  },
55  {
56     16, 16, 16, 32,
57     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
58       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
59     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
60       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
61     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
62       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
63     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
64       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
65       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
66       0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
67     { 0x29, 0xd8, 0x78, 0xd1, 0xa3, 0xbe, 0x85, 0x7b,
68       0x6f, 0xb8, 0xc8, 0xea, 0x59, 0x50, 0xa7, 0x78,
69       0x33, 0x1f, 0xbf, 0x2c, 0xcf, 0x33, 0x98, 0x6f,
70       0x35, 0xe8, 0xcf, 0x12, 0x1d, 0xcb, 0x30, 0xbc },
71     { 0x4f, 0xbe, 0x03, 0x38, 0xbe, 0x1c, 0x8c, 0x7e,
72       0x1d, 0x7a, 0xe7, 0xe4, 0x5b, 0x92, 0xc5, 0x87 }
73  },
74  {
75     16, 15, 14, 29,
76     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
77       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
78     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
79       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e },
80     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
81       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d },
82     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
83       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
84       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
85       0x18, 0x19, 0x1a, 0x1b, 0x1c },
86     { 0xdd, 0x25, 0xc7, 0x54, 0xc5, 0xb1, 0x7c, 0x59,
87       0x28, 0xb6, 0x9b, 0x73, 0x15, 0x5f, 0x7b, 0xb8,
88       0x88, 0x8f, 0xaf, 0x37, 0x09, 0x1a, 0xd9, 0x2c,
89       0x8a, 0x24, 0xdb, 0x86, 0x8b },
90     { 0x0d, 0x1a, 0x14, 0xe5, 0x22, 0x24, 0xff, 0xd2,
91       0x3a, 0x05, 0xfa, 0x02, 0xcd, 0xef, 0x52, 0xda }
92  },
93  {
94     16, 16, 8, 0,
95     { 0x23, 0x39, 0x52, 0xde, 0xe4, 0xd5, 0xed, 0x5f,
96       0x9b, 0x9c, 0x6d, 0x6f, 0xf8, 0x0f, 0xf4, 0x78 },
97     { 0x62, 0xec, 0x67, 0xf9, 0xc3, 0xa4, 0xa4, 0x07,
98       0xfc, 0xb2, 0xa8, 0xc4, 0x90, 0x31, 0xa8, 0xb3 },
99     { 0x6b, 0xfb, 0x91, 0x4f, 0xd0, 0x7e, 0xae, 0x6b },
100     { 0x00 },
101     { 0x00 },
102     { 0xe0, 0x37, 0x83, 0x0e, 0x83, 0x89, 0xf2, 0x7b,
103       0x02, 0x5a, 0x2d, 0x65, 0x27, 0xe7, 0x9d, 0x01 }
104  },
105  {
106     16, 16, 8, 2,
107     { 0x91, 0x94, 0x5d, 0x3f, 0x4d, 0xcb, 0xee, 0x0b,
108       0xf4, 0x5e, 0xf5, 0x22, 0x55, 0xf0, 0x95, 0xa4 },
109     { 0xbe, 0xca, 0xf0, 0x43, 0xb0, 0xa2, 0x3d, 0x84,
110       0x31, 0x94, 0xba, 0x97, 0x2c, 0x66, 0xde, 0xbd },
111     { 0xfa, 0x3b, 0xfd, 0x48, 0x06, 0xeb, 0x53, 0xfa },
112     { 0xf7, 0xfb },
113     { 0x19, 0xdd },
114     { 0x5c, 0x4c, 0x93, 0x31, 0x04, 0x9d, 0x0b, 0xda,
115       0xb0, 0x27, 0x74, 0x08, 0xf6, 0x79, 0x67, 0xe5 }
116  },
117  {
118     16, 16, 8, 5,
119     { 0x01, 0xf7, 0x4a, 0xd6, 0x40, 0x77, 0xf2, 0xe7,
120       0x04, 0xc0, 0xf6, 0x0a, 0xda, 0x3d, 0xd5, 0x23 },
121     { 0x70, 0xc3, 0xdb, 0x4f, 0x0d, 0x26, 0x36, 0x84,
122       0x00, 0xa1, 0x0e, 0xd0, 0x5d, 0x2b, 0xff, 0x5e },
123     { 0x23, 0x4a, 0x34, 0x63, 0xc1, 0x26, 0x4a, 0xc6 },
124     { 0x1a, 0x47, 0xcb, 0x49, 0x33 },
125     { 0xd8, 0x51, 0xd5, 0xba, 0xe0 },
126     { 0x3a, 0x59, 0xf2, 0x38, 0xa2, 0x3e, 0x39, 0x19,
127       0x9d, 0xc9, 0x26, 0x66, 0x26, 0xc4, 0x0f, 0x80 }
128  }
129  };
130     int err, x, idx, res;
131     unsigned long len;
132     unsigned char outct[MAXBLOCKSIZE], outtag[MAXBLOCKSIZE];
133      if ((idx = find_cipher("aes")) == -1) {
134         if ((idx = find_cipher("rijndael")) == -1) {
135            return CRYPT_NOP;
136         }
137      }
138      for (x = 0; x < (int)(sizeof(tests)/sizeof(tests[0])); x++) {
139          len = sizeof(outtag);
140          if ((err = eax_encrypt_authenticate_memory(idx, tests[x].key, tests[x].keylen,
141              tests[x].nonce, tests[x].noncelen, tests[x].header, tests[x].headerlen,
142              tests[x].plaintext, tests[x].msglen, outct, outtag, &len)) != CRYPT_OK) {
143             return err;
144          }
145          if (compare_testvector(outtag, len, tests[x].tag, len, "EAX Tag", x) ||
146                compare_testvector(outct, tests[x].msglen, tests[x].ciphertext, tests[x].msglen, "EAX CT", x)) {
147             return CRYPT_FAIL_TESTVECTOR;
148          }
149          if ((err = eax_decrypt_verify_memory(idx, tests[x].key, tests[x].keylen,
150               tests[x].nonce, tests[x].noncelen, tests[x].header, tests[x].headerlen,
151               outct, tests[x].msglen, outct, outtag, len, &res)) != CRYPT_OK) {
152              return err;
153          }
154          if ((res != 1) || compare_testvector(outct, tests[x].msglen, tests[x].plaintext, tests[x].msglen, "EAX", x)) {
155  #ifdef LTC_TEST_DBG
156             printf("\n\nEAX: Failure-decrypt - res = %d\n", res);
157  #endif
158             return CRYPT_FAIL_TESTVECTOR;
159          }
160      }
161      return CRYPT_OK;
162  #endif &bsol;* LTC_TEST */
163  }
164  #endif &bsol;* LTC_EAX_MODE */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-twofish.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_TWOFISH
3  #ifdef LTC_TWOFISH_ALL_TABLES
4  #ifndef LTC_TWOFISH_TABLES
5  #define LTC_TWOFISH_TABLES
6  #endif
7  #endif
8  const struct ltc_cipher_descriptor twofish_desc =
9  {
10      "twofish",
11      7,
12      16, 32, 16, 16,
13      &twofish_setup,
14      &twofish_ecb_encrypt,
15      &twofish_ecb_decrypt,
16      &twofish_test,
17      &twofish_done,
18      &twofish_keysize,
19      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
20  };
21  #ifndef LTC_TWOFISH_TABLES
22  #define MDS_POLY          0x169
23  #endif
24  #ifndef LTC_TWOFISH_ALL_TABLES
25  #define RS_POLY           0x14D
26  #endif
27  static const unsigned char RS[4][8] = {
28      { 0x01, 0xA4, 0x55, 0x87, 0x5A, 0x58, 0xDB, 0x9E },
29      { 0xA4, 0x56, 0x82, 0xF3, 0X1E, 0XC6, 0X68, 0XE5 },
30      { 0X02, 0XA1, 0XFC, 0XC1, 0X47, 0XAE, 0X3D, 0X19 },
31      { 0XA4, 0X55, 0X87, 0X5A, 0X58, 0XDB, 0X9E, 0X03 }
32  };
33  #ifdef LTC_TWOFISH_SMALL
34  static const unsigned char qord[4][5] = {
35     { 1, 1, 0, 0, 1 },
36     { 0, 1, 1, 0, 0 },
37     { 0, 0, 0, 1, 1 },
38     { 1, 0, 1, 1, 0 }
39  };
40  #endif &bsol;* LTC_TWOFISH_SMALL */
41  #ifdef LTC_TWOFISH_TABLES
42  #define LTC_TWOFISH_TAB_C
43  #include "twofish_tab.c"
44  #define sbox(i, x) ((ulong32)SBOX[i][(x)&255])
45  #else
46  static const unsigned char qbox[2][4][16] = {
47  {
<span onclick='openModal()' class='match'>48     { 0x8, 0x1, 0x7, 0xD, 0x6, 0xF, 0x3, 0x2, 0x0, 0xB, 0x5, 0x9, 0xE, 0xC, 0xA, 0x4 },
49     { 0xE, 0XC, 0XB, 0X8, 0X1, 0X2, 0X3, 0X5, 0XF, 0X4, 0XA, 0X6, 0X7, 0X0, 0X9, 0XD },
50     { 0XB, 0XA, 0X5, 0XE, 0X6, 0XD, 0X9, 0X0, 0XC, 0X8, 0XF, 0X3, 0X2, 0X4, 0X7, 0X1 },
51     { 0XD, 0X7, 0XF, 0X4, 0X1, 0X2, 0X6, 0XE, 0X9, 0XB, 0X3, 0X0, 0X8, 0X5, 0XC, 0XA }
52  },
53  {
54     { 0X2, 0X8, 0XB, 0XD, 0XF, 0X7, 0X6, 0XE, 0X3, 0X1, 0X9, 0X4, 0X0, 0XA, 0XC, 0X5 },
55     { 0X1, 0XE, 0X2, 0XB, 0X4, 0XC, 0X3, 0X7, 0X6, 0XD, 0XA, 0X5, 0XF, 0X9, 0X0, 0X8 },
56     { 0X4, 0XC, 0X7, 0X5, 0X1, 0X6, 0X9, 0XA, 0X0, 0XE, 0XD, 0X8, 0X2, 0XB, 0X3, 0XF },
57     { 0xB, 0X9, 0X5, 0X1, 0XC, 0X3, 0XD, 0XE, 0X6, 0X4, 0X7, 0XF, 0X2, 0X0, 0X8, 0XA }
</span>58  }
59  };
60  #ifdef LTC_CLEAN_STACK
61  static ulong32 s_sbox(int i, ulong32 x)
62  #else
63  static ulong32 sbox(int i, ulong32 x)
64  #endif
65  {
66     unsigned char a0,b0,a1,b1,a2,b2,a3,b3,a4,b4,y;
67     a0 = (unsigned char)((x>>4)&15);
68     b0 = (unsigned char)((x)&15);
69     a1 = a0 ^ b0;
70     b1 = (a0 ^ ((b0<<3)|(b0>>1)) ^ (a0<<3)) & 15;
71     a2 = qbox[i][0][(int)a1];
72     b2 = qbox[i][1][(int)b1];
73     a3 = a2 ^ b2;
74     b3 = (a2 ^ ((b2<<3)|(b2>>1)) ^ (a2<<3)) & 15;
75     a4 = qbox[i][2][(int)a3];
76     b4 = qbox[i][3][(int)b3];
77     y = (b4 << 4) + a4;
78     return (ulong32)y;
79  }
80  #ifdef LTC_CLEAN_STACK
81  static ulong32 sbox(int i, ulong32 x)
82  {
83     ulong32 y;
84     y = s_sbox(i, x);
85     burn_stack(sizeof(unsigned char) * 11);
86     return y;
87  }
88  #endif &bsol;* LTC_CLEAN_STACK */
89  #endif &bsol;* LTC_TWOFISH_TABLES */
90  static ulong32 gf_mult(ulong32 a, ulong32 b, ulong32 p)
91  {
92     ulong32 result, B[2], P[2];
93     P[1] = p;
94     B[1] = b;
95     result = P[0] = B[0] = 0;
96     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
97     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
98     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
99     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
100     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
101     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
102     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
103     result ^= B[a&1];
104     return result;
105  }
106  #ifndef LTC_TWOFISH_TABLES
107  static ulong32 mds_column_mult(unsigned char in, int col)
108  {
109     ulong32 x01, x5B, xEF;
110     x01 = in;
111     x5B = gf_mult(in, 0x5B, MDS_POLY);
112     xEF = gf_mult(in, 0xEF, MDS_POLY);
113     switch (col) {
114         case 0:
115            return (x01 << 0 ) |
116                   (x5B << 8 ) |
117                   (xEF << 16) |
118                   (xEF << 24);
119         case 1:
120            return (xEF << 0 ) |
121                   (xEF << 8 ) |
122                   (x5B << 16) |
123                   (x01 << 24);
124         case 2:
125            return (x5B << 0 ) |
126                   (xEF << 8 ) |
127                   (x01 << 16) |
128                   (xEF << 24);
129         case 3:
130            return (x5B << 0 ) |
131                   (x01 << 8 ) |
132                   (xEF << 16) |
133                   (x5B << 24);
134     }
135     return 0;
136  }
137  #else &bsol;* !LTC_TWOFISH_TABLES */
138  #define mds_column_mult(x, i) mds_tab[i][x]
139  #endif &bsol;* LTC_TWOFISH_TABLES */
140  static void mds_mult(const unsigned char *in, unsigned char *out)
141  {
142    int x;
143    ulong32 tmp;
144    for (tmp = x = 0; x < 4; x++) {
145        tmp ^= mds_column_mult(in[x], x);
146    }
147    STORE32L(tmp, out);
148  }
149  #ifdef LTC_TWOFISH_ALL_TABLES
150  static void rs_mult(const unsigned char *in, unsigned char *out)
151  {
152     ulong32 tmp;
153     tmp = rs_tab0[in[0]] ^ rs_tab1[in[1]] ^ rs_tab2[in[2]] ^ rs_tab3[in[3]] ^
154           rs_tab4[in[4]] ^ rs_tab5[in[5]] ^ rs_tab6[in[6]] ^ rs_tab7[in[7]];
155     STORE32L(tmp, out);
156  }
157  #else &bsol;* !LTC_TWOFISH_ALL_TABLES */
158  static void rs_mult(const unsigned char *in, unsigned char *out)
159  {
160    int x, y;
161    for (x = 0; x < 4; x++) {
162        out[x] = 0;
163        for (y = 0; y < 8; y++) {
164            out[x] ^= gf_mult(in[y], RS[x][y], RS_POLY);
165        }
166    }
167  }
168  #endif
169  static void h_func(const unsigned char *in, unsigned char *out, const unsigned char *M, int k, int offset)
170  {
171    int x;
172    unsigned char y[4];
173    for (x = 0; x < 4; x++) {
174        y[x] = in[x];
175    }
176    switch (k) {
177       case 4:
178              y[0] = (unsigned char)(sbox(1, (ulong32)y[0]) ^ M[4 * (6 + offset) + 0]);
179              y[1] = (unsigned char)(sbox(0, (ulong32)y[1]) ^ M[4 * (6 + offset) + 1]);
180              y[2] = (unsigned char)(sbox(0, (ulong32)y[2]) ^ M[4 * (6 + offset) + 2]);
181              y[3] = (unsigned char)(sbox(1, (ulong32)y[3]) ^ M[4 * (6 + offset) + 3]);
182       case 3:
183              y[0] = (unsigned char)(sbox(1, (ulong32)y[0]) ^ M[4 * (4 + offset) + 0]);
184              y[1] = (unsigned char)(sbox(1, (ulong32)y[1]) ^ M[4 * (4 + offset) + 1]);
185              y[2] = (unsigned char)(sbox(0, (ulong32)y[2]) ^ M[4 * (4 + offset) + 2]);
186              y[3] = (unsigned char)(sbox(0, (ulong32)y[3]) ^ M[4 * (4 + offset) + 3]);
187       case 2:
188              y[0] = (unsigned char)(sbox(1, sbox(0, sbox(0, (ulong32)y[0]) ^ M[4 * (2 + offset) + 0]) ^ M[4 * (0 + offset) + 0]));
189              y[1] = (unsigned char)(sbox(0, sbox(0, sbox(1, (ulong32)y[1]) ^ M[4 * (2 + offset) + 1]) ^ M[4 * (0 + offset) + 1]));
190              y[2] = (unsigned char)(sbox(1, sbox(1, sbox(0, (ulong32)y[2]) ^ M[4 * (2 + offset) + 2]) ^ M[4 * (0 + offset) + 2]));
191              y[3] = (unsigned char)(sbox(0, sbox(1, sbox(1, (ulong32)y[3]) ^ M[4 * (2 + offset) + 3]) ^ M[4 * (0 + offset) + 3]));
192    }
193    mds_mult(y, out);
194  }
195  #ifndef LTC_TWOFISH_SMALL
196  #if defined(__GNUC__)
197      #define S1 skey->twofish.S[0]
198      #define S2 skey->twofish.S[1]
199      #define S3 skey->twofish.S[2]
200      #define S4 skey->twofish.S[3]
201  #endif
202  #define g_func(x, dum)  (S1[LTC_BYTE(x,0)] ^ S2[LTC_BYTE(x,1)] ^ S3[LTC_BYTE(x,2)] ^ S4[LTC_BYTE(x,3)])
203  #define g1_func(x, dum) (S2[LTC_BYTE(x,0)] ^ S3[LTC_BYTE(x,1)] ^ S4[LTC_BYTE(x,2)] ^ S1[LTC_BYTE(x,3)])
204  #else
205  #ifdef LTC_CLEAN_STACK
206  static ulong32 s_g_func(ulong32 x, const symmetric_key *key)
207  #else
208  static ulong32 g_func(ulong32 x, const symmetric_key *key)
209  #endif
210  {
211     unsigned char g, i, y, z;
212     ulong32 res;
213     res = 0;
214     for (y = 0; y < 4; y++) {
215         z = key->twofish.start;
216         g = sbox(qord[y][z++], (x >> (8*y)) & 255);
217         i = 0;
218         while (z != 5) {
219            g = g ^ key->twofish.S[4*i++ + y];
220            g = sbox(qord[y][z++], g);
221         }
222         res ^= mds_column_mult(g, y);
223     }
224     return res;
225  }
226  #define g1_func(x, key) g_func(ROLc(x, 8), key)
227  #ifdef LTC_CLEAN_STACK
228  static ulong32 g_func(ulong32 x, const symmetric_key *key)
229  {
230      ulong32 y;
231      y = s_g_func(x, key);
232      burn_stack(sizeof(unsigned char) * 4 + sizeof(ulong32));
233      return y;
234  }
235  #endif &bsol;* LTC_CLEAN_STACK */
236  #endif &bsol;* LTC_TWOFISH_SMALL */
237  #ifdef LTC_CLEAN_STACK
238  static int s_twofish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
239  #else
240  int twofish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
241  #endif
242  {
243  #ifndef LTC_TWOFISH_SMALL
244     unsigned char S[4*4], tmpx0, tmpx1;
245  #endif
246     int k, x, y;
247     unsigned char tmp[4], tmp2[4], M[8*4];
248     ulong32 A, B;
249     LTC_ARGCHK(key  != NULL);
250     LTC_ARGCHK(skey != NULL);
251     if (num_rounds != 16 && num_rounds != 0) {
252        return CRYPT_INVALID_ROUNDS;
253     }
254     if (keylen != 16 && keylen != 24 && keylen != 32) {
255        return CRYPT_INVALID_KEYSIZE;
256     }
257     k = keylen / 8;
258     for (x = 0; x < keylen; x++) {
259         M[x] = key[x] & 255;
260     }
261  #ifndef LTC_TWOFISH_SMALL
262     for (x = 0; x < k; x++) {
263         rs_mult(M+(x*8), S+(x*4));
264     }
265  #else
266     for (x = 0; x < k; x++) {
267         rs_mult(M+(x*8), skey->twofish.S+(x*4));
268     }
269  #endif
270     for (x = 0; x < 20; x++) {
271         for (y = 0; y < 4; y++) {
272             tmp[y] = x+x;
273         }
274         h_func(tmp, tmp2, M, k, 0);
275         LOAD32L(A, tmp2);
276         for (y = 0; y < 4; y++) {
277             tmp[y] = (unsigned char)(x+x+1);
278         }
279         h_func(tmp, tmp2, M, k, 1);
280         LOAD32L(B, tmp2);
281         B = ROLc(B, 8);
282         skey->twofish.K[x+x] = (A + B) & 0xFFFFFFFFUL;
283         skey->twofish.K[x+x+1] = ROLc(B + B + A, 9);
284     }
285  #ifndef LTC_TWOFISH_SMALL
286     if (k == 2) {
287          for (x = 0; x < 256; x++) {
288             tmpx0 = (unsigned char)sbox(0, x);
289             tmpx1 = (unsigned char)sbox(1, x);
290             skey->twofish.S[0][x] = mds_column_mult(sbox(1, (sbox(0, tmpx0 ^ S[0]) ^ S[4])),0);
291             skey->twofish.S[1][x] = mds_column_mult(sbox(0, (sbox(0, tmpx1 ^ S[1]) ^ S[5])),1);
292             skey->twofish.S[2][x] = mds_column_mult(sbox(1, (sbox(1, tmpx0 ^ S[2]) ^ S[6])),2);
293             skey->twofish.S[3][x] = mds_column_mult(sbox(0, (sbox(1, tmpx1 ^ S[3]) ^ S[7])),3);
294          }
295     } else if (k == 3) {
296          for (x = 0; x < 256; x++) {
297             tmpx0 = (unsigned char)sbox(0, x);
298             tmpx1 = (unsigned char)sbox(1, x);
299             skey->twofish.S[0][x] = mds_column_mult(sbox(1, (sbox(0, sbox(0, tmpx1 ^ S[0]) ^ S[4]) ^ S[8])),0);
300             skey->twofish.S[1][x] = mds_column_mult(sbox(0, (sbox(0, sbox(1, tmpx1 ^ S[1]) ^ S[5]) ^ S[9])),1);
301             skey->twofish.S[2][x] = mds_column_mult(sbox(1, (sbox(1, sbox(0, tmpx0 ^ S[2]) ^ S[6]) ^ S[10])),2);
302             skey->twofish.S[3][x] = mds_column_mult(sbox(0, (sbox(1, sbox(1, tmpx0 ^ S[3]) ^ S[7]) ^ S[11])),3);
303          }
304     } else {
305          for (x = 0; x < 256; x++) {
306             tmpx0 = (unsigned char)sbox(0, x);
307             tmpx1 = (unsigned char)sbox(1, x);
308             skey->twofish.S[0][x] = mds_column_mult(sbox(1, (sbox(0, sbox(0, sbox(1, tmpx1 ^ S[0]) ^ S[4]) ^ S[8]) ^ S[12])),0);
309             skey->twofish.S[1][x] = mds_column_mult(sbox(0, (sbox(0, sbox(1, sbox(1, tmpx0 ^ S[1]) ^ S[5]) ^ S[9]) ^ S[13])),1);
310             skey->twofish.S[2][x] = mds_column_mult(sbox(1, (sbox(1, sbox(0, sbox(0, tmpx0 ^ S[2]) ^ S[6]) ^ S[10]) ^ S[14])),2);
311             skey->twofish.S[3][x] = mds_column_mult(sbox(0, (sbox(1, sbox(1, sbox(0, tmpx1 ^ S[3]) ^ S[7]) ^ S[11]) ^ S[15])),3);
312          }
313     }
314  #else
315     switch (k) {
316           case 4 : skey->twofish.start = 0; break;
317           case 3 : skey->twofish.start = 1; break;
318           default: skey->twofish.start = 2; break;
319     }
320  #endif
321     return CRYPT_OK;
322  }
323  #ifdef LTC_CLEAN_STACK
324  int twofish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
325  {
326     int x;
327     x = s_twofish_setup(key, keylen, num_rounds, skey);
328     burn_stack(sizeof(int) * 7 + sizeof(unsigned char) * 56 + sizeof(ulong32) * 2);
329     return x;
330  }
331  #endif
332  #ifdef LTC_CLEAN_STACK
333  static int s_twofish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
334  #else
335  int twofish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
336  #endif
337  {
338      ulong32 a,b,c,d,ta,tb,tc,td,t1,t2;
339      const ulong32 *k;
340      int r;
341  #if !defined(LTC_TWOFISH_SMALL) && !defined(__GNUC__)
342      const ulong32 *S1, *S2, *S3, *S4;
343  #endif
344      LTC_ARGCHK(pt   != NULL);
345      LTC_ARGCHK(ct   != NULL);
346      LTC_ARGCHK(skey != NULL);
347  #if !defined(LTC_TWOFISH_SMALL) && !defined(__GNUC__)
348      S1 = skey->twofish.S[0];
349      S2 = skey->twofish.S[1];
350      S3 = skey->twofish.S[2];
351      S4 = skey->twofish.S[3];
352  #endif
353      LOAD32L(a,&pt[0]); LOAD32L(b,&pt[4]);
354      LOAD32L(c,&pt[8]); LOAD32L(d,&pt[12]);
355      a ^= skey->twofish.K[0];
356      b ^= skey->twofish.K[1];
357      c ^= skey->twofish.K[2];
358      d ^= skey->twofish.K[3];
359      k  = skey->twofish.K + 8;
360      for (r = 8; r != 0; --r) {
361          t2 = g1_func(b, skey);
362          t1 = g_func(a, skey) + t2;
363          c  = RORc(c ^ (t1 + k[0]), 1);
364          d  = ROLc(d, 1) ^ (t2 + t1 + k[1]);
365          t2 = g1_func(d, skey);
366          t1 = g_func(c, skey) + t2;
367          a  = RORc(a ^ (t1 + k[2]), 1);
368          b  = ROLc(b, 1) ^ (t2 + t1 + k[3]);
369          k += 4;
370      }
371      ta = c ^ skey->twofish.K[4];
372      tb = d ^ skey->twofish.K[5];
373      tc = a ^ skey->twofish.K[6];
374      td = b ^ skey->twofish.K[7];
375      STORE32L(ta,&ct[0]); STORE32L(tb,&ct[4]);
376      STORE32L(tc,&ct[8]); STORE32L(td,&ct[12]);
377      return CRYPT_OK;
378  }
379  #ifdef LTC_CLEAN_STACK
380  int twofish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
381  {
382     int err = s_twofish_ecb_encrypt(pt, ct, skey);
383     burn_stack(sizeof(ulong32) * 10 + sizeof(int));
384     return err;
385  }
386  #endif
387  #ifdef LTC_CLEAN_STACK
388  static int s_twofish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
389  #else
390  int twofish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
391  #endif
392  {
393      ulong32 a,b,c,d,ta,tb,tc,td,t1,t2;
394      const ulong32 *k;
395      int r;
396  #if !defined(LTC_TWOFISH_SMALL) && !defined(__GNUC__)
397      const ulong32 *S1, *S2, *S3, *S4;
398  #endif
399      LTC_ARGCHK(pt   != NULL);
400      LTC_ARGCHK(ct   != NULL);
401      LTC_ARGCHK(skey != NULL);
402  #if !defined(LTC_TWOFISH_SMALL) && !defined(__GNUC__)
403      S1 = skey->twofish.S[0];
404      S2 = skey->twofish.S[1];
405      S3 = skey->twofish.S[2];
406      S4 = skey->twofish.S[3];
407  #endif
408      LOAD32L(ta,&ct[0]); LOAD32L(tb,&ct[4]);
409      LOAD32L(tc,&ct[8]); LOAD32L(td,&ct[12]);
410      a = tc ^ skey->twofish.K[6];
411      b = td ^ skey->twofish.K[7];
412      c = ta ^ skey->twofish.K[4];
413      d = tb ^ skey->twofish.K[5];
414      k = skey->twofish.K + 36;
415      for (r = 8; r != 0; --r) {
416          t2 = g1_func(d, skey);
417          t1 = g_func(c, skey) + t2;
418          a = ROLc(a, 1) ^ (t1 + k[2]);
419          b = RORc(b ^ (t2 + t1 + k[3]), 1);
420          t2 = g1_func(b, skey);
421          t1 = g_func(a, skey) + t2;
422          c = ROLc(c, 1) ^ (t1 + k[0]);
423          d = RORc(d ^ (t2 +  t1 + k[1]), 1);
424          k -= 4;
425      }
426      a ^= skey->twofish.K[0];
427      b ^= skey->twofish.K[1];
428      c ^= skey->twofish.K[2];
429      d ^= skey->twofish.K[3];
430      STORE32L(a, &pt[0]); STORE32L(b, &pt[4]);
431      STORE32L(c, &pt[8]); STORE32L(d, &pt[12]);
432      return CRYPT_OK;
433  }
434  #ifdef LTC_CLEAN_STACK
435  int twofish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
436  {
437     int err = s_twofish_ecb_decrypt(ct, pt, skey);
438     burn_stack(sizeof(ulong32) * 10 + sizeof(int));
439     return err;
440  }
441  #endif
442  int twofish_test(void)
443  {
444   #ifndef LTC_TEST
445      return CRYPT_NOP;
446   #else
447   static const struct {
448       int keylen;
449       unsigned char key[32], pt[16], ct[16];
450   } tests[] = {
451     { 16,
452       { 0x9F, 0x58, 0x9F, 0x5C, 0xF6, 0x12, 0x2C, 0x32,
453         0xB6, 0xBF, 0xEC, 0x2F, 0x2A, 0xE8, 0xC3, 0x5A },
454       { 0xD4, 0x91, 0xDB, 0x16, 0xE7, 0xB1, 0xC3, 0x9E,
455         0x86, 0xCB, 0x08, 0x6B, 0x78, 0x9F, 0x54, 0x19 },
456       { 0x01, 0x9F, 0x98, 0x09, 0xDE, 0x17, 0x11, 0x85,
457         0x8F, 0xAA, 0xC3, 0xA3, 0xBA, 0x20, 0xFB, 0xC3 }
458     }, {
459       24,
460       { 0x88, 0xB2, 0xB2, 0x70, 0x6B, 0x10, 0x5E, 0x36,
461         0xB4, 0x46, 0xBB, 0x6D, 0x73, 0x1A, 0x1E, 0x88,
462         0xEF, 0xA7, 0x1F, 0x78, 0x89, 0x65, 0xBD, 0x44 },
463       { 0x39, 0xDA, 0x69, 0xD6, 0xBA, 0x49, 0x97, 0xD5,
464         0x85, 0xB6, 0xDC, 0x07, 0x3C, 0xA3, 0x41, 0xB2 },
465       { 0x18, 0x2B, 0x02, 0xD8, 0x14, 0x97, 0xEA, 0x45,
466         0xF9, 0xDA, 0xAC, 0xDC, 0x29, 0x19, 0x3A, 0x65 }
467     }, {
468       32,
469       { 0xD4, 0x3B, 0xB7, 0x55, 0x6E, 0xA3, 0x2E, 0x46,
470         0xF2, 0xA2, 0x82, 0xB7, 0xD4, 0x5B, 0x4E, 0x0D,
471         0x57, 0xFF, 0x73, 0x9D, 0x4D, 0xC9, 0x2C, 0x1B,
472         0xD7, 0xFC, 0x01, 0x70, 0x0C, 0xC8, 0x21, 0x6F },
473       { 0x90, 0xAF, 0xE9, 0x1B, 0xB2, 0x88, 0x54, 0x4F,
474         0x2C, 0x32, 0xDC, 0x23, 0x9B, 0x26, 0x35, 0xE6 },
475       { 0x6C, 0xB4, 0x56, 0x1C, 0x40, 0xBF, 0x0A, 0x97,
476         0x05, 0x93, 0x1C, 0xB6, 0xD4, 0x08, 0xE7, 0xFA }
477     }
478  };
479    symmetric_key key;
480    unsigned char tmp[2][16];
481    int err, i, y;
482    for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
483      if ((err = twofish_setup(tests[i].key, tests[i].keylen, 0, &key)) != CRYPT_OK) {
484         return err;
485      }
486      twofish_ecb_encrypt(tests[i].pt, tmp[0], &key);
487      twofish_ecb_decrypt(tmp[0], tmp[1], &key);
488      if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "Twofish Encrypt", i) != 0 ||
489            compare_testvector(tmp[1], 16, tests[i].pt, 16, "Twofish Decrypt", i) != 0) {
490         return CRYPT_FAIL_TESTVECTOR;
491      }
492      for (y = 0; y < 16; y++) tmp[0][y] = 0;
493      for (y = 0; y < 1000; y++) twofish_ecb_encrypt(tmp[0], tmp[0], &key);
494      for (y = 0; y < 1000; y++) twofish_ecb_decrypt(tmp[0], tmp[0], &key);
495      for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
496    }
497    return CRYPT_OK;
498  #endif
499  }
500  void twofish_done(symmetric_key *skey)
501  {
502    LTC_UNUSED_PARAM(skey);
503  }
504  int twofish_keysize(int *keysize)
505  {
506     LTC_ARGCHK(keysize);
507     if (*keysize < 16) {
508        return CRYPT_INVALID_KEYSIZE;
509     }
510     if (*keysize < 24) {
511        *keysize = 16;
512        return CRYPT_OK;
513     }
514     if (*keysize < 32) {
515        *keysize = 24;
516        return CRYPT_OK;
517     }
518     *keysize = 32;
519     return CRYPT_OK;
520  }
521  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-eax_test.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-twofish.c</div>
                </div>
                <div class="column column_space"><pre><code>37     { 0 },
38     { 0 },
39     { 0 },
40     { 0x1c, 0xe1, 0x0d, 0x3e, 0xff, 0xd4, 0xca, 0xdb,
41       0xe2, 0xe4, 0x4b, 0x58, 0xd6, 0x0a, 0xb9, 0xec }
42  },
43  {
44     16, 0, 16, 0,
45     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
46       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
47     { 0 },
48     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
49       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
50     { 0 },
</pre></code></div>
                <div class="column column_space"><pre><code>48     { 0x8, 0x1, 0x7, 0xD, 0x6, 0xF, 0x3, 0x2, 0x0, 0xB, 0x5, 0x9, 0xE, 0xC, 0xA, 0x4 },
49     { 0xE, 0XC, 0XB, 0X8, 0X1, 0X2, 0X3, 0X5, 0XF, 0X4, 0XA, 0X6, 0X7, 0X0, 0X9, 0XD },
50     { 0XB, 0XA, 0X5, 0XE, 0X6, 0XD, 0X9, 0X0, 0XC, 0X8, 0XF, 0X3, 0X2, 0X4, 0X7, 0X1 },
51     { 0XD, 0X7, 0XF, 0X4, 0X1, 0X2, 0X6, 0XE, 0X9, 0XB, 0X3, 0X0, 0X8, 0X5, 0XC, 0XA }
52  },
53  {
54     { 0X2, 0X8, 0XB, 0XD, 0XF, 0X7, 0X6, 0XE, 0X3, 0X1, 0X9, 0X4, 0X0, 0XA, 0XC, 0X5 },
55     { 0X1, 0XE, 0X2, 0XB, 0X4, 0XC, 0X3, 0X7, 0X6, 0XD, 0XA, 0X5, 0XF, 0X9, 0X0, 0X8 },
56     { 0X4, 0XC, 0X7, 0X5, 0X1, 0X6, 0X9, 0XA, 0X0, 0XE, 0XD, 0X8, 0X2, 0XB, 0X3, 0XF },
57     { 0xB, 0X9, 0X5, 0X1, 0XC, 0X3, 0XD, 0XE, 0X6, 0X4, 0X7, 0XF, 0X2, 0X0, 0X8, 0XA }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    