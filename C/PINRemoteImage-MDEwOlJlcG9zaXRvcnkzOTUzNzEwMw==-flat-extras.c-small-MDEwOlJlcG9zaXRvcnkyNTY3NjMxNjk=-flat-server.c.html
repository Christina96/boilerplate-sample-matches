
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.451202905129369%, Tokens: 10</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-extras.c</h3>
            <pre><code>1  #include "extras/extras.h"
2  #include "webp/format_constants.h"
3  #include "src/dsp/dsp.h"
4  #include <assert.h>
5  #include <string.h>
6  #define XTRA_MAJ_VERSION 1
7  #define XTRA_MIN_VERSION 1
8  #define XTRA_REV_VERSION 0
9  int WebPGetExtrasVersion(void) {
10    return (XTRA_MAJ_VERSION << 16) | (XTRA_MIN_VERSION << 8) | XTRA_REV_VERSION;
11  }
12  int WebPImportGray(const uint8_t* gray_data, WebPPicture* pic) {
13    int y, width, uv_width;
14    if (pic == NULL || gray_data == NULL) return 0;
15    pic->colorspace = WEBP_YUV420;
16    if (!WebPPictureAlloc(pic)) return 0;
17    width = pic->width;
18    uv_width = (width + 1) >> 1;
19    for (y = 0; y < pic->height; ++y) {
20      memcpy(pic->y + y * pic->y_stride, gray_data, width);
21      gray_data += width;    
22      if ((y & 1) == 0) {
23        memset(pic->u + (y >> 1) * pic->uv_stride, 128, uv_width);
24        memset(pic->v + (y >> 1) * pic->uv_stride, 128, uv_width);
25      }
26    }
27    return 1;
28  }
29  int WebPImportRGB565(const uint8_t* rgb565, WebPPicture* pic) {
30    int x, y;
31    uint32_t* dst;
32    if (pic == NULL || rgb565 == NULL) return 0;
33    pic->colorspace = WEBP_YUV420;
34    pic->use_argb = 1;
35    if (!WebPPictureAlloc(pic)) return 0;
36    dst = pic->argb;
37    for (y = 0; y < pic->height; ++y) {
38      const int width = pic->width;
39      for (x = 0; x < width; ++x) {
40  #if defined(WEBP_SWAP_16BIT_CSP) && (WEBP_SWAP_16BIT_CSP == 1)
41        const uint32_t rg = rgb565[2 * x + 1];
42        const uint32_t gb = rgb565[2 * x + 0];
43  #else
44        const uint32_t rg = rgb565[2 * x + 0];
45        const uint32_t gb = rgb565[2 * x + 1];
46  #endif
47        uint32_t r = rg & 0xf8;
48        uint32_t g = ((rg << 5) | (gb >> 3)) & 0xfc;
49        uint32_t b = (gb << 5);
50        r = r | (r >> 5);
51        g = g | (g >> 6);
52        b = b | (b >> 5);
53        dst[x] = (0xffu << 24) | (r << 16) | (g << 8) | b;
54      }
55      rgb565 += 2 * width;
56      dst += pic->argb_stride;
57    }
58    return 1;
59  }
60  int WebPImportRGB4444(const uint8_t* rgb4444, WebPPicture* pic) {
61    int x, y;
62    uint32_t* dst;
63    if (pic == NULL || rgb4444 == NULL) return 0;
64    pic->colorspace = WEBP_YUV420;
65    pic->use_argb = 1;
66    if (!WebPPictureAlloc(pic)) return 0;
67    dst = pic->argb;
68    for (y = 0; y < pic->height; ++y) {
69      const int width = pic->width;
70      for (x = 0; x < width; ++x) {
71  #if defined(WEBP_SWAP_16BIT_CSP) && (WEBP_SWAP_16BIT_CSP == 1)
72        const uint32_t rg = rgb4444[2 * x + 1];
73        const uint32_t ba = rgb4444[2 * x + 0];
74  #else
75        const uint32_t rg = rgb4444[2 * x + 0];
<span onclick='openModal()' class='match'>76        const uint32_t ba = rgb4444[2 * x + 1];
77  #endif
78        uint32_t r = rg & 0xf0;
79        uint32_t g = (rg << 4);
80        uint32_t b = (ba & 0xf0);
81        uint32_t a = (ba << 4);
82        r = r | (r >> 4);
83        g = g | (g >> 4);
84        b = b | (b >> 4);
85        a = a | (a >> 4);
86        dst[x] = (a << 24) | (r << 16) | (g << 8) | b;
</span>87      }
88      rgb4444 += 2 * width;
89      dst += pic->argb_stride;
90    }
91    return 1;
92  }
93  int WebPImportColorMappedARGB(const uint8_t* indexed, int indexed_stride,
94                                const uint32_t palette[], int palette_size,
95                                WebPPicture* pic) {
96    int x, y;
97    uint32_t* dst;
98    assert(MAX_PALETTE_SIZE <= 256);
99    if (pic == NULL || indexed == NULL || indexed_stride < pic->width ||
100        palette == NULL || palette_size > MAX_PALETTE_SIZE || palette_size <= 0) {
101      return 0;
102    }
103    pic->use_argb = 1;
104    if (!WebPPictureAlloc(pic)) return 0;
105    dst = pic->argb;
106    for (y = 0; y < pic->height; ++y) {
107      for (x = 0; x < pic->width; ++x) {
108        if (indexed[x] >= palette_size) {
109          WebPPictureFree(pic);
110          return 0;
111        }
112        dst[x] = palette[indexed[x]];
113      }
114      indexed += indexed_stride;
115      dst += pic->argb_stride;
116    }
117    return 1;
118  }
119  int WebPUnmultiplyARGB(WebPPicture* pic) {
120    int y;
121    uint32_t* dst;
122    if (pic == NULL || pic->use_argb != 1 || pic->argb == NULL) return 0;
123    WebPInitAlphaProcessing();
124    dst = pic->argb;
125    for (y = 0; y < pic->height; ++y) {
126      WebPMultARGBRow(dst, pic->width, &bsol;*inverse=*/1);
127      dst += pic->argb_stride;
128    }
129    return 1;
130  }
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-server.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "config.h"
3  #endif
4  #include <sys/stat.h>
5  #include <sys/types.h>
6  #include <fcntl.h>
7  #include <locale.h>
8  #include <signal.h>
9  #include <string.h>
10  #include <strings.h>
11  #include <time.h>
12  #include <unistd.h>
13  #include <getopt.h>
14  #include <math.h>
15  #ifndef __MINGW32__
16  #include <netdb.h>
17  #include <errno.h>
18  #include <arpa/inet.h>
19  #include <netinet/in.h>
20  #include <pthread.h>
21  #include <sys/un.h>
22  #endif
23  #include <libcork/core.h>
24  #include <udns.h>
25  #ifdef __MINGW32__
26  #include "win32.h"
27  #endif
28  #if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H) && defined(__linux__)
29  #include <net/if.h>
30  #include <sys/ioctl.h>
31  #define SET_INTERFACE
32  #endif
33  #include "netutils.h"
34  #include "utils.h"
35  #include "acl.h"
36  #include "server.h"
37  #include "obfs.c" 
38  #ifndef EAGAIN
39  #define EAGAIN EWOULDBLOCK
40  #endif
41  #ifndef EWOULDBLOCK
42  #define EWOULDBLOCK EAGAIN
43  #endif
44  #ifndef BUF_SIZE
45  #define BUF_SIZE 2048
46  #endif
47  #ifndef SSMAXCONN
48  #define SSMAXCONN 1024
49  #endif
50  #ifndef UPDATE_INTERVAL
51  #define UPDATE_INTERVAL 30
52  #endif
53  static void signal_cb(EV_P_ ev_signal *w, int revents);
54  static void accept_cb(EV_P_ ev_io *w, int revents);
55  static void server_send_cb(EV_P_ ev_io *w, int revents);
56  static void server_recv_cb(EV_P_ ev_io *w, int revents);
57  static void remote_recv_cb(EV_P_ ev_io *w, int revents);
58  static void remote_send_cb(EV_P_ ev_io *w, int revents);
59  static void server_timeout_cb(EV_P_ ev_timer *watcher, int revents);
60  static void block_list_clear_cb(EV_P_ ev_timer *watcher, int revents);
61  static remote_t *new_remote(int fd);
62  static server_t *new_server(int fd, listen_ctx_t *listener);
63  static remote_t *connect_to_remote(EV_P_ struct addrinfo *res,
64                                     server_t *server);
65  static void free_remote(remote_t *remote);
66  static void close_and_free_remote(EV_P_ remote_t *remote);
67  static void free_server(server_t *server);
68  static void close_and_free_server(EV_P_ server_t *server);
69  static void server_resolve_cb(struct sockaddr *addr, void *data);
70  static void query_free_cb(void *data);
71  static size_t parse_header_len(const char atyp, const char *data, size_t offset);
72  static int is_header_complete(const buffer_t *buf);
73  int verbose = 0;
74  static int acl       = 0;
75  static int mode      = TCP_ONLY;
76  static int auth      = 0;
77  static int ipv6first = 0;
78  static int protocol_compatible = 0;
79  static int obfs_compatible = 0;
80  static int fast_open = 0;
81  #ifdef HAVE_SETRLIMIT
82  static int nofile = 0;
83  #endif
84  static int remote_conn = 0;
85  static int server_conn = 0;
86  static char *bind_address    = NULL;
87  static char *server_port     = NULL;
88  static char *manager_address = NULL;
89  uint64_t tx                  = 0;
90  uint64_t rx                  = 0;
91  ev_timer stat_update_watcher;
92  ev_timer block_list_watcher;
93  static struct cork_dllist connections;
94  static void
95  stat_update_cb(EV_P_ ev_timer *watcher, int revents)
96  {
97      struct sockaddr_un svaddr, claddr;
98      int sfd = -1;
99      size_t msgLen;
100      char resp[BUF_SIZE];
101      if (verbose) {
102          LOGI("update traffic stat: tx: %" PRIu64 " rx: %" PRIu64 "", tx, rx);
103      }
104      snprintf(resp, BUF_SIZE, "stat: {\"%s\":%" PRIu64 "}", server_port, tx + rx);
105      msgLen = strlen(resp) + 1;
106      ss_addr_t ip_addr = { .host = NULL, .port = NULL };
107      parse_addr(manager_address, &ip_addr);
108      if (ip_addr.host == NULL || ip_addr.port == NULL) {
109          sfd = socket(AF_UNIX, SOCK_DGRAM, 0);
110          if (sfd == -1) {
111              ERROR("stat_socket");
112              return;
113          }
114          memset(&claddr, 0, sizeof(struct sockaddr_un));
115          claddr.sun_family = AF_UNIX;
116          snprintf(claddr.sun_path, sizeof(claddr.sun_path), "/tmp/shadowsocks.%s", server_port);
117          unlink(claddr.sun_path);
118          if (bind(sfd, (struct sockaddr *)&claddr, sizeof(struct sockaddr_un)) == -1) {
119              ERROR("stat_bind");
120              close(sfd);
121              return;
122          }
123          memset(&svaddr, 0, sizeof(struct sockaddr_un));
124          svaddr.sun_family = AF_UNIX;
125          strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);
126          if (sendto(sfd, resp, strlen(resp) + 1, 0, (struct sockaddr *)&svaddr,
127                     sizeof(struct sockaddr_un)) != msgLen) {
128              ERROR("stat_sendto");
129              close(sfd);
130              return;
131          }
132          unlink(claddr.sun_path);
133      } else {
134          struct sockaddr_storage storage;
135          memset(&storage, 0, sizeof(struct sockaddr_storage));
136          if (get_sockaddr(ip_addr.host, ip_addr.port, &storage, 0, ipv6first) == -1) {
137              ERROR("failed to parse the manager addr");
138              return;
139          }
140          sfd = socket(storage.ss_family, SOCK_DGRAM, 0);
141          if (sfd == -1) {
142              ERROR("stat_socket");
143              return;
144          }
145          size_t addr_len = get_sockaddr_len((struct sockaddr *)&storage);
146          if (sendto(sfd, resp, strlen(resp) + 1, 0, (struct sockaddr *)&storage,
147                     addr_len) != msgLen) {
148              ERROR("stat_sendto");
149              close(sfd);
150              return;
151          }
152      }
153      close(sfd);
154  }
155  static void
156  free_connections(struct ev_loop *loop)
157  {
158      struct cork_dllist_item *curr, *next;
159      cork_dllist_foreach_void(&connections, curr, next) {
160          server_t *server = cork_container_of(curr, server_t, entries);
161          remote_t *remote = server->remote;
162          close_and_free_server(loop, server);
163          close_and_free_remote(loop, remote);
164      }
165  }
166  static size_t
167  parse_header_len(const char atyp, const char *data, size_t offset)
168  {
169      size_t len = 0;
170      if ((atyp & ADDRTYPE_MASK) == 1) {
171          len += sizeof(struct in_addr);
172      } else if ((atyp & ADDRTYPE_MASK) == 3) {
173          uint8_t name_len = *(uint8_t *)(data + offset);
174          len += name_len + 1;
175      } else if ((atyp & ADDRTYPE_MASK) == 4) {
176          len += sizeof(struct in6_addr);
177      } else {
178          return 0;
179      }
180      len += 2;
181      return len;
182  }
183  static int
184  is_header_complete(const buffer_t *buf)
185  {
186      size_t header_len = 0;
187      size_t buf_len    = buf->len;
188      char atyp = buf->array[header_len];
189      header_len++;
190      if ((atyp & ADDRTYPE_MASK) == 1) {
191          header_len += sizeof(struct in_addr);
192      } else if ((atyp & ADDRTYPE_MASK) == 3) {
193          if (buf_len < header_len + 1)
194              return 0;
195          uint8_t name_len = *(uint8_t *)(buf->array + header_len);
196          header_len += name_len + 1;
197      } else if ((atyp & ADDRTYPE_MASK) == 4) {
198          header_len += sizeof(struct in6_addr);
199      } else {
200          return -1;
201      }
202      header_len += 2;
203      if (auth || (atyp & ONETIMEAUTH_FLAG)) {
204          header_len += ONETIMEAUTH_BYTES;
205      }
206      return buf_len >= header_len ? 1 : 0;
207  }
208  static char *
209  get_peer_name(int fd)
210  {
211      static char peer_name[INET6_ADDRSTRLEN] = { 0 };
212      struct sockaddr_storage addr;
213      socklen_t len = sizeof(struct sockaddr_storage);
214      memset(&addr, 0, len);
215      memset(peer_name, 0, INET6_ADDRSTRLEN);
216      int err = getpeername(fd, (struct sockaddr *)&addr, &len);
217      if (err == 0) {
218          if (addr.ss_family == AF_INET) {
219              struct sockaddr_in *s = (struct sockaddr_in *)&addr;
220              dns_ntop(AF_INET, &s->sin_addr, peer_name, INET_ADDRSTRLEN);
221          } else if (addr.ss_family == AF_INET6) {
222              struct sockaddr_in6 *s = (struct sockaddr_in6 *)&addr;
223              dns_ntop(AF_INET6, &s->sin6_addr, peer_name, INET6_ADDRSTRLEN);
224          }
225      } else {
226          return NULL;
227      }
228      return peer_name;
229  }
230  #ifdef __linux__
231  static void
232  set_linger(int fd)
233  {
234      struct linger so_linger;
235      memset(&so_linger, 0, sizeof(struct linger));
236      so_linger.l_onoff  = 1;
237      so_linger.l_linger = 0;
238      setsockopt(fd, SOL_SOCKET, SO_LINGER, &so_linger, sizeof so_linger);
239  }
240  #endif
241  static void
242  reset_addr(int fd)
243  {
244      char *peer_name;
245      peer_name = get_peer_name(fd);
246      if (peer_name != NULL) {
247          remove_from_block_list(peer_name);
248      }
249  }
250  static void
251  report_addr(int fd, int err_level)
252  {
253  #ifdef __linux__
254      set_linger(fd);
255  #endif
256      char *peer_name;
257      peer_name = get_peer_name(fd);
258      if (peer_name != NULL) {
259          LOGE("failed to handshake with %s", peer_name);
260          update_block_list(peer_name, err_level);
261      }
262  }
263  int
264  setfastopen(int fd)
265  {
266      int s = 0;
267  #ifdef TCP_FASTOPEN
268      if (fast_open) {
269  #ifdef __APPLE__
270          int opt = 1;
271  #else
272          int opt = 5;
273  #endif
274          s = setsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN, &opt, sizeof(opt));
275          if (s == -1) {
276              if (errno == EPROTONOSUPPORT || errno == ENOPROTOOPT) {
277                  LOGE("fast open is not supported on this platform");
278                  fast_open = 0;
279              } else {
280                  ERROR("setsockopt");
281              }
282          }
283      }
284  #endif
285      return s;
286  }
287  #ifndef __MINGW32__
288  int
289  setnonblocking(int fd)
290  {
291      int flags;
292      if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
293          flags = 0;
294      }
295      return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
296  }
297  #endif
298  int
299  create_and_bind(const char *host, const char *port, int mptcp)
300  {
301      struct addrinfo hints;
302      struct addrinfo *result, *rp, *ipv4v6bindall;
303      int s, listen_sock;
304      memset(&hints, 0, sizeof(struct addrinfo));
305      hints.ai_family   = AF_UNSPEC;               &bsol;* Return IPv4 and IPv6 choices */
306      hints.ai_socktype = SOCK_STREAM;             &bsol;* We want a TCP socket */
307      hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG; &bsol;* For wildcard IP address */
308      hints.ai_protocol = IPPROTO_TCP;
309      for (int i = 1; i < 8; i++) {
310          s = getaddrinfo(host, port, &hints, &result);
311          if (s == 0) {
312              break;
313          } else {
314              sleep(pow(2, i));
315              LOGE("failed to resolve server name, wait %.0f seconds", pow(2, i));
316          }
317      }
318      if (s != 0) {
319          LOGE("getaddrinfo: %s", gai_strerror(s));
320          return -1;
321      }
322      rp = result;
323      if (!host) {
324          ipv4v6bindall = result;
325          while (ipv4v6bindall) {
326              if (ipv4v6bindall->ai_family == AF_INET6) {
327                  rp = ipv4v6bindall; &bsol;* Take first IPV6 address available */
328                  break;
329              }
330              ipv4v6bindall = ipv4v6bindall->ai_next; &bsol;* Get next address info, if any */
331          }
332      }
333      for (&bsol;*rp = result*/; rp != NULL; rp = rp->ai_next) {
334          listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
335          if (listen_sock == -1) {
336              continue;
337          }
338          if (rp->ai_family == AF_INET6) {
339              int ipv6only = host ? 1 : 0;
340              setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));
341          }
342          int opt = 1;
343          setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
344  #ifdef SO_NOSIGPIPE
345          setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
346  #endif
347          int err = set_reuseport(listen_sock);
348          if (err == 0) {
349              LOGI("tcp port reuse enabled");
350          }
351          if (mptcp == 1) {
352              int err = setsockopt(listen_sock, SOL_TCP, MPTCP_ENABLED, &opt, sizeof(opt));
353              if (err == -1) {
354                  ERROR("failed to enable multipath TCP");
355              }
356          }
357          s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);
358          if (s == 0) {
359              break;
360          } else {
361              ERROR("bind");
362          }
363          close(listen_sock);
364      }
365      if (rp == NULL) {
366          LOGE("Could not bind");
367          return -1;
368      }
369      freeaddrinfo(result);
370      return listen_sock;
371  }
372  static remote_t *
373  connect_to_remote(EV_P_ struct addrinfo *res,
374                    server_t *server)
375  {
376      int sockfd;
377  #ifdef SET_INTERFACE
378      const char *iface = server->listen_ctx->iface;
379  #endif
380      if (acl) {
381          char ipstr[INET6_ADDRSTRLEN];
382          memset(ipstr, 0, INET6_ADDRSTRLEN);
383          if (res->ai_addr->sa_family == AF_INET) {
384              struct sockaddr_in *s = (struct sockaddr_in *)res->ai_addr;
385              dns_ntop(AF_INET, &s->sin_addr, ipstr, INET_ADDRSTRLEN);
386          } else if (res->ai_addr->sa_family == AF_INET6) {
387              struct sockaddr_in6 *s = (struct sockaddr_in6 *)res->ai_addr;
388              dns_ntop(AF_INET6, &s->sin6_addr, ipstr, INET6_ADDRSTRLEN);
389          }
390          if (outbound_block_match_host(ipstr) == 1) {
391              if (verbose)
392                  LOGI("outbound blocked %s", ipstr);
393              return NULL;
394          }
395      }
396      sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
397      if (sockfd == -1) {
398          ERROR("socket");
399          close(sockfd);
400          return NULL;
401      }
402      int opt = 1;
403      setsockopt(sockfd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
404  #ifdef SO_NOSIGPIPE
405      setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
406  #endif
407      setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
408      if (setnonblocking(sockfd) == -1)
409          ERROR("setnonblocking");
410      if (bind_address != NULL)
411          if (bind_to_address(sockfd, bind_address) == -1) {
412              ERROR("bind_to_address");
413              close(sockfd);
414              return NULL;
415          }
416  #ifdef SET_INTERFACE
417      if (iface) {
418          if (setinterface(sockfd, iface) == -1) {
419              ERROR("setinterface");
420              close(sockfd);
421              return NULL;
422          }
423      }
424  #endif
425      remote_t *remote = new_remote(sockfd);
426  #ifdef TCP_FASTOPEN
427      if (fast_open) {
428  #ifdef __APPLE__
429          ((struct sockaddr_in *)(res->ai_addr))->sin_len = sizeof(struct sockaddr_in);
430          sa_endpoints_t endpoints;
431          memset((char *)&endpoints, 0, sizeof(endpoints));
432          endpoints.sae_dstaddr    = res->ai_addr;
433          endpoints.sae_dstaddrlen = res->ai_addrlen;
434          struct iovec iov;
435          iov.iov_base = server->buf->array + server->buf->idx;
436          iov.iov_len  = server->buf->len;
437          size_t len;
438          int s = connectx(sockfd, &endpoints, SAE_ASSOCID_ANY, CONNECT_DATA_IDEMPOTENT,
439                           &iov, 1, &len, NULL);
440          if (s == 0) {
441              s = len;
442          }
443  #else
444          ssize_t s = sendto(sockfd, server->buf->array + server->buf->idx,
445                             server->buf->len, MSG_FASTOPEN, res->ai_addr,
446                             res->ai_addrlen);
447  #endif
448          if (s == -1) {
449              if (errno == CONNECT_IN_PROGRESS || errno == EAGAIN
450                  || errno == EWOULDBLOCK) {
451              } else if (errno == EOPNOTSUPP || errno == EPROTONOSUPPORT ||
452                         errno == ENOPROTOOPT) {
453                  fast_open = 0;
454                  LOGE("fast open is not supported on this platform");
455              } else {
456                  ERROR("sendto");
457              }
458          } else if (s <= server->buf->len) {
459              server->buf->idx += s;
460              server->buf->len -= s;
461          } else {
462              server->buf->idx = 0;
463              server->buf->len = 0;
464          }
465      }
466  #endif
467      if (!fast_open) {
468          int r = connect(sockfd, res->ai_addr, res->ai_addrlen);
469          if (r == -1 && errno != CONNECT_IN_PROGRESS) {
470              ERROR("connect");
471              close_and_free_remote(EV_A_ remote);
472              return NULL;
473          }
474      }
475      return remote;
476  }
477  static void
478  server_recv_cb(EV_P_ ev_io *w, int revents)
479  {
480      server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
481      server_t *server              = server_recv_ctx->server;
482      remote_t *remote              = NULL;
483      int len       = server->buf->len;
484      buffer_t *buf = server->buf;
485      if (server->stage > STAGE_PARSE) {
486          remote = server->remote;
487          buf    = remote->buf;
488          len    = 0;
489          ev_timer_again(EV_A_ & server->recv_ctx->watcher);
490      }
491      if (len > BUF_SIZE) {
492          ERROR("out of recv buffer");
493          close_and_free_remote(EV_A_ remote);
494          close_and_free_server(EV_A_ server);
495          return;
496      }
497      ssize_t r = recv(server->fd, buf->array + len, BUF_SIZE - len, 0);
498      if (r == 0) {
499          if (verbose) {
500              LOGI("server_recv close the connection");
501          }
502          close_and_free_remote(EV_A_ remote);
503          close_and_free_server(EV_A_ server);
504          return;
505      } else if (r == -1) {
506          if (errno == EAGAIN || errno == EWOULDBLOCK) {
507              return;
508          } else {
509              ERROR("server recv");
510              close_and_free_remote(EV_A_ remote);
511              close_and_free_server(EV_A_ server);
512              return;
513          }
514      }
515      tx += r;
516      if (server->stage == STAGE_ERROR) {
517          server->buf->len = 0;
518          server->buf->idx = 0;
519          return;
520      }
521      if (server->stage == STAGE_INIT) {
522          buf->len += r;
523          if (buf->len <= enc_get_iv_len() + 1) {
524              return;
525          }
526      } else {
527          buf->len = r;
528      }
529      if (server->obfs_plugin) {
530          obfs_class *obfs_plugin = server->obfs_plugin;
531          if (obfs_plugin->server_decode) {
532              int needsendback = 0;
533              if(obfs_compatible == 1)
534              {
535                  char *back_buf = (char*)malloc(sizeof(buffer_t));
536                  memcpy(back_buf, buf, sizeof(buffer_t));
537                  buf->len = obfs_plugin->server_decode(server->obfs, &buf->array, buf->len, &buf->capacity, &needsendback);
538                  if ((int)buf->len < 0)
539                  {
540                      LOGE("obfs_compatible");
541                      memcpy(buf, back_buf, sizeof(buffer_t));
542                      free(back_buf);
543                      server->obfs_compatible_state = 1;
544                  }
545              }
546              else
547              {
548                  buf->len = obfs_plugin->server_decode(server->obfs, &buf->array, buf->len, &buf->capacity, &needsendback);
549                  if ((int)buf->len < 0) {
550                      LOGE("server_decode");
551                      close_and_free_remote(EV_A_ remote);
552                      close_and_free_server(EV_A_ server);
553                      return;
554                  }
555              }
556              if (needsendback) {
557                  size_t capacity = BUF_SIZE;
558                  char *sendback_buf = (char*)malloc(capacity);
559                  obfs_class *obfs_plugin = server->obfs_plugin;
560                  if (obfs_plugin->server_encode) {
561                      int len = obfs_plugin->server_encode(server->obfs, &sendback_buf, 0, &capacity);
562                      send(server->fd, sendback_buf, len, 0);
563                  }
564                  free(sendback_buf);
565                  return;
566              }
567          }
568      }
569      int err = ss_decrypt(buf, server->d_ctx, BUF_SIZE);
570      if (err) {
571          report_addr(server->fd, MALICIOUS);
572          close_and_free_remote(EV_A_ remote);
573          close_and_free_server(EV_A_ server);
574          return;
575      }
576      if (server->protocol_plugin) {
577          obfs_class *protocol_plugin = server->protocol_plugin;
578          if (protocol_plugin->server_post_decrypt) {
579              if(protocol_compatible == 1)
580              {
581                  char *back_buf = (char*)malloc(sizeof(buffer_t));
582                  memcpy(back_buf, buf, sizeof(buffer_t));
583                  buf->len = protocol_plugin->server_post_decrypt(server->protocol, &buf->array, buf->len, &buf->capacity);
584                  if ((int)buf->len < 0) {
585                      LOGE("protocol_compatible");
586                      memcpy(buf, back_buf, sizeof(buffer_t));
587                      free(back_buf);
588                      server->protocol_compatible_state = 1;
589                  }
590                  if ( buf->len == 0 )
591                  {
592                      LOGE("protocol_compatible");
593                      memcpy(buf, back_buf, sizeof(buffer_t));
594                      free(back_buf);
595                      server->protocol_compatible_state = 1;
596                  }
597              }
598              else
599              {
600                  buf->len = protocol_plugin->server_post_decrypt(server->protocol, &buf->array, buf->len, &buf->capacity);
601                  if ((int)buf->len < 0) {
602                      LOGE("server_post_decrypt");
603                      close_and_free_remote(EV_A_ remote);
604                      close_and_free_server(EV_A_ server);
605                      return;
606                  }
607                  if ( buf->len == 0 )
608                  {
609                      LOGE("server_post_decrypt");
610                      return;
611                  }
612              }
613          }
614      }
615      if (server->stage == STAGE_INIT) {
616          int ret = is_header_complete(server->buf);
617          if (ret == 1) {
618              bfree(server->header_buf);
619              ss_free(server->header_buf);
620              server->stage = STAGE_PARSE;
621          } else if (ret == -1) {
622              server->stage = STAGE_ERROR;
623              report_addr(server->fd, MALFORMED);
624              server->buf->len = 0;
625              server->buf->idx = 0;
626              return;
627          } else {
628              server->stage = STAGE_HANDSHAKE;
629          }
630      }
631      if (server->stage == STAGE_HANDSHAKE) {
632          size_t header_len = server->header_buf->len;
633          brealloc(server->header_buf, server->buf->len + header_len, BUF_SIZE);
634          memcpy(server->header_buf->array + header_len,
635                 server->buf->array, server->buf->len);
636          server->header_buf->len = server->buf->len + header_len;
637          int ret = is_header_complete(server->buf);
638          if (ret == 1) {
639              brealloc(server->buf, server->header_buf->len, BUF_SIZE);
640              memcpy(server->buf->array, server->header_buf->array, server->header_buf->len);
641              server->buf->len = server->header_buf->len;
642              bfree(server->header_buf);
643              ss_free(server->header_buf);
644              server->stage = STAGE_PARSE;
645          } else {
646              if (ret == -1)
647                  server->stage = STAGE_ERROR;
648              server->buf->len = 0;
649              server->buf->idx = 0;
650              return;
651          }
652      }
653      if (server->stage == STAGE_STREAM) {
654          if (server->auth && !ss_check_hash(remote->buf, server->chunk, server->d_ctx, BUF_SIZE)) {
655              LOGE("hash error");
656              report_addr(server->fd, BAD);
657              close_and_free_server(EV_A_ server);
658              close_and_free_remote(EV_A_ remote);
659              return;
660          }
661          int s = send(remote->fd, remote->buf->array, remote->buf->len, 0);
662          if (s == -1) {
663              if (errno == EAGAIN || errno == EWOULDBLOCK) {
664                  remote->buf->idx = 0;
665                  ev_io_stop(EV_A_ & server_recv_ctx->io);
666                  ev_io_start(EV_A_ & remote->send_ctx->io);
667              } else {
668                  ERROR("server_recv_send");
669                  close_and_free_remote(EV_A_ remote);
670                  close_and_free_server(EV_A_ server);
671              }
672          } else if (s < remote->buf->len) {
673              remote->buf->len -= s;
674              remote->buf->idx  = s;
675              ev_io_stop(EV_A_ & server_recv_ctx->io);
676              ev_io_start(EV_A_ & remote->send_ctx->io);
677          }
678          return;
679      } else if (server->stage == STAGE_PARSE) {
680          int offset     = 0;
681          int need_query = 0;
682          char atyp      = server->buf->array[offset++];
683          char host[257] = { 0 };
684          uint16_t port  = 0;
685          struct addrinfo info;
686          struct sockaddr_storage storage;
687          memset(&info, 0, sizeof(struct addrinfo));
688          memset(&storage, 0, sizeof(struct sockaddr_storage));
689          if (auth || (atyp & ONETIMEAUTH_FLAG)) {
690              size_t header_len = parse_header_len(atyp, server->buf->array, offset);
691              size_t len        = server->buf->len;
692              if (header_len == 0 || len < offset + header_len + ONETIMEAUTH_BYTES) {
693                  report_addr(server->fd, MALFORMED);
694                  close_and_free_server(EV_A_ server);
695                  return;
696              }
697              server->buf->len = offset + header_len + ONETIMEAUTH_BYTES;
698              if (ss_onetimeauth_verify(server->buf, server->d_ctx->evp.iv)) {
699                  report_addr(server->fd, BAD);
700                  close_and_free_server(EV_A_ server);
701                  return;
702              }
703              server->buf->len = len;
704              server->auth     = 1;
705          }
706          if ((atyp & ADDRTYPE_MASK) == 1) {
707              struct sockaddr_in *addr = (struct sockaddr_in *)&storage;
708              size_t in_addr_len       = sizeof(struct in_addr);
709              addr->sin_family = AF_INET;
710              if (server->buf->len >= in_addr_len + 3) {
711                  addr->sin_addr = *(struct in_addr *)(server->buf->array + offset);
712                  dns_ntop(AF_INET, (const void *)(server->buf->array + offset),
713                           host, INET_ADDRSTRLEN);
714                  offset += in_addr_len;
715              } else {
716                  LOGE("invalid header with addr type %d", atyp);
717                  report_addr(server->fd, MALFORMED);
718                  close_and_free_server(EV_A_ server);
719                  return;
720              }
721              addr->sin_port   = *(uint16_t *)(server->buf->array + offset);
722              info.ai_family   = AF_INET;
723              info.ai_socktype = SOCK_STREAM;
724              info.ai_protocol = IPPROTO_TCP;
725              info.ai_addrlen  = sizeof(struct sockaddr_in);
726              info.ai_addr     = (struct sockaddr *)addr;
727          } else if ((atyp & ADDRTYPE_MASK) == 3) {
728              uint8_t name_len = *(uint8_t *)(server->buf->array + offset);
729              if (name_len + 4 <= server->buf->len) {
730                  memcpy(host, server->buf->array + offset + 1, name_len);
731                  offset += name_len + 1;
732              } else {
733                  LOGE("invalid name length: %d", name_len);
734                  report_addr(server->fd, MALFORMED);
735                  close_and_free_server(EV_A_ server);
736                  return;
737              }
738              if (acl && outbound_block_match_host(host) == 1) {
739                  if (verbose)
740                      LOGI("outbound blocked %s", host);
741                  close_and_free_server(EV_A_ server);
742                  return;
743              }
744              struct cork_ip ip;
745              if (cork_ip_init(&ip, host) != -1) {
746                  info.ai_socktype = SOCK_STREAM;
747                  info.ai_protocol = IPPROTO_TCP;
748                  if (ip.version == 4) {
749                      struct sockaddr_in *addr = (struct sockaddr_in *)&storage;
750                      dns_pton(AF_INET, host, &(addr->sin_addr));
751                      addr->sin_port   = *(uint16_t *)(server->buf->array + offset);
752                      addr->sin_family = AF_INET;
753                      info.ai_family   = AF_INET;
754                      info.ai_addrlen  = sizeof(struct sockaddr_in);
755                      info.ai_addr     = (struct sockaddr *)addr;
756                  } else if (ip.version == 6) {
757                      struct sockaddr_in6 *addr = (struct sockaddr_in6 *)&storage;
758                      dns_pton(AF_INET6, host, &(addr->sin6_addr));
759                      addr->sin6_port   = *(uint16_t *)(server->buf->array + offset);
760                      addr->sin6_family = AF_INET6;
761                      info.ai_family    = AF_INET6;
762                      info.ai_addrlen   = sizeof(struct sockaddr_in6);
763                      info.ai_addr      = (struct sockaddr *)addr;
764                  }
765              } else {
766                  if (!validate_hostname(host, name_len)) {
767                      LOGE("invalid host name");
768                      report_addr(server->fd, MALFORMED);
769                      close_and_free_server(EV_A_ server);
770                      return;
771                  }
772                  need_query = 1;
773              }
774          } else if ((atyp & ADDRTYPE_MASK) == 4) {
775              struct sockaddr_in6 *addr = (struct sockaddr_in6 *)&storage;
776              size_t in6_addr_len       = sizeof(struct in6_addr);
777              addr->sin6_family = AF_INET6;
778              if (server->buf->len >= in6_addr_len + 3) {
779                  addr->sin6_addr = *(struct in6_addr *)(server->buf->array + offset);
780                  dns_ntop(AF_INET6, (const void *)(server->buf->array + offset),
781                           host, INET6_ADDRSTRLEN);
782                  offset += in6_addr_len;
783              } else {
784                  LOGE("invalid header with addr type %d", atyp);
785                  report_addr(server->fd, MALFORMED);
786                  close_and_free_server(EV_A_ server);
787                  return;
788              }
789              addr->sin6_port  = *(uint16_t *)(server->buf->array + offset);
790              info.ai_family   = AF_INET6;
791              info.ai_socktype = SOCK_STREAM;
792              info.ai_protocol = IPPROTO_TCP;
793              info.ai_addrlen  = sizeof(struct sockaddr_in6);
794              info.ai_addr     = (struct sockaddr *)addr;
795          }
796          if (offset == 1) {
797              LOGE("invalid header with addr type %d", atyp);
798              report_addr(server->fd, MALFORMED);
799              close_and_free_server(EV_A_ server);
800              return;
801          }
802          port = (*(uint16_t *)(server->buf->array + offset));
803          offset += 2;
804          if (server->auth) {
805              offset += ONETIMEAUTH_BYTES;
806          }
807          if (server->buf->len < offset) {
808              report_addr(server->fd, MALFORMED);
809              close_and_free_server(EV_A_ server);
810              return;
811          } else {
812              server->buf->len -= offset;
813              memmove(server->buf->array, server->buf->array + offset, server->buf->len);
814          }
815          if (verbose) {
816              if ((atyp & ADDRTYPE_MASK) == 4)
817                  LOGI("connect to [%s]:%d", host, ntohs(port));
818              else
819                  LOGI("connect to %s:%d", host, ntohs(port));
820          }
821          if (server->auth && !ss_check_hash(server->buf, server->chunk, server->d_ctx, BUF_SIZE)) {
822              LOGE("hash error");
823              report_addr(server->fd, BAD);
824              close_and_free_server(EV_A_ server);
825              return;
826          }
827          if (!need_query) {
828              remote_t *remote = connect_to_remote(EV_A_ &info, server);
829              if (remote == NULL) {
830                  LOGE("connect error");
831                  close_and_free_server(EV_A_ server);
832                  return;
833              } else {
834                  server->remote = remote;
835                  remote->server = server;
836                  if (server->buf->len > 0) {
837                      memcpy(remote->buf->array, server->buf->array, server->buf->len);
838                      remote->buf->len = server->buf->len;
839                      remote->buf->idx = 0;
840                      server->buf->len = 0;
841                      server->buf->idx = 0;
842                  }
843                  ev_io_stop(EV_A_ & server_recv_ctx->io);
844                  ev_io_start(EV_A_ & remote->send_ctx->io);
845              }
846          } else {
847              query_t *query = (query_t *)ss_malloc(sizeof(query_t));
848              query->server = server;
849              snprintf(query->hostname, 256, "%s", host);
850              server->stage = STAGE_RESOLVE;
851              server->query = resolv_query(host, server_resolve_cb,
852                                           query_free_cb, query, port);
853              ev_io_stop(EV_A_ & server_recv_ctx->io);
854          }
855          return;
856      }
857      FATAL("server context error");
858  }
859  static void
860  server_send_cb(EV_P_ ev_io *w, int revents)
861  {
862      server_ctx_t *server_send_ctx = (server_ctx_t *)w;
863      server_t *server              = server_send_ctx->server;
864      remote_t *remote              = server->remote;
865      if (remote == NULL) {
866          LOGE("invalid server");
867          close_and_free_server(EV_A_ server);
868          return;
869      }
870      if (server->buf->len == 0) {
871          if (verbose) {
872              LOGI("server_send close the connection");
873          }
874          close_and_free_remote(EV_A_ remote);
875          close_and_free_server(EV_A_ server);
876          return;
877      } else {
878          ssize_t s = send(server->fd, server->buf->array + server->buf->idx,
879                           server->buf->len, 0);
880          if (s == -1) {
881              if (errno != EAGAIN && errno != EWOULDBLOCK) {
882                  ERROR("server_send_send");
883                  close_and_free_remote(EV_A_ remote);
884                  close_and_free_server(EV_A_ server);
885              }
886              return;
887          } else if (s < server->buf->len) {
888              server->buf->len -= s;
889              server->buf->idx += s;
890              return;
891          } else {
892              server->buf->len = 0;
893              server->buf->idx = 0;
894              ev_io_stop(EV_A_ & server_send_ctx->io);
895              if (remote != NULL) {
896                  ev_io_start(EV_A_ & remote->recv_ctx->io);
897                  return;
898              } else {
899                  LOGE("invalid remote");
900                  close_and_free_remote(EV_A_ remote);
901                  close_and_free_server(EV_A_ server);
902                  return;
903              }
904          }
905      }
906  }
907  static void
908  block_list_clear_cb(EV_P_ ev_timer *watcher, int revents)
909  {
910      clear_block_list();
911  }
912  static void
913  server_timeout_cb(EV_P_ ev_timer *watcher, int revents)
914  {
915      server_ctx_t *server_ctx
916          = cork_container_of(watcher, server_ctx_t, watcher);
917      server_t *server = server_ctx->server;
918      remote_t *remote = server->remote;
919      if (verbose) {
920          LOGI("TCP connection timeout");
921      }
922      if (server->stage < STAGE_PARSE) {
923          if (verbose) {
924              size_t len = server->stage ?
925                           server->header_buf->len : server->buf->len;
926  #ifdef __MINGW32__
927              LOGI("incomplete header: %u", len);
928  #else
929              LOGI("incomplete header: %zu", len);
930  #endif
931          }
932          report_addr(server->fd, SUSPICIOUS);
933      }
934      close_and_free_remote(EV_A_ remote);
935      close_and_free_server(EV_A_ server);
936  }
937  static void
938  query_free_cb(void *data)
939  {
940      if (data != NULL) {
941          ss_free(data);
942      }
943  }
944  static void
945  server_resolve_cb(struct sockaddr *addr, void *data)
946  {
947      query_t *query       = (query_t *)data;
948      server_t *server     = query->server;
949      struct ev_loop *loop = server->listen_ctx->loop;
950      server->query = NULL;
951      if (addr == NULL) {
952          LOGE("unable to resolve %s", query->hostname);
953          close_and_free_server(EV_A_ server);
954      } else {
955          if (verbose) {
956              LOGI("successfully resolved %s", query->hostname);
957          }
958          struct addrinfo info;
959          memset(&info, 0, sizeof(struct addrinfo));
960          info.ai_socktype = SOCK_STREAM;
961          info.ai_protocol = IPPROTO_TCP;
962          info.ai_addr     = addr;
963          if (addr->sa_family == AF_INET) {
964              info.ai_family  = AF_INET;
965              info.ai_addrlen = sizeof(struct sockaddr_in);
966          } else if (addr->sa_family == AF_INET6) {
967              info.ai_family  = AF_INET6;
968              info.ai_addrlen = sizeof(struct sockaddr_in6);
969          }
970          remote_t *remote = connect_to_remote(EV_A_ &info, server);
971          if (remote == NULL) {
972              close_and_free_server(EV_A_ server);
973          } else {
974              server->remote = remote;
975              remote->server = server;
976              if (server->buf->len > 0) {
977                  memcpy(remote->buf->array, server->buf->array + server->buf->idx,
978                         server->buf->len);
979                  remote->buf->len = server->buf->len;
980                  remote->buf->idx = 0;
981                  server->buf->len = 0;
982                  server->buf->idx = 0;
983              }
984              ev_io_start(EV_A_ & remote->send_ctx->io);
985          }
986      }
987  }
988  static void
989  remote_recv_cb(EV_P_ ev_io *w, int revents)
990  {
991      remote_ctx_t *remote_recv_ctx = (remote_ctx_t *)w;
992      remote_t *remote              = remote_recv_ctx->remote;
993      server_t *server              = remote->server;
994      if (server == NULL) {
995          LOGE("invalid server");
996          close_and_free_remote(EV_A_ remote);
997          return;
998      }
999      ev_timer_again(EV_A_ & server->recv_ctx->watcher);
1000      ssize_t r = recv(remote->fd, server->buf->array, BUF_SIZE, 0);
1001      if (r == 0) {
1002          if (verbose) {
1003              LOGI("remote_recv close the connection");
1004          }
1005          close_and_free_remote(EV_A_ remote);
1006          close_and_free_server(EV_A_ server);
1007          return;
1008      } else if (r == -1) {
1009          if (errno == EAGAIN || errno == EWOULDBLOCK) {
1010              return;
1011          } else {
1012              ERROR("remote recv");
1013              close_and_free_remote(EV_A_ remote);
1014              close_and_free_server(EV_A_ server);
1015              return;
1016          }
1017      }
1018      rx += r;
1019      server->buf->len = r;
1020      server_info _server_info;
1021      if (server->obfs_plugin) {
1022          server->obfs_plugin->get_server_info(server->obfs, &_server_info);
1023          _server_info.head_len = get_head_size(server->buf->array, server->buf->len, 30);
1024          server->obfs_plugin->set_server_info(server->obfs, &_server_info);
1025      }
1026      if (server->protocol_plugin && server->obfs_compatible_state == 0) {
1027          obfs_class *protocol_plugin = server->protocol_plugin;
1028          if (protocol_plugin->server_pre_encrypt) {
1029              server->buf->len = protocol_plugin->server_pre_encrypt(server->protocol, &server->buf->array, server->buf->len, &server->buf->capacity);
1030          }
1031      }
1032      int err = ss_encrypt(server->buf, server->e_ctx, BUF_SIZE);
1033      if (err) {
1034          LOGE("invalid password or cipher");
1035          close_and_free_remote(EV_A_ remote);
1036          close_and_free_server(EV_A_ server);
1037          return;
1038      }
1039      if (server->obfs_plugin && server->obfs_compatible_state == 0) {
1040          obfs_class *obfs_plugin = server->obfs_plugin;
1041          if (obfs_plugin->server_encode) {
1042              server->buf->len = obfs_plugin->server_encode(server->obfs, &server->buf->array, server->buf->len, &server->buf->capacity);
1043          }
1044      }
1045      int s = send(server->fd, server->buf->array, server->buf->len, 0);
1046      if (s == -1) {
1047          if (errno == EAGAIN || errno == EWOULDBLOCK) {
1048              server->buf->idx = 0;
1049              ev_io_stop(EV_A_ & remote_recv_ctx->io);
1050              ev_io_start(EV_A_ & server->send_ctx->io);
1051          } else {
1052              ERROR("remote_recv_send");
1053              close_and_free_remote(EV_A_ remote);
1054              close_and_free_server(EV_A_ server);
1055              return;
1056          }
1057      } else if (s < server->buf->len) {
1058          server->buf->len -= s;
1059          server->buf->idx  = s;
1060          ev_io_stop(EV_A_ & remote_recv_ctx->io);
1061          ev_io_start(EV_A_ & server->send_ctx->io);
1062      }
1063      if (!remote->recv_ctx->connected) {
1064          int opt = 0;
1065          setsockopt(server->fd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
1066          setsockopt(remote->fd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
1067          remote->recv_ctx->connected = 1;
1068      }
1069  }
1070  static void
1071  remote_send_cb(EV_P_ ev_io *w, int revents)
1072  {
1073      remote_ctx_t *remote_send_ctx = (remote_ctx_t *)w;
1074      remote_t *remote              = remote_send_ctx->remote;
1075      server_t *server              = remote->server;
1076      if (server == NULL) {
1077          LOGE("invalid server");
1078          close_and_free_remote(EV_A_ remote);
1079          return;
1080      }
1081      if (!remote_send_ctx->connected) {
1082          struct sockaddr_storage addr;
1083          socklen_t len = sizeof(struct sockaddr_storage);
1084          memset(&addr, 0, len);
1085          int r = getpeername(remote->fd, (struct sockaddr *)&addr, &len);
1086          if (r == 0) {
1087              if (verbose) {
1088                  LOGI("remote connected");
1089              }
1090              remote_send_ctx->connected = 1;
1091              reset_addr(server->fd);
1092              if (remote->buf->len == 0) {
1093                  server->stage = STAGE_STREAM;
1094                  ev_io_stop(EV_A_ & remote_send_ctx->io);
1095                  ev_io_start(EV_A_ & server->recv_ctx->io);
1096                  ev_io_start(EV_A_ & remote->recv_ctx->io);
1097                  return;
1098              }
1099          } else {
1100              ERROR("getpeername");
1101              close_and_free_remote(EV_A_ remote);
1102              close_and_free_server(EV_A_ server);
1103              return;
1104          }
1105      }
1106      if (remote->buf->len == 0) {
1107          if (verbose) {
1108              LOGI("remote_send close the connection");
1109          }
1110          close_and_free_remote(EV_A_ remote);
1111          close_and_free_server(EV_A_ server);
1112          return;
1113      } else {
1114          ssize_t s = send(remote->fd, remote->buf->array + remote->buf->idx,
1115                           remote->buf->len, 0);
1116          if (s == -1) {
1117              if (errno != EAGAIN && errno != EWOULDBLOCK) {
1118                  ERROR("remote_send_send");
1119                  close_and_free_remote(EV_A_ remote);
1120                  close_and_free_server(EV_A_ server);
1121              }
1122              return;
1123          } else if (s < remote->buf->len) {
1124              remote->buf->len -= s;
1125              remote->buf->idx += s;
1126              return;
1127          } else {
1128              remote->buf->len = 0;
1129              remote->buf->idx = 0;
1130              ev_io_stop(EV_A_ & remote_send_ctx->io);
1131              if (server != NULL) {
1132                  ev_io_start(EV_A_ & server->recv_ctx->io);
1133                  if (server->stage != STAGE_STREAM) {
1134                      server->stage = STAGE_STREAM;
1135                      ev_io_start(EV_A_ & remote->recv_ctx->io);
1136                  }
1137              } else {
1138                  LOGE("invalid server");
1139                  close_and_free_remote(EV_A_ remote);
1140                  close_and_free_server(EV_A_ server);
1141              }
1142              return;
1143          }
1144      }
1145  }
1146  static remote_t *
1147  new_remote(int fd)
1148  {
1149      if (verbose) {
1150          remote_conn++;
1151      }
1152      remote_t *remote;
1153      remote                      = ss_malloc(sizeof(remote_t));
1154      remote->recv_ctx            = ss_malloc(sizeof(remote_ctx_t));
1155      remote->send_ctx            = ss_malloc(sizeof(remote_ctx_t));
1156      remote->buf                 = ss_malloc(sizeof(buffer_t));
1157      remote->fd                  = fd;
1158      remote->recv_ctx->remote    = remote;
1159      remote->recv_ctx->connected = 0;
1160      remote->send_ctx->remote    = remote;
1161      remote->send_ctx->connected = 0;
1162      remote->server              = NULL;
1163      ev_io_init(&remote->recv_ctx->io, remote_recv_cb, fd, EV_READ);
1164      ev_io_init(&remote->send_ctx->io, remote_send_cb, fd, EV_WRITE);
1165      balloc(remote->buf, BUF_SIZE);
1166      return remote;
1167  }
1168  static void
1169  free_remote(remote_t *remote)
1170  {
1171      if (remote->server != NULL) {
1172          remote->server->remote = NULL;
1173      }
1174      if (remote->buf != NULL) {
1175          bfree(remote->buf);
1176          ss_free(remote->buf);
1177      }
1178      ss_free(remote->recv_ctx);
1179      ss_free(remote->send_ctx);
1180      ss_free(remote);
1181  }
1182  static void
1183  close_and_free_remote(EV_P_ remote_t *remote)
1184  {
1185      if (remote != NULL) {
1186          ev_io_stop(EV_A_ & remote->send_ctx->io);
1187          ev_io_stop(EV_A_ & remote->recv_ctx->io);
1188          close(remote->fd);
1189          free_remote(remote);
1190          if (verbose) {
1191              remote_conn--;
1192              LOGI("current remote connection: %d", remote_conn);
1193          }
1194      }
1195  }
1196  static server_t *
1197  new_server(int fd, listen_ctx_t *listener)
1198  {
1199      if (verbose) {
1200          server_conn++;
1201      }
1202      server_t *server;
1203      server = ss_malloc(sizeof(server_t));
1204      memset(server, 0, sizeof(server_t));
1205      server->recv_ctx            = ss_malloc(sizeof(server_ctx_t));
1206      server->send_ctx            = ss_malloc(sizeof(server_ctx_t));
1207      server->buf                 = ss_malloc(sizeof(buffer_t));
1208      server->header_buf          = ss_malloc(sizeof(buffer_t));
1209      server->fd                  = fd;
1210      server->recv_ctx->server    = server;
1211      server->recv_ctx->connected = 0;
1212      server->send_ctx->server    = server;
1213      server->send_ctx->connected = 0;
1214      server->stage               = STAGE_INIT;
1215      server->query               = NULL;
1216      server->listen_ctx          = listener;
1217      server->remote              = NULL;
1218      if (listener->method) {
1219          server->e_ctx = ss_malloc(sizeof(enc_ctx_t));
1220          server->d_ctx = ss_malloc(sizeof(enc_ctx_t));
1221          enc_ctx_init(listener->method, server->e_ctx, 1);
1222          enc_ctx_init(listener->method, server->d_ctx, 0);
1223      } else {
1224          server->e_ctx = NULL;
1225          server->d_ctx = NULL;
1226      }
1227      int request_timeout = min(MAX_REQUEST_TIMEOUT, listener->timeout)
1228                            + rand() % MAX_REQUEST_TIMEOUT;
1229      ev_io_init(&server->recv_ctx->io, server_recv_cb, fd, EV_READ);
1230      ev_io_init(&server->send_ctx->io, server_send_cb, fd, EV_WRITE);
1231      ev_timer_init(&server->recv_ctx->watcher, server_timeout_cb,
1232                    request_timeout, listener->timeout);
1233      balloc(server->buf, BUF_SIZE);
1234      balloc(server->header_buf, BUF_SIZE);
1235      server->chunk = (chunk_t *)malloc(sizeof(chunk_t));
1236      memset(server->chunk, 0, sizeof(chunk_t));
1237      server->chunk->buf = ss_malloc(sizeof(buffer_t));
1238      memset(server->chunk->buf, 0, sizeof(buffer_t));
1239      cork_dllist_add(&connections, &server->entries);
1240      return server;
1241  }
1242  static void
1243  free_server(server_t *server)
1244  {
1245      cork_dllist_remove(&server->entries);
1246      if (server->chunk != NULL) {
1247          if (server->chunk->buf != NULL) {
1248              bfree(server->chunk->buf);
1249              ss_free(server->chunk->buf);
1250          }
1251          ss_free(server->chunk);
1252      }
1253      if (server->remote != NULL) {
1254          server->remote->server = NULL;
1255      }
1256      if (server->e_ctx != NULL) {
1257          cipher_context_release(&server->e_ctx->evp);
1258          ss_free(server->e_ctx);
1259      }
1260      if (server->d_ctx != NULL) {
1261          cipher_context_release(&server->d_ctx->evp);
1262          ss_free(server->d_ctx);
1263      }
1264      if (server->buf != NULL) {
1265          bfree(server->buf);
1266          ss_free(server->buf);
1267      }
1268      if (server->header_buf != NULL) {
1269          bfree(server->header_buf);
1270          ss_free(server->header_buf);
1271      }
1272      ss_free(server->recv_ctx);
1273      ss_free(server->send_ctx);
1274      ss_free(server);
1275  }
1276  static void
1277  close_and_free_server(EV_P_ server_t *server)
1278  {
1279      if (server != NULL) {
1280          if (server->query != NULL) {
1281              resolv_cancel(server->query);
1282              server->query = NULL;
1283          }
1284          ev_io_stop(EV_A_ & server->send_ctx->io);
1285          ev_io_stop(EV_A_ & server->recv_ctx->io);
1286          ev_timer_stop(EV_A_ & server->recv_ctx->watcher);
1287          close(server->fd);
1288          free_server(server);
1289          if (verbose) {
1290              server_conn--;
1291              LOGI("current server connection: %d", server_conn);
1292          }
1293      }
1294  }
1295  static void
1296  signal_cb(EV_P_ ev_signal *w, int revents)
1297  {
1298      if (revents & EV_SIGNAL) {
1299          switch (w->signum) {
1300          case SIGINT:
1301          case SIGTERM:
1302              ev_unloop(EV_A_ EVUNLOOP_ALL);
1303          }
1304      }
1305  }
1306  static void
1307  accept_cb(EV_P_ ev_io *w, int revents)
1308  {
1309      listen_ctx_t *listener = (listen_ctx_t *)w;
1310      int serverfd           = accept(listener->fd, NULL, NULL);
1311      if (serverfd == -1) {
1312          ERROR("accept");
1313          return;
1314      }
1315      char *peer_name = get_peer_name(serverfd);
1316      if (peer_name != NULL) {
1317          int in_white_list = 0;
1318          if (acl) {
1319              if ((get_acl_mode() == BLACK_LIST && acl_match_host(peer_name) == 1)
1320                  || (get_acl_mode() == WHITE_LIST && acl_match_host(peer_name) >= 0)) {
1321                  LOGE("Access denied from %s", peer_name);
1322                  close(serverfd);
1323                  return;
1324              } else if (acl_match_host(peer_name) == -1) {
1325                  in_white_list = 1;
1326              }
1327          }
1328          if (!in_white_list && check_block_list(peer_name)) {
1329              LOGE("block all requests from %s", peer_name);
1330  #ifdef __linux__
1331              set_linger(serverfd);
1332  #endif
1333              close(serverfd);
1334              return;
1335          }
1336      }
1337      int opt = 1;
1338      setsockopt(serverfd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
1339  #ifdef SO_NOSIGPIPE
1340      setsockopt(serverfd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
1341  #endif
1342      setnonblocking(serverfd);
1343      if (verbose) {
1344          LOGI("accept a connection");
1345      }
1346      server_t *server = new_server(serverfd, listener);
1347      server->obfs_plugin = new_obfs_class(server->listen_ctx->obfs_name);
1348      if (server->obfs_plugin) {
1349          server->obfs = server->obfs_plugin->new_obfs();
1350          server->obfs_compatible_state = 0;
1351      }
1352      server->protocol_plugin = new_obfs_class(server->listen_ctx->protocol_name);
1353      if (server->protocol_plugin) {
1354          server->protocol = server->protocol_plugin->new_obfs();
1355          server->protocol_compatible_state = 0;
1356      }
1357      server_info _server_info;
1358      memset(&_server_info, 0, sizeof(server_info));
1359      _server_info.param = server->listen_ctx->obfs_param;
1360      if(server->obfs_plugin)
1361          _server_info.g_data = server->obfs_plugin->init_data();
1362      _server_info.head_len = 7;
1363      _server_info.iv = server->e_ctx->evp.iv;
1364      _server_info.iv_len = enc_get_iv_len();
1365      _server_info.key = enc_get_key();
1366      _server_info.key_len = enc_get_key_len();
1367      _server_info.tcp_mss = 1460;
1368      if (server->obfs_plugin)
1369          server->obfs_plugin->set_server_info(server->obfs, &_server_info);
1370      _server_info.param = server->listen_ctx->protocol_param;
1371      if (server->protocol_plugin)
1372          _server_info.g_data = server->protocol_plugin->init_data();
1373      if (server->protocol_plugin)
1374          server->protocol_plugin->set_server_info(server->protocol, &_server_info);
1375      ev_io_start(EV_A_ & server->recv_ctx->io);
1376      ev_timer_start(EV_A_ & server->recv_ctx->watcher);
1377  }
1378  int
1379  main(int argc, char **argv)
1380  {
1381      int i, c;
1382      int pid_flags   = 0;
1383      int mptcp       = 0;
1384      int firewall    = 0;
1385      int mtu         = 0;
1386      char *user      = NULL;
1387      char *password  = NULL;
1388      char *timeout   = NULL;
1389      char *protocol = NULL; 
1390      char *protocol_param = NULL; 
1391      char *method = NULL;
1392      char *obfs = NULL; 
1393      char *obfs_param = NULL; 
1394      char *pid_path  = NULL;
1395      char *conf_path = NULL;
1396      char *iface     = NULL;
1397      int server_num = 0;
1398      const char *server_host[MAX_REMOTE_NUM];
1399      char *nameservers[MAX_DNS_NUM + 1];
1400      int nameserver_num = 0;
1401      int option_index                    = 0;
1402      static struct option long_options[] = {
1403          { "fast-open",       no_argument,       0, 0 },
1404          { "acl",             required_argument, 0, 0 },
1405          { "manager-address", required_argument, 0, 0 },
1406          { "mtu",             required_argument, 0, 0 },
1407          { "help",            no_argument,       0, 0 },
1408  #ifdef __linux__
1409          { "mptcp",           no_argument,       0, 0 },
1410          { "firewall",        no_argument,       0, 0 },
1411  #endif
1412          {                 0,                 0, 0, 0 }
1413      };
1414      opterr = 0;
1415      USE_TTY();
1416      while ((c = getopt_long(argc, argv, "f:s:p:l:k:t:m:b:c:i:d:a:n:O:o:G:g:huUvA6",
1417                              long_options, &option_index)) != -1) {
1418          switch (c) {
1419          case 0:
1420              if (option_index == 0) {
1421                  fast_open = 1;
1422              } else if (option_index == 1) {
1423                  LOGI("initializing acl...");
1424                  acl = !init_acl(optarg);
1425              } else if (option_index == 2) {
1426                  manager_address = optarg;
1427              } else if (option_index == 3) {
1428                  mtu = atoi(optarg);
1429                  LOGI("set MTU to %d", mtu);
1430              } else if (option_index == 4) {
1431                  usage();
1432                  exit(EXIT_SUCCESS);
1433              } else if (option_index == 5) {
1434                  mptcp = 1;
1435                  LOGI("enable multipath TCP");
1436              } else if (option_index == 6) {
1437                  firewall = 1;
1438                  LOGI("enable firewall rules");
1439              }
1440              break;
1441          case 's':
1442              if (server_num < MAX_REMOTE_NUM) {
1443                  server_host[server_num++] = optarg;
1444              }
1445              break;
1446          case 'b':
1447              bind_address = optarg;
1448              break;
1449          case 'p':
1450              server_port = optarg;
1451              break;
1452          case 'k':
1453              password = optarg;
1454              break;
1455          case 'f':
1456              pid_flags = 1;
1457              pid_path  = optarg;
1458              break;
1459          case 't':
1460              timeout = optarg;
1461              break;
1462          case 'O':
1463              protocol = optarg;
1464              break;
1465          case 'm':
1466              method = optarg;
1467              break;
1468          case 'o':
1469              obfs = optarg;
1470              break;
1471          case 'G':
1472              protocol_param = optarg;
1473              break;
1474          case 'g':
1475              obfs_param = optarg;
1476              break;
1477          case 'c':
1478              conf_path = optarg;
1479              break;
1480          case 'i':
1481              iface = optarg;
1482              break;
1483          case 'd':
1484              if (nameserver_num < MAX_DNS_NUM) {
1485                  nameservers[nameserver_num++] = optarg;
1486              }
1487              break;
1488          case 'a':
1489              user = optarg;
1490              break;
1491  #ifdef HAVE_SETRLIMIT
1492          case 'n':
1493              nofile = atoi(optarg);
1494              break;
1495  #endif
1496          case 'u':
1497              mode = TCP_AND_UDP;
1498              break;
1499          case 'U':
1500              mode = UDP_ONLY;
1501              break;
1502          case 'v':
1503              verbose = 1;
1504              break;
1505          case 'h':
1506              usage();
1507              exit(EXIT_SUCCESS);
1508          case 'A':
1509              auth = 1;
1510              break;
1511          case '6':
1512              ipv6first = 1;
1513              break;
1514          case '?':
1515              LOGE("Unrecognized option: %s", optarg);
1516              opterr = 1;
1517              break;
1518          }
1519      }
1520      if (opterr) {
1521          usage();
1522          exit(EXIT_FAILURE);
1523      }
1524      if (argc == 1) {
1525          if (conf_path == NULL) {
1526              conf_path = DEFAULT_CONF_PATH;
1527          }
1528      }
1529      if (conf_path != NULL) {
1530          jconf_t *conf = read_jconf(conf_path);
1531          if (server_num == 0) {
1532              server_num = conf->remote_num;
1533              for (i = 0; i < server_num; i++)
1534                  server_host[i] = conf->remote_addr[i].host;
1535          }
1536          if (server_port == NULL) {
1537              server_port = conf->remote_port;
1538          }
1539          if (password == NULL) {
1540              password = conf->password;
1541          }
1542          if (protocol == NULL) {
1543              protocol = conf->protocol;
1544              LOGI("protocol %s", protocol);
1545          }
1546          if (protocol_param == NULL) {
1547              protocol_param = conf->protocol_param;
1548              LOGI("protocol_param %s", obfs_param);
1549          }
1550          if (method == NULL) {
1551              method = conf->method;
1552              LOGI("method %s", method);
1553          }
1554          if (obfs == NULL) {
1555              obfs = conf->obfs;
1556              LOGI("obfs %s", obfs);
1557          }
1558          if (obfs_param == NULL) {
1559              obfs_param = conf->obfs_param;
1560              LOGI("obfs_param %s", obfs_param);
1561          }
1562          if (timeout == NULL) {
1563              timeout = conf->timeout;
1564          }
1565          if (user == NULL) {
1566              user = conf->user;
1567          }
1568          if (auth == 0) {
1569              auth = conf->auth;
1570          }
1571          if (mode == TCP_ONLY) {
1572              mode = conf->mode;
1573          }
1574          if (mtu == 0) {
1575              mtu = conf->mtu;
1576          }
1577          if (mptcp == 0) {
1578              mptcp = conf->mptcp;
1579          }
1580  #ifdef TCP_FASTOPEN
1581          if (fast_open == 0) {
1582              fast_open = conf->fast_open;
1583          }
1584  #endif
1585  #ifdef HAVE_SETRLIMIT
1586          if (nofile == 0) {
1587              nofile = conf->nofile;
1588          }
1589  #endif
1590          if (conf->nameserver != NULL) {
1591              nameservers[nameserver_num++] = conf->nameserver;
1592          }
1593          if (ipv6first == 0) {
1594              ipv6first = conf->ipv6_first;
1595          }
1596      }
1597      if(strlen(protocol)>11)
1598      {
1599          char *text;
1600          text = (char*)malloc(12);
1601          memcpy(text, protocol + strlen(protocol) - 11, 12);
1602          if(strcmp(text, "_compatible") == 0)
1603          {
1604              free(text);
1605              text = (char*)malloc(strlen(protocol) - 11);
1606              memcpy(text, protocol, strlen(protocol) - 11);
1607              int length = strlen(protocol) - 11;
1608              free(protocol);
1609              obfs = (char*)malloc(length);
1610              memset(protocol, 0x00, length);
1611              memcpy(protocol, text, length);
1612              LOGI("protocol compatible enable, %s", protocol);
1613              free(text);
1614              protocol_compatible = 1;
1615          }
1616      }
1617      if(strlen(obfs)>11)
1618      {
1619          char *text;
1620          text = (char*)malloc(12);
1621          memcpy(text, obfs + strlen(obfs) - 11, 12);
1622          if(strcmp(text, "_compatible") == 0)
1623          {
1624              free(text);
1625              text = (char*)malloc(strlen(obfs) - 11);
1626              memcpy(text, obfs, strlen(obfs) - 11);
1627              int length = strlen(obfs) - 11;
1628              free(obfs);
1629              obfs = (char*)malloc(length);
1630              memset(obfs, 0x00, length);
1631              memcpy(obfs, text, length);
1632              LOGI("obfs compatible enable, %s", obfs);
1633              free(text);
1634              obfs_compatible = 1;
1635          }
1636      }
1637      if (server_num == 0) {
1638          server_host[server_num++] = NULL;
1639      }
1640      if (server_num == 0 || server_port == NULL || password == NULL) {
1641          usage();
1642          exit(EXIT_FAILURE);
1643      }
1644      if (protocol && strcmp(protocol, "verify_sha1") == 0) {
1645          auth = 1;
1646          protocol = NULL;
1647      }
1648      if (method == NULL) {
1649          method = "rc4-md5";
1650      }
1651      if (timeout == NULL) {
1652          timeout = "60";
1653      }
1654  #ifdef HAVE_SETRLIMIT
1655      if (nofile > 1024) {
1656          if (verbose) {
1657              LOGI("setting NOFILE to %d", nofile);
1658          }
1659          set_nofile(nofile);
1660      }
1661  #endif
1662      if (pid_flags) {
1663          USE_SYSLOG(argv[0]);
1664          daemonize(pid_path);
1665      }
1666      if (ipv6first) {
1667          LOGI("resolving hostname to IPv6 address first");
1668      }
1669      if (fast_open == 1) {
1670  #ifdef TCP_FASTOPEN
1671          LOGI("using tcp fast open");
1672  #else
1673          LOGE("tcp fast open is not supported by this environment");
1674          fast_open = 0;
1675  #endif
1676      }
1677      if (auth) {
1678          LOGI("onetime authentication enabled");
1679      }
1680      if (mode != TCP_ONLY) {
1681          LOGI("UDP relay enabled");
1682      }
1683      if (mode == UDP_ONLY) {
1684          LOGI("TCP relay disabled");
1685      }
1686  #ifdef __MINGW32__
1687      winsock_init();
1688  #else
1689      signal(SIGPIPE, SIG_IGN);
1690      signal(SIGCHLD, SIG_IGN);
1691      signal(SIGABRT, SIG_IGN);
1692  #endif
1693      struct ev_signal sigint_watcher;
1694      struct ev_signal sigterm_watcher;
1695      ev_signal_init(&sigint_watcher, signal_cb, SIGINT);
1696      ev_signal_init(&sigterm_watcher, signal_cb, SIGTERM);
1697      ev_signal_start(EV_DEFAULT, &sigint_watcher);
1698      ev_signal_start(EV_DEFAULT, &sigterm_watcher);
1699      LOGI("initializing ciphers... %s", method);
1700      int m = enc_init(password, method);
1701      struct ev_loop *loop = EV_DEFAULT;
1702      if (nameserver_num == 0) {
1703  #ifdef __MINGW32__
1704          nameservers[nameserver_num++] = "8.8.8.8";
1705          resolv_init(loop, nameservers, nameserver_num, ipv6first);
1706  #else
1707          resolv_init(loop, NULL, 0, ipv6first);
1708  #endif
1709      } else {
1710          resolv_init(loop, nameservers, nameserver_num, ipv6first);
1711      }
1712      for (int i = 0; i < nameserver_num; i++)
1713          LOGI("using nameserver: %s", nameservers[i]);
1714      listen_ctx_t listen_ctx_list[server_num];
1715      while (server_num > 0) {
1716          int index        = --server_num;
1717          const char *host = server_host[index];
1718          if (mode != UDP_ONLY) {
1719              int listenfd;
1720              listenfd = create_and_bind(host, server_port, mptcp);
1721              if (listenfd == -1) {
1722                  FATAL("bind() error");
1723              }
1724              if (listen(listenfd, SSMAXCONN) == -1) {
1725                  FATAL("listen() error");
1726              }
1727              setfastopen(listenfd);
1728              setnonblocking(listenfd);
<span onclick='openModal()' class='match'>1729              listen_ctx_t *listen_ctx = &listen_ctx_list[index];
1730              listen_ctx->timeout = atoi(timeout);
1731              listen_ctx->fd      = listenfd;
1732              listen_ctx->method  = m;
1733              listen_ctx->iface   = iface;
1734              listen_ctx->protocol_name = protocol;
1735              listen_ctx->protocol_param = protocol_param;
1736              listen_ctx->method = m;
1737              listen_ctx->obfs_name = obfs;
1738              listen_ctx->obfs_param = obfs_param;
</span>1739              listen_ctx->list_protocol_global = malloc(sizeof(void *));
1740              listen_ctx->list_obfs_global = malloc(sizeof(void *));
1741              memset(listen_ctx->list_protocol_global, 0, sizeof(void *));
1742              memset(listen_ctx->list_obfs_global, 0, sizeof(void *));
1743              listen_ctx->loop    = loop;
1744              ev_io_init(&listen_ctx->io, accept_cb, listenfd, EV_READ);
1745              ev_io_start(loop, &listen_ctx->io);
1746          }
1747          if (mode != TCP_ONLY) {
1748              init_udprelay(server_host[index], server_port, mtu, m,
1749                            auth, atoi(timeout), iface, protocol, protocol_param);
1750          }
1751          if (host && strcmp(host, ":") > 0)
1752              LOGI("listening at [%s]:%s", host, server_port);
1753          else
1754              LOGI("listening at %s:%s", host ? host : "*", server_port);
1755      }
1756      if (manager_address != NULL) {
1757          ev_timer_init(&stat_update_watcher, stat_update_cb, UPDATE_INTERVAL, UPDATE_INTERVAL);
1758          ev_timer_start(EV_DEFAULT, &stat_update_watcher);
1759      }
1760      ev_timer_init(&block_list_watcher, block_list_clear_cb, UPDATE_INTERVAL, UPDATE_INTERVAL);
1761      ev_timer_start(EV_DEFAULT, &block_list_watcher);
1762      if (user != NULL && ! run_as(user)) {
1763          FATAL("failed to switch user");
1764      }
1765  #ifndef __MINGW32__
1766      if (geteuid() == 0){
1767          LOGI("running from root user");
1768      } else if (firewall) {
1769          LOGE("firewall setup requires running from root user");
1770          exit(-1);
1771      }
1772  #endif
1773      init_block_list(firewall);
1774      cork_dllist_init(&connections);
1775      ev_run(loop, 0);
1776      if (verbose) {
1777          LOGI("closed gracefully");
1778      }
1779      free_block_list();
1780      if (manager_address != NULL) {
1781          ev_timer_stop(EV_DEFAULT, &stat_update_watcher);
1782      }
1783      ev_timer_stop(EV_DEFAULT, &block_list_watcher);
1784      for (int i = 0; i <= server_num; i++) {
1785          listen_ctx_t *listen_ctx = &listen_ctx_list[i];
1786          if (mode != UDP_ONLY) {
1787              ev_io_stop(loop, &listen_ctx->io);
1788              close(listen_ctx->fd);
1789          }
1790      }
1791      if (mode != UDP_ONLY) {
1792          free_connections(loop);
1793      }
1794      if (mode != TCP_ONLY) {
1795          free_udprelay();
1796      }
1797      resolv_shutdown(loop);
1798  #ifdef __MINGW32__
1799      winsock_cleanup();
1800  #endif
1801      ev_signal_stop(EV_DEFAULT, &sigint_watcher);
1802      ev_signal_stop(EV_DEFAULT, &sigterm_watcher);
1803      return 0;
1804  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-extras.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-server.c</div>
                <div class="column column_space"><pre><code>76        const uint32_t ba = rgb4444[2 * x + 1];
77  #endif
78        uint32_t r = rg & 0xf0;
79        uint32_t g = (rg << 4);
80        uint32_t b = (ba & 0xf0);
81        uint32_t a = (ba << 4);
82        r = r | (r >> 4);
83        g = g | (g >> 4);
84        b = b | (b >> 4);
85        a = a | (a >> 4);
86        dst[x] = (a << 24) | (r << 16) | (g << 8) | b;
</pre></code></div>
                <div class="column column_space"><pre><code>1729              listen_ctx_t *listen_ctx = &listen_ctx_list[index];
1730              listen_ctx->timeout = atoi(timeout);
1731              listen_ctx->fd      = listenfd;
1732              listen_ctx->method  = m;
1733              listen_ctx->iface   = iface;
1734              listen_ctx->protocol_name = protocol;
1735              listen_ctx->protocol_param = protocol_param;
1736              listen_ctx->method = m;
1737              listen_ctx->obfs_name = obfs;
1738              listen_ctx->obfs_param = obfs_param;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    