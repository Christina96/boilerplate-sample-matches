
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.287427809862283%, Tokens: 8</h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "pcap-int.h"
5  #include <airpcap.h>
6  #include "pcap-airpcap.h"
7  #define	AIRPCAP_DEFAULT_USER_BUFFER_SIZE 256000
8  #define	AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE 1000000
9  static pcap_code_handle_t airpcap_lib;
10  typedef PCHAR (*AirpcapGetLastErrorHandler)(PAirpcapHandle);
11  typedef BOOL (*AirpcapGetDeviceListHandler)(PAirpcapDeviceDescription *, PCHAR);
12  typedef VOID (*AirpcapFreeDeviceListHandler)(PAirpcapDeviceDescription);
13  typedef PAirpcapHandle (*AirpcapOpenHandler)(PCHAR, PCHAR);
14  typedef VOID (*AirpcapCloseHandler)(PAirpcapHandle);
15  typedef BOOL (*AirpcapSetDeviceMacFlagsHandler)(PAirpcapHandle, UINT);
16  typedef BOOL (*AirpcapSetLinkTypeHandler)(PAirpcapHandle, AirpcapLinkType);
17  typedef BOOL (*AirpcapGetLinkTypeHandler)(PAirpcapHandle, PAirpcapLinkType);
18  typedef BOOL (*AirpcapSetKernelBufferHandler)(PAirpcapHandle, UINT);
19  typedef BOOL (*AirpcapSetFilterHandler)(PAirpcapHandle, PVOID, UINT);
20  typedef BOOL (*AirpcapSetMinToCopyHandler)(PAirpcapHandle, UINT);
21  typedef BOOL (*AirpcapGetReadEventHandler)(PAirpcapHandle, HANDLE *);
22  typedef BOOL (*AirpcapReadHandler)(PAirpcapHandle, PBYTE, UINT, PUINT);
23  typedef BOOL (*AirpcapWriteHandler)(PAirpcapHandle, PCHAR, ULONG);
24  typedef BOOL (*AirpcapGetStatsHandler)(PAirpcapHandle, PAirpcapStats);
25  static AirpcapGetLastErrorHandler p_AirpcapGetLastError;
26  static AirpcapGetDeviceListHandler p_AirpcapGetDeviceList;
27  static AirpcapFreeDeviceListHandler p_AirpcapFreeDeviceList;
28  static AirpcapOpenHandler p_AirpcapOpen;
29  static AirpcapCloseHandler p_AirpcapClose;
30  static AirpcapSetDeviceMacFlagsHandler p_AirpcapSetDeviceMacFlags;
31  static AirpcapSetLinkTypeHandler p_AirpcapSetLinkType;
32  static AirpcapGetLinkTypeHandler p_AirpcapGetLinkType;
33  static AirpcapSetKernelBufferHandler p_AirpcapSetKernelBuffer;
34  static AirpcapSetFilterHandler p_AirpcapSetFilter;
35  static AirpcapSetMinToCopyHandler p_AirpcapSetMinToCopy;
36  static AirpcapGetReadEventHandler p_AirpcapGetReadEvent;
37  static AirpcapReadHandler p_AirpcapRead;
38  static AirpcapWriteHandler p_AirpcapWrite;
39  static AirpcapGetStatsHandler p_AirpcapGetStats;
40  typedef enum LONG
41  {
42  	AIRPCAP_API_UNLOADED = 0,
43  	AIRPCAP_API_LOADED,
44  	AIRPCAP_API_CANNOT_LOAD,
45  	AIRPCAP_API_LOADING
46  } AIRPCAP_API_LOAD_STATUS;
47  static AIRPCAP_API_LOAD_STATUS	airpcap_load_status;
48  static AIRPCAP_API_LOAD_STATUS
49  load_airpcap_functions(void)
50  {
51  	AIRPCAP_API_LOAD_STATUS current_status;
52  	current_status = InterlockedCompareExchange((LONG *)&airpcap_load_status,
53  	    AIRPCAP_API_LOADING, AIRPCAP_API_UNLOADED);
54  	while (current_status == AIRPCAP_API_LOADING) {
55  		current_status = InterlockedCompareExchange((LONG*)&airpcap_load_status,
56  		    AIRPCAP_API_LOADING, AIRPCAP_API_LOADING);
57  		Sleep(10);
58  	}
59  	if (current_status == AIRPCAP_API_LOADED)
60  		return AIRPCAP_API_LOADED;
61  	if (current_status == AIRPCAP_API_CANNOT_LOAD)
62  		return AIRPCAP_API_CANNOT_LOAD;
63  	current_status = AIRPCAP_API_CANNOT_LOAD;
64  	airpcap_lib = pcap_load_code("airpcap.dll");
<span onclick='openModal()' class='match'>65  	if (airpcap_lib != NULL) {
66  		p_AirpcapGetLastError = (AirpcapGetLastErrorHandler) pcap_find_function(airpcap_lib, "AirpcapGetLastError");
67  		p_AirpcapGetDeviceList = (AirpcapGetDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapGetDeviceList");
68  		p_AirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapFreeDeviceList");
69  		p_AirpcapOpen = (AirpcapOpenHandler) pcap_find_function(airpcap_lib, "AirpcapOpen");
70  		p_AirpcapClose = (AirpcapCloseHandler) pcap_find_function(airpcap_lib, "AirpcapClose");
71  		p_AirpcapSetDeviceMacFlags = (AirpcapSetDeviceMacFlagsHandler) pcap_find_function(airpcap_lib, "AirpcapSetDeviceMacFlags");
72  		p_AirpcapSetLinkType = (AirpcapSetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapSetLinkType");
</span>73  		p_AirpcapGetLinkType = (AirpcapGetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapGetLinkType");
74  		p_AirpcapSetKernelBuffer = (AirpcapSetKernelBufferHandler) pcap_find_function(airpcap_lib, "AirpcapSetKernelBuffer");
75  		p_AirpcapSetFilter = (AirpcapSetFilterHandler) pcap_find_function(airpcap_lib, "AirpcapSetFilter");
76  		p_AirpcapSetMinToCopy = (AirpcapSetMinToCopyHandler) pcap_find_function(airpcap_lib, "AirpcapSetMinToCopy");
77  		p_AirpcapGetReadEvent = (AirpcapGetReadEventHandler) pcap_find_function(airpcap_lib, "AirpcapGetReadEvent");
78  		p_AirpcapRead = (AirpcapReadHandler) pcap_find_function(airpcap_lib, "AirpcapRead");
79  		p_AirpcapWrite = (AirpcapWriteHandler) pcap_find_function(airpcap_lib, "AirpcapWrite");
80  		p_AirpcapGetStats = (AirpcapGetStatsHandler) pcap_find_function(airpcap_lib, "AirpcapGetStats");
81  		if (p_AirpcapGetLastError != NULL &&
82  		    p_AirpcapGetDeviceList != NULL &&
83  		    p_AirpcapFreeDeviceList != NULL &&
84  		    p_AirpcapOpen != NULL &&
85  		    p_AirpcapClose != NULL &&
86  		    p_AirpcapSetDeviceMacFlags != NULL &&
87  		    p_AirpcapSetLinkType != NULL &&
88  		    p_AirpcapGetLinkType != NULL &&
89  		    p_AirpcapSetKernelBuffer != NULL &&
90  		    p_AirpcapSetFilter != NULL &&
91  		    p_AirpcapSetMinToCopy != NULL &&
92  		    p_AirpcapGetReadEvent != NULL &&
93  		    p_AirpcapRead != NULL &&
94  		    p_AirpcapWrite != NULL &&
95  		    p_AirpcapGetStats != NULL) {
96  			current_status = AIRPCAP_API_LOADED;
97  		}
98  	}
99  	if (current_status != AIRPCAP_API_LOADED) {
100  		if (airpcap_lib != NULL) {
101  			FreeLibrary(airpcap_lib);
102  			airpcap_lib = NULL;
103  		}
104  	}
105  	InterlockedExchange((LONG *)&airpcap_load_status, current_status);
106  	return current_status;
107  }
108  struct pcap_airpcap {
109  	PAirpcapHandle adapter;
110  	int filtering_in_kernel;
111  	int nonblock;
112  	int read_timeout;
113  	HANDLE read_event;
114  	struct pcap_stat stat;
115  };
116  static int
117  airpcap_setfilter(pcap_t *p, struct bpf_program *fp)
118  {
119  	struct pcap_airpcap *pa = p->priv;
120  	if (!p_AirpcapSetFilter(pa->adapter, fp->bf_insns,
121  	    fp->bf_len * sizeof(struct bpf_insn))) {
122  		if (pcap_install_bpf_program(p, fp) < 0)
123  			return (-1);
124  		pa->filtering_in_kernel = 0;	&bsol;* filtering in userland */
125  		return (0);
126  	}
127  	pa->filtering_in_kernel = 1;	&bsol;* filtering in the kernel */
128  	p->cc = 0;
129  	return (0);
130  }
131  static int
132  airpcap_set_datalink(pcap_t *p, int dlt)
133  {
134  	struct pcap_airpcap *pa = p->priv;
135  	AirpcapLinkType type;
136  	switch (dlt) {
137  	case DLT_IEEE802_11_RADIO:
138  		type = AIRPCAP_LT_802_11_PLUS_RADIO;
139  		break;
140  	case DLT_PPI:
141  		type = AIRPCAP_LT_802_11_PLUS_PPI;
142  		break;
143  	case DLT_IEEE802_11:
144  		type = AIRPCAP_LT_802_11;
145  		break;
146  	default:
147  		return (0);
148  	}
149  	if (!p_AirpcapSetLinkType(pa->adapter, type)) {
150  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
151  		    "AirpcapSetLinkType() failed: %s",
152  		    p_AirpcapGetLastError(pa->adapter));
153  		return (-1);
154  	}
155  	p->linktype = dlt;
156  	return (0);
157  }
158  static int
159  airpcap_getnonblock(pcap_t *p)
160  {
161  	struct pcap_airpcap *pa = p->priv;
162  	return (pa->nonblock);
163  }
164  static int
165  airpcap_setnonblock(pcap_t *p, int nonblock)
166  {
167  	struct pcap_airpcap *pa = p->priv;
168  	int newtimeout;
169  	if (nonblock) {
170  		newtimeout = -1;
171  	} else {
172  		newtimeout = p->opt.timeout;
173  	}
174  	pa->read_timeout = newtimeout;
175  	pa->nonblock = (newtimeout == -1);
176  	return (0);
177  }
178  static int
179  airpcap_stats(pcap_t *p, struct pcap_stat *ps)
180  {
181  	struct pcap_airpcap *pa = p->priv;
182  	AirpcapStats tas;
183  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
184  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
185  		    "AirpcapGetStats() failed: %s",
186  		    p_AirpcapGetLastError(pa->adapter));
187  		return (-1);
188  	}
189  	ps->ps_drop = tas.Drops;
190  	ps->ps_recv = tas.Recvs;
191  	ps->ps_ifdrop = tas.IfDrops;
192  	return (0);
193  }
194  static struct pcap_stat *
195  airpcap_stats_ex(pcap_t *p, int *pcap_stat_size)
196  {
197  	struct pcap_airpcap *pa = p->priv;
198  	AirpcapStats tas;
199  	*pcap_stat_size = sizeof (p->stat);
200  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
201  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
202  		    "AirpcapGetStats() failed: %s",
203  		    p_AirpcapGetLastError(pa->adapter));
204  		return (NULL);
205  	}
206  	p->stat.ps_recv = tas.Recvs;
207  	p->stat.ps_drop = tas.Drops;
208  	p->stat.ps_ifdrop = tas.IfDrops;
209  #ifdef _WIN32
210  	p->stat.ps_capt = tas.Capt;
211  #endif
212  	return (&p->stat);
213  }
214  static int
215  airpcap_setbuff(pcap_t *p, int dim)
216  {
217  	struct pcap_airpcap *pa = p->priv;
218  	if (!p_AirpcapSetKernelBuffer(pa->adapter, dim)) {
219  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
220  		    "AirpcapSetKernelBuffer() failed: %s",
221  		    p_AirpcapGetLastError(pa->adapter));
222  		return (-1);
223  	}
224  	return (0);
225  }
226  static int
227  airpcap_setmode(pcap_t *p, int mode)
228  {
229  	 if (mode != MODE_CAPT) {
230  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
231  		    "Only MODE_CAPT is supported on an AirPcap adapter");
232  		return (-1);
233  	 }
234  	 return (0);
235  }
236  static int
237  airpcap_setmintocopy(pcap_t *p, int size)
238  {
239  	struct pcap_airpcap *pa = p->priv;
240  	if (!p_AirpcapSetMinToCopy(pa->adapter, size)) {
241  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
242  		    "AirpcapSetMinToCopy() failed: %s",
243  		    p_AirpcapGetLastError(pa->adapter));
244  		return (-1);
245  	}
246  	return (0);
247  }
248  static HANDLE
249  airpcap_getevent(pcap_t *p)
250  {
251  	struct pcap_airpcap *pa = p->priv;
252  	return (pa->read_event);
253  }
254  static int
255  airpcap_oid_get_request(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,
256      size_t *lenp _U_)
257  {
258  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
259  	    "Getting OID values is not supported on an AirPcap adapter");
260  	return (PCAP_ERROR);
261  }
262  static int
263  airpcap_oid_set_request(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
264      size_t *lenp _U_)
265  {
266  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
267  	    "Setting OID values is not supported on an AirPcap adapter");
268  	return (PCAP_ERROR);
269  }
270  static u_int
271  airpcap_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)
272  {
273  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
274  	    "Cannot queue packets for transmission on an AirPcap adapter");
275  	return (0);
276  }
277  static int
278  airpcap_setuserbuffer(pcap_t *p, int size)
279  {
280  	unsigned char *new_buff;
281  	if (size <= 0) {
282  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
283  		    "Error: invalid size %d",size);
284  		return (-1);
285  	}
286  	new_buff = (unsigned char *)malloc(sizeof(char)*size);
287  	if (!new_buff) {
288  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
289  		    "Error: not enough memory");
290  		return (-1);
291  	}
292  	free(p->buffer);
293  	p->buffer = new_buff;
294  	p->bufsize = size;
295  	return (0);
296  }
297  static int
298  airpcap_live_dump(pcap_t *p, char *filename _U_, int maxsize _U_,
299      int maxpacks _U_)
300  {
301  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
302  	    "AirPcap adapters don't support live dump");
303  	return (-1);
304  }
305  static int
306  airpcap_live_dump_ended(pcap_t *p, int sync _U_)
307  {
308  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
309  	    "AirPcap adapters don't support live dump");
310  	return (-1);
311  }
312  static PAirpcapHandle
313  airpcap_get_airpcap_handle(pcap_t *p)
314  {
315  	struct pcap_airpcap *pa = p->priv;
316  	return (pa->adapter);
317  }
318  static int
319  airpcap_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
320  {
321  	struct pcap_airpcap *pa = p->priv;
322  	int cc;
323  	int n;
324  	register u_char *bp, *ep;
325  	UINT bytes_read;
326  	u_char *datap;
327  	cc = p->cc;
328  	if (cc == 0) {
329  		if (p->break_loop) {
330  			p->break_loop = 0;
331  			return (PCAP_ERROR_BREAK);
332  		}
333  		if (pa->read_timeout != -1) {
334  			WaitForSingleObject(pa->read_event,
335  			    (pa->read_timeout ==0 )? INFINITE: pa->read_timeout);
336  		}
337  		if (!p_AirpcapRead(pa->adapter, (PBYTE)p->buffer,
338  		    p->bufsize, &bytes_read)) {
339  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
340  			    "AirpcapRead() failed: %s",
341  			    p_AirpcapGetLastError(pa->adapter));
342  			return (-1);
343  		}
344  		cc = bytes_read;
345  		bp = p->buffer;
346  	} else
347  		bp = p->bp;
348  #define bhp ((AirpcapBpfHeader *)bp)
349  	n = 0;
350  	ep = bp + cc;
351  	for (;;) {
352  		register u_int caplen, hdrlen;
353  		if (p->break_loop) {
354  			if (n == 0) {
355  				p->break_loop = 0;
356  				return (PCAP_ERROR_BREAK);
357  			} else {
358  				p->bp = bp;
359  				p->cc = (int) (ep - bp);
360  				return (n);
361  			}
362  		}
363  		if (bp >= ep)
364  			break;
365  		caplen = bhp->Caplen;
366  		hdrlen = bhp->Hdrlen;
367  		datap = bp + hdrlen;
368  		if (pa->filtering_in_kernel ||
369  		    p->fcode.bf_insns == NULL ||
370  		    pcap_filter(p->fcode.bf_insns, datap, bhp->Originallen, caplen)) {
371  			struct pcap_pkthdr pkthdr;
372  			pkthdr.ts.tv_sec = bhp->TsSec;
373  			pkthdr.ts.tv_usec = bhp->TsUsec;
374  			pkthdr.caplen = caplen;
375  			pkthdr.len = bhp->Originallen;
376  			(*callback)(user, &pkthdr, datap);
377  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
378  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
379  				p->bp = bp;
380  				p->cc = (int)(ep - bp);
381  				return (n);
382  			}
383  		} else {
384  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
385  		}
386  	}
387  #undef bhp
388  	p->cc = 0;
389  	return (n);
390  }
391  static int
392  airpcap_inject(pcap_t *p, const void *buf, int size)
393  {
394  	struct pcap_airpcap *pa = p->priv;
395  	if (!p_AirpcapWrite(pa->adapter, (void *)buf, size)) {
396  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
397  		    "AirpcapWrite() failed: %s",
398  		    p_AirpcapGetLastError(pa->adapter));
399  		return (-1);
400  	}
401  	return (size);
402  }
403  static void
404  airpcap_cleanup(pcap_t *p)
405  {
406  	struct pcap_airpcap *pa = p->priv;
407  	if (pa->adapter != NULL) {
408  		p_AirpcapClose(pa->adapter);
409  		pa->adapter = NULL;
410  	}
411  	pcap_cleanup_live_common(p);
412  }
413  static void
414  airpcap_breakloop(pcap_t *p)
415  {
416  	HANDLE read_event;
417  	pcap_breakloop_common(p);
418  	struct pcap_airpcap *pa = p->priv;
419  	if (!p_AirpcapGetReadEvent(pa->adapter, &read_event))
420  		return;
421  	SetEvent(read_event);
422  }
423  static int
424  airpcap_activate(pcap_t *p)
425  {
426  	struct pcap_airpcap *pa = p->priv;
427  	char *device = p->opt.device;
428  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
429  	BOOL status;
430  	AirpcapLinkType link_type;
431  	pa->adapter = p_AirpcapOpen(device, airpcap_errbuf);
432  	if (pa->adapter == NULL) {
433  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "%s", airpcap_errbuf);
434  		return (PCAP_ERROR);
435  	}
436  	if (p->opt.rfmon) {
437  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
438  		    AIRPCAP_MF_MONITOR_MODE_ON);
439  	} else
440  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
441  		    AIRPCAP_MF_ACK_FRAMES_ON);
442  	if (!status) {
443  		p_AirpcapClose(pa->adapter);
444  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
445  		    "AirpcapSetDeviceMacFlags() failed: %s",
446  		    p_AirpcapGetLastError(pa->adapter));
447  		return (PCAP_ERROR);
448  	}
449  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
450  		p->snapshot = MAXIMUM_SNAPLEN;
451  	if (p->opt.buffer_size == 0)
452  		p->opt.buffer_size = AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE;
453  	if (!p_AirpcapSetKernelBuffer(pa->adapter, p->opt.buffer_size)) {
454  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
455  		    "AirpcapSetKernelBuffer() failed: %s",
456  		    p_AirpcapGetLastError(pa->adapter));
457  		goto bad;
458  	}
459  	if(!p_AirpcapGetReadEvent(pa->adapter, &pa->read_event)) {
460  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
461  		    "AirpcapGetReadEvent() failed: %s",
462  		    p_AirpcapGetLastError(pa->adapter));
463  		goto bad;
464  	}
465  	p->bufsize = AIRPCAP_DEFAULT_USER_BUFFER_SIZE;
466  	p->buffer = malloc(p->bufsize);
467  	if (p->buffer == NULL) {
468  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
469  		    errno, "malloc");
470  		goto bad;
471  	}
472  	if (p->opt.immediate) {
473  		if (!p_AirpcapSetMinToCopy(pa->adapter, 0)) {
474  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
475  			    "AirpcapSetMinToCopy() failed: %s",
476  			    p_AirpcapGetLastError(pa->adapter));
477  			goto bad;
478  		}
479  	} else {
480  		if (!p_AirpcapSetMinToCopy(pa->adapter, 16000)) {
481  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
482  			    "AirpcapSetMinToCopy() failed: %s",
483  			    p_AirpcapGetLastError(pa->adapter));
484  			goto bad;
485  		}
486  	}
487  	if (!p_AirpcapGetLinkType(pa->adapter, &link_type)) {
488  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
489  		    "AirpcapGetLinkType() failed: %s",
490  		    p_AirpcapGetLastError(pa->adapter));
491  		goto bad;
492  	}
493  	switch (link_type) {
494  	case AIRPCAP_LT_802_11_PLUS_RADIO:
495  		p->linktype = DLT_IEEE802_11_RADIO;
496  		break;
497  	case AIRPCAP_LT_802_11_PLUS_PPI:
498  		p->linktype = DLT_PPI;
499  		break;
500  	case AIRPCAP_LT_802_11:
501  		p->linktype = DLT_IEEE802_11;
502  		break;
503  	case AIRPCAP_LT_UNKNOWN:
504  	default:
505  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
506  		    "AirpcapGetLinkType() returned unknown link type %u",
507  		    link_type);
508  		goto bad;
509  	}
510  	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 3);
511  	if (p->dlt_list == NULL)
512  		goto bad;
513  	p->dlt_list[0] = DLT_IEEE802_11_RADIO;
514  	p->dlt_list[1] = DLT_PPI;
515  	p->dlt_list[2] = DLT_IEEE802_11;
516  	p->dlt_count = 3;
517  	p->read_op = airpcap_read;
518  	p->inject_op = airpcap_inject;
519  	p->setfilter_op = airpcap_setfilter;
520  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
521  	p->set_datalink_op = airpcap_set_datalink;
522  	p->getnonblock_op = airpcap_getnonblock;
523  	p->setnonblock_op = airpcap_setnonblock;
524  	p->breakloop_op = airpcap_breakloop;
525  	p->stats_op = airpcap_stats;
526  	p->stats_ex_op = airpcap_stats_ex;
527  	p->setbuff_op = airpcap_setbuff;
528  	p->setmode_op = airpcap_setmode;
529  	p->setmintocopy_op = airpcap_setmintocopy;
530  	p->getevent_op = airpcap_getevent;
531  	p->oid_get_request_op = airpcap_oid_get_request;
532  	p->oid_set_request_op = airpcap_oid_set_request;
533  	p->sendqueue_transmit_op = airpcap_sendqueue_transmit;
534  	p->setuserbuffer_op = airpcap_setuserbuffer;
535  	p->live_dump_op = airpcap_live_dump;
536  	p->live_dump_ended_op = airpcap_live_dump_ended;
537  	p->get_airpcap_handle_op = airpcap_get_airpcap_handle;
538  	p->cleanup_op = airpcap_cleanup;
539  	return (0);
540   bad:
541  	airpcap_cleanup(p);
542  	return (PCAP_ERROR);
543  }
544  static int
545  airpcap_can_set_rfmon(pcap_t *p)
546  {
547  	return (1);
548  }
549  int
550  device_is_airpcap(const char *device, char *ebuf)
551  {
552  	static const char airpcap_prefix[] = "\\\\.\\airpcap";
553  	if (strncmp(device, airpcap_prefix, sizeof airpcap_prefix - 1) == 0) {
554  		return (1);
555  	}
556  	return (0);
557  }
558  pcap_t *
559  airpcap_create(const char *device, char *ebuf, int *is_ours)
560  {
561  	int ret;
562  	pcap_t *p;
563  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
564  		*is_ours = 0;
565  		return (NULL);
566  	}
567  	ret = device_is_airpcap(device, ebuf);
568  	if (ret == 0) {
569  		*is_ours = 0;
570  		return (NULL);
571  	}
572  	*is_ours = 1;
573  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_airpcap);
574  	if (p == NULL)
575  		return (NULL);
576  	p->activate_op = airpcap_activate;
577  	p->can_set_rfmon_op = airpcap_can_set_rfmon;
578  	return (p);
579  }
580  int
581  airpcap_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
582  {
583  	AirpcapDeviceDescription *airpcap_devices, *airpcap_device;
584  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
585  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
586  		return (0);
587  	}
588  	if (!p_AirpcapGetDeviceList(&airpcap_devices, airpcap_errbuf)) {
589  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
590  		    "AirpcapGetDeviceList() failed: %s", airpcap_errbuf);
591  		return (-1);
592  	}
593  	for (airpcap_device = airpcap_devices; airpcap_device != NULL;
594  	    airpcap_device = airpcap_device->next) {
595  		if (pcap_add_dev(devlistp, airpcap_device->Name, 0,
596  		    airpcap_device->Description, errbuf) == NULL) {
597  			p_AirpcapFreeDeviceList(airpcap_devices);
598  			return (-1);
599  		}
600  	}
601  	p_AirpcapFreeDeviceList(airpcap_devices);
602  	return (0);
603  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ziplist.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include <stdint.h>
5  #include <limits.h>
6  #include "zmalloc.h"
7  #include "util.h"
8  #include "ziplist.h"
9  #include "endianconv.h"
10  #include "redisassert.h"
11  #ifdef _WIN32
12  #include "Win32_Interop/Win32_FDAPI.h"
13  #endif
14  #define ZIP_END 255         &bsol;* Special "end of ziplist" entry. */
15  #define ZIP_BIG_PREVLEN 254 &bsol;* Max number of bytes of the previous entry, for
16                                 the "prevlen" field prefixing each entry, to be
17                                 represented with just a single byte. Otherwise
18                                 it is represented as FF AA BB CC DD, where
19                                 AA BB CC DD are a 4 bytes unsigned integer
20                                 representing the previous entry len. */
21  #define ZIP_STR_MASK 0xc0
22  #define ZIP_INT_MASK 0x30
23  #define ZIP_STR_06B (0 << 6)
24  #define ZIP_STR_14B (1 << 6)
25  #define ZIP_STR_32B (2 << 6)
26  #define ZIP_INT_16B (0xc0 | 0<<4)
27  #define ZIP_INT_32B (0xc0 | 1<<4)
28  #define ZIP_INT_64B (0xc0 | 2<<4)
29  #define ZIP_INT_24B (0xc0 | 3<<4)
30  #define ZIP_INT_8B 0xfe
31  #define ZIP_INT_IMM_MASK 0x0f   &bsol;* Mask to extract the 4 bits value. To add
32                                     one is needed to reconstruct the value. */
33  #define ZIP_INT_IMM_MIN 0xf1    &bsol;* 11110001 */
34  #define ZIP_INT_IMM_MAX 0xfd    &bsol;* 11111101 */
35  #define INT24_MAX 0x7fffff
36  #define INT24_MIN (-INT24_MAX - 1)
37  #define ZIP_IS_STR(enc) (((enc) & ZIP_STR_MASK) < ZIP_STR_MASK)
38  #define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
39  #define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
40  #define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
41  #define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
42  #define ZIPLIST_END_SIZE        (sizeof(uint8_t))
43  #define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)
44  #define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
45  #define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
46  #define ZIPLIST_INCR_LENGTH(zl,incr) { \
47      if (ZIPLIST_LENGTH(zl) < UINT16_MAX) \
48          ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \
49  }
50  typedef struct zlentry {
51      unsigned int prevrawlensize; &bsol;* Bytes used to encode the previous entry len*/
52      unsigned int prevrawlen;     &bsol;* Previous entry len. */
53      unsigned int lensize;        &bsol;* Bytes used to encode this entry type/len.
54                                      For example strings have a 1, 2 or 5 bytes
55                                      header. Integers always use a single byte.*/
56      unsigned int len;            &bsol;* Bytes used to represent the actual entry.
57                                      For strings this is just the string length
58                                      while for integers it is 1, 2, 3, 4, 8 or
59                                      0 (for 4 bit immediate) depending on the
60                                      number range. */
61      unsigned int headersize;     &bsol;* prevrawlensize + lensize. */
62      unsigned char encoding;      &bsol;* Set to ZIP_STR_* or ZIP_INT_* depending on
63                                      the entry encoding. However for 4 bits
64                                      immediate integers this can assume a range
65                                      of values and must be range-checked. */
66      unsigned char *p;            &bsol;* Pointer to the very start of the entry, that
67                                      is, this points to prev-entry-len field. */
68  } zlentry;
69  #define ZIPLIST_ENTRY_ZERO(zle) { \
70      (zle)->prevrawlensize = (zle)->prevrawlen = 0; \
71      (zle)->lensize = (zle)->len = (zle)->headersize = 0; \
72      (zle)->encoding = 0; \
73      (zle)->p = NULL; \
74  }
75  #define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
76      (encoding) = (ptr[0]); \
77      if ((encoding) < ZIP_STR_MASK) (encoding) &= ZIP_STR_MASK; \
78  } while(0)
79  unsigned int zipIntSize(unsigned char encoding) {
80      switch(encoding) {
81      case ZIP_INT_8B:  return 1;
82      case ZIP_INT_16B: return 2;
83      case ZIP_INT_24B: return 3;
84      case ZIP_INT_32B: return 4;
85      case ZIP_INT_64B: return 8;
86      }
87      if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX)
88          return 0; &bsol;* 4 bit immediate */
89      panic("Invalid integer encoding 0x%02X", encoding);
90      return 0;
91  }
92  unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
93      unsigned char len = 1, buf[5];
94      if (ZIP_IS_STR(encoding)) {
95          if (rawlen <= 0x3f) {
96              if (!p) return len;
97              buf[0] = ZIP_STR_06B | rawlen;
98          } else if (rawlen <= 0x3fff) {
99              len += 1;
100              if (!p) return len;
101              buf[0] = ZIP_STR_14B | ((rawlen >> 8) & 0x3f);
102              buf[1] = rawlen & 0xff;
103          } else {
104              len += 4;
105              if (!p) return len;
106              buf[0] = ZIP_STR_32B;
107              buf[1] = (rawlen >> 24) & 0xff;
108              buf[2] = (rawlen >> 16) & 0xff;
109              buf[3] = (rawlen >> 8) & 0xff;
110              buf[4] = rawlen & 0xff;
111          }
112      } else {
113          if (!p) return len;
114          buf[0] = encoding;
115      }
116      memcpy(p,buf,len);
117      return len;
118  }
119  #define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
120      ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
121      if ((encoding) < ZIP_STR_MASK) {                                           \
122          if ((encoding) == ZIP_STR_06B) {                                       \
123              (lensize) = 1;                                                     \
124              (len) = (ptr)[0] & 0x3f;                                           \
125          } else if ((encoding) == ZIP_STR_14B) {                                \
126              (lensize) = 2;                                                     \
127              (len) = (((ptr)[0] & 0x3f) << 8) | (ptr)[1];                       \
128          } else if ((encoding) == ZIP_STR_32B) {                                \
129              (lensize) = 5;                                                     \
130              (len) = ((ptr)[1] << 24) |                                         \
131                      ((ptr)[2] << 16) |                                         \
132                      ((ptr)[3] <<  8) |                                         \
133                      ((ptr)[4]);                                                \
134          } else {                                                               \
135              panic("Invalid string encoding 0x%02X", (encoding));               \
136          }                                                                      \
137      } else {                                                                   \
138          (lensize) = 1;                                                         \
139          (len) = zipIntSize(encoding);                                          \
140      }                                                                          \
141  } while(0);
142  int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
143      if (p != NULL) {
144          p[0] = ZIP_BIG_PREVLEN;
145          memcpy(p+1,&len,sizeof(len));
146          memrev32ifbe(p+1);
147      }
148      return 1+sizeof(len);
149  }
150  unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
151      if (p == NULL) {
152          return (len < ZIP_BIG_PREVLEN) ? 1 : sizeof(len)+1;
153      } else {
154          if (len < ZIP_BIG_PREVLEN) {
155              p[0] = len;
156              return 1;
157          } else {
158              return zipStorePrevEntryLengthLarge(p,len);
159          }
160      }
161  }
162  #define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
163      if ((ptr)[0] < ZIP_BIG_PREVLEN) {                                          \
164          (prevlensize) = 1;                                                     \
165      } else {                                                                   \
166          (prevlensize) = 5;                                                     \
167      }                                                                          \
168  } while(0);
169  #define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
170      ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
171      if ((prevlensize) == 1) {                                                  \
172          (prevlen) = (ptr)[0];                                                  \
173      } else if ((prevlensize) == 5) {                                           \
174          assert(sizeof((prevlen)) == 4);                                    \
175          memcpy(&(prevlen), ((char*)(ptr)) + 1, 4);                             \
176          memrev32ifbe(&prevlen);                                                \
177      }                                                                          \
178  } while(0);
179  int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
180      unsigned int prevlensize;
181      ZIP_DECODE_PREVLENSIZE(p, prevlensize);
182      return zipStorePrevEntryLength(NULL, len) - prevlensize;
183  }
184  unsigned int zipRawEntryLength(unsigned char *p) {
185      unsigned int prevlensize, encoding, lensize, len;
186      ZIP_DECODE_PREVLENSIZE(p, prevlensize);
187      ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
188      return prevlensize + lensize + len;
189  }
190  int zipTryEncoding(unsigned char *entry, unsigned int entrylen, PORT_LONGLONG *v, unsigned char *encoding) {
191      PORT_LONGLONG value;
192      if (entrylen >= 32 || entrylen == 0) return 0;
193      if (string2ll((char*)entry,entrylen,&value)) {
194          if (value >= 0 && value <= 12) {
195              *encoding = (unsigned char)(ZIP_INT_IMM_MIN+value);                 WIN_PORT_FIX &bsol;* cast (unsigned char) */
196          } else if (value >= INT8_MIN && value <= INT8_MAX) {
197              *encoding = ZIP_INT_8B;
198          } else if (value >= INT16_MIN && value <= INT16_MAX) {
199              *encoding = ZIP_INT_16B;
200          } else if (value >= INT24_MIN && value <= INT24_MAX) {
201              *encoding = ZIP_INT_24B;
202          } else if (value >= INT32_MIN && value <= INT32_MAX) {
203              *encoding = ZIP_INT_32B;
204          } else {
205              *encoding = ZIP_INT_64B;
206          }
207          *v = value;
208          return 1;
209      }
210      return 0;
211  }
212  void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {
213      int16_t i16;
214      int32_t i32;
215      int64_t i64;
216      if (encoding == ZIP_INT_8B) {
217          ((int8_t*)p)[0] = (int8_t)value;
218      } else if (encoding == ZIP_INT_16B) {
219          i16 = (int16_t)value;                                                   WIN_PORT_FIX &bsol;* cast (int16_t) */
220          memcpy(p,&i16,sizeof(i16));
221          memrev16ifbe(p);
222      } else if (encoding == ZIP_INT_24B) {
223          i32 = (int32_t)(value<<8);                                              WIN_PORT_FIX &bsol;* cast (int32_t) */
224          memrev32ifbe(&i32);
225          memcpy(p,((uint8_t*)&i32)+1,sizeof(i32)-sizeof(uint8_t));
226      } else if (encoding == ZIP_INT_32B) {
227          i32 = (int32_t)value;                                                   WIN_PORT_FIX &bsol;* cast (int32_t) */
228          memcpy(p,&i32,sizeof(i32));
229          memrev32ifbe(p);
230      } else if (encoding == ZIP_INT_64B) {
231          i64 = value;
232          memcpy(p,&i64,sizeof(i64));
233          memrev64ifbe(p);
234      } else if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX) {
235      } else {
236          assert(NULL);
237      }
238  }
239  int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {
240      int16_t i16;
241      int32_t i32;
242      int64_t i64, ret = 0;
243      if (encoding == ZIP_INT_8B) {
244          ret = ((int8_t*)p)[0];
245      } else if (encoding == ZIP_INT_16B) {
246          memcpy(&i16,p,sizeof(i16));
247          memrev16ifbe(&i16);
248          ret = i16;
249      } else if (encoding == ZIP_INT_32B) {
250          memcpy(&i32,p,sizeof(i32));
251          memrev32ifbe(&i32);
252          ret = i32;
253      } else if (encoding == ZIP_INT_24B) {
254          i32 = 0;
255          memcpy(((uint8_t*)&i32)+1,p,sizeof(i32)-sizeof(uint8_t));
256          memrev32ifbe(&i32);
257          ret = i32>>8;
258      } else if (encoding == ZIP_INT_64B) {
259          memcpy(&i64,p,sizeof(i64));
260          memrev64ifbe(&i64);
261          ret = i64;
262      } else if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX) {
263          ret = (encoding & ZIP_INT_IMM_MASK)-1;
264      } else {
265          assert(NULL);
266      }
267      return ret;
268  }
269  void zipEntry(unsigned char *p, zlentry *e) {
270      ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
271      ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
272      e->headersize = e->prevrawlensize + e->lensize;
273      e->p = p;
274  }
275  unsigned char *ziplistNew(void) {
276      unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
277      unsigned char *zl = zmalloc(bytes);
278      ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
279      ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
280      ZIPLIST_LENGTH(zl) = 0;
281      zl[bytes-1] = ZIP_END;
282      return zl;
283  }
284  unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {
285      zl = zrealloc(zl,len);
286      ZIPLIST_BYTES(zl) = intrev32ifbe(len);
287      zl[len-1] = ZIP_END;
288      return zl;
289  }
290  unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
291      size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
292      size_t offset, noffset, extra;
293      unsigned char *np;
294      zlentry cur, next;
295      while (p[0] != ZIP_END) {
296          zipEntry(p, &cur);
297          rawlen = cur.headersize + cur.len;
298          rawlensize = zipStorePrevEntryLength(NULL,(unsigned int)rawlen);            WIN_PORT_FIX &bsol;* cast (unsigned int) */
299          if (p[rawlen] == ZIP_END) break;
300          zipEntry(p+rawlen, &next);
301          if (next.prevrawlen == rawlen) break;
302          if (next.prevrawlensize < rawlensize) {
303              offset = p-zl;
304              extra = rawlensize-next.prevrawlensize;
305              zl = ziplistResize(zl,(unsigned int)(curlen+extra));                WIN_PORT_FIX &bsol;* cast (unsigned int) */
306              p = zl+offset;
307              np = p+rawlen;
308              noffset = np-zl;
309              if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {
310                  ZIPLIST_TAIL_OFFSET(zl) =
311                      (uint32_t)intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra); WIN_PORT_FIX &bsol;* cast (uint32_t) */
312              }
313              memmove(np+rawlensize,
314                  np+next.prevrawlensize,
315                  curlen-noffset-next.prevrawlensize-1);
316              zipStorePrevEntryLength(np,(unsigned int)rawlen);                       WIN_PORT_FIX &bsol;* cast (unsigned int) */
317              p += rawlen;
318              curlen += extra;
319          } else {
320              if (next.prevrawlensize > rawlensize) {
321                  zipStorePrevEntryLengthLarge(p+rawlen,(unsigned int)rawlen);
322              } else {
323                  zipStorePrevEntryLength(p+rawlen,(unsigned int)rawlen);
324              }
325              break;
326          }
327      }
328      return zl;
329  }
330  unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
331      unsigned int i, totlen, deleted = 0;
332      size_t offset;
333      int nextdiff = 0;
334      zlentry first, tail;
335      zipEntry(p, &first);
336      for (i = 0; p[0] != ZIP_END && i < num; i++) {
337          p += zipRawEntryLength(p);
338          deleted++;
339      }
340      totlen = (unsigned int)(p-first.p); &bsol;* Bytes taken by the element(s) to delete. */ WIN_PORT_FIX &bsol;* cast (unsigned int) */
341      if (totlen > 0) {
342          if (p[0] != ZIP_END) {
343              nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);
344              p -= nextdiff;
345              zipStorePrevEntryLength(p,first.prevrawlen);
346              ZIPLIST_TAIL_OFFSET(zl) =
347                  intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);
348              zipEntry(p, &tail);
349              if (p[tail.headersize+tail.len] != ZIP_END) {
350                  ZIPLIST_TAIL_OFFSET(zl) =
351                     intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
352              }
353              memmove(first.p,p,
354                  intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1);
355          } else {
356              ZIPLIST_TAIL_OFFSET(zl) =
357                  (unsigned int)intrev32ifbe((first.p-zl)-first.prevrawlen);      WIN_PORT_FIX &bsol;* cast (unsigned int) */
358          }
359          offset = first.p-zl;
360          zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);
361          ZIPLIST_INCR_LENGTH(zl,-deleted);
362          p = zl+offset;
363          if (nextdiff != 0)
364              zl = __ziplistCascadeUpdate(zl,p);
365      }
366      return zl;
367  }
368  unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
369      size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
370      unsigned int prevlensize, prevlen = 0;
371      size_t offset;
372      int nextdiff = 0;
373      unsigned char encoding = 0;
374      PORT_LONGLONG value = 123456789; &bsol;* initialized to avoid warning. Using a value
375                                      that is easy to see if for some reason
376                                      we use it uninitialized. */
377      zlentry tail;
378      if (p[0] != ZIP_END) {
379          ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
380      } else {
381          unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
382          if (ptail[0] != ZIP_END) {
383              prevlen = zipRawEntryLength(ptail);
384          }
385      }
386      if (zipTryEncoding(s,slen,&value,&encoding)) {
387          reqlen = zipIntSize(encoding);
388      } else {
389          reqlen = slen;
390      }
391      reqlen += zipStorePrevEntryLength(NULL,(unsigned int)prevlen); WIN_PORT_FIX &bsol;* cast (unsigned int) */
392      reqlen += zipStoreEntryEncoding(NULL,encoding,slen);
393      int forcelarge = 0;
394      nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,(unsigned int)reqlen) : 0;  WIN_PORT_FIX &bsol;* cast (unsigned int) */
395      if (nextdiff == -4 && reqlen < 4) {
396          nextdiff = 0;
397          forcelarge = 1;
398      }
399      offset = p-zl;
400      zl = ziplistResize(zl,(unsigned int)(curlen+reqlen+nextdiff));              WIN_PORT_FIX &bsol;* cast (unsigned int) */
401      p = zl+offset;
402      if (p[0] != ZIP_END) {
403          memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);
404          if (forcelarge)
405              zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
406          else
407              zipStorePrevEntryLength(p+reqlen,reqlen);
408          ZIPLIST_TAIL_OFFSET(zl) =
409              (uint32_t)intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen); WIN_PORT_FIX &bsol;* cast (uint32_t) */
410          zipEntry(p+reqlen, &tail);
411          if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
412              ZIPLIST_TAIL_OFFSET(zl) =
413                  intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
414          }
415      } else {
416          ZIPLIST_TAIL_OFFSET(zl) = (uint32_t)intrev32ifbe(p-zl);                 WIN_PORT_FIX &bsol;* cast (uint32_) */
417      }
418      if (nextdiff != 0) {
419          offset = p-zl;
420          zl = __ziplistCascadeUpdate(zl,p+reqlen);
421          p = zl+offset;
422      }
423      p += zipStorePrevEntryLength(p,prevlen);
424      p += zipStoreEntryEncoding(p,encoding,slen);
425      if (ZIP_IS_STR(encoding)) {
426          memcpy(p,s,slen);
427      } else {
428          zipSaveInteger(p,value,encoding);
429      }
430      ZIPLIST_INCR_LENGTH(zl,1);
431      return zl;
432  }
433  unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {
434      if (first == NULL || *first == NULL || second == NULL || *second == NULL)
435          return NULL;
436      if (*first == *second)
437          return NULL;
438      size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
439      size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));
440      size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
441      size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));
442      int append;
443      unsigned char *source, *target;
444      size_t target_bytes, source_bytes;
445      if (first_len >= second_len) {
446          target = *first;
447          target_bytes = first_bytes;
448          source = *second;
449          source_bytes = second_bytes;
450          append = 1;
451      } else {
452          target = *second;
453          target_bytes = second_bytes;
454          source = *first;
455          source_bytes = first_bytes;
456          append = 0;
457      }
458      size_t zlbytes = first_bytes + second_bytes -
459                       ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;
460      size_t zllength = first_len + second_len;
461      zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;
462      size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));
463      size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));
464      target = zrealloc(target, zlbytes);
465      if (append) {
466          memcpy(target + target_bytes - ZIPLIST_END_SIZE,
467                 source + ZIPLIST_HEADER_SIZE,
468                 source_bytes - ZIPLIST_HEADER_SIZE);
469      } else {
470          memmove(target + source_bytes - ZIPLIST_END_SIZE,
471                  target + ZIPLIST_HEADER_SIZE,
472                  target_bytes - ZIPLIST_HEADER_SIZE);
473          memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);
474      }
475      ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);
476      ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);
477      ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(
478                                     (first_bytes - ZIPLIST_END_SIZE) +
479                                     (second_offset - ZIPLIST_HEADER_SIZE));
480      target = __ziplistCascadeUpdate(target, target+first_offset);
481      if (append) {
482          zfree(*second);
483          *second = NULL;
484          *first = target;
485      } else {
486          zfree(*first);
487          *first = NULL;
488          *second = target;
489      }
490      return target;
491  }
492  unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
493      unsigned char *p;
494      p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
495      return __ziplistInsert(zl,p,s,slen);
496  }
497  unsigned char *ziplistIndex(unsigned char *zl, int index) {
498      unsigned char *p;
499      unsigned int prevlensize, prevlen = 0;
500      if (index < 0) {
501          index = (-index)-1;
502          p = ZIPLIST_ENTRY_TAIL(zl);
503          if (p[0] != ZIP_END) {
504              ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
505              while (prevlen > 0 && index--) {
506                  p -= prevlen;
507                  ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
508              }
509          }
510      } else {
511          p = ZIPLIST_ENTRY_HEAD(zl);
512          while (p[0] != ZIP_END && index--) {
513              p += zipRawEntryLength(p);
514          }
515      }
516      return (p[0] == ZIP_END || index > 0) ? NULL : p;
517  }
518  unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {
519      ((void) zl);
520      if (p[0] == ZIP_END) {
521          return NULL;
522      }
523      p += zipRawEntryLength(p);
524      if (p[0] == ZIP_END) {
525          return NULL;
526      }
527      return p;
528  }
529  unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {
530      unsigned int prevlensize, prevlen = 0;
531      if (p[0] == ZIP_END) {
532          p = ZIPLIST_ENTRY_TAIL(zl);
533          return (p[0] == ZIP_END) ? NULL : p;
534      } else if (p == ZIPLIST_ENTRY_HEAD(zl)) {
535          return NULL;
536      } else {
537          ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
538          assert(prevlen > 0);
539          return p-prevlen;
540      }
541  }
542  unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, PORT_LONGLONG *sval) {
543      zlentry entry;
544      if (p == NULL || p[0] == ZIP_END) return 0;
545      if (sstr) *sstr = NULL;
546      zipEntry(p, &entry);
547      if (ZIP_IS_STR(entry.encoding)) {
548          if (sstr) {
549              *slen = entry.len;
550              *sstr = p+entry.headersize;
551          }
552      } else {
553          if (sval) {
554              *sval = zipLoadInteger(p+entry.headersize,entry.encoding);
555          }
556      }
557      return 1;
558  }
559  unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
560      return __ziplistInsert(zl,p,s,slen);
561  }
562  unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
563      size_t offset = *p-zl;
564      zl = __ziplistDelete(zl,*p,1);
565      *p = zl+offset;
566      return zl;
567  }
568  unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {
569      unsigned char *p = ziplistIndex(zl,index);
570      return (p == NULL) ? zl : __ziplistDelete(zl,p,num);
571  }
572  unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {
573      zlentry entry;
574      unsigned char sencoding;
575      PORT_LONGLONG zval, sval;
576      if (p[0] == ZIP_END) return 0;
577      zipEntry(p, &entry);
578      if (ZIP_IS_STR(entry.encoding)) {
579          if (entry.len == slen) {
580              return memcmp(p+entry.headersize,sstr,slen) == 0;
581          } else {
582              return 0;
583          }
584      } else {
585          if (zipTryEncoding(sstr,slen,&sval,&sencoding)) {
586            zval = zipLoadInteger(p+entry.headersize,entry.encoding);
587            return zval == sval;
588          }
589      }
590      return 0;
591  }
592  unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {
593      int skipcnt = 0;
594      unsigned char vencoding = 0;
595      PORT_LONGLONG vll = 0;
596      while (p[0] != ZIP_END) {
597          unsigned int prevlensize, encoding, lensize, len;
598          unsigned char *q;
599          ZIP_DECODE_PREVLENSIZE(p, prevlensize);
600          ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
601          q = p + prevlensize + lensize;
602          if (skipcnt == 0) {
603              if (ZIP_IS_STR(encoding)) {
604                  if (len == vlen && memcmp(q, vstr, vlen) == 0) {
605                      return p;
606                  }
607              } else {
608                  if (vencoding == 0) {
609                      if (!zipTryEncoding(vstr, vlen, &vll, &vencoding)) {
610                          vencoding = UCHAR_MAX;
611                      }
612                      assert(vencoding);
613                  }
614                  if (vencoding != UCHAR_MAX) {
615                      PORT_LONGLONG ll = zipLoadInteger(q, encoding);
616                      if (ll == vll) {
617                          return p;
618                      }
619                  }
620              }
621              skipcnt = skip;
622          } else {
623              skipcnt--;
624          }
625          p = q + len;
626      }
627      return NULL;
628  }
629  unsigned int ziplistLen(unsigned char *zl) {
630      unsigned int len = 0;
631      if (intrev16ifbe(ZIPLIST_LENGTH(zl)) < UINT16_MAX) {
632          len = intrev16ifbe(ZIPLIST_LENGTH(zl));
633      } else {
634          unsigned char *p = zl+ZIPLIST_HEADER_SIZE;
635          while (*p != ZIP_END) {
636              p += zipRawEntryLength(p);
637              len++;
638          }
639          if (len < UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
640      }
641      return len;
642  }
643  size_t ziplistBlobLen(unsigned char *zl) {
644      return intrev32ifbe(ZIPLIST_BYTES(zl));
645  }
646  void ziplistRepr(unsigned char *zl) {
647      unsigned char *p;
648      int index = 0;
649      zlentry entry;
650      printf(
651          "{total bytes %d} "
652          "{num entries %u}\n"
653          "{tail offset %u}\n",
654          intrev32ifbe(ZIPLIST_BYTES(zl)),
655          intrev16ifbe(ZIPLIST_LENGTH(zl)),
656          intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
657      p = ZIPLIST_ENTRY_HEAD(zl);
658      while(*p != ZIP_END) {
659          zipEntry(p, &entry);
660          printf(
661              "{\n"
662                  "\taddr 0x%08lx,\n"
663                  "\tindex %2d,\n"
664                  "\toffset %5ld,\n"
665                  "\thdr+entry len: %5u,\n"
666                  "\thdr len%2u,\n"
667                  "\tprevrawlen: %5u,\n"
668                  "\tprevrawlensize: %2u,\n"
669                  "\tpayload %5u\n",
670              (PORT_ULONG)p,
671              index,
672              (PORT_ULONG) (p-zl),
673              entry.headersize+entry.len,
674              entry.headersize,
675              entry.prevrawlen,
676              entry.prevrawlensize,
677              entry.len);
678          printf("\tbytes: ");
679          for (unsigned int i = 0; i < entry.headersize+entry.len; i++) {
680              printf("%02x|",p[i]);
681          }
682          printf("\n");
683          p += entry.headersize;
684          if (ZIP_IS_STR(entry.encoding)) {
685              printf("\t[str]");
686              if (entry.len > 40) {
687                  if (fwrite(p,40,1,stdout) == 0) perror("fwrite");
688                  printf("...");
689              } else {
690                  if (entry.len &&
691                      fwrite(p,entry.len,1,stdout) == 0) perror("fwrite");
692              }
693          } else {
694              printf("\t[int]%lld", (PORT_LONGLONG) zipLoadInteger(p,entry.encoding));
695          }
696          printf("\n}\n");
697          p += entry.len;
698          index++;
699      }
700      printf("{end}\n\n");
701  }
702  #ifdef REDIS_TEST
703  #include <sys/time.h>
704  #include "adlist.h"
705  #include "sds.h"
706  #define debug(f, ...) { if (DEBUG) printf(f, __VA_ARGS__); }
707  static unsigned char *createList() {
708      unsigned char *zl = ziplistNew();
709      zl = ziplistPush(zl, (unsigned char*)"foo", 3, ZIPLIST_TAIL);
710      zl = ziplistPush(zl, (unsigned char*)"quux", 4, ZIPLIST_TAIL);
711      zl = ziplistPush(zl, (unsigned char*)"hello", 5, ZIPLIST_HEAD);
712      zl = ziplistPush(zl, (unsigned char*)"1024", 4, ZIPLIST_TAIL);
713      return zl;
714  }
715  static unsigned char *createIntList() {
716      unsigned char *zl = ziplistNew();
717      char buf[32];
718      sprintf(buf, "100");
719      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
720      sprintf(buf, "128000");
721      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
722      sprintf(buf, "-100");
723      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
724      sprintf(buf, "4294967296");
725      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
726      sprintf(buf, "non integer");
727      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
728      sprintf(buf, "much much longer non integer");
729      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
730      return zl;
731  }
732  static PORT_LONGLONG usec(void) {
733  #ifdef _WIN32
734      return GetHighResRelativeTime(1000000);
735  #else
736      struct timeval tv;
737      gettimeofday(&tv,NULL);
738      return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
739  #endif
740  }
741  static void stress(int pos, int num, int maxsize, int dnum) {
742      int i,j,k;
743      unsigned char *zl;
744      char posstr[2][5] = { "HEAD", "TAIL" };
745      PORT_LONGLONG start;
746      for (i = 0; i < maxsize; i+=dnum) {
747          zl = ziplistNew();
748          for (j = 0; j < i; j++) {
749              zl = ziplistPush(zl,(unsigned char*)"quux",4,ZIPLIST_TAIL);
750          }
751          start = usec();
752          for (k = 0; k < num; k++) {
753              zl = ziplistPush(zl,(unsigned char*)"quux",4,pos);
754              zl = ziplistDeleteRange(zl,0,1);
755          }
756          printf("List size: %8d, bytes: %8d, %dx push+pop (%s): %6lld usec\n",
757              i,intrev32ifbe(ZIPLIST_BYTES(zl)),num,posstr[pos],usec()-start);
758          zfree(zl);
759      }
760  }
761  static unsigned char *pop(unsigned char *zl, int where) {
762      unsigned char *p, *vstr;
763      unsigned int vlen;
764      PORT_LONGLONG vlong;
765      p = ziplistIndex(zl,where == ZIPLIST_HEAD ? 0 : -1);
766      if (ziplistGet(p,&vstr,&vlen,&vlong)) {
767          if (where == ZIPLIST_HEAD)
768              printf("Pop head: ");
769          else
770              printf("Pop tail: ");
771          if (vstr) {
772              if (vlen && fwrite(vstr,vlen,1,stdout) == 0) perror("fwrite");
773          }
774          else {
775              printf("%lld", vlong);
776          }
777          printf("\n");
778          return ziplistDelete(zl,&p);
779      } else {
780          printf("ERROR: Could not pop\n");
781          exit(1);
782      }
783  }
784  static int randstring(char *target, unsigned int min, unsigned int max) {
785      int p = 0;
786      int len = min+rand()%(max-min+1);
787      int minval, maxval;
788      switch(rand() % 3) {
789      case 0:
790          minval = 0;
791          maxval = 255;
792      break;
793      case 1:
794          minval = 48;
795          maxval = 122;
796      break;
797      case 2:
798          minval = 48;
799          maxval = 52;
800      break;
801      default:
802          assert(NULL);
803      }
804      while(p < len)
805          target[p++] = minval+rand()%(maxval-minval+1);
806      return len;
807  }
808  static void verify(unsigned char *zl, zlentry *e) {
809      int len = ziplistLen(zl);
810      zlentry _e;
811      ZIPLIST_ENTRY_ZERO(&_e);
812      for (int i = 0; i < len; i++) {
813          memset(&e[i], 0, sizeof(zlentry));
814          zipEntry(ziplistIndex(zl, i), &e[i]);
815          memset(&_e, 0, sizeof(zlentry));
816          zipEntry(ziplistIndex(zl, -len+i), &_e);
817          assert(memcmp(&e[i], &_e, sizeof(zlentry)) == 0);
818      }
819  }
820  int ziplistTest(int argc, char **argv) {
821      unsigned char *zl, *p;
822      unsigned char *entry;
823      unsigned int elen;
824      PORT_LONGLONG value;
825      if (argc == 2)
826          srand(atoi(argv[1]));
827      zl = createIntList();
828      ziplistRepr(zl);
829      zfree(zl);
830      zl = createList();
831      ziplistRepr(zl);
832      zl = pop(zl,ZIPLIST_TAIL);
833      ziplistRepr(zl);
834      zl = pop(zl,ZIPLIST_HEAD);
835      ziplistRepr(zl);
836      zl = pop(zl,ZIPLIST_TAIL);
837      ziplistRepr(zl);
838      zl = pop(zl,ZIPLIST_TAIL);
839      ziplistRepr(zl);
840      zfree(zl);
841      printf("Get element at index 3:\n");
842      {
843          zl = createList();
844          p = ziplistIndex(zl, 3);
845          if (!ziplistGet(p, &entry, &elen, &value)) {
846              printf("ERROR: Could not access index 3\n");
847              return 1;
848          }
849          if (entry) {
850              if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
851              printf("\n");
852          } else {
853              printf("%lld\n", value);
854          }
855          printf("\n");
856          zfree(zl);
857      }
858      printf("Get element at index 4 (out of range):\n");
859      {
860          zl = createList();
861          p = ziplistIndex(zl, 4);
862          if (p == NULL) {
863              printf("No entry\n");
864          } else {
865              printf("ERROR: Out of range index should return NULL, returned offset: %ld\n", p-zl);
866              return 1;
867          }
868          printf("\n");
869          zfree(zl);
870      }
871      printf("Get element at index -1 (last element):\n");
872      {
873          zl = createList();
874          p = ziplistIndex(zl, -1);
875          if (!ziplistGet(p, &entry, &elen, &value)) {
876              printf("ERROR: Could not access index -1\n");
877              return 1;
878          }
879          if (entry) {
880              if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
881              printf("\n");
882          } else {
883              printf("%lld\n", value);
884          }
885          printf("\n");
886          zfree(zl);
887      }
888      printf("Get element at index -4 (first element):\n");
889      {
890          zl = createList();
891          p = ziplistIndex(zl, -4);
892          if (!ziplistGet(p, &entry, &elen, &value)) {
893              printf("ERROR: Could not access index -4\n");
894              return 1;
895          }
896          if (entry) {
897              if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
898              printf("\n");
899          } else {
900              printf("%lld\n", value);
901          }
902          printf("\n");
903          zfree(zl);
904      }
905      printf("Get element at index -5 (reverse out of range):\n");
906      {
907          zl = createList();
908          p = ziplistIndex(zl, -5);
909          if (p == NULL) {
910              printf("No entry\n");
911          } else {
912              printf("ERROR: Out of range index should return NULL, returned offset: %ld\n", p-zl);
913              return 1;
914          }
915          printf("\n");
916          zfree(zl);
917      }
918      printf("Iterate list from 0 to end:\n");
919      {
920          zl = createList();
921          p = ziplistIndex(zl, 0);
922          while (ziplistGet(p, &entry, &elen, &value)) {
923              printf("Entry: ");
924              if (entry) {
925                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
926              } else {
927                  printf("%lld", value);
928              }
929              p = ziplistNext(zl,p);
930              printf("\n");
931          }
932          printf("\n");
933          zfree(zl);
934      }
935      printf("Iterate list from 1 to end:\n");
936      {
937          zl = createList();
938          p = ziplistIndex(zl, 1);
939          while (ziplistGet(p, &entry, &elen, &value)) {
940              printf("Entry: ");
941              if (entry) {
942                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
943              } else {
944                  printf("%lld", value);
945              }
946              p = ziplistNext(zl,p);
947              printf("\n");
948          }
949          printf("\n");
950          zfree(zl);
951      }
952      printf("Iterate list from 2 to end:\n");
953      {
954          zl = createList();
955          p = ziplistIndex(zl, 2);
956          while (ziplistGet(p, &entry, &elen, &value)) {
957              printf("Entry: ");
958              if (entry) {
959                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
960              } else {
961                  printf("%lld", value);
962              }
963              p = ziplistNext(zl,p);
964              printf("\n");
965          }
966          printf("\n");
967          zfree(zl);
968      }
969      printf("Iterate starting out of range:\n");
970      {
971          zl = createList();
972          p = ziplistIndex(zl, 4);
973          if (!ziplistGet(p, &entry, &elen, &value)) {
974              printf("No entry\n");
975          } else {
976              printf("ERROR\n");
977          }
978          printf("\n");
979          zfree(zl);
980      }
981      printf("Iterate from back to front:\n");
982      {
983          zl = createList();
984          p = ziplistIndex(zl, -1);
985          while (ziplistGet(p, &entry, &elen, &value)) {
986              printf("Entry: ");
987              if (entry) {
988                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
989              } else {
990                  printf("%lld", value);
991              }
992              p = ziplistPrev(zl,p);
993              printf("\n");
994          }
995          printf("\n");
996          zfree(zl);
997      }
998      printf("Iterate from back to front, deleting all items:\n");
999      {
1000          zl = createList();
1001          p = ziplistIndex(zl, -1);
1002          while (ziplistGet(p, &entry, &elen, &value)) {
1003              printf("Entry: ");
1004              if (entry) {
1005                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
1006              } else {
1007                  printf("%lld", value);
1008              }
1009              zl = ziplistDelete(zl,&p);
1010              p = ziplistPrev(zl,p);
1011              printf("\n");
1012          }
1013          printf("\n");
1014          zfree(zl);
1015      }
1016      printf("Delete inclusive range 0,0:\n");
1017      {
1018          zl = createList();
1019          zl = ziplistDeleteRange(zl, 0, 1);
1020          ziplistRepr(zl);
1021          zfree(zl);
1022      }
1023      printf("Delete inclusive range 0,1:\n");
1024      {
1025          zl = createList();
1026          zl = ziplistDeleteRange(zl, 0, 2);
1027          ziplistRepr(zl);
1028          zfree(zl);
1029      }
1030      printf("Delete inclusive range 1,2:\n");
1031      {
1032          zl = createList();
1033          zl = ziplistDeleteRange(zl, 1, 2);
1034          ziplistRepr(zl);
1035          zfree(zl);
1036      }
1037      printf("Delete with start index out of range:\n");
1038      {
1039          zl = createList();
1040          zl = ziplistDeleteRange(zl, 5, 1);
1041          ziplistRepr(zl);
1042          zfree(zl);
1043      }
1044      printf("Delete with num overflow:\n");
1045      {
1046          zl = createList();
1047          zl = ziplistDeleteRange(zl, 1, 5);
1048          ziplistRepr(zl);
1049          zfree(zl);
1050      }
1051      printf("Delete foo while iterating:\n");
1052      {
1053          zl = createList();
1054          p = ziplistIndex(zl,0);
1055          while (ziplistGet(p,&entry,&elen,&value)) {
1056              if (entry && strncmp("foo",(char*)entry,elen) == 0) {
1057                  printf("Delete foo\n");
1058                  zl = ziplistDelete(zl,&p);
1059              } else {
1060                  printf("Entry: ");
1061                  if (entry) {
1062                      if (elen && fwrite(entry,elen,1,stdout) == 0)
1063                          perror("fwrite");
1064                  } else {
1065                      printf("%lld",value);
1066                  }
1067                  p = ziplistNext(zl,p);
1068                  printf("\n");
1069              }
1070          }
1071          printf("\n");
1072          ziplistRepr(zl);
1073          zfree(zl);
1074      }
1075      printf("Regression test for >255 byte strings:\n");
1076      {
1077          char v1[257] = {0}, v2[257] = {0};
1078          memset(v1,'x',256);
1079          memset(v2,'y',256);
1080          zl = ziplistNew();
1081          zl = ziplistPush(zl,(unsigned char*)v1,strlen(v1),ZIPLIST_TAIL);
1082          zl = ziplistPush(zl,(unsigned char*)v2,strlen(v2),ZIPLIST_TAIL);
1083          p = ziplistIndex(zl,0);
1084          assert(ziplistGet(p,&entry,&elen,&value));
1085          assert(strncmp(v1,(char*)entry,elen) == 0);
1086          p = ziplistIndex(zl,1);
1087          assert(ziplistGet(p,&entry,&elen,&value));
1088          assert(strncmp(v2,(char*)entry,elen) == 0);
1089          printf("SUCCESS\n\n");
1090          zfree(zl);
1091      }
1092      printf("Regression test deleting next to last entries:\n");
1093      {
1094          char v[3][257] = {{0}};
<span onclick='openModal()' class='match'>1095          zlentry e[3] = {{.prevrawlensize = 0, .prevrawlen = 0, .lensize = 0,
1096                           .len = 0, .headersize = 0, .encoding = 0, .p = NULL}};
</span>1097          size_t i;
1098          for (i = 0; i < (sizeof(v)/sizeof(v[0])); i++) {
1099              memset(v[i], 'a' + i, sizeof(v[0]));
1100          }
1101          v[0][256] = '\0';
1102          v[1][  1] = '\0';
1103          v[2][256] = '\0';
1104          zl = ziplistNew();
1105          for (i = 0; i < (sizeof(v)/sizeof(v[0])); i++) {
1106              zl = ziplistPush(zl, (unsigned char *) v[i], strlen(v[i]), ZIPLIST_TAIL);
1107          }
1108          verify(zl, e);
1109          assert(e[0].prevrawlensize == 1);
1110          assert(e[1].prevrawlensize == 5);
1111          assert(e[2].prevrawlensize == 1);
1112          unsigned char *p = e[1].p;
1113          zl = ziplistDelete(zl, &p);
1114          verify(zl, e);
1115          assert(e[0].prevrawlensize == 1);
1116          assert(e[1].prevrawlensize == 5);
1117          printf("SUCCESS\n\n");
1118          zfree(zl);
1119      }
1120      printf("Create long list and check indices:\n");
1121      {
1122          zl = ziplistNew();
1123          char buf[32];
1124          int i,len;
1125          for (i = 0; i < 1000; i++) {
1126              len = sprintf(buf,"%d",i);
1127              zl = ziplistPush(zl,(unsigned char*)buf,len,ZIPLIST_TAIL);
1128          }
1129          for (i = 0; i < 1000; i++) {
1130              p = ziplistIndex(zl,i);
1131              assert(ziplistGet(p,NULL,NULL,&value));
1132              assert(i == value);
1133              p = ziplistIndex(zl,-i-1);
1134              assert(ziplistGet(p,NULL,NULL,&value));
1135              assert(999-i == value);
1136          }
1137          printf("SUCCESS\n\n");
1138          zfree(zl);
1139      }
1140      printf("Compare strings with ziplist entries:\n");
1141      {
1142          zl = createList();
1143          p = ziplistIndex(zl,0);
1144          if (!ziplistCompare(p,(unsigned char*)"hello",5)) {
1145              printf("ERROR: not \"hello\"\n");
1146              return 1;
1147          }
1148          if (ziplistCompare(p,(unsigned char*)"hella",5)) {
1149              printf("ERROR: \"hella\"\n");
1150              return 1;
1151          }
1152          p = ziplistIndex(zl,3);
1153          if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
1154              printf("ERROR: not \"1024\"\n");
1155              return 1;
1156          }
1157          if (ziplistCompare(p,(unsigned char*)"1025",4)) {
1158              printf("ERROR: \"1025\"\n");
1159              return 1;
1160          }
1161          printf("SUCCESS\n\n");
1162          zfree(zl);
1163      }
1164      printf("Merge test:\n");
1165      {
1166          zl = createList();
1167          unsigned char *zl2 = createList();
1168          unsigned char *zl3 = ziplistNew();
1169          unsigned char *zl4 = ziplistNew();
1170          if (ziplistMerge(&zl4, &zl4)) {
1171              printf("ERROR: Allowed merging of one ziplist into itself.\n");
1172              return 1;
1173          }
1174          zl4 = ziplistMerge(&zl3, &zl4);
1175          ziplistRepr(zl4);
1176          if (ziplistLen(zl4)) {
1177              printf("ERROR: Merging two empty ziplists created entries.\n");
1178              return 1;
1179          }
1180          zfree(zl4);
1181          zl2 = ziplistMerge(&zl, &zl2);
1182          ziplistRepr(zl2);
1183          if (ziplistLen(zl2) != 8) {
1184              printf("ERROR: Merged length not 8, but: %u\n", ziplistLen(zl2));
1185              return 1;
1186          }
1187          p = ziplistIndex(zl2,0);
1188          if (!ziplistCompare(p,(unsigned char*)"hello",5)) {
1189              printf("ERROR: not \"hello\"\n");
1190              return 1;
1191          }
1192          if (ziplistCompare(p,(unsigned char*)"hella",5)) {
1193              printf("ERROR: \"hella\"\n");
1194              return 1;
1195          }
1196          p = ziplistIndex(zl2,3);
1197          if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
1198              printf("ERROR: not \"1024\"\n");
1199              return 1;
1200          }
1201          if (ziplistCompare(p,(unsigned char*)"1025",4)) {
1202              printf("ERROR: \"1025\"\n");
1203              return 1;
1204          }
1205          p = ziplistIndex(zl2,4);
1206          if (!ziplistCompare(p,(unsigned char*)"hello",5)) {
1207              printf("ERROR: not \"hello\"\n");
1208              return 1;
1209          }
1210          if (ziplistCompare(p,(unsigned char*)"hella",5)) {
1211              printf("ERROR: \"hella\"\n");
1212              return 1;
1213          }
1214          p = ziplistIndex(zl2,7);
1215          if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
1216              printf("ERROR: not \"1024\"\n");
1217              return 1;
1218          }
1219          if (ziplistCompare(p,(unsigned char*)"1025",4)) {
1220              printf("ERROR: \"1025\"\n");
1221              return 1;
1222          }
1223          printf("SUCCESS\n\n");
1224          zfree(zl);
1225      }
1226      printf("Stress with random payloads of different encoding:\n");
1227      {
1228          int i,j,len,where;
1229          unsigned char *p;
1230          char buf[1024];
1231          int buflen;
1232          list *ref;
1233          listNode *refnode;
1234          unsigned char *sstr;
1235          unsigned int slen;
1236          PORT_LONGLONG sval;
1237          for (i = 0; i < 20000; i++) {
1238              zl = ziplistNew();
1239              ref = listCreate();
1240              listSetFreeMethod(ref,(void (*)(void*))sdsfree);
1241              len = rand() % 256;
1242              for (j = 0; j < len; j++) {
1243                  where = (rand() & 1) ? ZIPLIST_HEAD : ZIPLIST_TAIL;
1244                  if (rand() % 2) {
1245                      buflen = randstring(buf,1,sizeof(buf)-1);
1246                  } else {
1247                      switch(rand() % 3) {
1248                      case 0:
1249                          buflen = sprintf(buf,"%lld",(0LL + rand()) >> 20);
1250                          break;
1251                      case 1:
1252                          buflen = sprintf(buf,"%lld",(0LL + rand()));
1253                          break;
1254                      case 2:
1255                          buflen = sprintf(buf,"%lld",(0LL + rand()) << 20);
1256                          break;
1257                      default:
1258                          assert(NULL);
1259                      }
1260                  }
1261                  zl = ziplistPush(zl, (unsigned char*)buf, buflen, where);
1262                  if (where == ZIPLIST_HEAD) {
1263                      listAddNodeHead(ref,sdsnewlen(buf, buflen));
1264                  } else if (where == ZIPLIST_TAIL) {
1265                      listAddNodeTail(ref,sdsnewlen(buf, buflen));
1266                  } else {
1267                      assert(NULL);
1268                  }
1269              }
1270              assert(listLength(ref) == ziplistLen(zl));
1271              for (j = 0; j < len; j++) {
1272                  p = ziplistIndex(zl,j);
1273                  refnode = listIndex(ref,j);
1274                  assert(ziplistGet(p,&sstr,&slen,&sval));
1275                  if (sstr == NULL) {
1276                      buflen = sprintf(buf,"%lld",sval);
1277                  } else {
1278                      buflen = slen;
1279                      memcpy(buf,sstr,buflen);
1280                      buf[buflen] = '\0';
1281                  }
1282                  assert(memcmp(buf,listNodeValue(refnode),buflen) == 0);
1283              }
1284              zfree(zl);
1285              listRelease(ref);
1286          }
1287          printf("SUCCESS\n\n");
1288      }
1289      printf("Stress with variable ziplist size:\n");
1290      {
1291          stress(ZIPLIST_HEAD,100000,16384,256);
1292          stress(ZIPLIST_TAIL,100000,16384,256);
1293      }
1294      return 0;
1295  }
1296  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ziplist.c</div>
                </div>
                <div class="column column_space"><pre><code>65  	if (airpcap_lib != NULL) {
66  		p_AirpcapGetLastError = (AirpcapGetLastErrorHandler) pcap_find_function(airpcap_lib, "AirpcapGetLastError");
67  		p_AirpcapGetDeviceList = (AirpcapGetDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapGetDeviceList");
68  		p_AirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapFreeDeviceList");
69  		p_AirpcapOpen = (AirpcapOpenHandler) pcap_find_function(airpcap_lib, "AirpcapOpen");
70  		p_AirpcapClose = (AirpcapCloseHandler) pcap_find_function(airpcap_lib, "AirpcapClose");
71  		p_AirpcapSetDeviceMacFlags = (AirpcapSetDeviceMacFlagsHandler) pcap_find_function(airpcap_lib, "AirpcapSetDeviceMacFlags");
72  		p_AirpcapSetLinkType = (AirpcapSetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapSetLinkType");
</pre></code></div>
                <div class="column column_space"><pre><code>1095          zlentry e[3] = {{.prevrawlensize = 0, .prevrawlen = 0, .lensize = 0,
1096                           .len = 0, .headersize = 0, .encoding = 0, .p = NULL}};
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    