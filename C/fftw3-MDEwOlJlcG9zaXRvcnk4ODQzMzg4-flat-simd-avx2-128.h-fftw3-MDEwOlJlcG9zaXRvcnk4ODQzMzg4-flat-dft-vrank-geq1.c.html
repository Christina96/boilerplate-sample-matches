
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.724409448818897%, Tokens: 9</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-simd-avx2-128.h</h3>
            <pre><code>1  #if defined(FFTW_LDOUBLE) || defined(FFTW_QUAD)
2  #error "AVX2 only works in single or double precision"
3  #endif
4  #ifdef FFTW_SINGLE
5  #  define DS(d,s) s &bsol;* single-precision option */
6  #  define SUFF(name) name ## s
7  #else
8  #  define DS(d,s) d &bsol;* double-precision option */
9  #  define SUFF(name) name ## d
10  #endif
11  #define SIMD_SUFFIX  _avx2_128  &bsol;* for renaming */
12  #define VL DS(1,2)         &bsol;* SIMD vector length, in term of complex numbers */
13  #define SIMD_VSTRIDE_OKA(x) DS(SIMD_STRIDE_OKA(x),((x) == 2))
14  #define SIMD_STRIDE_OKPAIR SIMD_STRIDE_OK
15  #if defined(__GNUC__) && !defined(__AVX2__) &bsol;* sanity check */
16  #error "compiling simd-avx2-128.h without avx2 support"
17  #endif
18  #ifdef _MSC_VER
19  #ifndef inline
20  #define inline __inline
21  #endif
22  #endif
23  #include <immintrin.h>
24  typedef DS(__m128d,__m128) V;
25  #define VADD SUFF(_mm_add_p)
26  #define VSUB SUFF(_mm_sub_p)
27  #define VMUL SUFF(_mm_mul_p)
28  #define VXOR SUFF(_mm_xor_p)
29  #define SHUF SUFF(_mm_shuffle_p)
30  #define VPERM1 SUFF(_mm_permute_p)
31  #define UNPCKL SUFF(_mm_unpacklo_p)
32  #define UNPCKH SUFF(_mm_unpackhi_p)
33  #define SHUFVALS(fp0,fp1,fp2,fp3) \
34     (((fp3) << 6) | ((fp2) << 4) | ((fp1) << 2) | ((fp0)))
35  #define VDUPL(x) DS(_mm_permute_pd(x,0), _mm_moveldup_ps(x))
36  #define VDUPH(x) DS(_mm_permute_pd(x,3), _mm_movehdup_ps(x))
37  #define LOADH(addr, val) _mm_loadh_pi(val, (const __m64 *)(addr))
38  #define LOADL(addr, val) _mm_loadl_pi(val, (const __m64 *)(addr))
39  #define STOREH(a, v) DS(_mm_storeh_pd(a, v), _mm_storeh_pi((__m64 *)(a), v))
40  #define STOREL(a, v) DS(_mm_storel_pd(a, v), _mm_storel_pi((__m64 *)(a), v))
41  #define VLIT(x0, x1) DS(_mm_set_pd(x0, x1), _mm_set_ps(x0, x1, x0, x1))
42  #define DVK(var, val) V var = VLIT(val, val)
43  #define LDK(x) x
44  static inline V LDA(const R *x, INT ivs, const R *aligned_like)
45  {
46       (void)aligned_like; &bsol;* UNUSED */
47       (void)ivs; &bsol;* UNUSED */
48       return *(const V *)x;
49  }
50  static inline void STA(R *x, V v, INT ovs, const R *aligned_like)
51  {
52       (void)aligned_like; &bsol;* UNUSED */
53       (void)ovs; &bsol;* UNUSED */
54       *(V *)x = v;
55  }
56  #ifdef FFTW_SINGLE
57  #  ifdef _MSC_VER
58  #    ifndef __INTEL_COMPILER
59  #      pragma warning(disable : 4700)
60  #      pragma runtime_checks("u", off)
61  #    endif
62  #  endif
63  #  ifdef __INTEL_COMPILER
64  #    pragma warning(disable : 592)
65  #  endif
66  static inline V LD(const R *x, INT ivs, const R *aligned_like)
67  {
68      __m128 l0, l1;
69      (void)aligned_like; &bsol;* UNUSED */
70  #if defined(__ICC) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ > 8)
71      l0 = LOADL(x, SUFF(_mm_undefined_p)());
72      l1 = LOADL(x + ivs, SUFF(_mm_undefined_p)());
73  #else
74      l0 = LOADL(x, l0);
75      l1 = LOADL(x + ivs, l1);
76  #endif
77      return SUFF(_mm_movelh_p)(l0,l1);
78  }
79  #  ifdef _MSC_VER
80  #    ifndef __INTEL_COMPILER
81  #      pragma warning(default : 4700)
82  #      pragma runtime_checks("u", restore)
83  #    endif
84  #  endif
85  #  ifdef __INTEL_COMPILER
86  #    pragma warning(default : 592)
87  #  endif
88  static inline void ST(R *x, V v, INT ovs, const R *aligned_like)
89  {
90       (void)aligned_like; &bsol;* UNUSED */
91       STOREH(x + ovs, v);
92       STOREL(x, v);
93  }
94  #else &bsol;* ! FFTW_SINGLE */
95  #  define LD LDA
96  #  define ST STA
97  #endif
98  #define STM2 DS(STA,ST)
99  #define STN2(x, v0, v1, ovs) &bsol;* nop */
100  #ifdef FFTW_SINGLE
101  #  define STM4(x, v, ovs, aligned_like) &bsol;* no-op */
102  #  define STN4(x, v0, v1, v2, v3, ovs)			\
103  {							\
104       V xxx0, xxx1, xxx2, xxx3;				\
105       xxx0 = UNPCKL(v0, v2);				\
106       xxx1 = UNPCKH(v0, v2);				\
107       xxx2 = UNPCKL(v1, v3);				\
108       xxx3 = UNPCKH(v1, v3);				\
109       STA(x, UNPCKL(xxx0, xxx2), 0, 0);			\
110       STA(x + ovs, UNPCKH(xxx0, xxx2), 0, 0);		\
111       STA(x + 2 * ovs, UNPCKL(xxx1, xxx3), 0, 0);	\
112       STA(x + 3 * ovs, UNPCKH(xxx1, xxx3), 0, 0);	\
113  }
114  #else &bsol;* !FFTW_SINGLE */
115  static inline void STM4(R *x, V v, INT ovs, const R *aligned_like)
116  {
117       (void)aligned_like; &bsol;* UNUSED */
118       STOREL(x, v);
119       STOREH(x + ovs, v);
120  }
121  #  define STN4(x, v0, v1, v2, v3, ovs) &bsol;* nothing */
122  #endif
123  static inline V FLIP_RI(V x)
124  {
125       return VPERM1(x, DS(1, SHUFVALS(1, 0, 3, 2)));
126  }
127  static inline V VCONJ(V x)
128  {
129       union uvec {
130            unsigned u[4];
131            V v;
132       };
133       static const union uvec pmpm = {
134  #ifdef FFTW_SINGLE
135            { 0x00000000, 0x80000000, 0x00000000, 0x80000000 }
136  #else
137            { 0x00000000, 0x00000000, 0x00000000, 0x80000000 }
138  #endif
139       };
140       return VXOR(pmpm.v, x);
141  }
142  static inline V VBYI(V x)
143  {
144       x = VCONJ(x);
145       x = FLIP_RI(x);
146       return x;
147  }
148  #define VFMA(a, b, c)  SUFF(_mm_fmadd_p)(a,b,c)
149  #define VFNMS(a, b, c) SUFF(_mm_fnmadd_p)(a,b,c)
150  #define VFMS(a, b, c)  SUFF(_mm_fmsub_p)(a,b,c)
151  #define VFMAI(b, c)    SUFF(_mm_addsub_p)(c,FLIP_RI(b))
152  #define VFNMSI(b, c)   VSUB(c, VBYI(b))
153  #define VFMACONJ(b,c)  VADD(VCONJ(b),c)
154  #define VFMSCONJ(b,c)  VSUB(VCONJ(b),c)
155  #define VFNMSCONJ(b,c) SUFF(_mm_addsub_p)(c,b)
156  static inline V VZMUL(V tx, V sr)
157  {
158      V tr = VDUPL(tx);
159      V ti = VDUPH(tx);
160      ti = VMUL(ti, FLIP_RI(sr));
161      return SUFF(_mm_fmaddsub_p)(tr,sr,ti);
162  }
163  static inline V VZMULJ(V tx, V sr)
164  {
165       V tr = VDUPL(tx);
166       V ti = VDUPH(tx);
167       ti = VMUL(ti, FLIP_RI(sr));
168       return SUFF(_mm_fmsubadd_p)(tr,sr,ti);
169  }
170  static inline V VZMULI(V tx, V sr)
171  {
172       V tr = VDUPL(tx);
173       V ti = VDUPH(tx);
174       ti = VMUL(ti, sr);
175       sr = VBYI(sr);
176       return VFMS(tr, sr, ti);
177  }
178  static inline V VZMULIJ(V tx, V sr)
179  {
180      V tr = VDUPL(tx);
181      V ti = VDUPH(tx);
182      tr = VMUL(tr, FLIP_RI(sr));
183      return SUFF(_mm_fmaddsub_p)(ti,sr,tr);
184  }
185  #ifdef FFTW_SINGLE
186  #  define VTW1(v,x)  \
187    {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_SIN, v, x}, {TW_SIN, v+1, x}
<span onclick='openModal()' class='match'>188  static inline V BYTW1(const R *t, V sr)
189  {
190      const V *twp = (const V *)t;
191      V tx = twp[0];
192      V tr = UNPCKL(tx, tx);
193      V ti = UNPCKH(tx, tx);
194      ti = VMUL(ti, FLIP_RI(sr));
</span>195      return SUFF(_mm_fmaddsub_p)(tr,sr,ti);
196  }
197  static inline V BYTWJ1(const R *t, V sr)
198  {
199      const V *twp = (const V *)t;
200      V tx = twp[0];
201      V tr = UNPCKL(tx, tx);
202      V ti = UNPCKH(tx, tx);
203      ti = VMUL(ti, FLIP_RI(sr));
204      return SUFF(_mm_fmsubadd_p)(tr,sr,ti);
205  }
206  #else &bsol;* !FFTW_SINGLE */
207  #  define VTW1(v,x) {TW_CEXP, v, x}
208  static inline V BYTW1(const R *t, V sr)
209  {
210       V tx = LD(t, 1, t);
211       return VZMUL(tx, sr);
212  }
213  static inline V BYTWJ1(const R *t, V sr)
214  {
215       V tx = LD(t, 1, t);
216       return VZMULJ(tx, sr);
217  }
218  #endif
219  #define TWVL1 (VL)
220  #ifdef FFTW_SINGLE
221  #  define VTW2(v,x)							\
222    {TW_COS, v, x}, {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+1, x},	\
223    {TW_SIN, v, -x}, {TW_SIN, v, x}, {TW_SIN, v+1, -x}, {TW_SIN, v+1, x}
224  #else &bsol;* !FFTW_SINGLE */
225  #  define VTW2(v,x)							\
226    {TW_COS, v, x}, {TW_COS, v, x}, {TW_SIN, v, -x}, {TW_SIN, v, x}
227  #endif
228  #define TWVL2 (2 * VL)
229  static inline V BYTW2(const R *t, V sr)
230  {
231       const V *twp = (const V *)t;
232       V si = FLIP_RI(sr);
233       V tr = twp[0], ti = twp[1];
234       return VFMA(tr, sr, VMUL(ti, si));
235  }
236  static inline V BYTWJ2(const R *t, V sr)
237  {
238       const V *twp = (const V *)t;
239       V si = FLIP_RI(sr);
240       V tr = twp[0], ti = twp[1];
241       return VFNMS(ti, si, VMUL(tr, sr));
242  }
243  #ifdef FFTW_SINGLE
244  #  define VTW3(v,x) {TW_CEXP, v, x}, {TW_CEXP, v+1, x}
245  #  define TWVL3 (VL)
246  #else
247  #  define VTW3(v,x) VTW1(v,x)
248  #  define TWVL3 TWVL1
249  #endif
250  #ifdef FFTW_SINGLE
251  #  define VTWS(v,x)							  \
252      {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+2, x}, {TW_COS, v+3, x}, \
253      {TW_SIN, v, x}, {TW_SIN, v+1, x}, {TW_SIN, v+2, x}, {TW_SIN, v+3, x}
254  #else
255  #  define VTWS(v,x)							  \
256      {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_SIN, v, x}, {TW_SIN, v+1, x}
257  #endif
258  #define TWVLS (2 * VL)
259  #define VLEAVE() &bsol;* nothing */
260  #include "simd-common.h"
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-vrank-geq1.c</h3>
            <pre><code>1  #include "threads/threads.h"
2  typedef struct {
3       solver super;
4       int vecloop_dim;
5       const int *buddies;
6       size_t nbuddies;
7  } S;
8  typedef struct {
9       plan_dft super;
10       plan **cldrn;
11       INT its, ots;
12       int nthr;
13       const S *solver;
14  } P;
15  typedef struct {
16       INT its, ots;
17       R *ri, *ii, *ro, *io;
18       plan **cldrn;
19  } PD;
20  static void *spawn_apply(spawn_data *d)
21  {
22       PD *ego = (PD *) d->data;
23       INT its = ego->its;
24       INT ots = ego->ots;
25       int thr_num = d->thr_num;
26       plan_dft *cld = (plan_dft *) ego->cldrn[thr_num];
27       cld->apply((plan *) cld,
28  		ego->ri + thr_num * its, ego->ii + thr_num * its,
29  		ego->ro + thr_num * ots, ego->io + thr_num * ots);
30       return 0;
31  }
<span onclick='openModal()' class='match'>32  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
33  {
34       const P *ego = (const P *) ego_;
35       PD d;
36       d.its = ego->its;
37       d.ots = ego->ots;
38       d.cldrn = ego->cldrn;
39       d.ri = ri; d.ii = ii; d.ro = ro; d.io = io;
</span>40       X(spawn_loop)(ego->nthr, ego->nthr, spawn_apply, (void*) &d);
41  }
42  static void awake(plan *ego_, enum wakefulness wakefulness)
43  {
44       P *ego = (P *) ego_;
45       int i;
46       for (i = 0; i < ego->nthr; ++i)
47  	  X(plan_awake)(ego->cldrn[i], wakefulness);
48  }
49  static void destroy(plan *ego_)
50  {
51       P *ego = (P *) ego_;
52       int i;
53       for (i = 0; i < ego->nthr; ++i)
54  	  X(plan_destroy_internal)(ego->cldrn[i]);
55       X(ifree)(ego->cldrn);
56  }
57  static void print(const plan *ego_, printer *p)
58  {
59       const P *ego = (const P *) ego_;
60       const S *s = ego->solver;
61       int i;
62       p->print(p, "(dft-thr-vrank>=1-x%d/%d", ego->nthr, s->vecloop_dim);
63       for (i = 0; i < ego->nthr; ++i)
64  	  if (i == 0 || (ego->cldrn[i] != ego->cldrn[i-1] &&
65  			 (i <= 1 || ego->cldrn[i] != ego->cldrn[i-2])))
66  	       p->print(p, "%(%p%)", ego->cldrn[i]);
67       p->putchr(p, ')');
68  }
69  static int pickdim(const S *ego, const tensor *vecsz, int oop, int *dp)
70  {
71       return X(pickdim)(ego->vecloop_dim, ego->buddies, ego->nbuddies,
72                         vecsz, oop, dp);
73  }
74  static int applicable0(const solver *ego_, const problem *p_,
75  		       const planner *plnr, int *dp)
76  {
77       const S *ego = (const S *) ego_;
78       const problem_dft *p = (const problem_dft *) p_;
79       return (1
80  	     && plnr->nthr > 1
81  	     && FINITE_RNK(p->vecsz->rnk)
82  	     && p->vecsz->rnk > 0
83  	     && pickdim(ego, p->vecsz, p->ri != p->ro, dp)
84  	  );
85  }
86  static int applicable(const solver *ego_, const problem *p_,
87  		      const planner *plnr, int *dp)
88  {
89       const S *ego = (const S *)ego_;
90       if (!applicable0(ego_, p_, plnr, dp)) return 0;
91       if (NO_VRANK_SPLITSP(plnr) && (ego->vecloop_dim != ego->buddies[0]))
92  	  return 0;
93       return 1;
94  }
95  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
96  {
97       const S *ego = (const S *) ego_;
98       const problem_dft *p;
99       P *pln;
100       problem *cldp;
101       int vdim;
102       iodim *d;
103       plan **cldrn = (plan **) 0;
104       int i, nthr;
105       INT its, ots, block_size;
106       tensor *vecsz = 0;
107       static const plan_adt padt = {
108  	  X(dft_solve), awake, print, destroy
109       };
110       if (!applicable(ego_, p_, plnr, &vdim))
111            return (plan *) 0;
112       p = (const problem_dft *) p_;
113       d = p->vecsz->dims + vdim;
114       block_size = (d->n + plnr->nthr - 1) / plnr->nthr;
115       nthr = (int)((d->n + block_size - 1) / block_size);
116       plnr->nthr = (plnr->nthr + nthr - 1) / nthr;
117       its = d->is * block_size;
118       ots = d->os * block_size;
119       cldrn = (plan **)MALLOC(sizeof(plan *) * nthr, PLANS);
120       for (i = 0; i < nthr; ++i) cldrn[i] = (plan *) 0;
121       vecsz = X(tensor_copy)(p->vecsz);
122       for (i = 0; i < nthr; ++i) {
123  	  vecsz->dims[vdim].n =
124  	       (i == nthr - 1) ? (d->n - i*block_size) : block_size;
125  	  cldp = X(mkproblem_dft)(p->sz, vecsz,
126  				  p->ri + i*its, p->ii + i*its, 
127  				  p->ro + i*ots, p->io + i*ots);
128  	  cldrn[i] = X(mkplan_d)(plnr, cldp);
129  	  if (!cldrn[i]) goto nada;
130       }
131       X(tensor_destroy)(vecsz);
132       pln = MKPLAN_DFT(P, &padt, apply);
133       pln->cldrn = cldrn;
134       pln->its = its;
135       pln->ots = ots;
136       pln->nthr = nthr;
137       pln->solver = ego;
138       X(ops_zero)(&pln->super.super.ops);
139       pln->super.super.pcost = 0;
140       for (i = 0; i < nthr; ++i) {
141  	  X(ops_add2)(&cldrn[i]->ops, &pln->super.super.ops);
142  	  pln->super.super.pcost += cldrn[i]->pcost;
143       }
144       return &(pln->super.super);
145   nada:
146       if (cldrn) {
147  	  for (i = 0; i < nthr; ++i)
148  	       X(plan_destroy_internal)(cldrn[i]);
149  	  X(ifree)(cldrn);
150       }
151       X(tensor_destroy)(vecsz);
152       return (plan *) 0;
153  }
154  static solver *mksolver(int vecloop_dim, const int *buddies, size_t nbuddies)
155  {
156       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
157       S *slv = MKSOLVER(S, &sadt);
158       slv->vecloop_dim = vecloop_dim;
159       slv->buddies = buddies;
160       slv->nbuddies = nbuddies;
161       return &(slv->super);
162  }
163  void X(dft_thr_vrank_geq1_register)(planner *p)
164  {
165       static const int buddies[] = { 1, -1 };
166       size_t i;
167       for (i = 0; i < NELEM(buddies); ++i)
168            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
169  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-simd-avx2-128.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-vrank-geq1.c</div>
                </div>
                <div class="column column_space"><pre><code>188  static inline V BYTW1(const R *t, V sr)
189  {
190      const V *twp = (const V *)t;
191      V tx = twp[0];
192      V tr = UNPCKL(tx, tx);
193      V ti = UNPCKH(tx, tx);
194      ti = VMUL(ti, FLIP_RI(sr));
</pre></code></div>
                <div class="column column_space"><pre><code>32  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
33  {
34       const P *ego = (const P *) ego_;
35       PD d;
36       d.its = ego->its;
37       d.ots = ego->ots;
38       d.cldrn = ego->cldrn;
39       d.ri = ri; d.ii = ii; d.ro = ro; d.io = io;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    