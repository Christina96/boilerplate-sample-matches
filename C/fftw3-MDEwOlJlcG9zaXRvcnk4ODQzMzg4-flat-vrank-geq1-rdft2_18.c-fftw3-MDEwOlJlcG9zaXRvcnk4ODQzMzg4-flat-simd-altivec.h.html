
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.364485981308411%, Tokens: 9</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-vrank-geq1-rdft2_18.c</h3>
            <pre><code>1  #include "threads/threads.h"
2  typedef struct {
3       solver super;
4       int vecloop_dim;
5       const int *buddies;
6       size_t nbuddies;
7  } S;
8  typedef struct {
9       plan_rdft2 super;
10       plan **cldrn;
11       INT its, ots;
12       int nthr;
13       const S *solver;
14  } P;
15  typedef struct {
16       INT its, ots;
17       R *r0, *r1, *cr, *ci;
18       plan **cldrn;
19  } PD;
20  static void *spawn_apply(spawn_data *d)
21  {
22       PD *ego = (PD *) d->data;
23       INT its = ego->its;
24       INT ots = ego->ots;
25       int thr_num = d->thr_num;
26       plan_rdft2 *cld = (plan_rdft2 *) ego->cldrn[d->thr_num];
27       cld->apply((plan *) cld,
28  		ego->r0 + thr_num * its, ego->r1 + thr_num * its,
29  		ego->cr + thr_num * ots, ego->ci + thr_num * ots);
30       return 0;
31  }
<span onclick='openModal()' class='match'>32  static void apply(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
33  {
34       const P *ego = (const P *) ego_;
35       PD d;
36       d.its = ego->its;
37       d.ots = ego->ots;
38       d.cldrn = ego->cldrn;
39       d.r0 = r0; d.r1 = r1; d.cr = cr; d.ci = ci;
</span>40       X(spawn_loop)(ego->nthr, ego->nthr, spawn_apply, (void*) &d);
41  }
42  static void awake(plan *ego_, enum wakefulness wakefulness)
43  {
44       P *ego = (P *) ego_;
45       int i;
46       for (i = 0; i < ego->nthr; ++i)
47  	  X(plan_awake)(ego->cldrn[i], wakefulness);
48  }
49  static void destroy(plan *ego_)
50  {
51       P *ego = (P *) ego_;
52       int i;
53       for (i = 0; i < ego->nthr; ++i)
54  	  X(plan_destroy_internal)(ego->cldrn[i]);
55       X(ifree)(ego->cldrn);
56  }
57  static void print(const plan *ego_, printer *p)
58  {
59       const P *ego = (const P *) ego_;
60       const S *s = ego->solver;
61       int i;
62       p->print(p, "(rdft2-thr-vrank>=1-x%d/%d)", ego->nthr, s->vecloop_dim);
63       for (i = 0; i < ego->nthr; ++i)
64  	  if (i == 0 || (ego->cldrn[i] != ego->cldrn[i-1] &&
65  			 (i <= 1 || ego->cldrn[i] != ego->cldrn[i-2])))
66  	       p->print(p, "%(%p%)", ego->cldrn[i]);
67       p->putchr(p, ')');
68  }
69  static int pickdim(const S *ego, const tensor *vecsz, int oop, int *dp)
70  {
71       return X(pickdim)(ego->vecloop_dim, ego->buddies, ego->nbuddies,
72  		       vecsz, oop, dp);
73  }
74  static int applicable0(const solver *ego_, const problem *p_,
75  		       const planner *plnr, int *dp)
76  {
77       const S *ego = (const S *) ego_;
78       const problem_rdft2 *p = (const problem_rdft2 *) p_;
79       if (FINITE_RNK(p->vecsz->rnk)
80  	 && p->vecsz->rnk > 0
81  	 && plnr->nthr > 1
82  	 && pickdim(ego, p->vecsz, p->r0 != p->cr, dp)) {
83  	  if (p->r0 != p->cr)
84  	       return 1;  &bsol;* can always operate out-of-place */
85  	  return(X(rdft2_inplace_strides)(p, *dp));
86       }
87       return 0;
88  }
89  static int applicable(const solver *ego_, const problem *p_,
90  		      const planner *plnr, int *dp)
91  {
92       const S *ego = (const S *)ego_;
93       if (!applicable0(ego_, p_, plnr, dp)) return 0;
94       if (NO_VRANK_SPLITSP(plnr) && (ego->vecloop_dim != ego->buddies[0]))
95  	  return 0;
96       return 1;
97  }
98  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
99  {
100       const S *ego = (const S *) ego_;
101       const problem_rdft2 *p;
102       P *pln;
103       problem *cldp;
104       int vdim;
105       iodim *d;
106       plan **cldrn = (plan **) 0;
107       int i, nthr;
108       INT its, ots, block_size;
109       tensor *vecsz;
110       static const plan_adt padt = {
111  	  X(rdft2_solve), awake, print, destroy
112       };
113       if (!applicable(ego_, p_, plnr, &vdim))
114            return (plan *) 0;
115       p = (const problem_rdft2 *) p_;
116       d = p->vecsz->dims + vdim;
117       block_size = (d->n + plnr->nthr - 1) / plnr->nthr;
118       nthr = (int)((d->n + block_size - 1) / block_size);
119       plnr->nthr = (plnr->nthr + nthr - 1) / nthr;
120       X(rdft2_strides)(p->kind, d, &its, &ots);
121       its *= block_size; ots *= block_size;
122       cldrn = (plan **)MALLOC(sizeof(plan *) * nthr, PLANS);
123       for (i = 0; i < nthr; ++i) cldrn[i] = (plan *) 0;
124       vecsz = X(tensor_copy)(p->vecsz);
125       for (i = 0; i < nthr; ++i) {
126  	  vecsz->dims[vdim].n =
127  	       (i == nthr - 1) ? (d->n - i*block_size) : block_size;
128  	  cldp = X(mkproblem_rdft2)(p->sz, vecsz,
129  				    p->r0 + i*its, p->r1 + i*its,
130  				    p->cr + i*ots, p->ci + i*ots, 
131  				    p->kind);
132  	  cldrn[i] = X(mkplan_d)(plnr, cldp);
133  	  if (!cldrn[i]) goto nada;
134       }
135       X(tensor_destroy)(vecsz);
136       pln = MKPLAN_RDFT2(P, &padt, apply);
137       pln->cldrn = cldrn;
138       pln->its = its;
139       pln->ots = ots;
140       pln->nthr = nthr;
141       pln->solver = ego;
142       X(ops_zero)(&pln->super.super.ops);
143       pln->super.super.pcost = 0;
144       for (i = 0; i < nthr; ++i) {
145  	  X(ops_add2)(&cldrn[i]->ops, &pln->super.super.ops);
146  	  pln->super.super.pcost += cldrn[i]->pcost;
147       }
148       return &(pln->super.super);
149   nada:
150       if (cldrn) {
151  	  for (i = 0; i < nthr; ++i)
152  	       X(plan_destroy_internal)(cldrn[i]);
153  	  X(ifree)(cldrn);
154       }
155       X(tensor_destroy)(vecsz);
156       return (plan *) 0;
157  }
158  static solver *mksolver(int vecloop_dim, const int *buddies, size_t nbuddies)
159  {
160       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
161       S *slv = MKSOLVER(S, &sadt);
162       slv->vecloop_dim = vecloop_dim;
163       slv->buddies = buddies;
164       slv->nbuddies = nbuddies;
165       return &(slv->super);
166  }
167  void X(rdft2_thr_vrank_geq1_register)(planner *p)
168  {
169       static const int buddies[] = { 1, -1 };
170       size_t i;
171       for (i = 0; i < NELEM(buddies); ++i)
172            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
173  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-simd-altivec.h</h3>
            <pre><code>1  #ifndef FFTW_SINGLE
2  #error "ALTIVEC only works in single precision"
3  #endif
4  #define SIMD_SUFFIX _altivec  &bsol;* for renaming */
5  #define VL 2            &bsol;* SIMD complex vector length */
6  #define SIMD_VSTRIDE_OKA(x) ((x) == 2)
7  #define SIMD_STRIDE_OKPAIR SIMD_STRIDE_OKA
8  #if !defined(__VEC__) && !defined(FAKE__VEC__)
9  #  error "compiling simd-altivec.h requires -maltivec or equivalent"
10  #endif
11  #ifdef HAVE_ALTIVEC_H
12  #  include <altivec.h>
13  #endif
14  typedef vector float V;
15  #define VLIT(x0, x1, x2, x3) {x0, x1, x2, x3}
16  #define LDK(x) x
17  #define DVK(var, val) const V var = VLIT(val, val, val, val)
18  static inline V VADD(V a, V b) { return vec_add(a, b); }
19  static inline V VSUB(V a, V b) { return vec_sub(a, b); }
20  static inline V VFMA(V a, V b, V c) { return vec_madd(a, b, c); }
21  static inline V VFNMS(V a, V b, V c) { return vec_nmsub(a, b, c); }
22  static inline V VMUL(V a, V b)
23  {
24       DVK(zero, -0.0);
25       return VFMA(a, b, zero);
26  }
27  static inline V VFMS(V a, V b, V c) { return VSUB(VMUL(a, b), c); }
28  static inline V LDA(const R *x, INT ivs, const R *aligned_like) 
29  {
30       UNUSED(ivs);
31       UNUSED(aligned_like);
32       return vec_ld(0, x);
33  }
34  static inline V LD(const R *x, INT ivs, const R *aligned_like) 
35  {
36       const INT fivs = sizeof(R) * ivs;
37       const vector unsigned int perm = VLIT(0, 0, 0xFFFFFFFF, 0xFFFFFFFF);
38       vector unsigned char ml = vec_lvsr(fivs + 8, aligned_like);
39       vector unsigned char mh = vec_lvsl(0, aligned_like);
40       vector unsigned char msk = 
41  	  (vector unsigned char)vec_sel((V)mh, (V)ml, perm);
42       return vec_perm(vec_ld(0, x), vec_ld(fivs, x), msk);
43  }
44  static inline void STH(R *x, V v, R *aligned_like)
45  {
46       v = vec_perm(v, v, vec_lvsr(0, aligned_like));
47       vec_ste(v, 0, x);
48       vec_ste(v, sizeof(R), x);
49  }
50  static inline void STL(R *x, V v, INT ovs, R *aligned_like)
51  {
52       const INT fovs = sizeof(R) * ovs;
53       v = vec_perm(v, v, vec_lvsr(fovs + 8, aligned_like));
54       vec_ste(v, fovs, x);
55       vec_ste(v, sizeof(R) + fovs, x);
56  }
57  static inline void STA(R *x, V v, INT ovs, R *aligned_like) 
58  {
59       UNUSED(ovs);
60       UNUSED(aligned_like);
61       vec_st(v, 0, x);
62  }
63  static inline void ST(R *x, V v, INT ovs, R *aligned_like) 
64  {
65       STL(x, v, ovs, aligned_like);
66       STH(x, v, aligned_like);
67  }
68  #define STM2(x, v, ovs, aligned_like) &bsol;* no-op */
69  static inline void STN2(R *x, V v0, V v1, INT ovs)
70  {
71       const INT fovs = sizeof(R) * ovs;
72       const vector unsigned int even = 
73  	  VLIT(0x00010203, 0x04050607, 0x10111213, 0x14151617);
74       const vector unsigned int odd = 
75  	  VLIT(0x08090a0b, 0x0c0d0e0f, 0x18191a1b, 0x1c1d1e1f);
76       vec_st(vec_perm(v0, v1, (vector unsigned char)even), 0, x);
77       vec_st(vec_perm(v0, v1, (vector unsigned char)odd), fovs, x);
78  }
79  #define STM4(x, v, ovs, aligned_like) &bsol;* no-op */
80  static inline void STN4(R *x, V v0, V v1, V v2, V v3, INT ovs)
81  {
82       const INT fovs = sizeof(R) * ovs;
83       V x0 = vec_mergeh(v0, v2);
84       V x1 = vec_mergel(v0, v2);
85       V x2 = vec_mergeh(v1, v3);
86       V x3 = vec_mergel(v1, v3);
87       V y0 = vec_mergeh(x0, x2);
88       V y1 = vec_mergel(x0, x2);
89       V y2 = vec_mergeh(x1, x3);
90       V y3 = vec_mergel(x1, x3);
91       vec_st(y0, 0, x);
92       vec_st(y1, fovs, x);
93       vec_st(y2, 2 * fovs, x);
94       vec_st(y3, 3 * fovs, x);
95  }
96  static inline V FLIP_RI(V x)
97  {
98       const vector unsigned int perm = 
99  	  VLIT(0x04050607, 0x00010203, 0x0c0d0e0f, 0x08090a0b);
100       return vec_perm(x, x, (vector unsigned char)perm);
101  }
102  static inline V VCONJ(V x)
103  {
104       const V pmpm = VLIT(0.0, -0.0, 0.0, -0.0);
105       return vec_xor(x, pmpm);
106  }
107  static inline V VBYI(V x)
108  {
109       return FLIP_RI(VCONJ(x));
110  }
111  static inline V VFMAI(V b, V c)
112  {
113       const V mpmp = VLIT(-1.0, 1.0, -1.0, 1.0);
114       return VFMA(FLIP_RI(b), mpmp, c);
115  }
116  static inline V VFNMSI(V b, V c)
117  {
118       const V mpmp = VLIT(-1.0, 1.0, -1.0, 1.0);
119       return VFNMS(FLIP_RI(b), mpmp, c);
120  }
121  static inline V VFMACONJ(V b, V c)
122  {
123       const V pmpm = VLIT(1.0, -1.0, 1.0, -1.0);
124       return VFMA(b, pmpm, c);
125  }
126  static inline V VFNMSCONJ(V b, V c)
127  {
128       const V pmpm = VLIT(1.0, -1.0, 1.0, -1.0);
129       return VFNMS(b, pmpm, c);
130  }
131  static inline V VFMSCONJ(V b, V c)
132  {
133       return VSUB(VCONJ(b), c);
134  }
135  static inline V VZMUL(V tx, V sr)
136  {
137       const vector unsigned int real = 
138  	  VLIT(0x00010203, 0x00010203, 0x08090a0b, 0x08090a0b);
139       const vector unsigned int imag = 
140  	  VLIT(0x04050607, 0x04050607, 0x0c0d0e0f, 0x0c0d0e0f);
141       V si = VBYI(sr);
142       V tr = vec_perm(tx, tx, (vector unsigned char)real);
143       V ti = vec_perm(tx, tx, (vector unsigned char)imag);
144       return VFMA(ti, si, VMUL(tr, sr));
145  }
146  static inline V VZMULJ(V tx, V sr)
147  {
148       const vector unsigned int real = 
149  	  VLIT(0x00010203, 0x00010203, 0x08090a0b, 0x08090a0b);
150       const vector unsigned int imag = 
151  	  VLIT(0x04050607, 0x04050607, 0x0c0d0e0f, 0x0c0d0e0f);
152       V si = VBYI(sr);
153       V tr = vec_perm(tx, tx, (vector unsigned char)real);
154       V ti = vec_perm(tx, tx, (vector unsigned char)imag);
155       return VFNMS(ti, si, VMUL(tr, sr));
156  }
157  static inline V VZMULI(V tx, V si)
158  {
159       const vector unsigned int real = 
160  	  VLIT(0x00010203, 0x00010203, 0x08090a0b, 0x08090a0b);
161       const vector unsigned int imag = 
162  	  VLIT(0x04050607, 0x04050607, 0x0c0d0e0f, 0x0c0d0e0f);
163       V sr = VBYI(si);
164       V tr = vec_perm(tx, tx, (vector unsigned char)real);
165       V ti = vec_perm(tx, tx, (vector unsigned char)imag);
166       return VFNMS(ti, si, VMUL(tr, sr));
167  }
168  static inline V VZMULIJ(V tx, V si)
169  {
170       const vector unsigned int real = 
171  	  VLIT(0x00010203, 0x00010203, 0x08090a0b, 0x08090a0b);
172       const vector unsigned int imag = 
173  	  VLIT(0x04050607, 0x04050607, 0x0c0d0e0f, 0x0c0d0e0f);
174       V sr = VBYI(si);
175       V tr = vec_perm(tx, tx, (vector unsigned char)real);
176       V ti = vec_perm(tx, tx, (vector unsigned char)imag);
177       return VFMA(ti, si, VMUL(tr, sr));
178  }
179  #define VTW1(v,x) \
180   {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_SIN, v, x}, {TW_SIN, v+1, x}
181  #define TWVL1 (VL)
<span onclick='openModal()' class='match'>182  static inline V BYTW1(const R *t, V sr)
183  {
184       const V *twp = (const V *)t;
185       V si = VBYI(sr);
186       V tx = twp[0];
187       V tr = vec_mergeh(tx, tx);
188       V ti = vec_mergel(tx, tx);
</span>189       return VFMA(ti, si, VMUL(tr, sr));
190  }
191  static inline V BYTWJ1(const R *t, V sr)
192  {
193       const V *twp = (const V *)t;
194       V si = VBYI(sr);
195       V tx = twp[0];
196       V tr = vec_mergeh(tx, tx);
197       V ti = vec_mergel(tx, tx);
198       return VFNMS(ti, si, VMUL(tr, sr));
199  }
200  #define VTW2(v,x)							\
201    {TW_COS, v, x}, {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+1, x},	\
202    {TW_SIN, v, -x}, {TW_SIN, v, x}, {TW_SIN, v+1, -x}, {TW_SIN, v+1, x}
203  #define TWVL2 (2 * VL)
204  static inline V BYTW2(const R *t, V sr)
205  {
206       const V *twp = (const V *)t;
207       V si = FLIP_RI(sr);
208       V tr = twp[0], ti = twp[1];
209       return VFMA(ti, si, VMUL(tr, sr));
210  }
211  static inline V BYTWJ2(const R *t, V sr)
212  {
213       const V *twp = (const V *)t;
214       V si = FLIP_RI(sr);
215       V tr = twp[0], ti = twp[1];
216       return VFNMS(ti, si, VMUL(tr, sr));
217  }
218  #define VTW3(v,x) {TW_CEXP, v, x}, {TW_CEXP, v+1, x}
219  #define TWVL3 (VL)
220  #define VTWS(v,x)							\
221    {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+2, x}, {TW_COS, v+3, x},	\
222    {TW_SIN, v, x}, {TW_SIN, v+1, x}, {TW_SIN, v+2, x}, {TW_SIN, v+3, x}
223  #define TWVLS (2 * VL)
224  #define VLEAVE() &bsol;* nothing */
225  #include "simd-common.h"
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-vrank-geq1-rdft2_18.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-simd-altivec.h</div>
                </div>
                <div class="column column_space"><pre><code>32  static void apply(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
33  {
34       const P *ego = (const P *) ego_;
35       PD d;
36       d.its = ego->its;
37       d.ots = ego->ots;
38       d.cldrn = ego->cldrn;
39       d.r0 = r0; d.r1 = r1; d.cr = cr; d.ci = ci;
</pre></code></div>
                <div class="column column_space"><pre><code>182  static inline V BYTW1(const R *t, V sr)
183  {
184       const V *twp = (const V *)t;
185       V si = VBYI(sr);
186       V tx = twp[0];
187       V tr = vec_mergeh(tx, tx);
188       V ti = vec_mergel(tx, tx);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    