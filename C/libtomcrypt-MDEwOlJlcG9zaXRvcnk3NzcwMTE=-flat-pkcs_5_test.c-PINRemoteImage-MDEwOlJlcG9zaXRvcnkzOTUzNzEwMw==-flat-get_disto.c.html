
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.643312101910828%, Tokens: 8</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pkcs_5_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_PKCS_5
3  int pkcs_5_test (void)
4  {
5   #ifndef LTC_TEST
6      return CRYPT_NOP;
7   #else
8      typedef struct {
9          const char* P;
10          unsigned long P_len;
11          const char* S;
12          unsigned long S_len;
13          int c;
14          unsigned long dkLen;
15          unsigned char DK[40];
16      } case_item;
17      static const case_item cases_5_2[] = {
18          {
19              "password",
20              8,
21              "salt",
22              4,
23              1,
24              20,
25              { 0x0c, 0x60, 0xc8, 0x0f, 0x96, 0x1f, 0x0e, 0x71,
26                0xf3, 0xa9, 0xb5, 0x24, 0xaf, 0x60, 0x12, 0x06,
27                0x2f, 0xe0, 0x37, 0xa6 }
28          },
29          {
30              "password",
31              8,
32              "salt",
33              4,
34              2,
35              20,
36              { 0xea, 0x6c, 0x01, 0x4d, 0xc7, 0x2d, 0x6f, 0x8c,
37                0xcd, 0x1e, 0xd9, 0x2a, 0xce, 0x1d, 0x41, 0xf0,
38                0xd8, 0xde, 0x89, 0x57 }
39          },
40  #ifdef LTC_TEST_EXT
41          {
42              "password",
43              8,
44              "salt",
45              4,
46              4096,
47              20,
48              { 0x4b, 0x00, 0x79, 0x01, 0xb7, 0x65, 0x48, 0x9a,
49                0xbe, 0xad, 0x49, 0xd9, 0x26, 0xf7, 0x21, 0xd0,
50                0x65, 0xa4, 0x29, 0xc1 }
51          },
52          {
53              "password",
54              8,
55              "salt",
56              4,
57              16777216,
58              20,
59              { 0xee, 0xfe, 0x3d, 0x61, 0xcd, 0x4d, 0xa4, 0xe4,
60                0xe9, 0x94, 0x5b, 0x3d, 0x6b, 0xa2, 0x15, 0x8c,
61                0x26, 0x34, 0xe9, 0x84 }
62          },
63          {
64              "passwordPASSWORDpassword",
65              25,
66              "saltSALTsaltSALTsaltSALTsaltSALTsalt",
67              36,
68              4096,
69              25,
70              { 0x3d, 0x2e, 0xec, 0x4f, 0xe4, 0x1c, 0x84, 0x9b,
71                0x80, 0xc8, 0xd8, 0x36, 0x62, 0xc0, 0xe4, 0x4a,
72                0x8b, 0x29, 0x1a, 0x96, 0x4c, 0xf2, 0xf0, 0x70,
73                0x38 }
74          },
75          {
76              "pass\0word",
77              9,
78              "sa\0lt",
79              5,
80              4096,
81              16,
82              { 0x56, 0xfa, 0x6a, 0xa7, 0x55, 0x48, 0x09, 0x9d,
83                0xcc, 0x37, 0xd7, 0xf0, 0x34, 0x25, 0xe0, 0xc3 }
84          },
85  #endif &bsol;* LTC_TEST_EXT */
86      };
87      static const case_item cases_5_1[] = {
88          {
89              "password",
90              8,
91              "saltsalt", &bsol;* must be 8 octects */
92              8,          &bsol;* ignored by alg1 */
93              1,
94              20,
95              { 0xca, 0xb8, 0x6d, 0xd6, 0x26, 0x17, 0x10, 0x89, 0x1e, 0x8c,
96                0xb5, 0x6e, 0xe3, 0x62, 0x56, 0x91, 0xa7, 0x5d, 0xf3, 0x44 }
97          },
98      };
99      static const case_item cases_5_1o[] = {
100          {
101              "password",
102              8,
103              "saltsalt", &bsol;* must be 8 octects */
104              8,          &bsol;* ignored by alg1_openssl */
105              1,
106              20,
107              { 0xca, 0xb8, 0x6d, 0xd6, 0x26, 0x17, 0x10, 0x89, 0x1e, 0x8c,
108                0xb5, 0x6e, 0xe3, 0x62, 0x56, 0x91, 0xa7, 0x5d, 0xf3, 0x44 }
109          },
110          {
111              "password",
112              8,
113              "saltsalt", &bsol;* must be 8 octects */
114              8,          &bsol;* ignored by alg1_openssl */
115              1,
116              30,
117              { 0xca, 0xb8, 0x6d, 0xd6, 0x26, 0x17, 0x10, 0x89, 0x1e, 0x8c,
118                0xb5, 0x6e, 0xe3, 0x62, 0x56, 0x91, 0xa7, 0x5d, 0xf3, 0x44,
119                0xf0, 0xbf, 0xf4, 0xc1, 0x2c, 0xf3, 0x59, 0x6f, 0xc0, 0x0b }
120          }
121      };
122      unsigned char DK[40];
123      unsigned long dkLen;
124      int i, err;
125      int tested=0, failed=0;
126      int hash = find_hash("sha1");
127      if (hash == -1)
128      {
129  #ifdef LTC_TEST_DBG
130        printf("PKCS#5 test failed: 'sha1' hash not found\n");
131  #endif
132        return CRYPT_ERROR;
133      }
134      for(i=0; i < (int)(sizeof(cases_5_2) / sizeof(cases_5_2[0])); i++) {
135          ++tested;
136          dkLen = cases_5_2[i].dkLen;
137          if((err = pkcs_5_alg2((unsigned char*)cases_5_2[i].P, cases_5_2[i].P_len,
138                                (unsigned char*)cases_5_2[i].S, cases_5_2[i].S_len,
139                                cases_5_2[i].c, hash,
<span onclick='openModal()' class='match'>140                                DK, &dkLen)) != CRYPT_OK) {
141  #ifdef LTC_TEST_DBG
142              printf("\npkcs_5_alg2() #%d: Failed/1 (%s)\n", i, error_to_string(err));
143  #endif
144              ++failed;
145          }
146          else if (compare_testvector(DK, dkLen, cases_5_2[i].DK, cases_5_2[i].dkLen, "PKCS#5_2", i)) {
147              ++failed;
148          }
</span>149      }
150      for(i=0; i < (int)(sizeof(cases_5_1) / sizeof(case_item)); i++, tested++) {
151          dkLen = cases_5_1[i].dkLen;
152          if((err = pkcs_5_alg1((unsigned char*)cases_5_1[i].P, cases_5_1[i].P_len,
153                                (unsigned char*)cases_5_1[i].S,
154                                cases_5_1[i].c, hash,
155                                DK, &dkLen)) != CRYPT_OK) {
156  #ifdef LTC_TEST_DBG
157              printf("\npkcs_5_alg1() #%d: Failed/1 (%s)\n", i, error_to_string(err));
158  #endif
159              ++failed;
160          }
161          else if (compare_testvector(DK, dkLen, cases_5_1[i].DK, cases_5_1[i].dkLen, "PKCS#5_1", i)) {
162              ++failed;
163          }
164      }
165      for(i = 0; i < (int)(sizeof(cases_5_1o) / sizeof(cases_5_1o[0])); i++, tested++) {
166          dkLen = cases_5_1o[i].dkLen;
167          if ((err = pkcs_5_alg1_openssl((unsigned char*)cases_5_1o[i].P, cases_5_1o[i].P_len,
168                                         (unsigned char*)cases_5_1o[i].S,
169                                         cases_5_1o[i].c, hash,
170                                         DK, &dkLen)) != CRYPT_OK) {
171  #ifdef LTC_TEST_DBG
172              printf("\npkcs_5_alg1_openssl() #%d: Failed/1 (%s)\n", i, error_to_string(err));
173  #endif
174              ++failed;
175          }
176          else if (compare_testvector(DK, dkLen, cases_5_1o[i].DK, cases_5_1o[i].dkLen, "PKCS#5_1o", i)) {
177              ++failed;
178          }
179      }
180      return (failed != 0) ? CRYPT_FAIL_TESTVECTOR : CRYPT_OK;
181   #endif
182  }
183  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-get_disto.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #include "webp/encode.h"
6  #include "imageio/image_dec.h"
7  #include "imageio/imageio_util.h"
8  #include "../examples/unicode.h"
9  static size_t ReadPicture(const char* const filename, WebPPicture* const pic,
10                            int keep_alpha) {
11    const uint8_t* data = NULL;
12    size_t data_size = 0;
13    WebPImageReader reader = NULL;
14    int ok = ImgIoUtilReadFile(filename, &data, &data_size);
15    if (!ok) goto End;
16    pic->use_argb = 1;  
17  #ifdef HAVE_WINCODEC_H
18    ok = ReadPictureWithWIC(filename, pic, keep_alpha, NULL);
19    if (ok) goto End;
20  #endif
21    reader = WebPGuessImageReader(data, data_size);
22    ok = reader(data, data_size, pic, keep_alpha, NULL);
23   End:
24    if (!ok) {
25      WFPRINTF(stderr, "Error! Could not process file %s\n",
26               (const W_CHAR*)filename);
27    }
28    free((void*)data);
29    return ok ? data_size : 0;
30  }
31  static void RescalePlane(uint8_t* plane, int width, int height,
32                           int x_stride, int y_stride, int max) {
33    const uint32_t factor = (max > 0) ? (255u << 16) / max : 0;
34    int x, y;
35    for (y = 0; y < height; ++y) {
36      uint8_t* const ptr = plane + y * y_stride;
37      for (x = 0; x < width * x_stride; x += x_stride) {
38        const uint32_t diff = (ptr[x] * factor + (1 << 15)) >> 16;
39        ptr[x] = diff;
40      }
41    }
42  }
43  static int DiffScaleChannel(uint8_t* src1, int stride1,
44                              const uint8_t* src2, int stride2,
45                              int x_stride, int w, int h, int do_scaling) {
46    int x, y;
47    int max = 0;
48    for (y = 0; y < h; ++y) {
49      uint8_t* const ptr1 = src1 + y * stride1;
50      const uint8_t* const ptr2 = src2 + y * stride2;
51      for (x = 0; x < w * x_stride; x += x_stride) {
52        const int diff = abs(ptr1[x] - ptr2[x]);
53        if (diff > max) max = diff;
54        ptr1[x] = diff;
55      }
56    }
57    if (do_scaling) RescalePlane(src1, w, h, x_stride, stride1, max);
58    return max;
59  }
60  #define SSIM_KERNEL 3   
61  typedef struct {
62    uint32_t w;              
63    uint32_t xm, ym;         
64    uint32_t xxm, xym, yym;  
65  } DistoStats;
66  static const uint32_t kWeight[2 * SSIM_KERNEL + 1] = { 1, 2, 3, 4, 3, 2, 1 };
67  static WEBP_INLINE double SSIMCalculation(const DistoStats* const stats) {
68    const uint32_t N = stats->w;
69    const uint32_t w2 =  N * N;
70    const uint32_t C1 = 20 * w2;
71    const uint32_t C2 = 60 * w2;
72    const uint32_t C3 = 8 * 8 * w2;   
73    const uint64_t xmxm = (uint64_t)stats->xm * stats->xm;
74    const uint64_t ymym = (uint64_t)stats->ym * stats->ym;
75    if (xmxm + ymym >= C3) {
76      const int64_t xmym = (int64_t)stats->xm * stats->ym;
77      const int64_t sxy = (int64_t)stats->xym * N - xmym;    
78      const uint64_t sxx = (uint64_t)stats->xxm * N - xmxm;
79      const uint64_t syy = (uint64_t)stats->yym * N - ymym;
80      const uint64_t num_S = (2 * (uint64_t)(sxy < 0 ? 0 : sxy) + C2) >> 8;
81      const uint64_t den_S = (sxx + syy + C2) >> 8;
82      const uint64_t fnum = (2 * xmym + C1) * num_S;
83      const uint64_t fden = (xmxm + ymym + C1) * den_S;
84      const double r = (double)fnum / fden;
85      assert(r >= 0. && r <= 1.0);
86      return r;
87    }
88    return 1.;   
89  }
90  static double SSIMGetClipped(const uint8_t* src1, int stride1,
91                               const uint8_t* src2, int stride2,
92                               int xo, int yo, int W, int H) {
93    DistoStats stats = { 0, 0, 0, 0, 0, 0 };
94    const int ymin = (yo - SSIM_KERNEL < 0) ? 0 : yo - SSIM_KERNEL;
95    const int ymax = (yo + SSIM_KERNEL > H - 1) ? H - 1 : yo + SSIM_KERNEL;
96    const int xmin = (xo - SSIM_KERNEL < 0) ? 0 : xo - SSIM_KERNEL;
97    const int xmax = (xo + SSIM_KERNEL > W - 1) ? W - 1 : xo + SSIM_KERNEL;
98    int x, y;
99    src1 += ymin * stride1;
100    src2 += ymin * stride2;
101    for (y = ymin; y <= ymax; ++y, src1 += stride1, src2 += stride2) {
102      for (x = xmin; x <= xmax; ++x) {
103        const uint32_t w = kWeight[SSIM_KERNEL + x - xo]
104                         * kWeight[SSIM_KERNEL + y - yo];
105        const uint32_t s1 = src1[x];
106        const uint32_t s2 = src2[x];
107        stats.w   += w;
108        stats.xm  += w * s1;
109        stats.ym  += w * s2;
110        stats.xxm += w * s1 * s1;
111        stats.xym += w * s1 * s2;
112        stats.yym += w * s2 * s2;
113      }
114    }
115    return SSIMCalculation(&stats);
116  }
117  static int SSIMScaleChannel(uint8_t* src1, int stride1,
118                              const uint8_t* src2, int stride2,
119                              int x_stride, int w, int h, int do_scaling) {
120    int x, y;
121    int max = 0;
122    uint8_t* const plane1 = (uint8_t*)malloc(2 * w * h * sizeof(*plane1));
123    uint8_t* const plane2 = plane1 + w * h;
124    if (plane1 == NULL) return -1;
125    for (y = 0; y < h; ++y) {
126      for (x = 0; x < w; ++x) {
127        plane1[x + y * w] = src1[x * x_stride + y * stride1];
128        plane2[x + y * w] = src2[x * x_stride + y * stride2];
129      }
130    }
131    for (y = 0; y < h; ++y) {
132      for (x = 0; x < w; ++x) {
133        const double ssim = SSIMGetClipped(plane1, w, plane2, w, x, y, w, h);
134        int diff = (int)(255 * (1. - ssim));
<span onclick='openModal()' class='match'>135        if (diff < 0) {
136          diff = 0;
137        } else if (diff > max) {
138          max = diff;
139        }
</span>140        src1[x * x_stride + y * stride1] = (diff > 255) ? 255u : (uint8_t)diff;
141      }
142    }
143    free(plane1);
144    if (do_scaling) RescalePlane(src1, w, h, x_stride, stride1, max);
145    return max;
146  }
147  static void ConvertToGray(WebPPicture* const pic) {
148    int x, y;
149    assert(pic != NULL);
150    assert(pic->use_argb);
151    for (y = 0; y < pic->height; ++y) {
152      uint32_t* const row = &pic->argb[y * pic->argb_stride];
153      for (x = 0; x < pic->width; ++x) {
154        const uint32_t argb = row[x];
155        const uint32_t r = (argb >> 16) & 0xff;
156        const uint32_t g = (argb >>  8) & 0xff;
157        const uint32_t b = (argb >>  0) & 0xff;
158        const uint32_t Y = (uint32_t)(0.2126 * r + 0.7152 * g + 0.0722 * b + .5);
159        row[x] = (argb & 0xff000000u) | (Y * 0x010101u);
160      }
161    }
162  }
163  static void Help(void) {
164    fprintf(stderr,
165            "Usage: get_disto [-ssim][-psnr][-alpha] compressed.webp orig.webp\n"
166            "  -ssim ..... print SSIM distortion\n"
167            "  -psnr ..... print PSNR distortion (default)\n"
168            "  -alpha .... preserve alpha plane\n"
169            "  -h ........ this message\n"
170            "  -o <file> . save the diff map as a WebP lossless file\n"
171            "  -scale .... scale the difference map to fit [0..255] range\n"
172            "  -gray ..... use grayscale for difference map (-scale)\n"
173            " Also handles PNG, JPG and TIFF files, in addition to WebP.\n");
174  }
175  int main(int argc, const char* argv[]) {
176    WebPPicture pic1, pic2;
177    size_t size1 = 0, size2 = 0;
178    int ret = 1;
179    float disto[5];
180    int type = 0;
181    int c;
182    int help = 0;
183    int keep_alpha = 0;
184    int scale = 0;
185    int use_gray = 0;
186    const char* name1 = NULL;
187    const char* name2 = NULL;
188    const char* output = NULL;
189    INIT_WARGV(argc, argv);
190    if (!WebPPictureInit(&pic1) || !WebPPictureInit(&pic2)) {
191      fprintf(stderr, "Can't init pictures\n");
192      FREE_WARGV_AND_RETURN(1);
193    }
194    for (c = 1; c < argc; ++c) {
195      if (!strcmp(argv[c], "-ssim")) {
196        type = 1;
197      } else if (!strcmp(argv[c], "-psnr")) {
198        type = 0;
199      } else if (!strcmp(argv[c], "-alpha")) {
200        keep_alpha = 1;
201      } else if (!strcmp(argv[c], "-scale")) {
202        scale = 1;
203      } else if (!strcmp(argv[c], "-gray")) {
204        use_gray = 1;
205      } else if (!strcmp(argv[c], "-h")) {
206        help = 1;
207        ret = 0;
208      } else if (!strcmp(argv[c], "-o")) {
209        if (++c == argc) {
210          fprintf(stderr, "missing file name after %s option.\n", argv[c - 1]);
211          goto End;
212        }
213        output = (const char*)GET_WARGV(argv, c);
214      } else if (name1 == NULL) {
215        name1 = (const char*)GET_WARGV(argv, c);
216      } else {
217        name2 = (const char*)GET_WARGV(argv, c);
218      }
219    }
220    if (help || name1 == NULL || name2 == NULL) {
221      if (!help) {
222        fprintf(stderr, "Error: missing arguments.\n");
223      }
224      Help();
225      goto End;
226    }
227    size1 = ReadPicture(name1, &pic1, 1);
228    size2 = ReadPicture(name2, &pic2, 1);
229    if (size1 == 0 || size2 == 0) goto End;
230    if (!keep_alpha) {
231      WebPBlendAlpha(&pic1, 0x00000000);
232      WebPBlendAlpha(&pic2, 0x00000000);
233    }
234    if (!WebPPictureDistortion(&pic1, &pic2, type, disto)) {
235      fprintf(stderr, "Error while computing the distortion.\n");
236      goto End;
237    }
238    printf("%u %.2f    %.2f %.2f %.2f %.2f [ %.2f bpp ]\n",
239           (unsigned int)size1,
240           disto[4], disto[0], disto[1], disto[2], disto[3],
241           8.f * size1 / pic1.width / pic1.height);
242    if (output != NULL) {
243      uint8_t* data = NULL;
244      size_t data_size = 0;
245      if (pic1.use_argb != pic2.use_argb) {
246        fprintf(stderr, "Pictures are not in the same argb format. "
247                        "Can't save the difference map.\n");
248        goto End;
249      }
250      if (pic1.use_argb) {
251        int n;
252        fprintf(stderr, "max differences per channel: ");
253        for (n = 0; n < 3; ++n) {    
254          const int range = (type == 1) ?
255            SSIMScaleChannel((uint8_t*)pic1.argb + n, pic1.argb_stride * 4,
256                             (const uint8_t*)pic2.argb + n, pic2.argb_stride * 4,
257                             4, pic1.width, pic1.height, scale) :
258            DiffScaleChannel((uint8_t*)pic1.argb + n, pic1.argb_stride * 4,
259                             (const uint8_t*)pic2.argb + n, pic2.argb_stride * 4,
260                             4, pic1.width, pic1.height, scale);
261          if (range < 0) fprintf(stderr, "\nError computing diff map\n");
262          fprintf(stderr, "[%d]", range);
263        }
264        fprintf(stderr, "\n");
265        if (use_gray) ConvertToGray(&pic1);
266      } else {
267        fprintf(stderr, "Can only compute the difference map in ARGB format.\n");
268        goto End;
269      }
270  #if !defined(WEBP_REDUCE_CSP)
271      data_size = WebPEncodeLosslessBGRA((const uint8_t*)pic1.argb,
272                                         pic1.width, pic1.height,
273                                         pic1.argb_stride * 4,
274                                         &data);
275      if (data_size == 0) {
276        fprintf(stderr, "Error during lossless encoding.\n");
277        goto End;
278      }
279      ret = ImgIoUtilWriteFile(output, data, data_size) ? 0 : 1;
280      WebPFree(data);
281      if (ret) goto End;
282  #else
283      (void)data;
284      (void)data_size;
285      fprintf(stderr, "Cannot save the difference map. Please recompile "
286                      "without the WEBP_REDUCE_CSP flag.\n");
287  #endif  
288    }
289    ret = 0;
290   End:
291    WebPPictureFree(&pic1);
292    WebPPictureFree(&pic2);
293    FREE_WARGV_AND_RETURN(ret);
294  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pkcs_5_test.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-get_disto.c</div>
                <div class="column column_space"><pre><code>140                                DK, &dkLen)) != CRYPT_OK) {
141  #ifdef LTC_TEST_DBG
142              printf("\npkcs_5_alg2() #%d: Failed/1 (%s)\n", i, error_to_string(err));
143  #endif
144              ++failed;
145          }
146          else if (compare_testvector(DK, dkLen, cases_5_2[i].DK, cases_5_2[i].dkLen, "PKCS#5_2", i)) {
147              ++failed;
148          }
</pre></code></div>
                <div class="column column_space"><pre><code>135        if (diff < 0) {
136          diff = 0;
137        } else if (diff > max) {
138          max = diff;
139        }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    