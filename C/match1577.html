<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for draw_smudge.c &amp; draw_rect.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for draw_smudge.c &amp; draw_rect.c
      </h3>
<h1 align="center">
        27.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>draw_smudge.c (31.404959%)<th>draw_rect.c (25.165564%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(178-217)<td><a href="#" name="0">(154-193)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(65-89)<td><a href="#" name="1">(65-90)</a><td align="center"><font color="#e50000">18</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>draw_smudge.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include &lt;vips/internal.h&gt;
8 <a name="1"></a>
9 #include "pdraw.h"
10 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _VipsDrawSmudge {
11 	VipsDraw parent_object;
12 	int left;
13 	int top;
14 	int width;
15 	int height;
16 } VipsDrawSmudge;
17 typedef struct _VipsDrawSmudgeClass {
18 	VipsDrawClass parent_class;
19 } VipsDrawSmudgeClass; 
20 G_DEFINE_TYPE( VipsDrawSmudge, vips_draw_smudge, VIPS_TYPE_DRAW );
21 static int
22 vips_draw_smudge_build( VipsObject *object )
23 {
24 	VipsDraw *draw = VIPS_DRAW( object );
25 	VipsImage *im = draw-&gt;image; 
26 	VipsDrawSmudge *smudge = (VipsDrawSmudge *) object;</b></font>
27 	int left = smudge-&gt;left;
28 	int top = smudge-&gt;top;
29 	int width = smudge-&gt;width;
30 	int height = smudge-&gt;height;
31 	int bands = vips_image_get_bands( draw-&gt;image ) * 
32 		(vips_band_format_iscomplex( vips_image_get_format( im ) ) ? 
33 		 	2 : 1);
34 	int elements = bands * vips_image_get_width( im );
35 	VipsRect area, image, clipped;
36 	double *total;
37 	int x, y, i, j, b;
38 	if( VIPS_OBJECT_CLASS( vips_draw_smudge_parent_class )-&gt;
39 		build( object ) )
40 		return( -1 );
41 	area.left = left;
42 	area.top = top;
43 	area.width = width;
44 	area.height = height;
45 	image.left = 0;
46 	image.top = 0;
47 	image.width = im-&gt;Xsize;
48 	image.height = im-&gt;Ysize;
49 	vips_rect_marginadjust( &amp;image, -1 );
50 	vips_rect_intersectrect( &amp;area, &amp;image, &amp;clipped );
51 	if( vips_rect_isempty( &amp;clipped ) )
52 		return( 0 );
53 	if( !(total = VIPS_ARRAY( im, bands, double )) )
54 		return( -1 );
55 #define SMUDGE( TYPE ) \
56 	for( y = 0; y &lt; clipped.height; y++ ) { \
57 		TYPE *q; \
58 		TYPE *p; \
59 		\
60 		q = (TYPE *) VIPS_IMAGE_ADDR( im, \
61 			clipped.left, clipped.top + y ); \
62 		p = q - elements - bands; \
63 		for( x = 0; x &lt; clipped.width; x++ ) { \
64 			TYPE *p1, *p2; \
65  			\
66 			for( b = 0; b &lt; bands; b++ ) \
67 				total[b] = 0.0; \
68 			\
69 			p1 = p; \
70 			for( i = 0; i &lt; 3; i++ ) { \
71 				p2 = p1; \
72 				for( j = 0; j &lt; 3; j++ ) \
73 					for( b = 0; b &lt; bands; b++ ) \
74 						total[b] += *p2++; \
75 				\
76 				p1 += elements; \
77 			} \
78  			\
79 			for( b = 0; b &lt; bands; b++ ) \
80 				q[b] = (16 * (double) q[b] + total[b]) / 25.0; \
81 			\
82 			p += bands; \
83 			q += bands; \
84 		} \
85 	}
86 	switch( vips_image_get_format( im ) ) { 
87 	case VIPS_FORMAT_UCHAR: 	SMUDGE( unsigned char ); break; 
88 	case VIPS_FORMAT_CHAR: 		SMUDGE( char ); break; 
89 	case VIPS_FORMAT_USHORT: 	SMUDGE( unsigned short ); break; 
90 	case VIPS_FORMAT_SHORT: 	SMUDGE( short ); break; 
91 	case VIPS_FORMAT_UINT: 		SMUDGE( unsigned int ); break; 
92 	case VIPS_FORMAT_INT: 		SMUDGE( int ); break; 
93 	case VIPS_FORMAT_FLOAT: 	SMUDGE( float ); break; 
94 	case VIPS_FORMAT_DOUBLE: 	SMUDGE( double ); break; 
95 	case VIPS_FORMAT_COMPLEX: 	SMUDGE( float ); break;
96 	case VIPS_FORMAT_DPCOMPLEX: 	SMUDGE( double ); break;
97 <a name="0"></a>
98 	default:
99 		g_assert_not_reached();
100 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
101 	return( 0 );
102 }
103 static void
104 vips_draw_smudge_class_init( VipsDrawSmudgeClass *class )
105 {
106 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
107 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
108 	gobject_class-&gt;set_property = vips_object_set_property;
109 	gobject_class-&gt;get_property = vips_object_get_property;
110 	vobject_class-&gt;nickname = "draw_smudge";
111 	vobject_class-&gt;description = _( "blur a rectangle on an image" );
112 	vobject_class-&gt;build = vips_draw_smudge_build;
113 	VIPS_ARG_INT( class, "left", 6, 
114 		_( "Left" ), 
115 		_( "Rect to fill" ),
116 		VIPS_ARGUMENT_REQUIRED_INPUT,
117 		G_STRUCT_OFFSET( VipsDrawSmudge, left ),
118 		-1000000000, 1000000000, 0 );
119 	VIPS_ARG_INT( class, "top", 7, 
120 		_( "top" ), 
121 		_( "Rect to fill" ),
122 		VIPS_ARGUMENT_REQUIRED_INPUT,
123 		G_STRUCT_OFFSET( VipsDrawSmudge, top ),
124 		-1000000000, 1000000000, 0 );
125 	VIPS_ARG_INT( class, "width", 8, 
126 		_( "width" ), 
127 		_( "Rect to fill" ),
128 		VIPS_ARGUMENT_REQUIRED_INPUT,
129 		G_STRUCT_OFFSET( VipsDrawSmudge, width ),
130 		-1000000000, 1000000000, 0 );
131 	VIPS_ARG_INT( class, "height", 9, </b></font>
132 		_( "height" ), 
133 		_( "Rect to fill" ),
134 		VIPS_ARGUMENT_REQUIRED_INPUT,
135 		G_STRUCT_OFFSET( VipsDrawSmudge, height ),
136 		-1000000000, 1000000000, 0 );
137 }
138 static void
139 vips_draw_smudge_init( VipsDrawSmudge *draw_smudge )
140 {
141 }
142 int
143 vips_draw_smudge( VipsImage *image, 
144 	int left, int top, int width, int height, ... ) 
145 {
146 	va_list ap;
147 	int result;
148 	va_start( ap, height );
149 	result = vips_call_split( "draw_smudge", ap, 
150 		image, left, top, width, height ); 
151 	va_end( ap );
152 	return( result );
153 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>draw_rect.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 <a name="1"></a>
10 #include "drawink.h"
11 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _VipsDrawRect {
12 	VipsDrawink parent_object;
13 	int left;
14 	int top;
15 	int width;
16 	int height;
17 	gboolean fill; 
18 } VipsDrawRect;
19 typedef struct _VipsDrawRectClass {
20 	VipsDrawinkClass parent_class;
21 } VipsDrawRectClass; 
22 G_DEFINE_TYPE( VipsDrawRect, vips_draw_rect, VIPS_TYPE_DRAWINK );
23 static int
24 vips_draw_rect_build( VipsObject *object )
25 {
26 	VipsDraw *draw = VIPS_DRAW( object );
27 	VipsDrawink *drawink = VIPS_DRAWINK( object );
28 	VipsArea *ink = VIPS_AREA( drawink-&gt;ink );</b></font>
29 	VipsDrawRect *draw_rect = (VipsDrawRect *) object;
30 	int left = draw_rect-&gt;left;
31 	int top = draw_rect-&gt;top;
32 	int width = draw_rect-&gt;width;
33 	int height = draw_rect-&gt;height;
34 	VipsRect image;
35 	VipsRect rect; 
36 	VipsRect clip;
37 	if( VIPS_OBJECT_CLASS( vips_draw_rect_parent_class )-&gt;build( object ) )
38 		return( -1 );
39 	if( !draw_rect-&gt;fill &amp;&amp;
40 		width &gt; 2 &amp;&amp;
41 		height &gt; 2 ) 
42 		return( vips_draw_rect( draw-&gt;image, 
43 				ink-&gt;data, ink-&gt;n, 
44 				left, top, width, 1, NULL ) ||
45 			vips_draw_rect( draw-&gt;image, 
46 				ink-&gt;data, ink-&gt;n, 
47 				left + width - 1, top, 1, height, NULL ) ||
48 			vips_draw_rect( draw-&gt;image, 
49 				ink-&gt;data, ink-&gt;n, 
50 				left, top + height - 1, width, 1, NULL ) ||
51 			vips_draw_rect( draw-&gt;image, 
52 				ink-&gt;data, ink-&gt;n, 
53 				left, top, 1, height, NULL ) );
54 	image.left = 0;
55 	image.top = 0;
56 	image.width = draw-&gt;image-&gt;Xsize;
57 	image.height = draw-&gt;image-&gt;Ysize;
58 	rect.left = left;
59 	rect.top = top;
60 	rect.width = width;
61 	rect.height = height;
62 	vips_rect_intersectrect( &amp;rect, &amp;image, &amp;clip );
63 	if( !vips_rect_isempty( &amp;clip ) ) {
64 		VipsPel *to = 
65 			VIPS_IMAGE_ADDR( draw-&gt;image, clip.left, clip.top );
66 		VipsPel *q;
67 		int x, y;
68 		q = to;
69 		for( x = 0; x &lt; clip.width; x++ ) {
70 			vips__drawink_pel( drawink, q );
71 			q += draw-&gt;psize;
72 		}
73 		q = to + draw-&gt;lsize;
74 		for( y = 1; y &lt; clip.height; y++ ) {
75 <a name="0"></a>			memcpy( q, to, clip.width * draw-&gt;psize );
76 			q += draw-&gt;lsize;
77 		}
78 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
79 	return( 0 );
80 }
81 static void
82 vips_draw_rect_class_init( VipsDrawRectClass *class )
83 {
84 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
85 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
86 	gobject_class-&gt;set_property = vips_object_set_property;
87 	gobject_class-&gt;get_property = vips_object_get_property;
88 	vobject_class-&gt;nickname = "draw_rect";
89 	vobject_class-&gt;description = _( "paint a rectangle on an image" );
90 	vobject_class-&gt;build = vips_draw_rect_build;
91 	VIPS_ARG_INT( class, "left", 6, 
92 		_( "Left" ), 
93 		_( "Rect to fill" ),
94 		VIPS_ARGUMENT_REQUIRED_INPUT,
95 		G_STRUCT_OFFSET( VipsDrawRect, left ),
96 		-1000000000, 1000000000, 0 );
97 	VIPS_ARG_INT( class, "top", 7, 
98 		_( "top" ), 
99 		_( "Rect to fill" ),
100 		VIPS_ARGUMENT_REQUIRED_INPUT,
101 		G_STRUCT_OFFSET( VipsDrawRect, top ),
102 		-1000000000, 1000000000, 0 );
103 	VIPS_ARG_INT( class, "width", 8, 
104 		_( "width" ), 
105 		_( "Rect to fill" ),
106 		VIPS_ARGUMENT_REQUIRED_INPUT,
107 		G_STRUCT_OFFSET( VipsDrawRect, width ),
108 		-1000000000, 1000000000, 0 );
109 	VIPS_ARG_INT( class, "height", 9, </b></font>
110 		_( "height" ), 
111 		_( "Rect to fill" ),
112 		VIPS_ARGUMENT_REQUIRED_INPUT,
113 		G_STRUCT_OFFSET( VipsDrawRect, height ),
114 		-1000000000, 1000000000, 0 );
115 	VIPS_ARG_BOOL( class, "fill", 10, 
116 		_( "Fill" ), 
117 		_( "Draw a solid object" ),
118 		VIPS_ARGUMENT_OPTIONAL_INPUT,
119 		G_STRUCT_OFFSET( VipsDrawRect, fill ),
120 		FALSE ); 
121 }
122 static void
123 vips_draw_rect_init( VipsDrawRect *draw_rect )
124 {
125 }
126 static int
127 vips_draw_rectv( VipsImage *image, 
128 	double *ink, int n, int left, int top, int width, int height, 
129 	va_list ap )
130 {
131 	VipsArea *area_ink;
132 	int result;
133 	area_ink = VIPS_AREA( vips_array_double_new( ink, n ) );
134 	result = vips_call_split( "draw_rect", ap, 
135 		image, area_ink, left, top, width, height ); 
136 	vips_area_unref( area_ink );
137 	return( result );
138 }
139 int
140 vips_draw_rect( VipsImage *image, 
141 	double *ink, int n, int left, int top, int width, int height, ... ) 
142 {
143 	va_list ap;
144 	int result;
145 	va_start( ap, height );
146 	result = vips_draw_rectv( image, 
147 		ink, n, left, top, width, height, ap ); 
148 	va_end( ap );
149 	return( result );
150 }
151 int
152 vips_draw_rect1( VipsImage *image, 
153 	double ink, int left, int top, int width, int height, ... ) 
154 {
155 	double array_ink[1];
156 	va_list ap;
157 	int result;
158 	array_ink[0] = ink; 
159 	va_start( ap, height );
160 	result = vips_draw_rectv( image, 
161 		array_ink, 1, left, top, width, height, ap );
162 	va_end( ap );
163 	return( result );
164 }
165 int
166 vips_draw_point( VipsImage *image, double *ink, int n, int x, int y, ... ) 
167 {
168 	va_list ap;
169 	int result;
170 	va_start( ap, y );
171 	result = vips_draw_rectv( image, ink, n, x, y, 1, 1, ap ); 
172 	va_end( ap );
173 	return( result );
174 }
175 int
176 vips_draw_point1( VipsImage *image, double ink, int x, int y, ... ) 
177 {
178 	double array_ink[1];
179 	va_list ap;
180 	int result;
181 	array_ink[0] = ink; 
182 	va_start( ap, y );
183 	result = vips_draw_rectv( image, array_ink, 1, x, y, 1, 1, ap );
184 	va_end( ap );
185 	return( result );
186 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
