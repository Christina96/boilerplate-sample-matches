<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for worley.c & cooc_funcs.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for worley.c & cooc_funcs.c
      </h3>
      <h1 align="center">
        3.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>worley.c (5.6074767%)<TH>cooc_funcs.c (2.6490066%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match26146-0.html#0',2,'match26146-1.html#0',3)" NAME="0">(149-166)<TD><A HREF="javascript:ZweiFrames('match26146-0.html#0',2,'match26146-1.html#0',3)" NAME="0">(318-325)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>worley.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Worley noise generator.
 *
 * 19/7/16
 *
 * 11/8/16
 * 	- float output
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define VIPS_DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#include &lt;vips/vips.h&gt;

#include &quot;pcreate.h&quot;

typedef struct _VipsWorley {
	VipsCreate parent_instance;

	int width;
	int height;
	int cell_size;

	int cells_across;
	int cells_down;

	/* Use this to seed this call of our rng.
	 */
	guint32 seed;
} VipsWorley;

typedef struct _VipsWorleyClass {
	VipsCreateClass parent_class;

} VipsWorleyClass;

G_DEFINE_TYPE( VipsWorley, vips_worley, VIPS_TYPE_CREATE );

#define MAX_FEATURES (10)

typedef struct _Cell {
	/* Cell position, in number of cells. Scale by cell_size to get
	 * absolute image cods.
	 */
	int cell_x;
	int cell_y;

	/* A cell contains 1 to n features.
	 */
	int n_features;

	/* Feature coordinates, in absolute image space.
	 */
	int feature_x[MAX_FEATURES];
	int feature_y[MAX_FEATURES];
} Cell;

typedef struct _Sequence {
	VipsWorley *worley;

	/* The position of the last cell we were in. Use this to avoid
	 * regenerating cells on every pixel lookup.
	 */
	int cell_x;
	int cell_y;

	/* The 3 x 3 grid of cells around the current point.
	 */
	Cell cells[9];

} Sequence;

/* Generate a 3 x 3 grid of cells around a point. 
 */
static void
vips_worley_create_cells( VipsWorley *worley, 
	Cell cells[9], int cell_x, int cell_y )
{
	int x, y;

	for( y = 0; y &lt; 3; y++ ) 
		for( x = 0; x &lt; 3; x++ ) {
			Cell *cell = &amp;cells[x + y * 3];

			guint32 seed;
			int value;
			int j;

			/* Can go &lt;0 and &gt;width for edges.
			 */
			cell-&gt;cell_x = cell_x + x - 1;
			cell-&gt;cell_y = cell_y + y - 1;

			seed = worley-&gt;seed;

			/* When we calculate the seed for this cell, we wrap
			 * around so that our output will tesselate.
			 */
			if( cell-&gt;cell_x &gt;= worley-&gt;cells_across )
				value = 0;
			else if( cell-&gt;cell_x &lt; 0 )
				value = worley-&gt;cells_across - 1;
			else 
				value = cell-&gt;cell_x;
			seed = vips__random_add( seed, value );

			if( cell-&gt;cell_y &gt;= worley-&gt;cells_down )
				value = 0;
<A NAME="0"></A>			else if( cell-&gt;cell_y &lt; 0 )
				value = worley-&gt;cells_down - 1;
			else 
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match26146-1.html#0',3,'match26146-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>				value = cell-&gt;cell_y;
			seed = vips__random_add( seed, value );

			/* [1, MAX_FEATURES)
			 */
			cell-&gt;n_features = (seed % (MAX_FEATURES - 1)) + 1;

			for( j = 0; j &lt; cell-&gt;n_features; j++ ) {
				seed = vips__random( seed ); 
				cell-&gt;feature_x[j] = 
					cell-&gt;cell_x * worley-&gt;cell_size + 
					seed % worley-&gt;cell_size;

				seed = vips__random( seed ); 
				cell-&gt;feature_y[j] = 
					cell-&gt;cell_y * worley-&gt;cell_size + 
					seed % worley-&gt;cell_size;
			}</B></FONT>
		}
}

static int
vips_worley_stop( void *vseq, void *a, void *b )
{
	Sequence *seq = (Sequence *) vseq;

	VIPS_FREE( seq );

	return( 0 );
}

static void *
vips_worley_start( VipsImage *out, void *a, void *b )
{
	VipsWorley *worley = (VipsWorley *) b;

	Sequence *seq;

	if( !(seq = VIPS_NEW( NULL, Sequence )) )
		return( NULL );

	seq-&gt;worley = worley;
	seq-&gt;cell_x = -1;
	seq-&gt;cell_y = -1;

	return( seq );
}

static float
vips_hypot( int x, int y )
{
	/* Faster than hypot() for int args.
	 */
	return( sqrt( x * x + y * y ) );
}

static float
vips_worley_distance( VipsWorley *worley, Cell cells[9], int x, int y )
{
	float distance;

	int i, j;

	distance = worley-&gt;cell_size * 1.5;

	for( i = 0; i &lt; 9; i++ ) {
		Cell *cell = &amp;cells[i];

		for( j = 0; j &lt; cell-&gt;n_features; j++ ) {
			float d = vips_hypot( 
				x - cell-&gt;feature_x[j], 
				y - cell-&gt;feature_y[j] );

			distance = VIPS_MIN( distance, d );
		}
	}

	return( distance );
}

static int
vips_worley_gen( VipsRegion *or, void *vseq, void *a, void *b,
	gboolean *stop )
{
	VipsWorley *worley = (VipsWorley *) a;
	VipsRect *r = &amp;or-&gt;valid;
	Sequence *seq = (Sequence *) vseq;

	int x, y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		float *q = (float *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y );

		for( x = 0; x &lt; r-&gt;width; x++ ) {
			int cell_x = (r-&gt;left + x) / worley-&gt;cell_size;
			int cell_y = (r-&gt;top + y) / worley-&gt;cell_size;

			if( cell_x != seq-&gt;cell_x ||
				cell_y != seq-&gt;cell_y ) {
				vips_worley_create_cells( worley, 
					seq-&gt;cells, cell_x, cell_y );
				seq-&gt;cell_x = cell_x;
				seq-&gt;cell_y = cell_y;
			}

			q[x] = vips_worley_distance( worley, seq-&gt;cells, 
				r-&gt;left + x, r-&gt;top + y );
		}
	}

	return( 0 );
}

static int
vips_worley_build( VipsObject *object )
{
	VipsCreate *create = VIPS_CREATE( object );
	VipsWorley *worley = (VipsWorley *) object;

	if( VIPS_OBJECT_CLASS( vips_worley_parent_class )-&gt;build( object ) )
		return( -1 );

	/* Be careful if width is a multiple of cell_size.
	 */
	worley-&gt;cells_across = 
		VIPS_ROUND_UP( worley-&gt;width, worley-&gt;cell_size ) / 
		worley-&gt;cell_size;
	worley-&gt;cells_down = 
		VIPS_ROUND_UP( worley-&gt;height, worley-&gt;cell_size ) / 
		worley-&gt;cell_size;

	vips_image_init_fields( create-&gt;out,
		worley-&gt;width, worley-&gt;height, 1,
		VIPS_FORMAT_FLOAT, VIPS_CODING_NONE, 
		VIPS_INTERPRETATION_MULTIBAND,
		1.0, 1.0 );
	if( vips_image_pipelinev( create-&gt;out, VIPS_DEMAND_STYLE_ANY, NULL ) ||
		vips_image_generate( create-&gt;out,
			vips_worley_start, vips_worley_gen, vips_worley_stop, 
			worley, NULL ) )
		return( -1 );

	return( 0 );
}

static void
vips_worley_class_init( VipsWorleyClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;nickname = &quot;worley&quot;;
	vobject_class-&gt;description = _( &quot;make a worley noise image&quot; );
	vobject_class-&gt;build = vips_worley_build;

	VIPS_ARG_INT( class, &quot;width&quot;, 2, 
		_( &quot;Width&quot; ), 
		_( &quot;Image width in pixels&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsWorley, width ),
		1, VIPS_MAX_COORD, 1 );

	VIPS_ARG_INT( class, &quot;height&quot;, 3, 
		_( &quot;Height&quot; ), 
		_( &quot;Image height in pixels&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsWorley, height ),
		1, VIPS_MAX_COORD, 1 );

	VIPS_ARG_INT( class, &quot;cell_size&quot;, 3, 
		_( &quot;Cell size&quot; ), 
		_( &quot;Size of Worley cells&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsWorley, cell_size ),
		1, VIPS_MAX_COORD, 256 );

	VIPS_ARG_INT( class, &quot;seed&quot;, 4, 
		_( &quot;Seed&quot; ), 
		_( &quot;Random number seed&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsWorley, seed ),
		INT_MIN, INT_MAX, 0 );

}

static void
vips_worley_init( VipsWorley *worley )
{
	worley-&gt;cell_size = 256;
	worley-&gt;seed = UINT_MAX * g_random_double();
}

/**
 * vips_worley:
 * @out: (out): output image
 * @width: horizontal size
 * @height: vertical size
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @cell_size: %gint, size of Worley cells
 *
 * Create a one-band float image of Worley noise. See:
 *
 * https://en.wikipedia.org/wiki/Worley_noise
 *
 * Use @cell_size to set the size of the cells from which the image is
 * constructed. The default is 256 x 256.
 *
 * If @width and @height are multiples of @cell_size, the image will tessellate.
 *
 * See also: vips_perlin(), vips_fractsurf(), vips_gaussnoise().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_worley( VipsImage **out, int width, int height, ... )
{
	va_list ap;
	int result;

	va_start( ap, height );
	result = vips_call_split( &quot;worley&quot;, ap, out, width, height );
	va_end( ap );

	return( result );
}

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>cooc_funcs.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* @(#)  Calculates the cooccurrence matrix of an image and some of its
 * @(#) features.  The 256x256 cooccurrence matrix of im is held by m
 * @(#) There should be enough margin around the box so the (dx,dy) can
 * @(#) access neighbouring pixels outside the box
 * @(#)
 * @(#) Usage:
 * @(#) int im_cooc_matrix(im, m, xpos, ypos, xsize, ysize, dx, dy, sym_flag)
 * @(#) IMAGE *im, *m;
 * @(#) int xpos, ypos, xsize, ysize;  location of the box within im 
 * @(#) int dx, dy;    displacements 
 * @(#) int sym_flag;
 * @(#)
 * @(#) int im_cooc_asm(m, asmoment)
 * @(#) IMAGE *m;
 * @(#) double *asmoment;
 * @(#)
 * @(#) int im_cooc_contrast(m, contrast)
 * @(#) IMAGE *m;
 * @(#) double *contrast;
 * @(#)
 * @(#) int im_cooc_correlation(m, correlation)
 * @(#) IMAGE *m;
 * @(#) double *correlation;
 * @(#)
 * @(#) int im_cooc_entropy(m, entropy)
 * @(#) IMAGE *m;
 * @(#) double *entropy;
 * @(#)
 * @(#) All functions return 0 on success and -1 on error
 *
 * Copyright: N. Dessipris 1991
 * Written on: 2/12/1991
 * Updated on: 2/12/1991
 * 22/7/93 JC
 *	- extern decls removed
 *	- im_incheck() calls added
 * 28/5/97 JC
 *	- protos added :( 
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;

static
int im_cooc_sym(IMAGE *im, IMAGE *m, int xpos, int ypos, int xsize, int ysize, int dx, int dy)
{
	VipsPel *input, *cpinput;
	int *buf, *pnt, *cpnt;
	double *line, *cpline;
	int x, y;
	int offset;
	int bufofst;
	int tempA, tempB;
	int norm;

	if (im_iocheck(im, m) == -1)
		return( -1 );
	if ((im-&gt;Bands != 1)||(im-&gt;BandFmt != IM_BANDFMT_UCHAR)) {
		im_error( &quot;im_cooc_sym&quot;, &quot;%s&quot;, _( &quot;Unable to accept input&quot;) );
		return(-1);
		}
	if ( (xpos + xsize + dx &gt; im-&gt;Xsize)|| (ypos + ysize + dy &gt; im-&gt;Ysize) ) { 
		im_error( &quot;im_cooc_sym&quot;, &quot;%s&quot;, _( &quot;wrong args&quot;) ); 
		return(-1); }
	if (im_cp_desc(m, im) == -1)
		return( -1 );
	m-&gt;Xsize = 256;
	m-&gt;Ysize = 256;
	m-&gt;BandFmt = IM_BANDFMT_DOUBLE;
	m-&gt;Type = IM_TYPE_B_W;
	if (im_setupout(m) == -1)
		return( -1 );
/* malloc space to keep the read values */
	buf = (int *)calloc( (unsigned)m-&gt;Xsize*m-&gt;Ysize, sizeof(int) );
	line = (double *)calloc( (unsigned)m-&gt;Xsize * m-&gt;Bands, sizeof(double));
	if ( (buf == NULL) || (line == NULL) ) { 
		im_error( &quot;im_cooc_sym&quot;, &quot;%s&quot;, _( &quot;calloc failed&quot;) ); 
		return(-1); }
	input = im-&gt;data;
	input += ( ypos * im-&gt;Xsize + xpos );
	offset = dy * im-&gt;Xsize + dx;
	for ( y=0; y&lt;ysize; y++ )
		{
		cpinput = input;
		input += im-&gt;Xsize;
		for ( x=0; x&lt;xsize; x++ )
			{
			tempA = (int)(*cpinput);
			tempB = (int)(*(cpinput + offset));
			bufofst = tempA + m-&gt;Xsize * tempB;
			(*(buf + bufofst))++;
			bufofst = tempB + m-&gt;Xsize * tempA;
			(*(buf + bufofst))++;
			cpinput++;
			}
		}

	norm = xsize * ysize * 2;
	pnt = buf;
	for ( y=0; y&lt;m-&gt;Ysize; y++ )
		{
		cpnt = pnt;
		pnt += m-&gt;Xsize;
		cpline = line;
		for (x=0; x&lt;m-&gt;Xsize; x++)
			*cpline++ = (double)(*cpnt++)/(double)norm;
		if (im_writeline( y, m, (VipsPel *) line ) == -1) 
			{
			im_error( &quot;im_cooc_sym&quot;, &quot;%s&quot;, _( &quot;unable to im_writeline&quot;) );
			return(-1);
			}
		}
	free((char*)buf);
	free((char*)line);
	return(0);
}

static
int im_cooc_ord(IMAGE *im, IMAGE *m, int xpos, int ypos, int xsize, int ysize, int dx, int dy)
{
	VipsPel *input, *cpinput;
	int *buf, *pnt, *cpnt;
	double *line, *cpline;
	int x, y;
	int offset;
	int bufofst;
	int tempA, tempB;
	int norm;

	if (im_iocheck(im, m) == -1)
		return( -1 );
	if ((im-&gt;Bands != 1)||(im-&gt;BandFmt != IM_BANDFMT_UCHAR))
		{
		im_error( &quot;im_cooc_ord&quot;, &quot;%s&quot;, _( &quot;Unable to accept input&quot;) );
		return(-1);
		}
	if ( (xpos + xsize + dx &gt; im-&gt;Xsize)|| (ypos + ysize + dy &gt; im-&gt;Ysize) ) { 
		im_error( &quot;im_cooc_ord&quot;, &quot;%s&quot;, _( &quot;wrong args&quot;) ); 
		return(-1); }
	if (im_cp_desc(m, im) == -1)
		return( -1 );
	m-&gt;Xsize = 256;
	m-&gt;Ysize = 256;
	m-&gt;BandFmt = IM_BANDFMT_DOUBLE;
	if (im_setupout(m) == -1)
		return( -1 );
/* malloc space to keep the read values */
	buf = (int *)calloc( (unsigned)m-&gt;Xsize*m-&gt;Ysize, sizeof(int) );
	line = (double *)calloc( (unsigned)m-&gt;Xsize * m-&gt;Bands, sizeof(double));
	if ( (buf == NULL) || (line == NULL) ) { 
		im_error( &quot;im_cooc_ord&quot;, &quot;%s&quot;, _( &quot;calloc failed&quot;) ); 
		return(-1); }
	input = im-&gt;data;
	input += ( ypos * im-&gt;Xsize + xpos );
	offset = dy * im-&gt;Xsize + dx;
	for ( y=0; y&lt;ysize; y++ )
		{
		cpinput = input;
		input += im-&gt;Xsize;
		for ( x=0; x&lt;xsize; x++ )
			{
			tempA = (int)(*cpinput);
			tempB = (int)(*(cpinput + offset));
			bufofst = tempA + m-&gt;Xsize * tempB;
			(*(buf + bufofst))++;
			cpinput++;
			}
		}

	norm = xsize * ysize;
	pnt = buf;
	for ( y=0; y&lt;m-&gt;Ysize; y++ )
		{
		cpnt = pnt;
		pnt += m-&gt;Xsize;
		cpline = line;
		for (x=0; x&lt;m-&gt;Xsize; x++)
			*cpline++ = (double)(*cpnt++)/(double)norm;
		if (im_writeline( y, m, (PEL *) line ) == -1) 
			{
			im_error( &quot;im_cooc_ord&quot;, &quot;%s&quot;, _( &quot;unable to im_writeline&quot;) );
			return(-1);
			}
		}
	free((char*)buf);
	free((char*)line);
	return(0);
}

/* Keep the coocurrence matrix as a 256x256x1 double image */

int 
im_cooc_matrix( IMAGE *im, IMAGE *m, 
	int xp, int yp, int xs, int ys, int dx, int dy, int flag )
{
	if (flag == 0)
		return( im_cooc_ord(im, m, xp, yp, xs, ys, dx, dy) );
	else if (flag == 1)	/* symmetrical cooc */
		return( im_cooc_sym(im, m, xp, yp, xs, ys, dx, dy) );
	else { 
		im_error( &quot;im_cooc_matrix&quot;, &quot;%s&quot;, _( &quot;wrong flag!&quot;) ); 
		return(-1); }
}

/* Calculate contrast, asmoment, entropy and correlation
 */
int 
im_cooc_asm( IMAGE *m, double *asmoment )
{
	double temp, tmpasm, *pnt;
	int i;

	if( im_incheck( m ) )
		return( -1 );

	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
		{
		im_error( &quot;im_cooc_asm&quot;, &quot;%s&quot;, _( &quot;unable to accept input&quot;) );
		return(-1);
		}
	tmpasm = 0.0;
	pnt = (double*)m-&gt;data;
	for(i=0; i&lt;m-&gt;Xsize * m-&gt;Ysize; i++)
		{
		temp = *pnt++;
		tmpasm += temp * temp;
		}
	*asmoment = tmpasm;
	return(0);
}

int 
im_cooc_contrast( IMAGE *m, double *contrast )
{
	double dtemp, tmpcon, *pnt, *cpnt;
	int x, y;

	if( im_incheck( m ) )
		return( -1 );

	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
		{
		im_error( &quot;im_cooc_contrast&quot;, &quot;%s&quot;, _( &quot;unable to accept input&quot;) );
		return(-1);
		}
	tmpcon = 0.0;
	pnt = (double*)m-&gt;data;
	for(y=0; y&lt;m-&gt;Ysize; y++)
		{
		cpnt = pnt;
		pnt += m-&gt;Xsize;
		for(x=0; x&lt;m-&gt;Xsize; x++)
			{
			dtemp = (double)( (y-x)*(y-x) );
			tmpcon += dtemp * (*cpnt);
			cpnt++;
			}
		}

	*contrast = tmpcon;
	return(0);
}

/* buffer contains the frequency distributions f[i] */
/*  Note that sum(f[i]) = 1.0 and that the */
/* cooccurence matrix is symmetrical */
static void 
stats(double *buffer, int size, double *pmean, double *pstd)
{
	double mean, std;
	register int i;
	double sumf;	/* calculates the sum of f[i] */
	double temp;	/* temporary variable */
	double *pbuffer;
	double sumf2;	/* calculates the sum of f[i]^2 */
	double correction; /* calulates the correction term for the variance */
<A NAME="0"></A>	double variance;	/* = (sumf2 - correction)/n, n=sum(f[i]) = 1 */
	
	mean = 0.0; std = 0.0;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match26146-0.html#0',2,'match26146-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	sumf = 0.0; sumf2 = 0.0;
	pbuffer = buffer;
	for (i=0; i&lt;size; i++)
		{
		temp = *pbuffer++;
		sumf += (temp*i);
		sumf2 += (temp*i*i);
		}</B></FONT>
	correction = sumf*sumf;
	mean = sumf;
	variance = sumf2-correction;
	std = sqrt(variance);
	*pmean = mean;
	*pstd = std;
}

int 
im_cooc_correlation( IMAGE *m, double *correlation )
{
	double mcol, stdcol, mrow, stdrow; /* mean and std of cols and rows */
	double *pbuf;
	double *cpbuf;
	double dtemp;
	register int i,j;
	double *row;	/* Keeps the sum of rows entries as double */
	double *col;	/* Keeps the sum of cols entries as double */
	double tmpcor=0.0;
	double sum = 0.0;

	if( im_incheck( m ) )
		return( -1 );

	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
		{
		im_error( &quot;im_cooc_correlation&quot;, &quot;%s&quot;, _( &quot;unable to accept input&quot;) );
		return(-1);
		}
	row = (double*)calloc( (unsigned)m-&gt;Ysize, sizeof(double));
	col = (double*)calloc( (unsigned)m-&gt;Xsize, sizeof(double));
	if ( row == NULL || col == NULL )
		{
		im_error( &quot;im_cooc_correlation&quot;, &quot;%s&quot;, _( &quot;unable to calloc&quot;) );
		return(-1);
		}
	pbuf = (double*)m-&gt;data;
	for(j=0; j&lt;m-&gt;Ysize; j++)
		{
		cpbuf = pbuf;
		pbuf += m-&gt;Xsize;
		sum=0.0;
		for(i=0; i&lt;m-&gt;Xsize; i++)
			sum += *cpbuf++;
		*(row+j) = sum;
		}

	pbuf = (double*)m-&gt;data;
	for(j=0; j&lt;m-&gt;Ysize; j++)
		{
		cpbuf = pbuf;
		pbuf++;
		sum=0.0;
		for(i=0; i&lt;m-&gt;Xsize; i++)
			{
			sum += *cpbuf;
			cpbuf += m-&gt;Xsize;
			}
		*(col+j) = sum;
		}

	stats(row, m-&gt;Ysize, &amp;mrow, &amp;stdrow);

	stats(col, m-&gt;Ysize ,&amp;mcol, &amp;stdcol);
#ifdef DEBUG
	fprintf(stderr, &quot;rows: mean=%f std=%f\ncols: mean=%f std=%f\n&quot;,
mrow, stdrow, mcol, stdcol);
#endif
	tmpcor = 0.0;
	pbuf = (double*)m-&gt;data;
	for(j=0; j&lt;m-&gt;Ysize; j++)
		{
		cpbuf = pbuf;
		pbuf += m-&gt;Xsize;
		for(i=0; i&lt;m-&gt;Xsize; i++)
			{
			dtemp = *cpbuf;
			tmpcor += ( ((double)i)*((double)j)*dtemp);
			cpbuf++;
			}
		}
#ifdef DEBUG
	fprintf(stderr, &quot;tmpcor=%f\n&quot;, tmpcor);
#endif
	if ( (stdcol==0.0)||(stdrow==0) )
		{
		im_error( &quot;im_cooc_correlation&quot;, &quot;%s&quot;, _( &quot;zero std&quot;) );
		return(-1);
		}
	tmpcor = (tmpcor-(mcol*mrow))/(stdcol*stdrow);
	*correlation = tmpcor;
	free((char*)row); free((char*)col);
	return(0);
}

int 
im_cooc_entropy( IMAGE *m, double *entropy )
{
	double *pbuf, *pbufstart;
	double *cpbuf;
	register int i,j;
	double tmpent, dtemp;
	double val;

	if( im_incheck( m ) )
		return( -1 );

	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
		{
		im_error( &quot;im_cooc_entropy&quot;, &quot;%s&quot;, _( &quot;unable to accept input&quot;) );
		return(-1);
		}
	pbufstart = (double*)m-&gt;data;

	tmpent = 0.0;
	pbuf = pbufstart;
	for(j=0; j&lt;m-&gt;Ysize; j++)
		{
		cpbuf = pbuf;
		pbuf += m-&gt;Xsize;
		for(i=0; i&lt;m-&gt;Xsize; i++)
			{
			if(*cpbuf != 0)
				{
				dtemp = *cpbuf;
				tmpent += (dtemp*log10(dtemp));
				}
			cpbuf++;
			}
		}
	val = tmpent*(-1);

#ifdef DEBUG
	fprintf(stderr,&quot;ENT=%f\nwhich is %f bits\n&quot;, val, val/log10(2.0) );
#endif
	*entropy = (val/log10(2.0));
	return(0);
}
</PRE>
</div>
  </div>
</body>
</html>
