<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for worley.c &amp; cooc_funcs.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for worley.c &amp; cooc_funcs.c
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>worley.c (5.6074767%)<th>cooc_funcs.c (2.6490066%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(149-166)<td><a href="#" name="0">(318-325)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>worley.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;vips/vips.h&gt;
#include "pcreate.h"
typedef struct _VipsWorley {
	VipsCreate parent_instance;
	int width;
	int height;
	int cell_size;
	int cells_across;
	int cells_down;
	guint32 seed;
} VipsWorley;
typedef struct _VipsWorleyClass {
	VipsCreateClass parent_class;
} VipsWorleyClass;
G_DEFINE_TYPE( VipsWorley, vips_worley, VIPS_TYPE_CREATE );
#define MAX_FEATURES (10)
typedef struct _Cell {
	int cell_x;
	int cell_y;
	int n_features;
	int feature_x[MAX_FEATURES];
	int feature_y[MAX_FEATURES];
} Cell;
typedef struct _Sequence {
	VipsWorley *worley;
	int cell_x;
	int cell_y;
	Cell cells[9];
} Sequence;
static void
vips_worley_create_cells( VipsWorley *worley, 
	Cell cells[9], int cell_x, int cell_y )
{
	int x, y;
	for( y = 0; y &lt; 3; y++ ) 
		for( x = 0; x &lt; 3; x++ ) {
			Cell *cell = &amp;cells[x + y * 3];
			guint32 seed;
			int value;
			int j;
			cell-&gt;cell_x = cell_x + x - 1;
			cell-&gt;cell_y = cell_y + y - 1;
			seed = worley-&gt;seed;
			if( cell-&gt;cell_x &gt;= worley-&gt;cells_across )
				value = 0;
			else if( cell-&gt;cell_x &lt; 0 )
				value = worley-&gt;cells_across - 1;
			else 
				value = cell-&gt;cell_x;
			seed = vips__random_add( seed, value );
			if( cell-&gt;cell_y &gt;= worley-&gt;cells_down )
				value = 0;
<a name="0"></a>			else if( cell-&gt;cell_y &lt; 0 )
				value = worley-&gt;cells_down - 1;
			else 
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>				value = cell-&gt;cell_y;
			seed = vips__random_add( seed, value );
			cell-&gt;n_features = (seed % (MAX_FEATURES - 1)) + 1;
			for( j = 0; j &lt; cell-&gt;n_features; j++ ) {
				seed = vips__random( seed ); 
				cell-&gt;feature_x[j] = 
					cell-&gt;cell_x * worley-&gt;cell_size + 
					seed % worley-&gt;cell_size;
				seed = vips__random( seed ); 
				cell-&gt;feature_y[j] = 
					cell-&gt;cell_y * worley-&gt;cell_size + 
					seed % worley-&gt;cell_size;
			}</b></font>
		}
}
static int
vips_worley_stop( void *vseq, void *a, void *b )
{
	Sequence *seq = (Sequence *) vseq;
	VIPS_FREE( seq );
	return( 0 );
}
static void *
vips_worley_start( VipsImage *out, void *a, void *b )
{
	VipsWorley *worley = (VipsWorley *) b;
	Sequence *seq;
	if( !(seq = VIPS_NEW( NULL, Sequence )) )
		return( NULL );
	seq-&gt;worley = worley;
	seq-&gt;cell_x = -1;
	seq-&gt;cell_y = -1;
	return( seq );
}
static float
vips_hypot( int x, int y )
{
	return( sqrt( x * x + y * y ) );
}
static float
vips_worley_distance( VipsWorley *worley, Cell cells[9], int x, int y )
{
	float distance;
	int i, j;
	distance = worley-&gt;cell_size * 1.5;
	for( i = 0; i &lt; 9; i++ ) {
		Cell *cell = &amp;cells[i];
		for( j = 0; j &lt; cell-&gt;n_features; j++ ) {
			float d = vips_hypot( 
				x - cell-&gt;feature_x[j], 
				y - cell-&gt;feature_y[j] );
			distance = VIPS_MIN( distance, d );
		}
	}
	return( distance );
}
static int
vips_worley_gen( VipsRegion *or, void *vseq, void *a, void *b,
	gboolean *stop )
{
	VipsWorley *worley = (VipsWorley *) a;
	VipsRect *r = &amp;or-&gt;valid;
	Sequence *seq = (Sequence *) vseq;
	int x, y;
	for( y = 0; y &lt; r-&gt;height; y++ ) {
		float *q = (float *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y );
		for( x = 0; x &lt; r-&gt;width; x++ ) {
			int cell_x = (r-&gt;left + x) / worley-&gt;cell_size;
			int cell_y = (r-&gt;top + y) / worley-&gt;cell_size;
			if( cell_x != seq-&gt;cell_x ||
				cell_y != seq-&gt;cell_y ) {
				vips_worley_create_cells( worley, 
					seq-&gt;cells, cell_x, cell_y );
				seq-&gt;cell_x = cell_x;
				seq-&gt;cell_y = cell_y;
			}
			q[x] = vips_worley_distance( worley, seq-&gt;cells, 
				r-&gt;left + x, r-&gt;top + y );
		}
	}
	return( 0 );
}
static int
vips_worley_build( VipsObject *object )
{
	VipsCreate *create = VIPS_CREATE( object );
	VipsWorley *worley = (VipsWorley *) object;
	if( VIPS_OBJECT_CLASS( vips_worley_parent_class )-&gt;build( object ) )
		return( -1 );
	worley-&gt;cells_across = 
		VIPS_ROUND_UP( worley-&gt;width, worley-&gt;cell_size ) / 
		worley-&gt;cell_size;
	worley-&gt;cells_down = 
		VIPS_ROUND_UP( worley-&gt;height, worley-&gt;cell_size ) / 
		worley-&gt;cell_size;
	vips_image_init_fields( create-&gt;out,
		worley-&gt;width, worley-&gt;height, 1,
		VIPS_FORMAT_FLOAT, VIPS_CODING_NONE, 
		VIPS_INTERPRETATION_MULTIBAND,
		1.0, 1.0 );
	if( vips_image_pipelinev( create-&gt;out, VIPS_DEMAND_STYLE_ANY, NULL ) ||
		vips_image_generate( create-&gt;out,
			vips_worley_start, vips_worley_gen, vips_worley_stop, 
			worley, NULL ) )
		return( -1 );
	return( 0 );
}
static void
vips_worley_class_init( VipsWorleyClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	vobject_class-&gt;nickname = "worley";
	vobject_class-&gt;description = _( "make a worley noise image" );
	vobject_class-&gt;build = vips_worley_build;
	VIPS_ARG_INT( class, "width", 2, 
		_( "Width" ), 
		_( "Image width in pixels" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsWorley, width ),
		1, VIPS_MAX_COORD, 1 );
	VIPS_ARG_INT( class, "height", 3, 
		_( "Height" ), 
		_( "Image height in pixels" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsWorley, height ),
		1, VIPS_MAX_COORD, 1 );
	VIPS_ARG_INT( class, "cell_size", 3, 
		_( "Cell size" ), 
		_( "Size of Worley cells" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsWorley, cell_size ),
		1, VIPS_MAX_COORD, 256 );
	VIPS_ARG_INT( class, "seed", 4, 
		_( "Seed" ), 
		_( "Random number seed" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsWorley, seed ),
		INT_MIN, INT_MAX, 0 );
}
static void
vips_worley_init( VipsWorley *worley )
{
	worley-&gt;cell_size = 256;
	worley-&gt;seed = UINT_MAX * g_random_double();
}
int
vips_worley( VipsImage **out, int width, int height, ... )
{
	va_list ap;
	int result;
	va_start( ap, height );
	result = vips_call_split( "worley", ap, out, width, height );
	va_end( ap );
	return( result );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>cooc_funcs.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;
static
int im_cooc_sym(IMAGE *im, IMAGE *m, int xpos, int ypos, int xsize, int ysize, int dx, int dy)
{
	VipsPel *input, *cpinput;
	int *buf, *pnt, *cpnt;
	double *line, *cpline;
	int x, y;
	int offset;
	int bufofst;
	int tempA, tempB;
	int norm;
	if (im_iocheck(im, m) == -1)
		return( -1 );
	if ((im-&gt;Bands != 1)||(im-&gt;BandFmt != IM_BANDFMT_UCHAR)) {
		im_error( "im_cooc_sym", "%s", _( "Unable to accept input") );
		return(-1);
		}
	if ( (xpos + xsize + dx &gt; im-&gt;Xsize)|| (ypos + ysize + dy &gt; im-&gt;Ysize) ) { 
		im_error( "im_cooc_sym", "%s", _( "wrong args") ); 
		return(-1); }
	if (im_cp_desc(m, im) == -1)
		return( -1 );
	m-&gt;Xsize = 256;
	m-&gt;Ysize = 256;
	m-&gt;BandFmt = IM_BANDFMT_DOUBLE;
	m-&gt;Type = IM_TYPE_B_W;
	if (im_setupout(m) == -1)
		return( -1 );
	buf = (int *)calloc( (unsigned)m-&gt;Xsize*m-&gt;Ysize, sizeof(int) );
	line = (double *)calloc( (unsigned)m-&gt;Xsize * m-&gt;Bands, sizeof(double));
	if ( (buf == NULL) || (line == NULL) ) { 
		im_error( "im_cooc_sym", "%s", _( "calloc failed") ); 
		return(-1); }
	input = im-&gt;data;
	input += ( ypos * im-&gt;Xsize + xpos );
	offset = dy * im-&gt;Xsize + dx;
	for ( y=0; y&lt;ysize; y++ )
		{
		cpinput = input;
		input += im-&gt;Xsize;
		for ( x=0; x&lt;xsize; x++ )
			{
			tempA = (int)(*cpinput);
			tempB = (int)(*(cpinput + offset));
			bufofst = tempA + m-&gt;Xsize * tempB;
			(*(buf + bufofst))++;
			bufofst = tempB + m-&gt;Xsize * tempA;
			(*(buf + bufofst))++;
			cpinput++;
			}
		}
	norm = xsize * ysize * 2;
	pnt = buf;
	for ( y=0; y&lt;m-&gt;Ysize; y++ )
		{
		cpnt = pnt;
		pnt += m-&gt;Xsize;
		cpline = line;
		for (x=0; x&lt;m-&gt;Xsize; x++)
			*cpline++ = (double)(*cpnt++)/(double)norm;
		if (im_writeline( y, m, (VipsPel *) line ) == -1) 
			{
			im_error( "im_cooc_sym", "%s", _( "unable to im_writeline") );
			return(-1);
			}
		}
	free((char*)buf);
	free((char*)line);
	return(0);
}
static
int im_cooc_ord(IMAGE *im, IMAGE *m, int xpos, int ypos, int xsize, int ysize, int dx, int dy)
{
	VipsPel *input, *cpinput;
	int *buf, *pnt, *cpnt;
	double *line, *cpline;
	int x, y;
	int offset;
	int bufofst;
	int tempA, tempB;
	int norm;
	if (im_iocheck(im, m) == -1)
		return( -1 );
	if ((im-&gt;Bands != 1)||(im-&gt;BandFmt != IM_BANDFMT_UCHAR))
		{
		im_error( "im_cooc_ord", "%s", _( "Unable to accept input") );
		return(-1);
		}
	if ( (xpos + xsize + dx &gt; im-&gt;Xsize)|| (ypos + ysize + dy &gt; im-&gt;Ysize) ) { 
		im_error( "im_cooc_ord", "%s", _( "wrong args") ); 
		return(-1); }
	if (im_cp_desc(m, im) == -1)
		return( -1 );
	m-&gt;Xsize = 256;
	m-&gt;Ysize = 256;
	m-&gt;BandFmt = IM_BANDFMT_DOUBLE;
	if (im_setupout(m) == -1)
		return( -1 );
	buf = (int *)calloc( (unsigned)m-&gt;Xsize*m-&gt;Ysize, sizeof(int) );
	line = (double *)calloc( (unsigned)m-&gt;Xsize * m-&gt;Bands, sizeof(double));
	if ( (buf == NULL) || (line == NULL) ) { 
		im_error( "im_cooc_ord", "%s", _( "calloc failed") ); 
		return(-1); }
	input = im-&gt;data;
	input += ( ypos * im-&gt;Xsize + xpos );
	offset = dy * im-&gt;Xsize + dx;
	for ( y=0; y&lt;ysize; y++ )
		{
		cpinput = input;
		input += im-&gt;Xsize;
		for ( x=0; x&lt;xsize; x++ )
			{
			tempA = (int)(*cpinput);
			tempB = (int)(*(cpinput + offset));
			bufofst = tempA + m-&gt;Xsize * tempB;
			(*(buf + bufofst))++;
			cpinput++;
			}
		}
	norm = xsize * ysize;
	pnt = buf;
	for ( y=0; y&lt;m-&gt;Ysize; y++ )
		{
		cpnt = pnt;
		pnt += m-&gt;Xsize;
		cpline = line;
		for (x=0; x&lt;m-&gt;Xsize; x++)
			*cpline++ = (double)(*cpnt++)/(double)norm;
		if (im_writeline( y, m, (PEL *) line ) == -1) 
			{
			im_error( "im_cooc_ord", "%s", _( "unable to im_writeline") );
			return(-1);
			}
		}
	free((char*)buf);
	free((char*)line);
	return(0);
}
int 
im_cooc_matrix( IMAGE *im, IMAGE *m, 
	int xp, int yp, int xs, int ys, int dx, int dy, int flag )
{
	if (flag == 0)
		return( im_cooc_ord(im, m, xp, yp, xs, ys, dx, dy) );
	else if (flag == 1)			return( im_cooc_sym(im, m, xp, yp, xs, ys, dx, dy) );
	else { 
		im_error( "im_cooc_matrix", "%s", _( "wrong flag!") ); 
		return(-1); }
}
int 
im_cooc_asm( IMAGE *m, double *asmoment )
{
	double temp, tmpasm, *pnt;
	int i;
	if( im_incheck( m ) )
		return( -1 );
	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
		{
		im_error( "im_cooc_asm", "%s", _( "unable to accept input") );
		return(-1);
		}
	tmpasm = 0.0;
	pnt = (double*)m-&gt;data;
	for(i=0; i&lt;m-&gt;Xsize * m-&gt;Ysize; i++)
		{
		temp = *pnt++;
		tmpasm += temp * temp;
		}
	*asmoment = tmpasm;
	return(0);
}
int 
im_cooc_contrast( IMAGE *m, double *contrast )
{
	double dtemp, tmpcon, *pnt, *cpnt;
	int x, y;
	if( im_incheck( m ) )
		return( -1 );
	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
		{
		im_error( "im_cooc_contrast", "%s", _( "unable to accept input") );
		return(-1);
		}
	tmpcon = 0.0;
	pnt = (double*)m-&gt;data;
	for(y=0; y&lt;m-&gt;Ysize; y++)
		{
		cpnt = pnt;
		pnt += m-&gt;Xsize;
		for(x=0; x&lt;m-&gt;Xsize; x++)
			{
			dtemp = (double)( (y-x)*(y-x) );
			tmpcon += dtemp * (*cpnt);
			cpnt++;
			}
		}
	*contrast = tmpcon;
	return(0);
}
static void 
stats(double *buffer, int size, double *pmean, double *pstd)
{
	double mean, std;
	register int i;
	double sumf;		double temp;		double *pbuffer;
	double sumf2;		double correction; <a name="0"></a>	double variance;		
	mean = 0.0; std = 0.0;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	sumf = 0.0; sumf2 = 0.0;
	pbuffer = buffer;
	for (i=0; i&lt;size; i++)
		{
		temp = *pbuffer++;
		sumf += (temp*i);
		sumf2 += (temp*i*i);
		}</b></font>
	correction = sumf*sumf;
	mean = sumf;
	variance = sumf2-correction;
	std = sqrt(variance);
	*pmean = mean;
	*pstd = std;
}
int 
im_cooc_correlation( IMAGE *m, double *correlation )
{
	double mcol, stdcol, mrow, stdrow; 	double *pbuf;
	double *cpbuf;
	double dtemp;
	register int i,j;
	double *row;		double *col;		double tmpcor=0.0;
	double sum = 0.0;
	if( im_incheck( m ) )
		return( -1 );
	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
		{
		im_error( "im_cooc_correlation", "%s", _( "unable to accept input") );
		return(-1);
		}
	row = (double*)calloc( (unsigned)m-&gt;Ysize, sizeof(double));
	col = (double*)calloc( (unsigned)m-&gt;Xsize, sizeof(double));
	if ( row == NULL || col == NULL )
		{
		im_error( "im_cooc_correlation", "%s", _( "unable to calloc") );
		return(-1);
		}
	pbuf = (double*)m-&gt;data;
	for(j=0; j&lt;m-&gt;Ysize; j++)
		{
		cpbuf = pbuf;
		pbuf += m-&gt;Xsize;
		sum=0.0;
		for(i=0; i&lt;m-&gt;Xsize; i++)
			sum += *cpbuf++;
		*(row+j) = sum;
		}
	pbuf = (double*)m-&gt;data;
	for(j=0; j&lt;m-&gt;Ysize; j++)
		{
		cpbuf = pbuf;
		pbuf++;
		sum=0.0;
		for(i=0; i&lt;m-&gt;Xsize; i++)
			{
			sum += *cpbuf;
			cpbuf += m-&gt;Xsize;
			}
		*(col+j) = sum;
		}
	stats(row, m-&gt;Ysize, &amp;mrow, &amp;stdrow);
	stats(col, m-&gt;Ysize ,&amp;mcol, &amp;stdcol);
#ifdef DEBUG
	fprintf(stderr, "rows: mean=%f std=%f\ncols: mean=%f std=%f\n",
mrow, stdrow, mcol, stdcol);
#endif
	tmpcor = 0.0;
	pbuf = (double*)m-&gt;data;
	for(j=0; j&lt;m-&gt;Ysize; j++)
		{
		cpbuf = pbuf;
		pbuf += m-&gt;Xsize;
		for(i=0; i&lt;m-&gt;Xsize; i++)
			{
			dtemp = *cpbuf;
			tmpcor += ( ((double)i)*((double)j)*dtemp);
			cpbuf++;
			}
		}
#ifdef DEBUG
	fprintf(stderr, "tmpcor=%f\n", tmpcor);
#endif
	if ( (stdcol==0.0)||(stdrow==0) )
		{
		im_error( "im_cooc_correlation", "%s", _( "zero std") );
		return(-1);
		}
	tmpcor = (tmpcor-(mcol*mrow))/(stdcol*stdrow);
	*correlation = tmpcor;
	free((char*)row); free((char*)col);
	return(0);
}
int 
im_cooc_entropy( IMAGE *m, double *entropy )
{
	double *pbuf, *pbufstart;
	double *cpbuf;
	register int i,j;
	double tmpent, dtemp;
	double val;
	if( im_incheck( m ) )
		return( -1 );
	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
		{
		im_error( "im_cooc_entropy", "%s", _( "unable to accept input") );
		return(-1);
		}
	pbufstart = (double*)m-&gt;data;
	tmpent = 0.0;
	pbuf = pbufstart;
	for(j=0; j&lt;m-&gt;Ysize; j++)
		{
		cpbuf = pbuf;
		pbuf += m-&gt;Xsize;
		for(i=0; i&lt;m-&gt;Xsize; i++)
			{
			if(*cpbuf != 0)
				{
				dtemp = *cpbuf;
				tmpent += (dtemp*log10(dtemp));
				}
			cpbuf++;
			}
		}
	val = tmpent*(-1);
#ifdef DEBUG
	fprintf(stderr,"ENT=%f\nwhich is %f bits\n", val, val/log10(2.0) );
#endif
	*entropy = (val/log10(2.0));
	return(0);
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
