<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for worley.c &amp; cooc_funcs.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for worley.c &amp; cooc_funcs.c
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>worley.c (5.6074767%)<th>cooc_funcs.c (2.6490066%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(149-166)<td><a href="#" name="0">(318-325)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>worley.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;math.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include "pcreate.h"
10 typedef struct _VipsWorley {
11 	VipsCreate parent_instance;
12 	int width;
13 	int height;
14 	int cell_size;
15 	int cells_across;
16 	int cells_down;
17 	guint32 seed;
18 } VipsWorley;
19 typedef struct _VipsWorleyClass {
20 	VipsCreateClass parent_class;
21 } VipsWorleyClass;
22 G_DEFINE_TYPE( VipsWorley, vips_worley, VIPS_TYPE_CREATE );
23 #define MAX_FEATURES (10)
24 typedef struct _Cell {
25 	int cell_x;
26 	int cell_y;
27 	int n_features;
28 	int feature_x[MAX_FEATURES];
29 	int feature_y[MAX_FEATURES];
30 } Cell;
31 typedef struct _Sequence {
32 	VipsWorley *worley;
33 	int cell_x;
34 	int cell_y;
35 	Cell cells[9];
36 } Sequence;
37 static void
38 vips_worley_create_cells( VipsWorley *worley, 
39 	Cell cells[9], int cell_x, int cell_y )
40 {
41 	int x, y;
42 	for( y = 0; y &lt; 3; y++ ) 
43 		for( x = 0; x &lt; 3; x++ ) {
44 			Cell *cell = &amp;cells[x + y * 3];
45 			guint32 seed;
46 			int value;
47 			int j;
48 			cell-&gt;cell_x = cell_x + x - 1;
49 			cell-&gt;cell_y = cell_y + y - 1;
50 			seed = worley-&gt;seed;
51 			if( cell-&gt;cell_x &gt;= worley-&gt;cells_across )
52 				value = 0;
53 			else if( cell-&gt;cell_x &lt; 0 )
54 				value = worley-&gt;cells_across - 1;
55 			else 
56 				value = cell-&gt;cell_x;
57 			seed = vips__random_add( seed, value );
58 			if( cell-&gt;cell_y &gt;= worley-&gt;cells_down )
59 				value = 0;
60 <a name="0"></a>			else if( cell-&gt;cell_y &lt; 0 )
61 				value = worley-&gt;cells_down - 1;
62 			else 
63 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>				value = cell-&gt;cell_y;
64 			seed = vips__random_add( seed, value );
65 			cell-&gt;n_features = (seed % (MAX_FEATURES - 1)) + 1;
66 			for( j = 0; j &lt; cell-&gt;n_features; j++ ) {
67 				seed = vips__random( seed ); 
68 				cell-&gt;feature_x[j] = 
69 					cell-&gt;cell_x * worley-&gt;cell_size + 
70 					seed % worley-&gt;cell_size;
71 				seed = vips__random( seed ); 
72 				cell-&gt;feature_y[j] = 
73 					cell-&gt;cell_y * worley-&gt;cell_size + 
74 					seed % worley-&gt;cell_size;
75 			}</b></font>
76 		}
77 }
78 static int
79 vips_worley_stop( void *vseq, void *a, void *b )
80 {
81 	Sequence *seq = (Sequence *) vseq;
82 	VIPS_FREE( seq );
83 	return( 0 );
84 }
85 static void *
86 vips_worley_start( VipsImage *out, void *a, void *b )
87 {
88 	VipsWorley *worley = (VipsWorley *) b;
89 	Sequence *seq;
90 	if( !(seq = VIPS_NEW( NULL, Sequence )) )
91 		return( NULL );
92 	seq-&gt;worley = worley;
93 	seq-&gt;cell_x = -1;
94 	seq-&gt;cell_y = -1;
95 	return( seq );
96 }
97 static float
98 vips_hypot( int x, int y )
99 {
100 	return( sqrt( x * x + y * y ) );
101 }
102 static float
103 vips_worley_distance( VipsWorley *worley, Cell cells[9], int x, int y )
104 {
105 	float distance;
106 	int i, j;
107 	distance = worley-&gt;cell_size * 1.5;
108 	for( i = 0; i &lt; 9; i++ ) {
109 		Cell *cell = &amp;cells[i];
110 		for( j = 0; j &lt; cell-&gt;n_features; j++ ) {
111 			float d = vips_hypot( 
112 				x - cell-&gt;feature_x[j], 
113 				y - cell-&gt;feature_y[j] );
114 			distance = VIPS_MIN( distance, d );
115 		}
116 	}
117 	return( distance );
118 }
119 static int
120 vips_worley_gen( VipsRegion *or, void *vseq, void *a, void *b,
121 	gboolean *stop )
122 {
123 	VipsWorley *worley = (VipsWorley *) a;
124 	VipsRect *r = &amp;or-&gt;valid;
125 	Sequence *seq = (Sequence *) vseq;
126 	int x, y;
127 	for( y = 0; y &lt; r-&gt;height; y++ ) {
128 		float *q = (float *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y );
129 		for( x = 0; x &lt; r-&gt;width; x++ ) {
130 			int cell_x = (r-&gt;left + x) / worley-&gt;cell_size;
131 			int cell_y = (r-&gt;top + y) / worley-&gt;cell_size;
132 			if( cell_x != seq-&gt;cell_x ||
133 				cell_y != seq-&gt;cell_y ) {
134 				vips_worley_create_cells( worley, 
135 					seq-&gt;cells, cell_x, cell_y );
136 				seq-&gt;cell_x = cell_x;
137 				seq-&gt;cell_y = cell_y;
138 			}
139 			q[x] = vips_worley_distance( worley, seq-&gt;cells, 
140 				r-&gt;left + x, r-&gt;top + y );
141 		}
142 	}
143 	return( 0 );
144 }
145 static int
146 vips_worley_build( VipsObject *object )
147 {
148 	VipsCreate *create = VIPS_CREATE( object );
149 	VipsWorley *worley = (VipsWorley *) object;
150 	if( VIPS_OBJECT_CLASS( vips_worley_parent_class )-&gt;build( object ) )
151 		return( -1 );
152 	worley-&gt;cells_across = 
153 		VIPS_ROUND_UP( worley-&gt;width, worley-&gt;cell_size ) / 
154 		worley-&gt;cell_size;
155 	worley-&gt;cells_down = 
156 		VIPS_ROUND_UP( worley-&gt;height, worley-&gt;cell_size ) / 
157 		worley-&gt;cell_size;
158 	vips_image_init_fields( create-&gt;out,
159 		worley-&gt;width, worley-&gt;height, 1,
160 		VIPS_FORMAT_FLOAT, VIPS_CODING_NONE, 
161 		VIPS_INTERPRETATION_MULTIBAND,
162 		1.0, 1.0 );
163 	if( vips_image_pipelinev( create-&gt;out, VIPS_DEMAND_STYLE_ANY, NULL ) ||
164 		vips_image_generate( create-&gt;out,
165 			vips_worley_start, vips_worley_gen, vips_worley_stop, 
166 			worley, NULL ) )
167 		return( -1 );
168 	return( 0 );
169 }
170 static void
171 vips_worley_class_init( VipsWorleyClass *class )
172 {
173 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
174 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
175 	gobject_class-&gt;set_property = vips_object_set_property;
176 	gobject_class-&gt;get_property = vips_object_get_property;
177 	vobject_class-&gt;nickname = "worley";
178 	vobject_class-&gt;description = _( "make a worley noise image" );
179 	vobject_class-&gt;build = vips_worley_build;
180 	VIPS_ARG_INT( class, "width", 2, 
181 		_( "Width" ), 
182 		_( "Image width in pixels" ),
183 		VIPS_ARGUMENT_REQUIRED_INPUT,
184 		G_STRUCT_OFFSET( VipsWorley, width ),
185 		1, VIPS_MAX_COORD, 1 );
186 	VIPS_ARG_INT( class, "height", 3, 
187 		_( "Height" ), 
188 		_( "Image height in pixels" ),
189 		VIPS_ARGUMENT_REQUIRED_INPUT,
190 		G_STRUCT_OFFSET( VipsWorley, height ),
191 		1, VIPS_MAX_COORD, 1 );
192 	VIPS_ARG_INT( class, "cell_size", 3, 
193 		_( "Cell size" ), 
194 		_( "Size of Worley cells" ),
195 		VIPS_ARGUMENT_OPTIONAL_INPUT,
196 		G_STRUCT_OFFSET( VipsWorley, cell_size ),
197 		1, VIPS_MAX_COORD, 256 );
198 	VIPS_ARG_INT( class, "seed", 4, 
199 		_( "Seed" ), 
200 		_( "Random number seed" ),
201 		VIPS_ARGUMENT_OPTIONAL_INPUT,
202 		G_STRUCT_OFFSET( VipsWorley, seed ),
203 		INT_MIN, INT_MAX, 0 );
204 }
205 static void
206 vips_worley_init( VipsWorley *worley )
207 {
208 	worley-&gt;cell_size = 256;
209 	worley-&gt;seed = UINT_MAX * g_random_double();
210 }
211 int
212 vips_worley( VipsImage **out, int width, int height, ... )
213 {
214 	va_list ap;
215 	int result;
216 	va_start( ap, height );
217 	result = vips_call_split( "worley", ap, out, width, height );
218 	va_end( ap );
219 	return( result );
220 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>cooc_funcs.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/vips7compat.h&gt;
9 static
10 int im_cooc_sym(IMAGE *im, IMAGE *m, int xpos, int ypos, int xsize, int ysize, int dx, int dy)
11 {
12 	VipsPel *input, *cpinput;
13 	int *buf, *pnt, *cpnt;
14 	double *line, *cpline;
15 	int x, y;
16 	int offset;
17 	int bufofst;
18 	int tempA, tempB;
19 	int norm;
20 	if (im_iocheck(im, m) == -1)
21 		return( -1 );
22 	if ((im-&gt;Bands != 1)||(im-&gt;BandFmt != IM_BANDFMT_UCHAR)) {
23 		im_error( "im_cooc_sym", "%s", _( "Unable to accept input") );
24 		return(-1);
25 		}
26 	if ( (xpos + xsize + dx &gt; im-&gt;Xsize)|| (ypos + ysize + dy &gt; im-&gt;Ysize) ) { 
27 		im_error( "im_cooc_sym", "%s", _( "wrong args") ); 
28 		return(-1); }
29 	if (im_cp_desc(m, im) == -1)
30 		return( -1 );
31 	m-&gt;Xsize = 256;
32 	m-&gt;Ysize = 256;
33 	m-&gt;BandFmt = IM_BANDFMT_DOUBLE;
34 	m-&gt;Type = IM_TYPE_B_W;
35 	if (im_setupout(m) == -1)
36 		return( -1 );
37 	buf = (int *)calloc( (unsigned)m-&gt;Xsize*m-&gt;Ysize, sizeof(int) );
38 	line = (double *)calloc( (unsigned)m-&gt;Xsize * m-&gt;Bands, sizeof(double));
39 	if ( (buf == NULL) || (line == NULL) ) { 
40 		im_error( "im_cooc_sym", "%s", _( "calloc failed") ); 
41 		return(-1); }
42 	input = im-&gt;data;
43 	input += ( ypos * im-&gt;Xsize + xpos );
44 	offset = dy * im-&gt;Xsize + dx;
45 	for ( y=0; y&lt;ysize; y++ )
46 		{
47 		cpinput = input;
48 		input += im-&gt;Xsize;
49 		for ( x=0; x&lt;xsize; x++ )
50 			{
51 			tempA = (int)(*cpinput);
52 			tempB = (int)(*(cpinput + offset));
53 			bufofst = tempA + m-&gt;Xsize * tempB;
54 			(*(buf + bufofst))++;
55 			bufofst = tempB + m-&gt;Xsize * tempA;
56 			(*(buf + bufofst))++;
57 			cpinput++;
58 			}
59 		}
60 	norm = xsize * ysize * 2;
61 	pnt = buf;
62 	for ( y=0; y&lt;m-&gt;Ysize; y++ )
63 		{
64 		cpnt = pnt;
65 		pnt += m-&gt;Xsize;
66 		cpline = line;
67 		for (x=0; x&lt;m-&gt;Xsize; x++)
68 			*cpline++ = (double)(*cpnt++)/(double)norm;
69 		if (im_writeline( y, m, (VipsPel *) line ) == -1) 
70 			{
71 			im_error( "im_cooc_sym", "%s", _( "unable to im_writeline") );
72 			return(-1);
73 			}
74 		}
75 	free((char*)buf);
76 	free((char*)line);
77 	return(0);
78 }
79 static
80 int im_cooc_ord(IMAGE *im, IMAGE *m, int xpos, int ypos, int xsize, int ysize, int dx, int dy)
81 {
82 	VipsPel *input, *cpinput;
83 	int *buf, *pnt, *cpnt;
84 	double *line, *cpline;
85 	int x, y;
86 	int offset;
87 	int bufofst;
88 	int tempA, tempB;
89 	int norm;
90 	if (im_iocheck(im, m) == -1)
91 		return( -1 );
92 	if ((im-&gt;Bands != 1)||(im-&gt;BandFmt != IM_BANDFMT_UCHAR))
93 		{
94 		im_error( "im_cooc_ord", "%s", _( "Unable to accept input") );
95 		return(-1);
96 		}
97 	if ( (xpos + xsize + dx &gt; im-&gt;Xsize)|| (ypos + ysize + dy &gt; im-&gt;Ysize) ) { 
98 		im_error( "im_cooc_ord", "%s", _( "wrong args") ); 
99 		return(-1); }
100 	if (im_cp_desc(m, im) == -1)
101 		return( -1 );
102 	m-&gt;Xsize = 256;
103 	m-&gt;Ysize = 256;
104 	m-&gt;BandFmt = IM_BANDFMT_DOUBLE;
105 	if (im_setupout(m) == -1)
106 		return( -1 );
107 	buf = (int *)calloc( (unsigned)m-&gt;Xsize*m-&gt;Ysize, sizeof(int) );
108 	line = (double *)calloc( (unsigned)m-&gt;Xsize * m-&gt;Bands, sizeof(double));
109 	if ( (buf == NULL) || (line == NULL) ) { 
110 		im_error( "im_cooc_ord", "%s", _( "calloc failed") ); 
111 		return(-1); }
112 	input = im-&gt;data;
113 	input += ( ypos * im-&gt;Xsize + xpos );
114 	offset = dy * im-&gt;Xsize + dx;
115 	for ( y=0; y&lt;ysize; y++ )
116 		{
117 		cpinput = input;
118 		input += im-&gt;Xsize;
119 		for ( x=0; x&lt;xsize; x++ )
120 			{
121 			tempA = (int)(*cpinput);
122 			tempB = (int)(*(cpinput + offset));
123 			bufofst = tempA + m-&gt;Xsize * tempB;
124 			(*(buf + bufofst))++;
125 			cpinput++;
126 			}
127 		}
128 	norm = xsize * ysize;
129 	pnt = buf;
130 	for ( y=0; y&lt;m-&gt;Ysize; y++ )
131 		{
132 		cpnt = pnt;
133 		pnt += m-&gt;Xsize;
134 		cpline = line;
135 		for (x=0; x&lt;m-&gt;Xsize; x++)
136 			*cpline++ = (double)(*cpnt++)/(double)norm;
137 		if (im_writeline( y, m, (PEL *) line ) == -1) 
138 			{
139 			im_error( "im_cooc_ord", "%s", _( "unable to im_writeline") );
140 			return(-1);
141 			}
142 		}
143 	free((char*)buf);
144 	free((char*)line);
145 	return(0);
146 }
147 int 
148 im_cooc_matrix( IMAGE *im, IMAGE *m, 
149 	int xp, int yp, int xs, int ys, int dx, int dy, int flag )
150 {
151 	if (flag == 0)
152 		return( im_cooc_ord(im, m, xp, yp, xs, ys, dx, dy) );
153 	else if (flag == 1)			return( im_cooc_sym(im, m, xp, yp, xs, ys, dx, dy) );
154 	else { 
155 		im_error( "im_cooc_matrix", "%s", _( "wrong flag!") ); 
156 		return(-1); }
157 }
158 int 
159 im_cooc_asm( IMAGE *m, double *asmoment )
160 {
161 	double temp, tmpasm, *pnt;
162 	int i;
163 	if( im_incheck( m ) )
164 		return( -1 );
165 	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
166 		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
167 		{
168 		im_error( "im_cooc_asm", "%s", _( "unable to accept input") );
169 		return(-1);
170 		}
171 	tmpasm = 0.0;
172 	pnt = (double*)m-&gt;data;
173 	for(i=0; i&lt;m-&gt;Xsize * m-&gt;Ysize; i++)
174 		{
175 		temp = *pnt++;
176 		tmpasm += temp * temp;
177 		}
178 	*asmoment = tmpasm;
179 	return(0);
180 }
181 int 
182 im_cooc_contrast( IMAGE *m, double *contrast )
183 {
184 	double dtemp, tmpcon, *pnt, *cpnt;
185 	int x, y;
186 	if( im_incheck( m ) )
187 		return( -1 );
188 	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
189 		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
190 		{
191 		im_error( "im_cooc_contrast", "%s", _( "unable to accept input") );
192 		return(-1);
193 		}
194 	tmpcon = 0.0;
195 	pnt = (double*)m-&gt;data;
196 	for(y=0; y&lt;m-&gt;Ysize; y++)
197 		{
198 		cpnt = pnt;
199 		pnt += m-&gt;Xsize;
200 		for(x=0; x&lt;m-&gt;Xsize; x++)
201 			{
202 			dtemp = (double)( (y-x)*(y-x) );
203 			tmpcon += dtemp * (*cpnt);
204 			cpnt++;
205 			}
206 		}
207 	*contrast = tmpcon;
208 	return(0);
209 }
210 static void 
211 stats(double *buffer, int size, double *pmean, double *pstd)
212 {
213 	double mean, std;
214 	register int i;
215 	double sumf;		double temp;		double *pbuffer;
216 	double sumf2;		double correction; <a name="0"></a>	double variance;		
217 	mean = 0.0; std = 0.0;
218 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	sumf = 0.0; sumf2 = 0.0;
219 	pbuffer = buffer;
220 	for (i=0; i&lt;size; i++)
221 		{
222 		temp = *pbuffer++;
223 		sumf += (temp*i);
224 		sumf2 += (temp*i*i);
225 		}</b></font>
226 	correction = sumf*sumf;
227 	mean = sumf;
228 	variance = sumf2-correction;
229 	std = sqrt(variance);
230 	*pmean = mean;
231 	*pstd = std;
232 }
233 int 
234 im_cooc_correlation( IMAGE *m, double *correlation )
235 {
236 	double mcol, stdcol, mrow, stdrow; 	double *pbuf;
237 	double *cpbuf;
238 	double dtemp;
239 	register int i,j;
240 	double *row;		double *col;		double tmpcor=0.0;
241 	double sum = 0.0;
242 	if( im_incheck( m ) )
243 		return( -1 );
244 	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
245 		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
246 		{
247 		im_error( "im_cooc_correlation", "%s", _( "unable to accept input") );
248 		return(-1);
249 		}
250 	row = (double*)calloc( (unsigned)m-&gt;Ysize, sizeof(double));
251 	col = (double*)calloc( (unsigned)m-&gt;Xsize, sizeof(double));
252 	if ( row == NULL || col == NULL )
253 		{
254 		im_error( "im_cooc_correlation", "%s", _( "unable to calloc") );
255 		return(-1);
256 		}
257 	pbuf = (double*)m-&gt;data;
258 	for(j=0; j&lt;m-&gt;Ysize; j++)
259 		{
260 		cpbuf = pbuf;
261 		pbuf += m-&gt;Xsize;
262 		sum=0.0;
263 		for(i=0; i&lt;m-&gt;Xsize; i++)
264 			sum += *cpbuf++;
265 		*(row+j) = sum;
266 		}
267 	pbuf = (double*)m-&gt;data;
268 	for(j=0; j&lt;m-&gt;Ysize; j++)
269 		{
270 		cpbuf = pbuf;
271 		pbuf++;
272 		sum=0.0;
273 		for(i=0; i&lt;m-&gt;Xsize; i++)
274 			{
275 			sum += *cpbuf;
276 			cpbuf += m-&gt;Xsize;
277 			}
278 		*(col+j) = sum;
279 		}
280 	stats(row, m-&gt;Ysize, &amp;mrow, &amp;stdrow);
281 	stats(col, m-&gt;Ysize ,&amp;mcol, &amp;stdcol);
282 #ifdef DEBUG
283 	fprintf(stderr, "rows: mean=%f std=%f\ncols: mean=%f std=%f\n",
284 mrow, stdrow, mcol, stdcol);
285 #endif
286 	tmpcor = 0.0;
287 	pbuf = (double*)m-&gt;data;
288 	for(j=0; j&lt;m-&gt;Ysize; j++)
289 		{
290 		cpbuf = pbuf;
291 		pbuf += m-&gt;Xsize;
292 		for(i=0; i&lt;m-&gt;Xsize; i++)
293 			{
294 			dtemp = *cpbuf;
295 			tmpcor += ( ((double)i)*((double)j)*dtemp);
296 			cpbuf++;
297 			}
298 		}
299 #ifdef DEBUG
300 	fprintf(stderr, "tmpcor=%f\n", tmpcor);
301 #endif
302 	if ( (stdcol==0.0)||(stdrow==0) )
303 		{
304 		im_error( "im_cooc_correlation", "%s", _( "zero std") );
305 		return(-1);
306 		}
307 	tmpcor = (tmpcor-(mcol*mrow))/(stdcol*stdrow);
308 	*correlation = tmpcor;
309 	free((char*)row); free((char*)col);
310 	return(0);
311 }
312 int 
313 im_cooc_entropy( IMAGE *m, double *entropy )
314 {
315 	double *pbuf, *pbufstart;
316 	double *cpbuf;
317 	register int i,j;
318 	double tmpent, dtemp;
319 	double val;
320 	if( im_incheck( m ) )
321 		return( -1 );
322 	if (m-&gt;Xsize != 256 || m-&gt;Ysize != 256 || 
323 		m-&gt;Bands != 1 || m-&gt;BandFmt != IM_BANDFMT_DOUBLE)
324 		{
325 		im_error( "im_cooc_entropy", "%s", _( "unable to accept input") );
326 		return(-1);
327 		}
328 	pbufstart = (double*)m-&gt;data;
329 	tmpent = 0.0;
330 	pbuf = pbufstart;
331 	for(j=0; j&lt;m-&gt;Ysize; j++)
332 		{
333 		cpbuf = pbuf;
334 		pbuf += m-&gt;Xsize;
335 		for(i=0; i&lt;m-&gt;Xsize; i++)
336 			{
337 			if(*cpbuf != 0)
338 				{
339 				dtemp = *cpbuf;
340 				tmpent += (dtemp*log10(dtemp));
341 				}
342 			cpbuf++;
343 			}
344 		}
345 	val = tmpent*(-1);
346 #ifdef DEBUG
347 	fprintf(stderr,"ENT=%f\nwhich is %f bits\n", val, val/log10(2.0) );
348 #endif
349 	*entropy = (val/log10(2.0));
350 	return(0);
351 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
