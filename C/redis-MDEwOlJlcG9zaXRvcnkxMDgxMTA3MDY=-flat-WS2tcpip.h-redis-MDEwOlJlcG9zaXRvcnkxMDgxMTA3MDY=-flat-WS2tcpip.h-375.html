
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 33, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-WS2tcpip.h</h3>
            <pre><code>1  #ifndef _WS2TCPIP_H_
2  #define _WS2TCPIP_H_
3  #if _MSC_VER &gt; 1000
4  #pragma once
5  #endif
6  #if WINVER &lt;= _WIN32_WINNT_WS03
7  #include &quot;win32_winapifamily.h&quot;
8  #else
9  #include &lt;winapifamily.h&gt;
10  #endif
11  #pragma region Desktop Family
12  #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
13  #include &lt;winsock2.h&gt;
14  #include &lt;ws2ipdef.h&gt;
15  #include &lt;limits.h&gt;
16  #define UDP_NOCHECKSUM  1
17  #define UDP_CHECKSUM_COVERAGE   20  &amp;bsol;* Set/get UDP-Lite checksum coverage */
18  #ifdef _MSC_VER
19  #define WS2TCPIP_INLINE __inline
20  #else
21  #define WS2TCPIP_INLINE extern inline &amp;bsol;* GNU style */
22  #endif
23  #define EAI_AGAIN           WSATRY_AGAIN
24  #define EAI_BADFLAGS        WSAEINVAL
25  #define EAI_FAIL            WSANO_RECOVERY
26  #define EAI_FAMILY          WSAEAFNOSUPPORT
27  #define EAI_MEMORY          WSA_NOT_ENOUGH_MEMORY
28  #define EAI_NOSECURENAME    WSA_SECURE_HOST_NOT_FOUND
29  #define EAI_NONAME          WSAHOST_NOT_FOUND
30  #define EAI_SERVICE         WSATYPE_NOT_FOUND
31  #define EAI_SOCKTYPE        WSAESOCKTNOSUPPORT
32  #define EAI_IPSECPOLICY     WSA_IPSEC_NAME_POLICY_ERROR
33  #define EAI_NODATA      EAI_NONAME
34  #ifdef UNICODE
35  typedef ADDRINFOW       ADDRINFOT, *PADDRINFOT;
36  #else
37  typedef ADDRINFOA       ADDRINFOT, *PADDRINFOT;
38  #endif
39  typedef ADDRINFOA       ADDRINFO, FAR * LPADDRINFO;
40  #if (_WIN32_WINNT &gt;= 0x0600)
41  #ifdef UNICODE
42  typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
43  #else
44  typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
45  #endif
46  #endif
47  #ifdef __cplusplus
48  extern &quot;C&quot; {
49  #endif
50  #if INCL_WINSOCK_API_TYPEDEFS
51  WINSOCK_API_LINKAGE
52  INT
53  WSAAPI
54  getaddrinfo(
55      _In_opt_        PCSTR               pNodeName,
56      _In_opt_        PCSTR               pServiceName,
57      _In_opt_        const ADDRINFOA *   pHints,
58      _Outptr_     PADDRINFOA *        ppResult
59      );
60  #if (NTDDI_VERSION &gt;= NTDDI_WINXPSP2) || (_WIN32_WINNT &gt;= 0x0502)
61  WINSOCK_API_LINKAGE
62  INT
63  WSAAPI
64  GetAddrInfoW(
65      _In_opt_        PCWSTR              pNodeName,
66      _In_opt_        PCWSTR              pServiceName,
<span onclick='openModal()' class='match'>67      _In_opt_        const ADDRINFOW *   pHints,
68      _Outptr_     PADDRINFOW *        ppResult
69      );
70  #define GetAddrInfoA    getaddrinfo
71  #ifdef UNICODE
72  #define GetAddrInfo     GetAddrInfoW
73  #else
74  #define GetAddrInfo     GetAddrInfoA
75  #endif
76  #endif
77  #endif
</span>78  #if INCL_WINSOCK_API_TYPEDEFS
79  typedef
80  INT
81  (WSAAPI * LPFN_GETADDRINFO)(
82      _In_opt_        PCSTR               pNodeName,
83      _In_opt_        PCSTR               pServiceName,
84      _In_opt_        const ADDRINFOA *   pHints,
85      _Outptr_     PADDRINFOA *        ppResult
86      );
87  typedef
88  INT
89  (WSAAPI * LPFN_GETADDRINFOW)(
90      _In_opt_        PCWSTR              pNodeName,
91      _In_opt_        PCWSTR              pServiceName,
92      _In_opt_        const ADDRINFOW *   pHints,
93      _Outptr_     PADDRINFOW *        ppResult
94      );
95  #define LPFN_GETADDRINFOA      LPFN_GETADDRINFO
96  #ifdef UNICODE
97  #define LPFN_GETADDRINFOT      LPFN_GETADDRINFOW
98  #else
99  #define LPFN_GETADDRINFOT      LPFN_GETADDRINFOA
100  #endif
101  #endif
102  #if (_WIN32_WINNT &gt;= 0x0600)
103  typedef
104  void
105  (CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(
106      _In_      DWORD    dwError,
107      _In_      DWORD    dwBytes,
108      _In_      LPWSAOVERLAPPED lpOverlapped
109      );
110  WINSOCK_API_LINKAGE
111  INT
112  WSAAPI
113  GetAddrInfoExA(
114      _In_opt_    PCSTR           pName,
115      _In_opt_    PCSTR           pServiceName,
116      _In_        DWORD           dwNameSpace,
117      _In_opt_    LPGUID          lpNspId,
118      _In_opt_    const ADDRINFOEXA *hints,
119      _Outptr_ PADDRINFOEXA *  ppResult,
120      _In_opt_    struct timeval *timeout,
121      _In_opt_    LPOVERLAPPED    lpOverlapped,
122      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
123      _Out_opt_   LPHANDLE        lpNameHandle
124      );
125  WINSOCK_API_LINKAGE
126  INT
127  WSAAPI
128  GetAddrInfoExW(
129      _In_opt_    PCWSTR          pName,
130      _In_opt_    PCWSTR          pServiceName,
131      _In_        DWORD           dwNameSpace,
132      _In_opt_    LPGUID          lpNspId,
133      _In_opt_    const ADDRINFOEXW *hints,
134      _Outptr_ PADDRINFOEXW *  ppResult,
135      _In_opt_    struct timeval *timeout,
136      _In_opt_    LPOVERLAPPED    lpOverlapped,
137      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
138      _Out_opt_   LPHANDLE        lpHandle
139      );
140  WINSOCK_API_LINKAGE
141  INT
142  WSAAPI
143  GetAddrInfoExCancel(
144      _In_        LPHANDLE        lpHandle
145      );
146  WINSOCK_API_LINKAGE
147  INT
148  WSAAPI
149  GetAddrInfoExOverlappedResult(
150      _In_        LPOVERLAPPED    lpOverlapped
151      );
152  #ifdef UNICODE
153  #define GetAddrInfoEx       GetAddrInfoExW
154  #else
155  #define GetAddrInfoEx       GetAddrInfoExA
156  #endif
157  #if INCL_WINSOCK_API_TYPEDEFS
158  typedef
159  INT
160  (WSAAPI *LPFN_GETADDRINFOEXA)(
161      _In_        PCSTR           pName,
162      _In_opt_    PCSTR           pServiceName,
163      _In_        DWORD           dwNameSpace,
164      _In_opt_    LPGUID          lpNspId,
165      _In_opt_    const ADDRINFOEXA *hints,
166      _Outptr_ PADDRINFOEXA   *ppResult,
167      _In_opt_    struct timeval *timeout,
168      _In_opt_    LPOVERLAPPED    lpOverlapped,
169      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
170      _Out_opt_   LPHANDLE        lpNameHandle
171      );
172  typedef
173  INT
174  (WSAAPI *LPFN_GETADDRINFOEXW)(
175      _In_        PCWSTR          pName,
176      _In_opt_    PCWSTR          pServiceName,
177      _In_        DWORD           dwNameSpace,
178      _In_opt_    LPGUID          lpNspId,
179      _In_opt_    const ADDRINFOEXW *hints,
180      _Outptr_ PADDRINFOEXW   *ppResult,
181      _In_opt_    struct timeval *timeout,
182      _In_opt_    LPOVERLAPPED    lpOverlapped,
183      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
184      _Out_opt_   LPHANDLE        lpHandle
185      );
186  typedef
187  INT
188  (WSAAPI *LPFN_GETADDRINFOEXCANCEL)(
189      _In_        LPHANDLE        lpHandle
190      );
191  typedef
192  INT
193  (WSAAPI *LPFN_GETADDRINFOEXOVERLAPPEDRESULT)(
194      _In_        LPOVERLAPPED    lpOverlapped
195      );
196  #ifdef UNICODE
197  #define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXW
198  #else
199  #define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXA
200  #endif
201  #endif
202  #endif
203  #if (_WIN32_WINNT &gt;= 0x0600)
204  WINSOCK_API_LINKAGE
205  INT
206  WSAAPI
207  SetAddrInfoExA(
208      _In_        PCSTR           pName,
209      _In_opt_    PCSTR           pServiceName,
210      _In_opt_    SOCKET_ADDRESS *pAddresses,
211      _In_        DWORD           dwAddressCount,
212      _In_opt_    LPBLOB          lpBlob,
213      _In_        DWORD           dwFlags,
214      _In_        DWORD           dwNameSpace,
215      _In_opt_    LPGUID          lpNspId,
216      _In_opt_    struct timeval *timeout,
217      _In_opt_    LPOVERLAPPED    lpOverlapped,
218      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
219      _Out_opt_   LPHANDLE        lpNameHandle
220      );
221  WINSOCK_API_LINKAGE
222  INT
223  WSAAPI
224  SetAddrInfoExW(
225      _In_        PCWSTR          pName,
226      _In_opt_    PCWSTR          pServiceName,
227      _In_opt_    SOCKET_ADDRESS *pAddresses,
228      _In_        DWORD           dwAddressCount,
229      _In_opt_    LPBLOB          lpBlob,
230      _In_        DWORD           dwFlags,
231      _In_        DWORD           dwNameSpace,
232      _In_opt_    LPGUID          lpNspId,
233      _In_opt_    struct timeval *timeout,
234      _In_opt_    LPOVERLAPPED    lpOverlapped,
235      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
236      _Out_opt_   LPHANDLE        lpNameHandle
237      );
238  #ifdef UNICODE
239  #define SetAddrInfoEx       SetAddrInfoExW
240  #else
241  #define SetAddrInfoEx       SetAddrInfoExA
242  #endif
243  #if INCL_WINSOCK_API_TYPEDEFS
244  typedef
245  INT
246  (WSAAPI *LPFN_SETADDRINFOEXA)(
247      _In_        PCSTR           pName,
248      _In_opt_    PCSTR           pServiceName,
249      _In_opt_    SOCKET_ADDRESS *pAddresses,
250      _In_        DWORD           dwAddressCount,
251      _In_opt_    LPBLOB          lpBlob,
252      _In_        DWORD           dwFlags,
253      _In_        DWORD           dwNameSpace,
254      _In_opt_    LPGUID          lpNspId,
255      _In_opt_    struct timeval *timeout,
256      _In_opt_    LPOVERLAPPED    lpOverlapped,
257      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
258      _Out_opt_   LPHANDLE        lpNameHandle
259      );
260  typedef
261  INT
262  (WSAAPI *LPFN_SETADDRINFOEXW)(
263      _In_        PCWSTR          pName,
264      _In_opt_    PCWSTR          pServiceName,
265      _In_opt_    SOCKET_ADDRESS *pAddresses,
266      _In_        DWORD           dwAddressCount,
267      _In_opt_    LPBLOB          lpBlob,
268      _In_        DWORD           dwFlags,
269      _In_        DWORD           dwNameSpace,
270      _In_opt_    LPGUID          lpNspId,
271      _In_opt_    struct timeval *timeout,
272      _In_opt_    LPOVERLAPPED    lpOverlapped,
273      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
274      _Out_opt_   LPHANDLE        lpNameHandle
275      );
276  #ifdef UNICODE
277  #define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXW
278  #else
279  #define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXA
280  #endif
281  #endif
282  #endif
283  #if INCL_WINSOCK_API_TYPEDEFS
284  WINSOCK_API_LINKAGE
285  VOID
286  WSAAPI
287  freeaddrinfo(
288      _In_opt_        PADDRINFOA      pAddrInfo
289      );
290  #if (NTDDI_VERSION &gt;= NTDDI_WINXPSP2) || (_WIN32_WINNT &gt;= 0x0502)
291  WINSOCK_API_LINKAGE
292  VOID
293  WSAAPI
294  FreeAddrInfoW(
295      _In_opt_        PADDRINFOW      pAddrInfo
296      );
297  #endif
298  #define FreeAddrInfoA   freeaddrinfo
299  #ifdef UNICODE
300  #define FreeAddrInfo    FreeAddrInfoW
301  #else
302  #define FreeAddrInfo    FreeAddrInfoA
303  #endif
304  #endif
305  #if INCL_WINSOCK_API_TYPEDEFS
306  typedef
307  VOID
308  (WSAAPI * LPFN_FREEADDRINFO)(
309      _In_opt_        PADDRINFOA      pAddrInfo
310      );
311  typedef
312  VOID
313  (WSAAPI * LPFN_FREEADDRINFOW)(
314      _In_opt_        PADDRINFOW      pAddrInfo
315      );
316  #define LPFN_FREEADDRINFOA      LPFN_FREEADDRINFO
317  #ifdef UNICODE
318  #define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOW
319  #else
320  #define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOA
321  #endif
322  #endif
323  #if (_WIN32_WINNT &gt;= 0x0600)
324  WINSOCK_API_LINKAGE
325  void
326  WSAAPI
327  FreeAddrInfoEx(
328      _In_opt_  PADDRINFOEXA    pAddrInfoEx
329      );
330  WINSOCK_API_LINKAGE
331  void
332  WSAAPI
333  FreeAddrInfoExW(
334      _In_opt_  PADDRINFOEXW    pAddrInfoEx
335      );
336  #define FreeAddrInfoExA     FreeAddrInfoEx
337  #ifdef UNICODE
338  #define FreeAddrInfoEx      FreeAddrInfoExW
339  #endif
340  #ifdef INCL_WINSOCK_API_TYPEDEFS
341  typedef
342  void
343  (WSAAPI *LPFN_FREEADDRINFOEXA)(
344      _In_    PADDRINFOEXA    pAddrInfoEx
345      );
346  typedef
347  void
348  (WSAAPI *LPFN_FREEADDRINFOEXW)(
349      _In_    PADDRINFOEXW    pAddrInfoEx
350      );
351  #ifdef UNICODE
352  #define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXW
353  #else
354  #define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXA
355  #endif
356  #endif
357  #endif
358  typedef int socklen_t;
359  WINSOCK_API_LINKAGE
360  INT
361  WSAAPI
362  getnameinfo(
363      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
364      _In_                                socklen_t           SockaddrLength,
365      _Out_writes_opt_(NodeBufferSize)    PCHAR               pNodeBuffer,
366      _In_                                DWORD               NodeBufferSize,
367      _Out_writes_opt_(ServiceBufferSize) PCHAR               pServiceBuffer,
368      _In_                                DWORD               ServiceBufferSize,
369      _In_                                INT                 Flags
370      );
371  #if (NTDDI_VERSION &gt;= NTDDI_WINXPSP2) || (_WIN32_WINNT &gt;= 0x0502)
372  WINSOCK_API_LINKAGE
373  INT
374  WSAAPI
375  GetNameInfoW(
376      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
377      _In_                                socklen_t           SockaddrLength,
378      _Out_writes_opt_(NodeBufferSize)    PWCHAR              pNodeBuffer,
379      _In_                                DWORD               NodeBufferSize,
380      _Out_writes_opt_(ServiceBufferSize) PWCHAR              pServiceBuffer,
381      _In_                                DWORD               ServiceBufferSize,
382      _In_                                INT                 Flags
383      );
384  #define GetNameInfoA    getnameinfo
385  #ifdef UNICODE
386  #define GetNameInfo     GetNameInfoW
387  #else
388  #define GetNameInfo     GetNameInfoA
389  #endif
390  #endif
391  #if INCL_WINSOCK_API_TYPEDEFS
392  typedef
393  int
394  (WSAAPI * LPFN_GETNAMEINFO)(
395      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
396      _In_                                socklen_t           SockaddrLength,
397      _Out_writes_opt_(NodeBufferSize)    PCHAR               pNodeBuffer,
398      _In_                                DWORD               NodeBufferSize,
399      _Out_writes_opt_(ServiceBufferSize) PCHAR               pServiceBuffer,
400      _In_                                DWORD               ServiceBufferSize,
401      _In_                                INT                 Flags
402      );
403  typedef
404  INT
405  (WSAAPI * LPFN_GETNAMEINFOW)(
406      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
407      _In_                                socklen_t           SockaddrLength,
408      _Out_writes_opt_(NodeBufferSize)    PWCHAR              pNodeBuffer,
409      _In_                                DWORD               NodeBufferSize,
410      _Out_writes_opt_(ServiceBufferSize) PWCHAR              pServiceBuffer,
411      _In_                                DWORD               ServiceBufferSize,
412      _In_                                INT                 Flags
413      );
414  #define LPFN_GETNAMEINFOA      LPFN_GETNAMEINFO
415  #ifdef UNICODE
416  #define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOW
417  #else
418  #define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOA
419  #endif
420  #endif
421  #if (NTDDI_VERSION &gt;= NTDDI_VISTA)
422  #if INCL_WINSOCK_API_TYPEDEFS
423  WINSOCK_API_LINKAGE
424  INT
425  WSAAPI
426  inet_pton(
427      _In_                                INT             Family,
428      _In_                                PCSTR           pszAddrString,
429      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
430      );
431  INT
432  WSAAPI
433  InetPtonW(
434      _In_                                INT             Family,
435      _In_                                PCWSTR          pszAddrString,
436      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
437      );
438  PCSTR
439  WSAAPI
440  inet_ntop(
441      _In_                                INT             Family,
442      _In_                                PVOID           pAddr,
443      _Out_writes_(StringBufSize)         PSTR            pStringBuf,
444      _In_                                size_t          StringBufSize
445      );
446  PCWSTR
447  WSAAPI
448  InetNtopW(
449      _In_                                INT             Family,
450      _In_                                PVOID           pAddr,
451      _Out_writes_(StringBufSize)         PWSTR           pStringBuf,
452      _In_                                size_t          StringBufSize
453      );
454  #define InetPtonA       inet_pton
455  #define InetNtopA       inet_ntop
456  #ifdef UNICODE
457  #define InetPton        InetPtonW
458  #define InetNtop        InetNtopW
459  #else
460  #define InetPton        InetPtonA
461  #define InetNtop        InetNtopA
462  #endif
463  #endif
464  #if INCL_WINSOCK_API_TYPEDEFS
465  typedef
466  INT
467  (WSAAPI * LPFN_INET_PTONA)(
468      _In_                                INT             Family,
469      _In_                                PCSTR           pszAddrString,
470      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
471      );
472  typedef
473  INT
474  (WSAAPI * LPFN_INET_PTONW)(
475      _In_                                INT             Family,
476      _In_                                PCWSTR          pszAddrString,
477      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
478      );
479  typedef
480  PCSTR
481  (WSAAPI * LPFN_INET_NTOPA)(
482      _In_                                INT             Family,
483      _In_                                PVOID           pAddr,
484      _Out_writes_(StringBufSize)         PSTR            pStringBuf,
485      _In_                                size_t          StringBufSize
486      );
487  typedef
488  PCWSTR
489  (WSAAPI * LPFN_INET_NTOPW)(
490      _In_                                INT             Family,
491      _In_                                PVOID           pAddr,
492      _Out_writes_(StringBufSize)         PWSTR           pStringBuf,
493      _In_                                size_t          StringBufSize
494      );
495  #ifdef UNICODE
496  #define LPFN_INET_PTON          LPFN_INET_PTONW
497  #define LPFN_INET_NTOP          LPFN_INET_NTOPW
498  #else
499  #define LPFN_INET_PTON          LPFN_INET_PTONA
500  #define LPFN_INET_NTOP          LPFN_INET_NTOPA
501  #endif
502  #endif  
503  #endif  
504  #if INCL_WINSOCK_API_PROTOTYPES
505  #ifdef UNICODE
506  #define gai_strerror   gai_strerrorW
507  #else
508  #define gai_strerror   gai_strerrorA
509  #endif  &amp;bsol;* UNICODE */
510  #define GAI_STRERROR_BUFFER_SIZE 1024
511  WS2TCPIP_INLINE
512  char *
513  gai_strerrorA(
514      _In_ int ecode)
515  {
516      DWORD dwMsgLen;
517      static char buff[GAI_STRERROR_BUFFER_SIZE + 1];
518      dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
519                               |FORMAT_MESSAGE_IGNORE_INSERTS
520                               |FORMAT_MESSAGE_MAX_WIDTH_MASK,
521                                NULL,
522                                ecode,
523                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
524                                (LPSTR)buff,
525                                GAI_STRERROR_BUFFER_SIZE,
526                                NULL);
527      return buff;
528  }
529  WS2TCPIP_INLINE
530  WCHAR *
531  gai_strerrorW(
532      _In_ int ecode
533      )
534  {
535      DWORD dwMsgLen;
536      static WCHAR buff[GAI_STRERROR_BUFFER_SIZE + 1];
537      dwMsgLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
538                               |FORMAT_MESSAGE_IGNORE_INSERTS
539                               |FORMAT_MESSAGE_MAX_WIDTH_MASK,
540                                NULL,
541                                ecode,
542                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
543                                (LPWSTR)buff,
544                                GAI_STRERROR_BUFFER_SIZE,
545                                NULL);
546      return buff;
547  }
548  #endif &amp;bsol;* INCL_WINSOCK_API_PROTOTYPES */
549  #if INCL_WINSOCK_API_PROTOTYPES
550  WS2TCPIP_INLINE
551  int
552  setipv4sourcefilter(
553      _In_ SOCKET Socket,
554      _In_ IN_ADDR Interface,
555      _In_ IN_ADDR Group,
556      _In_ MULTICAST_MODE_TYPE FilterMode,
557      _In_ ULONG SourceCount,
558      _In_reads_(SourceCount) CONST IN_ADDR *SourceList
559      )
560  {
561      int Error;
562      DWORD Size, Returned;
563      PIP_MSFILTER Filter;
564      if (SourceCount &gt;
565          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
566          WSASetLastError(WSAENOBUFS);
567          return SOCKET_ERROR;
568      }
569      Size = IP_MSFILTER_SIZE(SourceCount);
570      Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
571      if (Filter == NULL) {
572          WSASetLastError(WSAENOBUFS);
573          return SOCKET_ERROR;
574      }
575      Filter-&gt;imsf_multiaddr = Group;
576      Filter-&gt;imsf_interface = Interface;
577      Filter-&gt;imsf_fmode = FilterMode;
578      Filter-&gt;imsf_numsrc = SourceCount;
579      if (SourceCount &gt; 0) {
580          CopyMemory(Filter-&gt;imsf_slist, SourceList,
581                     SourceCount * sizeof(*SourceList));
582      }
583      Error = WSAIoctl(Socket, SIOCSIPMSFILTER, Filter, Size, NULL, 0,
584                       &amp;Returned, NULL, NULL);
585      HeapFree(GetProcessHeap(), 0, Filter);
586      return Error;
587  }
588  _Success_(return == 0)
589  WS2TCPIP_INLINE
590  int
591  getipv4sourcefilter(
592      _In_ SOCKET Socket,
593      _In_ IN_ADDR Interface,
594      _In_ IN_ADDR Group,
595      _Out_ MULTICAST_MODE_TYPE *FilterMode,
596      _Inout_ ULONG *SourceCount,
597      _Out_writes_(*SourceCount) IN_ADDR *SourceList
598      )
599  {
600      int Error;
601      DWORD Size, Returned;
602      PIP_MSFILTER Filter;
603      if (*SourceCount &gt;
604          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
605          WSASetLastError(WSAENOBUFS);
606          return SOCKET_ERROR;
607      }
608      Size = IP_MSFILTER_SIZE(*SourceCount);
609      Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
610      if (Filter == NULL) {
611          WSASetLastError(WSAENOBUFS);
612          return SOCKET_ERROR;
613      }
614      Filter-&gt;imsf_multiaddr = Group;
615      Filter-&gt;imsf_interface = Interface;
616      Filter-&gt;imsf_numsrc = *SourceCount;
617      Error = WSAIoctl(Socket, SIOCGIPMSFILTER, Filter, Size, Filter, Size,
618                       &amp;Returned, NULL, NULL);
619      if (Error == 0) {
620          if (*SourceCount &gt; 0) {
621              CopyMemory(SourceList, Filter-&gt;imsf_slist,
622                         *SourceCount * sizeof(*SourceList));
623              *SourceCount = Filter-&gt;imsf_numsrc;
624          }
625          *FilterMode = Filter-&gt;imsf_fmode;
626      }
627      HeapFree(GetProcessHeap(), 0, Filter);
628      return Error;
629  }
630  #endif &amp;bsol;* INCL_WINSOCK_API_PROTOTYPES */
631  #if (NTDDI_VERSION &gt;= NTDDI_WINXP)
632  #if INCL_WINSOCK_API_PROTOTYPES
633  WS2TCPIP_INLINE
634  int
635  setsourcefilter(
636      _In_ SOCKET Socket,
637      _In_ ULONG Interface,
638      _In_ CONST SOCKADDR *Group,
639      _In_ int GroupLength,
640      _In_ MULTICAST_MODE_TYPE FilterMode,
641      _In_ ULONG SourceCount,
642      _In_reads_(SourceCount) CONST SOCKADDR_STORAGE *SourceList
643      )
644  {
645      int Error;
646      DWORD Size, Returned;
647      PGROUP_FILTER Filter;
648      if (SourceCount &gt;=
649          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
650          WSASetLastError(WSAENOBUFS);
651          return SOCKET_ERROR;
652      }
653      Size = GROUP_FILTER_SIZE(SourceCount);
654      Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
655      if (Filter == NULL) {
656          WSASetLastError(WSAENOBUFS);
657          return SOCKET_ERROR;
658      }
659      Filter-&gt;gf_interface = Interface;
660      ZeroMemory(&amp;Filter-&gt;gf_group, sizeof(Filter-&gt;gf_group));
661      CopyMemory(&amp;Filter-&gt;gf_group, Group, GroupLength);
662      Filter-&gt;gf_fmode = FilterMode;
663      Filter-&gt;gf_numsrc = SourceCount;
664      if (SourceCount &gt; 0) {
665          CopyMemory(Filter-&gt;gf_slist, SourceList,
666                     SourceCount * sizeof(*SourceList));
667      }
668      Error = WSAIoctl(Socket, SIOCSMSFILTER, Filter, Size, NULL, 0,
669                       &amp;Returned, NULL, NULL);
670      HeapFree(GetProcessHeap(), 0, Filter);
671      return Error;
672  }
673  _Success_(return == 0)
674  WS2TCPIP_INLINE
675  int
676  getsourcefilter(
677      _In_ SOCKET Socket,
678      _In_ ULONG Interface,
679      _In_ CONST SOCKADDR *Group,
680      _In_ int GroupLength,
681      _Out_ MULTICAST_MODE_TYPE *FilterMode,
682      _Inout_ ULONG *SourceCount,
683      _Out_writes_(*SourceCount) SOCKADDR_STORAGE *SourceList
684      )
685  {
686      int Error;
687      DWORD Size, Returned;
688      PGROUP_FILTER Filter;
689      if (*SourceCount &gt;
690          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
691          WSASetLastError(WSAENOBUFS);
692          return SOCKET_ERROR;
693      }
694      Size = GROUP_FILTER_SIZE(*SourceCount);
695      Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
696      if (Filter == NULL) {
697          WSASetLastError(WSAENOBUFS);
698          return SOCKET_ERROR;
699      }
700      Filter-&gt;gf_interface = Interface;
701      ZeroMemory(&amp;Filter-&gt;gf_group, sizeof(Filter-&gt;gf_group));
702      CopyMemory(&amp;Filter-&gt;gf_group, Group, GroupLength);
703      Filter-&gt;gf_numsrc = *SourceCount;
704      Error = WSAIoctl(Socket, SIOCGMSFILTER, Filter, Size, Filter, Size,
705                       &amp;Returned, NULL, NULL);
706      if (Error == 0) {
707          if (*SourceCount &gt; 0) {
708              CopyMemory(SourceList, Filter-&gt;gf_slist,
709                         *SourceCount * sizeof(*SourceList));
710              *SourceCount = Filter-&gt;gf_numsrc;
711          }
712          *FilterMode = Filter-&gt;gf_fmode;
713      }
714      HeapFree(GetProcessHeap(), 0, Filter);
715      return Error;
716  }
717  #endif &amp;bsol;* INCL_WINSOCK_API_PROTOTYPES */
718  #endif
719  #ifdef IDEAL_SEND_BACKLOG_IOCTLS
720  #if INCL_WINSOCK_API_PROTOTYPES
721  WS2TCPIP_INLINE 
722  int  
723  idealsendbacklogquery(
724      _In_ SOCKET s,
725      _Out_ ULONG *pISB
726      )
727  {
728      DWORD bytes;
729      return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_QUERY, 
730                      NULL, 0, pISB, sizeof(*pISB), &amp;bytes, NULL, NULL);
731  }
732  WS2TCPIP_INLINE 
733  int  
734  idealsendbacklognotify(
735      _In_ SOCKET s,
736      _In_opt_ LPWSAOVERLAPPED lpOverlapped,
737      _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
738      )
739  {
740      DWORD bytes;
741      return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_CHANGE, 
742                      NULL, 0, NULL, 0, &amp;bytes, 
743                      lpOverlapped, lpCompletionRoutine);
744  }
745  #endif &amp;bsol;* INCL_WINSOCK_API_PROTOTYPES */
746  #endif
747  #if (_WIN32_WINNT &gt;= 0x0600)
748  #ifdef _SECURE_SOCKET_TYPES_DEFINED_
749  WINSOCK_API_LINKAGE
750  INT
751  WSAAPI
752  WSASetSocketSecurity (
753     _In_ SOCKET Socket,
754     _In_reads_bytes_opt_(SecuritySettingsLen) const SOCKET_SECURITY_SETTINGS* SecuritySettings,
755     _In_ ULONG SecuritySettingsLen,
756     _In_opt_ LPWSAOVERLAPPED Overlapped,
757     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
758  );
759  WINSOCK_API_LINKAGE
760  INT
761  WSAAPI
762  WSAQuerySocketSecurity (
763     _In_ SOCKET Socket,
764     _In_reads_bytes_opt_(SecurityQueryTemplateLen) const SOCKET_SECURITY_QUERY_TEMPLATE* SecurityQueryTemplate,
765     _In_ ULONG SecurityQueryTemplateLen,
766     _Out_writes_bytes_to_opt_(*SecurityQueryInfoLen, *SecurityQueryInfoLen) SOCKET_SECURITY_QUERY_INFO* SecurityQueryInfo,
767     _Inout_ ULONG* SecurityQueryInfoLen,
768     _In_opt_ LPWSAOVERLAPPED Overlapped,
769     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
770  );
771  WINSOCK_API_LINKAGE
772  INT
773  WSAAPI
774  WSASetSocketPeerTargetName (
775     _In_ SOCKET Socket,
776     _In_reads_bytes_(PeerTargetNameLen) const SOCKET_PEER_TARGET_NAME* PeerTargetName,
777     _In_ ULONG PeerTargetNameLen,
778     _In_opt_ LPWSAOVERLAPPED Overlapped,
779     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
780  );
781  WINSOCK_API_LINKAGE
782  INT
783  WSAAPI
784  WSADeleteSocketPeerTargetName (
785     _In_ SOCKET Socket,
786     _In_reads_bytes_(PeerAddrLen) const struct sockaddr* PeerAddr,
787     _In_ ULONG PeerAddrLen,
788     _In_opt_ LPWSAOVERLAPPED Overlapped,
789     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
790  );
791  WINSOCK_API_LINKAGE
792  INT
793  WSAAPI
794  WSAImpersonateSocketPeer (
795     _In_ SOCKET Socket,
796     _In_reads_bytes_opt_(PeerAddrLen) const struct sockaddr* PeerAddr,
797     _In_ ULONG PeerAddrLen
798  );
799  WINSOCK_API_LINKAGE
800  INT
801  WSAAPI
802  WSARevertImpersonation ();
803  #endif 
804  #endif 
805  #ifdef __cplusplus
806  }
807  #endif
808  #if !defined(_WIN32_WINNT) || (_WIN32_WINNT &lt;= 0x0500)
809  #include &lt;wspiapi.h&gt;
810  #endif
811  #endif &amp;bsol;* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
812  #pragma endregion
813  #endif  &amp;bsol;* _WS2TCPIP_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-WS2tcpip.h</h3>
            <pre><code>1  #ifndef _WS2TCPIP_H_
2  #define _WS2TCPIP_H_
3  #if _MSC_VER &gt; 1000
4  #pragma once
5  #endif
6  #if WINVER &lt;= _WIN32_WINNT_WS03
7  #include &quot;win32_winapifamily.h&quot;
8  #else
9  #include &lt;winapifamily.h&gt;
10  #endif
11  #pragma region Desktop Family
12  #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
13  #include &lt;winsock2.h&gt;
14  #include &lt;ws2ipdef.h&gt;
15  #include &lt;limits.h&gt;
16  #define UDP_NOCHECKSUM  1
17  #define UDP_CHECKSUM_COVERAGE   20  &amp;bsol;* Set/get UDP-Lite checksum coverage */
18  #ifdef _MSC_VER
19  #define WS2TCPIP_INLINE __inline
20  #else
21  #define WS2TCPIP_INLINE extern inline &amp;bsol;* GNU style */
22  #endif
23  #define EAI_AGAIN           WSATRY_AGAIN
24  #define EAI_BADFLAGS        WSAEINVAL
25  #define EAI_FAIL            WSANO_RECOVERY
26  #define EAI_FAMILY          WSAEAFNOSUPPORT
27  #define EAI_MEMORY          WSA_NOT_ENOUGH_MEMORY
28  #define EAI_NOSECURENAME    WSA_SECURE_HOST_NOT_FOUND
29  #define EAI_NONAME          WSAHOST_NOT_FOUND
30  #define EAI_SERVICE         WSATYPE_NOT_FOUND
31  #define EAI_SOCKTYPE        WSAESOCKTNOSUPPORT
32  #define EAI_IPSECPOLICY     WSA_IPSEC_NAME_POLICY_ERROR
33  #define EAI_NODATA      EAI_NONAME
34  #ifdef UNICODE
35  typedef ADDRINFOW       ADDRINFOT, *PADDRINFOT;
36  #else
37  typedef ADDRINFOA       ADDRINFOT, *PADDRINFOT;
38  #endif
39  typedef ADDRINFOA       ADDRINFO, FAR * LPADDRINFO;
40  #if (_WIN32_WINNT &gt;= 0x0600)
41  #ifdef UNICODE
42  typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
43  #else
44  typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
45  #endif
46  #endif
47  #ifdef __cplusplus
48  extern &quot;C&quot; {
49  #endif
50  #if INCL_WINSOCK_API_TYPEDEFS
51  WINSOCK_API_LINKAGE
52  INT
53  WSAAPI
54  getaddrinfo(
55      _In_opt_        PCSTR               pNodeName,
56      _In_opt_        PCSTR               pServiceName,
57      _In_opt_        const ADDRINFOA *   pHints,
58      _Outptr_     PADDRINFOA *        ppResult
59      );
60  #if (NTDDI_VERSION &gt;= NTDDI_WINXPSP2) || (_WIN32_WINNT &gt;= 0x0502)
61  WINSOCK_API_LINKAGE
62  INT
63  WSAAPI
64  GetAddrInfoW(
65      _In_opt_        PCWSTR              pNodeName,
66      _In_opt_        PCWSTR              pServiceName,
67      _In_opt_        const ADDRINFOW *   pHints,
68      _Outptr_     PADDRINFOW *        ppResult
69      );
70  #define GetAddrInfoA    getaddrinfo
71  #ifdef UNICODE
72  #define GetAddrInfo     GetAddrInfoW
73  #else
74  #define GetAddrInfo     GetAddrInfoA
75  #endif
76  #endif
77  #endif
78  #if INCL_WINSOCK_API_TYPEDEFS
79  typedef
80  INT
81  (WSAAPI * LPFN_GETADDRINFO)(
82      _In_opt_        PCSTR               pNodeName,
83      _In_opt_        PCSTR               pServiceName,
84      _In_opt_        const ADDRINFOA *   pHints,
85      _Outptr_     PADDRINFOA *        ppResult
86      );
87  typedef
88  INT
89  (WSAAPI * LPFN_GETADDRINFOW)(
90      _In_opt_        PCWSTR              pNodeName,
91      _In_opt_        PCWSTR              pServiceName,
<span onclick='openModal()' class='match'>92      _In_opt_        const ADDRINFOW *   pHints,
93      _Outptr_     PADDRINFOW *        ppResult
94      );
95  #define LPFN_GETADDRINFOA      LPFN_GETADDRINFO
96  #ifdef UNICODE
97  #define LPFN_GETADDRINFOT      LPFN_GETADDRINFOW
98  #else
99  #define LPFN_GETADDRINFOT      LPFN_GETADDRINFOA
100  #endif
101  #endif
102  #if (_WIN32_WINNT &gt;= 0x0600)
</span>103  typedef
104  void
105  (CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(
106      _In_      DWORD    dwError,
107      _In_      DWORD    dwBytes,
108      _In_      LPWSAOVERLAPPED lpOverlapped
109      );
110  WINSOCK_API_LINKAGE
111  INT
112  WSAAPI
113  GetAddrInfoExA(
114      _In_opt_    PCSTR           pName,
115      _In_opt_    PCSTR           pServiceName,
116      _In_        DWORD           dwNameSpace,
117      _In_opt_    LPGUID          lpNspId,
118      _In_opt_    const ADDRINFOEXA *hints,
119      _Outptr_ PADDRINFOEXA *  ppResult,
120      _In_opt_    struct timeval *timeout,
121      _In_opt_    LPOVERLAPPED    lpOverlapped,
122      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
123      _Out_opt_   LPHANDLE        lpNameHandle
124      );
125  WINSOCK_API_LINKAGE
126  INT
127  WSAAPI
128  GetAddrInfoExW(
129      _In_opt_    PCWSTR          pName,
130      _In_opt_    PCWSTR          pServiceName,
131      _In_        DWORD           dwNameSpace,
132      _In_opt_    LPGUID          lpNspId,
133      _In_opt_    const ADDRINFOEXW *hints,
134      _Outptr_ PADDRINFOEXW *  ppResult,
135      _In_opt_    struct timeval *timeout,
136      _In_opt_    LPOVERLAPPED    lpOverlapped,
137      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
138      _Out_opt_   LPHANDLE        lpHandle
139      );
140  WINSOCK_API_LINKAGE
141  INT
142  WSAAPI
143  GetAddrInfoExCancel(
144      _In_        LPHANDLE        lpHandle
145      );
146  WINSOCK_API_LINKAGE
147  INT
148  WSAAPI
149  GetAddrInfoExOverlappedResult(
150      _In_        LPOVERLAPPED    lpOverlapped
151      );
152  #ifdef UNICODE
153  #define GetAddrInfoEx       GetAddrInfoExW
154  #else
155  #define GetAddrInfoEx       GetAddrInfoExA
156  #endif
157  #if INCL_WINSOCK_API_TYPEDEFS
158  typedef
159  INT
160  (WSAAPI *LPFN_GETADDRINFOEXA)(
161      _In_        PCSTR           pName,
162      _In_opt_    PCSTR           pServiceName,
163      _In_        DWORD           dwNameSpace,
164      _In_opt_    LPGUID          lpNspId,
165      _In_opt_    const ADDRINFOEXA *hints,
166      _Outptr_ PADDRINFOEXA   *ppResult,
167      _In_opt_    struct timeval *timeout,
168      _In_opt_    LPOVERLAPPED    lpOverlapped,
169      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
170      _Out_opt_   LPHANDLE        lpNameHandle
171      );
172  typedef
173  INT
174  (WSAAPI *LPFN_GETADDRINFOEXW)(
175      _In_        PCWSTR          pName,
176      _In_opt_    PCWSTR          pServiceName,
177      _In_        DWORD           dwNameSpace,
178      _In_opt_    LPGUID          lpNspId,
179      _In_opt_    const ADDRINFOEXW *hints,
180      _Outptr_ PADDRINFOEXW   *ppResult,
181      _In_opt_    struct timeval *timeout,
182      _In_opt_    LPOVERLAPPED    lpOverlapped,
183      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
184      _Out_opt_   LPHANDLE        lpHandle
185      );
186  typedef
187  INT
188  (WSAAPI *LPFN_GETADDRINFOEXCANCEL)(
189      _In_        LPHANDLE        lpHandle
190      );
191  typedef
192  INT
193  (WSAAPI *LPFN_GETADDRINFOEXOVERLAPPEDRESULT)(
194      _In_        LPOVERLAPPED    lpOverlapped
195      );
196  #ifdef UNICODE
197  #define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXW
198  #else
199  #define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXA
200  #endif
201  #endif
202  #endif
203  #if (_WIN32_WINNT &gt;= 0x0600)
204  WINSOCK_API_LINKAGE
205  INT
206  WSAAPI
207  SetAddrInfoExA(
208      _In_        PCSTR           pName,
209      _In_opt_    PCSTR           pServiceName,
210      _In_opt_    SOCKET_ADDRESS *pAddresses,
211      _In_        DWORD           dwAddressCount,
212      _In_opt_    LPBLOB          lpBlob,
213      _In_        DWORD           dwFlags,
214      _In_        DWORD           dwNameSpace,
215      _In_opt_    LPGUID          lpNspId,
216      _In_opt_    struct timeval *timeout,
217      _In_opt_    LPOVERLAPPED    lpOverlapped,
218      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
219      _Out_opt_   LPHANDLE        lpNameHandle
220      );
221  WINSOCK_API_LINKAGE
222  INT
223  WSAAPI
224  SetAddrInfoExW(
225      _In_        PCWSTR          pName,
226      _In_opt_    PCWSTR          pServiceName,
227      _In_opt_    SOCKET_ADDRESS *pAddresses,
228      _In_        DWORD           dwAddressCount,
229      _In_opt_    LPBLOB          lpBlob,
230      _In_        DWORD           dwFlags,
231      _In_        DWORD           dwNameSpace,
232      _In_opt_    LPGUID          lpNspId,
233      _In_opt_    struct timeval *timeout,
234      _In_opt_    LPOVERLAPPED    lpOverlapped,
235      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
236      _Out_opt_   LPHANDLE        lpNameHandle
237      );
238  #ifdef UNICODE
239  #define SetAddrInfoEx       SetAddrInfoExW
240  #else
241  #define SetAddrInfoEx       SetAddrInfoExA
242  #endif
243  #if INCL_WINSOCK_API_TYPEDEFS
244  typedef
245  INT
246  (WSAAPI *LPFN_SETADDRINFOEXA)(
247      _In_        PCSTR           pName,
248      _In_opt_    PCSTR           pServiceName,
249      _In_opt_    SOCKET_ADDRESS *pAddresses,
250      _In_        DWORD           dwAddressCount,
251      _In_opt_    LPBLOB          lpBlob,
252      _In_        DWORD           dwFlags,
253      _In_        DWORD           dwNameSpace,
254      _In_opt_    LPGUID          lpNspId,
255      _In_opt_    struct timeval *timeout,
256      _In_opt_    LPOVERLAPPED    lpOverlapped,
257      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
258      _Out_opt_   LPHANDLE        lpNameHandle
259      );
260  typedef
261  INT
262  (WSAAPI *LPFN_SETADDRINFOEXW)(
263      _In_        PCWSTR          pName,
264      _In_opt_    PCWSTR          pServiceName,
265      _In_opt_    SOCKET_ADDRESS *pAddresses,
266      _In_        DWORD           dwAddressCount,
267      _In_opt_    LPBLOB          lpBlob,
268      _In_        DWORD           dwFlags,
269      _In_        DWORD           dwNameSpace,
270      _In_opt_    LPGUID          lpNspId,
271      _In_opt_    struct timeval *timeout,
272      _In_opt_    LPOVERLAPPED    lpOverlapped,
273      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
274      _Out_opt_   LPHANDLE        lpNameHandle
275      );
276  #ifdef UNICODE
277  #define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXW
278  #else
279  #define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXA
280  #endif
281  #endif
282  #endif
283  #if INCL_WINSOCK_API_TYPEDEFS
284  WINSOCK_API_LINKAGE
285  VOID
286  WSAAPI
287  freeaddrinfo(
288      _In_opt_        PADDRINFOA      pAddrInfo
289      );
290  #if (NTDDI_VERSION &gt;= NTDDI_WINXPSP2) || (_WIN32_WINNT &gt;= 0x0502)
291  WINSOCK_API_LINKAGE
292  VOID
293  WSAAPI
294  FreeAddrInfoW(
295      _In_opt_        PADDRINFOW      pAddrInfo
296      );
297  #endif
298  #define FreeAddrInfoA   freeaddrinfo
299  #ifdef UNICODE
300  #define FreeAddrInfo    FreeAddrInfoW
301  #else
302  #define FreeAddrInfo    FreeAddrInfoA
303  #endif
304  #endif
305  #if INCL_WINSOCK_API_TYPEDEFS
306  typedef
307  VOID
308  (WSAAPI * LPFN_FREEADDRINFO)(
309      _In_opt_        PADDRINFOA      pAddrInfo
310      );
311  typedef
312  VOID
313  (WSAAPI * LPFN_FREEADDRINFOW)(
314      _In_opt_        PADDRINFOW      pAddrInfo
315      );
316  #define LPFN_FREEADDRINFOA      LPFN_FREEADDRINFO
317  #ifdef UNICODE
318  #define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOW
319  #else
320  #define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOA
321  #endif
322  #endif
323  #if (_WIN32_WINNT &gt;= 0x0600)
324  WINSOCK_API_LINKAGE
325  void
326  WSAAPI
327  FreeAddrInfoEx(
328      _In_opt_  PADDRINFOEXA    pAddrInfoEx
329      );
330  WINSOCK_API_LINKAGE
331  void
332  WSAAPI
333  FreeAddrInfoExW(
334      _In_opt_  PADDRINFOEXW    pAddrInfoEx
335      );
336  #define FreeAddrInfoExA     FreeAddrInfoEx
337  #ifdef UNICODE
338  #define FreeAddrInfoEx      FreeAddrInfoExW
339  #endif
340  #ifdef INCL_WINSOCK_API_TYPEDEFS
341  typedef
342  void
343  (WSAAPI *LPFN_FREEADDRINFOEXA)(
344      _In_    PADDRINFOEXA    pAddrInfoEx
345      );
346  typedef
347  void
348  (WSAAPI *LPFN_FREEADDRINFOEXW)(
349      _In_    PADDRINFOEXW    pAddrInfoEx
350      );
351  #ifdef UNICODE
352  #define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXW
353  #else
354  #define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXA
355  #endif
356  #endif
357  #endif
358  typedef int socklen_t;
359  WINSOCK_API_LINKAGE
360  INT
361  WSAAPI
362  getnameinfo(
363      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
364      _In_                                socklen_t           SockaddrLength,
365      _Out_writes_opt_(NodeBufferSize)    PCHAR               pNodeBuffer,
366      _In_                                DWORD               NodeBufferSize,
367      _Out_writes_opt_(ServiceBufferSize) PCHAR               pServiceBuffer,
368      _In_                                DWORD               ServiceBufferSize,
369      _In_                                INT                 Flags
370      );
371  #if (NTDDI_VERSION &gt;= NTDDI_WINXPSP2) || (_WIN32_WINNT &gt;= 0x0502)
372  WINSOCK_API_LINKAGE
373  INT
374  WSAAPI
375  GetNameInfoW(
376      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
377      _In_                                socklen_t           SockaddrLength,
378      _Out_writes_opt_(NodeBufferSize)    PWCHAR              pNodeBuffer,
379      _In_                                DWORD               NodeBufferSize,
380      _Out_writes_opt_(ServiceBufferSize) PWCHAR              pServiceBuffer,
381      _In_                                DWORD               ServiceBufferSize,
382      _In_                                INT                 Flags
383      );
384  #define GetNameInfoA    getnameinfo
385  #ifdef UNICODE
386  #define GetNameInfo     GetNameInfoW
387  #else
388  #define GetNameInfo     GetNameInfoA
389  #endif
390  #endif
391  #if INCL_WINSOCK_API_TYPEDEFS
392  typedef
393  int
394  (WSAAPI * LPFN_GETNAMEINFO)(
395      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
396      _In_                                socklen_t           SockaddrLength,
397      _Out_writes_opt_(NodeBufferSize)    PCHAR               pNodeBuffer,
398      _In_                                DWORD               NodeBufferSize,
399      _Out_writes_opt_(ServiceBufferSize) PCHAR               pServiceBuffer,
400      _In_                                DWORD               ServiceBufferSize,
401      _In_                                INT                 Flags
402      );
403  typedef
404  INT
405  (WSAAPI * LPFN_GETNAMEINFOW)(
406      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
407      _In_                                socklen_t           SockaddrLength,
408      _Out_writes_opt_(NodeBufferSize)    PWCHAR              pNodeBuffer,
409      _In_                                DWORD               NodeBufferSize,
410      _Out_writes_opt_(ServiceBufferSize) PWCHAR              pServiceBuffer,
411      _In_                                DWORD               ServiceBufferSize,
412      _In_                                INT                 Flags
413      );
414  #define LPFN_GETNAMEINFOA      LPFN_GETNAMEINFO
415  #ifdef UNICODE
416  #define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOW
417  #else
418  #define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOA
419  #endif
420  #endif
421  #if (NTDDI_VERSION &gt;= NTDDI_VISTA)
422  #if INCL_WINSOCK_API_TYPEDEFS
423  WINSOCK_API_LINKAGE
424  INT
425  WSAAPI
426  inet_pton(
427      _In_                                INT             Family,
428      _In_                                PCSTR           pszAddrString,
429      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
430      );
431  INT
432  WSAAPI
433  InetPtonW(
434      _In_                                INT             Family,
435      _In_                                PCWSTR          pszAddrString,
436      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
437      );
438  PCSTR
439  WSAAPI
440  inet_ntop(
441      _In_                                INT             Family,
442      _In_                                PVOID           pAddr,
443      _Out_writes_(StringBufSize)         PSTR            pStringBuf,
444      _In_                                size_t          StringBufSize
445      );
446  PCWSTR
447  WSAAPI
448  InetNtopW(
449      _In_                                INT             Family,
450      _In_                                PVOID           pAddr,
451      _Out_writes_(StringBufSize)         PWSTR           pStringBuf,
452      _In_                                size_t          StringBufSize
453      );
454  #define InetPtonA       inet_pton
455  #define InetNtopA       inet_ntop
456  #ifdef UNICODE
457  #define InetPton        InetPtonW
458  #define InetNtop        InetNtopW
459  #else
460  #define InetPton        InetPtonA
461  #define InetNtop        InetNtopA
462  #endif
463  #endif
464  #if INCL_WINSOCK_API_TYPEDEFS
465  typedef
466  INT
467  (WSAAPI * LPFN_INET_PTONA)(
468      _In_                                INT             Family,
469      _In_                                PCSTR           pszAddrString,
470      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
471      );
472  typedef
473  INT
474  (WSAAPI * LPFN_INET_PTONW)(
475      _In_                                INT             Family,
476      _In_                                PCWSTR          pszAddrString,
477      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
478      );
479  typedef
480  PCSTR
481  (WSAAPI * LPFN_INET_NTOPA)(
482      _In_                                INT             Family,
483      _In_                                PVOID           pAddr,
484      _Out_writes_(StringBufSize)         PSTR            pStringBuf,
485      _In_                                size_t          StringBufSize
486      );
487  typedef
488  PCWSTR
489  (WSAAPI * LPFN_INET_NTOPW)(
490      _In_                                INT             Family,
491      _In_                                PVOID           pAddr,
492      _Out_writes_(StringBufSize)         PWSTR           pStringBuf,
493      _In_                                size_t          StringBufSize
494      );
495  #ifdef UNICODE
496  #define LPFN_INET_PTON          LPFN_INET_PTONW
497  #define LPFN_INET_NTOP          LPFN_INET_NTOPW
498  #else
499  #define LPFN_INET_PTON          LPFN_INET_PTONA
500  #define LPFN_INET_NTOP          LPFN_INET_NTOPA
501  #endif
502  #endif  
503  #endif  
504  #if INCL_WINSOCK_API_PROTOTYPES
505  #ifdef UNICODE
506  #define gai_strerror   gai_strerrorW
507  #else
508  #define gai_strerror   gai_strerrorA
509  #endif  &amp;bsol;* UNICODE */
510  #define GAI_STRERROR_BUFFER_SIZE 1024
511  WS2TCPIP_INLINE
512  char *
513  gai_strerrorA(
514      _In_ int ecode)
515  {
516      DWORD dwMsgLen;
517      static char buff[GAI_STRERROR_BUFFER_SIZE + 1];
518      dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
519                               |FORMAT_MESSAGE_IGNORE_INSERTS
520                               |FORMAT_MESSAGE_MAX_WIDTH_MASK,
521                                NULL,
522                                ecode,
523                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
524                                (LPSTR)buff,
525                                GAI_STRERROR_BUFFER_SIZE,
526                                NULL);
527      return buff;
528  }
529  WS2TCPIP_INLINE
530  WCHAR *
531  gai_strerrorW(
532      _In_ int ecode
533      )
534  {
535      DWORD dwMsgLen;
536      static WCHAR buff[GAI_STRERROR_BUFFER_SIZE + 1];
537      dwMsgLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
538                               |FORMAT_MESSAGE_IGNORE_INSERTS
539                               |FORMAT_MESSAGE_MAX_WIDTH_MASK,
540                                NULL,
541                                ecode,
542                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
543                                (LPWSTR)buff,
544                                GAI_STRERROR_BUFFER_SIZE,
545                                NULL);
546      return buff;
547  }
548  #endif &amp;bsol;* INCL_WINSOCK_API_PROTOTYPES */
549  #if INCL_WINSOCK_API_PROTOTYPES
550  WS2TCPIP_INLINE
551  int
552  setipv4sourcefilter(
553      _In_ SOCKET Socket,
554      _In_ IN_ADDR Interface,
555      _In_ IN_ADDR Group,
556      _In_ MULTICAST_MODE_TYPE FilterMode,
557      _In_ ULONG SourceCount,
558      _In_reads_(SourceCount) CONST IN_ADDR *SourceList
559      )
560  {
561      int Error;
562      DWORD Size, Returned;
563      PIP_MSFILTER Filter;
564      if (SourceCount &gt;
565          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
566          WSASetLastError(WSAENOBUFS);
567          return SOCKET_ERROR;
568      }
569      Size = IP_MSFILTER_SIZE(SourceCount);
570      Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
571      if (Filter == NULL) {
572          WSASetLastError(WSAENOBUFS);
573          return SOCKET_ERROR;
574      }
575      Filter-&gt;imsf_multiaddr = Group;
576      Filter-&gt;imsf_interface = Interface;
577      Filter-&gt;imsf_fmode = FilterMode;
578      Filter-&gt;imsf_numsrc = SourceCount;
579      if (SourceCount &gt; 0) {
580          CopyMemory(Filter-&gt;imsf_slist, SourceList,
581                     SourceCount * sizeof(*SourceList));
582      }
583      Error = WSAIoctl(Socket, SIOCSIPMSFILTER, Filter, Size, NULL, 0,
584                       &amp;Returned, NULL, NULL);
585      HeapFree(GetProcessHeap(), 0, Filter);
586      return Error;
587  }
588  _Success_(return == 0)
589  WS2TCPIP_INLINE
590  int
591  getipv4sourcefilter(
592      _In_ SOCKET Socket,
593      _In_ IN_ADDR Interface,
594      _In_ IN_ADDR Group,
595      _Out_ MULTICAST_MODE_TYPE *FilterMode,
596      _Inout_ ULONG *SourceCount,
597      _Out_writes_(*SourceCount) IN_ADDR *SourceList
598      )
599  {
600      int Error;
601      DWORD Size, Returned;
602      PIP_MSFILTER Filter;
603      if (*SourceCount &gt;
604          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
605          WSASetLastError(WSAENOBUFS);
606          return SOCKET_ERROR;
607      }
608      Size = IP_MSFILTER_SIZE(*SourceCount);
609      Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
610      if (Filter == NULL) {
611          WSASetLastError(WSAENOBUFS);
612          return SOCKET_ERROR;
613      }
614      Filter-&gt;imsf_multiaddr = Group;
615      Filter-&gt;imsf_interface = Interface;
616      Filter-&gt;imsf_numsrc = *SourceCount;
617      Error = WSAIoctl(Socket, SIOCGIPMSFILTER, Filter, Size, Filter, Size,
618                       &amp;Returned, NULL, NULL);
619      if (Error == 0) {
620          if (*SourceCount &gt; 0) {
621              CopyMemory(SourceList, Filter-&gt;imsf_slist,
622                         *SourceCount * sizeof(*SourceList));
623              *SourceCount = Filter-&gt;imsf_numsrc;
624          }
625          *FilterMode = Filter-&gt;imsf_fmode;
626      }
627      HeapFree(GetProcessHeap(), 0, Filter);
628      return Error;
629  }
630  #endif &amp;bsol;* INCL_WINSOCK_API_PROTOTYPES */
631  #if (NTDDI_VERSION &gt;= NTDDI_WINXP)
632  #if INCL_WINSOCK_API_PROTOTYPES
633  WS2TCPIP_INLINE
634  int
635  setsourcefilter(
636      _In_ SOCKET Socket,
637      _In_ ULONG Interface,
638      _In_ CONST SOCKADDR *Group,
639      _In_ int GroupLength,
640      _In_ MULTICAST_MODE_TYPE FilterMode,
641      _In_ ULONG SourceCount,
642      _In_reads_(SourceCount) CONST SOCKADDR_STORAGE *SourceList
643      )
644  {
645      int Error;
646      DWORD Size, Returned;
647      PGROUP_FILTER Filter;
648      if (SourceCount &gt;=
649          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
650          WSASetLastError(WSAENOBUFS);
651          return SOCKET_ERROR;
652      }
653      Size = GROUP_FILTER_SIZE(SourceCount);
654      Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
655      if (Filter == NULL) {
656          WSASetLastError(WSAENOBUFS);
657          return SOCKET_ERROR;
658      }
659      Filter-&gt;gf_interface = Interface;
660      ZeroMemory(&amp;Filter-&gt;gf_group, sizeof(Filter-&gt;gf_group));
661      CopyMemory(&amp;Filter-&gt;gf_group, Group, GroupLength);
662      Filter-&gt;gf_fmode = FilterMode;
663      Filter-&gt;gf_numsrc = SourceCount;
664      if (SourceCount &gt; 0) {
665          CopyMemory(Filter-&gt;gf_slist, SourceList,
666                     SourceCount * sizeof(*SourceList));
667      }
668      Error = WSAIoctl(Socket, SIOCSMSFILTER, Filter, Size, NULL, 0,
669                       &amp;Returned, NULL, NULL);
670      HeapFree(GetProcessHeap(), 0, Filter);
671      return Error;
672  }
673  _Success_(return == 0)
674  WS2TCPIP_INLINE
675  int
676  getsourcefilter(
677      _In_ SOCKET Socket,
678      _In_ ULONG Interface,
679      _In_ CONST SOCKADDR *Group,
680      _In_ int GroupLength,
681      _Out_ MULTICAST_MODE_TYPE *FilterMode,
682      _Inout_ ULONG *SourceCount,
683      _Out_writes_(*SourceCount) SOCKADDR_STORAGE *SourceList
684      )
685  {
686      int Error;
687      DWORD Size, Returned;
688      PGROUP_FILTER Filter;
689      if (*SourceCount &gt;
690          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
691          WSASetLastError(WSAENOBUFS);
692          return SOCKET_ERROR;
693      }
694      Size = GROUP_FILTER_SIZE(*SourceCount);
695      Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
696      if (Filter == NULL) {
697          WSASetLastError(WSAENOBUFS);
698          return SOCKET_ERROR;
699      }
700      Filter-&gt;gf_interface = Interface;
701      ZeroMemory(&amp;Filter-&gt;gf_group, sizeof(Filter-&gt;gf_group));
702      CopyMemory(&amp;Filter-&gt;gf_group, Group, GroupLength);
703      Filter-&gt;gf_numsrc = *SourceCount;
704      Error = WSAIoctl(Socket, SIOCGMSFILTER, Filter, Size, Filter, Size,
705                       &amp;Returned, NULL, NULL);
706      if (Error == 0) {
707          if (*SourceCount &gt; 0) {
708              CopyMemory(SourceList, Filter-&gt;gf_slist,
709                         *SourceCount * sizeof(*SourceList));
710              *SourceCount = Filter-&gt;gf_numsrc;
711          }
712          *FilterMode = Filter-&gt;gf_fmode;
713      }
714      HeapFree(GetProcessHeap(), 0, Filter);
715      return Error;
716  }
717  #endif &amp;bsol;* INCL_WINSOCK_API_PROTOTYPES */
718  #endif
719  #ifdef IDEAL_SEND_BACKLOG_IOCTLS
720  #if INCL_WINSOCK_API_PROTOTYPES
721  WS2TCPIP_INLINE 
722  int  
723  idealsendbacklogquery(
724      _In_ SOCKET s,
725      _Out_ ULONG *pISB
726      )
727  {
728      DWORD bytes;
729      return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_QUERY, 
730                      NULL, 0, pISB, sizeof(*pISB), &amp;bytes, NULL, NULL);
731  }
732  WS2TCPIP_INLINE 
733  int  
734  idealsendbacklognotify(
735      _In_ SOCKET s,
736      _In_opt_ LPWSAOVERLAPPED lpOverlapped,
737      _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
738      )
739  {
740      DWORD bytes;
741      return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_CHANGE, 
742                      NULL, 0, NULL, 0, &amp;bytes, 
743                      lpOverlapped, lpCompletionRoutine);
744  }
745  #endif &amp;bsol;* INCL_WINSOCK_API_PROTOTYPES */
746  #endif
747  #if (_WIN32_WINNT &gt;= 0x0600)
748  #ifdef _SECURE_SOCKET_TYPES_DEFINED_
749  WINSOCK_API_LINKAGE
750  INT
751  WSAAPI
752  WSASetSocketSecurity (
753     _In_ SOCKET Socket,
754     _In_reads_bytes_opt_(SecuritySettingsLen) const SOCKET_SECURITY_SETTINGS* SecuritySettings,
755     _In_ ULONG SecuritySettingsLen,
756     _In_opt_ LPWSAOVERLAPPED Overlapped,
757     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
758  );
759  WINSOCK_API_LINKAGE
760  INT
761  WSAAPI
762  WSAQuerySocketSecurity (
763     _In_ SOCKET Socket,
764     _In_reads_bytes_opt_(SecurityQueryTemplateLen) const SOCKET_SECURITY_QUERY_TEMPLATE* SecurityQueryTemplate,
765     _In_ ULONG SecurityQueryTemplateLen,
766     _Out_writes_bytes_to_opt_(*SecurityQueryInfoLen, *SecurityQueryInfoLen) SOCKET_SECURITY_QUERY_INFO* SecurityQueryInfo,
767     _Inout_ ULONG* SecurityQueryInfoLen,
768     _In_opt_ LPWSAOVERLAPPED Overlapped,
769     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
770  );
771  WINSOCK_API_LINKAGE
772  INT
773  WSAAPI
774  WSASetSocketPeerTargetName (
775     _In_ SOCKET Socket,
776     _In_reads_bytes_(PeerTargetNameLen) const SOCKET_PEER_TARGET_NAME* PeerTargetName,
777     _In_ ULONG PeerTargetNameLen,
778     _In_opt_ LPWSAOVERLAPPED Overlapped,
779     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
780  );
781  WINSOCK_API_LINKAGE
782  INT
783  WSAAPI
784  WSADeleteSocketPeerTargetName (
785     _In_ SOCKET Socket,
786     _In_reads_bytes_(PeerAddrLen) const struct sockaddr* PeerAddr,
787     _In_ ULONG PeerAddrLen,
788     _In_opt_ LPWSAOVERLAPPED Overlapped,
789     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
790  );
791  WINSOCK_API_LINKAGE
792  INT
793  WSAAPI
794  WSAImpersonateSocketPeer (
795     _In_ SOCKET Socket,
796     _In_reads_bytes_opt_(PeerAddrLen) const struct sockaddr* PeerAddr,
797     _In_ ULONG PeerAddrLen
798  );
799  WINSOCK_API_LINKAGE
800  INT
801  WSAAPI
802  WSARevertImpersonation ();
803  #endif 
804  #endif 
805  #ifdef __cplusplus
806  }
807  #endif
808  #if !defined(_WIN32_WINNT) || (_WIN32_WINNT &lt;= 0x0500)
809  #include &lt;wspiapi.h&gt;
810  #endif
811  #endif &amp;bsol;* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
812  #pragma endregion
813  #endif  &amp;bsol;* _WS2TCPIP_H_ */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-WS2tcpip.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-WS2tcpip.h</div>
                </div>
                <div class="column column_space"><pre><code>67      _In_opt_        const ADDRINFOW *   pHints,
68      _Outptr_     PADDRINFOW *        ppResult
69      );
70  #define GetAddrInfoA    getaddrinfo
71  #ifdef UNICODE
72  #define GetAddrInfo     GetAddrInfoW
73  #else
74  #define GetAddrInfo     GetAddrInfoA
75  #endif
76  #endif
77  #endif
</pre></code></div>
                <div class="column column_space"><pre><code>92      _In_opt_        const ADDRINFOW *   pHints,
93      _Outptr_     PADDRINFOW *        ppResult
94      );
95  #define LPFN_GETADDRINFOA      LPFN_GETADDRINFO
96  #ifdef UNICODE
97  #define LPFN_GETADDRINFOT      LPFN_GETADDRINFOW
98  #else
99  #define LPFN_GETADDRINFOT      LPFN_GETADDRINFOA
100  #endif
101  #endif
102  #if (_WIN32_WINNT &gt;= 0x0600)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    