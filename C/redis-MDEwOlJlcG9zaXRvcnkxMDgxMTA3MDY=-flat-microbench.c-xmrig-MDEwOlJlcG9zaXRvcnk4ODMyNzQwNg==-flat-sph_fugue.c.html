
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.931506849315069%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-microbench.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  static inline void
3  time_func(timedelta_t *timer, uint64_t nwarmup, uint64_t niter,
4      void (*func)(void)) {
5  	uint64_t i;
<span onclick='openModal()' class='match'>6  	for (i = 0; i < nwarmup; i++) {
7  		func();
8  	}
9  	timer_start(timer);
10  	for (i = 0; i < niter; i++) {
</span>11  		func();
12  	}
13  	timer_stop(timer);
14  }
15  void
16  compare_funcs(uint64_t nwarmup, uint64_t niter, const char *name_a,
17      void (*func_a), const char *name_b, void (*func_b)) {
18  	timedelta_t timer_a, timer_b;
19  	char ratio_buf[6];
20  	void *p;
21  	p = mallocx(1, 0);
22  	if (p == NULL) {
23  		test_fail("Unexpected mallocx() failure");
24  		return;
25  	}
26  	time_func(&timer_a, nwarmup, niter, func_a);
27  	time_func(&timer_b, nwarmup, niter, func_b);
28  	timer_ratio(&timer_a, &timer_b, ratio_buf, sizeof(ratio_buf));
29  	malloc_printf("%"FMTu64" iterations, %s=%"FMTu64"us, "
30  	    "%s=%"FMTu64"us, ratio=1:%s\n",
31  	    niter, name_a, timer_usec(&timer_a), name_b, timer_usec(&timer_b),
32  	    ratio_buf);
33  	dallocx(p, 0);
34  }
35  static void
36  malloc_free(void) {
37  	void *p = malloc(1);
38  	if (p == NULL) {
39  		test_fail("Unexpected malloc() failure");
40  		return;
41  	}
42  	free(p);
43  }
44  static void
45  mallocx_free(void) {
46  	void *p = mallocx(1, 0);
47  	if (p == NULL) {
48  		test_fail("Unexpected mallocx() failure");
49  		return;
50  	}
51  	free(p);
52  }
53  TEST_BEGIN(test_malloc_vs_mallocx) {
54  	compare_funcs(10*1000*1000, 100*1000*1000, "malloc",
55  	    malloc_free, "mallocx", mallocx_free);
56  }
57  TEST_END
58  static void
59  malloc_dallocx(void) {
60  	void *p = malloc(1);
61  	if (p == NULL) {
62  		test_fail("Unexpected malloc() failure");
63  		return;
64  	}
65  	dallocx(p, 0);
66  }
67  static void
68  malloc_sdallocx(void) {
69  	void *p = malloc(1);
70  	if (p == NULL) {
71  		test_fail("Unexpected malloc() failure");
72  		return;
73  	}
74  	sdallocx(p, 1, 0);
75  }
76  TEST_BEGIN(test_free_vs_dallocx) {
77  	compare_funcs(10*1000*1000, 100*1000*1000, "free", malloc_free,
78  	    "dallocx", malloc_dallocx);
79  }
80  TEST_END
81  TEST_BEGIN(test_dallocx_vs_sdallocx) {
82  	compare_funcs(10*1000*1000, 100*1000*1000, "dallocx", malloc_dallocx,
83  	    "sdallocx", malloc_sdallocx);
84  }
85  TEST_END
86  static void
87  malloc_mus_free(void) {
88  	void *p;
89  	p = malloc(1);
90  	if (p == NULL) {
91  		test_fail("Unexpected malloc() failure");
92  		return;
93  	}
94  	malloc_usable_size(p);
95  	free(p);
96  }
97  static void
98  malloc_sallocx_free(void) {
99  	void *p;
100  	p = malloc(1);
101  	if (p == NULL) {
102  		test_fail("Unexpected malloc() failure");
103  		return;
104  	}
105  	if (sallocx(p, 0) < 1) {
106  		test_fail("Unexpected sallocx() failure");
107  	}
108  	free(p);
109  }
110  TEST_BEGIN(test_mus_vs_sallocx) {
111  	compare_funcs(10*1000*1000, 100*1000*1000, "malloc_usable_size",
112  	    malloc_mus_free, "sallocx", malloc_sallocx_free);
113  }
114  TEST_END
115  static void
116  malloc_nallocx_free(void) {
117  	void *p;
118  	p = malloc(1);
119  	if (p == NULL) {
120  		test_fail("Unexpected malloc() failure");
121  		return;
122  	}
123  	if (nallocx(1, 0) < 1) {
124  		test_fail("Unexpected nallocx() failure");
125  	}
126  	free(p);
127  }
128  TEST_BEGIN(test_sallocx_vs_nallocx) {
129  	compare_funcs(10*1000*1000, 100*1000*1000, "sallocx",
130  	    malloc_sallocx_free, "nallocx", malloc_nallocx_free);
131  }
132  TEST_END
133  int
134  main(void) {
135  	return test_no_reentrancy(
136  	    test_malloc_vs_mallocx,
137  	    test_free_vs_dallocx,
138  	    test_dallocx_vs_sdallocx,
139  	    test_mus_vs_sallocx,
140  	    test_sallocx_vs_nallocx);
141  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_fugue.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include "sph_fugue.h"
4  #ifdef __cplusplus
5  extern "C"{
6  #endif
7  #ifdef _MSC_VER
8  #pragma warning (disable: 4146)
9  #endif
10  #define SPH_FUGUE_NOCOPY 1
11  static const sph_u32 IV224[] = {
12  	SPH_C32(0xf4c9120d), SPH_C32(0x6286f757), SPH_C32(0xee39e01c),
13  	SPH_C32(0xe074e3cb), SPH_C32(0xa1127c62), SPH_C32(0x9a43d215),
14  	SPH_C32(0xbd8d679a)
15  };
16  static const sph_u32 IV256[] = {
17  	SPH_C32(0xe952bdde), SPH_C32(0x6671135f), SPH_C32(0xe0d4f668),
18  	SPH_C32(0xd2b0b594), SPH_C32(0xf96c621d), SPH_C32(0xfbf929de),
19  	SPH_C32(0x9149e899), SPH_C32(0x34f8c248)
20  };
21  static const sph_u32 IV384[] = {
22  	SPH_C32(0xaa61ec0d), SPH_C32(0x31252e1f), SPH_C32(0xa01db4c7),
23  	SPH_C32(0x00600985), SPH_C32(0x215ef44a), SPH_C32(0x741b5e9c),
24  	SPH_C32(0xfa693e9a), SPH_C32(0x473eb040), SPH_C32(0xe502ae8a),
25  	SPH_C32(0xa99c25e0), SPH_C32(0xbc95517c), SPH_C32(0x5c1095a1)
26  };
27  static const sph_u32 IV512[] = {
28  	SPH_C32(0x8807a57e), SPH_C32(0xe616af75), SPH_C32(0xc5d3e4db),
29  	SPH_C32(0xac9ab027), SPH_C32(0xd915f117), SPH_C32(0xb6eecc54),
30  	SPH_C32(0x06e8020b), SPH_C32(0x4a92efd1), SPH_C32(0xaac6e2c9),
31  	SPH_C32(0xddb21398), SPH_C32(0xcae65838), SPH_C32(0x437f203f),
32  	SPH_C32(0x25ea78e7), SPH_C32(0x951fddd6), SPH_C32(0xda6ed11d),
33  	SPH_C32(0xe13e3567)
34  };
35  static const sph_u32 mixtab0[] = {
36  	SPH_C32(0x63633297), SPH_C32(0x7c7c6feb), SPH_C32(0x77775ec7),
37  	SPH_C32(0x7b7b7af7), SPH_C32(0xf2f2e8e5), SPH_C32(0x6b6b0ab7),
38  	SPH_C32(0x6f6f16a7), SPH_C32(0xc5c56d39), SPH_C32(0x303090c0),
39  	SPH_C32(0x01010704), SPH_C32(0x67672e87), SPH_C32(0x2b2bd1ac),
40  	SPH_C32(0xfefeccd5), SPH_C32(0xd7d71371), SPH_C32(0xabab7c9a),
41  	SPH_C32(0x767659c3), SPH_C32(0xcaca4005), SPH_C32(0x8282a33e),
42  	SPH_C32(0xc9c94909), SPH_C32(0x7d7d68ef), SPH_C32(0xfafad0c5),
43  	SPH_C32(0x5959947f), SPH_C32(0x4747ce07), SPH_C32(0xf0f0e6ed),
44  	SPH_C32(0xadad6e82), SPH_C32(0xd4d41a7d), SPH_C32(0xa2a243be),
45  	SPH_C32(0xafaf608a), SPH_C32(0x9c9cf946), SPH_C32(0xa4a451a6),
46  	SPH_C32(0x727245d3), SPH_C32(0xc0c0762d), SPH_C32(0xb7b728ea),
47  	SPH_C32(0xfdfdc5d9), SPH_C32(0x9393d47a), SPH_C32(0x2626f298),
48  	SPH_C32(0x363682d8), SPH_C32(0x3f3fbdfc), SPH_C32(0xf7f7f3f1),
49  	SPH_C32(0xcccc521d), SPH_C32(0x34348cd0), SPH_C32(0xa5a556a2),
50  	SPH_C32(0xe5e58db9), SPH_C32(0xf1f1e1e9), SPH_C32(0x71714cdf),
51  	SPH_C32(0xd8d83e4d), SPH_C32(0x313197c4), SPH_C32(0x15156b54),
52  	SPH_C32(0x04041c10), SPH_C32(0xc7c76331), SPH_C32(0x2323e98c),
53  	SPH_C32(0xc3c37f21), SPH_C32(0x18184860), SPH_C32(0x9696cf6e),
54  	SPH_C32(0x05051b14), SPH_C32(0x9a9aeb5e), SPH_C32(0x0707151c),
55  	SPH_C32(0x12127e48), SPH_C32(0x8080ad36), SPH_C32(0xe2e298a5),
56  	SPH_C32(0xebeba781), SPH_C32(0x2727f59c), SPH_C32(0xb2b233fe),
57  	SPH_C32(0x757550cf), SPH_C32(0x09093f24), SPH_C32(0x8383a43a),
58  	SPH_C32(0x2c2cc4b0), SPH_C32(0x1a1a4668), SPH_C32(0x1b1b416c),
59  	SPH_C32(0x6e6e11a3), SPH_C32(0x5a5a9d73), SPH_C32(0xa0a04db6),
60  	SPH_C32(0x5252a553), SPH_C32(0x3b3ba1ec), SPH_C32(0xd6d61475),
61  	SPH_C32(0xb3b334fa), SPH_C32(0x2929dfa4), SPH_C32(0xe3e39fa1),
62  	SPH_C32(0x2f2fcdbc), SPH_C32(0x8484b126), SPH_C32(0x5353a257),
63  	SPH_C32(0xd1d10169), SPH_C32(0x00000000), SPH_C32(0xededb599),
64  	SPH_C32(0x2020e080), SPH_C32(0xfcfcc2dd), SPH_C32(0xb1b13af2),
65  	SPH_C32(0x5b5b9a77), SPH_C32(0x6a6a0db3), SPH_C32(0xcbcb4701),
66  	SPH_C32(0xbebe17ce), SPH_C32(0x3939afe4), SPH_C32(0x4a4aed33),
67  	SPH_C32(0x4c4cff2b), SPH_C32(0x5858937b), SPH_C32(0xcfcf5b11),
68  	SPH_C32(0xd0d0066d), SPH_C32(0xefefbb91), SPH_C32(0xaaaa7b9e),
69  	SPH_C32(0xfbfbd7c1), SPH_C32(0x4343d217), SPH_C32(0x4d4df82f),
70  	SPH_C32(0x333399cc), SPH_C32(0x8585b622), SPH_C32(0x4545c00f),
71  	SPH_C32(0xf9f9d9c9), SPH_C32(0x02020e08), SPH_C32(0x7f7f66e7),
72  	SPH_C32(0x5050ab5b), SPH_C32(0x3c3cb4f0), SPH_C32(0x9f9ff04a),
73  	SPH_C32(0xa8a87596), SPH_C32(0x5151ac5f), SPH_C32(0xa3a344ba),
74  	SPH_C32(0x4040db1b), SPH_C32(0x8f8f800a), SPH_C32(0x9292d37e),
75  	SPH_C32(0x9d9dfe42), SPH_C32(0x3838a8e0), SPH_C32(0xf5f5fdf9),
76  	SPH_C32(0xbcbc19c6), SPH_C32(0xb6b62fee), SPH_C32(0xdada3045),
77  	SPH_C32(0x2121e784), SPH_C32(0x10107040), SPH_C32(0xffffcbd1),
78  	SPH_C32(0xf3f3efe1), SPH_C32(0xd2d20865), SPH_C32(0xcdcd5519),
79  	SPH_C32(0x0c0c2430), SPH_C32(0x1313794c), SPH_C32(0xececb29d),
80  	SPH_C32(0x5f5f8667), SPH_C32(0x9797c86a), SPH_C32(0x4444c70b),
81  	SPH_C32(0x1717655c), SPH_C32(0xc4c46a3d), SPH_C32(0xa7a758aa),
82  	SPH_C32(0x7e7e61e3), SPH_C32(0x3d3db3f4), SPH_C32(0x6464278b),
83  	SPH_C32(0x5d5d886f), SPH_C32(0x19194f64), SPH_C32(0x737342d7),
84  	SPH_C32(0x60603b9b), SPH_C32(0x8181aa32), SPH_C32(0x4f4ff627),
85  	SPH_C32(0xdcdc225d), SPH_C32(0x2222ee88), SPH_C32(0x2a2ad6a8),
86  	SPH_C32(0x9090dd76), SPH_C32(0x88889516), SPH_C32(0x4646c903),
87  	SPH_C32(0xeeeebc95), SPH_C32(0xb8b805d6), SPH_C32(0x14146c50),
88  	SPH_C32(0xdede2c55), SPH_C32(0x5e5e8163), SPH_C32(0x0b0b312c),
89  	SPH_C32(0xdbdb3741), SPH_C32(0xe0e096ad), SPH_C32(0x32329ec8),
90  	SPH_C32(0x3a3aa6e8), SPH_C32(0x0a0a3628), SPH_C32(0x4949e43f),
91  	SPH_C32(0x06061218), SPH_C32(0x2424fc90), SPH_C32(0x5c5c8f6b),
92  	SPH_C32(0xc2c27825), SPH_C32(0xd3d30f61), SPH_C32(0xacac6986),
93  	SPH_C32(0x62623593), SPH_C32(0x9191da72), SPH_C32(0x9595c662),
94  	SPH_C32(0xe4e48abd), SPH_C32(0x797974ff), SPH_C32(0xe7e783b1),
95  	SPH_C32(0xc8c84e0d), SPH_C32(0x373785dc), SPH_C32(0x6d6d18af),
96  	SPH_C32(0x8d8d8e02), SPH_C32(0xd5d51d79), SPH_C32(0x4e4ef123),
97  	SPH_C32(0xa9a97292), SPH_C32(0x6c6c1fab), SPH_C32(0x5656b943),
98  	SPH_C32(0xf4f4fafd), SPH_C32(0xeaeaa085), SPH_C32(0x6565208f),
99  	SPH_C32(0x7a7a7df3), SPH_C32(0xaeae678e), SPH_C32(0x08083820),
100  	SPH_C32(0xbaba0bde), SPH_C32(0x787873fb), SPH_C32(0x2525fb94),
101  	SPH_C32(0x2e2ecab8), SPH_C32(0x1c1c5470), SPH_C32(0xa6a65fae),
102  	SPH_C32(0xb4b421e6), SPH_C32(0xc6c66435), SPH_C32(0xe8e8ae8d),
103  	SPH_C32(0xdddd2559), SPH_C32(0x747457cb), SPH_C32(0x1f1f5d7c),
104  	SPH_C32(0x4b4bea37), SPH_C32(0xbdbd1ec2), SPH_C32(0x8b8b9c1a),
105  	SPH_C32(0x8a8a9b1e), SPH_C32(0x70704bdb), SPH_C32(0x3e3ebaf8),
106  	SPH_C32(0xb5b526e2), SPH_C32(0x66662983), SPH_C32(0x4848e33b),
107  	SPH_C32(0x0303090c), SPH_C32(0xf6f6f4f5), SPH_C32(0x0e0e2a38),
108  	SPH_C32(0x61613c9f), SPH_C32(0x35358bd4), SPH_C32(0x5757be47),
109  	SPH_C32(0xb9b902d2), SPH_C32(0x8686bf2e), SPH_C32(0xc1c17129),
110  	SPH_C32(0x1d1d5374), SPH_C32(0x9e9ef74e), SPH_C32(0xe1e191a9),
111  	SPH_C32(0xf8f8decd), SPH_C32(0x9898e556), SPH_C32(0x11117744),
112  	SPH_C32(0x696904bf), SPH_C32(0xd9d93949), SPH_C32(0x8e8e870e),
113  	SPH_C32(0x9494c166), SPH_C32(0x9b9bec5a), SPH_C32(0x1e1e5a78),
114  	SPH_C32(0x8787b82a), SPH_C32(0xe9e9a989), SPH_C32(0xcece5c15),
115  	SPH_C32(0x5555b04f), SPH_C32(0x2828d8a0), SPH_C32(0xdfdf2b51),
116  	SPH_C32(0x8c8c8906), SPH_C32(0xa1a14ab2), SPH_C32(0x89899212),
117  	SPH_C32(0x0d0d2334), SPH_C32(0xbfbf10ca), SPH_C32(0xe6e684b5),
118  	SPH_C32(0x4242d513), SPH_C32(0x686803bb), SPH_C32(0x4141dc1f),
119  	SPH_C32(0x9999e252), SPH_C32(0x2d2dc3b4), SPH_C32(0x0f0f2d3c),
120  	SPH_C32(0xb0b03df6), SPH_C32(0x5454b74b), SPH_C32(0xbbbb0cda),
121  	SPH_C32(0x16166258)
122  };
123  static const sph_u32 mixtab1[] = {
124  	SPH_C32(0x97636332), SPH_C32(0xeb7c7c6f), SPH_C32(0xc777775e),
125  	SPH_C32(0xf77b7b7a), SPH_C32(0xe5f2f2e8), SPH_C32(0xb76b6b0a),
126  	SPH_C32(0xa76f6f16), SPH_C32(0x39c5c56d), SPH_C32(0xc0303090),
127  	SPH_C32(0x04010107), SPH_C32(0x8767672e), SPH_C32(0xac2b2bd1),
128  	SPH_C32(0xd5fefecc), SPH_C32(0x71d7d713), SPH_C32(0x9aabab7c),
129  	SPH_C32(0xc3767659), SPH_C32(0x05caca40), SPH_C32(0x3e8282a3),
130  	SPH_C32(0x09c9c949), SPH_C32(0xef7d7d68), SPH_C32(0xc5fafad0),
131  	SPH_C32(0x7f595994), SPH_C32(0x074747ce), SPH_C32(0xedf0f0e6),
132  	SPH_C32(0x82adad6e), SPH_C32(0x7dd4d41a), SPH_C32(0xbea2a243),
133  	SPH_C32(0x8aafaf60), SPH_C32(0x469c9cf9), SPH_C32(0xa6a4a451),
134  	SPH_C32(0xd3727245), SPH_C32(0x2dc0c076), SPH_C32(0xeab7b728),
135  	SPH_C32(0xd9fdfdc5), SPH_C32(0x7a9393d4), SPH_C32(0x982626f2),
136  	SPH_C32(0xd8363682), SPH_C32(0xfc3f3fbd), SPH_C32(0xf1f7f7f3),
137  	SPH_C32(0x1dcccc52), SPH_C32(0xd034348c), SPH_C32(0xa2a5a556),
138  	SPH_C32(0xb9e5e58d), SPH_C32(0xe9f1f1e1), SPH_C32(0xdf71714c),
139  	SPH_C32(0x4dd8d83e), SPH_C32(0xc4313197), SPH_C32(0x5415156b),
140  	SPH_C32(0x1004041c), SPH_C32(0x31c7c763), SPH_C32(0x8c2323e9),
141  	SPH_C32(0x21c3c37f), SPH_C32(0x60181848), SPH_C32(0x6e9696cf),
142  	SPH_C32(0x1405051b), SPH_C32(0x5e9a9aeb), SPH_C32(0x1c070715),
143  	SPH_C32(0x4812127e), SPH_C32(0x368080ad), SPH_C32(0xa5e2e298),
144  	SPH_C32(0x81ebeba7), SPH_C32(0x9c2727f5), SPH_C32(0xfeb2b233),
145  	SPH_C32(0xcf757550), SPH_C32(0x2409093f), SPH_C32(0x3a8383a4),
146  	SPH_C32(0xb02c2cc4), SPH_C32(0x681a1a46), SPH_C32(0x6c1b1b41),
147  	SPH_C32(0xa36e6e11), SPH_C32(0x735a5a9d), SPH_C32(0xb6a0a04d),
148  	SPH_C32(0x535252a5), SPH_C32(0xec3b3ba1), SPH_C32(0x75d6d614),
149  	SPH_C32(0xfab3b334), SPH_C32(0xa42929df), SPH_C32(0xa1e3e39f),
150  	SPH_C32(0xbc2f2fcd), SPH_C32(0x268484b1), SPH_C32(0x575353a2),
151  	SPH_C32(0x69d1d101), SPH_C32(0x00000000), SPH_C32(0x99ededb5),
152  	SPH_C32(0x802020e0), SPH_C32(0xddfcfcc2), SPH_C32(0xf2b1b13a),
153  	SPH_C32(0x775b5b9a), SPH_C32(0xb36a6a0d), SPH_C32(0x01cbcb47),
154  	SPH_C32(0xcebebe17), SPH_C32(0xe43939af), SPH_C32(0x334a4aed),
155  	SPH_C32(0x2b4c4cff), SPH_C32(0x7b585893), SPH_C32(0x11cfcf5b),
156  	SPH_C32(0x6dd0d006), SPH_C32(0x91efefbb), SPH_C32(0x9eaaaa7b),
157  	SPH_C32(0xc1fbfbd7), SPH_C32(0x174343d2), SPH_C32(0x2f4d4df8),
158  	SPH_C32(0xcc333399), SPH_C32(0x228585b6), SPH_C32(0x0f4545c0),
159  	SPH_C32(0xc9f9f9d9), SPH_C32(0x0802020e), SPH_C32(0xe77f7f66),
160  	SPH_C32(0x5b5050ab), SPH_C32(0xf03c3cb4), SPH_C32(0x4a9f9ff0),
161  	SPH_C32(0x96a8a875), SPH_C32(0x5f5151ac), SPH_C32(0xbaa3a344),
162  	SPH_C32(0x1b4040db), SPH_C32(0x0a8f8f80), SPH_C32(0x7e9292d3),
163  	SPH_C32(0x429d9dfe), SPH_C32(0xe03838a8), SPH_C32(0xf9f5f5fd),
164  	SPH_C32(0xc6bcbc19), SPH_C32(0xeeb6b62f), SPH_C32(0x45dada30),
165  	SPH_C32(0x842121e7), SPH_C32(0x40101070), SPH_C32(0xd1ffffcb),
166  	SPH_C32(0xe1f3f3ef), SPH_C32(0x65d2d208), SPH_C32(0x19cdcd55),
167  	SPH_C32(0x300c0c24), SPH_C32(0x4c131379), SPH_C32(0x9dececb2),
168  	SPH_C32(0x675f5f86), SPH_C32(0x6a9797c8), SPH_C32(0x0b4444c7),
169  	SPH_C32(0x5c171765), SPH_C32(0x3dc4c46a), SPH_C32(0xaaa7a758),
170  	SPH_C32(0xe37e7e61), SPH_C32(0xf43d3db3), SPH_C32(0x8b646427),
171  	SPH_C32(0x6f5d5d88), SPH_C32(0x6419194f), SPH_C32(0xd7737342),
172  	SPH_C32(0x9b60603b), SPH_C32(0x328181aa), SPH_C32(0x274f4ff6),
173  	SPH_C32(0x5ddcdc22), SPH_C32(0x882222ee), SPH_C32(0xa82a2ad6),
174  	SPH_C32(0x769090dd), SPH_C32(0x16888895), SPH_C32(0x034646c9),
175  	SPH_C32(0x95eeeebc), SPH_C32(0xd6b8b805), SPH_C32(0x5014146c),
176  	SPH_C32(0x55dede2c), SPH_C32(0x635e5e81), SPH_C32(0x2c0b0b31),
177  	SPH_C32(0x41dbdb37), SPH_C32(0xade0e096), SPH_C32(0xc832329e),
178  	SPH_C32(0xe83a3aa6), SPH_C32(0x280a0a36), SPH_C32(0x3f4949e4),
179  	SPH_C32(0x18060612), SPH_C32(0x902424fc), SPH_C32(0x6b5c5c8f),
180  	SPH_C32(0x25c2c278), SPH_C32(0x61d3d30f), SPH_C32(0x86acac69),
181  	SPH_C32(0x93626235), SPH_C32(0x729191da), SPH_C32(0x629595c6),
182  	SPH_C32(0xbde4e48a), SPH_C32(0xff797974), SPH_C32(0xb1e7e783),
183  	SPH_C32(0x0dc8c84e), SPH_C32(0xdc373785), SPH_C32(0xaf6d6d18),
184  	SPH_C32(0x028d8d8e), SPH_C32(0x79d5d51d), SPH_C32(0x234e4ef1),
185  	SPH_C32(0x92a9a972), SPH_C32(0xab6c6c1f), SPH_C32(0x435656b9),
186  	SPH_C32(0xfdf4f4fa), SPH_C32(0x85eaeaa0), SPH_C32(0x8f656520),
187  	SPH_C32(0xf37a7a7d), SPH_C32(0x8eaeae67), SPH_C32(0x20080838),
188  	SPH_C32(0xdebaba0b), SPH_C32(0xfb787873), SPH_C32(0x942525fb),
189  	SPH_C32(0xb82e2eca), SPH_C32(0x701c1c54), SPH_C32(0xaea6a65f),
190  	SPH_C32(0xe6b4b421), SPH_C32(0x35c6c664), SPH_C32(0x8de8e8ae),
191  	SPH_C32(0x59dddd25), SPH_C32(0xcb747457), SPH_C32(0x7c1f1f5d),
192  	SPH_C32(0x374b4bea), SPH_C32(0xc2bdbd1e), SPH_C32(0x1a8b8b9c),
193  	SPH_C32(0x1e8a8a9b), SPH_C32(0xdb70704b), SPH_C32(0xf83e3eba),
194  	SPH_C32(0xe2b5b526), SPH_C32(0x83666629), SPH_C32(0x3b4848e3),
195  	SPH_C32(0x0c030309), SPH_C32(0xf5f6f6f4), SPH_C32(0x380e0e2a),
196  	SPH_C32(0x9f61613c), SPH_C32(0xd435358b), SPH_C32(0x475757be),
197  	SPH_C32(0xd2b9b902), SPH_C32(0x2e8686bf), SPH_C32(0x29c1c171),
198  	SPH_C32(0x741d1d53), SPH_C32(0x4e9e9ef7), SPH_C32(0xa9e1e191),
199  	SPH_C32(0xcdf8f8de), SPH_C32(0x569898e5), SPH_C32(0x44111177),
200  	SPH_C32(0xbf696904), SPH_C32(0x49d9d939), SPH_C32(0x0e8e8e87),
201  	SPH_C32(0x669494c1), SPH_C32(0x5a9b9bec), SPH_C32(0x781e1e5a),
202  	SPH_C32(0x2a8787b8), SPH_C32(0x89e9e9a9), SPH_C32(0x15cece5c),
203  	SPH_C32(0x4f5555b0), SPH_C32(0xa02828d8), SPH_C32(0x51dfdf2b),
204  	SPH_C32(0x068c8c89), SPH_C32(0xb2a1a14a), SPH_C32(0x12898992),
205  	SPH_C32(0x340d0d23), SPH_C32(0xcabfbf10), SPH_C32(0xb5e6e684),
206  	SPH_C32(0x134242d5), SPH_C32(0xbb686803), SPH_C32(0x1f4141dc),
207  	SPH_C32(0x529999e2), SPH_C32(0xb42d2dc3), SPH_C32(0x3c0f0f2d),
208  	SPH_C32(0xf6b0b03d), SPH_C32(0x4b5454b7), SPH_C32(0xdabbbb0c),
209  	SPH_C32(0x58161662)
210  };
211  static const sph_u32 mixtab2[] = {
212  	SPH_C32(0x32976363), SPH_C32(0x6feb7c7c), SPH_C32(0x5ec77777),
213  	SPH_C32(0x7af77b7b), SPH_C32(0xe8e5f2f2), SPH_C32(0x0ab76b6b),
214  	SPH_C32(0x16a76f6f), SPH_C32(0x6d39c5c5), SPH_C32(0x90c03030),
215  	SPH_C32(0x07040101), SPH_C32(0x2e876767), SPH_C32(0xd1ac2b2b),
216  	SPH_C32(0xccd5fefe), SPH_C32(0x1371d7d7), SPH_C32(0x7c9aabab),
217  	SPH_C32(0x59c37676), SPH_C32(0x4005caca), SPH_C32(0xa33e8282),
218  	SPH_C32(0x4909c9c9), SPH_C32(0x68ef7d7d), SPH_C32(0xd0c5fafa),
219  	SPH_C32(0x947f5959), SPH_C32(0xce074747), SPH_C32(0xe6edf0f0),
220  	SPH_C32(0x6e82adad), SPH_C32(0x1a7dd4d4), SPH_C32(0x43bea2a2),
221  	SPH_C32(0x608aafaf), SPH_C32(0xf9469c9c), SPH_C32(0x51a6a4a4),
222  	SPH_C32(0x45d37272), SPH_C32(0x762dc0c0), SPH_C32(0x28eab7b7),
223  	SPH_C32(0xc5d9fdfd), SPH_C32(0xd47a9393), SPH_C32(0xf2982626),
224  	SPH_C32(0x82d83636), SPH_C32(0xbdfc3f3f), SPH_C32(0xf3f1f7f7),
225  	SPH_C32(0x521dcccc), SPH_C32(0x8cd03434), SPH_C32(0x56a2a5a5),
226  	SPH_C32(0x8db9e5e5), SPH_C32(0xe1e9f1f1), SPH_C32(0x4cdf7171),
227  	SPH_C32(0x3e4dd8d8), SPH_C32(0x97c43131), SPH_C32(0x6b541515),
228  	SPH_C32(0x1c100404), SPH_C32(0x6331c7c7), SPH_C32(0xe98c2323),
229  	SPH_C32(0x7f21c3c3), SPH_C32(0x48601818), SPH_C32(0xcf6e9696),
230  	SPH_C32(0x1b140505), SPH_C32(0xeb5e9a9a), SPH_C32(0x151c0707),
231  	SPH_C32(0x7e481212), SPH_C32(0xad368080), SPH_C32(0x98a5e2e2),
232  	SPH_C32(0xa781ebeb), SPH_C32(0xf59c2727), SPH_C32(0x33feb2b2),
233  	SPH_C32(0x50cf7575), SPH_C32(0x3f240909), SPH_C32(0xa43a8383),
234  	SPH_C32(0xc4b02c2c), SPH_C32(0x46681a1a), SPH_C32(0x416c1b1b),
235  	SPH_C32(0x11a36e6e), SPH_C32(0x9d735a5a), SPH_C32(0x4db6a0a0),
236  	SPH_C32(0xa5535252), SPH_C32(0xa1ec3b3b), SPH_C32(0x1475d6d6),
237  	SPH_C32(0x34fab3b3), SPH_C32(0xdfa42929), SPH_C32(0x9fa1e3e3),
238  	SPH_C32(0xcdbc2f2f), SPH_C32(0xb1268484), SPH_C32(0xa2575353),
239  	SPH_C32(0x0169d1d1), SPH_C32(0x00000000), SPH_C32(0xb599eded),
240  	SPH_C32(0xe0802020), SPH_C32(0xc2ddfcfc), SPH_C32(0x3af2b1b1),
241  	SPH_C32(0x9a775b5b), SPH_C32(0x0db36a6a), SPH_C32(0x4701cbcb),
242  	SPH_C32(0x17cebebe), SPH_C32(0xafe43939), SPH_C32(0xed334a4a),
243  	SPH_C32(0xff2b4c4c), SPH_C32(0x937b5858), SPH_C32(0x5b11cfcf),
244  	SPH_C32(0x066dd0d0), SPH_C32(0xbb91efef), SPH_C32(0x7b9eaaaa),
245  	SPH_C32(0xd7c1fbfb), SPH_C32(0xd2174343), SPH_C32(0xf82f4d4d),
246  	SPH_C32(0x99cc3333), SPH_C32(0xb6228585), SPH_C32(0xc00f4545),
247  	SPH_C32(0xd9c9f9f9), SPH_C32(0x0e080202), SPH_C32(0x66e77f7f),
248  	SPH_C32(0xab5b5050), SPH_C32(0xb4f03c3c), SPH_C32(0xf04a9f9f),
249  	SPH_C32(0x7596a8a8), SPH_C32(0xac5f5151), SPH_C32(0x44baa3a3),
250  	SPH_C32(0xdb1b4040), SPH_C32(0x800a8f8f), SPH_C32(0xd37e9292),
251  	SPH_C32(0xfe429d9d), SPH_C32(0xa8e03838), SPH_C32(0xfdf9f5f5),
252  	SPH_C32(0x19c6bcbc), SPH_C32(0x2feeb6b6), SPH_C32(0x3045dada),
253  	SPH_C32(0xe7842121), SPH_C32(0x70401010), SPH_C32(0xcbd1ffff),
254  	SPH_C32(0xefe1f3f3), SPH_C32(0x0865d2d2), SPH_C32(0x5519cdcd),
255  	SPH_C32(0x24300c0c), SPH_C32(0x794c1313), SPH_C32(0xb29decec),
256  	SPH_C32(0x86675f5f), SPH_C32(0xc86a9797), SPH_C32(0xc70b4444),
257  	SPH_C32(0x655c1717), SPH_C32(0x6a3dc4c4), SPH_C32(0x58aaa7a7),
258  	SPH_C32(0x61e37e7e), SPH_C32(0xb3f43d3d), SPH_C32(0x278b6464),
259  	SPH_C32(0x886f5d5d), SPH_C32(0x4f641919), SPH_C32(0x42d77373),
260  	SPH_C32(0x3b9b6060), SPH_C32(0xaa328181), SPH_C32(0xf6274f4f),
261  	SPH_C32(0x225ddcdc), SPH_C32(0xee882222), SPH_C32(0xd6a82a2a),
262  	SPH_C32(0xdd769090), SPH_C32(0x95168888), SPH_C32(0xc9034646),
263  	SPH_C32(0xbc95eeee), SPH_C32(0x05d6b8b8), SPH_C32(0x6c501414),
264  	SPH_C32(0x2c55dede), SPH_C32(0x81635e5e), SPH_C32(0x312c0b0b),
265  	SPH_C32(0x3741dbdb), SPH_C32(0x96ade0e0), SPH_C32(0x9ec83232),
266  	SPH_C32(0xa6e83a3a), SPH_C32(0x36280a0a), SPH_C32(0xe43f4949),
267  	SPH_C32(0x12180606), SPH_C32(0xfc902424), SPH_C32(0x8f6b5c5c),
268  	SPH_C32(0x7825c2c2), SPH_C32(0x0f61d3d3), SPH_C32(0x6986acac),
269  	SPH_C32(0x35936262), SPH_C32(0xda729191), SPH_C32(0xc6629595),
270  	SPH_C32(0x8abde4e4), SPH_C32(0x74ff7979), SPH_C32(0x83b1e7e7),
271  	SPH_C32(0x4e0dc8c8), SPH_C32(0x85dc3737), SPH_C32(0x18af6d6d),
272  	SPH_C32(0x8e028d8d), SPH_C32(0x1d79d5d5), SPH_C32(0xf1234e4e),
273  	SPH_C32(0x7292a9a9), SPH_C32(0x1fab6c6c), SPH_C32(0xb9435656),
274  	SPH_C32(0xfafdf4f4), SPH_C32(0xa085eaea), SPH_C32(0x208f6565),
275  	SPH_C32(0x7df37a7a), SPH_C32(0x678eaeae), SPH_C32(0x38200808),
276  	SPH_C32(0x0bdebaba), SPH_C32(0x73fb7878), SPH_C32(0xfb942525),
277  	SPH_C32(0xcab82e2e), SPH_C32(0x54701c1c), SPH_C32(0x5faea6a6),
278  	SPH_C32(0x21e6b4b4), SPH_C32(0x6435c6c6), SPH_C32(0xae8de8e8),
279  	SPH_C32(0x2559dddd), SPH_C32(0x57cb7474), SPH_C32(0x5d7c1f1f),
280  	SPH_C32(0xea374b4b), SPH_C32(0x1ec2bdbd), SPH_C32(0x9c1a8b8b),
281  	SPH_C32(0x9b1e8a8a), SPH_C32(0x4bdb7070), SPH_C32(0xbaf83e3e),
282  	SPH_C32(0x26e2b5b5), SPH_C32(0x29836666), SPH_C32(0xe33b4848),
283  	SPH_C32(0x090c0303), SPH_C32(0xf4f5f6f6), SPH_C32(0x2a380e0e),
284  	SPH_C32(0x3c9f6161), SPH_C32(0x8bd43535), SPH_C32(0xbe475757),
285  	SPH_C32(0x02d2b9b9), SPH_C32(0xbf2e8686), SPH_C32(0x7129c1c1),
286  	SPH_C32(0x53741d1d), SPH_C32(0xf74e9e9e), SPH_C32(0x91a9e1e1),
287  	SPH_C32(0xdecdf8f8), SPH_C32(0xe5569898), SPH_C32(0x77441111),
288  	SPH_C32(0x04bf6969), SPH_C32(0x3949d9d9), SPH_C32(0x870e8e8e),
289  	SPH_C32(0xc1669494), SPH_C32(0xec5a9b9b), SPH_C32(0x5a781e1e),
290  	SPH_C32(0xb82a8787), SPH_C32(0xa989e9e9), SPH_C32(0x5c15cece),
291  	SPH_C32(0xb04f5555), SPH_C32(0xd8a02828), SPH_C32(0x2b51dfdf),
292  	SPH_C32(0x89068c8c), SPH_C32(0x4ab2a1a1), SPH_C32(0x92128989),
293  	SPH_C32(0x23340d0d), SPH_C32(0x10cabfbf), SPH_C32(0x84b5e6e6),
294  	SPH_C32(0xd5134242), SPH_C32(0x03bb6868), SPH_C32(0xdc1f4141),
295  	SPH_C32(0xe2529999), SPH_C32(0xc3b42d2d), SPH_C32(0x2d3c0f0f),
296  	SPH_C32(0x3df6b0b0), SPH_C32(0xb74b5454), SPH_C32(0x0cdabbbb),
297  	SPH_C32(0x62581616)
298  };
299  static const sph_u32 mixtab3[] = {
300  	SPH_C32(0x63329763), SPH_C32(0x7c6feb7c), SPH_C32(0x775ec777),
301  	SPH_C32(0x7b7af77b), SPH_C32(0xf2e8e5f2), SPH_C32(0x6b0ab76b),
302  	SPH_C32(0x6f16a76f), SPH_C32(0xc56d39c5), SPH_C32(0x3090c030),
303  	SPH_C32(0x01070401), SPH_C32(0x672e8767), SPH_C32(0x2bd1ac2b),
304  	SPH_C32(0xfeccd5fe), SPH_C32(0xd71371d7), SPH_C32(0xab7c9aab),
305  	SPH_C32(0x7659c376), SPH_C32(0xca4005ca), SPH_C32(0x82a33e82),
306  	SPH_C32(0xc94909c9), SPH_C32(0x7d68ef7d), SPH_C32(0xfad0c5fa),
307  	SPH_C32(0x59947f59), SPH_C32(0x47ce0747), SPH_C32(0xf0e6edf0),
308  	SPH_C32(0xad6e82ad), SPH_C32(0xd41a7dd4), SPH_C32(0xa243bea2),
309  	SPH_C32(0xaf608aaf), SPH_C32(0x9cf9469c), SPH_C32(0xa451a6a4),
310  	SPH_C32(0x7245d372), SPH_C32(0xc0762dc0), SPH_C32(0xb728eab7),
311  	SPH_C32(0xfdc5d9fd), SPH_C32(0x93d47a93), SPH_C32(0x26f29826),
312  	SPH_C32(0x3682d836), SPH_C32(0x3fbdfc3f), SPH_C32(0xf7f3f1f7),
313  	SPH_C32(0xcc521dcc), SPH_C32(0x348cd034), SPH_C32(0xa556a2a5),
314  	SPH_C32(0xe58db9e5), SPH_C32(0xf1e1e9f1), SPH_C32(0x714cdf71),
315  	SPH_C32(0xd83e4dd8), SPH_C32(0x3197c431), SPH_C32(0x156b5415),
316  	SPH_C32(0x041c1004), SPH_C32(0xc76331c7), SPH_C32(0x23e98c23),
317  	SPH_C32(0xc37f21c3), SPH_C32(0x18486018), SPH_C32(0x96cf6e96),
318  	SPH_C32(0x051b1405), SPH_C32(0x9aeb5e9a), SPH_C32(0x07151c07),
319  	SPH_C32(0x127e4812), SPH_C32(0x80ad3680), SPH_C32(0xe298a5e2),
320  	SPH_C32(0xeba781eb), SPH_C32(0x27f59c27), SPH_C32(0xb233feb2),
321  	SPH_C32(0x7550cf75), SPH_C32(0x093f2409), SPH_C32(0x83a43a83),
322  	SPH_C32(0x2cc4b02c), SPH_C32(0x1a46681a), SPH_C32(0x1b416c1b),
323  	SPH_C32(0x6e11a36e), SPH_C32(0x5a9d735a), SPH_C32(0xa04db6a0),
324  	SPH_C32(0x52a55352), SPH_C32(0x3ba1ec3b), SPH_C32(0xd61475d6),
325  	SPH_C32(0xb334fab3), SPH_C32(0x29dfa429), SPH_C32(0xe39fa1e3),
326  	SPH_C32(0x2fcdbc2f), SPH_C32(0x84b12684), SPH_C32(0x53a25753),
327  	SPH_C32(0xd10169d1), SPH_C32(0x00000000), SPH_C32(0xedb599ed),
328  	SPH_C32(0x20e08020), SPH_C32(0xfcc2ddfc), SPH_C32(0xb13af2b1),
329  	SPH_C32(0x5b9a775b), SPH_C32(0x6a0db36a), SPH_C32(0xcb4701cb),
330  	SPH_C32(0xbe17cebe), SPH_C32(0x39afe439), SPH_C32(0x4aed334a),
331  	SPH_C32(0x4cff2b4c), SPH_C32(0x58937b58), SPH_C32(0xcf5b11cf),
332  	SPH_C32(0xd0066dd0), SPH_C32(0xefbb91ef), SPH_C32(0xaa7b9eaa),
333  	SPH_C32(0xfbd7c1fb), SPH_C32(0x43d21743), SPH_C32(0x4df82f4d),
334  	SPH_C32(0x3399cc33), SPH_C32(0x85b62285), SPH_C32(0x45c00f45),
335  	SPH_C32(0xf9d9c9f9), SPH_C32(0x020e0802), SPH_C32(0x7f66e77f),
336  	SPH_C32(0x50ab5b50), SPH_C32(0x3cb4f03c), SPH_C32(0x9ff04a9f),
337  	SPH_C32(0xa87596a8), SPH_C32(0x51ac5f51), SPH_C32(0xa344baa3),
338  	SPH_C32(0x40db1b40), SPH_C32(0x8f800a8f), SPH_C32(0x92d37e92),
339  	SPH_C32(0x9dfe429d), SPH_C32(0x38a8e038), SPH_C32(0xf5fdf9f5),
340  	SPH_C32(0xbc19c6bc), SPH_C32(0xb62feeb6), SPH_C32(0xda3045da),
341  	SPH_C32(0x21e78421), SPH_C32(0x10704010), SPH_C32(0xffcbd1ff),
342  	SPH_C32(0xf3efe1f3), SPH_C32(0xd20865d2), SPH_C32(0xcd5519cd),
343  	SPH_C32(0x0c24300c), SPH_C32(0x13794c13), SPH_C32(0xecb29dec),
344  	SPH_C32(0x5f86675f), SPH_C32(0x97c86a97), SPH_C32(0x44c70b44),
345  	SPH_C32(0x17655c17), SPH_C32(0xc46a3dc4), SPH_C32(0xa758aaa7),
346  	SPH_C32(0x7e61e37e), SPH_C32(0x3db3f43d), SPH_C32(0x64278b64),
347  	SPH_C32(0x5d886f5d), SPH_C32(0x194f6419), SPH_C32(0x7342d773),
348  	SPH_C32(0x603b9b60), SPH_C32(0x81aa3281), SPH_C32(0x4ff6274f),
349  	SPH_C32(0xdc225ddc), SPH_C32(0x22ee8822), SPH_C32(0x2ad6a82a),
350  	SPH_C32(0x90dd7690), SPH_C32(0x88951688), SPH_C32(0x46c90346),
351  	SPH_C32(0xeebc95ee), SPH_C32(0xb805d6b8), SPH_C32(0x146c5014),
352  	SPH_C32(0xde2c55de), SPH_C32(0x5e81635e), SPH_C32(0x0b312c0b),
353  	SPH_C32(0xdb3741db), SPH_C32(0xe096ade0), SPH_C32(0x329ec832),
354  	SPH_C32(0x3aa6e83a), SPH_C32(0x0a36280a), SPH_C32(0x49e43f49),
355  	SPH_C32(0x06121806), SPH_C32(0x24fc9024), SPH_C32(0x5c8f6b5c),
356  	SPH_C32(0xc27825c2), SPH_C32(0xd30f61d3), SPH_C32(0xac6986ac),
357  	SPH_C32(0x62359362), SPH_C32(0x91da7291), SPH_C32(0x95c66295),
358  	SPH_C32(0xe48abde4), SPH_C32(0x7974ff79), SPH_C32(0xe783b1e7),
359  	SPH_C32(0xc84e0dc8), SPH_C32(0x3785dc37), SPH_C32(0x6d18af6d),
360  	SPH_C32(0x8d8e028d), SPH_C32(0xd51d79d5), SPH_C32(0x4ef1234e),
361  	SPH_C32(0xa97292a9), SPH_C32(0x6c1fab6c), SPH_C32(0x56b94356),
362  	SPH_C32(0xf4fafdf4), SPH_C32(0xeaa085ea), SPH_C32(0x65208f65),
363  	SPH_C32(0x7a7df37a), SPH_C32(0xae678eae), SPH_C32(0x08382008),
364  	SPH_C32(0xba0bdeba), SPH_C32(0x7873fb78), SPH_C32(0x25fb9425),
365  	SPH_C32(0x2ecab82e), SPH_C32(0x1c54701c), SPH_C32(0xa65faea6),
366  	SPH_C32(0xb421e6b4), SPH_C32(0xc66435c6), SPH_C32(0xe8ae8de8),
367  	SPH_C32(0xdd2559dd), SPH_C32(0x7457cb74), SPH_C32(0x1f5d7c1f),
368  	SPH_C32(0x4bea374b), SPH_C32(0xbd1ec2bd), SPH_C32(0x8b9c1a8b),
369  	SPH_C32(0x8a9b1e8a), SPH_C32(0x704bdb70), SPH_C32(0x3ebaf83e),
370  	SPH_C32(0xb526e2b5), SPH_C32(0x66298366), SPH_C32(0x48e33b48),
371  	SPH_C32(0x03090c03), SPH_C32(0xf6f4f5f6), SPH_C32(0x0e2a380e),
372  	SPH_C32(0x613c9f61), SPH_C32(0x358bd435), SPH_C32(0x57be4757),
373  	SPH_C32(0xb902d2b9), SPH_C32(0x86bf2e86), SPH_C32(0xc17129c1),
374  	SPH_C32(0x1d53741d), SPH_C32(0x9ef74e9e), SPH_C32(0xe191a9e1),
375  	SPH_C32(0xf8decdf8), SPH_C32(0x98e55698), SPH_C32(0x11774411),
376  	SPH_C32(0x6904bf69), SPH_C32(0xd93949d9), SPH_C32(0x8e870e8e),
377  	SPH_C32(0x94c16694), SPH_C32(0x9bec5a9b), SPH_C32(0x1e5a781e),
378  	SPH_C32(0x87b82a87), SPH_C32(0xe9a989e9), SPH_C32(0xce5c15ce),
379  	SPH_C32(0x55b04f55), SPH_C32(0x28d8a028), SPH_C32(0xdf2b51df),
380  	SPH_C32(0x8c89068c), SPH_C32(0xa14ab2a1), SPH_C32(0x89921289),
381  	SPH_C32(0x0d23340d), SPH_C32(0xbf10cabf), SPH_C32(0xe684b5e6),
382  	SPH_C32(0x42d51342), SPH_C32(0x6803bb68), SPH_C32(0x41dc1f41),
383  	SPH_C32(0x99e25299), SPH_C32(0x2dc3b42d), SPH_C32(0x0f2d3c0f),
384  	SPH_C32(0xb03df6b0), SPH_C32(0x54b74b54), SPH_C32(0xbb0cdabb),
385  	SPH_C32(0x16625816)
386  };
387  #define TIX2(q, x00, x01, x08, x10, x24)   do { \
388  		x10 ^= x00; \
389  		x00 = (q); \
390  		x08 ^= x00; \
391  		x01 ^= x24; \
392  	} while (0)
393  #define TIX3(q, x00, x01, x04, x08, x16, x27, x30)   do { \
394  		x16 ^= x00; \
395  		x00 = (q); \
396  		x08 ^= x00; \
397  		x01 ^= x27; \
398  		x04 ^= x30; \
399  	} while (0)
400  #define TIX4(q, x00, x01, x04, x07, x08, x22, x24, x27, x30)   do { \
401  		x22 ^= x00; \
402  		x00 = (q); \
403  		x08 ^= x00; \
404  		x01 ^= x24; \
405  		x04 ^= x27; \
406  		x07 ^= x30; \
407  	} while (0)
408  #define CMIX30(x00, x01, x02, x04, x05, x06, x15, x16, x17)   do { \
409  		x00 ^= x04; \
410  		x01 ^= x05; \
411  		x02 ^= x06; \
412  		x15 ^= x04; \
413  		x16 ^= x05; \
414  		x17 ^= x06; \
415  	} while (0)
416  #define CMIX36(x00, x01, x02, x04, x05, x06, x18, x19, x20)   do { \
417  		x00 ^= x04; \
418  		x01 ^= x05; \
419  		x02 ^= x06; \
420  		x18 ^= x04; \
421  		x19 ^= x05; \
422  		x20 ^= x06; \
423  	} while (0)
424  #define SMIX(x0, x1, x2, x3)   do { \
425  		sph_u32 c0 = 0; \
426  		sph_u32 c1 = 0; \
427  		sph_u32 c2 = 0; \
428  		sph_u32 c3 = 0; \
429  		sph_u32 r0 = 0; \
430  		sph_u32 r1 = 0; \
431  		sph_u32 r2 = 0; \
432  		sph_u32 r3 = 0; \
433  		sph_u32 tmp; \
434  		tmp = mixtab0[x0 >> 24]; \
435  		c0 ^= tmp; \
436  		tmp = mixtab1[(x0 >> 16) & 0xFF]; \
437  		c0 ^= tmp; \
438  		r1 ^= tmp; \
439  		tmp = mixtab2[(x0 >>  8) & 0xFF]; \
440  		c0 ^= tmp; \
441  		r2 ^= tmp; \
442  		tmp = mixtab3[x0 & 0xFF]; \
443  		c0 ^= tmp; \
444  		r3 ^= tmp; \
445  		tmp = mixtab0[x1 >> 24]; \
446  		c1 ^= tmp; \
447  		r0 ^= tmp; \
448  		tmp = mixtab1[(x1 >> 16) & 0xFF]; \
449  		c1 ^= tmp; \
450  		tmp = mixtab2[(x1 >>  8) & 0xFF]; \
451  		c1 ^= tmp; \
452  		r2 ^= tmp; \
453  		tmp = mixtab3[x1 & 0xFF]; \
454  		c1 ^= tmp; \
455  		r3 ^= tmp; \
456  		tmp = mixtab0[x2 >> 24]; \
457  		c2 ^= tmp; \
458  		r0 ^= tmp; \
459  		tmp = mixtab1[(x2 >> 16) & 0xFF]; \
460  		c2 ^= tmp; \
461  		r1 ^= tmp; \
462  		tmp = mixtab2[(x2 >>  8) & 0xFF]; \
463  		c2 ^= tmp; \
464  		tmp = mixtab3[x2 & 0xFF]; \
465  		c2 ^= tmp; \
466  		r3 ^= tmp; \
467  		tmp = mixtab0[x3 >> 24]; \
468  		c3 ^= tmp; \
469  		r0 ^= tmp; \
470  		tmp = mixtab1[(x3 >> 16) & 0xFF]; \
471  		c3 ^= tmp; \
472  		r1 ^= tmp; \
473  		tmp = mixtab2[(x3 >>  8) & 0xFF]; \
474  		c3 ^= tmp; \
475  		r2 ^= tmp; \
476  		tmp = mixtab3[x3 & 0xFF]; \
477  		c3 ^= tmp; \
478  		x0 = ((c0 ^ r0) & SPH_C32(0xFF000000)) \
479  			| ((c1 ^ r1) & SPH_C32(0x00FF0000)) \
480  			| ((c2 ^ r2) & SPH_C32(0x0000FF00)) \
481  			| ((c3 ^ r3) & SPH_C32(0x000000FF)); \
482  		x1 = ((c1 ^ (r0 << 8)) & SPH_C32(0xFF000000)) \
483  			| ((c2 ^ (r1 << 8)) & SPH_C32(0x00FF0000)) \
484  			| ((c3 ^ (r2 << 8)) & SPH_C32(0x0000FF00)) \
485  			| ((c0 ^ (r3 >> 24)) & SPH_C32(0x000000FF)); \
486  		x2 = ((c2 ^ (r0 << 16)) & SPH_C32(0xFF000000)) \
487  			| ((c3 ^ (r1 << 16)) & SPH_C32(0x00FF0000)) \
488  			| ((c0 ^ (r2 >> 16)) & SPH_C32(0x0000FF00)) \
489  			| ((c1 ^ (r3 >> 16)) & SPH_C32(0x000000FF)); \
490  		x3 = ((c3 ^ (r0 << 24)) & SPH_C32(0xFF000000)) \
491  			| ((c0 ^ (r1 >> 8)) & SPH_C32(0x00FF0000)) \
492  			| ((c1 ^ (r2 >> 8)) & SPH_C32(0x0000FF00)) \
493  			| ((c2 ^ (r3 >> 8)) & SPH_C32(0x000000FF)); \
494  		 \
495  	} while (0)
496  #if SPH_FUGUE_NOCOPY
497  #define DECL_STATE_SMALL
498  #define READ_STATE_SMALL(state)
499  #define WRITE_STATE_SMALL(state)
500  #define DECL_STATE_BIG
501  #define READ_STATE_BIG(state)
502  #define WRITE_STATE_BIG(state)
503  #define S00   ((sc)->S[ 0])
504  #define S01   ((sc)->S[ 1])
505  #define S02   ((sc)->S[ 2])
506  #define S03   ((sc)->S[ 3])
507  #define S04   ((sc)->S[ 4])
508  #define S05   ((sc)->S[ 5])
509  #define S06   ((sc)->S[ 6])
510  #define S07   ((sc)->S[ 7])
511  #define S08   ((sc)->S[ 8])
512  #define S09   ((sc)->S[ 9])
513  #define S10   ((sc)->S[10])
514  #define S11   ((sc)->S[11])
515  #define S12   ((sc)->S[12])
516  #define S13   ((sc)->S[13])
517  #define S14   ((sc)->S[14])
518  #define S15   ((sc)->S[15])
519  #define S16   ((sc)->S[16])
520  #define S17   ((sc)->S[17])
521  #define S18   ((sc)->S[18])
522  #define S19   ((sc)->S[19])
523  #define S20   ((sc)->S[20])
524  #define S21   ((sc)->S[21])
525  #define S22   ((sc)->S[22])
526  #define S23   ((sc)->S[23])
527  #define S24   ((sc)->S[24])
528  #define S25   ((sc)->S[25])
529  #define S26   ((sc)->S[26])
530  #define S27   ((sc)->S[27])
531  #define S28   ((sc)->S[28])
532  #define S29   ((sc)->S[29])
533  #define S30   ((sc)->S[30])
534  #define S31   ((sc)->S[31])
535  #define S32   ((sc)->S[32])
536  #define S33   ((sc)->S[33])
537  #define S34   ((sc)->S[34])
538  #define S35   ((sc)->S[35])
539  #else
540  #define DECL_STATE_SMALL \
541  	sph_u32 S00, S01, S02, S03, S04, S05, S06, S07, S08, S09; \
542  	sph_u32 S10, S11, S12, S13, S14, S15, S16, S17, S18, S19; \
543  	sph_u32 S20, S21, S22, S23, S24, S25, S26, S27, S28, S29;
544  #define DECL_STATE_BIG \
545  	DECL_STATE_SMALL \
546  	sph_u32 S30, S31, S32, S33, S34, S35;
547  #define READ_STATE_SMALL(state)   do { \
548  		S00 = (state)->S[ 0]; \
549  		S01 = (state)->S[ 1]; \
550  		S02 = (state)->S[ 2]; \
551  		S03 = (state)->S[ 3]; \
552  		S04 = (state)->S[ 4]; \
553  		S05 = (state)->S[ 5]; \
554  		S06 = (state)->S[ 6]; \
555  		S07 = (state)->S[ 7]; \
556  		S08 = (state)->S[ 8]; \
557  		S09 = (state)->S[ 9]; \
558  		S10 = (state)->S[10]; \
559  		S11 = (state)->S[11]; \
560  		S12 = (state)->S[12]; \
561  		S13 = (state)->S[13]; \
562  		S14 = (state)->S[14]; \
563  		S15 = (state)->S[15]; \
564  		S16 = (state)->S[16]; \
565  		S17 = (state)->S[17]; \
566  		S18 = (state)->S[18]; \
567  		S19 = (state)->S[19]; \
568  		S20 = (state)->S[20]; \
569  		S21 = (state)->S[21]; \
570  		S22 = (state)->S[22]; \
571  		S23 = (state)->S[23]; \
572  		S24 = (state)->S[24]; \
573  		S25 = (state)->S[25]; \
574  		S26 = (state)->S[26]; \
575  		S27 = (state)->S[27]; \
576  		S28 = (state)->S[28]; \
577  		S29 = (state)->S[29]; \
578  	} while (0)
579  #define READ_STATE_BIG(state)   do { \
580  		READ_STATE_SMALL(state); \
581  		S30 = (state)->S[30]; \
582  		S31 = (state)->S[31]; \
583  		S32 = (state)->S[32]; \
584  		S33 = (state)->S[33]; \
585  		S34 = (state)->S[34]; \
586  		S35 = (state)->S[35]; \
587  	} while (0)
588  #define WRITE_STATE_SMALL(state)   do { \
589  		(state)->S[ 0] = S00; \
590  		(state)->S[ 1] = S01; \
591  		(state)->S[ 2] = S02; \
592  		(state)->S[ 3] = S03; \
593  		(state)->S[ 4] = S04; \
594  		(state)->S[ 5] = S05; \
595  		(state)->S[ 6] = S06; \
596  		(state)->S[ 7] = S07; \
597  		(state)->S[ 8] = S08; \
598  		(state)->S[ 9] = S09; \
599  		(state)->S[10] = S10; \
600  		(state)->S[11] = S11; \
601  		(state)->S[12] = S12; \
602  		(state)->S[13] = S13; \
603  		(state)->S[14] = S14; \
604  		(state)->S[15] = S15; \
605  		(state)->S[16] = S16; \
606  		(state)->S[17] = S17; \
607  		(state)->S[18] = S18; \
608  		(state)->S[19] = S19; \
609  		(state)->S[20] = S20; \
610  		(state)->S[21] = S21; \
611  		(state)->S[22] = S22; \
612  		(state)->S[23] = S23; \
613  		(state)->S[24] = S24; \
614  		(state)->S[25] = S25; \
615  		(state)->S[26] = S26; \
616  		(state)->S[27] = S27; \
617  		(state)->S[28] = S28; \
618  		(state)->S[29] = S29; \
619  	} while (0)
620  #define WRITE_STATE_BIG(state)   do { \
621  		WRITE_STATE_SMALL(state); \
622  		(state)->S[30] = S30; \
623  		(state)->S[31] = S31; \
624  		(state)->S[32] = S32; \
625  		(state)->S[33] = S33; \
626  		(state)->S[34] = S34; \
627  		(state)->S[35] = S35; \
628  	} while (0)
629  #endif
630  static void
631  fugue_init(sph_fugue_context *sc, size_t z_len,
632  	const sph_u32 *iv, size_t iv_len)
633  {
634  	size_t u;
635  	for (u = 0; u < z_len; u ++)
636  		sc->S[u] = 0;
637  	memcpy(&sc->S[z_len], iv, iv_len * sizeof *iv);
638  	sc->partial = 0;
639  	sc->partial_len = 0;
640  	sc->round_shift = 0;
641  #if SPH_64
642  	sc->bit_count = 0;
643  #else
644  	sc->bit_count_high = 0;
645  	sc->bit_count_low = 0;
646  #endif
647  }
648  #if SPH_64
649  #define INCR_COUNTER   do { \
650  		sc->bit_count += (sph_u64)len << 3; \
651  	} while (0)
652  #else
653  #define INCR_COUNTER   do { \
654  		sph_u32 tmp = SPH_T32((sph_u32)len << 3); \
655  		sc->bit_count_low = SPH_T32(sc->bit_count_low + tmp); \
656  		if (sc->bit_count_low < tmp) \
657  			sc->bit_count_high ++; \
658  		sc->bit_count_high = SPH_T32(sc->bit_count_high \
659  			+ ((sph_u32)len >> 29)); \
660  	} while (0)
661  #endif
662  #define CORE_ENTRY \
663  	sph_u32 p; \
664  	unsigned plen, rshift; \
665  	INCR_COUNTER; \
666  	p = sc->partial; \
667  	plen = sc->partial_len; \
668  	if (plen < 4) { \
669  		unsigned count = 4 - plen; \
670  		if (len < count) \
671  			count = len; \
672  		plen += count; \
673  		while (count -- > 0) { \
674  			p = (p << 8) | *(const unsigned char *)data; \
675  			data = (const unsigned char *)data + 1; \
676  			len --; \
677  		} \
678  		if (len == 0) { \
679  			sc->partial = p; \
680  			sc->partial_len = plen; \
681  			return; \
682  		} \
683  	}
684  #define CORE_EXIT \
685  	p = 0; \
686  	sc->partial_len = (unsigned)len; \
687  	while (len -- > 0) { \
688  		p = (p << 8) | *(const unsigned char *)data; \
689  		data = (const unsigned char *)data + 1; \
690  	} \
691  	sc->partial = p; \
692  	sc->round_shift = rshift;
693  #define NEXT(rc) \
694  	if (len <= 4) { \
695  		rshift = (rc); \
696  		break; \
697  	} \
698  	p = sph_dec32be(data); \
699  	data = (const unsigned char *)data + 4; \
700  	len -= 4
701  static void
702  fugue2_core(sph_fugue_context *sc, const void *data, size_t len)
703  {
704  	DECL_STATE_SMALL
705  	CORE_ENTRY
706  	READ_STATE_SMALL(sc);
707  	rshift = sc->round_shift;
708  	switch (rshift) {
709  		for (;;) {
710  			sph_u32 q;
711  		case 0:
712  			q = p;
713  			TIX2(q, S00, S01, S08, S10, S24);
714  			CMIX30(S27, S28, S29, S01, S02, S03, S12, S13, S14);
715  			SMIX(S27, S28, S29, S00);
716  			CMIX30(S24, S25, S26, S28, S29, S00, S09, S10, S11);
717  			SMIX(S24, S25, S26, S27);
718  			NEXT(1);
719  		case 1:
720  			q = p;
721  			TIX2(q, S24, S25, S02, S04, S18);
722  			CMIX30(S21, S22, S23, S25, S26, S27, S06, S07, S08);
723  			SMIX(S21, S22, S23, S24);
724  			CMIX30(S18, S19, S20, S22, S23, S24, S03, S04, S05);
725  			SMIX(S18, S19, S20, S21);
726  			NEXT(2);
727  		case 2:
728  			q = p;
729  			TIX2(q, S18, S19, S26, S28, S12);
730  			CMIX30(S15, S16, S17, S19, S20, S21, S00, S01, S02);
731  			SMIX(S15, S16, S17, S18);
732  			CMIX30(S12, S13, S14, S16, S17, S18, S27, S28, S29);
733  			SMIX(S12, S13, S14, S15);
734  			NEXT(3);
735  		case 3:
736  			q = p;
737  			TIX2(q, S12, S13, S20, S22, S06);
738  			CMIX30(S09, S10, S11, S13, S14, S15, S24, S25, S26);
739  			SMIX(S09, S10, S11, S12);
740  			CMIX30(S06, S07, S08, S10, S11, S12, S21, S22, S23);
741  			SMIX(S06, S07, S08, S09);
742  			NEXT(4);
743  		case 4:
744  			q = p;
745  			TIX2(q, S06, S07, S14, S16, S00);
746  			CMIX30(S03, S04, S05, S07, S08, S09, S18, S19, S20);
747  			SMIX(S03, S04, S05, S06);
748  			CMIX30(S00, S01, S02, S04, S05, S06, S15, S16, S17);
749  			SMIX(S00, S01, S02, S03);
750  			NEXT(0);
751  		}
752  	}
753  	CORE_EXIT
754  	WRITE_STATE_SMALL(sc);
755  }
756  static void
757  fugue3_core(sph_fugue_context *sc, const void *data, size_t len)
758  {
759  	DECL_STATE_BIG
760  	CORE_ENTRY
761  	READ_STATE_BIG(sc);
762  	rshift = sc->round_shift;
763  	switch (rshift) {
764  		for (;;) {
765  			sph_u32 q;
766  		case 0:
767  			q = p;
768  			TIX3(q, S00, S01, S04, S08, S16, S27, S30);
769  			CMIX36(S33, S34, S35, S01, S02, S03, S15, S16, S17);
770  			SMIX(S33, S34, S35, S00);
771  			CMIX36(S30, S31, S32, S34, S35, S00, S12, S13, S14);
772  			SMIX(S30, S31, S32, S33);
773  			CMIX36(S27, S28, S29, S31, S32, S33, S09, S10, S11);
774  			SMIX(S27, S28, S29, S30);
775  			NEXT(1);
776  		case 1:
777  			q = p;
778  			TIX3(q, S27, S28, S31, S35, S07, S18, S21);
779  			CMIX36(S24, S25, S26, S28, S29, S30, S06, S07, S08);
780  			SMIX(S24, S25, S26, S27);
781  			CMIX36(S21, S22, S23, S25, S26, S27, S03, S04, S05);
782  			SMIX(S21, S22, S23, S24);
783  			CMIX36(S18, S19, S20, S22, S23, S24, S00, S01, S02);
784  			SMIX(S18, S19, S20, S21);
785  			NEXT(2);
786  		case 2:
787  			q = p;
788  			TIX3(q, S18, S19, S22, S26, S34, S09, S12);
789  			CMIX36(S15, S16, S17, S19, S20, S21, S33, S34, S35);
790  			SMIX(S15, S16, S17, S18);
791  			CMIX36(S12, S13, S14, S16, S17, S18, S30, S31, S32);
792  			SMIX(S12, S13, S14, S15);
793  			CMIX36(S09, S10, S11, S13, S14, S15, S27, S28, S29);
794  			SMIX(S09, S10, S11, S12);
795  			NEXT(3);
796  		case 3:
797  			q = p;
798  			TIX3(q, S09, S10, S13, S17, S25, S00, S03);
799  			CMIX36(S06, S07, S08, S10, S11, S12, S24, S25, S26);
800  			SMIX(S06, S07, S08, S09);
801  			CMIX36(S03, S04, S05, S07, S08, S09, S21, S22, S23);
802  			SMIX(S03, S04, S05, S06);
803  			CMIX36(S00, S01, S02, S04, S05, S06, S18, S19, S20);
804  			SMIX(S00, S01, S02, S03);
805  			NEXT(0);
806  		}
807  	}
808  	CORE_EXIT
809  	WRITE_STATE_BIG(sc);
810  }
811  static void
812  fugue4_core(sph_fugue_context *sc, const void *data, size_t len)
813  {
814  	DECL_STATE_BIG
815  	CORE_ENTRY
816  	READ_STATE_BIG(sc);
817  	rshift = sc->round_shift;
818  	switch (rshift) {
819  		for (;;) {
820  			sph_u32 q;
821  		case 0:
822  			q = p;
823  			TIX4(q, S00, S01, S04, S07, S08, S22, S24, S27, S30);
824  			CMIX36(S33, S34, S35, S01, S02, S03, S15, S16, S17);
825  			SMIX(S33, S34, S35, S00);
826  			CMIX36(S30, S31, S32, S34, S35, S00, S12, S13, S14);
827  			SMIX(S30, S31, S32, S33);
828  			CMIX36(S27, S28, S29, S31, S32, S33, S09, S10, S11);
829  			SMIX(S27, S28, S29, S30);
830  			CMIX36(S24, S25, S26, S28, S29, S30, S06, S07, S08);
831  			SMIX(S24, S25, S26, S27);
832  			NEXT(1);
833  		case 1:
834  			q = p;
835  			TIX4(q, S24, S25, S28, S31, S32, S10, S12, S15, S18);
836  			CMIX36(S21, S22, S23, S25, S26, S27, S03, S04, S05);
837  			SMIX(S21, S22, S23, S24);
838  			CMIX36(S18, S19, S20, S22, S23, S24, S00, S01, S02);
839  			SMIX(S18, S19, S20, S21);
840  			CMIX36(S15, S16, S17, S19, S20, S21, S33, S34, S35);
841  			SMIX(S15, S16, S17, S18);
842  			CMIX36(S12, S13, S14, S16, S17, S18, S30, S31, S32);
843  			SMIX(S12, S13, S14, S15);
844  			NEXT(2);
845  		case 2:
846  			q = p;
847  			TIX4(q, S12, S13, S16, S19, S20, S34, S00, S03, S06);
848  			CMIX36(S09, S10, S11, S13, S14, S15, S27, S28, S29);
849  			SMIX(S09, S10, S11, S12);
850  			CMIX36(S06, S07, S08, S10, S11, S12, S24, S25, S26);
851  			SMIX(S06, S07, S08, S09);
852  			CMIX36(S03, S04, S05, S07, S08, S09, S21, S22, S23);
853  			SMIX(S03, S04, S05, S06);
854  			CMIX36(S00, S01, S02, S04, S05, S06, S18, S19, S20);
855  			SMIX(S00, S01, S02, S03);
856  			NEXT(0);
857  		}
858  	}
859  	CORE_EXIT
860  	WRITE_STATE_BIG(sc);
861  }
862  #if SPH_64
863  #define WRITE_COUNTER   do { \
864  		sph_enc64be(buf + 4, sc->bit_count + n); \
865  	} while (0)
866  #else
867  #define WRITE_COUNTER   do { \
868  		sph_enc32be(buf + 4, sc->bit_count_high); \
869  		sph_enc32be(buf + 8, sc->bit_count_low + n); \
870  	} while (0)
871  #endif
872  #define CLOSE_ENTRY(s, rcm, core) \
873  	unsigned char buf[16]; \
874  	unsigned plen, rms; \
875  	unsigned char *out; \
876  	sph_u32 S[s]; \
877  	plen = sc->partial_len; \
878  	WRITE_COUNTER; \
879  	if (plen == 0 && n == 0) { \
880  		plen = 4; \
881  	} else if (plen < 4 || n != 0) { \
882  		unsigned u; \
883   \
884  		if (plen == 4) \
885  			plen = 0; \
886  		buf[plen] = ub & ~(0xFFU >> n); \
887  		for (u = plen + 1; u < 4; u ++) \
888  			buf[u] = 0; \
889  	} \
890  	core(sc, buf + plen, (sizeof buf) - plen); \
891  	rms = sc->round_shift * (rcm); \
892  	memcpy(S, sc->S + (s) - rms, rms * sizeof(sph_u32)); \
893  	memcpy(S + rms, sc->S, ((s) - rms) * sizeof(sph_u32));
894  #define ROR(n, s)   do { \
895  		sph_u32 tmp[n]; \
896  		memcpy(tmp, S + ((s) - (n)), (n) * sizeof(sph_u32)); \
897  		memmove(S + (n), S, ((s) - (n)) * sizeof(sph_u32)); \
898  		memcpy(S, tmp, (n) * sizeof(sph_u32)); \
899  	} while (0)
900  static void
901  fugue2_close(sph_fugue_context *sc, unsigned ub, unsigned n,
902  	void *dst, size_t out_size_w32)
903  {
904  	int i;
905  	CLOSE_ENTRY(30, 6, fugue2_core)
<span onclick='openModal()' class='match'>906  	for (i = 0; i < 10; i ++) {
907  		ROR(3, 30);
908  		CMIX30(S[0], S[1], S[2], S[4], S[5], S[6], S[15], S[16], S[17]);
909  		SMIX(S[0], S[1], S[2], S[3]);
910  	}
911  	for (i = 0; i < 13; i ++) {
</span>912  		S[4] ^= S[0];
913  		S[15] ^= S[0];
914  		ROR(15, 30);
915  		SMIX(S[0], S[1], S[2], S[3]);
916  		S[4] ^= S[0];
917  		S[16] ^= S[0];
918  		ROR(14, 30);
919  		SMIX(S[0], S[1], S[2], S[3]);
920  	}
921  	S[4] ^= S[0];
922  	S[15] ^= S[0];
923  	out = dst;
924  	sph_enc32be(out +  0, S[ 1]);
925  	sph_enc32be(out +  4, S[ 2]);
926  	sph_enc32be(out +  8, S[ 3]);
927  	sph_enc32be(out + 12, S[ 4]);
928  	sph_enc32be(out + 16, S[15]);
929  	sph_enc32be(out + 20, S[16]);
930  	sph_enc32be(out + 24, S[17]);
931  	if (out_size_w32 == 8) {
932  		sph_enc32be(out + 28, S[18]);
933  		sph_fugue256_init(sc);
934  	} else {
935  		sph_fugue224_init(sc);
936  	}
937  }
938  static void
939  fugue3_close(sph_fugue_context *sc, unsigned ub, unsigned n, void *dst)
940  {
941  	int i;
942  	CLOSE_ENTRY(36, 9, fugue3_core)
943  	for (i = 0; i < 18; i ++) {
944  		ROR(3, 36);
945  		CMIX36(S[0], S[1], S[2], S[4], S[5], S[6], S[18], S[19], S[20]);
946  		SMIX(S[0], S[1], S[2], S[3]);
947  	}
948  	for (i = 0; i < 13; i ++) {
949  		S[4] ^= S[0];
950  		S[12] ^= S[0];
951  		S[24] ^= S[0];
952  		ROR(12, 36);
953  		SMIX(S[0], S[1], S[2], S[3]);
954  		S[4] ^= S[0];
955  		S[13] ^= S[0];
956  		S[24] ^= S[0];
957  		ROR(12, 36);
958  		SMIX(S[0], S[1], S[2], S[3]);
959  		S[4] ^= S[0];
960  		S[13] ^= S[0];
961  		S[25] ^= S[0];
962  		ROR(11, 36);
963  		SMIX(S[0], S[1], S[2], S[3]);
964  	}
965  	S[4] ^= S[0];
966  	S[12] ^= S[0];
967  	S[24] ^= S[0];
968  	out = dst;
969  	sph_enc32be(out +  0, S[ 1]);
970  	sph_enc32be(out +  4, S[ 2]);
971  	sph_enc32be(out +  8, S[ 3]);
972  	sph_enc32be(out + 12, S[ 4]);
973  	sph_enc32be(out + 16, S[12]);
974  	sph_enc32be(out + 20, S[13]);
975  	sph_enc32be(out + 24, S[14]);
976  	sph_enc32be(out + 28, S[15]);
977  	sph_enc32be(out + 32, S[24]);
978  	sph_enc32be(out + 36, S[25]);
979  	sph_enc32be(out + 40, S[26]);
980  	sph_enc32be(out + 44, S[27]);
981  	sph_fugue384_init(sc);
982  }
983  static void
984  fugue4_close(sph_fugue_context *sc, unsigned ub, unsigned n, void *dst)
985  {
986  	int i;
987  	CLOSE_ENTRY(36, 12, fugue4_core)
988  	for (i = 0; i < 32; i ++) {
989  		ROR(3, 36);
990  		CMIX36(S[0], S[1], S[2], S[4], S[5], S[6], S[18], S[19], S[20]);
991  		SMIX(S[0], S[1], S[2], S[3]);
992  	}
993  	for (i = 0; i < 13; i ++) {
994  		S[4] ^= S[0];
995  		S[9] ^= S[0];
996  		S[18] ^= S[0];
997  		S[27] ^= S[0];
998  		ROR(9, 36);
999  		SMIX(S[0], S[1], S[2], S[3]);
1000  		S[4] ^= S[0];
1001  		S[10] ^= S[0];
1002  		S[18] ^= S[0];
1003  		S[27] ^= S[0];
1004  		ROR(9, 36);
1005  		SMIX(S[0], S[1], S[2], S[3]);
1006  		S[4] ^= S[0];
1007  		S[10] ^= S[0];
1008  		S[19] ^= S[0];
1009  		S[27] ^= S[0];
1010  		ROR(9, 36);
1011  		SMIX(S[0], S[1], S[2], S[3]);
1012  		S[4] ^= S[0];
1013  		S[10] ^= S[0];
1014  		S[19] ^= S[0];
1015  		S[28] ^= S[0];
1016  		ROR(8, 36);
1017  		SMIX(S[0], S[1], S[2], S[3]);
1018  	}
1019  	S[4] ^= S[0];
1020  	S[9] ^= S[0];
1021  	S[18] ^= S[0];
1022  	S[27] ^= S[0];
1023  	out = dst;
1024  	sph_enc32be(out +  0, S[ 1]);
1025  	sph_enc32be(out +  4, S[ 2]);
1026  	sph_enc32be(out +  8, S[ 3]);
1027  	sph_enc32be(out + 12, S[ 4]);
1028  	sph_enc32be(out + 16, S[ 9]);
1029  	sph_enc32be(out + 20, S[10]);
1030  	sph_enc32be(out + 24, S[11]);
1031  	sph_enc32be(out + 28, S[12]);
1032  	sph_enc32be(out + 32, S[18]);
1033  	sph_enc32be(out + 36, S[19]);
1034  	sph_enc32be(out + 40, S[20]);
1035  	sph_enc32be(out + 44, S[21]);
1036  	sph_enc32be(out + 48, S[27]);
1037  	sph_enc32be(out + 52, S[28]);
1038  	sph_enc32be(out + 56, S[29]);
1039  	sph_enc32be(out + 60, S[30]);
1040  }
1041  void
1042  sph_fugue224_init(void *cc)
1043  {
1044  	fugue_init(cc, 23, IV224, 7);
1045  }
1046  void
1047  sph_fugue224(void *cc, const void *data, size_t len)
1048  {
1049  	fugue2_core(cc, data, len);
1050  }
1051  void
1052  sph_fugue224_close(void *cc, void *dst)
1053  {
1054  	fugue2_close(cc, 0, 0, dst, 7);
1055  }
1056  void
1057  sph_fugue224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1058  {
1059  	fugue2_close(cc, ub, n, dst, 7);
1060  }
1061  void
1062  sph_fugue256_init(void *cc)
1063  {
1064  	fugue_init(cc, 22, IV256, 8);
1065  }
1066  void
1067  sph_fugue256(void *cc, const void *data, size_t len)
1068  {
1069  	fugue2_core(cc, data, len);
1070  }
1071  void
1072  sph_fugue256_close(void *cc, void *dst)
1073  {
1074  	fugue2_close(cc, 0, 0, dst, 8);
1075  }
1076  void
1077  sph_fugue256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1078  {
1079  	fugue2_close(cc, ub, n, dst, 8);
1080  }
1081  void
1082  sph_fugue384_init(void *cc)
1083  {
1084  	fugue_init(cc, 24, IV384, 12);
1085  }
1086  void
1087  sph_fugue384(void *cc, const void *data, size_t len)
1088  {
1089  	fugue3_core(cc, data, len);
1090  }
1091  void
1092  sph_fugue384_close(void *cc, void *dst)
1093  {
1094  	fugue3_close(cc, 0, 0, dst);
1095  }
1096  void
1097  sph_fugue384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1098  {
1099  	fugue3_close(cc, ub, n, dst);
1100  }
1101  void
1102  sph_fugue512_init(void *cc)
1103  {
1104  	fugue_init(cc, 20, IV512, 16);
1105  }
1106  void
1107  sph_fugue512(void *cc, const void *data, size_t len)
1108  {
1109  	fugue4_core(cc, data, len);
1110  }
1111  void
1112  sph_fugue512_close(void *cc, void *dst)
1113  {
1114  	fugue4_close(cc, 0, 0, dst);
1115  }
1116  void
1117  sph_fugue512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1118  {
1119  	fugue4_close(cc, ub, n, dst);
1120  }
1121  #ifdef __cplusplus
1122  }
1123  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-microbench.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_fugue.c</div>
                </div>
                <div class="column column_space"><pre><code>6  	for (i = 0; i < nwarmup; i++) {
7  		func();
8  	}
9  	timer_start(timer);
10  	for (i = 0; i < niter; i++) {
</pre></code></div>
                <div class="column column_space"><pre><code>906  	for (i = 0; i < 10; i ++) {
907  		ROR(3, 30);
908  		CMIX30(S[0], S[1], S[2], S[4], S[5], S[6], S[15], S[16], S[17]);
909  		SMIX(S[0], S[1], S[2], S[3]);
910  	}
911  	for (i = 0; i < 13; i ++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    