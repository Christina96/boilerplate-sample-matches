
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.827586206896552%, Tokens: 8</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_neon.c</h3>
            <pre><code>1  #include "src/dsp/yuv.h"
2  #if defined(WEBP_USE_NEON)
3  #include <assert.h>
4  #include <stdlib.h>
5  #include "src/dsp/neon.h"
6  static uint8x8_t ConvertRGBToY_NEON(const uint8x8_t R,
7                                      const uint8x8_t G,
8                                      const uint8x8_t B) {
9    const uint16x8_t r = vmovl_u8(R);
10    const uint16x8_t g = vmovl_u8(G);
11    const uint16x8_t b = vmovl_u8(B);
12    const uint16x4_t r_lo = vget_low_u16(r);
13    const uint16x4_t r_hi = vget_high_u16(r);
14    const uint16x4_t g_lo = vget_low_u16(g);
15    const uint16x4_t g_hi = vget_high_u16(g);
16    const uint16x4_t b_lo = vget_low_u16(b);
17    const uint16x4_t b_hi = vget_high_u16(b);
18    const uint32x4_t tmp0_lo = vmull_n_u16(         r_lo, 16839u);
19    const uint32x4_t tmp0_hi = vmull_n_u16(         r_hi, 16839u);
20    const uint32x4_t tmp1_lo = vmlal_n_u16(tmp0_lo, g_lo, 33059u);
21    const uint32x4_t tmp1_hi = vmlal_n_u16(tmp0_hi, g_hi, 33059u);
22    const uint32x4_t tmp2_lo = vmlal_n_u16(tmp1_lo, b_lo, 6420u);
23    const uint32x4_t tmp2_hi = vmlal_n_u16(tmp1_hi, b_hi, 6420u);
24    const uint16x8_t Y1 = vcombine_u16(vrshrn_n_u32(tmp2_lo, 16),
25                                       vrshrn_n_u32(tmp2_hi, 16));
26    const uint16x8_t Y2 = vaddq_u16(Y1, vdupq_n_u16(16));
27    return vqmovn_u16(Y2);
28  }
29  static void ConvertRGB24ToY_NEON(const uint8_t* rgb, uint8_t* y, int width) {
30    int i;
31    for (i = 0; i + 8 <= width; i += 8, rgb += 3 * 8) {
32      const uint8x8x3_t RGB = vld3_u8(rgb);
33      const uint8x8_t Y = ConvertRGBToY_NEON(RGB.val[0], RGB.val[1], RGB.val[2]);
34      vst1_u8(y + i, Y);
35    }
<span onclick='openModal()' class='match'>36    for (; i < width; ++i, rgb += 3) {   
37      y[i] = VP8RGBToY(rgb[0], rgb[1], rgb[2], YUV_HALF);
38    }
39  }
40  static void ConvertBGR24ToY_NEON(const uint8_t* bgr, uint8_t* y, int width) {
</span>41    int i;
42    for (i = 0; i + 8 <= width; i += 8, bgr += 3 * 8) {
43      const uint8x8x3_t BGR = vld3_u8(bgr);
44      const uint8x8_t Y = ConvertRGBToY_NEON(BGR.val[2], BGR.val[1], BGR.val[0]);
45      vst1_u8(y + i, Y);
46    }
47    for (; i < width; ++i, bgr += 3) {  
48      y[i] = VP8RGBToY(bgr[2], bgr[1], bgr[0], YUV_HALF);
49    }
50  }
51  static void ConvertARGBToY_NEON(const uint32_t* argb, uint8_t* y, int width) {
52    int i;
53    for (i = 0; i + 8 <= width; i += 8) {
54      const uint8x8x4_t RGB = vld4_u8((const uint8_t*)&argb[i]);
55      const uint8x8_t Y = ConvertRGBToY_NEON(RGB.val[2], RGB.val[1], RGB.val[0]);
56      vst1_u8(y + i, Y);
57    }
58    for (; i < width; ++i) {   
59      const uint32_t p = argb[i];
60      y[i] = VP8RGBToY((p >> 16) & 0xff, (p >> 8) & 0xff, (p >>  0) & 0xff,
61                       YUV_HALF);
62    }
63  }
64  #define MULTIPLY_16b_PREAMBLE(r, g, b)                           \
65    const int16x4_t r_lo = vreinterpret_s16_u16(vget_low_u16(r));  \
66    const int16x4_t r_hi = vreinterpret_s16_u16(vget_high_u16(r)); \
67    const int16x4_t g_lo = vreinterpret_s16_u16(vget_low_u16(g));  \
68    const int16x4_t g_hi = vreinterpret_s16_u16(vget_high_u16(g)); \
69    const int16x4_t b_lo = vreinterpret_s16_u16(vget_low_u16(b));  \
70    const int16x4_t b_hi = vreinterpret_s16_u16(vget_high_u16(b))
71  #define MULTIPLY_16b(C0, C1, C2, CST, DST_s16) do {              \
72    const int32x4_t tmp0_lo = vmull_n_s16(         r_lo, C0);      \
73    const int32x4_t tmp0_hi = vmull_n_s16(         r_hi, C0);      \
74    const int32x4_t tmp1_lo = vmlal_n_s16(tmp0_lo, g_lo, C1);      \
75    const int32x4_t tmp1_hi = vmlal_n_s16(tmp0_hi, g_hi, C1);      \
76    const int32x4_t tmp2_lo = vmlal_n_s16(tmp1_lo, b_lo, C2);      \
77    const int32x4_t tmp2_hi = vmlal_n_s16(tmp1_hi, b_hi, C2);      \
78    const int16x8_t tmp3 = vcombine_s16(vshrn_n_s32(tmp2_lo, 16),  \
79                                        vshrn_n_s32(tmp2_hi, 16)); \
80    DST_s16 = vaddq_s16(tmp3, vdupq_n_s16(CST));                   \
81  } while (0)
82  #define CONVERT_RGB_TO_UV(r, g, b, SHIFT, U_DST, V_DST) do {     \
83    MULTIPLY_16b_PREAMBLE(r, g, b);                                \
84    MULTIPLY_16b(-9719, -19081, 28800, 128 << SHIFT, U_DST);       \
85    MULTIPLY_16b(28800, -24116, -4684, 128 << SHIFT, V_DST);       \
86  } while (0)
87  static void ConvertRGBA32ToUV_NEON(const uint16_t* rgb,
88                                     uint8_t* u, uint8_t* v, int width) {
89    int i;
90    for (i = 0; i + 8 <= width; i += 8, rgb += 4 * 8) {
91      const uint16x8x4_t RGB = vld4q_u16((const uint16_t*)rgb);
92      int16x8_t U, V;
93      CONVERT_RGB_TO_UV(RGB.val[0], RGB.val[1], RGB.val[2], 2, U, V);
94      vst1_u8(u + i, vqrshrun_n_s16(U, 2));
95      vst1_u8(v + i, vqrshrun_n_s16(V, 2));
96    }
97    for (; i < width; i += 1, rgb += 4) {
98      const int r = rgb[0], g = rgb[1], b = rgb[2];
99      u[i] = VP8RGBToU(r, g, b, YUV_HALF << 2);
100      v[i] = VP8RGBToV(r, g, b, YUV_HALF << 2);
101    }
102  }
103  static void ConvertARGBToUV_NEON(const uint32_t* argb, uint8_t* u, uint8_t* v,
104                                   int src_width, int do_store) {
105    int i;
106    for (i = 0; i + 16 <= src_width; i += 16, u += 8, v += 8) {
107      const uint8x16x4_t RGB = vld4q_u8((const uint8_t*)&argb[i]);
108      const uint16x8_t R = vpaddlq_u8(RGB.val[2]);  
109      const uint16x8_t G = vpaddlq_u8(RGB.val[1]);
110      const uint16x8_t B = vpaddlq_u8(RGB.val[0]);
111      int16x8_t U_tmp, V_tmp;
112      CONVERT_RGB_TO_UV(R, G, B, 1, U_tmp, V_tmp);
113      {
114        const uint8x8_t U = vqrshrun_n_s16(U_tmp, 1);
115        const uint8x8_t V = vqrshrun_n_s16(V_tmp, 1);
116        if (do_store) {
117          vst1_u8(u, U);
118          vst1_u8(v, V);
119        } else {
120          const uint8x8_t prev_u = vld1_u8(u);
121          const uint8x8_t prev_v = vld1_u8(v);
122          vst1_u8(u, vrhadd_u8(U, prev_u));
123          vst1_u8(v, vrhadd_u8(V, prev_v));
124        }
125      }
126    }
127    if (i < src_width) {  
128      WebPConvertARGBToUV_C(argb + i, u, v, src_width - i, do_store);
129    }
130  }
131  extern void WebPInitConvertARGBToYUVNEON(void);
132  WEBP_TSAN_IGNORE_FUNCTION void WebPInitConvertARGBToYUVNEON(void) {
133    WebPConvertRGB24ToY = ConvertRGB24ToY_NEON;
134    WebPConvertBGR24ToY = ConvertBGR24ToY_NEON;
135    WebPConvertARGBToY = ConvertARGBToY_NEON;
136    WebPConvertARGBToUV = ConvertARGBToUV_NEON;
137    WebPConvertRGBA32ToUV = ConvertRGBA32ToUV_NEON;
138  }
139  #define MAX_Y ((1 << 10) - 1)    
140  static uint16_t clip_y_NEON(int v) {
141    return (v < 0) ? 0 : (v > MAX_Y) ? MAX_Y : (uint16_t)v;
142  }
143  static uint64_t SharpYUVUpdateY_NEON(const uint16_t* ref, const uint16_t* src,
144                                       uint16_t* dst, int len) {
145    int i;
146    const int16x8_t zero = vdupq_n_s16(0);
147    const int16x8_t max = vdupq_n_s16(MAX_Y);
148    uint64x2_t sum = vdupq_n_u64(0);
149    uint64_t diff;
150    for (i = 0; i + 8 <= len; i += 8) {
151      const int16x8_t A = vreinterpretq_s16_u16(vld1q_u16(ref + i));
152      const int16x8_t B = vreinterpretq_s16_u16(vld1q_u16(src + i));
153      const int16x8_t C = vreinterpretq_s16_u16(vld1q_u16(dst + i));
154      const int16x8_t D = vsubq_s16(A, B);       
155      const int16x8_t F = vaddq_s16(C, D);       
156      const uint16x8_t H =
157          vreinterpretq_u16_s16(vmaxq_s16(vminq_s16(F, max), zero));
158      const int16x8_t I = vabsq_s16(D);          
159      vst1q_u16(dst + i, H);
160      sum = vpadalq_u32(sum, vpaddlq_u16(vreinterpretq_u16_s16(I)));
161    }
162    diff = vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);
163    for (; i < len; ++i) {
164      const int diff_y = ref[i] - src[i];
165      const int new_y = (int)(dst[i]) + diff_y;
166      dst[i] = clip_y_NEON(new_y);
167      diff += (uint64_t)(abs(diff_y));
168    }
169    return diff;
170  }
171  static void SharpYUVUpdateRGB_NEON(const int16_t* ref, const int16_t* src,
172                                     int16_t* dst, int len) {
173    int i;
174    for (i = 0; i + 8 <= len; i += 8) {
175      const int16x8_t A = vld1q_s16(ref + i);
176      const int16x8_t B = vld1q_s16(src + i);
177      const int16x8_t C = vld1q_s16(dst + i);
178      const int16x8_t D = vsubq_s16(A, B);   
179      const int16x8_t E = vaddq_s16(C, D);   
180      vst1q_s16(dst + i, E);
181    }
182    for (; i < len; ++i) {
183      const int diff_uv = ref[i] - src[i];
184      dst[i] += diff_uv;
185    }
186  }
187  static void SharpYUVFilterRow_NEON(const int16_t* A, const int16_t* B, int len,
188                                     const uint16_t* best_y, uint16_t* out) {
189    int i;
190    const int16x8_t max = vdupq_n_s16(MAX_Y);
191    const int16x8_t zero = vdupq_n_s16(0);
192    for (i = 0; i + 8 <= len; i += 8) {
193      const int16x8_t a0 = vld1q_s16(A + i + 0);
194      const int16x8_t a1 = vld1q_s16(A + i + 1);
195      const int16x8_t b0 = vld1q_s16(B + i + 0);
196      const int16x8_t b1 = vld1q_s16(B + i + 1);
197      const int16x8_t a0b1 = vaddq_s16(a0, b1);
198      const int16x8_t a1b0 = vaddq_s16(a1, b0);
199      const int16x8_t a0a1b0b1 = vaddq_s16(a0b1, a1b0);  
200      const int16x8_t a0b1_2 = vaddq_s16(a0b1, a0b1);    
201      const int16x8_t a1b0_2 = vaddq_s16(a1b0, a1b0);    
202      const int16x8_t c0 = vshrq_n_s16(vaddq_s16(a0b1_2, a0a1b0b1), 3);
203      const int16x8_t c1 = vshrq_n_s16(vaddq_s16(a1b0_2, a0a1b0b1), 3);
204      const int16x8_t d0 = vaddq_s16(c1, a0);
205      const int16x8_t d1 = vaddq_s16(c0, a1);
206      const int16x8_t e0 = vrshrq_n_s16(d0, 1);
207      const int16x8_t e1 = vrshrq_n_s16(d1, 1);
208      const int16x8x2_t f = vzipq_s16(e0, e1);
209      const int16x8_t g0 = vreinterpretq_s16_u16(vld1q_u16(best_y + 2 * i + 0));
210      const int16x8_t g1 = vreinterpretq_s16_u16(vld1q_u16(best_y + 2 * i + 8));
211      const int16x8_t h0 = vaddq_s16(g0, f.val[0]);
212      const int16x8_t h1 = vaddq_s16(g1, f.val[1]);
213      const int16x8_t i0 = vmaxq_s16(vminq_s16(h0, max), zero);
214      const int16x8_t i1 = vmaxq_s16(vminq_s16(h1, max), zero);
215      vst1q_u16(out + 2 * i + 0, vreinterpretq_u16_s16(i0));
216      vst1q_u16(out + 2 * i + 8, vreinterpretq_u16_s16(i1));
217    }
218    for (; i < len; ++i) {
219      const int a0b1 = A[i + 0] + B[i + 1];
220      const int a1b0 = A[i + 1] + B[i + 0];
221      const int a0a1b0b1 = a0b1 + a1b0 + 8;
222      const int v0 = (8 * A[i + 0] + 2 * a1b0 + a0a1b0b1) >> 4;
223      const int v1 = (8 * A[i + 1] + 2 * a0b1 + a0a1b0b1) >> 4;
224      out[2 * i + 0] = clip_y_NEON(best_y[2 * i + 0] + v0);
225      out[2 * i + 1] = clip_y_NEON(best_y[2 * i + 1] + v1);
226    }
227  }
228  #undef MAX_Y
229  extern void WebPInitSharpYUVNEON(void);
230  WEBP_TSAN_IGNORE_FUNCTION void WebPInitSharpYUVNEON(void) {
231    WebPSharpYUVUpdateY = SharpYUVUpdateY_NEON;
232    WebPSharpYUVUpdateRGB = SharpYUVUpdateRGB_NEON;
233    WebPSharpYUVFilterRow = SharpYUVFilterRow_NEON;
234  }
235  #else  
236  WEBP_DSP_INIT_STUB(WebPInitConvertARGBToYUVNEON)
237  WEBP_DSP_INIT_STUB(WebPInitSharpYUVNEON)
238  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/dsp/dsp.h"
3  #include "src/dec/vp8i_dec.h"
4  #include "src/utils/utils.h"
5  static WEBP_INLINE uint8_t clip_8b(int v) {
6    return (!(v & ~0xff)) ? v : (v < 0) ? 0 : 255;
7  }
8  #define STORE(x, y, v) \
9    dst[(x) + (y) * BPS] = clip_8b(dst[(x) + (y) * BPS] + ((v) >> 3))
10  #define STORE2(y, dc, d, c) do {    \
11    const int DC = (dc);              \
12    STORE(0, y, DC + (d));            \
13    STORE(1, y, DC + (c));            \
14    STORE(2, y, DC - (c));            \
15    STORE(3, y, DC - (d));            \
16  } while (0)
17  #define MUL1(a) ((((a) * 20091) >> 16) + (a))
18  #define MUL2(a) (((a) * 35468) >> 16)
19  #if !WEBP_NEON_OMIT_C_CODE
20  static void TransformOne_C(const int16_t* in, uint8_t* dst) {
21    int C[4 * 4], *tmp;
22    int i;
23    tmp = C;
24    for (i = 0; i < 4; ++i) {    
25      const int a = in[0] + in[8];    
26      const int b = in[0] - in[8];    
27      const int c = MUL2(in[4]) - MUL1(in[12]);   
28      const int d = MUL1(in[4]) + MUL2(in[12]);   
29      tmp[0] = a + d;   
30      tmp[1] = b + c;   
31      tmp[2] = b - c;   
32      tmp[3] = a - d;   
33      tmp += 4;
34      in++;
35    }
36    tmp = C;
37    for (i = 0; i < 4; ++i) {    
38      const int dc = tmp[0] + 4;
39      const int a =  dc +  tmp[8];
40      const int b =  dc -  tmp[8];
41      const int c = MUL2(tmp[4]) - MUL1(tmp[12]);
42      const int d = MUL1(tmp[4]) + MUL2(tmp[12]);
43      STORE(0, 0, a + d);
44      STORE(1, 0, b + c);
45      STORE(2, 0, b - c);
46      STORE(3, 0, a - d);
47      tmp++;
48      dst += BPS;
49    }
50  }
51  static void TransformAC3_C(const int16_t* in, uint8_t* dst) {
52    const int a = in[0] + 4;
53    const int c4 = MUL2(in[4]);
54    const int d4 = MUL1(in[4]);
55    const int c1 = MUL2(in[1]);
56    const int d1 = MUL1(in[1]);
57    STORE2(0, a + d4, d1, c1);
58    STORE2(1, a + c4, d1, c1);
59    STORE2(2, a - c4, d1, c1);
60    STORE2(3, a - d4, d1, c1);
61  }
62  #undef MUL1
63  #undef MUL2
64  #undef STORE2
65  static void TransformTwo_C(const int16_t* in, uint8_t* dst, int do_two) {
66    TransformOne_C(in, dst);
67    if (do_two) {
68      TransformOne_C(in + 16, dst + 4);
69    }
70  }
71  #endif  
72  static void TransformUV_C(const int16_t* in, uint8_t* dst) {
73    VP8Transform(in + 0 * 16, dst, 1);
74    VP8Transform(in + 2 * 16, dst + 4 * BPS, 1);
75  }
76  #if !WEBP_NEON_OMIT_C_CODE
77  static void TransformDC_C(const int16_t* in, uint8_t* dst) {
78    const int DC = in[0] + 4;
79    int i, j;
80    for (j = 0; j < 4; ++j) {
81      for (i = 0; i < 4; ++i) {
82        STORE(i, j, DC);
83      }
84    }
85  }
86  #endif  
87  static void TransformDCUV_C(const int16_t* in, uint8_t* dst) {
88    if (in[0 * 16]) VP8TransformDC(in + 0 * 16, dst);
89    if (in[1 * 16]) VP8TransformDC(in + 1 * 16, dst + 4);
90    if (in[2 * 16]) VP8TransformDC(in + 2 * 16, dst + 4 * BPS);
91    if (in[3 * 16]) VP8TransformDC(in + 3 * 16, dst + 4 * BPS + 4);
92  }
93  #undef STORE
94  #if !WEBP_NEON_OMIT_C_CODE
95  static void TransformWHT_C(const int16_t* in, int16_t* out) {
96    int tmp[16];
97    int i;
98    for (i = 0; i < 4; ++i) {
99      const int a0 = in[0 + i] + in[12 + i];
100      const int a1 = in[4 + i] + in[ 8 + i];
101      const int a2 = in[4 + i] - in[ 8 + i];
102      const int a3 = in[0 + i] - in[12 + i];
103      tmp[0  + i] = a0 + a1;
104      tmp[8  + i] = a0 - a1;
105      tmp[4  + i] = a3 + a2;
106      tmp[12 + i] = a3 - a2;
107    }
108    for (i = 0; i < 4; ++i) {
109      const int dc = tmp[0 + i * 4] + 3;    
110      const int a0 = dc             + tmp[3 + i * 4];
111      const int a1 = tmp[1 + i * 4] + tmp[2 + i * 4];
112      const int a2 = tmp[1 + i * 4] - tmp[2 + i * 4];
113      const int a3 = dc             - tmp[3 + i * 4];
114      out[ 0] = (a0 + a1) >> 3;
115      out[16] = (a3 + a2) >> 3;
116      out[32] = (a0 - a1) >> 3;
117      out[48] = (a3 - a2) >> 3;
118      out += 64;
119    }
120  }
121  #endif  
122  void (*VP8TransformWHT)(const int16_t* in, int16_t* out);
123  #define DST(x, y) dst[(x) + (y) * BPS]
124  #if !WEBP_NEON_OMIT_C_CODE
125  static WEBP_INLINE void TrueMotion(uint8_t* dst, int size) {
126    const uint8_t* top = dst - BPS;
127    const uint8_t* const clip0 = VP8kclip1 - top[-1];
128    int y;
129    for (y = 0; y < size; ++y) {
130      const uint8_t* const clip = clip0 + dst[-1];
131      int x;
132      for (x = 0; x < size; ++x) {
133        dst[x] = clip[top[x]];
134      }
135      dst += BPS;
136    }
137  }
138  static void TM4_C(uint8_t* dst)   { TrueMotion(dst, 4); }
139  static void TM8uv_C(uint8_t* dst) { TrueMotion(dst, 8); }
140  static void TM16_C(uint8_t* dst)  { TrueMotion(dst, 16); }
141  static void VE16_C(uint8_t* dst) {     
142    int j;
143    for (j = 0; j < 16; ++j) {
144      memcpy(dst + j * BPS, dst - BPS, 16);
145    }
146  }
147  static void HE16_C(uint8_t* dst) {     
148    int j;
<span onclick='openModal()' class='match'>149    for (j = 16; j > 0; --j) {
150      memset(dst, dst[-1], 16);
151      dst += BPS;
152    }
153  }
154  static WEBP_INLINE void Put16(int v, uint8_t* dst) {
</span>155    int j;
156    for (j = 0; j < 16; ++j) {
157      memset(dst + j * BPS, v, 16);
158    }
159  }
160  static void DC16_C(uint8_t* dst) {    
161    int DC = 16;
162    int j;
163    for (j = 0; j < 16; ++j) {
164      DC += dst[-1 + j * BPS] + dst[j - BPS];
165    }
166    Put16(DC >> 5, dst);
167  }
168  static void DC16NoTop_C(uint8_t* dst) {   
169    int DC = 8;
170    int j;
171    for (j = 0; j < 16; ++j) {
172      DC += dst[-1 + j * BPS];
173    }
174    Put16(DC >> 4, dst);
175  }
176  static void DC16NoLeft_C(uint8_t* dst) {  
177    int DC = 8;
178    int i;
179    for (i = 0; i < 16; ++i) {
180      DC += dst[i - BPS];
181    }
182    Put16(DC >> 4, dst);
183  }
184  static void DC16NoTopLeft_C(uint8_t* dst) {  
185    Put16(0x80, dst);
186  }
187  #endif  
188  VP8PredFunc VP8PredLuma16[NUM_B_DC_MODES];
189  #define AVG3(a, b, c) ((uint8_t)(((a) + 2 * (b) + (c) + 2) >> 2))
190  #define AVG2(a, b) (((a) + (b) + 1) >> 1)
191  #if !WEBP_NEON_OMIT_C_CODE
192  static void VE4_C(uint8_t* dst) {    
193    const uint8_t* top = dst - BPS;
194    const uint8_t vals[4] = {
195      AVG3(top[-1], top[0], top[1]),
196      AVG3(top[ 0], top[1], top[2]),
197      AVG3(top[ 1], top[2], top[3]),
198      AVG3(top[ 2], top[3], top[4])
199    };
200    int i;
201    for (i = 0; i < 4; ++i) {
202      memcpy(dst + i * BPS, vals, sizeof(vals));
203    }
204  }
205  #endif  
206  static void HE4_C(uint8_t* dst) {    
207    const int A = dst[-1 - BPS];
208    const int B = dst[-1];
209    const int C = dst[-1 + BPS];
210    const int D = dst[-1 + 2 * BPS];
211    const int E = dst[-1 + 3 * BPS];
212    WebPUint32ToMem(dst + 0 * BPS, 0x01010101U * AVG3(A, B, C));
213    WebPUint32ToMem(dst + 1 * BPS, 0x01010101U * AVG3(B, C, D));
214    WebPUint32ToMem(dst + 2 * BPS, 0x01010101U * AVG3(C, D, E));
215    WebPUint32ToMem(dst + 3 * BPS, 0x01010101U * AVG3(D, E, E));
216  }
217  #if !WEBP_NEON_OMIT_C_CODE
218  static void DC4_C(uint8_t* dst) {   
219    uint32_t dc = 4;
220    int i;
221    for (i = 0; i < 4; ++i) dc += dst[i - BPS] + dst[-1 + i * BPS];
222    dc >>= 3;
223    for (i = 0; i < 4; ++i) memset(dst + i * BPS, dc, 4);
224  }
225  static void RD4_C(uint8_t* dst) {   
226    const int I = dst[-1 + 0 * BPS];
227    const int J = dst[-1 + 1 * BPS];
228    const int K = dst[-1 + 2 * BPS];
229    const int L = dst[-1 + 3 * BPS];
230    const int X = dst[-1 - BPS];
231    const int A = dst[0 - BPS];
232    const int B = dst[1 - BPS];
233    const int C = dst[2 - BPS];
234    const int D = dst[3 - BPS];
235    DST(0, 3)                                     = AVG3(J, K, L);
236    DST(1, 3) = DST(0, 2)                         = AVG3(I, J, K);
237    DST(2, 3) = DST(1, 2) = DST(0, 1)             = AVG3(X, I, J);
238    DST(3, 3) = DST(2, 2) = DST(1, 1) = DST(0, 0) = AVG3(A, X, I);
239                DST(3, 2) = DST(2, 1) = DST(1, 0) = AVG3(B, A, X);
240                            DST(3, 1) = DST(2, 0) = AVG3(C, B, A);
241                                        DST(3, 0) = AVG3(D, C, B);
242  }
243  static void LD4_C(uint8_t* dst) {   
244    const int A = dst[0 - BPS];
245    const int B = dst[1 - BPS];
246    const int C = dst[2 - BPS];
247    const int D = dst[3 - BPS];
248    const int E = dst[4 - BPS];
249    const int F = dst[5 - BPS];
250    const int G = dst[6 - BPS];
251    const int H = dst[7 - BPS];
252    DST(0, 0)                                     = AVG3(A, B, C);
253    DST(1, 0) = DST(0, 1)                         = AVG3(B, C, D);
254    DST(2, 0) = DST(1, 1) = DST(0, 2)             = AVG3(C, D, E);
255    DST(3, 0) = DST(2, 1) = DST(1, 2) = DST(0, 3) = AVG3(D, E, F);
256                DST(3, 1) = DST(2, 2) = DST(1, 3) = AVG3(E, F, G);
257                            DST(3, 2) = DST(2, 3) = AVG3(F, G, H);
258                                        DST(3, 3) = AVG3(G, H, H);
259  }
260  #endif  
261  static void VR4_C(uint8_t* dst) {   
262    const int I = dst[-1 + 0 * BPS];
263    const int J = dst[-1 + 1 * BPS];
264    const int K = dst[-1 + 2 * BPS];
265    const int X = dst[-1 - BPS];
266    const int A = dst[0 - BPS];
267    const int B = dst[1 - BPS];
268    const int C = dst[2 - BPS];
269    const int D = dst[3 - BPS];
270    DST(0, 0) = DST(1, 2) = AVG2(X, A);
271    DST(1, 0) = DST(2, 2) = AVG2(A, B);
272    DST(2, 0) = DST(3, 2) = AVG2(B, C);
273    DST(3, 0)             = AVG2(C, D);
274    DST(0, 3) =             AVG3(K, J, I);
275    DST(0, 2) =             AVG3(J, I, X);
276    DST(0, 1) = DST(1, 3) = AVG3(I, X, A);
277    DST(1, 1) = DST(2, 3) = AVG3(X, A, B);
278    DST(2, 1) = DST(3, 3) = AVG3(A, B, C);
279    DST(3, 1) =             AVG3(B, C, D);
280  }
281  static void VL4_C(uint8_t* dst) {   
282    const int A = dst[0 - BPS];
283    const int B = dst[1 - BPS];
284    const int C = dst[2 - BPS];
285    const int D = dst[3 - BPS];
286    const int E = dst[4 - BPS];
287    const int F = dst[5 - BPS];
288    const int G = dst[6 - BPS];
289    const int H = dst[7 - BPS];
290    DST(0, 0) =             AVG2(A, B);
291    DST(1, 0) = DST(0, 2) = AVG2(B, C);
292    DST(2, 0) = DST(1, 2) = AVG2(C, D);
293    DST(3, 0) = DST(2, 2) = AVG2(D, E);
294    DST(0, 1) =             AVG3(A, B, C);
295    DST(1, 1) = DST(0, 3) = AVG3(B, C, D);
296    DST(2, 1) = DST(1, 3) = AVG3(C, D, E);
297    DST(3, 1) = DST(2, 3) = AVG3(D, E, F);
298                DST(3, 2) = AVG3(E, F, G);
299                DST(3, 3) = AVG3(F, G, H);
300  }
301  static void HU4_C(uint8_t* dst) {   
302    const int I = dst[-1 + 0 * BPS];
303    const int J = dst[-1 + 1 * BPS];
304    const int K = dst[-1 + 2 * BPS];
305    const int L = dst[-1 + 3 * BPS];
306    DST(0, 0) =             AVG2(I, J);
307    DST(2, 0) = DST(0, 1) = AVG2(J, K);
308    DST(2, 1) = DST(0, 2) = AVG2(K, L);
309    DST(1, 0) =             AVG3(I, J, K);
310    DST(3, 0) = DST(1, 1) = AVG3(J, K, L);
311    DST(3, 1) = DST(1, 2) = AVG3(K, L, L);
312    DST(3, 2) = DST(2, 2) =
313      DST(0, 3) = DST(1, 3) = DST(2, 3) = DST(3, 3) = L;
314  }
315  static void HD4_C(uint8_t* dst) {  
316    const int I = dst[-1 + 0 * BPS];
317    const int J = dst[-1 + 1 * BPS];
318    const int K = dst[-1 + 2 * BPS];
319    const int L = dst[-1 + 3 * BPS];
320    const int X = dst[-1 - BPS];
321    const int A = dst[0 - BPS];
322    const int B = dst[1 - BPS];
323    const int C = dst[2 - BPS];
324    DST(0, 0) = DST(2, 1) = AVG2(I, X);
325    DST(0, 1) = DST(2, 2) = AVG2(J, I);
326    DST(0, 2) = DST(2, 3) = AVG2(K, J);
327    DST(0, 3)             = AVG2(L, K);
328    DST(3, 0)             = AVG3(A, B, C);
329    DST(2, 0)             = AVG3(X, A, B);
330    DST(1, 0) = DST(3, 1) = AVG3(I, X, A);
331    DST(1, 1) = DST(3, 2) = AVG3(J, I, X);
332    DST(1, 2) = DST(3, 3) = AVG3(K, J, I);
333    DST(1, 3)             = AVG3(L, K, J);
334  }
335  #undef DST
336  #undef AVG3
337  #undef AVG2
338  VP8PredFunc VP8PredLuma4[NUM_BMODES];
339  #if !WEBP_NEON_OMIT_C_CODE
340  static void VE8uv_C(uint8_t* dst) {    
341    int j;
342    for (j = 0; j < 8; ++j) {
343      memcpy(dst + j * BPS, dst - BPS, 8);
344    }
345  }
346  static void HE8uv_C(uint8_t* dst) {    
347    int j;
348    for (j = 0; j < 8; ++j) {
349      memset(dst, dst[-1], 8);
350      dst += BPS;
351    }
352  }
353  static WEBP_INLINE void Put8x8uv(uint8_t value, uint8_t* dst) {
354    int j;
355    for (j = 0; j < 8; ++j) {
356      memset(dst + j * BPS, value, 8);
357    }
358  }
359  static void DC8uv_C(uint8_t* dst) {     
360    int dc0 = 8;
361    int i;
362    for (i = 0; i < 8; ++i) {
363      dc0 += dst[i - BPS] + dst[-1 + i * BPS];
364    }
365    Put8x8uv(dc0 >> 4, dst);
366  }
367  static void DC8uvNoLeft_C(uint8_t* dst) {   
368    int dc0 = 4;
369    int i;
370    for (i = 0; i < 8; ++i) {
371      dc0 += dst[i - BPS];
372    }
373    Put8x8uv(dc0 >> 3, dst);
374  }
375  static void DC8uvNoTop_C(uint8_t* dst) {  
376    int dc0 = 4;
377    int i;
378    for (i = 0; i < 8; ++i) {
379      dc0 += dst[-1 + i * BPS];
380    }
381    Put8x8uv(dc0 >> 3, dst);
382  }
383  static void DC8uvNoTopLeft_C(uint8_t* dst) {    
384    Put8x8uv(0x80, dst);
385  }
386  #endif  
387  VP8PredFunc VP8PredChroma8[NUM_B_DC_MODES];
388  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
389  static WEBP_INLINE void DoFilter2_C(uint8_t* p, int step) {
390    const int p1 = p[-2*step], p0 = p[-step], q0 = p[0], q1 = p[step];
391    const int a = 3 * (q0 - p0) + VP8ksclip1[p1 - q1];  
392    const int a1 = VP8ksclip2[(a + 4) >> 3];            
393    const int a2 = VP8ksclip2[(a + 3) >> 3];
394    p[-step] = VP8kclip1[p0 + a2];
395    p[    0] = VP8kclip1[q0 - a1];
396  }
397  static WEBP_INLINE void DoFilter4_C(uint8_t* p, int step) {
398    const int p1 = p[-2*step], p0 = p[-step], q0 = p[0], q1 = p[step];
399    const int a = 3 * (q0 - p0);
400    const int a1 = VP8ksclip2[(a + 4) >> 3];
401    const int a2 = VP8ksclip2[(a + 3) >> 3];
402    const int a3 = (a1 + 1) >> 1;
403    p[-2*step] = VP8kclip1[p1 + a3];
404    p[-  step] = VP8kclip1[p0 + a2];
405    p[      0] = VP8kclip1[q0 - a1];
406    p[   step] = VP8kclip1[q1 - a3];
407  }
408  static WEBP_INLINE void DoFilter6_C(uint8_t* p, int step) {
409    const int p2 = p[-3*step], p1 = p[-2*step], p0 = p[-step];
410    const int q0 = p[0], q1 = p[step], q2 = p[2*step];
411    const int a = VP8ksclip1[3 * (q0 - p0) + VP8ksclip1[p1 - q1]];
412    const int a1 = (27 * a + 63) >> 7;  
413    const int a2 = (18 * a + 63) >> 7;  
414    const int a3 = (9  * a + 63) >> 7;  
415    p[-3*step] = VP8kclip1[p2 + a3];
416    p[-2*step] = VP8kclip1[p1 + a2];
417    p[-  step] = VP8kclip1[p0 + a1];
418    p[      0] = VP8kclip1[q0 - a1];
419    p[   step] = VP8kclip1[q1 - a2];
420    p[ 2*step] = VP8kclip1[q2 - a3];
421  }
422  static WEBP_INLINE int Hev(const uint8_t* p, int step, int thresh) {
423    const int p1 = p[-2*step], p0 = p[-step], q0 = p[0], q1 = p[step];
424    return (VP8kabs0[p1 - p0] > thresh) || (VP8kabs0[q1 - q0] > thresh);
425  }
426  #endif  
427  #if !WEBP_NEON_OMIT_C_CODE
428  static WEBP_INLINE int NeedsFilter_C(const uint8_t* p, int step, int t) {
429    const int p1 = p[-2 * step], p0 = p[-step], q0 = p[0], q1 = p[step];
430    return ((4 * VP8kabs0[p0 - q0] + VP8kabs0[p1 - q1]) <= t);
431  }
432  #endif  
433  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
434  static WEBP_INLINE int NeedsFilter2_C(const uint8_t* p,
435                                        int step, int t, int it) {
436    const int p3 = p[-4 * step], p2 = p[-3 * step], p1 = p[-2 * step];
437    const int p0 = p[-step], q0 = p[0];
438    const int q1 = p[step], q2 = p[2 * step], q3 = p[3 * step];
439    if ((4 * VP8kabs0[p0 - q0] + VP8kabs0[p1 - q1]) > t) return 0;
440    return VP8kabs0[p3 - p2] <= it && VP8kabs0[p2 - p1] <= it &&
441           VP8kabs0[p1 - p0] <= it && VP8kabs0[q3 - q2] <= it &&
442           VP8kabs0[q2 - q1] <= it && VP8kabs0[q1 - q0] <= it;
443  }
444  #endif  
445  #if !WEBP_NEON_OMIT_C_CODE
446  static void SimpleVFilter16_C(uint8_t* p, int stride, int thresh) {
447    int i;
448    const int thresh2 = 2 * thresh + 1;
449    for (i = 0; i < 16; ++i) {
450      if (NeedsFilter_C(p + i, stride, thresh2)) {
451        DoFilter2_C(p + i, stride);
452      }
453    }
454  }
455  static void SimpleHFilter16_C(uint8_t* p, int stride, int thresh) {
456    int i;
457    const int thresh2 = 2 * thresh + 1;
458    for (i = 0; i < 16; ++i) {
459      if (NeedsFilter_C(p + i * stride, 1, thresh2)) {
460        DoFilter2_C(p + i * stride, 1);
461      }
462    }
463  }
464  static void SimpleVFilter16i_C(uint8_t* p, int stride, int thresh) {
465    int k;
466    for (k = 3; k > 0; --k) {
467      p += 4 * stride;
468      SimpleVFilter16_C(p, stride, thresh);
469    }
470  }
471  static void SimpleHFilter16i_C(uint8_t* p, int stride, int thresh) {
472    int k;
473    for (k = 3; k > 0; --k) {
474      p += 4;
475      SimpleHFilter16_C(p, stride, thresh);
476    }
477  }
478  #endif  
479  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
480  static WEBP_INLINE void FilterLoop26_C(uint8_t* p,
481                                         int hstride, int vstride, int size,
482                                         int thresh, int ithresh,
483                                         int hev_thresh) {
484    const int thresh2 = 2 * thresh + 1;
485    while (size-- > 0) {
486      if (NeedsFilter2_C(p, hstride, thresh2, ithresh)) {
487        if (Hev(p, hstride, hev_thresh)) {
488          DoFilter2_C(p, hstride);
489        } else {
490          DoFilter6_C(p, hstride);
491        }
492      }
493      p += vstride;
494    }
495  }
496  static WEBP_INLINE void FilterLoop24_C(uint8_t* p,
497                                         int hstride, int vstride, int size,
498                                         int thresh, int ithresh,
499                                         int hev_thresh) {
500    const int thresh2 = 2 * thresh + 1;
501    while (size-- > 0) {
502      if (NeedsFilter2_C(p, hstride, thresh2, ithresh)) {
503        if (Hev(p, hstride, hev_thresh)) {
504          DoFilter2_C(p, hstride);
505        } else {
506          DoFilter4_C(p, hstride);
507        }
508      }
509      p += vstride;
510    }
511  }
512  #endif  
513  #if !WEBP_NEON_OMIT_C_CODE
514  static void VFilter16_C(uint8_t* p, int stride,
515                          int thresh, int ithresh, int hev_thresh) {
516    FilterLoop26_C(p, stride, 1, 16, thresh, ithresh, hev_thresh);
517  }
518  static void HFilter16_C(uint8_t* p, int stride,
519                          int thresh, int ithresh, int hev_thresh) {
520    FilterLoop26_C(p, 1, stride, 16, thresh, ithresh, hev_thresh);
521  }
522  static void VFilter16i_C(uint8_t* p, int stride,
523                           int thresh, int ithresh, int hev_thresh) {
524    int k;
525    for (k = 3; k > 0; --k) {
526      p += 4 * stride;
527      FilterLoop24_C(p, stride, 1, 16, thresh, ithresh, hev_thresh);
528    }
529  }
530  #endif  
531  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
532  static void HFilter16i_C(uint8_t* p, int stride,
533                           int thresh, int ithresh, int hev_thresh) {
534    int k;
535    for (k = 3; k > 0; --k) {
536      p += 4;
537      FilterLoop24_C(p, 1, stride, 16, thresh, ithresh, hev_thresh);
538    }
539  }
540  #endif  
541  #if !WEBP_NEON_OMIT_C_CODE
542  static void VFilter8_C(uint8_t* u, uint8_t* v, int stride,
543                         int thresh, int ithresh, int hev_thresh) {
544    FilterLoop26_C(u, stride, 1, 8, thresh, ithresh, hev_thresh);
545    FilterLoop26_C(v, stride, 1, 8, thresh, ithresh, hev_thresh);
546  }
547  #endif  
548  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
549  static void HFilter8_C(uint8_t* u, uint8_t* v, int stride,
550                         int thresh, int ithresh, int hev_thresh) {
551    FilterLoop26_C(u, 1, stride, 8, thresh, ithresh, hev_thresh);
552    FilterLoop26_C(v, 1, stride, 8, thresh, ithresh, hev_thresh);
553  }
554  #endif  
555  #if !WEBP_NEON_OMIT_C_CODE
556  static void VFilter8i_C(uint8_t* u, uint8_t* v, int stride,
557                          int thresh, int ithresh, int hev_thresh) {
558    FilterLoop24_C(u + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
559    FilterLoop24_C(v + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
560  }
561  #endif  
562  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
563  static void HFilter8i_C(uint8_t* u, uint8_t* v, int stride,
564                          int thresh, int ithresh, int hev_thresh) {
565    FilterLoop24_C(u + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
566    FilterLoop24_C(v + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
567  }
568  #endif  
569  static void DitherCombine8x8_C(const uint8_t* dither, uint8_t* dst,
570                                 int dst_stride) {
571    int i, j;
572    for (j = 0; j < 8; ++j) {
573      for (i = 0; i < 8; ++i) {
574        const int delta0 = dither[i] - VP8_DITHER_AMP_CENTER;
575        const int delta1 =
576            (delta0 + VP8_DITHER_DESCALE_ROUNDER) >> VP8_DITHER_DESCALE;
577        dst[i] = clip_8b((int)dst[i] + delta1);
578      }
579      dst += dst_stride;
580      dither += 8;
581    }
582  }
583  VP8DecIdct2 VP8Transform;
584  VP8DecIdct VP8TransformAC3;
585  VP8DecIdct VP8TransformUV;
586  VP8DecIdct VP8TransformDC;
587  VP8DecIdct VP8TransformDCUV;
588  VP8LumaFilterFunc VP8VFilter16;
589  VP8LumaFilterFunc VP8HFilter16;
590  VP8ChromaFilterFunc VP8VFilter8;
591  VP8ChromaFilterFunc VP8HFilter8;
592  VP8LumaFilterFunc VP8VFilter16i;
593  VP8LumaFilterFunc VP8HFilter16i;
594  VP8ChromaFilterFunc VP8VFilter8i;
595  VP8ChromaFilterFunc VP8HFilter8i;
596  VP8SimpleFilterFunc VP8SimpleVFilter16;
597  VP8SimpleFilterFunc VP8SimpleHFilter16;
598  VP8SimpleFilterFunc VP8SimpleVFilter16i;
599  VP8SimpleFilterFunc VP8SimpleHFilter16i;
600  void (*VP8DitherCombine8x8)(const uint8_t* dither, uint8_t* dst,
601                              int dst_stride);
602  extern void VP8DspInitSSE2(void);
603  extern void VP8DspInitSSE41(void);
604  extern void VP8DspInitNEON(void);
605  extern void VP8DspInitMIPS32(void);
606  extern void VP8DspInitMIPSdspR2(void);
607  extern void VP8DspInitMSA(void);
608  WEBP_DSP_INIT_FUNC(VP8DspInit) {
609    VP8InitClipTables();
610  #if !WEBP_NEON_OMIT_C_CODE
611    VP8TransformWHT = TransformWHT_C;
612    VP8Transform = TransformTwo_C;
613    VP8TransformDC = TransformDC_C;
614    VP8TransformAC3 = TransformAC3_C;
615  #endif
616    VP8TransformUV = TransformUV_C;
617    VP8TransformDCUV = TransformDCUV_C;
618  #if !WEBP_NEON_OMIT_C_CODE
619    VP8VFilter16 = VFilter16_C;
620    VP8VFilter16i = VFilter16i_C;
621    VP8HFilter16 = HFilter16_C;
622    VP8VFilter8 = VFilter8_C;
623    VP8VFilter8i = VFilter8i_C;
624    VP8SimpleVFilter16 = SimpleVFilter16_C;
625    VP8SimpleHFilter16 = SimpleHFilter16_C;
626    VP8SimpleVFilter16i = SimpleVFilter16i_C;
627    VP8SimpleHFilter16i = SimpleHFilter16i_C;
628  #endif
629  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
630    VP8HFilter16i = HFilter16i_C;
631    VP8HFilter8 = HFilter8_C;
632    VP8HFilter8i = HFilter8i_C;
633  #endif
634  #if !WEBP_NEON_OMIT_C_CODE
635    VP8PredLuma4[0] = DC4_C;
636    VP8PredLuma4[1] = TM4_C;
637    VP8PredLuma4[2] = VE4_C;
638    VP8PredLuma4[4] = RD4_C;
639    VP8PredLuma4[6] = LD4_C;
640  #endif
641    VP8PredLuma4[3] = HE4_C;
642    VP8PredLuma4[5] = VR4_C;
643    VP8PredLuma4[7] = VL4_C;
644    VP8PredLuma4[8] = HD4_C;
645    VP8PredLuma4[9] = HU4_C;
646  #if !WEBP_NEON_OMIT_C_CODE
647    VP8PredLuma16[0] = DC16_C;
648    VP8PredLuma16[1] = TM16_C;
649    VP8PredLuma16[2] = VE16_C;
650    VP8PredLuma16[3] = HE16_C;
651    VP8PredLuma16[4] = DC16NoTop_C;
652    VP8PredLuma16[5] = DC16NoLeft_C;
653    VP8PredLuma16[6] = DC16NoTopLeft_C;
654    VP8PredChroma8[0] = DC8uv_C;
655    VP8PredChroma8[1] = TM8uv_C;
656    VP8PredChroma8[2] = VE8uv_C;
657    VP8PredChroma8[3] = HE8uv_C;
658    VP8PredChroma8[4] = DC8uvNoTop_C;
659    VP8PredChroma8[5] = DC8uvNoLeft_C;
660    VP8PredChroma8[6] = DC8uvNoTopLeft_C;
661  #endif
662    VP8DitherCombine8x8 = DitherCombine8x8_C;
663    if (VP8GetCPUInfo != NULL) {
664  #if defined(WEBP_USE_SSE2)
665      if (VP8GetCPUInfo(kSSE2)) {
666        VP8DspInitSSE2();
667  #if defined(WEBP_USE_SSE41)
668        if (VP8GetCPUInfo(kSSE4_1)) {
669          VP8DspInitSSE41();
670        }
671  #endif
672      }
673  #endif
674  #if defined(WEBP_USE_MIPS32)
675      if (VP8GetCPUInfo(kMIPS32)) {
676        VP8DspInitMIPS32();
677      }
678  #endif
679  #if defined(WEBP_USE_MIPS_DSP_R2)
680      if (VP8GetCPUInfo(kMIPSdspR2)) {
681        VP8DspInitMIPSdspR2();
682      }
683  #endif
684  #if defined(WEBP_USE_MSA)
685      if (VP8GetCPUInfo(kMSA)) {
686        VP8DspInitMSA();
687      }
688  #endif
689    }
690  #if defined(WEBP_USE_NEON)
691    if (WEBP_NEON_OMIT_C_CODE ||
692        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
693      VP8DspInitNEON();
694    }
695  #endif
696    assert(VP8TransformWHT != NULL);
697    assert(VP8Transform != NULL);
698    assert(VP8TransformDC != NULL);
699    assert(VP8TransformAC3 != NULL);
700    assert(VP8TransformUV != NULL);
701    assert(VP8TransformDCUV != NULL);
702    assert(VP8VFilter16 != NULL);
703    assert(VP8HFilter16 != NULL);
704    assert(VP8VFilter8 != NULL);
705    assert(VP8HFilter8 != NULL);
706    assert(VP8VFilter16i != NULL);
707    assert(VP8HFilter16i != NULL);
708    assert(VP8VFilter8i != NULL);
709    assert(VP8HFilter8i != NULL);
710    assert(VP8SimpleVFilter16 != NULL);
711    assert(VP8SimpleHFilter16 != NULL);
712    assert(VP8SimpleVFilter16i != NULL);
713    assert(VP8SimpleHFilter16i != NULL);
714    assert(VP8PredLuma4[0] != NULL);
715    assert(VP8PredLuma4[1] != NULL);
716    assert(VP8PredLuma4[2] != NULL);
717    assert(VP8PredLuma4[3] != NULL);
718    assert(VP8PredLuma4[4] != NULL);
719    assert(VP8PredLuma4[5] != NULL);
720    assert(VP8PredLuma4[6] != NULL);
721    assert(VP8PredLuma4[7] != NULL);
722    assert(VP8PredLuma4[8] != NULL);
723    assert(VP8PredLuma4[9] != NULL);
724    assert(VP8PredLuma16[0] != NULL);
725    assert(VP8PredLuma16[1] != NULL);
726    assert(VP8PredLuma16[2] != NULL);
727    assert(VP8PredLuma16[3] != NULL);
728    assert(VP8PredLuma16[4] != NULL);
729    assert(VP8PredLuma16[5] != NULL);
730    assert(VP8PredLuma16[6] != NULL);
731    assert(VP8PredChroma8[0] != NULL);
732    assert(VP8PredChroma8[1] != NULL);
733    assert(VP8PredChroma8[2] != NULL);
734    assert(VP8PredChroma8[3] != NULL);
735    assert(VP8PredChroma8[4] != NULL);
736    assert(VP8PredChroma8[5] != NULL);
737    assert(VP8PredChroma8[6] != NULL);
738    assert(VP8DitherCombine8x8 != NULL);
739  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_neon.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec.c</div>
                <div class="column column_space"><pre><code>36    for (; i < width; ++i, rgb += 3) {   
37      y[i] = VP8RGBToY(rgb[0], rgb[1], rgb[2], YUV_HALF);
38    }
39  }
40  static void ConvertBGR24ToY_NEON(const uint8_t* bgr, uint8_t* y, int width) {
</pre></code></div>
                <div class="column column_space"><pre><code>149    for (j = 16; j > 0; --j) {
150      memset(dst, dst[-1], 16);
151      dst += BPS;
152    }
153  }
154  static WEBP_INLINE void Put16(int v, uint8_t* dst) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    