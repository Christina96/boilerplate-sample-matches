
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 27, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-threads.c</h3>
            <pre><code>1  #include "threads/threads.h"
2  #include "api/api.h"
3  #if defined(USING_POSIX_THREADS)
4  #include <pthread.h>
5  #ifdef HAVE_UNISTD_H
6  #  include <unistd.h>
7  #endif
8  #if (defined(_POSIX_SEMAPHORES) && (_POSIX_SEMAPHORES >= 200112L))
9  #  include <semaphore.h>
10  #  include <errno.h>
11     typedef sem_t os_sem_t;
12     static void os_sem_init(os_sem_t *s) { sem_init(s, 0, 0); }
13     static void os_sem_destroy(os_sem_t *s) { sem_destroy(s); }
14     static void os_sem_down(os_sem_t *s)
15     {
16  	int err;
17  	do {
18  	     err = sem_wait(s);
19  	} while (err == -1 && errno == EINTR);
20  	CK(err == 0);
21     }
22     static void os_sem_up(os_sem_t *s) { sem_post(s); }
23     typedef sem_t os_mutex_t;
24     static void os_mutex_init(os_mutex_t *s) { sem_init(s, 0, 1); }
25     #define os_mutex_destroy os_sem_destroy
26     #define os_mutex_lock os_sem_down
27     #define os_mutex_unlock os_sem_up
28  #else
29     typedef pthread_mutex_t os_mutex_t;
30     static void os_mutex_init(os_mutex_t *s)
31     {
32  	pthread_mutex_init(s, (pthread_mutexattr_t *)0);
33     }
34     static void os_mutex_destroy(os_mutex_t *s) { pthread_mutex_destroy(s); }
35     static void os_mutex_lock(os_mutex_t *s) { pthread_mutex_lock(s); }
36     static void os_mutex_unlock(os_mutex_t *s) { pthread_mutex_unlock(s); }
37     typedef struct {
38  	pthread_mutex_t m;
39  	pthread_cond_t c;
40  	volatile int x;
41     } os_sem_t;
42     static void os_sem_init(os_sem_t *s)
43     {
44  	pthread_mutex_init(&s->m, (pthread_mutexattr_t *)0);
45  	pthread_cond_init(&s->c, (pthread_condattr_t *)0);
46  	pthread_mutex_lock(&s->m);
47  	s->x = 0;
48  	pthread_mutex_unlock(&s->m);
49     }
50     static void os_sem_destroy(os_sem_t *s)
51     {
52  	pthread_mutex_destroy(&s->m);
53  	pthread_cond_destroy(&s->c);
54     }
55     static void os_sem_down(os_sem_t *s)
56     {
57  	pthread_mutex_lock(&s->m);
58  	while (s->x <= 0)
59  	     pthread_cond_wait(&s->c, &s->m);
60  	--s->x;
61  	pthread_mutex_unlock(&s->m);
62     }
63     static void os_sem_up(os_sem_t *s)
64     {
65  	pthread_mutex_lock(&s->m);
66  	++s->x;
67  	pthread_cond_signal(&s->c);
68  	pthread_mutex_unlock(&s->m);
69     }
70  #endif
71  #define FFTW_WORKER void *
72  static void os_create_thread(FFTW_WORKER (*worker)(void *arg),
73  			     void *arg)
74  {
75       pthread_attr_t attr;
76       pthread_t tid;
77       pthread_attr_init(&attr);
78       pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
79       pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
80       pthread_create(&tid, &attr, worker, (void *)arg);
81       pthread_attr_destroy(&attr);
82  }
83  static void os_destroy_thread(void)
84  {
85       pthread_exit((void *)0);
86  }
87  typedef pthread_mutex_t os_static_mutex_t;
88  #define OS_STATIC_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
89  static void os_static_mutex_lock(os_static_mutex_t *s) { pthread_mutex_lock(s); }
90  static void os_static_mutex_unlock(os_static_mutex_t *s) { pthread_mutex_unlock(s); }
91  #elif defined(__WIN32__) || defined(_WIN32) || defined(_WINDOWS)
92  #define INT magnus_ab_INTegro_seclorum_nascitur_ordo
93  #include <windows.h>
94  #include <process.h>
95  #include <intrin.h>
96  #undef INT
97  typedef HANDLE os_mutex_t;
98  static void os_mutex_init(os_mutex_t *s)
99  {
100       *s = CreateMutex(NULL, FALSE, NULL);
101  }
102  static void os_mutex_destroy(os_mutex_t *s)
103  {
104       CloseHandle(*s);
105  }
106  static void os_mutex_lock(os_mutex_t *s)
107  {
108       WaitForSingleObject(*s, INFINITE);
109  }
110  static void os_mutex_unlock(os_mutex_t *s)
111  {
112       ReleaseMutex(*s);
113  }
114  typedef HANDLE os_sem_t;
115  static void os_sem_init(os_sem_t *s)
116  {
117       *s = CreateSemaphore(NULL, 0, 0x7FFFFFFFL, NULL);
118  }
119  static void os_sem_destroy(os_sem_t *s)
120  {
121       CloseHandle(*s);
122  }
<span onclick='openModal()' class='match'>123  static void os_sem_down(os_sem_t *s)
124  {
125       WaitForSingleObject(*s, INFINITE);
126  }
127  static void os_sem_up(os_sem_t *s)
128  {
129       ReleaseSemaphore(*s, 1, NULL);
</span>130  }
131  #define FFTW_WORKER unsigned __stdcall
132  typedef unsigned (__stdcall *winthread_start) (void *);
133  static void os_create_thread(winthread_start worker,
134  			     void *arg)
135  {
136       _beginthreadex((void *)NULL,               &bsol;* security attrib */
137  		    0,				&bsol;* stack size */
138  		    worker,                     &bsol;* start address */
139  		    arg,			&bsol;* parameters */
140  		    0,				&bsol;* creation flags */
141  		    (unsigned *)NULL);		&bsol;* tid */
142  }
143  static void os_destroy_thread(void)
144  {
145       _endthreadex(0);
146  }
147  typedef volatile LONG os_static_mutex_t;
148  #define OS_STATIC_MUTEX_INITIALIZER 0
149  static void os_static_mutex_lock(os_static_mutex_t *s)
150  {
151       while (InterlockedExchange(s, 1) == 1) {
152            YieldProcessor();
153            Sleep(0);
154       }
155  }
156  static void os_static_mutex_unlock(os_static_mutex_t *s)
157  {
158       LONG old = InterlockedExchange(s, 0);
159       A(old == 1);
160  }
161  #else
162  #error "No threading layer defined"
163  #endif
164  struct worker {
165       os_sem_t ready;
166       os_sem_t done;
167       struct work *w;
168       struct worker *cdr;
169  };
170  static struct worker *make_worker(void)
171  {
172       struct worker *q = (struct worker *)MALLOC(sizeof(*q), OTHER);
173       os_sem_init(&q->ready);
174       os_sem_init(&q->done);
175       return q;
176  }
177  static void unmake_worker(struct worker *q)
178  {
179       os_sem_destroy(&q->done);
180       os_sem_destroy(&q->ready);
181       X(ifree)(q);
182  }
183  struct work {
184       spawn_function proc;
185       spawn_data d;
186       struct worker *q; &bsol;* the worker responsible for performing this work */
187  };
188  static os_mutex_t queue_lock;
189  static os_sem_t termination_semaphore;
190  static struct worker *worker_queue;
191  #define WITH_QUEUE_LOCK(what)			\
192  {						\
193       os_mutex_lock(&queue_lock);		\
194       what;					\
195       os_mutex_unlock(&queue_lock);		\
196  }
197  static FFTW_WORKER worker(void *arg)
198  {
199       struct worker *ego = (struct worker *)arg;
200       struct work *w;
201       for (;;) {
202  	  os_sem_down(&ego->ready);
203  	  w = ego->w;
204  	  if (!w->proc) break;
205            w->proc(&w->d);
206  	  os_sem_up(&ego->done);
207       }
208       os_sem_up(&termination_semaphore);
209       os_destroy_thread();
210       return 0;
211  }
212  static void enqueue(struct worker *q)
213  {
214       WITH_QUEUE_LOCK({
215  	  q->cdr = worker_queue;
216  	  worker_queue = q;
217       });
218  }
219  static struct worker *dequeue(void)
220  {
221       struct worker *q;
222       WITH_QUEUE_LOCK({
223  	  q = worker_queue;
224  	  if (q)
225  	       worker_queue = q->cdr;
226       });
227       if (!q) {
228  	  q = make_worker();
229  	  os_create_thread(worker, q);
230       }
231       return q;
232  }
233  static void kill_workforce(void)
234  {
235       struct work w;
236       w.proc = 0;
237       WITH_QUEUE_LOCK({
238  	  while (worker_queue) {
239  	       struct worker *q = worker_queue;
240  	       worker_queue = q->cdr;
241  	       q->w = &w;
242  	       os_sem_up(&q->ready);
243  	       os_sem_down(&termination_semaphore);
244  	       unmake_worker(q);
245  	  }
246       });
247  }
248  static os_static_mutex_t initialization_mutex = OS_STATIC_MUTEX_INITIALIZER;
249  int X(ithreads_init)(void)
250  {
251       os_static_mutex_lock(&initialization_mutex); {
252            os_mutex_init(&queue_lock);
253            os_sem_init(&termination_semaphore);
254            WITH_QUEUE_LOCK({
255                 worker_queue = 0;
256            });
257       } os_static_mutex_unlock(&initialization_mutex);
258       return 0; &bsol;* no error */
259  }
260  void X(spawn_loop)(int loopmax, int nthr, spawn_function proc, void *data)
261  {
262       int block_size;
263       int i;
264       A(loopmax >= 0);
265       A(nthr > 0);
266       A(proc);
267       if (!loopmax) return;
268       block_size = (loopmax + nthr - 1) / nthr;
269       nthr = (loopmax + block_size - 1) / block_size;
270       if (X(spawnloop_callback)) { &bsol;* user-defined spawnloop backend */
271            spawn_data *sdata;
272            STACK_MALLOC(spawn_data *, sdata, sizeof(spawn_data) * nthr);
273            for (i = 0; i < nthr; ++i) {
274                 spawn_data *d = &sdata[i];
275                 d->max = (d->min = i * block_size) + block_size;
276                 if (d->max > loopmax)
277                      d->max = loopmax;
278                 d->thr_num = i;
279                 d->data = data;
280            }
281            X(spawnloop_callback)(proc, sdata, sizeof(spawn_data), nthr, X(spawnloop_callback_data));
282            STACK_FREE(sdata);
283       }
284       else {
285            struct work *r;
286            STACK_MALLOC(struct work *, r, sizeof(struct work) * nthr);
287            for (i = 0; i < nthr; ++i) {
288                 struct work *w = &r[i];
289                 spawn_data *d = &w->d;
290                 d->max = (d->min = i * block_size) + block_size;
291                 if (d->max > loopmax)
292                      d->max = loopmax;
293                 d->thr_num = i;
294                 d->data = data;
295                 w->proc = proc;
296                 if (i == nthr - 1) {
297                      proc(d);
298                 } else {
299                      w->q = dequeue();
300                      w->q->w = w; &bsol;* Dirac could have written this */
301                      os_sem_up(&w->q->ready);
302                 }
303            }
304            for (i = 0; i < nthr - 1; ++i) {
305                 struct work *w = &r[i];
306                 os_sem_down(&w->q->done);
307                 enqueue(w->q);
308            }
309            STACK_FREE(r);
310       }
311  }
312  void X(threads_cleanup)(void)
313  {
314       kill_workforce();
315       os_mutex_destroy(&queue_lock);
316       os_sem_destroy(&termination_semaphore);
317  }
318  static os_static_mutex_t install_planner_hooks_mutex = OS_STATIC_MUTEX_INITIALIZER;
319  static os_mutex_t planner_mutex;
320  static int planner_hooks_installed = 0;
321  static void lock_planner_mutex(void)
322  {
323       os_mutex_lock(&planner_mutex);
324  }
325  static void unlock_planner_mutex(void)
326  {
327       os_mutex_unlock(&planner_mutex);
328  }
329  void X(threads_register_planner_hooks)(void)
330  {
331       os_static_mutex_lock(&install_planner_hooks_mutex); {
332            if (!planner_hooks_installed) {
333                 os_mutex_init(&planner_mutex);
334                 X(set_planner_hooks)(lock_planner_mutex, unlock_planner_mutex);
335                 planner_hooks_installed = 1;
336            }
337       } os_static_mutex_unlock(&install_planner_hooks_mutex);
338  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-threads.c</h3>
            <pre><code>1  #include "threads/threads.h"
2  #include "api/api.h"
3  #if defined(USING_POSIX_THREADS)
4  #include <pthread.h>
5  #ifdef HAVE_UNISTD_H
6  #  include <unistd.h>
7  #endif
8  #if (defined(_POSIX_SEMAPHORES) && (_POSIX_SEMAPHORES >= 200112L))
9  #  include <semaphore.h>
10  #  include <errno.h>
11     typedef sem_t os_sem_t;
12     static void os_sem_init(os_sem_t *s) { sem_init(s, 0, 0); }
13     static void os_sem_destroy(os_sem_t *s) { sem_destroy(s); }
14     static void os_sem_down(os_sem_t *s)
15     {
16  	int err;
17  	do {
18  	     err = sem_wait(s);
19  	} while (err == -1 && errno == EINTR);
20  	CK(err == 0);
21     }
22     static void os_sem_up(os_sem_t *s) { sem_post(s); }
23     typedef sem_t os_mutex_t;
24     static void os_mutex_init(os_mutex_t *s) { sem_init(s, 0, 1); }
25     #define os_mutex_destroy os_sem_destroy
26     #define os_mutex_lock os_sem_down
27     #define os_mutex_unlock os_sem_up
28  #else
29     typedef pthread_mutex_t os_mutex_t;
30     static void os_mutex_init(os_mutex_t *s)
31     {
32  	pthread_mutex_init(s, (pthread_mutexattr_t *)0);
33     }
34     static void os_mutex_destroy(os_mutex_t *s) { pthread_mutex_destroy(s); }
35     static void os_mutex_lock(os_mutex_t *s) { pthread_mutex_lock(s); }
36     static void os_mutex_unlock(os_mutex_t *s) { pthread_mutex_unlock(s); }
37     typedef struct {
38  	pthread_mutex_t m;
39  	pthread_cond_t c;
40  	volatile int x;
41     } os_sem_t;
42     static void os_sem_init(os_sem_t *s)
43     {
44  	pthread_mutex_init(&s->m, (pthread_mutexattr_t *)0);
45  	pthread_cond_init(&s->c, (pthread_condattr_t *)0);
46  	pthread_mutex_lock(&s->m);
47  	s->x = 0;
48  	pthread_mutex_unlock(&s->m);
49     }
50     static void os_sem_destroy(os_sem_t *s)
51     {
52  	pthread_mutex_destroy(&s->m);
53  	pthread_cond_destroy(&s->c);
54     }
55     static void os_sem_down(os_sem_t *s)
56     {
57  	pthread_mutex_lock(&s->m);
58  	while (s->x <= 0)
59  	     pthread_cond_wait(&s->c, &s->m);
60  	--s->x;
61  	pthread_mutex_unlock(&s->m);
62     }
63     static void os_sem_up(os_sem_t *s)
64     {
65  	pthread_mutex_lock(&s->m);
66  	++s->x;
67  	pthread_cond_signal(&s->c);
68  	pthread_mutex_unlock(&s->m);
69     }
70  #endif
71  #define FFTW_WORKER void *
72  static void os_create_thread(FFTW_WORKER (*worker)(void *arg),
73  			     void *arg)
74  {
75       pthread_attr_t attr;
76       pthread_t tid;
77       pthread_attr_init(&attr);
78       pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
79       pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
80       pthread_create(&tid, &attr, worker, (void *)arg);
81       pthread_attr_destroy(&attr);
82  }
83  static void os_destroy_thread(void)
84  {
85       pthread_exit((void *)0);
86  }
87  typedef pthread_mutex_t os_static_mutex_t;
88  #define OS_STATIC_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
89  static void os_static_mutex_lock(os_static_mutex_t *s) { pthread_mutex_lock(s); }
90  static void os_static_mutex_unlock(os_static_mutex_t *s) { pthread_mutex_unlock(s); }
91  #elif defined(__WIN32__) || defined(_WIN32) || defined(_WINDOWS)
92  #define INT magnus_ab_INTegro_seclorum_nascitur_ordo
93  #include <windows.h>
94  #include <process.h>
95  #include <intrin.h>
96  #undef INT
97  typedef HANDLE os_mutex_t;
98  static void os_mutex_init(os_mutex_t *s)
99  {
100       *s = CreateMutex(NULL, FALSE, NULL);
101  }
102  static void os_mutex_destroy(os_mutex_t *s)
103  {
104       CloseHandle(*s);
105  }
<span onclick='openModal()' class='match'>106  static void os_mutex_lock(os_mutex_t *s)
107  {
108       WaitForSingleObject(*s, INFINITE);
109  }
110  static void os_mutex_unlock(os_mutex_t *s)
111  {
112       ReleaseMutex(*s);
</span>113  }
114  typedef HANDLE os_sem_t;
115  static void os_sem_init(os_sem_t *s)
116  {
117       *s = CreateSemaphore(NULL, 0, 0x7FFFFFFFL, NULL);
118  }
119  static void os_sem_destroy(os_sem_t *s)
120  {
121       CloseHandle(*s);
122  }
123  static void os_sem_down(os_sem_t *s)
124  {
125       WaitForSingleObject(*s, INFINITE);
126  }
127  static void os_sem_up(os_sem_t *s)
128  {
129       ReleaseSemaphore(*s, 1, NULL);
130  }
131  #define FFTW_WORKER unsigned __stdcall
132  typedef unsigned (__stdcall *winthread_start) (void *);
133  static void os_create_thread(winthread_start worker,
134  			     void *arg)
135  {
136       _beginthreadex((void *)NULL,               &bsol;* security attrib */
137  		    0,				&bsol;* stack size */
138  		    worker,                     &bsol;* start address */
139  		    arg,			&bsol;* parameters */
140  		    0,				&bsol;* creation flags */
141  		    (unsigned *)NULL);		&bsol;* tid */
142  }
143  static void os_destroy_thread(void)
144  {
145       _endthreadex(0);
146  }
147  typedef volatile LONG os_static_mutex_t;
148  #define OS_STATIC_MUTEX_INITIALIZER 0
149  static void os_static_mutex_lock(os_static_mutex_t *s)
150  {
151       while (InterlockedExchange(s, 1) == 1) {
152            YieldProcessor();
153            Sleep(0);
154       }
155  }
156  static void os_static_mutex_unlock(os_static_mutex_t *s)
157  {
158       LONG old = InterlockedExchange(s, 0);
159       A(old == 1);
160  }
161  #else
162  #error "No threading layer defined"
163  #endif
164  struct worker {
165       os_sem_t ready;
166       os_sem_t done;
167       struct work *w;
168       struct worker *cdr;
169  };
170  static struct worker *make_worker(void)
171  {
172       struct worker *q = (struct worker *)MALLOC(sizeof(*q), OTHER);
173       os_sem_init(&q->ready);
174       os_sem_init(&q->done);
175       return q;
176  }
177  static void unmake_worker(struct worker *q)
178  {
179       os_sem_destroy(&q->done);
180       os_sem_destroy(&q->ready);
181       X(ifree)(q);
182  }
183  struct work {
184       spawn_function proc;
185       spawn_data d;
186       struct worker *q; &bsol;* the worker responsible for performing this work */
187  };
188  static os_mutex_t queue_lock;
189  static os_sem_t termination_semaphore;
190  static struct worker *worker_queue;
191  #define WITH_QUEUE_LOCK(what)			\
192  {						\
193       os_mutex_lock(&queue_lock);		\
194       what;					\
195       os_mutex_unlock(&queue_lock);		\
196  }
197  static FFTW_WORKER worker(void *arg)
198  {
199       struct worker *ego = (struct worker *)arg;
200       struct work *w;
201       for (;;) {
202  	  os_sem_down(&ego->ready);
203  	  w = ego->w;
204  	  if (!w->proc) break;
205            w->proc(&w->d);
206  	  os_sem_up(&ego->done);
207       }
208       os_sem_up(&termination_semaphore);
209       os_destroy_thread();
210       return 0;
211  }
212  static void enqueue(struct worker *q)
213  {
214       WITH_QUEUE_LOCK({
215  	  q->cdr = worker_queue;
216  	  worker_queue = q;
217       });
218  }
219  static struct worker *dequeue(void)
220  {
221       struct worker *q;
222       WITH_QUEUE_LOCK({
223  	  q = worker_queue;
224  	  if (q)
225  	       worker_queue = q->cdr;
226       });
227       if (!q) {
228  	  q = make_worker();
229  	  os_create_thread(worker, q);
230       }
231       return q;
232  }
233  static void kill_workforce(void)
234  {
235       struct work w;
236       w.proc = 0;
237       WITH_QUEUE_LOCK({
238  	  while (worker_queue) {
239  	       struct worker *q = worker_queue;
240  	       worker_queue = q->cdr;
241  	       q->w = &w;
242  	       os_sem_up(&q->ready);
243  	       os_sem_down(&termination_semaphore);
244  	       unmake_worker(q);
245  	  }
246       });
247  }
248  static os_static_mutex_t initialization_mutex = OS_STATIC_MUTEX_INITIALIZER;
249  int X(ithreads_init)(void)
250  {
251       os_static_mutex_lock(&initialization_mutex); {
252            os_mutex_init(&queue_lock);
253            os_sem_init(&termination_semaphore);
254            WITH_QUEUE_LOCK({
255                 worker_queue = 0;
256            });
257       } os_static_mutex_unlock(&initialization_mutex);
258       return 0; &bsol;* no error */
259  }
260  void X(spawn_loop)(int loopmax, int nthr, spawn_function proc, void *data)
261  {
262       int block_size;
263       int i;
264       A(loopmax >= 0);
265       A(nthr > 0);
266       A(proc);
267       if (!loopmax) return;
268       block_size = (loopmax + nthr - 1) / nthr;
269       nthr = (loopmax + block_size - 1) / block_size;
270       if (X(spawnloop_callback)) { &bsol;* user-defined spawnloop backend */
271            spawn_data *sdata;
272            STACK_MALLOC(spawn_data *, sdata, sizeof(spawn_data) * nthr);
273            for (i = 0; i < nthr; ++i) {
274                 spawn_data *d = &sdata[i];
275                 d->max = (d->min = i * block_size) + block_size;
276                 if (d->max > loopmax)
277                      d->max = loopmax;
278                 d->thr_num = i;
279                 d->data = data;
280            }
281            X(spawnloop_callback)(proc, sdata, sizeof(spawn_data), nthr, X(spawnloop_callback_data));
282            STACK_FREE(sdata);
283       }
284       else {
285            struct work *r;
286            STACK_MALLOC(struct work *, r, sizeof(struct work) * nthr);
287            for (i = 0; i < nthr; ++i) {
288                 struct work *w = &r[i];
289                 spawn_data *d = &w->d;
290                 d->max = (d->min = i * block_size) + block_size;
291                 if (d->max > loopmax)
292                      d->max = loopmax;
293                 d->thr_num = i;
294                 d->data = data;
295                 w->proc = proc;
296                 if (i == nthr - 1) {
297                      proc(d);
298                 } else {
299                      w->q = dequeue();
300                      w->q->w = w; &bsol;* Dirac could have written this */
301                      os_sem_up(&w->q->ready);
302                 }
303            }
304            for (i = 0; i < nthr - 1; ++i) {
305                 struct work *w = &r[i];
306                 os_sem_down(&w->q->done);
307                 enqueue(w->q);
308            }
309            STACK_FREE(r);
310       }
311  }
312  void X(threads_cleanup)(void)
313  {
314       kill_workforce();
315       os_mutex_destroy(&queue_lock);
316       os_sem_destroy(&termination_semaphore);
317  }
318  static os_static_mutex_t install_planner_hooks_mutex = OS_STATIC_MUTEX_INITIALIZER;
319  static os_mutex_t planner_mutex;
320  static int planner_hooks_installed = 0;
321  static void lock_planner_mutex(void)
322  {
323       os_mutex_lock(&planner_mutex);
324  }
325  static void unlock_planner_mutex(void)
326  {
327       os_mutex_unlock(&planner_mutex);
328  }
329  void X(threads_register_planner_hooks)(void)
330  {
331       os_static_mutex_lock(&install_planner_hooks_mutex); {
332            if (!planner_hooks_installed) {
333                 os_mutex_init(&planner_mutex);
334                 X(set_planner_hooks)(lock_planner_mutex, unlock_planner_mutex);
335                 planner_hooks_installed = 1;
336            }
337       } os_static_mutex_unlock(&install_planner_hooks_mutex);
338  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-threads.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-threads.c</div>
                </div>
                <div class="column column_space"><pre><code>123  static void os_sem_down(os_sem_t *s)
124  {
125       WaitForSingleObject(*s, INFINITE);
126  }
127  static void os_sem_up(os_sem_t *s)
128  {
129       ReleaseSemaphore(*s, 1, NULL);
</pre></code></div>
                <div class="column column_space"><pre><code>106  static void os_mutex_lock(os_mutex_t *s)
107  {
108       WaitForSingleObject(*s, INFINITE);
109  }
110  static void os_mutex_unlock(os_mutex_t *s)
111  {
112       ReleaseMutex(*s);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    