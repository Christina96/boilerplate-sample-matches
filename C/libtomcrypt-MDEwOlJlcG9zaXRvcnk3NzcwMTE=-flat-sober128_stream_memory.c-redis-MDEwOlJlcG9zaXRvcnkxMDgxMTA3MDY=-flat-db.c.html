
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.288244766505636%, Tokens: 8</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sober128_stream_memory.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SOBER128_STREAM
3  int sober128_stream_memory(const unsigned char *key,    unsigned long keylen,
4                             const unsigned char *iv,     unsigned long ivlen,
<span onclick='openModal()' class='match'>5                             const unsigned char *datain, unsigned long datalen,
6                             unsigned char *dataout)
7  {
8     sober128_state st;
9     int err;
</span>10     if ((err = sober128_stream_setup(&st, key, keylen)) != CRYPT_OK) goto WIPE_KEY;
11     if ((err = sober128_stream_setiv(&st, iv, ivlen))   != CRYPT_OK) goto WIPE_KEY;
12     err = sober128_stream_crypt(&st, datain, datalen, dataout);
13  WIPE_KEY:
14     sober128_stream_done(&st);
15     return err;
16  }
17  #endif &bsol;* LTC_SOBER128_STREAM */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-db.c</h3>
            <pre><code>1  #include "server.h"
2  #ifdef _WIN32
3  #include "Win32_Interop/Win32_QFork.h"
4  #endif
5  #include "cluster.h"
6  #include "atomicvar.h"
7  #include <signal.h>
8  #include <ctype.h>
9  int keyIsExpired(redisDb *db, robj *key);
10  void updateLFU(robj *val) {
11      PORT_ULONG counter = LFUDecrAndReturn(val);
12      counter = LFULogIncr(counter);
13      val->lru = (LFUGetTimeInMinutes()<<8) | counter;
14  }
15  robj *lookupKey(redisDb *db, robj *key, int flags) {
16      dictEntry *de = dictFind(db->dict,key->ptr);
17      if (de) {
18          robj *val = dictGetVal(de);
19          if (server.rdb_child_pid == -1 &&
20              server.aof_child_pid == -1 &&
21              !(flags & LOOKUP_NOTOUCH))
22          {
23              if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
24                  updateLFU(val);
25              } else {
26                  val->lru = LRU_CLOCK();
27              }
28          }
29          return val;
30      } else {
31          return NULL;
32      }
33  }
34  robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
35      robj *val;
36      if (expireIfNeeded(db,key) == 1) {
37          if (server.masterhost == NULL) {
38              server.stat_keyspace_misses++;
39              return NULL;
40          }
41          if (server.current_client &&
42              server.current_client != server.master &&
43              server.current_client->cmd &&
44              server.current_client->cmd->flags & CMD_READONLY)
45          {
46              server.stat_keyspace_misses++;
47              return NULL;
48          }
49      }
50      val = lookupKey(db,key,flags);
51      if (val == NULL)
52          server.stat_keyspace_misses++;
53      else
54          server.stat_keyspace_hits++;
55      return val;
56  }
57  robj *lookupKeyRead(redisDb *db, robj *key) {
58      return lookupKeyReadWithFlags(db,key,LOOKUP_NONE);
59  }
60  robj *lookupKeyWrite(redisDb *db, robj *key) {
61      expireIfNeeded(db,key);
62      return lookupKey(db,key,LOOKUP_NONE);
63  }
64  robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {
65      robj *o = lookupKeyRead(c->db, key);
66      if (!o) addReply(c,reply);
67      return o;
68  }
69  robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {
70      robj *o = lookupKeyWrite(c->db, key);
71      if (!o) addReply(c,reply);
72      return o;
73  }
74  void dbAdd(redisDb *db, robj *key, robj *val) {
75      sds copy = sdsdup(key->ptr);
76      int retval = dictAdd(db->dict, copy, val);
77      serverAssertWithInfo(NULL,key,retval == DICT_OK);
78      if (val->type == OBJ_LIST ||
79          val->type == OBJ_ZSET)
80          signalKeyAsReady(db, key);
81      if (server.cluster_enabled) slotToKeyAdd(key);
82  }
83  void dbOverwrite(redisDb *db, robj *key, robj *val) {
84      dictEntry *de = dictFind(db->dict,key->ptr);
85      serverAssertWithInfo(NULL,key,de != NULL);
86      dictEntry auxentry = *de;
87      robj *old = dictGetVal(de);
88      if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
89          val->lru = old->lru;
90      }
91      dictSetVal(db->dict, de, val);
92      if (server.lazyfree_lazy_server_del) {
93          freeObjAsync(old);
94          dictSetVal(db->dict, &auxentry, NULL);
95      }
96      dictFreeVal(db->dict, &auxentry);
97  }
98  void setKey(redisDb *db, robj *key, robj *val) {
99      if (lookupKeyWrite(db,key) == NULL) {
100          dbAdd(db,key,val);
101      } else {
102          dbOverwrite(db,key,val);
103      }
104      incrRefCount(val);
105      removeExpire(db,key);
106      signalModifiedKey(db,key);
107  }
108  int dbExists(redisDb *db, robj *key) {
109      return dictFind(db->dict,key->ptr) != NULL;
110  }
111  robj *dbRandomKey(redisDb *db) {
112      dictEntry *de;
113      int maxtries = 100;
114      int allvolatile = dictSize(db->dict) == dictSize(db->expires);
115      while(1) {
116          sds key;
117          robj *keyobj;
118          de = dictGetRandomKey(db->dict);
119          if (de == NULL) return NULL;
120          key = dictGetKey(de);
121          keyobj = createStringObject(key,sdslen(key));
122          if (dictFind(db->expires,key)) {
123              if (allvolatile && server.masterhost && --maxtries == 0) {
124                  return keyobj;
125              }
126              if (expireIfNeeded(db,keyobj)) {
127                  decrRefCount(keyobj);
128                  continue; &bsol;* search for another key. This expired. */
129              }
130          }
131          return keyobj;
132      }
133  }
134  int dbSyncDelete(redisDb *db, robj *key) {
135      if (dictSize(db->expires) > 0) dictDelete(db->expires,key->ptr);
136      if (dictDelete(db->dict,key->ptr) == DICT_OK) {
137          if (server.cluster_enabled) slotToKeyDel(key);
138          return 1;
139      } else {
140          return 0;
141      }
142  }
143  int dbDelete(redisDb *db, robj *key) {
144      return server.lazyfree_lazy_server_del ? dbAsyncDelete(db,key) :
145                                               dbSyncDelete(db,key);
146  }
147  robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
148      serverAssert(o->type == OBJ_STRING);
149      if (o->refcount != 1 || o->encoding != OBJ_ENCODING_RAW) {
150          robj *decoded = getDecodedObject(o);
151          o = createRawStringObject(decoded->ptr, sdslen(decoded->ptr));
152          decrRefCount(decoded);
153          dbOverwrite(db,key,o);
154      }
155      return o;
156  }
157  PORT_LONGLONG emptyDb(int dbnum, int flags, void(callback)(void*)) {
158      int async = (flags & EMPTYDB_ASYNC);
159      PORT_LONGLONG removed = 0;
160      if (dbnum < -1 || dbnum >= server.dbnum) {
161          errno = EINVAL;
162          return -1;
163      }
164      int startdb, enddb;
165      if (dbnum == -1) {
166          startdb = 0;
167          enddb = server.dbnum-1;
168      } else {
169          startdb = enddb = dbnum;
170      }
171      for (int j = startdb; j <= enddb; j++) {
172          removed += dictSize(server.db[j].dict);
173          if (async) {
174              emptyDbAsync(&server.db[j]);
175          } else {
176              dictEmpty(server.db[j].dict,callback);
177              dictEmpty(server.db[j].expires,callback);
178          }
179      }
180      if (server.cluster_enabled) {
181          if (async) {
182              slotToKeyFlushAsync();
183          } else {
184              slotToKeyFlush();
185          }
186      }
187      if (dbnum == -1) flushSlaveKeysWithExpireList();
188      return removed;
189  }
190  int selectDb(client *c, int id) {
191      if (id < 0 || id >= server.dbnum)
192          return C_ERR;
193      c->db = &server.db[id];
194      return C_OK;
195  }
196  void signalModifiedKey(redisDb *db, robj *key) {
197      touchWatchedKey(db,key);
198  }
199  void signalFlushedDb(int dbid) {
200      touchWatchedKeysOnFlush(dbid);
201  }
202  int getFlushCommandFlags(client *c, int *flags) {
203      if (c->argc > 1) {
204          if (c->argc > 2 || strcasecmp(c->argv[1]->ptr,"async")) {
205              addReply(c,shared.syntaxerr);
206              return C_ERR;
207          }
208          *flags = EMPTYDB_ASYNC;
209      } else {
210          *flags = EMPTYDB_NO_FLAGS;
211      }
212      return C_OK;
213  }
214  void flushdbCommand(client *c) {
215      int flags;
216      if (getFlushCommandFlags(c,&flags) == C_ERR) return;
217      signalFlushedDb(c->db->id);
218      server.dirty += emptyDb(c->db->id,flags,NULL);
219      addReply(c,shared.ok);
220  }
221  void flushallCommand(client *c) {
222      int flags;
223      if (getFlushCommandFlags(c,&flags) == C_ERR) return;
224      signalFlushedDb(-1);
225      server.dirty += emptyDb(-1,flags,NULL);
226      addReply(c,shared.ok);
227      if (server.rdb_child_pid != -1) {
228          IF_WIN32(AbortForkOperation(), kill(server.rdb_child_pid,SIGUSR1));
229          rdbRemoveTempFile(server.rdb_child_pid);
230      }
231      if (server.saveparamslen > 0) {
232          int saved_dirty = server.dirty;
233          rdbSaveInfo rsi, *rsiptr;
234          rsiptr = rdbPopulateSaveInfo(&rsi);
235          rdbSave(server.rdb_filename,rsiptr);
236          server.dirty = saved_dirty;
237      }
238      server.dirty++;
239  }
240  void delGenericCommand(client *c, int lazy) {
241      int numdel = 0, j;
242      for (j = 1; j < c->argc; j++) {
243          expireIfNeeded(c->db,c->argv[j]);
244          int deleted  = lazy ? dbAsyncDelete(c->db,c->argv[j]) :
245                                dbSyncDelete(c->db,c->argv[j]);
246          if (deleted) {
247              signalModifiedKey(c->db,c->argv[j]);
248              notifyKeyspaceEvent(NOTIFY_GENERIC,
249                  "del",c->argv[j],c->db->id);
250              server.dirty++;
251              numdel++;
252          }
253      }
254      addReplyLongLong(c,numdel);
255  }
256  void delCommand(client *c) {
257      delGenericCommand(c,0);
258  }
259  void unlinkCommand(client *c) {
260      delGenericCommand(c,1);
261  }
262  void existsCommand(client *c) {
263      PORT_LONGLONG count = 0;
264      int j;
265      for (j = 1; j < c->argc; j++) {
266          if (lookupKeyRead(c->db,c->argv[j])) count++;
267      }
268      addReplyLongLong(c,count);
269  }
270  void selectCommand(client *c) {
271      PORT_LONG id;
272      if (getLongFromObjectOrReply(c, c->argv[1], &id,
273          "invalid DB index") != C_OK)
274          return;
275      if (server.cluster_enabled && id != 0) {
276          addReplyError(c,"SELECT is not allowed in cluster mode");
277          return;
278      }
279      if (selectDb(c,(int)id) == C_ERR) {                                     WIN_PORT_FIX &bsol;* cast (int) */
280          addReplyError(c,"DB index is out of range");
281      } else {
282          addReply(c,shared.ok);
283      }
284  }
285  void randomkeyCommand(client *c) {
286      robj *key;
287      if ((key = dbRandomKey(c->db)) == NULL) {
288          addReply(c,shared.nullbulk);
289          return;
290      }
291      addReplyBulk(c,key);
292      decrRefCount(key);
293  }
294  void keysCommand(client *c) {
295      dictIterator *di;
296      dictEntry *de;
297      sds pattern = c->argv[1]->ptr;
298      int plen = (int)sdslen(pattern), allkeys;
299      PORT_ULONG numkeys = 0;
300      void *replylen = addDeferredMultiBulkLength(c);
301      di = dictGetSafeIterator(c->db->dict);
302      allkeys = (pattern[0] == '*' && plen == 1);
303      while((de = dictNext(di)) != NULL) {
304          sds key = dictGetKey(de);
305          robj *keyobj;
306          if (allkeys || stringmatchlen(pattern,plen,key,sdslen(key),0)) {
307              keyobj = createStringObject(key,sdslen(key));
308              if (!keyIsExpired(c->db,keyobj)) {
309                  addReplyBulk(c,keyobj);
310                  numkeys++;
311              }
312              decrRefCount(keyobj);
313          }
314      }
315      dictReleaseIterator(di);
316      setDeferredMultiBulkLength(c,replylen,numkeys);
317  }
318  void scanCallback(void *privdata, const dictEntry *de) {
319      void **pd = (void**) privdata;
320      list *keys = pd[0];
321      robj *o = pd[1];
322      robj *key, *val = NULL;
323      if (o == NULL) {
324          sds sdskey = dictGetKey(de);
325          key = createStringObject(sdskey, sdslen(sdskey));
326      } else if (o->type == OBJ_SET) {
327          sds keysds = dictGetKey(de);
328          key = createStringObject(keysds,sdslen(keysds));
329      } else if (o->type == OBJ_HASH) {
330          sds sdskey = dictGetKey(de);
331          sds sdsval = dictGetVal(de);
332          key = createStringObject(sdskey,sdslen(sdskey));
333          val = createStringObject(sdsval,sdslen(sdsval));
334      } else if (o->type == OBJ_ZSET) {
335          sds sdskey = dictGetKey(de);
336          key = createStringObject(sdskey,sdslen(sdskey));
337          val = createStringObjectFromLongDouble(*(double*)dictGetVal(de),0);
338      } else {
339          serverPanic("Type not handled in SCAN callback.");
340      }
341      listAddNodeTail(keys, key);
342      if (val) listAddNodeTail(keys, val);
343  }
344  int parseScanCursorOrReply(client *c, robj *o, PORT_ULONG *cursor) {
345      char *eptr;
346      errno = 0;
347      *cursor = strtoul(o->ptr, &eptr, 10);
348      if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' || errno == ERANGE)
349      {
350          addReplyError(c, "invalid cursor");
351          return C_ERR;
352      }
353      return C_OK;
354  }
355  void scanGenericCommand(client *c, robj *o, PORT_ULONG cursor) {
356      int i, j;
357      list *keys = listCreate();
358      listNode *node, *nextnode;
359      PORT_LONG count = 10;
360      sds pat = NULL;
361      int patlen = 0, use_pattern = 0;
362      dict *ht;
363      serverAssert(o == NULL || o->type == OBJ_SET || o->type == OBJ_HASH ||
364                  o->type == OBJ_ZSET);
365      i = (o == NULL) ? 2 : 3; &bsol;* Skip the key argument if needed. */
366      while (i < c->argc) {
367          j = c->argc - i;
368          if (!strcasecmp(c->argv[i]->ptr, "count") && j >= 2) {
369              if (getLongFromObjectOrReply(c, c->argv[i+1], &count, NULL)
370                  != C_OK)
371              {
372                  goto cleanup;
373              }
374              if (count < 1) {
375                  addReply(c,shared.syntaxerr);
376                  goto cleanup;
377              }
378              i += 2;
379          } else if (!strcasecmp(c->argv[i]->ptr, "match") && j >= 2) {
380              pat = c->argv[i+1]->ptr;
381              patlen = (int)sdslen(pat);                                          WIN_PORT_FIX &bsol;* cast (int) */
382              use_pattern = !(pat[0] == '*' && patlen == 1);
383              i += 2;
384          } else {
385              addReply(c,shared.syntaxerr);
386              goto cleanup;
387          }
388      }
389      ht = NULL;
390      if (o == NULL) {
391          ht = c->db->dict;
392      } else if (o->type == OBJ_SET && o->encoding == OBJ_ENCODING_HT) {
393          ht = o->ptr;
394      } else if (o->type == OBJ_HASH && o->encoding == OBJ_ENCODING_HT) {
395          ht = o->ptr;
396          count *= 2; &bsol;* We return key / value for this type. */
397      } else if (o->type == OBJ_ZSET && o->encoding == OBJ_ENCODING_SKIPLIST) {
398          zset *zs = o->ptr;
399          ht = zs->dict;
400          count *= 2; &bsol;* We return key / value for this type. */
401      }
402      if (ht) {
403          void *privdata[2];
404          PORT_LONG maxiterations = count*10;
405          privdata[0] = keys;
406          privdata[1] = o;
407          do {
408              cursor = dictScan(ht, cursor, scanCallback, NULL, privdata);
409          } while (cursor &&
410                maxiterations-- &&
411                listLength(keys) < (PORT_ULONG)count);
412      } else if (o->type == OBJ_SET) {
413          int pos = 0;
414          int64_t ll;
415          while(intsetGet(o->ptr,pos++,&ll))
416              listAddNodeTail(keys,createStringObjectFromLongLong(ll));
417          cursor = 0;
418      } else if (o->type == OBJ_HASH || o->type == OBJ_ZSET) {
419          unsigned char *p = ziplistIndex(o->ptr,0);
420          unsigned char *vstr;
421          unsigned int vlen;
422          PORT_LONGLONG vll;
423          while(p) {
424              ziplistGet(p,&vstr,&vlen,&vll);
425              listAddNodeTail(keys,
426                  (vstr != NULL) ? createStringObject((char*)vstr,vlen) :
427                                   createStringObjectFromLongLong(vll));
428              p = ziplistNext(o->ptr,p);
429          }
430          cursor = 0;
431      } else {
432          serverPanic("Not handled encoding in SCAN.");
433      }
434      node = listFirst(keys);
435      while (node) {
436          robj *kobj = listNodeValue(node);
437          nextnode = listNextNode(node);
438          int filter = 0;
439          if (!filter && use_pattern) {
440              if (sdsEncodedObject(kobj)) {
441                  if (!stringmatchlen(pat, patlen, kobj->ptr, (int)sdslen(kobj->ptr), 0)) WIN_PORT_FIX &bsol;* cast (int) */
442                      filter = 1;
443              } else {
444                  char buf[LONG_STR_SIZE];
445                  int len;
446                  serverAssert(kobj->encoding == OBJ_ENCODING_INT);
447                  len = ll2string(buf,sizeof(buf),(PORT_LONG)kobj->ptr);
448                  if (!stringmatchlen(pat, patlen, buf, len, 0)) filter = 1;
449              }
450          }
451          if (!filter && o == NULL && expireIfNeeded(c->db, kobj)) filter = 1;
452          if (filter) {
453              decrRefCount(kobj);
454              listDelNode(keys, node);
455          }
456          if (o && (o->type == OBJ_ZSET || o->type == OBJ_HASH)) {
457              node = nextnode;
458              nextnode = listNextNode(node);
459              if (filter) {
460                  kobj = listNodeValue(node);
461                  decrRefCount(kobj);
462                  listDelNode(keys, node);
463              }
464          }
465          node = nextnode;
466      }
467      addReplyMultiBulkLen(c, 2);
468      addReplyBulkLongLong(c,cursor);
469      addReplyMultiBulkLen(c, listLength(keys));
470      while ((node = listFirst(keys)) != NULL) {
471          robj *kobj = listNodeValue(node);
472          addReplyBulk(c, kobj);
473          decrRefCount(kobj);
474          listDelNode(keys, node);
475      }
476  cleanup:
477      listSetFreeMethod(keys,decrRefCountVoid);
478      listRelease(keys);
479  }
480  void scanCommand(client *c) {
481      PORT_ULONG cursor;
482      if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) return;
483      scanGenericCommand(c,NULL,cursor);
484  }
485  void dbsizeCommand(client *c) {
486      addReplyLongLong(c,dictSize(c->db->dict));
487  }
488  void lastsaveCommand(client *c) {
489      addReplyLongLong(c,server.lastsave);
490  }
491  void typeCommand(client *c) {
492      robj *o;
493      char *type;
494      o = lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH);
495      if (o == NULL) {
496          type = "none";
497      } else {
498          switch(o->type) {
499          case OBJ_STRING: type = "string"; break;
500          case OBJ_LIST: type = "list"; break;
501          case OBJ_SET: type = "set"; break;
502          case OBJ_ZSET: type = "zset"; break;
503          case OBJ_HASH: type = "hash"; break;
504          case OBJ_STREAM: type = "stream"; break;
505          case OBJ_MODULE: {
506              moduleValue *mv = o->ptr;
507              type = mv->type->name;
508          }; break;
509          default: type = "unknown"; break;
510          }
511      }
512      addReplyStatus(c,type);
513  }
514  void shutdownCommand(client *c) {
515      int flags = 0;
516      if (c->argc > 2) {
517          addReply(c,shared.syntaxerr);
518          return;
519      } else if (c->argc == 2) {
520          if (!strcasecmp(c->argv[1]->ptr,"nosave")) {
521              flags |= SHUTDOWN_NOSAVE;
522          } else if (!strcasecmp(c->argv[1]->ptr,"save")) {
523              flags |= SHUTDOWN_SAVE;
524          } else {
525              addReply(c,shared.syntaxerr);
526              return;
527          }
528      }
529      if (prepareForShutdown(flags) == C_OK) exit(0);
530      addReplyError(c,"Errors trying to SHUTDOWN. Check logs.");
531  }
532  void renameGenericCommand(client *c, int nx) {
533      robj *o;
534      PORT_LONGLONG expire;
535      int samekey = 0;
536      if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) samekey = 1;
537      if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
538          return;
539      if (samekey) {
540          addReply(c,nx ? shared.czero : shared.ok);
541          return;
542      }
543      incrRefCount(o);
544      expire = getExpire(c->db,c->argv[1]);
545      if (lookupKeyWrite(c->db,c->argv[2]) != NULL) {
546          if (nx) {
547              decrRefCount(o);
548              addReply(c,shared.czero);
549              return;
550          }
551          dbDelete(c->db,c->argv[2]);
552      }
553      dbAdd(c->db,c->argv[2],o);
554      if (expire != -1) setExpire(c,c->db,c->argv[2],expire);
555      dbDelete(c->db,c->argv[1]);
556      signalModifiedKey(c->db,c->argv[1]);
557      signalModifiedKey(c->db,c->argv[2]);
558      notifyKeyspaceEvent(NOTIFY_GENERIC,"rename_from",
559          c->argv[1],c->db->id);
560      notifyKeyspaceEvent(NOTIFY_GENERIC,"rename_to",
561          c->argv[2],c->db->id);
562      server.dirty++;
563      addReply(c,nx ? shared.cone : shared.ok);
564  }
565  void renameCommand(client *c) {
566      renameGenericCommand(c,0);
567  }
568  void renamenxCommand(client *c) {
569      renameGenericCommand(c,1);
570  }
571  void moveCommand(client *c) {
572      robj *o;
573      redisDb *src, *dst;
574      int srcid;
575      PORT_LONGLONG dbid, expire;
576      if (server.cluster_enabled) {
577          addReplyError(c,"MOVE is not allowed in cluster mode");
578          return;
579      }
580      src = c->db;
581      srcid = c->db->id;
582      if (getLongLongFromObject(c->argv[2],&dbid) == C_ERR ||
583          dbid < INT_MIN || dbid > INT_MAX ||
584          selectDb(c,(int)dbid) == C_ERR)                                     WIN_PORT_FIX &bsol;* cast (int) */
585      {
586          addReply(c,shared.outofrangeerr);
587          return;
588      }
589      dst = c->db;
590      selectDb(c,srcid); &bsol;* Back to the source DB */
591      if (src == dst) {
592          addReply(c,shared.sameobjecterr);
593          return;
594      }
595      o = lookupKeyWrite(c->db,c->argv[1]);
596      if (!o) {
597          addReply(c,shared.czero);
598          return;
599      }
600      expire = getExpire(c->db,c->argv[1]);
601      if (lookupKeyWrite(dst,c->argv[1]) != NULL) {
602          addReply(c,shared.czero);
603          return;
604      }
605      dbAdd(dst,c->argv[1],o);
606      if (expire != -1) setExpire(c,dst,c->argv[1],expire);
607      incrRefCount(o);
608      dbDelete(src,c->argv[1]);
609      server.dirty++;
610      addReply(c,shared.cone);
611  }
612  void scanDatabaseForReadyLists(redisDb *db) {
613      dictEntry *de;
614      dictIterator *di = dictGetSafeIterator(db->blocking_keys);
615      while((de = dictNext(di)) != NULL) {
616          robj *key = dictGetKey(de);
617          robj *value = lookupKey(db,key,LOOKUP_NOTOUCH);
618          if (value && (value->type == OBJ_LIST ||
619                        value->type == OBJ_STREAM ||
620                        value->type == OBJ_ZSET))
621              signalKeyAsReady(db, key);
622      }
623      dictReleaseIterator(di);
624  }
625  int dbSwapDatabases(int id1, int id2) {
626      if (id1 < 0 || id1 >= server.dbnum ||
627          id2 < 0 || id2 >= server.dbnum) return C_ERR;
628      if (id1 == id2) return C_OK;
629      redisDb aux = server.db[id1];
630      redisDb *db1 = &server.db[id1], *db2 = &server.db[id2];
631      db1->dict = db2->dict;
632      db1->expires = db2->expires;
633      db1->avg_ttl = db2->avg_ttl;
634      db2->dict = aux.dict;
635      db2->expires = aux.expires;
636      db2->avg_ttl = aux.avg_ttl;
637      scanDatabaseForReadyLists(db1);
638      scanDatabaseForReadyLists(db2);
639      return C_OK;
640  }
641  void swapdbCommand(client *c) {
642      PORT_LONG id1, id2;
643      if (server.cluster_enabled) {
644          addReplyError(c,"SWAPDB is not allowed in cluster mode");
645          return;
646      }
647      if (getLongFromObjectOrReply(c, c->argv[1], &id1,
648          "invalid first DB index") != C_OK)
649          return;
650      if (getLongFromObjectOrReply(c, c->argv[2], &id2,
651          "invalid second DB index") != C_OK)
652          return;
653      if (dbSwapDatabases(id1,id2) == C_ERR) {
654          addReplyError(c,"DB index is out of range");
655          return;
656      } else {
657          server.dirty++;
658          addReply(c,shared.ok);
659      }
660  }
661  int removeExpire(redisDb *db, robj *key) {
662      serverAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
663      return dictDelete(db->expires,key->ptr) == DICT_OK;
664  }
665  void setExpire(client *c, redisDb *db, robj *key, PORT_LONGLONG when) {
666      dictEntry *kde, *de;
667      kde = dictFind(db->dict,key->ptr);
668      serverAssertWithInfo(NULL,key,kde != NULL);
669      de = dictAddOrFind(db->expires,dictGetKey(kde));
670      dictSetSignedIntegerVal(de,when);
671      int writable_slave = server.masterhost && server.repl_slave_ro == 0;
672      if (c && writable_slave && !(c->flags & CLIENT_MASTER))
673          rememberSlaveKeyWithExpire(db,key);
674  }
675  PORT_LONGLONG getExpire(redisDb *db, robj *key) {
676      dictEntry *de;
677      if (dictSize(db->expires) == 0 ||
678         (de = dictFind(db->expires,key->ptr)) == NULL) return -1;
679      serverAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
680      return dictGetSignedIntegerVal(de);
681  }
682  void propagateExpire(redisDb *db, robj *key, int lazy) {
683      robj *argv[2];
684      argv[0] = lazy ? shared.unlink : shared.del;
685      argv[1] = key;
686      incrRefCount(argv[0]);
687      incrRefCount(argv[1]);
688      if (server.aof_state != AOF_OFF)
689          feedAppendOnlyFile(server.delCommand,db->id,argv,2);
690      replicationFeedSlaves(server.slaves,db->id,argv,2);
691      decrRefCount(argv[0]);
692      decrRefCount(argv[1]);
693  }
694  int keyIsExpired(redisDb *db, robj *key) {
695      mstime_t when = getExpire(db,key);
696      mstime_t now;
697      if (when < 0) return 0; &bsol;* No expire for this key */
698      if (server.loading) return 0;
699      if (server.lua_caller) {
700          now = server.lua_time_start;
701      }
702      else if (server.fixed_time_expire > 0) {
703          now = server.mstime;
704      }
705      else {
706          now = mstime();
707      }
708      return now > when;
709  }
710  int expireIfNeeded(redisDb *db, robj *key) {
711      if (!keyIsExpired(db,key)) return 0;
712      if (server.masterhost != NULL) return 1;
713      server.stat_expiredkeys++;
714      propagateExpire(db,key,server.lazyfree_lazy_expire);
715      notifyKeyspaceEvent(NOTIFY_EXPIRED,
716          "expired",key,db->id);
717      return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :
718                                           dbSyncDelete(db,key);
719  }
720  int *getKeysUsingCommandTable(struct redisCommand *cmd,robj **argv, int argc, int *numkeys) {
721      int j, i = 0, last, *keys;
722      UNUSED(argv);
723      if (cmd->firstkey == 0) {
724          *numkeys = 0;
725          return NULL;
726      }
727      last = cmd->lastkey;
728      if (last < 0) last = argc+last;
729      keys = zmalloc(sizeof(int)*(((PORT_ULONG) last - cmd->firstkey)+1));  WIN_PORT_FIX &bsol;* cat (PORT_ULONG) */
730      for (j = cmd->firstkey; j <= last; j += cmd->keystep) {
731          if (j >= argc) {
732              if (cmd->flags & CMD_MODULE || cmd->arity < 0) {
733                  zfree(keys);
734                  *numkeys = 0;
735                  return NULL;
736              } else {
737                  serverPanic("Redis built-in command declared keys positions not matching the arity requirements.");
738              }
739          }
740          keys[i++] = j;
741      }
742      *numkeys = i;
743      return keys;
744  }
745  int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
746      if (cmd->flags & CMD_MODULE_GETKEYS) {
747          return moduleGetCommandKeysViaAPI(cmd,argv,argc,numkeys);
748      } else if (!(cmd->flags & CMD_MODULE) && cmd->getkeys_proc) {
749          return cmd->getkeys_proc(cmd,argv,argc,numkeys);
750      } else {
751          return getKeysUsingCommandTable(cmd,argv,argc,numkeys);
752      }
753  }
754  void getKeysFreeResult(int *result) {
755      zfree(result);
756  }
757  int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
758      int i, num, *keys;
759      UNUSED(cmd);
760      num = atoi(argv[2]->ptr);
761      if (num < 1 || num > (argc-3)) {
762          *numkeys = 0;
763          return NULL;
764      }
765      keys = zmalloc(sizeof(int)*((PORT_ULONG)num+1));  WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
766      for (i = 0; i < num; i++) keys[i] = 3+i;
767      keys[num] = 1;
768      *numkeys = num+1;  &bsol;* Total keys = {union,inter} keys + storage key */
769      return keys;
770  }
771  int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
772      int i, num, *keys;
773      UNUSED(cmd);
774      num = atoi(argv[2]->ptr);
775      if (num <= 0 || num > (argc-3)) {
776          *numkeys = 0;
777          return NULL;
778      }
779      keys = zmalloc(sizeof(int)*num);
780      *numkeys = num;
781      for (i = 0; i < num; i++) keys[i] = 3+i;
782      return keys;
783  }
784  int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
785      int i, j, num, *keys, found_store = 0;
786      UNUSED(cmd);
787      num = 0;
788      keys = zmalloc(sizeof(int)*2); &bsol;* Alloc 2 places for the worst case. */
789      keys[num++] = 1; &bsol;* <sort-key> is always present. */
790      struct {
791          char *name;
792          int skip;
793      } skiplist[] = {
794          {"limit", 2},
795          {"get", 1},
796          {"by", 1},
797          {NULL, 0} &bsol;* End of elements. */
798      };
799      for (i = 2; i < argc; i++) {
800          for (j = 0; skiplist[j].name != NULL; j++) {
801              if (!strcasecmp(argv[i]->ptr,skiplist[j].name)) {
802                  i += skiplist[j].skip;
803                  break;
804              } else if (!strcasecmp(argv[i]->ptr,"store") && i+1 < argc) {
805                  found_store = 1;
806                  keys[num] = i+1; &bsol;* <store-key> */
807                  break;
808              }
809          }
810      }
811      *numkeys = num + found_store;
812      return keys;
813  }
814  int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
815      int i, num, first, *keys;
816      UNUSED(cmd);
817      first = 3;
818      num = 1;
819      if (argc > 6) {
820          for (i = 6; i < argc; i++) {
821              if (!strcasecmp(argv[i]->ptr,"keys") &&
822                  sdslen(argv[3]->ptr) == 0)
823              {
824                  first = i+1;
825                  num = argc-first;
826                  break;
827              }
828          }
829      }
830      keys = zmalloc(sizeof(int)*num);
831      for (i = 0; i < num; i++) keys[i] = first+i;
832      *numkeys = num;
833      return keys;
834  }
835  int *georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
836      int i, num, *keys;
837      UNUSED(cmd);
838      int stored_key = -1;
839      for (i = 5; i < argc; i++) {
840          char *arg = argv[i]->ptr;
841          if ((!strcasecmp(arg, "store") || !strcasecmp(arg, "storedist")) && ((i+1) < argc)) {
842              stored_key = i+1;
843              i++;
844          }
845      }
846      num = 1 + (stored_key == -1 ? 0 : 1);
847      keys = zmalloc(sizeof(int) * num);
848      keys[0] = 1;
849      if(num > 1) {
850           keys[1] = stored_key;
851      }
852      *numkeys = num;
853      return keys;
854  }
855  int *xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
856      int i, num = 0, *keys;
857      UNUSED(cmd);
858      int streams_pos = -1;
859      for (i = 1; i < argc; i++) {
860          char *arg = argv[i]->ptr;
861          if (!strcasecmp(arg, "block")) {
862              i++; &bsol;* Skip option argument. */
863          } else if (!strcasecmp(arg, "count")) {
864              i++; &bsol;* Skip option argument. */
865          } else if (!strcasecmp(arg, "group")) {
866              i += 2; &bsol;* Skip option argument. */
867          } else if (!strcasecmp(arg, "noack")) {
868          } else if (!strcasecmp(arg, "streams")) {
869              streams_pos = i;
870              break;
871          } else {
872              break; &bsol;* Syntax error. */
873          }
874      }
875      if (streams_pos != -1) num = argc - streams_pos - 1;
876      if (streams_pos == -1 || num == 0 || num % 2 != 0) {
877          *numkeys = 0;
878          return NULL;
879      }
880      num /= 2; &bsol;* We have half the keys as there are arguments because
881                   there are also the IDs, one per key. */
882      keys = zmalloc(sizeof(int) * num);
883      for (i = streams_pos+1; i < argc-num; i++) keys[i-streams_pos-1] = i;
884      *numkeys = num;
885      return keys;
886  }
887  void slotToKeyUpdateKey(robj *key, int add) {
888      unsigned int hashslot = keyHashSlot(key->ptr,sdslen(key->ptr));
889      unsigned char buf[64];
890      unsigned char *indexed = buf;
891      size_t keylen = sdslen(key->ptr);
892      server.cluster->slots_keys_count[hashslot] += add ? 1 : -1;
893      if (keylen+2 > 64) indexed = zmalloc(keylen+2);
894      indexed[0] = (hashslot >> 8) & 0xff;
895      indexed[1] = hashslot & 0xff;
896      memcpy(indexed+2,key->ptr,keylen);
897      if (add) {
898          raxInsert(server.cluster->slots_to_keys,indexed,keylen+2,NULL,NULL);
899      } else {
900          raxRemove(server.cluster->slots_to_keys,indexed,keylen+2,NULL);
901      }
902      if (indexed != buf) zfree(indexed);
903  }
904  void slotToKeyAdd(robj *key) {
905      slotToKeyUpdateKey(key,1);
906  }
907  void slotToKeyDel(robj *key) {
908      slotToKeyUpdateKey(key,0);
909  }
910  void slotToKeyFlush(void) {
911      raxFree(server.cluster->slots_to_keys);
912      server.cluster->slots_to_keys = raxNew();
913      memset(server.cluster->slots_keys_count,0,
914             sizeof(server.cluster->slots_keys_count));
915  }
<span onclick='openModal()' class='match'>916  unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count) {
917      raxIterator iter;
918      int j = 0;
</span>919      unsigned char indexed[2];
920      indexed[0] = (hashslot >> 8) & 0xff;
921      indexed[1] = hashslot & 0xff;
922      raxStart(&iter,server.cluster->slots_to_keys);
923      raxSeek(&iter,">=",indexed,2);
924      while(count-- && raxNext(&iter)) {
925          if (iter.key[0] != indexed[0] || iter.key[1] != indexed[1]) break;
926          keys[j++] = createStringObject((char*)iter.key+2,iter.key_len-2);
927      }
928      raxStop(&iter);
929      return j;
930  }
931  unsigned int delKeysInSlot(unsigned int hashslot) {
932      raxIterator iter;
933      int j = 0;
934      unsigned char indexed[2];
935      indexed[0] = (hashslot >> 8) & 0xff;
936      indexed[1] = hashslot & 0xff;
937      raxStart(&iter,server.cluster->slots_to_keys);
938      while(server.cluster->slots_keys_count[hashslot]) {
939          raxSeek(&iter,">=",indexed,2);
940          raxNext(&iter);
941          robj *key = createStringObject((char*)iter.key+2,iter.key_len-2);
942          dbDelete(&server.db[0],key);
943          decrRefCount(key);
944          j++;
945      }
946      raxStop(&iter);
947      return j;
948  }
949  unsigned int countKeysInSlot(unsigned int hashslot) {
950      return server.cluster->slots_keys_count[hashslot];
951  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sober128_stream_memory.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-db.c</div>
                <div class="column column_space"><pre><code>5                             const unsigned char *datain, unsigned long datalen,
6                             unsigned char *dataout)
7  {
8     sober128_state st;
9     int err;
</pre></code></div>
                <div class="column column_space"><pre><code>916  unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count) {
917      raxIterator iter;
918      int j = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    