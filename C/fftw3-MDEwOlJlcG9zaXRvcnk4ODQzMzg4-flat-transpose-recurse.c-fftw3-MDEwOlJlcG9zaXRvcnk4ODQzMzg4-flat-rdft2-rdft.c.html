
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.10204081632653%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-transpose-recurse.c</h3>
            <pre><code>1  #include "mpi-transpose.h"
2  #include <string.h>
3  typedef struct {
4       solver super;
5       int (*radix)(int np);
6       const char *nam;
7       int preserve_input; &bsol;* preserve input even if DESTROY_INPUT was passed */
8  } S;
9  typedef struct {
10       plan_mpi_transpose super;
11       plan *cld1, *cldtr, *cldtm;
12       int preserve_input;
13       int r; &bsol;* "radix" */
14       const char *nam;
<span onclick='openModal()' class='match'>15  } P;
16  static void apply(const plan *ego_, R *I, R *O)
17  {
18       const P *ego = (const P *) ego_;
19       plan_rdft *cld1, *cldtr, *cldtm;
20       cld1 = (plan_rdft *) ego->cld1;
</span>21       if (cld1) cld1->apply((plan *) cld1, I, O);
22       if (ego->preserve_input) I = O;
23       cldtr = (plan_rdft *) ego->cldtr;
24       if (cldtr) cldtr->apply((plan *) cldtr, O, I);
25       cldtm = (plan_rdft *) ego->cldtm;
26       if (cldtm) cldtm->apply((plan *) cldtm, I, O);
27  }
28  static int radix_sqrt(int np)
29  {
30       int r;
31       for (r = (int) (X(isqrt)(np)); np % r != 0; ++r)
32  	  ;
33       return r;
34  }
35  static int radix_first(int np)
36  {
37       int r = (int) (X(first_divisor)(np));
38       return (r >= (int) (X(isqrt)(np)) ? 0 : r);
39  }
40  static INT transpose_space(INT nx, INT ny, INT block, INT tblock, int pe)
41  {
42       return X(imax)(XM(block)(nx, block, pe) * ny,
43  		    nx * XM(block)(ny, tblock, pe));
44  }
45  static int enough_space(INT nx, INT ny, INT block, INT tblock,
46  			int r, int n_pes)
47  {
48       int pe;
49       int m = n_pes / r;
50       for (pe = 0; pe < n_pes; ++pe) {
51  	  INT space = transpose_space(nx, ny, block, tblock, pe);
52  	  INT b1 = XM(block)(nx, r * block, pe / r);
53  	  INT b2 = XM(block)(ny, m * tblock, pe % r);
54  	  if (transpose_space(b1, ny, block, m*tblock, pe % r) > space
55  	      || transpose_space(nx, b2, r*block, tblock, pe / r) > space)
56  	       return 0;
57       }
58       return 1;
59  }
60  #define SMALL_MESSAGE 2048
61  static int applicable(const S *ego, const problem *p_,
62  		      const planner *plnr, int *r)
63  {
64       const problem_mpi_transpose *p = (const problem_mpi_transpose *) p_;
65       int n_pes;
66       MPI_Comm_size(p->comm, &n_pes);
67       return (1
68  	     && p->tblock * n_pes == p->ny
69  	     && (!ego->preserve_input || (!NO_DESTROY_INPUTP(plnr)
70                                            && p->I != p->O))
71  	     && (*r = ego->radix(n_pes)) && *r < n_pes && *r > 1
72  	     && enough_space(p->nx, p->ny, p->block, p->tblock, *r, n_pes)
73  	     && (!CONSERVE_MEMORYP(plnr) || *r > 8
74  		 || !X(toobig)((p->nx * (p->ny / n_pes) * p->vn) / *r))
75  	     && (!NO_SLOWP(plnr) || 
76  		 (p->nx * (p->ny / n_pes) * p->vn) / n_pes <= SMALL_MESSAGE)
77  	     && ONLY_TRANSPOSEDP(p->flags)
78  	  );
79  }
80  static void awake(plan *ego_, enum wakefulness wakefulness)
81  {
82       P *ego = (P *) ego_;
83       X(plan_awake)(ego->cld1, wakefulness);
84       X(plan_awake)(ego->cldtr, wakefulness);
85       X(plan_awake)(ego->cldtm, wakefulness);
86  }
87  static void destroy(plan *ego_)
88  {
89       P *ego = (P *) ego_;
90       X(plan_destroy_internal)(ego->cldtm);
91       X(plan_destroy_internal)(ego->cldtr);
92       X(plan_destroy_internal)(ego->cld1);
93  }
94  static void print(const plan *ego_, printer *p)
95  {
96       const P *ego = (const P *) ego_;
97       p->print(p, "(mpi-transpose-recurse/%s/%d%s%(%p%)%(%p%)%(%p%))",
98  	      ego->nam, ego->r, ego->preserve_input==2 ?"/p":"",
99  	      ego->cld1, ego->cldtr, ego->cldtm);
100  }
101  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
102  {
103       const S *ego = (const S *) ego_;
104       const problem_mpi_transpose *p;
105       P *pln;
106       plan *cld1 = 0, *cldtr = 0, *cldtm = 0;
107       R *I, *O;
108       int me, np, r, m;
109       INT b;
110       MPI_Comm comm2;
111       static const plan_adt padt = {
112            XM(transpose_solve), awake, print, destroy
113       };
114       UNUSED(ego);
115       if (!applicable(ego, p_, plnr, &r))
116            return (plan *) 0;
117       p = (const problem_mpi_transpose *) p_;
118       MPI_Comm_size(p->comm, &np);
119       MPI_Comm_rank(p->comm, &me);
120       m = np / r;
121       A(r * m == np);
122       I = p->I; O = p->O;
123       b = XM(block)(p->nx, p->block, me);
124       A(p->tblock * np == p->ny); &bsol;* this is currently required for cld1 */
125       if (p->flags & TRANSPOSED_IN) { 
126  	  INT vn = p->vn * b * p->tblock;
127  	  cld1 = X(mkplan_f_d)(plnr,
128                                 X(mkproblem_rdft_0_d)(X(mktensor_3d)
129  						     (m, r*vn, vn,
130  						      r, vn, m*vn,
131  						      vn, 1, 1),
132                                                       I, O),
133                                 0, 0, NO_SLOW);
134       }
135       else if (I != O) { &bsol;* combine cld1 with TRANSPOSED_IN permutation */
136  	  INT vn = p->vn;
137  	  INT bt = p->tblock;
138  	  cld1 = X(mkplan_f_d)(plnr,
139                                 X(mkproblem_rdft_0_d)(X(mktensor_5d)
140  						     (b, m*r*bt*vn, vn,
141  						      m, r*bt*vn, bt*b*vn,
142  						      r, bt*vn, m*bt*b*vn,
143  						      bt, vn, b*vn,
144  						      vn, 1, 1),
145                                                       I, O),
146                                 0, 0, NO_SLOW);
147       }
148       else { &bsol;* TRANSPOSED_IN permutation must be separate for in-place */
149  	  INT vn = p->vn * p->tblock;
150  	  cld1 = X(mkplan_f_d)(plnr,
151                                 X(mkproblem_rdft_0_d)(X(mktensor_4d)
152  						     (m, r*vn, vn,
153  						      r, vn, m*vn,
154  						      vn, 1, 1,
155  						      b, np*vn, np*vn),
156                                                       I, O),
157                                 0, 0, NO_SLOW);
158       }
159       if (XM(any_true)(!cld1, p->comm)) goto nada;
160       if (ego->preserve_input || NO_DESTROY_INPUTP(plnr)) I = O;
161       b = XM(block)(p->nx, r * p->block, me / r);
162       MPI_Comm_split(p->comm, me / r, me, &comm2);
163       if (b)
164  	  cldtr = X(mkplan_d)(plnr, XM(mkproblem_transpose)
165  			      (b, p->ny, p->vn,
166  			       O, I, p->block, m * p->tblock, comm2, 
167  			       p->I != p->O
168  			       ? TRANSPOSED_IN : (p->flags & TRANSPOSED_IN)));
169       MPI_Comm_free(&comm2);
170       if (XM(any_true)(b && !cldtr, p->comm)) goto nada;
171       b = XM(block)(p->ny, m * p->tblock, me % r);
172       MPI_Comm_split(p->comm, me % r, me, &comm2);
173       if (b)
174  	  cldtm = X(mkplan_d)(plnr, XM(mkproblem_transpose)
175  			      (p->nx, b, p->vn,
176  			       I, O, r * p->block, p->tblock, comm2, 
177  			       TRANSPOSED_IN | (p->flags & TRANSPOSED_OUT)));
178       MPI_Comm_free(&comm2);
179       if (XM(any_true)(b && !cldtm, p->comm)) goto nada;
180       pln = MKPLAN_MPI_TRANSPOSE(P, &padt, apply);
181       pln->cld1 = cld1;
182       pln->cldtr = cldtr;
183       pln->cldtm = cldtm;
184       pln->preserve_input = ego->preserve_input ? 2 : NO_DESTROY_INPUTP(plnr);
185       pln->r = r;
186       pln->nam = ego->nam;
187       pln->super.super.ops = cld1->ops;
188       if (cldtr) X(ops_add2)(&cldtr->ops, &pln->super.super.ops);
189       if (cldtm) X(ops_add2)(&cldtm->ops, &pln->super.super.ops);
190       return &(pln->super.super);
191   nada:
192       X(plan_destroy_internal)(cldtm);
193       X(plan_destroy_internal)(cldtr);
194       X(plan_destroy_internal)(cld1);
195       return (plan *) 0;
196  }
197  static solver *mksolver(int preserve_input,
198  			int (*radix)(int np), const char *nam)
199  {
200       static const solver_adt sadt = { PROBLEM_MPI_TRANSPOSE, mkplan, 0 };
201       S *slv = MKSOLVER(S, &sadt);
202       slv->preserve_input = preserve_input;
203       slv->radix = radix;
204       slv->nam = nam;
205       return &(slv->super);
206  }
207  void XM(transpose_recurse_register)(planner *p)
208  {
209       int preserve_input;
210       for (preserve_input = 0; preserve_input <= 1; ++preserve_input) {
211  	  REGISTER_SOLVER(p, mksolver(preserve_input, radix_sqrt, "sqrt"));
212  	  REGISTER_SOLVER(p, mksolver(preserve_input, radix_first, "first"));
213       }
214  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft2 super;
7       plan *cld, *cldrest;
8       INT n, vl, nbuf, bufdist;
9       INT cs, ivs, ovs;
10  } P;
11  static void hc2c(INT n, R *r, R *rio, R *iio, INT os)
12  {
13       INT i;
14       rio[0] = r[0];
15       iio[0] = 0;
16       for (i = 1; i + i < n; ++i) {
17  	  rio[i * os] = r[i];
18  	  iio[i * os] = r[n - i];
19       }
20       if (i + i == n) {	&bsol;* store the Nyquist frequency */
21  	  rio[i * os] = r[i];
22  	  iio[i * os] = K(0.0);
23       }
24  }
25  static void c2hc(INT n, R *rio, R *iio, INT is, R *r)
26  {
27       INT i;
28       r[0] = rio[0];
29       for (i = 1; i + i < n; ++i) {
30  	  r[i] = rio[i * is];
31  	  r[n - i] = iio[i * is];
32       }
33       if (i + i == n)		&bsol;* store the Nyquist frequency */
34  	  r[i] = rio[i * is];
<span onclick='openModal()' class='match'>35  }
36  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
37  {
38       const P *ego = (const P *) ego_;
39       plan_rdft *cld = (plan_rdft *) ego->cld;
</span>40       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
41       INT n = ego->n;
42       INT ivs = ego->ivs, ovs = ego->ovs, os = ego->cs;
43       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
44       plan_rdft2 *cldrest;
45       for (i = nbuf; i <= vl; i += nbuf) {
46            cld->apply((plan *) cld, r0, bufs);
47  	  r0 += ivs * nbuf; r1 += ivs * nbuf;
48  	  for (j = 0; j < nbuf; ++j, cr += ovs, ci += ovs)
49  	       hc2c(n, bufs + j*bufdist, cr, ci, os);
50       }
51       X(ifree)(bufs);
52       cldrest = (plan_rdft2 *) ego->cldrest;
53       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
54  }
55  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
56  {
57       const P *ego = (const P *) ego_;
58       plan_rdft *cld = (plan_rdft *) ego->cld;
59       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
60       INT n = ego->n;
61       INT ivs = ego->ivs, ovs = ego->ovs, is = ego->cs;
62       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
63       plan_rdft2 *cldrest;
64       for (i = nbuf; i <= vl; i += nbuf) {
65  	  for (j = 0; j < nbuf; ++j, cr += ivs, ci += ivs)
66  	       c2hc(n, cr, ci, is, bufs + j*bufdist);
67            cld->apply((plan *) cld, bufs, r0);
68  	  r0 += ovs * nbuf; r1 += ovs * nbuf;
69       }
70       X(ifree)(bufs);
71       cldrest = (plan_rdft2 *) ego->cldrest;
72       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
73  }
74  static void awake(plan *ego_, enum wakefulness wakefulness)
75  {
76       P *ego = (P *) ego_;
77       X(plan_awake)(ego->cld, wakefulness);
78       X(plan_awake)(ego->cldrest, wakefulness);
79  }
80  static void destroy(plan *ego_)
81  {
82       P *ego = (P *) ego_;
83       X(plan_destroy_internal)(ego->cldrest);
84       X(plan_destroy_internal)(ego->cld);
85  }
86  static void print(const plan *ego_, printer *p)
87  {
88       const P *ego = (const P *) ego_;
89       p->print(p, "(rdft2-rdft-%s-%D%v/%D-%D%(%p%)%(%p%))",
90  	      ego->super.apply == apply_r2hc ? "r2hc" : "hc2r",
91                ego->n, ego->nbuf,
92                ego->vl, ego->bufdist % ego->n,
93                ego->cld, ego->cldrest);
94  }
95  static INT min_nbuf(const problem_rdft2 *p, INT n, INT vl)
96  {
97       INT is, os, ivs, ovs;
98       if (p->r0 != p->cr)
99  	  return 1;
100       if (X(rdft2_inplace_strides(p, RNK_MINFTY)))
101  	  return 1;
102       A(p->vecsz->rnk == 1); &bsol;*  rank 0 and MINFTY are inplace */
103       X(rdft2_strides)(p->kind, p->sz->dims, &is, &os);
104       X(rdft2_strides)(p->kind, p->vecsz->dims, &ivs, &ovs);
105       if (n * X(iabs)(is) <= X(iabs)(ivs)
106  	 && (n/2 + 1) * X(iabs)(os) <= X(iabs)(ovs)
107  	 && ( ((p->cr - p->ci) <= X(iabs)(os)) || 
108  	      ((p->ci - p->cr) <= X(iabs)(os)) )
109  	 && ivs > 0 && ovs > 0) {
110  	  INT vsmin = X(imin)(ivs, ovs);
111  	  INT vsmax = X(imax)(ivs, ovs);
112  	  return(((vsmax - vsmin) * vl + vsmin - 1) / vsmin);
113       }
114       return vl; &bsol;* punt: just buffer the whole vector */
115  }
116  static int applicable0(const problem *p_, const S *ego, const planner *plnr)
117  {
118       const problem_rdft2 *p = (const problem_rdft2 *) p_;
119       UNUSED(ego);
120       return(1
121  	    && p->vecsz->rnk <= 1
122  	    && p->sz->rnk == 1
123  	    && (p->kind == R2HC || p->kind == HC2R)
124  	    && (2 * (p->r1 - p->r0) ==
125  		(((p->kind == R2HC) ? p->sz->dims[0].is : p->sz->dims[0].os)))
126  	    && !(X(toobig)(p->sz->dims[0].n) && CONSERVE_MEMORYP(plnr))
127  	  );
128  }
129  static int applicable(const problem *p_, const S *ego, const planner *plnr)
130  {
131       const problem_rdft2 *p;
132       if (NO_BUFFERINGP(plnr)) return 0;
133       if (!applicable0(p_, ego, plnr)) return 0;
134       p = (const problem_rdft2 *) p_;
135       if (NO_UGLYP(plnr)) {
136  	  if (p->r0 != p->cr) return 0;
137  	  if (X(toobig)(p->sz->dims[0].n)) return 0;
138       }
139       return 1;
140  }
141  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
142  {
143       const S *ego = (const S *) ego_;
144       P *pln;
145       plan *cld = (plan *) 0;
146       plan *cldrest = (plan *) 0;
147       const problem_rdft2 *p = (const problem_rdft2 *) p_;
148       R *bufs = (R *) 0;
149       INT nbuf = 0, bufdist, n, vl;
150       INT ivs, ovs, rs, id, od;
151       static const plan_adt padt = {
152  	  X(rdft2_solve), awake, print, destroy
153       };
154       if (!applicable(p_, ego, plnr))
155            goto nada;
156       n = p->sz->dims[0].n;
157       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
158       nbuf = X(imax)(X(nbuf)(n, vl, 0), min_nbuf(p, n, vl));
159       bufdist = X(bufdist)(n, vl);
160       A(nbuf > 0);
161       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
162       id = ivs * (nbuf * (vl / nbuf));
163       od = ovs * (nbuf * (vl / nbuf));
164       if (p->kind == R2HC) {
165  	  cld = X(mkplan_f_d)(
166  	       plnr,
167  	       X(mkproblem_rdft_d)(
168  		    X(mktensor_1d)(n, p->sz->dims[0].is/2, 1),
169  		    X(mktensor_1d)(nbuf, ivs, bufdist),
170  		    TAINT(p->r0, ivs * nbuf), bufs, &p->kind),
171  	       0, 0, (p->r0 == p->cr) ? NO_DESTROY_INPUT : 0);
172  	  if (!cld) goto nada;
173  	  X(ifree)(bufs); bufs = 0;
174  	  cldrest = X(mkplan_d)(plnr, 
175  				X(mkproblem_rdft2_d)(
176  				     X(tensor_copy)(p->sz),
177  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
178  				     p->r0 + id, p->r1 + id, 
179  				     p->cr + od, p->ci + od,
180  				     p->kind));
181  	  if (!cldrest) goto nada;
182  	  pln = MKPLAN_RDFT2(P, &padt, apply_r2hc);
183       } else {
184  	  A(p->kind == HC2R);
185  	  cld = X(mkplan_f_d)(
186  	       plnr,
187  	       X(mkproblem_rdft_d)(
188  		    X(mktensor_1d)(n, 1, p->sz->dims[0].os/2),
189  		    X(mktensor_1d)(nbuf, bufdist, ovs),
190  		    bufs, TAINT(p->r0, ovs * nbuf), &p->kind),
191  	       0, 0, NO_DESTROY_INPUT); &bsol;* always ok to destroy bufs */
192  	  if (!cld) goto nada;
193  	  X(ifree)(bufs); bufs = 0;
194  	  cldrest = X(mkplan_d)(plnr, 
195  				X(mkproblem_rdft2_d)(
196  				     X(tensor_copy)(p->sz),
197  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
198  				     p->r0 + od, p->r1 + od, 
199  				     p->cr + id, p->ci + id,
200  				     p->kind));
201  	  if (!cldrest) goto nada;
202  	  pln = MKPLAN_RDFT2(P, &padt, apply_hc2r);
203       }
204       pln->cld = cld;
205       pln->cldrest = cldrest;
206       pln->n = n;
207       pln->vl = vl;
208       pln->ivs = ivs;
209       pln->ovs = ovs;
210       X(rdft2_strides)(p->kind, &p->sz->dims[0], &rs, &pln->cs);
211       pln->nbuf = nbuf;
212       pln->bufdist = bufdist;
213       X(ops_madd)(vl / nbuf, &cld->ops, &cldrest->ops,
214  		 &pln->super.super.ops);
215       pln->super.super.ops.other += (p->kind == R2HC ? (n + 2) : n) * vl;
216       return &(pln->super.super);
217   nada:
218       X(ifree0)(bufs);
219       X(plan_destroy_internal)(cldrest);
220       X(plan_destroy_internal)(cld);
221       return (plan *) 0;
222  }
223  static solver *mksolver(void)
224  {
225       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
226       S *slv = MKSOLVER(S, &sadt);
227       return &(slv->super);
228  }
229  void X(rdft2_rdft_register)(planner *p)
230  {
231       REGISTER_SOLVER(p, mksolver());
232  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-transpose-recurse.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</div>
                </div>
                <div class="column column_space"><pre><code>15  } P;
16  static void apply(const plan *ego_, R *I, R *O)
17  {
18       const P *ego = (const P *) ego_;
19       plan_rdft *cld1, *cldtr, *cldtm;
20       cld1 = (plan_rdft *) ego->cld1;
</pre></code></div>
                <div class="column column_space"><pre><code>35  }
36  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
37  {
38       const P *ego = (const P *) ego_;
39       plan_rdft *cld = (plan_rdft *) ego->cld;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    