
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.435483870967742%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-sslutils.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #ifdef HAVE_OPENSSL
5  #include <stdlib.h>
6  #include "portability.h"
7  #include "sslutils.h"
8  static const char *ssl_keyfile = "";   
9  static const char *ssl_certfile = "";  
10  static const char *ssl_rootfile = "";  
11  static SSL_CTX *ctx;
12  void ssl_set_certfile(const char *certfile)
13  {
14  	ssl_certfile = certfile;
15  }
16  void ssl_set_keyfile(const char *keyfile)
17  {
18  	ssl_keyfile = keyfile;
19  }
20  int ssl_init_once(int is_server, int enable_compression, char *errbuf, size_t errbuflen)
21  {
22  	static int inited = 0;
23  	if (inited) return 0;
24  	SSL_library_init();
25  	SSL_load_error_strings();
26  	OpenSSL_add_ssl_algorithms();
27  	if (enable_compression)
28  		SSL_COMP_get_compression_methods();
29  	SSL_METHOD const *meth =
30  	    is_server ? SSLv23_server_method() : SSLv23_client_method();
31  	ctx = SSL_CTX_new(meth);
32  	if (! ctx)
33  	{
34  		snprintf(errbuf, errbuflen, "Cannot get a new SSL context: %s", ERR_error_string(ERR_get_error(), NULL));
35  		goto die;
36  	}
37  	SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);
38  	if (is_server)
39  	{
40  		char const *certfile = ssl_certfile[0] ? ssl_certfile : "cert.pem";
41  		if (1 != SSL_CTX_use_certificate_file(ctx, certfile, SSL_FILETYPE_PEM))
42  		{
43  			snprintf(errbuf, errbuflen, "Cannot read certificate file %s: %s", certfile, ERR_error_string(ERR_get_error(), NULL));
44  			goto die;
45  		}
46  		char const *keyfile = ssl_keyfile[0] ? ssl_keyfile : "key.pem";
47  		if (1 != SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM))
48  		{
49  			snprintf(errbuf, errbuflen, "Cannot read private key file %s: %s", keyfile, ERR_error_string(ERR_get_error(), NULL));
50  			goto die;
51  		}
52  	}
53  	else
54  	{
55  		if (ssl_rootfile[0])
56  		{
57  			if (! SSL_CTX_load_verify_locations(ctx, ssl_rootfile, 0))
58  			{
59  				snprintf(errbuf, errbuflen, "Cannot read CA list from %s", ssl_rootfile);
60  				goto die;
61  			}
62  		}
63  		else
64  		{
65  			SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);
66  		}
67  	}
68  #if 0
69  	if (! RAND_load_file(RANDOM, 1024*1024))
70  	{
71  		snprintf(errbuf, errbuflen, "Cannot init random");
72  		goto die;
73  	}
74  	if (is_server)
75  	{
76  		SSL_CTX_set_session_id_context(ctx, (void *)&s_server_session_id_context, sizeof(s_server_session_id_context));
77  	}
78  #endif
79  	inited = 1;
80  	return 0;
81  die:
82  	return -1;
83  }
84  SSL *ssl_promotion(int is_server, SOCKET s, char *errbuf, size_t errbuflen)
85  {
86  	if (ssl_init_once(is_server, 1, errbuf, errbuflen) < 0) {
87  		return NULL;
88  	}
89  	SSL *ssl = SSL_new(ctx); 
90  	SSL_set_fd(ssl, (int)s);
91  	if (is_server) {
92  		if (SSL_accept(ssl) <= 0) {
93  			snprintf(errbuf, errbuflen, "SSL_accept(): %s",
94  					ERR_error_string(ERR_get_error(), NULL));
95  			return NULL;
96  		}
97  	} else {
98  		if (SSL_connect(ssl) <= 0) {
99  			snprintf(errbuf, errbuflen, "SSL_connect(): %s",
100  					ERR_error_string(ERR_get_error(), NULL));
101  			return NULL;
102  		}
103  	}
104  	return ssl;
105  }
106  void ssl_finish(SSL *ssl)
107  {
108  	SSL_shutdown(ssl);
109  	SSL_free(ssl);
110  }
111  int ssl_send(SSL *ssl, char const *buffer, int size, char *errbuf, size_t errbuflen)
112  {
113  	int status = SSL_write(ssl, buffer, size);
114  	if (status > 0)
115  	{
116  		return 0;
117  	}
118  	else
119  	{
120  		int ssl_err = SSL_get_error(ssl, status); 
121  		if (ssl_err == SSL_ERROR_ZERO_RETURN)
122  		{
123  			return -2;
124  		}
125  		else if (ssl_err == SSL_ERROR_SYSCALL)
126  		{
127  #ifndef _WIN32
128  			if (errno == ECONNRESET || errno == EPIPE) return -2;
129  #endif
130  		}
131  		snprintf(errbuf, errbuflen, "SSL_write(): %s",
132  		    ERR_error_string(ERR_get_error(), NULL));
133  		return -1;
134  	}
135  }
136  int ssl_recv(SSL *ssl, char *buffer, int size, char *errbuf, size_t errbuflen)
137  {
138  	int status = SSL_read(ssl, buffer, size);
139  	if (status <= 0)
140  	{
141  		int ssl_err = SSL_get_error(ssl, status);
<span onclick='openModal()' class='match'>142  		if (ssl_err == SSL_ERROR_ZERO_RETURN)
143  		{
144  			return 0;
145  		}
146  		else if (ssl_err == SSL_ERROR_SYSCALL)
147  		{
148  			return -1;
149  		}
150  		else
151  		{
</span>152  			snprintf(errbuf, errbuflen, "SSL_read(): %s",
153  			    ERR_error_string(ERR_get_error(), NULL));
154  			return -2;
155  		}
156  	}
157  	else
158  	{
159  		return status;
160  	}
161  }
162  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-buffer.c</h3>
            <pre><code>1  #define _GNU_SOURCE
2  #include "fuse_config.h"
3  #include "fuse_i.h"
4  #include "fuse_lowlevel.h"
5  #include <string.h>
6  #include <unistd.h>
7  #include <errno.h>
8  #include <assert.h>
9  size_t fuse_buf_size(const struct fuse_bufvec *bufv)
10  {
11  	size_t i;
12  	size_t size = 0;
13  	for (i = 0; i < bufv->count; i++) {
14  		if (bufv->buf[i].size == SIZE_MAX)
15  			size = SIZE_MAX;
16  		else
17  			size += bufv->buf[i].size;
18  	}
19  	return size;
20  }
21  static size_t min_size(size_t s1, size_t s2)
22  {
23  	return s1 < s2 ? s1 : s2;
24  }
25  static ssize_t fuse_buf_write(const struct fuse_buf *dst, size_t dst_off,
26  			      const struct fuse_buf *src, size_t src_off,
27  			      size_t len)
28  {
29  	ssize_t res = 0;
30  	size_t copied = 0;
31  	while (len) {
32  		if (dst->flags & FUSE_BUF_FD_SEEK) {
33  			res = pwrite(dst->fd, (char *)src->mem + src_off, len,
34  				     dst->pos + dst_off);
35  		} else {
36  			res = write(dst->fd, (char *)src->mem + src_off, len);
37  		}
38  		if (res == -1) {
39  			if (!copied)
40  				return -errno;
41  			break;
42  		}
43  		if (res == 0)
44  			break;
45  		copied += res;
46  		if (!(dst->flags & FUSE_BUF_FD_RETRY))
47  			break;
48  		src_off += res;
49  		dst_off += res;
50  		len -= res;
51  	}
52  	return copied;
53  }
54  static ssize_t fuse_buf_read(const struct fuse_buf *dst, size_t dst_off,
55  			     const struct fuse_buf *src, size_t src_off,
56  			     size_t len)
57  {
58  	ssize_t res = 0;
59  	size_t copied = 0;
60  	while (len) {
61  		if (src->flags & FUSE_BUF_FD_SEEK) {
62  			res = pread(src->fd, (char *)dst->mem + dst_off, len,
63  				     src->pos + src_off);
64  		} else {
65  			res = read(src->fd, (char *)dst->mem + dst_off, len);
66  		}
67  		if (res == -1) {
68  			if (!copied)
69  				return -errno;
70  			break;
71  		}
72  		if (res == 0)
73  			break;
74  		copied += res;
75  		if (!(src->flags & FUSE_BUF_FD_RETRY))
76  			break;
77  		dst_off += res;
78  		src_off += res;
79  		len -= res;
80  	}
81  	return copied;
82  }
83  static ssize_t fuse_buf_fd_to_fd(const struct fuse_buf *dst, size_t dst_off,
84  				 const struct fuse_buf *src, size_t src_off,
85  				 size_t len)
86  {
87  	char buf[4096];
88  	struct fuse_buf tmp = {
89  		.size = sizeof(buf),
90  		.flags = 0,
91  	};
92  	ssize_t res;
93  	size_t copied = 0;
94  	tmp.mem = buf;
95  	while (len) {
96  		size_t this_len = min_size(tmp.size, len);
97  		size_t read_len;
98  		res = fuse_buf_read(&tmp, 0, src, src_off, this_len);
99  		if (res < 0) {
100  			if (!copied)
101  				return res;
102  			break;
103  		}
104  		if (res == 0)
105  			break;
106  		read_len = res;
107  		res = fuse_buf_write(dst, dst_off, &tmp, 0, read_len);
108  		if (res < 0) {
109  			if (!copied)
110  				return res;
111  			break;
112  		}
113  		if (res == 0)
114  			break;
115  		copied += res;
116  		if (res < this_len)
117  			break;
118  		dst_off += res;
119  		src_off += res;
120  		len -= res;
121  	}
122  	return copied;
123  }
124  #ifdef HAVE_SPLICE
125  static ssize_t fuse_buf_splice(const struct fuse_buf *dst, size_t dst_off,
126  			       const struct fuse_buf *src, size_t src_off,
127  			       size_t len, enum fuse_buf_copy_flags flags)
128  {
129  	int splice_flags = 0;
130  	off_t *srcpos = NULL;
131  	off_t *dstpos = NULL;
132  	off_t srcpos_val;
133  	off_t dstpos_val;
134  	ssize_t res;
135  	size_t copied = 0;
136  	if (flags & FUSE_BUF_SPLICE_MOVE)
137  		splice_flags |= SPLICE_F_MOVE;
138  	if (flags & FUSE_BUF_SPLICE_NONBLOCK)
139  		splice_flags |= SPLICE_F_NONBLOCK;
140  	if (src->flags & FUSE_BUF_FD_SEEK) {
141  		srcpos_val = src->pos + src_off;
142  		srcpos = &srcpos_val;
143  	}
144  	if (dst->flags & FUSE_BUF_FD_SEEK) {
145  		dstpos_val = dst->pos + dst_off;
146  		dstpos = &dstpos_val;
147  	}
148  	while (len) {
149  		res = splice(src->fd, srcpos, dst->fd, dstpos, len,
150  			     splice_flags);
151  		if (res == -1) {
152  			if (copied)
153  				break;
154  			if (errno != EINVAL || (flags & FUSE_BUF_FORCE_SPLICE))
155  				return -errno;
156  			return fuse_buf_fd_to_fd(dst, dst_off, src, src_off,
157  						 len);
158  		}
159  		if (res == 0)
160  			break;
161  		copied += res;
162  		if (!(src->flags & FUSE_BUF_FD_RETRY) &&
163  		    !(dst->flags & FUSE_BUF_FD_RETRY)) {
164  			break;
165  		}
166  		len -= res;
167  	}
168  	return copied;
169  }
170  #else
171  static ssize_t fuse_buf_splice(const struct fuse_buf *dst, size_t dst_off,
172  			       const struct fuse_buf *src, size_t src_off,
173  			       size_t len, enum fuse_buf_copy_flags flags)
174  {
175  	(void) flags;
176  	return fuse_buf_fd_to_fd(dst, dst_off, src, src_off, len);
177  }
178  #endif
179  static ssize_t fuse_buf_copy_one(const struct fuse_buf *dst, size_t dst_off,
180  				 const struct fuse_buf *src, size_t src_off,
181  				 size_t len, enum fuse_buf_copy_flags flags)
182  {
183  	int src_is_fd = src->flags & FUSE_BUF_IS_FD;
184  	int dst_is_fd = dst->flags & FUSE_BUF_IS_FD;
185  	if (!src_is_fd && !dst_is_fd) {
186  		char *dstmem = (char *)dst->mem + dst_off;
187  		char *srcmem = (char *)src->mem + src_off;
188  		if (dstmem != srcmem) {
189  			if (dstmem + len <= srcmem || srcmem + len <= dstmem)
190  				memcpy(dstmem, srcmem, len);
191  			else
192  				memmove(dstmem, srcmem, len);
193  		}
194  		return len;
195  	} else if (!src_is_fd) {
196  		return fuse_buf_write(dst, dst_off, src, src_off, len);
<span onclick='openModal()' class='match'>197  	} else if (!dst_is_fd) {
198  		return fuse_buf_read(dst, dst_off, src, src_off, len);
199  	} else if (flags & FUSE_BUF_NO_SPLICE) {
200  		return fuse_buf_fd_to_fd(dst, dst_off, src, src_off, len);
201  	} else {
</span>202  		return fuse_buf_splice(dst, dst_off, src, src_off, len, flags);
203  	}
204  }
205  static const struct fuse_buf *fuse_bufvec_current(struct fuse_bufvec *bufv)
206  {
207  	if (bufv->idx < bufv->count)
208  		return &bufv->buf[bufv->idx];
209  	else
210  		return NULL;
211  }
212  static int fuse_bufvec_advance(struct fuse_bufvec *bufv, size_t len)
213  {
214  	const struct fuse_buf *buf = fuse_bufvec_current(bufv);
215  	if (!buf)
216  		return 0;
217  	bufv->off += len;
218  	assert(bufv->off <= buf->size);
219  	if (bufv->off == buf->size) {
220  		assert(bufv->idx < bufv->count);
221  		bufv->idx++;
222  		if (bufv->idx == bufv->count)
223  			return 0;
224  		bufv->off = 0;
225  	}
226  	return 1;
227  }
228  ssize_t fuse_buf_copy(struct fuse_bufvec *dstv, struct fuse_bufvec *srcv,
229  		      enum fuse_buf_copy_flags flags)
230  {
231  	size_t copied = 0;
232  	if (dstv == srcv)
233  		return fuse_buf_size(dstv);
234  	for (;;) {
235  		const struct fuse_buf *src = fuse_bufvec_current(srcv);
236  		const struct fuse_buf *dst = fuse_bufvec_current(dstv);
237  		size_t src_len;
238  		size_t dst_len;
239  		size_t len;
240  		ssize_t res;
241  		if (src == NULL || dst == NULL)
242  			break;
243  		src_len = src->size - srcv->off;
244  		dst_len = dst->size - dstv->off;
245  		len = min_size(src_len, dst_len);
246  		res = fuse_buf_copy_one(dst, dstv->off, src, srcv->off, len, flags);
247  		if (res < 0) {
248  			if (!copied)
249  				return res;
250  			break;
251  		}
252  		copied += res;
253  		if (!fuse_bufvec_advance(srcv, res) ||
254  		    !fuse_bufvec_advance(dstv, res))
255  			break;
256  		if (res < len)
257  			break;
258  	}
259  	return copied;
260  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-sslutils.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-buffer.c</div>
                </div>
                <div class="column column_space"><pre><code>142  		if (ssl_err == SSL_ERROR_ZERO_RETURN)
143  		{
144  			return 0;
145  		}
146  		else if (ssl_err == SSL_ERROR_SYSCALL)
147  		{
148  			return -1;
149  		}
150  		else
151  		{
</pre></code></div>
                <div class="column column_space"><pre><code>197  	} else if (!dst_is_fd) {
198  		return fuse_buf_read(dst, dst_off, src, src_off, len);
199  	} else if (flags & FUSE_BUF_NO_SPLICE) {
200  		return fuse_buf_fd_to_fd(dst, dst_off, src, src_off, len);
201  	} else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    