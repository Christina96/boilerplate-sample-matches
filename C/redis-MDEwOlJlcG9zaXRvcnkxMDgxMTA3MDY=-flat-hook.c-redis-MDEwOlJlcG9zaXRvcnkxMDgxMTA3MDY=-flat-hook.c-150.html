
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hook.c</h3>
            <pre><code>1  #include &quot;test/jemalloc_test.h&quot;
2  #include &quot;jemalloc/internal/hook.h&quot;
3  static void *arg_extra;
4  static int arg_type;
5  static void *arg_result;
6  static void *arg_address;
7  static size_t arg_old_usize;
8  static size_t arg_new_usize;
9  static uintptr_t arg_result_raw;
10  static uintptr_t arg_args_raw[4];
11  static int call_count = 0;
12  static void
13  reset_args() {
14  	arg_extra = NULL;
15  	arg_type = 12345;
16  	arg_result = NULL;
17  	arg_address = NULL;
18  	arg_old_usize = 0;
19  	arg_new_usize = 0;
20  	arg_result_raw = 0;
21  	memset(arg_args_raw, 77, sizeof(arg_args_raw));
22  }
23  static void
24  alloc_free_size(size_t sz) {
25  	void *ptr = mallocx(1, 0);
26  	free(ptr);
27  	ptr = mallocx(1, 0);
28  	free(ptr);
29  	ptr = mallocx(1, MALLOCX_TCACHE_NONE);
30  	dallocx(ptr, MALLOCX_TCACHE_NONE);
31  }
32  static void
33  be_reentrant() {
34  	alloc_free_size(1);
35  	alloc_free_size(1024);
36  	alloc_free_size(64 * 1024);
37  	alloc_free_size(256 * 1024);
38  	alloc_free_size(1024 * 1024);
39  	void *ptr = mallocx(129, 0);
40  	ptr = rallocx(ptr, 130, 0);
41  	free(ptr);
42  	ptr = mallocx(2 * 1024 * 1024, 0);
43  	free(ptr);
44  	ptr = mallocx(1 * 1024 * 1024, 0);
45  	ptr = rallocx(ptr, 2 * 1024 * 1024, 0);
46  	free(ptr);
47  	ptr = mallocx(1, 0);
48  	ptr = rallocx(ptr, 1000, 0);
49  	free(ptr);
50  }
51  static void
52  set_args_raw(uintptr_t *args_raw, int nargs) {
53  	memcpy(arg_args_raw, args_raw, sizeof(uintptr_t) * nargs);
54  }
55  static void
56  assert_args_raw(uintptr_t *args_raw_expected, int nargs) {
57  	int cmp = memcmp(args_raw_expected, arg_args_raw,
58  	    sizeof(uintptr_t) * nargs);
59  	assert_d_eq(cmp, 0, &quot;Raw args mismatch&quot;);
60  }
61  static void
62  reset() {
63  	call_count = 0;
64  	reset_args();
65  }
66  static void
67  test_alloc_hook(void *extra, hook_alloc_t type, void *result,
68      uintptr_t result_raw, uintptr_t args_raw[3]) {
69  	call_count++;
70  	arg_extra = extra;
71  	arg_type = (int)type;
72  	arg_result = result;
73  	arg_result_raw = result_raw;
74  	set_args_raw(args_raw, 3);
75  	be_reentrant();
76  }
77  static void
78  test_dalloc_hook(void *extra, hook_dalloc_t type, void *address,
79      uintptr_t args_raw[3]) {
80  	call_count++;
81  	arg_extra = extra;
82  	arg_type = (int)type;
83  	arg_address = address;
84  	set_args_raw(args_raw, 3);
85  	be_reentrant();
86  }
87  static void
88  test_expand_hook(void *extra, hook_expand_t type, void *address,
89      size_t old_usize, size_t new_usize, uintptr_t result_raw,
90      uintptr_t args_raw[4]) {
91  	call_count++;
92  	arg_extra = extra;
93  	arg_type = (int)type;
94  	arg_address = address;
95  	arg_old_usize = old_usize;
96  	arg_new_usize = new_usize;
97  	arg_result_raw = result_raw;
98  	set_args_raw(args_raw, 4);
99  	be_reentrant();
100  }
101  TEST_BEGIN(test_hooks_basic) {
102  	hooks_t hooks = {
103  		&amp;test_alloc_hook, &amp;test_dalloc_hook, &amp;test_expand_hook,
104  		(void *)111};
105  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
106  	uintptr_t args_raw[4] = {10, 20, 30, 40};
107  	reset_args();
108  	hook_invoke_alloc(hook_alloc_posix_memalign, (void *)222, 333,
109  	    args_raw);
110  	assert_ptr_eq(arg_extra, (void *)111, &quot;Passed wrong user pointer&quot;);
111  	assert_d_eq((int)hook_alloc_posix_memalign, arg_type,
112  	    &quot;Passed wrong alloc type&quot;);
113  	assert_ptr_eq((void *)222, arg_result, &quot;Passed wrong result address&quot;);
<span onclick='openModal()' class='match'>114  	assert_u64_eq(333, arg_result_raw, &quot;Passed wrong result&quot;);
115  	assert_args_raw(args_raw, 3);
116  	reset_args();
</span>117  	hook_invoke_dalloc(hook_dalloc_sdallocx, (void *)222, args_raw);
118  	assert_d_eq((int)hook_dalloc_sdallocx, arg_type,
119  	    &quot;Passed wrong dalloc type&quot;);
120  	assert_ptr_eq((void *)111, arg_extra, &quot;Passed wrong user pointer&quot;);
121  	assert_ptr_eq((void *)222, arg_address, &quot;Passed wrong address&quot;);
122  	assert_args_raw(args_raw, 3);
123  	reset_args();
124  	hook_invoke_expand(hook_expand_xallocx, (void *)222, 333, 444, 555,
125  	    args_raw);
126  	assert_d_eq((int)hook_expand_xallocx, arg_type,
127  	    &quot;Passed wrong expand type&quot;);
128  	assert_ptr_eq((void *)111, arg_extra, &quot;Passed wrong user pointer&quot;);
129  	assert_ptr_eq((void *)222, arg_address, &quot;Passed wrong address&quot;);
130  	assert_zu_eq(333, arg_old_usize, &quot;Passed wrong old usize&quot;);
131  	assert_zu_eq(444, arg_new_usize, &quot;Passed wrong new usize&quot;);
132  	assert_zu_eq(555, arg_result_raw, &quot;Passed wrong result&quot;);
133  	assert_args_raw(args_raw, 4);
134  	hook_remove(TSDN_NULL, handle);
135  }
136  TEST_END
137  TEST_BEGIN(test_hooks_null) {
138  	hooks_t hooks1 = {NULL, NULL, NULL, NULL};
139  	hooks_t hooks2 = {&amp;test_alloc_hook, NULL, NULL, NULL};
140  	hooks_t hooks3 = {NULL, &amp;test_dalloc_hook, NULL, NULL};
141  	hooks_t hooks4 = {NULL, NULL, &amp;test_expand_hook, NULL};
142  	void *handle1 = hook_install(TSDN_NULL, &amp;hooks1);
143  	void *handle2 = hook_install(TSDN_NULL, &amp;hooks2);
144  	void *handle3 = hook_install(TSDN_NULL, &amp;hooks3);
145  	void *handle4 = hook_install(TSDN_NULL, &amp;hooks4);
146  	assert_ptr_ne(handle1, NULL, &quot;Hook installation failed&quot;);
147  	assert_ptr_ne(handle2, NULL, &quot;Hook installation failed&quot;);
148  	assert_ptr_ne(handle3, NULL, &quot;Hook installation failed&quot;);
149  	assert_ptr_ne(handle4, NULL, &quot;Hook installation failed&quot;);
150  	uintptr_t args_raw[4] = {10, 20, 30, 40};
151  	call_count = 0;
152  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, args_raw);
153  	assert_d_eq(call_count, 1, &quot;Called wrong number of times&quot;);
154  	call_count = 0;
155  	hook_invoke_dalloc(hook_dalloc_free, NULL, args_raw);
156  	assert_d_eq(call_count, 1, &quot;Called wrong number of times&quot;);
157  	call_count = 0;
158  	hook_invoke_expand(hook_expand_realloc, NULL, 0, 0, 0, args_raw);
159  	assert_d_eq(call_count, 1, &quot;Called wrong number of times&quot;);
160  	hook_remove(TSDN_NULL, handle1);
161  	hook_remove(TSDN_NULL, handle2);
162  	hook_remove(TSDN_NULL, handle3);
163  	hook_remove(TSDN_NULL, handle4);
164  }
165  TEST_END
166  TEST_BEGIN(test_hooks_remove) {
167  	hooks_t hooks = {&amp;test_alloc_hook, NULL, NULL, NULL};
168  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
169  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
170  	call_count = 0;
171  	uintptr_t args_raw[4] = {10, 20, 30, 40};
172  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, args_raw);
173  	assert_d_eq(call_count, 1, &quot;Hook not invoked&quot;);
174  	call_count = 0;
175  	hook_remove(TSDN_NULL, handle);
176  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, NULL);
177  	assert_d_eq(call_count, 0, &quot;Hook invoked after removal&quot;);
178  }
179  TEST_END
180  TEST_BEGIN(test_hooks_alloc_simple) {
181  	hooks_t hooks = {&amp;test_alloc_hook, NULL, NULL, (void *)123};
182  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
183  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
184  	volatile int err;
185  	void *volatile ptr;
186  	reset();
187  	ptr = malloc(1);
188  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
189  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
190  	assert_d_eq(arg_type, (int)hook_alloc_malloc, &quot;Wrong hook type&quot;);
191  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
192  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
193  	    &quot;Wrong raw result&quot;);
194  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], &quot;Wrong argument&quot;);
195  	free(ptr);
196  	reset();
197  	err = posix_memalign((void **)&amp;ptr, 1024, 1);
198  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
199  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
200  	assert_d_eq(arg_type, (int)hook_alloc_posix_memalign,
201  	    &quot;Wrong hook type&quot;);
202  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
203  	assert_u64_eq((uintptr_t)err, (uintptr_t)arg_result_raw,
204  	    &quot;Wrong raw result&quot;);
205  	assert_u64_eq((uintptr_t)&amp;ptr, arg_args_raw[0], &quot;Wrong argument&quot;);
206  	assert_u64_eq((uintptr_t)1024, arg_args_raw[1], &quot;Wrong argument&quot;);
207  	assert_u64_eq((uintptr_t)1, arg_args_raw[2], &quot;Wrong argument&quot;);
208  	free(ptr);
209  	reset();
210  	ptr = aligned_alloc(1024, 1);
211  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
212  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
213  	assert_d_eq(arg_type, (int)hook_alloc_aligned_alloc,
214  	    &quot;Wrong hook type&quot;);
215  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
216  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
217  	    &quot;Wrong raw result&quot;);
218  	assert_u64_eq((uintptr_t)1024, arg_args_raw[0], &quot;Wrong argument&quot;);
219  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], &quot;Wrong argument&quot;);
220  	free(ptr);
221  	reset();
222  	ptr = calloc(11, 13);
223  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
224  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
225  	assert_d_eq(arg_type, (int)hook_alloc_calloc, &quot;Wrong hook type&quot;);
226  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
227  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
228  	    &quot;Wrong raw result&quot;);
229  	assert_u64_eq((uintptr_t)11, arg_args_raw[0], &quot;Wrong argument&quot;);
230  	assert_u64_eq((uintptr_t)13, arg_args_raw[1], &quot;Wrong argument&quot;);
231  	free(ptr);
232  #ifdef JEMALLOC_OVERRIDE_MEMALIGN
233  	reset();
234  	ptr = memalign(1024, 1);
235  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
236  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
237  	assert_d_eq(arg_type, (int)hook_alloc_memalign, &quot;Wrong hook type&quot;);
238  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
239  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
240  	    &quot;Wrong raw result&quot;);
241  	assert_u64_eq((uintptr_t)1024, arg_args_raw[0], &quot;Wrong argument&quot;);
242  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], &quot;Wrong argument&quot;);
243  	free(ptr);
244  #endif &amp;bsol;* JEMALLOC_OVERRIDE_MEMALIGN */
245  #ifdef JEMALLOC_OVERRIDE_VALLOC
246  	reset();
247  	ptr = valloc(1);
248  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
249  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
250  	assert_d_eq(arg_type, (int)hook_alloc_valloc, &quot;Wrong hook type&quot;);
251  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
252  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
253  	    &quot;Wrong raw result&quot;);
254  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], &quot;Wrong argument&quot;);
255  	free(ptr);
256  #endif &amp;bsol;* JEMALLOC_OVERRIDE_VALLOC */
257  	reset();
258  	ptr = mallocx(1, MALLOCX_LG_ALIGN(10));
259  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
260  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
261  	assert_d_eq(arg_type, (int)hook_alloc_mallocx, &quot;Wrong hook type&quot;);
262  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
263  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
264  	    &quot;Wrong raw result&quot;);
265  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], &quot;Wrong argument&quot;);
266  	assert_u64_eq((uintptr_t)MALLOCX_LG_ALIGN(10), arg_args_raw[1],
267  	    &quot;Wrong flags&quot;);
268  	free(ptr);
269  	hook_remove(TSDN_NULL, handle);
270  }
271  TEST_END
272  TEST_BEGIN(test_hooks_dalloc_simple) {
273  	hooks_t hooks = {NULL, &amp;test_dalloc_hook, NULL, (void *)123};
274  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
275  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
276  	void *volatile ptr;
277  	reset();
278  	ptr = malloc(1);
279  	free(ptr);
280  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
281  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
282  	assert_d_eq(arg_type, (int)hook_dalloc_free, &quot;Wrong hook type&quot;);
283  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer freed&quot;);
284  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong raw arg&quot;);
285  	reset();
286  	ptr = malloc(1);
287  	dallocx(ptr, MALLOCX_TCACHE_NONE);
288  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
289  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
290  	assert_d_eq(arg_type, (int)hook_dalloc_dallocx, &quot;Wrong hook type&quot;);
291  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer freed&quot;);
292  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong raw arg&quot;);
293  	assert_u64_eq((uintptr_t)MALLOCX_TCACHE_NONE, arg_args_raw[1],
294  	    &quot;Wrong raw arg&quot;);
295  	reset();
296  	ptr = malloc(1);
297  	sdallocx(ptr, 1, MALLOCX_TCACHE_NONE);
298  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
299  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
300  	assert_d_eq(arg_type, (int)hook_dalloc_sdallocx, &quot;Wrong hook type&quot;);
301  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer freed&quot;);
302  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong raw arg&quot;);
303  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], &quot;Wrong raw arg&quot;);
304  	assert_u64_eq((uintptr_t)MALLOCX_TCACHE_NONE, arg_args_raw[2],
305  	    &quot;Wrong raw arg&quot;);
306  	hook_remove(TSDN_NULL, handle);
307  }
308  TEST_END
309  TEST_BEGIN(test_hooks_expand_simple) {
310  	hooks_t hooks = {NULL, NULL, &amp;test_expand_hook, (void *)123};
311  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
312  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
313  	void *volatile ptr;
314  	reset();
315  	ptr = malloc(1);
316  	size_t new_usize = xallocx(ptr, 100, 200, MALLOCX_TCACHE_NONE);
317  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
318  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
319  	assert_d_eq(arg_type, (int)hook_expand_xallocx, &quot;Wrong hook type&quot;);
320  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer expanded&quot;);
321  	assert_u64_eq(arg_old_usize, nallocx(1, 0), &quot;Wrong old usize&quot;);
322  	assert_u64_eq(arg_new_usize, sallocx(ptr, 0), &quot;Wrong new usize&quot;);
323  	assert_u64_eq(new_usize, arg_result_raw, &quot;Wrong result&quot;);
324  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong arg&quot;);
325  	assert_u64_eq(100, arg_args_raw[1], &quot;Wrong arg&quot;);
326  	assert_u64_eq(200, arg_args_raw[2], &quot;Wrong arg&quot;);
327  	assert_u64_eq(MALLOCX_TCACHE_NONE, arg_args_raw[3], &quot;Wrong arg&quot;);
328  	hook_remove(TSDN_NULL, handle);
329  }
330  TEST_END
331  TEST_BEGIN(test_hooks_realloc_as_malloc_or_free) {
332  	hooks_t hooks = {&amp;test_alloc_hook, &amp;test_dalloc_hook,
333  		&amp;test_expand_hook, (void *)123};
334  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
335  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
336  	void *volatile ptr;
337  	reset();
338  	ptr = realloc(NULL, 1);
339  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
340  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
341  	assert_d_eq(arg_type, (int)hook_alloc_realloc, &quot;Wrong hook type&quot;);
342  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
343  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
344  	    &quot;Wrong raw result&quot;);
345  	assert_u64_eq((uintptr_t)NULL, arg_args_raw[0], &quot;Wrong argument&quot;);
346  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], &quot;Wrong argument&quot;);
347  	free(ptr);
348  	ptr = malloc(1);
349  	reset();
350  	realloc(ptr, 0);
351  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
352  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
353  	assert_d_eq(arg_type, (int)hook_dalloc_realloc, &quot;Wrong hook type&quot;);
354  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer freed&quot;);
355  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong raw arg&quot;);
356  	assert_u64_eq((uintptr_t)0, arg_args_raw[1], &quot;Wrong raw arg&quot;);
357  	reset();
358  	ptr = realloc(NULL, 0);
359  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
360  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
361  	assert_d_eq(arg_type, (int)hook_alloc_realloc, &quot;Wrong hook type&quot;);
362  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
363  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
364  	    &quot;Wrong raw result&quot;);
365  	assert_u64_eq((uintptr_t)NULL, arg_args_raw[0], &quot;Wrong argument&quot;);
366  	assert_u64_eq((uintptr_t)0, arg_args_raw[1], &quot;Wrong argument&quot;);
367  	free(ptr);
368  	hook_remove(TSDN_NULL, handle);
369  }
370  TEST_END
371  static void
372  do_realloc_test(void *(*ralloc)(void *, size_t, int), int flags,
373      int expand_type, int dalloc_type) {
374  	hooks_t hooks = {&amp;test_alloc_hook, &amp;test_dalloc_hook,
375  		&amp;test_expand_hook, (void *)123};
376  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
377  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
378  	void *volatile ptr;
379  	void *volatile ptr2;
380  	ptr = malloc(129);
381  	reset();
382  	ptr2 = ralloc(ptr, 130, flags);
383  	assert_ptr_eq(ptr, ptr2, &quot;Small realloc moved&quot;);
384  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
385  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
386  	assert_d_eq(arg_type, expand_type, &quot;Wrong hook type&quot;);
387  	assert_ptr_eq(ptr, arg_address, &quot;Wrong address&quot;);
388  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
389  	    &quot;Wrong raw result&quot;);
390  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong argument&quot;);
391  	assert_u64_eq((uintptr_t)130, arg_args_raw[1], &quot;Wrong argument&quot;);
392  	free(ptr);
393  	ptr = malloc(2 * 1024 * 1024);
394  	free(ptr);
395  	ptr2 = malloc(1 * 1024 * 1024);
396  	reset();
397  	ptr = ralloc(ptr2, 2 * 1024 * 1024, flags);
398  	if (ptr == ptr2) {
399  		assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
400  		assert_d_eq(arg_type, expand_type, &quot;Wrong hook type&quot;);
401  	} else {
402  		assert_d_eq(call_count, 2, &quot;Wrong hooks called&quot;);
403  		assert_ptr_eq(ptr, arg_result, &quot;Wrong address&quot;);
404  		assert_d_eq(arg_type, dalloc_type, &quot;Wrong hook type&quot;);
405  	}
406  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
407  	assert_ptr_eq(ptr2, arg_address, &quot;Wrong address&quot;);
408  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
409  	    &quot;Wrong raw result&quot;);
410  	assert_u64_eq((uintptr_t)ptr2, arg_args_raw[0], &quot;Wrong argument&quot;);
411  	assert_u64_eq((uintptr_t)2 * 1024 * 1024, arg_args_raw[1],
412  	    &quot;Wrong argument&quot;);
413  	free(ptr);
414  	ptr = malloc(8);
415  	reset();
416  	ptr2 = ralloc(ptr, 128, flags);
417  	assert_ptr_ne(ptr, ptr2, &quot;Small realloc didn&#x27;t move&quot;);
418  	assert_d_eq(call_count, 2, &quot;Hook not called&quot;);
419  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
420  	assert_d_eq(arg_type, dalloc_type, &quot;Wrong hook type&quot;);
421  	assert_ptr_eq(ptr, arg_address, &quot;Wrong address&quot;);
422  	assert_ptr_eq(ptr2, arg_result, &quot;Wrong address&quot;);
423  	assert_u64_eq((uintptr_t)ptr2, (uintptr_t)arg_result_raw,
424  	    &quot;Wrong raw result&quot;);
425  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong argument&quot;);
426  	assert_u64_eq((uintptr_t)128, arg_args_raw[1], &quot;Wrong argument&quot;);
427  	free(ptr2);
428  	ptr = malloc(1);
429  	reset();
430  	ptr2 = ralloc(ptr, 2 * 1024 * 1024, flags);
431  	assert_ptr_ne(ptr, ptr2, &quot;Large realloc didn&#x27;t move&quot;);
432  	assert_d_eq(call_count, 2, &quot;Hook not called&quot;);
433  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
434  	assert_d_eq(arg_type, dalloc_type, &quot;Wrong hook type&quot;);
435  	assert_ptr_eq(ptr, arg_address, &quot;Wrong address&quot;);
436  	assert_ptr_eq(ptr2, arg_result, &quot;Wrong address&quot;);
437  	assert_u64_eq((uintptr_t)ptr2, (uintptr_t)arg_result_raw,
438  	    &quot;Wrong raw result&quot;);
439  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong argument&quot;);
440  	assert_u64_eq((uintptr_t)2 * 1024 * 1024, arg_args_raw[1],
441  	    &quot;Wrong argument&quot;);
442  	free(ptr2);
443  	hook_remove(TSDN_NULL, handle);
444  }
445  static void *
446  realloc_wrapper(void *ptr, size_t size, UNUSED int flags) {
447  	return realloc(ptr, size);
448  }
449  TEST_BEGIN(test_hooks_realloc) {
450  	do_realloc_test(&amp;realloc_wrapper, 0, hook_expand_realloc,
451  	    hook_dalloc_realloc);
452  }
453  TEST_END
454  TEST_BEGIN(test_hooks_rallocx) {
455  	do_realloc_test(&amp;rallocx, MALLOCX_TCACHE_NONE, hook_expand_rallocx,
456  	    hook_dalloc_rallocx);
457  }
458  TEST_END
459  int
460  main(void) {
461  	return test_no_reentrancy(
462  	    test_hooks_basic,
463  	    test_hooks_null,
464  	    test_hooks_remove,
465  	    test_hooks_alloc_simple,
466  	    test_hooks_dalloc_simple,
467  	    test_hooks_expand_simple,
468  	    test_hooks_realloc_as_malloc_or_free,
469  	    test_hooks_realloc,
470  	    test_hooks_rallocx);
471  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hook.c</h3>
            <pre><code>1  #include &quot;test/jemalloc_test.h&quot;
2  #include &quot;jemalloc/internal/hook.h&quot;
3  static void *arg_extra;
4  static int arg_type;
5  static void *arg_result;
6  static void *arg_address;
7  static size_t arg_old_usize;
8  static size_t arg_new_usize;
9  static uintptr_t arg_result_raw;
10  static uintptr_t arg_args_raw[4];
11  static int call_count = 0;
12  static void
13  reset_args() {
14  	arg_extra = NULL;
15  	arg_type = 12345;
16  	arg_result = NULL;
17  	arg_address = NULL;
18  	arg_old_usize = 0;
19  	arg_new_usize = 0;
20  	arg_result_raw = 0;
21  	memset(arg_args_raw, 77, sizeof(arg_args_raw));
22  }
23  static void
24  alloc_free_size(size_t sz) {
25  	void *ptr = mallocx(1, 0);
26  	free(ptr);
27  	ptr = mallocx(1, 0);
28  	free(ptr);
29  	ptr = mallocx(1, MALLOCX_TCACHE_NONE);
30  	dallocx(ptr, MALLOCX_TCACHE_NONE);
31  }
32  static void
33  be_reentrant() {
34  	alloc_free_size(1);
35  	alloc_free_size(1024);
36  	alloc_free_size(64 * 1024);
37  	alloc_free_size(256 * 1024);
38  	alloc_free_size(1024 * 1024);
39  	void *ptr = mallocx(129, 0);
40  	ptr = rallocx(ptr, 130, 0);
41  	free(ptr);
42  	ptr = mallocx(2 * 1024 * 1024, 0);
43  	free(ptr);
44  	ptr = mallocx(1 * 1024 * 1024, 0);
45  	ptr = rallocx(ptr, 2 * 1024 * 1024, 0);
46  	free(ptr);
47  	ptr = mallocx(1, 0);
48  	ptr = rallocx(ptr, 1000, 0);
49  	free(ptr);
50  }
51  static void
52  set_args_raw(uintptr_t *args_raw, int nargs) {
53  	memcpy(arg_args_raw, args_raw, sizeof(uintptr_t) * nargs);
54  }
55  static void
56  assert_args_raw(uintptr_t *args_raw_expected, int nargs) {
57  	int cmp = memcmp(args_raw_expected, arg_args_raw,
58  	    sizeof(uintptr_t) * nargs);
59  	assert_d_eq(cmp, 0, &quot;Raw args mismatch&quot;);
60  }
61  static void
62  reset() {
63  	call_count = 0;
64  	reset_args();
65  }
66  static void
67  test_alloc_hook(void *extra, hook_alloc_t type, void *result,
68      uintptr_t result_raw, uintptr_t args_raw[3]) {
69  	call_count++;
70  	arg_extra = extra;
71  	arg_type = (int)type;
72  	arg_result = result;
73  	arg_result_raw = result_raw;
74  	set_args_raw(args_raw, 3);
75  	be_reentrant();
76  }
77  static void
78  test_dalloc_hook(void *extra, hook_dalloc_t type, void *address,
79      uintptr_t args_raw[3]) {
80  	call_count++;
81  	arg_extra = extra;
82  	arg_type = (int)type;
83  	arg_address = address;
84  	set_args_raw(args_raw, 3);
85  	be_reentrant();
86  }
87  static void
88  test_expand_hook(void *extra, hook_expand_t type, void *address,
89      size_t old_usize, size_t new_usize, uintptr_t result_raw,
90      uintptr_t args_raw[4]) {
91  	call_count++;
92  	arg_extra = extra;
93  	arg_type = (int)type;
94  	arg_address = address;
95  	arg_old_usize = old_usize;
96  	arg_new_usize = new_usize;
97  	arg_result_raw = result_raw;
98  	set_args_raw(args_raw, 4);
99  	be_reentrant();
100  }
101  TEST_BEGIN(test_hooks_basic) {
102  	hooks_t hooks = {
103  		&amp;test_alloc_hook, &amp;test_dalloc_hook, &amp;test_expand_hook,
104  		(void *)111};
105  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
106  	uintptr_t args_raw[4] = {10, 20, 30, 40};
107  	reset_args();
108  	hook_invoke_alloc(hook_alloc_posix_memalign, (void *)222, 333,
109  	    args_raw);
110  	assert_ptr_eq(arg_extra, (void *)111, &quot;Passed wrong user pointer&quot;);
111  	assert_d_eq((int)hook_alloc_posix_memalign, arg_type,
112  	    &quot;Passed wrong alloc type&quot;);
113  	assert_ptr_eq((void *)222, arg_result, &quot;Passed wrong result address&quot;);
114  	assert_u64_eq(333, arg_result_raw, &quot;Passed wrong result&quot;);
115  	assert_args_raw(args_raw, 3);
116  	reset_args();
117  	hook_invoke_dalloc(hook_dalloc_sdallocx, (void *)222, args_raw);
118  	assert_d_eq((int)hook_dalloc_sdallocx, arg_type,
119  	    &quot;Passed wrong dalloc type&quot;);
120  	assert_ptr_eq((void *)111, arg_extra, &quot;Passed wrong user pointer&quot;);
121  	assert_ptr_eq((void *)222, arg_address, &quot;Passed wrong address&quot;);
122  	assert_args_raw(args_raw, 3);
123  	reset_args();
124  	hook_invoke_expand(hook_expand_xallocx, (void *)222, 333, 444, 555,
125  	    args_raw);
126  	assert_d_eq((int)hook_expand_xallocx, arg_type,
127  	    &quot;Passed wrong expand type&quot;);
128  	assert_ptr_eq((void *)111, arg_extra, &quot;Passed wrong user pointer&quot;);
129  	assert_ptr_eq((void *)222, arg_address, &quot;Passed wrong address&quot;);
130  	assert_zu_eq(333, arg_old_usize, &quot;Passed wrong old usize&quot;);
131  	assert_zu_eq(444, arg_new_usize, &quot;Passed wrong new usize&quot;);
<span onclick='openModal()' class='match'>132  	assert_zu_eq(555, arg_result_raw, &quot;Passed wrong result&quot;);
133  	assert_args_raw(args_raw, 4);
134  	hook_remove(TSDN_NULL, handle);
</span>135  }
136  TEST_END
137  TEST_BEGIN(test_hooks_null) {
138  	hooks_t hooks1 = {NULL, NULL, NULL, NULL};
139  	hooks_t hooks2 = {&amp;test_alloc_hook, NULL, NULL, NULL};
140  	hooks_t hooks3 = {NULL, &amp;test_dalloc_hook, NULL, NULL};
141  	hooks_t hooks4 = {NULL, NULL, &amp;test_expand_hook, NULL};
142  	void *handle1 = hook_install(TSDN_NULL, &amp;hooks1);
143  	void *handle2 = hook_install(TSDN_NULL, &amp;hooks2);
144  	void *handle3 = hook_install(TSDN_NULL, &amp;hooks3);
145  	void *handle4 = hook_install(TSDN_NULL, &amp;hooks4);
146  	assert_ptr_ne(handle1, NULL, &quot;Hook installation failed&quot;);
147  	assert_ptr_ne(handle2, NULL, &quot;Hook installation failed&quot;);
148  	assert_ptr_ne(handle3, NULL, &quot;Hook installation failed&quot;);
149  	assert_ptr_ne(handle4, NULL, &quot;Hook installation failed&quot;);
150  	uintptr_t args_raw[4] = {10, 20, 30, 40};
151  	call_count = 0;
152  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, args_raw);
153  	assert_d_eq(call_count, 1, &quot;Called wrong number of times&quot;);
154  	call_count = 0;
155  	hook_invoke_dalloc(hook_dalloc_free, NULL, args_raw);
156  	assert_d_eq(call_count, 1, &quot;Called wrong number of times&quot;);
157  	call_count = 0;
158  	hook_invoke_expand(hook_expand_realloc, NULL, 0, 0, 0, args_raw);
159  	assert_d_eq(call_count, 1, &quot;Called wrong number of times&quot;);
160  	hook_remove(TSDN_NULL, handle1);
161  	hook_remove(TSDN_NULL, handle2);
162  	hook_remove(TSDN_NULL, handle3);
163  	hook_remove(TSDN_NULL, handle4);
164  }
165  TEST_END
166  TEST_BEGIN(test_hooks_remove) {
167  	hooks_t hooks = {&amp;test_alloc_hook, NULL, NULL, NULL};
168  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
169  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
170  	call_count = 0;
171  	uintptr_t args_raw[4] = {10, 20, 30, 40};
172  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, args_raw);
173  	assert_d_eq(call_count, 1, &quot;Hook not invoked&quot;);
174  	call_count = 0;
175  	hook_remove(TSDN_NULL, handle);
176  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, NULL);
177  	assert_d_eq(call_count, 0, &quot;Hook invoked after removal&quot;);
178  }
179  TEST_END
180  TEST_BEGIN(test_hooks_alloc_simple) {
181  	hooks_t hooks = {&amp;test_alloc_hook, NULL, NULL, (void *)123};
182  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
183  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
184  	volatile int err;
185  	void *volatile ptr;
186  	reset();
187  	ptr = malloc(1);
188  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
189  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
190  	assert_d_eq(arg_type, (int)hook_alloc_malloc, &quot;Wrong hook type&quot;);
191  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
192  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
193  	    &quot;Wrong raw result&quot;);
194  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], &quot;Wrong argument&quot;);
195  	free(ptr);
196  	reset();
197  	err = posix_memalign((void **)&amp;ptr, 1024, 1);
198  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
199  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
200  	assert_d_eq(arg_type, (int)hook_alloc_posix_memalign,
201  	    &quot;Wrong hook type&quot;);
202  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
203  	assert_u64_eq((uintptr_t)err, (uintptr_t)arg_result_raw,
204  	    &quot;Wrong raw result&quot;);
205  	assert_u64_eq((uintptr_t)&amp;ptr, arg_args_raw[0], &quot;Wrong argument&quot;);
206  	assert_u64_eq((uintptr_t)1024, arg_args_raw[1], &quot;Wrong argument&quot;);
207  	assert_u64_eq((uintptr_t)1, arg_args_raw[2], &quot;Wrong argument&quot;);
208  	free(ptr);
209  	reset();
210  	ptr = aligned_alloc(1024, 1);
211  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
212  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
213  	assert_d_eq(arg_type, (int)hook_alloc_aligned_alloc,
214  	    &quot;Wrong hook type&quot;);
215  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
216  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
217  	    &quot;Wrong raw result&quot;);
218  	assert_u64_eq((uintptr_t)1024, arg_args_raw[0], &quot;Wrong argument&quot;);
219  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], &quot;Wrong argument&quot;);
220  	free(ptr);
221  	reset();
222  	ptr = calloc(11, 13);
223  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
224  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
225  	assert_d_eq(arg_type, (int)hook_alloc_calloc, &quot;Wrong hook type&quot;);
226  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
227  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
228  	    &quot;Wrong raw result&quot;);
229  	assert_u64_eq((uintptr_t)11, arg_args_raw[0], &quot;Wrong argument&quot;);
230  	assert_u64_eq((uintptr_t)13, arg_args_raw[1], &quot;Wrong argument&quot;);
231  	free(ptr);
232  #ifdef JEMALLOC_OVERRIDE_MEMALIGN
233  	reset();
234  	ptr = memalign(1024, 1);
235  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
236  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
237  	assert_d_eq(arg_type, (int)hook_alloc_memalign, &quot;Wrong hook type&quot;);
238  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
239  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
240  	    &quot;Wrong raw result&quot;);
241  	assert_u64_eq((uintptr_t)1024, arg_args_raw[0], &quot;Wrong argument&quot;);
242  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], &quot;Wrong argument&quot;);
243  	free(ptr);
244  #endif &amp;bsol;* JEMALLOC_OVERRIDE_MEMALIGN */
245  #ifdef JEMALLOC_OVERRIDE_VALLOC
246  	reset();
247  	ptr = valloc(1);
248  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
249  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
250  	assert_d_eq(arg_type, (int)hook_alloc_valloc, &quot;Wrong hook type&quot;);
251  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
252  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
253  	    &quot;Wrong raw result&quot;);
254  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], &quot;Wrong argument&quot;);
255  	free(ptr);
256  #endif &amp;bsol;* JEMALLOC_OVERRIDE_VALLOC */
257  	reset();
258  	ptr = mallocx(1, MALLOCX_LG_ALIGN(10));
259  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
260  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
261  	assert_d_eq(arg_type, (int)hook_alloc_mallocx, &quot;Wrong hook type&quot;);
262  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
263  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
264  	    &quot;Wrong raw result&quot;);
265  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], &quot;Wrong argument&quot;);
266  	assert_u64_eq((uintptr_t)MALLOCX_LG_ALIGN(10), arg_args_raw[1],
267  	    &quot;Wrong flags&quot;);
268  	free(ptr);
269  	hook_remove(TSDN_NULL, handle);
270  }
271  TEST_END
272  TEST_BEGIN(test_hooks_dalloc_simple) {
273  	hooks_t hooks = {NULL, &amp;test_dalloc_hook, NULL, (void *)123};
274  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
275  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
276  	void *volatile ptr;
277  	reset();
278  	ptr = malloc(1);
279  	free(ptr);
280  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
281  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
282  	assert_d_eq(arg_type, (int)hook_dalloc_free, &quot;Wrong hook type&quot;);
283  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer freed&quot;);
284  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong raw arg&quot;);
285  	reset();
286  	ptr = malloc(1);
287  	dallocx(ptr, MALLOCX_TCACHE_NONE);
288  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
289  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
290  	assert_d_eq(arg_type, (int)hook_dalloc_dallocx, &quot;Wrong hook type&quot;);
291  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer freed&quot;);
292  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong raw arg&quot;);
293  	assert_u64_eq((uintptr_t)MALLOCX_TCACHE_NONE, arg_args_raw[1],
294  	    &quot;Wrong raw arg&quot;);
295  	reset();
296  	ptr = malloc(1);
297  	sdallocx(ptr, 1, MALLOCX_TCACHE_NONE);
298  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
299  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
300  	assert_d_eq(arg_type, (int)hook_dalloc_sdallocx, &quot;Wrong hook type&quot;);
301  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer freed&quot;);
302  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong raw arg&quot;);
303  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], &quot;Wrong raw arg&quot;);
304  	assert_u64_eq((uintptr_t)MALLOCX_TCACHE_NONE, arg_args_raw[2],
305  	    &quot;Wrong raw arg&quot;);
306  	hook_remove(TSDN_NULL, handle);
307  }
308  TEST_END
309  TEST_BEGIN(test_hooks_expand_simple) {
310  	hooks_t hooks = {NULL, NULL, &amp;test_expand_hook, (void *)123};
311  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
312  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
313  	void *volatile ptr;
314  	reset();
315  	ptr = malloc(1);
316  	size_t new_usize = xallocx(ptr, 100, 200, MALLOCX_TCACHE_NONE);
317  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
318  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
319  	assert_d_eq(arg_type, (int)hook_expand_xallocx, &quot;Wrong hook type&quot;);
320  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer expanded&quot;);
321  	assert_u64_eq(arg_old_usize, nallocx(1, 0), &quot;Wrong old usize&quot;);
322  	assert_u64_eq(arg_new_usize, sallocx(ptr, 0), &quot;Wrong new usize&quot;);
323  	assert_u64_eq(new_usize, arg_result_raw, &quot;Wrong result&quot;);
324  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong arg&quot;);
325  	assert_u64_eq(100, arg_args_raw[1], &quot;Wrong arg&quot;);
326  	assert_u64_eq(200, arg_args_raw[2], &quot;Wrong arg&quot;);
327  	assert_u64_eq(MALLOCX_TCACHE_NONE, arg_args_raw[3], &quot;Wrong arg&quot;);
328  	hook_remove(TSDN_NULL, handle);
329  }
330  TEST_END
331  TEST_BEGIN(test_hooks_realloc_as_malloc_or_free) {
332  	hooks_t hooks = {&amp;test_alloc_hook, &amp;test_dalloc_hook,
333  		&amp;test_expand_hook, (void *)123};
334  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
335  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
336  	void *volatile ptr;
337  	reset();
338  	ptr = realloc(NULL, 1);
339  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
340  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
341  	assert_d_eq(arg_type, (int)hook_alloc_realloc, &quot;Wrong hook type&quot;);
342  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
343  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
344  	    &quot;Wrong raw result&quot;);
345  	assert_u64_eq((uintptr_t)NULL, arg_args_raw[0], &quot;Wrong argument&quot;);
346  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], &quot;Wrong argument&quot;);
347  	free(ptr);
348  	ptr = malloc(1);
349  	reset();
350  	realloc(ptr, 0);
351  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
352  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
353  	assert_d_eq(arg_type, (int)hook_dalloc_realloc, &quot;Wrong hook type&quot;);
354  	assert_ptr_eq(ptr, arg_address, &quot;Wrong pointer freed&quot;);
355  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong raw arg&quot;);
356  	assert_u64_eq((uintptr_t)0, arg_args_raw[1], &quot;Wrong raw arg&quot;);
357  	reset();
358  	ptr = realloc(NULL, 0);
359  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
360  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
361  	assert_d_eq(arg_type, (int)hook_alloc_realloc, &quot;Wrong hook type&quot;);
362  	assert_ptr_eq(ptr, arg_result, &quot;Wrong result&quot;);
363  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
364  	    &quot;Wrong raw result&quot;);
365  	assert_u64_eq((uintptr_t)NULL, arg_args_raw[0], &quot;Wrong argument&quot;);
366  	assert_u64_eq((uintptr_t)0, arg_args_raw[1], &quot;Wrong argument&quot;);
367  	free(ptr);
368  	hook_remove(TSDN_NULL, handle);
369  }
370  TEST_END
371  static void
372  do_realloc_test(void *(*ralloc)(void *, size_t, int), int flags,
373      int expand_type, int dalloc_type) {
374  	hooks_t hooks = {&amp;test_alloc_hook, &amp;test_dalloc_hook,
375  		&amp;test_expand_hook, (void *)123};
376  	void *handle = hook_install(TSDN_NULL, &amp;hooks);
377  	assert_ptr_ne(handle, NULL, &quot;Hook installation failed&quot;);
378  	void *volatile ptr;
379  	void *volatile ptr2;
380  	ptr = malloc(129);
381  	reset();
382  	ptr2 = ralloc(ptr, 130, flags);
383  	assert_ptr_eq(ptr, ptr2, &quot;Small realloc moved&quot;);
384  	assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
385  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
386  	assert_d_eq(arg_type, expand_type, &quot;Wrong hook type&quot;);
387  	assert_ptr_eq(ptr, arg_address, &quot;Wrong address&quot;);
388  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
389  	    &quot;Wrong raw result&quot;);
390  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong argument&quot;);
391  	assert_u64_eq((uintptr_t)130, arg_args_raw[1], &quot;Wrong argument&quot;);
392  	free(ptr);
393  	ptr = malloc(2 * 1024 * 1024);
394  	free(ptr);
395  	ptr2 = malloc(1 * 1024 * 1024);
396  	reset();
397  	ptr = ralloc(ptr2, 2 * 1024 * 1024, flags);
398  	if (ptr == ptr2) {
399  		assert_d_eq(call_count, 1, &quot;Hook not called&quot;);
400  		assert_d_eq(arg_type, expand_type, &quot;Wrong hook type&quot;);
401  	} else {
402  		assert_d_eq(call_count, 2, &quot;Wrong hooks called&quot;);
403  		assert_ptr_eq(ptr, arg_result, &quot;Wrong address&quot;);
404  		assert_d_eq(arg_type, dalloc_type, &quot;Wrong hook type&quot;);
405  	}
406  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
407  	assert_ptr_eq(ptr2, arg_address, &quot;Wrong address&quot;);
408  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
409  	    &quot;Wrong raw result&quot;);
410  	assert_u64_eq((uintptr_t)ptr2, arg_args_raw[0], &quot;Wrong argument&quot;);
411  	assert_u64_eq((uintptr_t)2 * 1024 * 1024, arg_args_raw[1],
412  	    &quot;Wrong argument&quot;);
413  	free(ptr);
414  	ptr = malloc(8);
415  	reset();
416  	ptr2 = ralloc(ptr, 128, flags);
417  	assert_ptr_ne(ptr, ptr2, &quot;Small realloc didn&#x27;t move&quot;);
418  	assert_d_eq(call_count, 2, &quot;Hook not called&quot;);
419  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
420  	assert_d_eq(arg_type, dalloc_type, &quot;Wrong hook type&quot;);
421  	assert_ptr_eq(ptr, arg_address, &quot;Wrong address&quot;);
422  	assert_ptr_eq(ptr2, arg_result, &quot;Wrong address&quot;);
423  	assert_u64_eq((uintptr_t)ptr2, (uintptr_t)arg_result_raw,
424  	    &quot;Wrong raw result&quot;);
425  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong argument&quot;);
426  	assert_u64_eq((uintptr_t)128, arg_args_raw[1], &quot;Wrong argument&quot;);
427  	free(ptr2);
428  	ptr = malloc(1);
429  	reset();
430  	ptr2 = ralloc(ptr, 2 * 1024 * 1024, flags);
431  	assert_ptr_ne(ptr, ptr2, &quot;Large realloc didn&#x27;t move&quot;);
432  	assert_d_eq(call_count, 2, &quot;Hook not called&quot;);
433  	assert_ptr_eq(arg_extra, (void *)123, &quot;Wrong extra&quot;);
434  	assert_d_eq(arg_type, dalloc_type, &quot;Wrong hook type&quot;);
435  	assert_ptr_eq(ptr, arg_address, &quot;Wrong address&quot;);
436  	assert_ptr_eq(ptr2, arg_result, &quot;Wrong address&quot;);
437  	assert_u64_eq((uintptr_t)ptr2, (uintptr_t)arg_result_raw,
438  	    &quot;Wrong raw result&quot;);
439  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], &quot;Wrong argument&quot;);
440  	assert_u64_eq((uintptr_t)2 * 1024 * 1024, arg_args_raw[1],
441  	    &quot;Wrong argument&quot;);
442  	free(ptr2);
443  	hook_remove(TSDN_NULL, handle);
444  }
445  static void *
446  realloc_wrapper(void *ptr, size_t size, UNUSED int flags) {
447  	return realloc(ptr, size);
448  }
449  TEST_BEGIN(test_hooks_realloc) {
450  	do_realloc_test(&amp;realloc_wrapper, 0, hook_expand_realloc,
451  	    hook_dalloc_realloc);
452  }
453  TEST_END
454  TEST_BEGIN(test_hooks_rallocx) {
455  	do_realloc_test(&amp;rallocx, MALLOCX_TCACHE_NONE, hook_expand_rallocx,
456  	    hook_dalloc_rallocx);
457  }
458  TEST_END
459  int
460  main(void) {
461  	return test_no_reentrancy(
462  	    test_hooks_basic,
463  	    test_hooks_null,
464  	    test_hooks_remove,
465  	    test_hooks_alloc_simple,
466  	    test_hooks_dalloc_simple,
467  	    test_hooks_expand_simple,
468  	    test_hooks_realloc_as_malloc_or_free,
469  	    test_hooks_realloc,
470  	    test_hooks_rallocx);
471  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hook.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hook.c</div>
                </div>
                <div class="column column_space"><pre><code>114  	assert_u64_eq(333, arg_result_raw, &quot;Passed wrong result&quot;);
115  	assert_args_raw(args_raw, 3);
116  	reset_args();
</pre></code></div>
                <div class="column column_space"><pre><code>132  	assert_zu_eq(555, arg_result_raw, &quot;Passed wrong result&quot;);
133  	assert_args_raw(args_raw, 4);
134  	hook_remove(TSDN_NULL, handle);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    