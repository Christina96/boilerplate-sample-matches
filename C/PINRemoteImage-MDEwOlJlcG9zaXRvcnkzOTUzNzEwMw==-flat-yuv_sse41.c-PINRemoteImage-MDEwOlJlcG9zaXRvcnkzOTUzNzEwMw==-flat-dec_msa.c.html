
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 25.208681135225376%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_sse41.c</h3>
            <pre><code>1  #include "src/dsp/yuv.h"
2  #if defined(WEBP_USE_SSE41)
3  #include "src/dsp/common_sse41.h"
4  #include <stdlib.h>
5  #include <smmintrin.h>
6  static void ConvertYUV444ToRGB_SSE41(const __m128i* const Y0,
7                                       const __m128i* const U0,
8                                       const __m128i* const V0,
9                                       __m128i* const R,
10                                       __m128i* const G,
11                                       __m128i* const B) {
12    const __m128i k19077 = _mm_set1_epi16(19077);
13    const __m128i k26149 = _mm_set1_epi16(26149);
14    const __m128i k14234 = _mm_set1_epi16(14234);
15    const __m128i k33050 = _mm_set1_epi16((short)33050);
16    const __m128i k17685 = _mm_set1_epi16(17685);
17    const __m128i k6419  = _mm_set1_epi16(6419);
18    const __m128i k13320 = _mm_set1_epi16(13320);
19    const __m128i k8708  = _mm_set1_epi16(8708);
20    const __m128i Y1 = _mm_mulhi_epu16(*Y0, k19077);
21    const __m128i R0 = _mm_mulhi_epu16(*V0, k26149);
22    const __m128i R1 = _mm_sub_epi16(Y1, k14234);
23    const __m128i R2 = _mm_add_epi16(R1, R0);
24    const __m128i G0 = _mm_mulhi_epu16(*U0, k6419);
25    const __m128i G1 = _mm_mulhi_epu16(*V0, k13320);
26    const __m128i G2 = _mm_add_epi16(Y1, k8708);
27    const __m128i G3 = _mm_add_epi16(G0, G1);
28    const __m128i G4 = _mm_sub_epi16(G2, G3);
29    const __m128i B0 = _mm_mulhi_epu16(*U0, k33050);
30    const __m128i B1 = _mm_adds_epu16(B0, Y1);
31    const __m128i B2 = _mm_subs_epu16(B1, k17685);
32    *R = _mm_srai_epi16(R2, 6);   
33    *G = _mm_srai_epi16(G4, 6);   
34    *B = _mm_srli_epi16(B2, 6);   
35  }
36  static WEBP_INLINE __m128i Load_HI_16_SSE41(const uint8_t* src) {
37    const __m128i zero = _mm_setzero_si128();
38    return _mm_unpacklo_epi8(zero, _mm_loadl_epi64((const __m128i*)src));
39  }
40  static WEBP_INLINE __m128i Load_UV_HI_8_SSE41(const uint8_t* src) {
41    const __m128i zero = _mm_setzero_si128();
42    const __m128i tmp0 = _mm_cvtsi32_si128(*(const uint32_t*)src);
43    const __m128i tmp1 = _mm_unpacklo_epi8(zero, tmp0);
44    return _mm_unpacklo_epi16(tmp1, tmp1);   
45  }
46  static void YUV444ToRGB_SSE41(const uint8_t* const y,
47                                const uint8_t* const u,
48                                const uint8_t* const v,
49                                __m128i* const R, __m128i* const G,
50                                __m128i* const B) {
51    const __m128i Y0 = Load_HI_16_SSE41(y), U0 = Load_HI_16_SSE41(u),
52                  V0 = Load_HI_16_SSE41(v);
53    ConvertYUV444ToRGB_SSE41(&Y0, &U0, &V0, R, G, B);
54  }
55  static void YUV420ToRGB_SSE41(const uint8_t* const y,
56                                const uint8_t* const u,
57                                const uint8_t* const v,
58                                __m128i* const R, __m128i* const G,
59                                __m128i* const B) {
60    const __m128i Y0 = Load_HI_16_SSE41(y), U0 = Load_UV_HI_8_SSE41(u),
61                  V0 = Load_UV_HI_8_SSE41(v);
62    ConvertYUV444ToRGB_SSE41(&Y0, &U0, &V0, R, G, B);
63  }
64  static WEBP_INLINE void PlanarTo24b_SSE41(
65      __m128i* const in0, __m128i* const in1, __m128i* const in2,
66      __m128i* const in3, __m128i* const in4, __m128i* const in5,
67      uint8_t* const rgb) {
68    VP8PlanarTo24b_SSE41(in0, in1, in2, in3, in4, in5);
69    _mm_storeu_si128((__m128i*)(rgb +  0), *in0);
70    _mm_storeu_si128((__m128i*)(rgb + 16), *in1);
71    _mm_storeu_si128((__m128i*)(rgb + 32), *in2);
72    _mm_storeu_si128((__m128i*)(rgb + 48), *in3);
73    _mm_storeu_si128((__m128i*)(rgb + 64), *in4);
74    _mm_storeu_si128((__m128i*)(rgb + 80), *in5);
75  }
76  void VP8YuvToRgb32_SSE41(const uint8_t* y, const uint8_t* u, const uint8_t* v,
77                           uint8_t* dst) {
78    __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
79    __m128i rgb0, rgb1, rgb2, rgb3, rgb4, rgb5;
80    YUV444ToRGB_SSE41(y + 0, u + 0, v + 0, &R0, &G0, &B0);
81    YUV444ToRGB_SSE41(y + 8, u + 8, v + 8, &R1, &G1, &B1);
82    YUV444ToRGB_SSE41(y + 16, u + 16, v + 16, &R2, &G2, &B2);
83    YUV444ToRGB_SSE41(y + 24, u + 24, v + 24, &R3, &G3, &B3);
84    rgb0 = _mm_packus_epi16(R0, R1);
85    rgb1 = _mm_packus_epi16(R2, R3);
86    rgb2 = _mm_packus_epi16(G0, G1);
87    rgb3 = _mm_packus_epi16(G2, G3);
88    rgb4 = _mm_packus_epi16(B0, B1);
89    rgb5 = _mm_packus_epi16(B2, B3);
90    PlanarTo24b_SSE41(&rgb0, &rgb1, &rgb2, &rgb3, &rgb4, &rgb5, dst);
91  }
92  void VP8YuvToBgr32_SSE41(const uint8_t* y, const uint8_t* u, const uint8_t* v,
93                           uint8_t* dst) {
94    __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
95    __m128i bgr0, bgr1, bgr2, bgr3, bgr4, bgr5;
96    YUV444ToRGB_SSE41(y +  0, u +  0, v +  0, &R0, &G0, &B0);
97    YUV444ToRGB_SSE41(y +  8, u +  8, v +  8, &R1, &G1, &B1);
98    YUV444ToRGB_SSE41(y + 16, u + 16, v + 16, &R2, &G2, &B2);
99    YUV444ToRGB_SSE41(y + 24, u + 24, v + 24, &R3, &G3, &B3);
100    bgr0 = _mm_packus_epi16(B0, B1);
101    bgr1 = _mm_packus_epi16(B2, B3);
102    bgr2 = _mm_packus_epi16(G0, G1);
103    bgr3 = _mm_packus_epi16(G2, G3);
104    bgr4 = _mm_packus_epi16(R0, R1);
105    bgr5= _mm_packus_epi16(R2, R3);
106    PlanarTo24b_SSE41(&bgr0, &bgr1, &bgr2, &bgr3, &bgr4, &bgr5, dst);
107  }
108  static void YuvToRgbRow_SSE41(const uint8_t* y,
109                                const uint8_t* u, const uint8_t* v,
110                                uint8_t* dst, int len) {
111    int n;
112    for (n = 0; n + 32 <= len; n += 32, dst += 32 * 3) {
113      __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
114      __m128i rgb0, rgb1, rgb2, rgb3, rgb4, rgb5;
115      YUV420ToRGB_SSE41(y +  0, u +  0, v +  0, &R0, &G0, &B0);
116      YUV420ToRGB_SSE41(y +  8, u +  4, v +  4, &R1, &G1, &B1);
117      YUV420ToRGB_SSE41(y + 16, u +  8, v +  8, &R2, &G2, &B2);
118      YUV420ToRGB_SSE41(y + 24, u + 12, v + 12, &R3, &G3, &B3);
119      rgb0 = _mm_packus_epi16(R0, R1);
120      rgb1 = _mm_packus_epi16(R2, R3);
121      rgb2 = _mm_packus_epi16(G0, G1);
122      rgb3 = _mm_packus_epi16(G2, G3);
123      rgb4 = _mm_packus_epi16(B0, B1);
124      rgb5 = _mm_packus_epi16(B2, B3);
125      PlanarTo24b_SSE41(&rgb0, &rgb1, &rgb2, &rgb3, &rgb4, &rgb5, dst);
126      y += 32;
127      u += 16;
128      v += 16;
129    }
130    for (; n < len; ++n) {   
131      VP8YuvToRgb(y[0], u[0], v[0], dst);
132      dst += 3;
133      y += 1;
134      u += (n & 1);
135      v += (n & 1);
136    }
137  }
138  static void YuvToBgrRow_SSE41(const uint8_t* y,
139                                const uint8_t* u, const uint8_t* v,
140                                uint8_t* dst, int len) {
141    int n;
142    for (n = 0; n + 32 <= len; n += 32, dst += 32 * 3) {
143      __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
144      __m128i bgr0, bgr1, bgr2, bgr3, bgr4, bgr5;
145      YUV420ToRGB_SSE41(y +  0, u +  0, v +  0, &R0, &G0, &B0);
146      YUV420ToRGB_SSE41(y +  8, u +  4, v +  4, &R1, &G1, &B1);
147      YUV420ToRGB_SSE41(y + 16, u +  8, v +  8, &R2, &G2, &B2);
148      YUV420ToRGB_SSE41(y + 24, u + 12, v + 12, &R3, &G3, &B3);
<span onclick='openModal()' class='match'>149      bgr0 = _mm_packus_epi16(B0, B1);
150      bgr1 = _mm_packus_epi16(B2, B3);
151      bgr2 = _mm_packus_epi16(G0, G1);
152      bgr3 = _mm_packus_epi16(G2, G3);
153      bgr4 = _mm_packus_epi16(R0, R1);
154      bgr5 = _mm_packus_epi16(R2, R3);
155      PlanarTo24b_SSE41(&bgr0, &bgr1, &bgr2, &bgr3, &bgr4, &bgr5, dst);
156      y += 32;
157      u += 16;
158      v += 16;
159    }
</span>160    for (; n < len; ++n) {   
161      VP8YuvToBgr(y[0], u[0], v[0], dst);
162      dst += 3;
163      y += 1;
164      u += (n & 1);
165      v += (n & 1);
166    }
167  }
168  extern void WebPInitSamplersSSE41(void);
169  WEBP_TSAN_IGNORE_FUNCTION void WebPInitSamplersSSE41(void) {
170    WebPSamplers[MODE_RGB]  = YuvToRgbRow_SSE41;
171    WebPSamplers[MODE_BGR]  = YuvToBgrRow_SSE41;
172  }
173  #define LOAD_16(src) _mm_loadu_si128((const __m128i*)(src))
174  #define STORE_16(V, dst) _mm_storeu_si128((__m128i*)(dst), (V))
175  #define WEBP_SSE41_SHUFF(OUT)  do {                  \
176    const __m128i tmp0 = _mm_shuffle_epi8(A0, shuff0); \
177    const __m128i tmp1 = _mm_shuffle_epi8(A1, shuff1); \
178    const __m128i tmp2 = _mm_shuffle_epi8(A2, shuff2); \
179    const __m128i tmp3 = _mm_shuffle_epi8(A3, shuff0); \
180    const __m128i tmp4 = _mm_shuffle_epi8(A4, shuff1); \
181    const __m128i tmp5 = _mm_shuffle_epi8(A5, shuff2); \
182                                                       \
183                 \
184    const __m128i tmp6 = _mm_or_si128(tmp0, tmp1);     \
185    const __m128i tmp7 = _mm_or_si128(tmp3, tmp4);     \
186    out[OUT + 0] = _mm_or_si128(tmp6, tmp2);           \
187    out[OUT + 1] = _mm_or_si128(tmp7, tmp5);           \
188  } while (0);
189  static WEBP_INLINE void RGB24PackedToPlanar_SSE41(
190      const uint8_t* const rgb, __m128i* const out &bsol;*out[6]*/) {
191    const __m128i A0 = _mm_loadu_si128((const __m128i*)(rgb +  0));
192    const __m128i A1 = _mm_loadu_si128((const __m128i*)(rgb + 16));
193    const __m128i A2 = _mm_loadu_si128((const __m128i*)(rgb + 32));
194    const __m128i A3 = _mm_loadu_si128((const __m128i*)(rgb + 48));
195    const __m128i A4 = _mm_loadu_si128((const __m128i*)(rgb + 64));
196    const __m128i A5 = _mm_loadu_si128((const __m128i*)(rgb + 80));
197    {
198      const __m128i shuff0 = _mm_set_epi8(
199          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, 12, 9, 6, 3, 0);
200      const __m128i shuff1 = _mm_set_epi8(
201          -1, -1, -1, -1, -1, 14, 11, 8, 5, 2, -1, -1, -1, -1, -1, -1);
202      const __m128i shuff2 = _mm_set_epi8(
203          13, 10, 7, 4, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
204      WEBP_SSE41_SHUFF(0)
205    }
206    {
207      const __m128i shuff0 = _mm_set_epi8(
208          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, 10, 7, 4, 1);
209      const __m128i shuff1 = _mm_set_epi8(
210          -1, -1, -1, -1, -1, 15, 12, 9, 6, 3, 0, -1, -1, -1, -1, -1);
211      const __m128i shuff2 = _mm_set_epi8(
212          14, 11, 8, 5, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
213      WEBP_SSE41_SHUFF(2)
214    }
215    {
216      const __m128i shuff0 = _mm_set_epi8(
217          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, 11, 8, 5, 2);
218      const __m128i shuff1 = _mm_set_epi8(
219          -1, -1, -1, -1, -1, -1, 13, 10, 7, 4, 1, -1, -1, -1, -1, -1);
220      const __m128i shuff2 = _mm_set_epi8(
221          15, 12, 9, 6, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
222      WEBP_SSE41_SHUFF(4)
223    }
224  }
225  #undef WEBP_SSE41_SHUFF
226  static WEBP_INLINE void RGB32PackedToPlanar_SSE41(
227      const uint32_t* const argb, __m128i* const rgb &bsol;*in[6]*/) {
228    const __m128i zero = _mm_setzero_si128();
229    __m128i a0 = LOAD_16(argb + 0);
230    __m128i a1 = LOAD_16(argb + 4);
231    __m128i a2 = LOAD_16(argb + 8);
232    __m128i a3 = LOAD_16(argb + 12);
233    VP8L32bToPlanar_SSE41(&a0, &a1, &a2, &a3);
234    rgb[0] = _mm_unpacklo_epi8(a1, zero);
235    rgb[1] = _mm_unpackhi_epi8(a1, zero);
236    rgb[2] = _mm_unpacklo_epi8(a2, zero);
237    rgb[3] = _mm_unpackhi_epi8(a2, zero);
238    rgb[4] = _mm_unpacklo_epi8(a3, zero);
239    rgb[5] = _mm_unpackhi_epi8(a3, zero);
240  }
241  #define TRANSFORM(RG_LO, RG_HI, GB_LO, GB_HI, MULT_RG, MULT_GB, \
242                    ROUNDER, DESCALE_FIX, OUT) do {               \
243    const __m128i V0_lo = _mm_madd_epi16(RG_LO, MULT_RG);         \
244    const __m128i V0_hi = _mm_madd_epi16(RG_HI, MULT_RG);         \
245    const __m128i V1_lo = _mm_madd_epi16(GB_LO, MULT_GB);         \
246    const __m128i V1_hi = _mm_madd_epi16(GB_HI, MULT_GB);         \
247    const __m128i V2_lo = _mm_add_epi32(V0_lo, V1_lo);            \
248    const __m128i V2_hi = _mm_add_epi32(V0_hi, V1_hi);            \
249    const __m128i V3_lo = _mm_add_epi32(V2_lo, ROUNDER);          \
250    const __m128i V3_hi = _mm_add_epi32(V2_hi, ROUNDER);          \
251    const __m128i V5_lo = _mm_srai_epi32(V3_lo, DESCALE_FIX);     \
252    const __m128i V5_hi = _mm_srai_epi32(V3_hi, DESCALE_FIX);     \
253    (OUT) = _mm_packs_epi32(V5_lo, V5_hi);                        \
254  } while (0)
255  #define MK_CST_16(A, B) _mm_set_epi16((B), (A), (B), (A), (B), (A), (B), (A))
256  static WEBP_INLINE void ConvertRGBToY_SSE41(const __m128i* const R,
257                                              const __m128i* const G,
258                                              const __m128i* const B,
259                                              __m128i* const Y) {
260    const __m128i kRG_y = MK_CST_16(16839, 33059 - 16384);
261    const __m128i kGB_y = MK_CST_16(16384, 6420);
262    const __m128i kHALF_Y = _mm_set1_epi32((16 << YUV_FIX) + YUV_HALF);
263    const __m128i RG_lo = _mm_unpacklo_epi16(*R, *G);
264    const __m128i RG_hi = _mm_unpackhi_epi16(*R, *G);
265    const __m128i GB_lo = _mm_unpacklo_epi16(*G, *B);
266    const __m128i GB_hi = _mm_unpackhi_epi16(*G, *B);
267    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_y, kGB_y, kHALF_Y, YUV_FIX, *Y);
268  }
269  static WEBP_INLINE void ConvertRGBToUV_SSE41(const __m128i* const R,
270                                               const __m128i* const G,
271                                               const __m128i* const B,
272                                               __m128i* const U,
273                                               __m128i* const V) {
274    const __m128i kRG_u = MK_CST_16(-9719, -19081);
275    const __m128i kGB_u = MK_CST_16(0, 28800);
276    const __m128i kRG_v = MK_CST_16(28800, 0);
277    const __m128i kGB_v = MK_CST_16(-24116, -4684);
278    const __m128i kHALF_UV = _mm_set1_epi32(((128 << YUV_FIX) + YUV_HALF) << 2);
279    const __m128i RG_lo = _mm_unpacklo_epi16(*R, *G);
280    const __m128i RG_hi = _mm_unpackhi_epi16(*R, *G);
281    const __m128i GB_lo = _mm_unpacklo_epi16(*G, *B);
282    const __m128i GB_hi = _mm_unpackhi_epi16(*G, *B);
283    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_u, kGB_u,
284              kHALF_UV, YUV_FIX + 2, *U);
285    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_v, kGB_v,
286              kHALF_UV, YUV_FIX + 2, *V);
287  }
288  #undef MK_CST_16
289  #undef TRANSFORM
290  static void ConvertRGB24ToY_SSE41(const uint8_t* rgb, uint8_t* y, int width) {
291    const int max_width = width & ~31;
292    int i;
293    for (i = 0; i < max_width; rgb += 3 * 16 * 2) {
294      __m128i rgb_plane[6];
295      int j;
296      RGB24PackedToPlanar_SSE41(rgb, rgb_plane);
297      for (j = 0; j < 2; ++j, i += 16) {
298        const __m128i zero = _mm_setzero_si128();
299        __m128i r, g, b, Y0, Y1;
300        r = _mm_unpacklo_epi8(rgb_plane[0 + j], zero);
301        g = _mm_unpacklo_epi8(rgb_plane[2 + j], zero);
302        b = _mm_unpacklo_epi8(rgb_plane[4 + j], zero);
303        ConvertRGBToY_SSE41(&r, &g, &b, &Y0);
304        r = _mm_unpackhi_epi8(rgb_plane[0 + j], zero);
305        g = _mm_unpackhi_epi8(rgb_plane[2 + j], zero);
306        b = _mm_unpackhi_epi8(rgb_plane[4 + j], zero);
307        ConvertRGBToY_SSE41(&r, &g, &b, &Y1);
308        STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
309      }
310    }
311    for (; i < width; ++i, rgb += 3) {   
312      y[i] = VP8RGBToY(rgb[0], rgb[1], rgb[2], YUV_HALF);
313    }
314  }
315  static void ConvertBGR24ToY_SSE41(const uint8_t* bgr, uint8_t* y, int width) {
316    const int max_width = width & ~31;
317    int i;
318    for (i = 0; i < max_width; bgr += 3 * 16 * 2) {
319      __m128i bgr_plane[6];
320      int j;
321      RGB24PackedToPlanar_SSE41(bgr, bgr_plane);
322      for (j = 0; j < 2; ++j, i += 16) {
323        const __m128i zero = _mm_setzero_si128();
324        __m128i r, g, b, Y0, Y1;
325        b = _mm_unpacklo_epi8(bgr_plane[0 + j], zero);
326        g = _mm_unpacklo_epi8(bgr_plane[2 + j], zero);
327        r = _mm_unpacklo_epi8(bgr_plane[4 + j], zero);
328        ConvertRGBToY_SSE41(&r, &g, &b, &Y0);
329        b = _mm_unpackhi_epi8(bgr_plane[0 + j], zero);
330        g = _mm_unpackhi_epi8(bgr_plane[2 + j], zero);
331        r = _mm_unpackhi_epi8(bgr_plane[4 + j], zero);
332        ConvertRGBToY_SSE41(&r, &g, &b, &Y1);
333        STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
334      }
335    }
336    for (; i < width; ++i, bgr += 3) {  
337      y[i] = VP8RGBToY(bgr[2], bgr[1], bgr[0], YUV_HALF);
338    }
339  }
340  static void ConvertARGBToY_SSE41(const uint32_t* argb, uint8_t* y, int width) {
341    const int max_width = width & ~15;
342    int i;
343    for (i = 0; i < max_width; i += 16) {
344      __m128i Y0, Y1, rgb[6];
345      RGB32PackedToPlanar_SSE41(&argb[i], rgb);
346      ConvertRGBToY_SSE41(&rgb[0], &rgb[2], &rgb[4], &Y0);
347      ConvertRGBToY_SSE41(&rgb[1], &rgb[3], &rgb[5], &Y1);
348      STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
349    }
350    for (; i < width; ++i) {   
351      const uint32_t p = argb[i];
352      y[i] = VP8RGBToY((p >> 16) & 0xff, (p >> 8) & 0xff, (p >>  0) & 0xff,
353                       YUV_HALF);
354    }
355  }
356  static void HorizontalAddPack_SSE41(const __m128i* const A,
357                                      const __m128i* const B,
358                                      __m128i* const out) {
359    const __m128i k2 = _mm_set1_epi16(2);
360    const __m128i C = _mm_madd_epi16(*A, k2);
361    const __m128i D = _mm_madd_epi16(*B, k2);
362    *out = _mm_packs_epi32(C, D);
363  }
364  static void ConvertARGBToUV_SSE41(const uint32_t* argb,
365                                    uint8_t* u, uint8_t* v,
366                                    int src_width, int do_store) {
367    const int max_width = src_width & ~31;
368    int i;
369    for (i = 0; i < max_width; i += 32, u += 16, v += 16) {
370      __m128i rgb[6], U0, V0, U1, V1;
371      RGB32PackedToPlanar_SSE41(&argb[i], rgb);
372      HorizontalAddPack_SSE41(&rgb[0], &rgb[1], &rgb[0]);
373      HorizontalAddPack_SSE41(&rgb[2], &rgb[3], &rgb[2]);
374      HorizontalAddPack_SSE41(&rgb[4], &rgb[5], &rgb[4]);
375      ConvertRGBToUV_SSE41(&rgb[0], &rgb[2], &rgb[4], &U0, &V0);
376      RGB32PackedToPlanar_SSE41(&argb[i + 16], rgb);
377      HorizontalAddPack_SSE41(&rgb[0], &rgb[1], &rgb[0]);
378      HorizontalAddPack_SSE41(&rgb[2], &rgb[3], &rgb[2]);
379      HorizontalAddPack_SSE41(&rgb[4], &rgb[5], &rgb[4]);
380      ConvertRGBToUV_SSE41(&rgb[0], &rgb[2], &rgb[4], &U1, &V1);
381      U0 = _mm_packus_epi16(U0, U1);
382      V0 = _mm_packus_epi16(V0, V1);
383      if (!do_store) {
384        const __m128i prev_u = LOAD_16(u);
385        const __m128i prev_v = LOAD_16(v);
386        U0 = _mm_avg_epu8(U0, prev_u);
387        V0 = _mm_avg_epu8(V0, prev_v);
388      }
389      STORE_16(U0, u);
390      STORE_16(V0, v);
391    }
392    if (i < src_width) {  
393      WebPConvertARGBToUV_C(argb + i, u, v, src_width - i, do_store);
394    }
395  }
396  static WEBP_INLINE void RGBA32PackedToPlanar_16b_SSE41(
397      const uint16_t* const rgbx,
398      __m128i* const r, __m128i* const g, __m128i* const b) {
399    const __m128i in0 = LOAD_16(rgbx +  0);  
400    const __m128i in1 = LOAD_16(rgbx +  8);  
401    const __m128i in2 = LOAD_16(rgbx + 16);  
402    const __m128i in3 = LOAD_16(rgbx + 24);  
403    const __m128i shuff0 =
404        _mm_set_epi8(-1, -1, -1, -1, 13, 12, 5, 4, 11, 10, 3, 2, 9, 8, 1, 0);
405    const __m128i shuff1 =
406        _mm_set_epi8(13, 12, 5, 4, -1, -1, -1, -1, 11, 10, 3, 2, 9, 8, 1, 0);
407    const __m128i A0 = _mm_shuffle_epi8(in0, shuff0);
408    const __m128i A1 = _mm_shuffle_epi8(in1, shuff1);
409    const __m128i A2 = _mm_shuffle_epi8(in2, shuff0);
410    const __m128i A3 = _mm_shuffle_epi8(in3, shuff1);
411    const __m128i B0 = _mm_unpacklo_epi32(A0, A1);
412    const __m128i B1 = _mm_or_si128(A0, A1);
413    const __m128i B2 = _mm_unpacklo_epi32(A2, A3);
414    const __m128i B3 = _mm_or_si128(A2, A3);
415    *r = _mm_unpacklo_epi64(B0, B2);
416    *g = _mm_unpackhi_epi64(B0, B2);
417    *b = _mm_unpackhi_epi64(B1, B3);
418  }
419  static void ConvertRGBA32ToUV_SSE41(const uint16_t* rgb,
420                                      uint8_t* u, uint8_t* v, int width) {
421    const int max_width = width & ~15;
422    const uint16_t* const last_rgb = rgb + 4 * max_width;
423    while (rgb < last_rgb) {
424      __m128i r, g, b, U0, V0, U1, V1;
425      RGBA32PackedToPlanar_16b_SSE41(rgb +  0, &r, &g, &b);
426      ConvertRGBToUV_SSE41(&r, &g, &b, &U0, &V0);
427      RGBA32PackedToPlanar_16b_SSE41(rgb + 32, &r, &g, &b);
428      ConvertRGBToUV_SSE41(&r, &g, &b, &U1, &V1);
429      STORE_16(_mm_packus_epi16(U0, U1), u);
430      STORE_16(_mm_packus_epi16(V0, V1), v);
431      u += 16;
432      v += 16;
433      rgb += 2 * 32;
434    }
435    if (max_width < width) {  
436      WebPConvertRGBA32ToUV_C(rgb, u, v, width - max_width);
437    }
438  }
439  extern void WebPInitConvertARGBToYUVSSE41(void);
440  WEBP_TSAN_IGNORE_FUNCTION void WebPInitConvertARGBToYUVSSE41(void) {
441    WebPConvertARGBToY = ConvertARGBToY_SSE41;
442    WebPConvertARGBToUV = ConvertARGBToUV_SSE41;
443    WebPConvertRGB24ToY = ConvertRGB24ToY_SSE41;
444    WebPConvertBGR24ToY = ConvertBGR24ToY_SSE41;
445    WebPConvertRGBA32ToUV = ConvertRGBA32ToUV_SSE41;
446  }
447  #else  
448  WEBP_DSP_INIT_STUB(WebPInitSamplersSSE41)
449  WEBP_DSP_INIT_STUB(WebPInitConvertARGBToYUVSSE41)
450  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_msa.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MSA)
3  #include "src/dsp/msa_macro.h"
4  #define IDCT_1D_W(in0, in1, in2, in3, out0, out1, out2, out3) {  \
5    v4i32 a1_m, b1_m, c1_m, d1_m;                                  \
6    v4i32 c_tmp1_m, c_tmp2_m, d_tmp1_m, d_tmp2_m;                  \
7    const v4i32 cospi8sqrt2minus1 = __msa_fill_w(20091);           \
8    const v4i32 sinpi8sqrt2 = __msa_fill_w(35468);                 \
9                                                                   \
10    a1_m = in0 + in2;                                              \
11    b1_m = in0 - in2;                                              \
12    c_tmp1_m = (in1 * sinpi8sqrt2) >> 16;                          \
13    c_tmp2_m = in3 + ((in3 * cospi8sqrt2minus1) >> 16);            \
14    c1_m = c_tmp1_m - c_tmp2_m;                                    \
15    d_tmp1_m = in1 + ((in1 * cospi8sqrt2minus1) >> 16);            \
16    d_tmp2_m = (in3 * sinpi8sqrt2) >> 16;                          \
17    d1_m = d_tmp1_m + d_tmp2_m;                                    \
18    BUTTERFLY_4(a1_m, b1_m, c1_m, d1_m, out0, out1, out2, out3);   \
19  }
20  #define MULT1(a) ((((a) * 20091) >> 16) + (a))
21  #define MULT2(a) (((a) * 35468) >> 16)
22  static void TransformOne(const int16_t* in, uint8_t* dst) {
23    v8i16 input0, input1;
24    v4i32 in0, in1, in2, in3, hz0, hz1, hz2, hz3, vt0, vt1, vt2, vt3;
25    v4i32 res0, res1, res2, res3;
26    const v16i8 zero = { 0 };
27    v16i8 dest0, dest1, dest2, dest3;
28    LD_SH2(in, 8, input0, input1);
29    UNPCK_SH_SW(input0, in0, in1);
30    UNPCK_SH_SW(input1, in2, in3);
31    IDCT_1D_W(in0, in1, in2, in3, hz0, hz1, hz2, hz3);
32    TRANSPOSE4x4_SW_SW(hz0, hz1, hz2, hz3, hz0, hz1, hz2, hz3);
33    IDCT_1D_W(hz0, hz1, hz2, hz3, vt0, vt1, vt2, vt3);
34    SRARI_W4_SW(vt0, vt1, vt2, vt3, 3);
35    TRANSPOSE4x4_SW_SW(vt0, vt1, vt2, vt3, vt0, vt1, vt2, vt3);
36    LD_SB4(dst, BPS, dest0, dest1, dest2, dest3);
37    ILVR_B4_SW(zero, dest0, zero, dest1, zero, dest2, zero, dest3,
38               res0, res1, res2, res3);
39    ILVR_H4_SW(zero, res0, zero, res1, zero, res2, zero, res3,
40               res0, res1, res2, res3);
41    ADD4(res0, vt0, res1, vt1, res2, vt2, res3, vt3, res0, res1, res2, res3);
42    CLIP_SW4_0_255(res0, res1, res2, res3);
43    PCKEV_B2_SW(res0, res1, res2, res3, vt0, vt1);
44    res0 = (v4i32)__msa_pckev_b((v16i8)vt0, (v16i8)vt1);
45    ST4x4_UB(res0, res0, 3, 2, 1, 0, dst, BPS);
46  }
47  static void TransformTwo(const int16_t* in, uint8_t* dst, int do_two) {
48    TransformOne(in, dst);
49    if (do_two) {
50      TransformOne(in + 16, dst + 4);
51    }
52  }
53  static void TransformWHT(const int16_t* in, int16_t* out) {
54    v8i16 input0, input1;
55    const v8i16 mask0 = { 0, 1, 2, 3, 8, 9, 10, 11 };
56    const v8i16 mask1 = { 4, 5, 6, 7, 12, 13, 14, 15 };
57    const v8i16 mask2 = { 0, 4, 8, 12, 1, 5, 9, 13 };
58    const v8i16 mask3 = { 3, 7, 11, 15, 2, 6, 10, 14 };
59    v8i16 tmp0, tmp1, tmp2, tmp3;
60    v8i16 out0, out1;
61    LD_SH2(in, 8, input0, input1);
62    input1 = SLDI_SH(input1, input1, 8);
63    tmp0 = input0 + input1;
64    tmp1 = input0 - input1;
65    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
66    out0 = tmp2 + tmp3;
67    out1 = tmp2 - tmp3;
68    VSHF_H2_SH(out0, out1, out0, out1, mask2, mask3, input0, input1);
69    tmp0 = input0 + input1;
70    tmp1 = input0 - input1;
71    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
72    tmp0 = tmp2 + tmp3;
73    tmp1 = tmp2 - tmp3;
74    ADDVI_H2_SH(tmp0, 3, tmp1, 3, out0, out1);
75    SRAI_H2_SH(out0, out1, 3);
76    out[0] = __msa_copy_s_h(out0, 0);
77    out[16] = __msa_copy_s_h(out0, 4);
78    out[32] = __msa_copy_s_h(out1, 0);
79    out[48] = __msa_copy_s_h(out1, 4);
80    out[64] = __msa_copy_s_h(out0, 1);
81    out[80] = __msa_copy_s_h(out0, 5);
82    out[96] = __msa_copy_s_h(out1, 1);
<span onclick='openModal()' class='match'>83    out[112] = __msa_copy_s_h(out1, 5);
84    out[128] = __msa_copy_s_h(out0, 2);
85    out[144] = __msa_copy_s_h(out0, 6);
86    out[160] = __msa_copy_s_h(out1, 2);
87    out[176] = __msa_copy_s_h(out1, 6);
88    out[192] = __msa_copy_s_h(out0, 3);
89    out[208] = __msa_copy_s_h(out0, 7);
90    out[224] = __msa_copy_s_h(out1, 3);
91    out[240] = __msa_copy_s_h(out1, 7);
92  }
</span>93  static void TransformDC(const int16_t* in, uint8_t* dst) {
94    const int DC = (in[0] + 4) >> 3;
95    const v8i16 tmp0 = __msa_fill_h(DC);
96    ADDBLK_ST4x4_UB(tmp0, tmp0, tmp0, tmp0, dst, BPS);
97  }
98  static void TransformAC3(const int16_t* in, uint8_t* dst) {
99    const int a = in[0] + 4;
100    const int c4 = MULT2(in[4]);
101    const int d4 = MULT1(in[4]);
102    const int in2 = MULT2(in[1]);
103    const int in3 = MULT1(in[1]);
104    v4i32 tmp0 = { 0 };
105    v4i32 out0 = __msa_fill_w(a + d4);
106    v4i32 out1 = __msa_fill_w(a + c4);
107    v4i32 out2 = __msa_fill_w(a - c4);
108    v4i32 out3 = __msa_fill_w(a - d4);
109    v4i32 res0, res1, res2, res3;
110    const v4i32 zero = { 0 };
111    v16u8 dest0, dest1, dest2, dest3;
112    INSERT_W4_SW(in3, in2, -in2, -in3, tmp0);
113    ADD4(out0, tmp0, out1, tmp0, out2, tmp0, out3, tmp0,
114         out0, out1, out2, out3);
115    SRAI_W4_SW(out0, out1, out2, out3, 3);
116    LD_UB4(dst, BPS, dest0, dest1, dest2, dest3);
117    ILVR_B4_SW(zero, dest0, zero, dest1, zero, dest2, zero, dest3,
118               res0, res1, res2, res3);
119    ILVR_H4_SW(zero, res0, zero, res1, zero, res2, zero, res3,
120               res0, res1, res2, res3);
121    ADD4(res0, out0, res1, out1, res2, out2, res3, out3, res0, res1, res2, res3);
122    CLIP_SW4_0_255(res0, res1, res2, res3);
123    PCKEV_B2_SW(res0, res1, res2, res3, out0, out1);
124    res0 = (v4i32)__msa_pckev_b((v16i8)out0, (v16i8)out1);
125    ST4x4_UB(res0, res0, 3, 2, 1, 0, dst, BPS);
126  }
127  #define FLIP_SIGN2(in0, in1, out0, out1) {  \
128    out0 = (v16i8)__msa_xori_b(in0, 0x80);    \
129    out1 = (v16i8)__msa_xori_b(in1, 0x80);    \
130  }
131  #define FLIP_SIGN4(in0, in1, in2, in3, out0, out1, out2, out3) {  \
132    FLIP_SIGN2(in0, in1, out0, out1);                               \
133    FLIP_SIGN2(in2, in3, out2, out3);                               \
134  }
135  #define FILT_VAL(q0_m, p0_m, mask, filt) do {  \
136    v16i8 q0_sub_p0;                             \
137    q0_sub_p0 = __msa_subs_s_b(q0_m, p0_m);      \
138    filt = __msa_adds_s_b(filt, q0_sub_p0);      \
139    filt = __msa_adds_s_b(filt, q0_sub_p0);      \
140    filt = __msa_adds_s_b(filt, q0_sub_p0);      \
141    filt = filt & mask;                          \
142  } while (0)
143  #define FILT2(q_m, p_m, q, p) do {            \
144    u_r = SRAI_H(temp1, 7);                     \
145    u_r = __msa_sat_s_h(u_r, 7);                \
146    u_l = SRAI_H(temp3, 7);                     \
147    u_l = __msa_sat_s_h(u_l, 7);                \
148    u = __msa_pckev_b((v16i8)u_l, (v16i8)u_r);  \
149    q_m = __msa_subs_s_b(q_m, u);               \
150    p_m = __msa_adds_s_b(p_m, u);               \
151    q = __msa_xori_b((v16u8)q_m, 0x80);         \
152    p = __msa_xori_b((v16u8)p_m, 0x80);         \
153  } while (0)
154  #define LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev) do {  \
155    v16i8 p1_m, p0_m, q0_m, q1_m;                         \
156    v16i8 filt, t1, t2;                                   \
157    const v16i8 cnst4b = __msa_ldi_b(4);                  \
158    const v16i8 cnst3b = __msa_ldi_b(3);                  \
159                                                          \
160    FLIP_SIGN4(p1, p0, q0, q1, p1_m, p0_m, q0_m, q1_m);   \
161    filt = __msa_subs_s_b(p1_m, q1_m);                    \
162    filt = filt & hev;                                    \
163    FILT_VAL(q0_m, p0_m, mask, filt);                     \
164    t1 = __msa_adds_s_b(filt, cnst4b);                    \
165    t1 = SRAI_B(t1, 3);                                   \
166    t2 = __msa_adds_s_b(filt, cnst3b);                    \
167    t2 = SRAI_B(t2, 3);                                   \
168    q0_m = __msa_subs_s_b(q0_m, t1);                      \
169    q0 = __msa_xori_b((v16u8)q0_m, 0x80);                 \
170    p0_m = __msa_adds_s_b(p0_m, t2);                      \
171    p0 = __msa_xori_b((v16u8)p0_m, 0x80);                 \
172    filt = __msa_srari_b(t1, 1);                          \
173    hev = __msa_xori_b(hev, 0xff);                        \
174    filt = filt & hev;                                    \
175    q1_m = __msa_subs_s_b(q1_m, filt);                    \
176    q1 = __msa_xori_b((v16u8)q1_m, 0x80);                 \
177    p1_m = __msa_adds_s_b(p1_m, filt);                    \
178    p1 = __msa_xori_b((v16u8)p1_m, 0x80);                 \
179  } while (0)
180  #define LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev) do {  \
181    v16i8 p2_m, p1_m, p0_m, q2_m, q1_m, q0_m;                   \
182    v16i8 u, filt, t1, t2, filt_sign;                           \
183    v8i16 filt_r, filt_l, u_r, u_l;                             \
184    v8i16 temp0, temp1, temp2, temp3;                           \
185    const v16i8 cnst4b = __msa_ldi_b(4);                        \
186    const v16i8 cnst3b = __msa_ldi_b(3);                        \
187    const v8i16 cnst9h = __msa_ldi_h(9);                        \
188    const v8i16 cnst63h = __msa_ldi_h(63);                      \
189                                                                \
190    FLIP_SIGN4(p1, p0, q0, q1, p1_m, p0_m, q0_m, q1_m);         \
191    filt = __msa_subs_s_b(p1_m, q1_m);                          \
192    FILT_VAL(q0_m, p0_m, mask, filt);                           \
193    FLIP_SIGN2(p2, q2, p2_m, q2_m);                             \
194    t2 = filt & hev;                                            \
195                                          \
196    hev = __msa_xori_b(hev, 0xff);                              \
197    filt = filt & hev;                                          \
198    t1 = __msa_adds_s_b(t2, cnst4b);                            \
199    t1 = SRAI_B(t1, 3);                                         \
200    t2 = __msa_adds_s_b(t2, cnst3b);                            \
201    t2 = SRAI_B(t2, 3);                                         \
202    q0_m = __msa_subs_s_b(q0_m, t1);                            \
203    p0_m = __msa_adds_s_b(p0_m, t2);                            \
204    filt_sign = __msa_clti_s_b(filt, 0);                        \
205    ILVRL_B2_SH(filt_sign, filt, filt_r, filt_l);               \
206                                              \
207    temp0 = filt_r * cnst9h;                                    \
208    temp1 = temp0 + cnst63h;                                    \
209    temp2 = filt_l * cnst9h;                                    \
210    temp3 = temp2 + cnst63h;                                    \
211    FILT2(q2_m, p2_m, q2, p2);                                  \
212                                              \
213    temp1 = temp1 + temp0;                                      \
214    temp3 = temp3 + temp2;                                      \
215    FILT2(q1_m, p1_m, q1, p1);                                  \
216                                              \
217    temp1 = temp1 + temp0;                                      \
218    temp3 = temp3 + temp2;                                      \
219    FILT2(q0_m, p0_m, q0, p0);                                  \
220  } while (0)
221  #define LPF_MASK_HEV(p3_in, p2_in, p1_in, p0_in,                 \
222                       q0_in, q1_in, q2_in, q3_in,                 \
223                       limit_in, b_limit_in, thresh_in,            \
224                       hev_out, mask_out) do {                     \
225    v16u8 p3_asub_p2_m, p2_asub_p1_m, p1_asub_p0_m, q1_asub_q0_m;  \
226    v16u8 p1_asub_q1_m, p0_asub_q0_m, q3_asub_q2_m, q2_asub_q1_m;  \
227    v16u8 flat_out;                                                \
228                                                                   \
229                         \
230    p3_asub_p2_m = __msa_asub_u_b(p3_in, p2_in);                   \
231    p2_asub_p1_m = __msa_asub_u_b(p2_in, p1_in);                   \
232    p1_asub_p0_m = __msa_asub_u_b(p1_in, p0_in);                   \
233    q1_asub_q0_m = __msa_asub_u_b(q1_in, q0_in);                   \
234    q2_asub_q1_m = __msa_asub_u_b(q2_in, q1_in);                   \
235    q3_asub_q2_m = __msa_asub_u_b(q3_in, q2_in);                   \
236    p0_asub_q0_m = __msa_asub_u_b(p0_in, q0_in);                   \
237    p1_asub_q1_m = __msa_asub_u_b(p1_in, q1_in);                   \
238                                           \
239    flat_out = __msa_max_u_b(p1_asub_p0_m, q1_asub_q0_m);          \
240    hev_out = (thresh_in < flat_out);                              \
241                                          \
242    p0_asub_q0_m = __msa_adds_u_b(p0_asub_q0_m, p0_asub_q0_m);     \
243    p1_asub_q1_m = SRAI_B(p1_asub_q1_m, 1);                        \
244    p0_asub_q0_m = __msa_adds_u_b(p0_asub_q0_m, p1_asub_q1_m);     \
245    mask_out = (b_limit_in < p0_asub_q0_m);                        \
246    mask_out = __msa_max_u_b(flat_out, mask_out);                  \
247    p3_asub_p2_m = __msa_max_u_b(p3_asub_p2_m, p2_asub_p1_m);      \
248    mask_out = __msa_max_u_b(p3_asub_p2_m, mask_out);              \
249    q2_asub_q1_m = __msa_max_u_b(q2_asub_q1_m, q3_asub_q2_m);      \
250    mask_out = __msa_max_u_b(q2_asub_q1_m, mask_out);              \
251    mask_out = (limit_in < mask_out);                              \
252    mask_out = __msa_xori_b(mask_out, 0xff);                       \
253  } while (0)
254  #define ST6x1_UB(in0, in0_idx, in1, in1_idx, pdst, stride) do { \
255    const uint16_t tmp0_h = __msa_copy_s_h((v8i16)in1, in1_idx);  \
256    const uint32_t tmp0_w = __msa_copy_s_w((v4i32)in0, in0_idx);  \
257    SW(tmp0_w, pdst);                                             \
258    SH(tmp0_h, pdst + stride);                                    \
259  } while (0)
260  #define ST6x4_UB(in0, start_in0_idx, in1, start_in1_idx, pdst, stride) do { \
261    uint8_t* ptmp1 = (uint8_t*)pdst;                                          \
262    ST6x1_UB(in0, start_in0_idx, in1, start_in1_idx, ptmp1, 4);               \
263    ptmp1 += stride;                                                          \
264    ST6x1_UB(in0, start_in0_idx + 1, in1, start_in1_idx + 1, ptmp1, 4);       \
265    ptmp1 += stride;                                                          \
266    ST6x1_UB(in0, start_in0_idx + 2, in1, start_in1_idx + 2, ptmp1, 4);       \
267    ptmp1 += stride;                                                          \
268    ST6x1_UB(in0, start_in0_idx + 3, in1, start_in1_idx + 3, ptmp1, 4);       \
269  } while (0)
270  #define LPF_SIMPLE_FILT(p1_in, p0_in, q0_in, q1_in, mask) do {       \
271      v16i8 p1_m, p0_m, q0_m, q1_m, filt, filt1, filt2;                \
272      const v16i8 cnst4b = __msa_ldi_b(4);                             \
273      const v16i8 cnst3b =  __msa_ldi_b(3);                            \
274                                                                       \
275      FLIP_SIGN4(p1_in, p0_in, q0_in, q1_in, p1_m, p0_m, q0_m, q1_m);  \
276      filt = __msa_subs_s_b(p1_m, q1_m);                               \
277      FILT_VAL(q0_m, p0_m, mask, filt);                                \
278      filt1 = __msa_adds_s_b(filt, cnst4b);                            \
279      filt1 = SRAI_B(filt1, 3);                                        \
280      filt2 = __msa_adds_s_b(filt, cnst3b);                            \
281      filt2 = SRAI_B(filt2, 3);                                        \
282      q0_m = __msa_subs_s_b(q0_m, filt1);                              \
283      p0_m = __msa_adds_s_b(p0_m, filt2);                              \
284      q0_in = __msa_xori_b((v16u8)q0_m, 0x80);                         \
285      p0_in = __msa_xori_b((v16u8)p0_m, 0x80);                         \
286  } while (0)
287  #define LPF_SIMPLE_MASK(p1, p0, q0, q1, b_limit, mask) do {    \
288      v16u8 p1_a_sub_q1, p0_a_sub_q0;                            \
289                                                                 \
290      p0_a_sub_q0 = __msa_asub_u_b(p0, q0);                      \
291      p1_a_sub_q1 = __msa_asub_u_b(p1, q1);                      \
292      p1_a_sub_q1 = (v16u8)__msa_srli_b((v16i8)p1_a_sub_q1, 1);  \
293      p0_a_sub_q0 = __msa_adds_u_b(p0_a_sub_q0, p0_a_sub_q0);    \
294      mask = __msa_adds_u_b(p0_a_sub_q0, p1_a_sub_q1);           \
295      mask = (mask <= b_limit);                                  \
296  } while (0)
297  static void VFilter16(uint8_t* src, int stride,
298                        int b_limit_in, int limit_in, int thresh_in) {
299    uint8_t* ptemp = src - 4 * stride;
300    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
301    v16u8 mask, hev;
302    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
303    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
304    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
305    LD_UB8(ptemp, stride, p3, p2, p1, p0, q0, q1, q2, q3);
306    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
307                 hev, mask);
308    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
309    ptemp = src - 3 * stride;
310    ST_UB4(p2, p1, p0, q0, ptemp, stride);
311    ptemp += (4 * stride);
312    ST_UB2(q1, q2, ptemp, stride);
313  }
314  static void HFilter16(uint8_t* src, int stride,
315                        int b_limit_in, int limit_in, int thresh_in) {
316    uint8_t* ptmp  = src - 4;
317    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
318    v16u8 mask, hev;
319    v16u8 row0, row1, row2, row3, row4, row5, row6, row7, row8;
320    v16u8 row9, row10, row11, row12, row13, row14, row15;
321    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
322    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
323    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
324    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
325    LD_UB8(ptmp, stride, row0, row1, row2, row3, row4, row5, row6, row7);
326    ptmp += (8 * stride);
327    LD_UB8(ptmp, stride, row8, row9, row10, row11, row12, row13, row14, row15);
328    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
329                        row8, row9, row10, row11, row12, row13, row14, row15,
330                        p3, p2, p1, p0, q0, q1, q2, q3);
331    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
332                 hev, mask);
333    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
334    ILVR_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
335    ILVRL_H2_SH(tmp1, tmp0, tmp3, tmp4);
336    ILVL_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
337    ILVRL_H2_SH(tmp1, tmp0, tmp6, tmp7);
338    ILVRL_B2_SH(q2, q1, tmp2, tmp5);
339    ptmp = src - 3;
340    ST6x1_UB(tmp3, 0, tmp2, 0, ptmp, 4);
341    ptmp += stride;
342    ST6x1_UB(tmp3, 1, tmp2, 1, ptmp, 4);
343    ptmp += stride;
344    ST6x1_UB(tmp3, 2, tmp2, 2, ptmp, 4);
345    ptmp += stride;
346    ST6x1_UB(tmp3, 3, tmp2, 3, ptmp, 4);
347    ptmp += stride;
348    ST6x1_UB(tmp4, 0, tmp2, 4, ptmp, 4);
349    ptmp += stride;
350    ST6x1_UB(tmp4, 1, tmp2, 5, ptmp, 4);
351    ptmp += stride;
352    ST6x1_UB(tmp4, 2, tmp2, 6, ptmp, 4);
353    ptmp += stride;
354    ST6x1_UB(tmp4, 3, tmp2, 7, ptmp, 4);
355    ptmp += stride;
356    ST6x1_UB(tmp6, 0, tmp5, 0, ptmp, 4);
357    ptmp += stride;
358    ST6x1_UB(tmp6, 1, tmp5, 1, ptmp, 4);
359    ptmp += stride;
360    ST6x1_UB(tmp6, 2, tmp5, 2, ptmp, 4);
361    ptmp += stride;
362    ST6x1_UB(tmp6, 3, tmp5, 3, ptmp, 4);
363    ptmp += stride;
364    ST6x1_UB(tmp7, 0, tmp5, 4, ptmp, 4);
365    ptmp += stride;
366    ST6x1_UB(tmp7, 1, tmp5, 5, ptmp, 4);
367    ptmp += stride;
368    ST6x1_UB(tmp7, 2, tmp5, 6, ptmp, 4);
369    ptmp += stride;
370    ST6x1_UB(tmp7, 3, tmp5, 7, ptmp, 4);
371  }
372  static void VFilterHorEdge16i(uint8_t* src, int stride,
373                                int b_limit, int limit, int thresh) {
374    v16u8 mask, hev;
375    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
376    const v16u8 thresh0 = (v16u8)__msa_fill_b(thresh);
377    const v16u8 b_limit0 = (v16u8)__msa_fill_b(b_limit);
378    const v16u8 limit0 = (v16u8)__msa_fill_b(limit);
379    LD_UB8((src - 4 * stride), stride, p3, p2, p1, p0, q0, q1, q2, q3);
380    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit0, b_limit0, thresh0,
381                 hev, mask);
382    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
383    ST_UB4(p1, p0, q0, q1, (src - 2 * stride), stride);
384  }
385  static void VFilter16i(uint8_t* src_y, int stride,
386                         int b_limit, int limit, int thresh) {
387    VFilterHorEdge16i(src_y +  4 * stride, stride, b_limit, limit, thresh);
388    VFilterHorEdge16i(src_y +  8 * stride, stride, b_limit, limit, thresh);
389    VFilterHorEdge16i(src_y + 12 * stride, stride, b_limit, limit, thresh);
390  }
391  static void HFilterVertEdge16i(uint8_t* src, int stride,
392                                 int b_limit, int limit, int thresh) {
393    v16u8 mask, hev;
394    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
395    v16u8 row0, row1, row2, row3, row4, row5, row6, row7;
396    v16u8 row8, row9, row10, row11, row12, row13, row14, row15;
397    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
398    const v16u8 thresh0 = (v16u8)__msa_fill_b(thresh);
399    const v16u8 b_limit0 = (v16u8)__msa_fill_b(b_limit);
400    const v16u8 limit0 = (v16u8)__msa_fill_b(limit);
401    LD_UB8(src - 4, stride, row0, row1, row2, row3, row4, row5, row6, row7);
402    LD_UB8(src - 4 + (8 * stride), stride,
403           row8, row9, row10, row11, row12, row13, row14, row15);
404    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
405                        row8, row9, row10, row11, row12, row13, row14, row15,
406                        p3, p2, p1, p0, q0, q1, q2, q3);
407    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit0, b_limit0, thresh0,
408                 hev, mask);
409    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
410    ILVR_B2_SH(p0, p1, q1, q0, tmp0, tmp1);
411    ILVRL_H2_SH(tmp1, tmp0, tmp2, tmp3);
412    ILVL_B2_SH(p0, p1, q1, q0, tmp0, tmp1);
413    ILVRL_H2_SH(tmp1, tmp0, tmp4, tmp5);
414    src -= 2;
415    ST4x8_UB(tmp2, tmp3, src, stride);
416    src += (8 * stride);
417    ST4x8_UB(tmp4, tmp5, src, stride);
418  }
419  static void HFilter16i(uint8_t* src_y, int stride,
420                         int b_limit, int limit, int thresh) {
421    HFilterVertEdge16i(src_y +  4, stride, b_limit, limit, thresh);
422    HFilterVertEdge16i(src_y +  8, stride, b_limit, limit, thresh);
423    HFilterVertEdge16i(src_y + 12, stride, b_limit, limit, thresh);
424  }
425  static void VFilter8(uint8_t* src_u, uint8_t* src_v, int stride,
426                       int b_limit_in, int limit_in, int thresh_in) {
427    uint8_t* ptmp_src_u = src_u - 4 * stride;
428    uint8_t* ptmp_src_v = src_v - 4 * stride;
429    uint64_t p2_d, p1_d, p0_d, q0_d, q1_d, q2_d;
430    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
431    v16u8 p3_u, p2_u, p1_u, p0_u, q3_u, q2_u, q1_u, q0_u;
432    v16u8 p3_v, p2_v, p1_v, p0_v, q3_v, q2_v, q1_v, q0_v;
433    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
434    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
435    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
436    LD_UB8(ptmp_src_u, stride, p3_u, p2_u, p1_u, p0_u, q0_u, q1_u, q2_u, q3_u);
437    LD_UB8(ptmp_src_v, stride, p3_v, p2_v, p1_v, p0_v, q0_v, q1_v, q2_v, q3_v);
438    ILVR_D4_UB(p3_v, p3_u, p2_v, p2_u, p1_v, p1_u, p0_v, p0_u, p3, p2, p1, p0);
439    ILVR_D4_UB(q0_v, q0_u, q1_v, q1_u, q2_v, q2_u, q3_v, q3_u, q0, q1, q2, q3);
440    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
441                 hev, mask);
442    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
443    p2_d = __msa_copy_s_d((v2i64)p2, 0);
444    p1_d = __msa_copy_s_d((v2i64)p1, 0);
445    p0_d = __msa_copy_s_d((v2i64)p0, 0);
446    q0_d = __msa_copy_s_d((v2i64)q0, 0);
447    q1_d = __msa_copy_s_d((v2i64)q1, 0);
448    q2_d = __msa_copy_s_d((v2i64)q2, 0);
449    ptmp_src_u += stride;
450    SD4(p2_d, p1_d, p0_d, q0_d, ptmp_src_u, stride);
451    ptmp_src_u += (4 * stride);
452    SD(q1_d, ptmp_src_u);
453    ptmp_src_u += stride;
454    SD(q2_d, ptmp_src_u);
455    p2_d = __msa_copy_s_d((v2i64)p2, 1);
456    p1_d = __msa_copy_s_d((v2i64)p1, 1);
457    p0_d = __msa_copy_s_d((v2i64)p0, 1);
458    q0_d = __msa_copy_s_d((v2i64)q0, 1);
459    q1_d = __msa_copy_s_d((v2i64)q1, 1);
460    q2_d = __msa_copy_s_d((v2i64)q2, 1);
461    ptmp_src_v += stride;
462    SD4(p2_d, p1_d, p0_d, q0_d, ptmp_src_v, stride);
463    ptmp_src_v += (4 * stride);
464    SD(q1_d, ptmp_src_v);
465    ptmp_src_v += stride;
466    SD(q2_d, ptmp_src_v);
467  }
468  static void HFilter8(uint8_t* src_u, uint8_t* src_v, int stride,
469                       int b_limit_in, int limit_in, int thresh_in) {
470    uint8_t* ptmp_src_u = src_u - 4;
471    uint8_t* ptmp_src_v = src_v - 4;
472    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
473    v16u8 row0, row1, row2, row3, row4, row5, row6, row7, row8;
474    v16u8 row9, row10, row11, row12, row13, row14, row15;
475    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
476    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
477    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
478    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
479    LD_UB8(ptmp_src_u, stride, row0, row1, row2, row3, row4, row5, row6, row7);
480    LD_UB8(ptmp_src_v, stride,
481           row8, row9, row10, row11, row12, row13, row14, row15);
482    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
483                        row8, row9, row10, row11, row12, row13, row14, row15,
484                        p3, p2, p1, p0, q0, q1, q2, q3);
485    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
486                 hev, mask);
487    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
488    ILVR_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
489    ILVRL_H2_SH(tmp1, tmp0, tmp3, tmp4);
490    ILVL_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
491    ILVRL_H2_SH(tmp1, tmp0, tmp6, tmp7);
492    ILVRL_B2_SH(q2, q1, tmp2, tmp5);
493    ptmp_src_u += 1;
494    ST6x4_UB(tmp3, 0, tmp2, 0, ptmp_src_u, stride);
495    ptmp_src_u += 4 * stride;
496    ST6x4_UB(tmp4, 0, tmp2, 4, ptmp_src_u, stride);
497    ptmp_src_v += 1;
498    ST6x4_UB(tmp6, 0, tmp5, 0, ptmp_src_v, stride);
499    ptmp_src_v += 4 * stride;
500    ST6x4_UB(tmp7, 0, tmp5, 4, ptmp_src_v, stride);
501  }
502  static void VFilter8i(uint8_t* src_u, uint8_t* src_v, int stride,
503                        int b_limit_in, int limit_in, int thresh_in) {
504    uint64_t p1_d, p0_d, q0_d, q1_d;
505    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
506    v16u8 p3_u, p2_u, p1_u, p0_u, q3_u, q2_u, q1_u, q0_u;
507    v16u8 p3_v, p2_v, p1_v, p0_v, q3_v, q2_v, q1_v, q0_v;
508    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
509    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
510    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
511    LD_UB8(src_u, stride, p3_u, p2_u, p1_u, p0_u, q0_u, q1_u, q2_u, q3_u);
512    src_u += (5 * stride);
513    LD_UB8(src_v, stride, p3_v, p2_v, p1_v, p0_v, q0_v, q1_v, q2_v, q3_v);
514    src_v += (5 * stride);
515    ILVR_D4_UB(p3_v, p3_u, p2_v, p2_u, p1_v, p1_u, p0_v, p0_u, p3, p2, p1, p0);
516    ILVR_D4_UB(q0_v, q0_u, q1_v, q1_u, q2_v, q2_u, q3_v, q3_u, q0, q1, q2, q3);
517    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
518                 hev, mask);
519    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
520    p1_d = __msa_copy_s_d((v2i64)p1, 0);
521    p0_d = __msa_copy_s_d((v2i64)p0, 0);
522    q0_d = __msa_copy_s_d((v2i64)q0, 0);
523    q1_d = __msa_copy_s_d((v2i64)q1, 0);
524    SD4(q1_d, q0_d, p0_d, p1_d, src_u, -stride);
525    p1_d = __msa_copy_s_d((v2i64)p1, 1);
526    p0_d = __msa_copy_s_d((v2i64)p0, 1);
527    q0_d = __msa_copy_s_d((v2i64)q0, 1);
528    q1_d = __msa_copy_s_d((v2i64)q1, 1);
529    SD4(q1_d, q0_d, p0_d, p1_d, src_v, -stride);
530  }
531  static void HFilter8i(uint8_t* src_u, uint8_t* src_v, int stride,
532                        int b_limit_in, int limit_in, int thresh_in) {
533    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
534    v16u8 row0, row1, row2, row3, row4, row5, row6, row7, row8;
535    v16u8 row9, row10, row11, row12, row13, row14, row15;
536    v4i32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
537    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
538    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
539    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
540    LD_UB8(src_u, stride, row0, row1, row2, row3, row4, row5, row6, row7);
541    LD_UB8(src_v, stride,
542           row8, row9, row10, row11, row12, row13, row14, row15);
543    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
544                        row8, row9, row10, row11, row12, row13, row14, row15,
545                        p3, p2, p1, p0, q0, q1, q2, q3);
546    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
547                 hev, mask);
548    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
549    ILVR_B2_SW(p0, p1, q1, q0, tmp0, tmp1);
550    ILVRL_H2_SW(tmp1, tmp0, tmp2, tmp3);
551    ILVL_B2_SW(p0, p1, q1, q0, tmp0, tmp1);
552    ILVRL_H2_SW(tmp1, tmp0, tmp4, tmp5);
553    src_u += 2;
554    ST4x4_UB(tmp2, tmp2, 0, 1, 2, 3, src_u, stride);
555    src_u += 4 * stride;
556    ST4x4_UB(tmp3, tmp3, 0, 1, 2, 3, src_u, stride);
557    src_v += 2;
558    ST4x4_UB(tmp4, tmp4, 0, 1, 2, 3, src_v, stride);
559    src_v += 4 * stride;
560    ST4x4_UB(tmp5, tmp5, 0, 1, 2, 3, src_v, stride);
561  }
562  static void SimpleVFilter16(uint8_t* src, int stride, int b_limit_in) {
563    v16u8 p1, p0, q1, q0, mask;
564    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
565    LD_UB4(src - 2 * stride, stride, p1, p0, q0, q1);
566    LPF_SIMPLE_MASK(p1, p0, q0, q1, b_limit, mask);
567    LPF_SIMPLE_FILT(p1, p0, q0, q1, mask);
568    ST_UB2(p0, q0, src - stride, stride);
569  }
570  static void SimpleHFilter16(uint8_t* src, int stride, int b_limit_in) {
571    v16u8 p1, p0, q1, q0, mask, row0, row1, row2, row3, row4, row5, row6, row7;
572    v16u8 row8, row9, row10, row11, row12, row13, row14, row15;
573    v8i16 tmp0, tmp1;
574    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
575    uint8_t* ptemp_src = src - 2;
576    LD_UB8(ptemp_src, stride, row0, row1, row2, row3, row4, row5, row6, row7);
577    LD_UB8(ptemp_src + 8 * stride, stride,
578           row8, row9, row10, row11, row12, row13, row14, row15);
579    TRANSPOSE16x4_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
580                        row8, row9, row10, row11, row12, row13, row14, row15,
581                        p1, p0, q0, q1);
582    LPF_SIMPLE_MASK(p1, p0, q0, q1, b_limit, mask);
583    LPF_SIMPLE_FILT(p1, p0, q0, q1, mask);
584    ILVRL_B2_SH(q0, p0, tmp1, tmp0);
585    ptemp_src += 1;
586    ST2x4_UB(tmp1, 0, ptemp_src, stride);
587    ptemp_src += 4 * stride;
588    ST2x4_UB(tmp1, 4, ptemp_src, stride);
589    ptemp_src += 4 * stride;
590    ST2x4_UB(tmp0, 0, ptemp_src, stride);
591    ptemp_src += 4 * stride;
592    ST2x4_UB(tmp0, 4, ptemp_src, stride);
593    ptemp_src += 4 * stride;
594  }
595  static void SimpleVFilter16i(uint8_t* src_y, int stride, int b_limit_in) {
596    SimpleVFilter16(src_y +  4 * stride, stride, b_limit_in);
597    SimpleVFilter16(src_y +  8 * stride, stride, b_limit_in);
598    SimpleVFilter16(src_y + 12 * stride, stride, b_limit_in);
599  }
600  static void SimpleHFilter16i(uint8_t* src_y, int stride, int b_limit_in) {
601    SimpleHFilter16(src_y +  4, stride, b_limit_in);
602    SimpleHFilter16(src_y +  8, stride, b_limit_in);
603    SimpleHFilter16(src_y + 12, stride, b_limit_in);
604  }
605  static void DC4(uint8_t* dst) {   
606    uint32_t dc = 4;
607    int i;
608    for (i = 0; i < 4; ++i) dc += dst[i - BPS] + dst[-1 + i * BPS];
609    dc >>= 3;
610    dc = dc | (dc << 8) | (dc << 16) | (dc << 24);
611    SW4(dc, dc, dc, dc, dst, BPS);
612  }
613  static void TM4(uint8_t* dst) {
614    const uint8_t* const ptemp = dst - BPS - 1;
615    v8i16 T, d, r0, r1, r2, r3;
616    const v16i8 zero = { 0 };
617    const v8i16 TL = (v8i16)__msa_fill_h(ptemp[0 * BPS]);
618    const v8i16 L0 = (v8i16)__msa_fill_h(ptemp[1 * BPS]);
619    const v8i16 L1 = (v8i16)__msa_fill_h(ptemp[2 * BPS]);
620    const v8i16 L2 = (v8i16)__msa_fill_h(ptemp[3 * BPS]);
621    const v8i16 L3 = (v8i16)__msa_fill_h(ptemp[4 * BPS]);
622    const v16u8 T1 = LD_UB(ptemp + 1);
623    T  = (v8i16)__msa_ilvr_b(zero, (v16i8)T1);
624    d = T - TL;
625    ADD4(d, L0, d, L1, d, L2, d, L3, r0, r1, r2, r3);
626    CLIP_SH4_0_255(r0, r1, r2, r3);
627    PCKEV_ST4x4_UB(r0, r1, r2, r3, dst, BPS);
628  }
629  static void VE4(uint8_t* dst) {    
630    const uint8_t* const ptop = dst - BPS - 1;
631    const uint32_t val0 = LW(ptop + 0);
632    const uint32_t val1 = LW(ptop + 4);
633    uint32_t out;
634    v16u8 A = { 0 }, B, C, AC, B2, R;
635    INSERT_W2_UB(val0, val1, A);
636    B = SLDI_UB(A, A, 1);
637    C = SLDI_UB(A, A, 2);
638    AC = __msa_ave_u_b(A, C);
639    B2 = __msa_ave_u_b(B, B);
640    R = __msa_aver_u_b(AC, B2);
641    out = __msa_copy_s_w((v4i32)R, 0);
642    SW4(out, out, out, out, dst, BPS);
643  }
644  static void RD4(uint8_t* dst) {   
645    const uint8_t* const ptop = dst - 1 - BPS;
646    uint32_t val0 = LW(ptop + 0);
647    uint32_t val1 = LW(ptop + 4);
648    uint32_t val2, val3;
649    v16u8 A, B, C, AC, B2, R, A1 = { 0 };
650    INSERT_W2_UB(val0, val1, A1);
651    A = SLDI_UB(A1, A1, 12);
652    A = (v16u8)__msa_insert_b((v16i8)A, 3, ptop[1 * BPS]);
653    A = (v16u8)__msa_insert_b((v16i8)A, 2, ptop[2 * BPS]);
654    A = (v16u8)__msa_insert_b((v16i8)A, 1, ptop[3 * BPS]);
655    A = (v16u8)__msa_insert_b((v16i8)A, 0, ptop[4 * BPS]);
656    B = SLDI_UB(A, A, 1);
657    C = SLDI_UB(A, A, 2);
658    AC = __msa_ave_u_b(A, C);
659    B2 = __msa_ave_u_b(B, B);
660    R = __msa_aver_u_b(AC, B2);
661    val3 = __msa_copy_s_w((v4i32)R, 0);
662    R = SLDI_UB(R, R, 1);
663    val2 = __msa_copy_s_w((v4i32)R, 0);
664    R = SLDI_UB(R, R, 1);
665    val1 = __msa_copy_s_w((v4i32)R, 0);
666    R = SLDI_UB(R, R, 1);
667    val0 = __msa_copy_s_w((v4i32)R, 0);
668    SW4(val0, val1, val2, val3, dst, BPS);
669  }
670  static void LD4(uint8_t* dst) {   
671    const uint8_t* const ptop = dst - BPS;
672    uint32_t val0 = LW(ptop + 0);
673    uint32_t val1 = LW(ptop + 4);
674    uint32_t val2, val3;
675    v16u8 A = { 0 }, B, C, AC, B2, R;
676    INSERT_W2_UB(val0, val1, A);
677    B = SLDI_UB(A, A, 1);
678    C = SLDI_UB(A, A, 2);
679    C = (v16u8)__msa_insert_b((v16i8)C, 6, ptop[7]);
680    AC = __msa_ave_u_b(A, C);
681    B2 = __msa_ave_u_b(B, B);
682    R = __msa_aver_u_b(AC, B2);
683    val0 = __msa_copy_s_w((v4i32)R, 0);
684    R = SLDI_UB(R, R, 1);
685    val1 = __msa_copy_s_w((v4i32)R, 0);
686    R = SLDI_UB(R, R, 1);
687    val2 = __msa_copy_s_w((v4i32)R, 0);
688    R = SLDI_UB(R, R, 1);
689    val3 = __msa_copy_s_w((v4i32)R, 0);
690    SW4(val0, val1, val2, val3, dst, BPS);
691  }
692  static void DC16(uint8_t* dst) {   
693    uint32_t dc = 16;
694    int i;
695    const v16u8 rtop = LD_UB(dst - BPS);
696    const v8u16 dctop = __msa_hadd_u_h(rtop, rtop);
697    v16u8 out;
698    for (i = 0; i < 16; ++i) {
699      dc += dst[-1 + i * BPS];
700    }
701    dc += HADD_UH_U32(dctop);
702    out = (v16u8)__msa_fill_b(dc >> 5);
703    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
704    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
705  }
706  static void TM16(uint8_t* dst) {
707    int j;
708    v8i16 d1, d2;
709    const v16i8 zero = { 0 };
710    const v8i16 TL = (v8i16)__msa_fill_h(dst[-1 - BPS]);
711    const v16i8 T = LD_SB(dst - BPS);
712    ILVRL_B2_SH(zero, T, d1, d2);
713    SUB2(d1, TL, d2, TL, d1, d2);
714    for (j = 0; j < 16; j += 4) {
715      v16i8 t0, t1, t2, t3;
716      v8i16 r0, r1, r2, r3, r4, r5, r6, r7;
717      const v8i16 L0 = (v8i16)__msa_fill_h(dst[-1 + 0 * BPS]);
718      const v8i16 L1 = (v8i16)__msa_fill_h(dst[-1 + 1 * BPS]);
719      const v8i16 L2 = (v8i16)__msa_fill_h(dst[-1 + 2 * BPS]);
720      const v8i16 L3 = (v8i16)__msa_fill_h(dst[-1 + 3 * BPS]);
721      ADD4(d1, L0, d1, L1, d1, L2, d1, L3, r0, r1, r2, r3);
722      ADD4(d2, L0, d2, L1, d2, L2, d2, L3, r4, r5, r6, r7);
723      CLIP_SH4_0_255(r0, r1, r2, r3);
724      CLIP_SH4_0_255(r4, r5, r6, r7);
725      PCKEV_B4_SB(r4, r0, r5, r1, r6, r2, r7, r3, t0, t1, t2, t3);
726      ST_SB4(t0, t1, t2, t3, dst, BPS);
727      dst += 4 * BPS;
728    }
729  }
730  static void VE16(uint8_t* dst) {   
731    const v16u8 rtop = LD_UB(dst - BPS);
732    ST_UB8(rtop, rtop, rtop, rtop, rtop, rtop, rtop, rtop, dst, BPS);
733    ST_UB8(rtop, rtop, rtop, rtop, rtop, rtop, rtop, rtop, dst + 8 * BPS, BPS);
734  }
735  static void HE16(uint8_t* dst) {   
736    int j;
737    for (j = 16; j > 0; j -= 4) {
738      const v16u8 L0 = (v16u8)__msa_fill_b(dst[-1 + 0 * BPS]);
739      const v16u8 L1 = (v16u8)__msa_fill_b(dst[-1 + 1 * BPS]);
740      const v16u8 L2 = (v16u8)__msa_fill_b(dst[-1 + 2 * BPS]);
741      const v16u8 L3 = (v16u8)__msa_fill_b(dst[-1 + 3 * BPS]);
742      ST_UB4(L0, L1, L2, L3, dst, BPS);
743      dst += 4 * BPS;
744    }
745  }
746  static void DC16NoTop(uint8_t* dst) {   
747    int j;
748    uint32_t dc = 8;
749    v16u8 out;
750    for (j = 0; j < 16; ++j) {
751      dc += dst[-1 + j * BPS];
752    }
753    out = (v16u8)__msa_fill_b(dc >> 4);
754    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
755    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
756  }
757  static void DC16NoLeft(uint8_t* dst) {   
758    uint32_t dc = 8;
759    const v16u8 rtop = LD_UB(dst - BPS);
760    const v8u16 dctop = __msa_hadd_u_h(rtop, rtop);
761    v16u8 out;
762    dc += HADD_UH_U32(dctop);
763    out = (v16u8)__msa_fill_b(dc >> 4);
764    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
765    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
766  }
767  static void DC16NoTopLeft(uint8_t* dst) {   
768    const v16u8 out = (v16u8)__msa_fill_b(0x80);
769    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
770    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
771  }
772  #define STORE8x8(out, dst) do {                 \
773    SD4(out, out, out, out, dst + 0 * BPS, BPS);  \
774    SD4(out, out, out, out, dst + 4 * BPS, BPS);  \
775  } while (0)
776  static void DC8uv(uint8_t* dst) {   
777    uint32_t dc = 8;
778    int i;
779    uint64_t out;
780    const v16u8 rtop = LD_UB(dst - BPS);
781    const v8u16 temp0 = __msa_hadd_u_h(rtop, rtop);
782    const v4u32 temp1 = __msa_hadd_u_w(temp0, temp0);
783    const v2u64 temp2 = __msa_hadd_u_d(temp1, temp1);
784    v16u8 dctemp;
785    for (i = 0; i < 8; ++i) {
786      dc += dst[-1 + i * BPS];
787    }
788    dc += __msa_copy_s_w((v4i32)temp2, 0);
789    dctemp = (v16u8)__msa_fill_b(dc >> 4);
790    out = __msa_copy_s_d((v2i64)dctemp, 0);
791    STORE8x8(out, dst);
792  }
793  static void TM8uv(uint8_t* dst) {
794    int j;
795    const v16i8 T1 = LD_SB(dst - BPS);
796    const v16i8 zero = { 0 };
797    const v8i16 T  = (v8i16)__msa_ilvr_b(zero, T1);
798    const v8i16 TL = (v8i16)__msa_fill_h(dst[-1 - BPS]);
799    const v8i16 d = T - TL;
800    for (j = 0; j < 8; j += 4) {
801      v16i8 t0, t1;
802      v8i16 r0 = (v8i16)__msa_fill_h(dst[-1 + 0 * BPS]);
803      v8i16 r1 = (v8i16)__msa_fill_h(dst[-1 + 1 * BPS]);
804      v8i16 r2 = (v8i16)__msa_fill_h(dst[-1 + 2 * BPS]);
805      v8i16 r3 = (v8i16)__msa_fill_h(dst[-1 + 3 * BPS]);
806      ADD4(d, r0, d, r1, d, r2, d, r3, r0, r1, r2, r3);
807      CLIP_SH4_0_255(r0, r1, r2, r3);
808      PCKEV_B2_SB(r1, r0, r3, r2, t0, t1);
809      ST4x4_UB(t0, t1, 0, 2, 0, 2, dst, BPS);
810      ST4x4_UB(t0, t1, 1, 3, 1, 3, dst + 4, BPS);
811      dst += 4 * BPS;
812    }
813  }
814  static void VE8uv(uint8_t* dst) {   
815    const v16u8 rtop = LD_UB(dst - BPS);
816    const uint64_t out = __msa_copy_s_d((v2i64)rtop, 0);
817    STORE8x8(out, dst);
818  }
819  static void HE8uv(uint8_t* dst) {   
820    int j;
821    for (j = 0; j < 8; j += 4) {
822      const v16u8 L0 = (v16u8)__msa_fill_b(dst[-1 + 0 * BPS]);
823      const v16u8 L1 = (v16u8)__msa_fill_b(dst[-1 + 1 * BPS]);
824      const v16u8 L2 = (v16u8)__msa_fill_b(dst[-1 + 2 * BPS]);
825      const v16u8 L3 = (v16u8)__msa_fill_b(dst[-1 + 3 * BPS]);
826      const uint64_t out0 = __msa_copy_s_d((v2i64)L0, 0);
827      const uint64_t out1 = __msa_copy_s_d((v2i64)L1, 0);
828      const uint64_t out2 = __msa_copy_s_d((v2i64)L2, 0);
829      const uint64_t out3 = __msa_copy_s_d((v2i64)L3, 0);
830      SD4(out0, out1, out2, out3, dst, BPS);
831      dst += 4 * BPS;
832    }
833  }
834  static void DC8uvNoLeft(uint8_t* dst) {   
835    const uint32_t dc = 4;
836    const v16u8 rtop = LD_UB(dst - BPS);
837    const v8u16 temp0 = __msa_hadd_u_h(rtop, rtop);
838    const v4u32 temp1 = __msa_hadd_u_w(temp0, temp0);
839    const v2u64 temp2 = __msa_hadd_u_d(temp1, temp1);
840    const uint32_t sum_m = __msa_copy_s_w((v4i32)temp2, 0);
841    const v16u8 dcval = (v16u8)__msa_fill_b((dc + sum_m) >> 3);
842    const uint64_t out = __msa_copy_s_d((v2i64)dcval, 0);
843    STORE8x8(out, dst);
844  }
845  static void DC8uvNoTop(uint8_t* dst) {   
846    uint32_t dc = 4;
847    int i;
848    uint64_t out;
849    v16u8 dctemp;
850    for (i = 0; i < 8; ++i) {
851      dc += dst[-1 + i * BPS];
852    }
853    dctemp = (v16u8)__msa_fill_b(dc >> 3);
854    out = __msa_copy_s_d((v2i64)dctemp, 0);
855    STORE8x8(out, dst);
856  }
857  static void DC8uvNoTopLeft(uint8_t* dst) {   
858    const uint64_t out = 0x8080808080808080ULL;
859    STORE8x8(out, dst);
860  }
861  extern void VP8DspInitMSA(void);
862  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitMSA(void) {
863    VP8TransformWHT = TransformWHT;
864    VP8Transform = TransformTwo;
865    VP8TransformDC = TransformDC;
866    VP8TransformAC3 = TransformAC3;
867    VP8VFilter16  = VFilter16;
868    VP8HFilter16  = HFilter16;
869    VP8VFilter16i = VFilter16i;
870    VP8HFilter16i = HFilter16i;
871    VP8VFilter8  = VFilter8;
872    VP8HFilter8  = HFilter8;
873    VP8VFilter8i = VFilter8i;
874    VP8HFilter8i = HFilter8i;
875    VP8SimpleVFilter16  = SimpleVFilter16;
876    VP8SimpleHFilter16  = SimpleHFilter16;
877    VP8SimpleVFilter16i = SimpleVFilter16i;
878    VP8SimpleHFilter16i = SimpleHFilter16i;
879    VP8PredLuma4[0] = DC4;
880    VP8PredLuma4[1] = TM4;
881    VP8PredLuma4[2] = VE4;
882    VP8PredLuma4[4] = RD4;
883    VP8PredLuma4[6] = LD4;
884    VP8PredLuma16[0] = DC16;
885    VP8PredLuma16[1] = TM16;
886    VP8PredLuma16[2] = VE16;
887    VP8PredLuma16[3] = HE16;
888    VP8PredLuma16[4] = DC16NoTop;
889    VP8PredLuma16[5] = DC16NoLeft;
890    VP8PredLuma16[6] = DC16NoTopLeft;
891    VP8PredChroma8[0] = DC8uv;
892    VP8PredChroma8[1] = TM8uv;
893    VP8PredChroma8[2] = VE8uv;
894    VP8PredChroma8[3] = HE8uv;
895    VP8PredChroma8[4] = DC8uvNoTop;
896    VP8PredChroma8[5] = DC8uvNoLeft;
897    VP8PredChroma8[6] = DC8uvNoTopLeft;
898  }
899  #else  
900  WEBP_DSP_INIT_STUB(VP8DspInitMSA)
901  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_sse41.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_msa.c</div>
                </div>
                <div class="column column_space"><pre><code>149      bgr0 = _mm_packus_epi16(B0, B1);
150      bgr1 = _mm_packus_epi16(B2, B3);
151      bgr2 = _mm_packus_epi16(G0, G1);
152      bgr3 = _mm_packus_epi16(G2, G3);
153      bgr4 = _mm_packus_epi16(R0, R1);
154      bgr5 = _mm_packus_epi16(R2, R3);
155      PlanarTo24b_SSE41(&bgr0, &bgr1, &bgr2, &bgr3, &bgr4, &bgr5, dst);
156      y += 32;
157      u += 16;
158      v += 16;
159    }
</pre></code></div>
                <div class="column column_space"><pre><code>83    out[112] = __msa_copy_s_h(out1, 5);
84    out[128] = __msa_copy_s_h(out0, 2);
85    out[144] = __msa_copy_s_h(out0, 6);
86    out[160] = __msa_copy_s_h(out1, 2);
87    out[176] = __msa_copy_s_h(out1, 6);
88    out[192] = __msa_copy_s_h(out0, 3);
89    out[208] = __msa_copy_s_h(out0, 7);
90    out[224] = __msa_copy_s_h(out1, 3);
91    out[240] = __msa_copy_s_h(out1, 7);
92  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    