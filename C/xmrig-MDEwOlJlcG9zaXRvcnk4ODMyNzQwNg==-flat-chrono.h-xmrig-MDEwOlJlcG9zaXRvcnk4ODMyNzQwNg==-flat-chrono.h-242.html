
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</h3>
            <pre><code>1  #ifndef FMT_CHRONO_H_
2  #define FMT_CHRONO_H_
3  #include &lt;chrono&gt;
4  #include &lt;ctime&gt;
5  #include &lt;locale&gt;
6  #include &lt;sstream&gt;
7  #include &quot;format.h&quot;
8  #include &quot;locale.h&quot;
9  FMT_BEGIN_NAMESPACE
10  #ifndef FMT_SAFE_DURATION_CAST
11  #  define FMT_SAFE_DURATION_CAST 1
12  #endif
13  #if FMT_SAFE_DURATION_CAST
14  namespace safe_duration_cast {
15  template &lt;typename To, typename From,
16            FMT_ENABLE_IF(!std::is_same&lt;From, To&gt;::value &amp;&amp;
17                          std::numeric_limits&lt;From&gt;::is_signed ==
18                              std::numeric_limits&lt;To&gt;::is_signed)&gt;
19  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int&amp; ec) {
20    ec = 0;
21    using F = std::numeric_limits&lt;From&gt;;
22    using T = std::numeric_limits&lt;To&gt;;
23    static_assert(F::is_integer, &quot;From must be integral&quot;);
24    static_assert(T::is_integer, &quot;To must be integral&quot;);
25    if (F::digits &lt;= T::digits) {
26    } else {
27      if (from &lt; (T::min)() || from &gt; (T::max)()) {
28        ec = 1;
29        return {};
30      }
31    }
32    return static_cast&lt;To&gt;(from);
33  }
34  template &lt;typename To, typename From,
35            FMT_ENABLE_IF(!std::is_same&lt;From, To&gt;::value &amp;&amp;
36                          std::numeric_limits&lt;From&gt;::is_signed !=
37                              std::numeric_limits&lt;To&gt;::is_signed)&gt;
38  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int&amp; ec) {
39    ec = 0;
40    using F = std::numeric_limits&lt;From&gt;;
41    using T = std::numeric_limits&lt;To&gt;;
42    static_assert(F::is_integer, &quot;From must be integral&quot;);
43    static_assert(T::is_integer, &quot;To must be integral&quot;);
44    if (detail::const_check(F::is_signed &amp;&amp; !T::is_signed)) {
45      if (fmt::detail::is_negative(from)) {
46        ec = 1;
47        return {};
48      }
49      if (F::digits &gt; T::digits &amp;&amp;
50          from &gt; static_cast&lt;From&gt;(detail::max_value&lt;To&gt;())) {
51        ec = 1;
52        return {};
53      }
54    }
55    if (!F::is_signed &amp;&amp; T::is_signed &amp;&amp; F::digits &gt;= T::digits &amp;&amp;
56        from &gt; static_cast&lt;From&gt;(detail::max_value&lt;To&gt;())) {
57      ec = 1;
58      return {};
59    }
60    return static_cast&lt;To&gt;(from);  
61  }
62  template &lt;typename To, typename From,
63            FMT_ENABLE_IF(std::is_same&lt;From, To&gt;::value)&gt;
64  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int&amp; ec) {
65    ec = 0;
66    return from;
67  }  
68  template &lt;typename To, typename From,
69            FMT_ENABLE_IF(!std::is_same&lt;From, To&gt;::value)&gt;
70  FMT_CONSTEXPR To safe_float_conversion(const From from, int&amp; ec) {
71    ec = 0;
72    using T = std::numeric_limits&lt;To&gt;;
73    static_assert(std::is_floating_point&lt;From&gt;::value, &quot;From must be floating&quot;);
74    static_assert(std::is_floating_point&lt;To&gt;::value, &quot;To must be floating&quot;);
75    if (std::isfinite(from)) {
76      if (from &gt;= T::lowest() &amp;&amp; from &lt;= (T::max)()) {
77        return static_cast&lt;To&gt;(from);
78      }
79      ec = 1;
80      return {};
81    }
82    return static_cast&lt;To&gt;(from);
83  }  
84  template &lt;typename To, typename From,
85            FMT_ENABLE_IF(std::is_same&lt;From, To&gt;::value)&gt;
86  FMT_CONSTEXPR To safe_float_conversion(const From from, int&amp; ec) {
87    ec = 0;
88    static_assert(std::is_floating_point&lt;From&gt;::value, &quot;From must be floating&quot;);
89    return from;
90  }
91  template &lt;typename To, typename FromRep, typename FromPeriod,
92            FMT_ENABLE_IF(std::is_integral&lt;FromRep&gt;::value),
93            FMT_ENABLE_IF(std::is_integral&lt;typename To::rep&gt;::value)&gt;
94  To safe_duration_cast(std::chrono::duration&lt;FromRep, FromPeriod&gt; from,
95                        int&amp; ec) {
96    using From = std::chrono::duration&lt;FromRep, FromPeriod&gt;;
97    ec = 0;
98    struct Factor
99        : std::ratio_divide&lt;typename From::period, typename To::period&gt; {};
100    static_assert(Factor::num &gt; 0, &quot;num must be positive&quot;);
101    static_assert(Factor::den &gt; 0, &quot;den must be positive&quot;);
102    using IntermediateRep =
103        typename std::common_type&lt;typename From::rep, typename To::rep,
104                                  decltype(Factor::num)&gt;::type;
105    IntermediateRep count =
106        lossless_integral_conversion&lt;IntermediateRep&gt;(from.count(), ec);
107    if (ec) return {};
108    if (detail::const_check(Factor::num != 1)) {
109      const auto max1 = detail::max_value&lt;IntermediateRep&gt;() / Factor::num;
110      if (count &gt; max1) {
111        ec = 1;
112        return {};
113      }
114      const auto min1 =
115          (std::numeric_limits&lt;IntermediateRep&gt;::min)() / Factor::num;
116      if (count &lt; min1) {
117        ec = 1;
118        return {};
119      }
120      count *= Factor::num;
121    }
122    if (detail::const_check(Factor::den != 1)) count /= Factor::den;
123    auto tocount = lossless_integral_conversion&lt;typename To::rep&gt;(count, ec);
124    return ec ? To() : To(tocount);
125  }
126  template &lt;typename To, typename FromRep, typename FromPeriod,
127            FMT_ENABLE_IF(std::is_floating_point&lt;FromRep&gt;::value),
128            FMT_ENABLE_IF(std::is_floating_point&lt;typename To::rep&gt;::value)&gt;
129  To safe_duration_cast(std::chrono::duration&lt;FromRep, FromPeriod&gt; from,
130                        int&amp; ec) {
131    using From = std::chrono::duration&lt;FromRep, FromPeriod&gt;;
132    ec = 0;
133    if (std::isnan(from.count())) {
134      return To{std::numeric_limits&lt;typename To::rep&gt;::quiet_NaN()};
135    }
136    if (std::isinf(from.count())) {
137      return To{from.count()};
138    }
139    struct Factor
140        : std::ratio_divide&lt;typename From::period, typename To::period&gt; {};
141    static_assert(Factor::num &gt; 0, &quot;num must be positive&quot;);
142    static_assert(Factor::den &gt; 0, &quot;den must be positive&quot;);
143    using IntermediateRep =
144        typename std::common_type&lt;typename From::rep, typename To::rep,
145                                  decltype(Factor::num)&gt;::type;
146    IntermediateRep count =
147        safe_float_conversion&lt;IntermediateRep&gt;(from.count(), ec);
148    if (ec) {
149      return {};
150    }
151    if (Factor::num != 1) {
152      constexpr auto max1 = detail::max_value&lt;IntermediateRep&gt;() /
153                            static_cast&lt;IntermediateRep&gt;(Factor::num);
154      if (count &gt; max1) {
155        ec = 1;
156        return {};
157      }
158      constexpr auto min1 = std::numeric_limits&lt;IntermediateRep&gt;::lowest() /
159                            static_cast&lt;IntermediateRep&gt;(Factor::num);
160      if (count &lt; min1) {
161        ec = 1;
162        return {};
163      }
164      count *= static_cast&lt;IntermediateRep&gt;(Factor::num);
165    }
166    if (Factor::den != 1) {
167      using common_t = typename std::common_type&lt;IntermediateRep, intmax_t&gt;::type;
168      count /= static_cast&lt;common_t&gt;(Factor::den);
169    }
170    using ToRep = typename To::rep;
171    const ToRep tocount = safe_float_conversion&lt;ToRep&gt;(count, ec);
172    if (ec) {
173      return {};
174    }
175    return To{tocount};
176  }
177  }  
178  #endif
179  #define FMT_NOMACRO
180  namespace detail {
181  inline null&lt;&gt; localtime_r FMT_NOMACRO(...) { return null&lt;&gt;(); }
182  inline null&lt;&gt; localtime_s(...) { return null&lt;&gt;(); }
183  inline null&lt;&gt; gmtime_r(...) { return null&lt;&gt;(); }
184  inline null&lt;&gt; gmtime_s(...) { return null&lt;&gt;(); }
185  }  
186  inline std::tm localtime(std::time_t time) {
187    struct dispatcher {
188      std::time_t time_;
189      std::tm tm_;
190      dispatcher(std::time_t t) : time_(t) {}
191      bool run() {
192        using namespace fmt::detail;
193        return handle(localtime_r(&amp;time_, &amp;tm_));
194      }
195      bool handle(std::tm* tm) { return tm != nullptr; }
196      bool handle(detail::null&lt;&gt;) {
197        using namespace fmt::detail;
198        return fallback(localtime_s(&amp;tm_, &amp;time_));
199      }
200      bool fallback(int res) { return res == 0; }
201  #if !FMT_MSC_VER
202      bool fallback(detail::null&lt;&gt;) {
203        using namespace fmt::detail;
204        std::tm* tm = std::localtime(&amp;time_);
205        if (tm) tm_ = *tm;
206        return tm != nullptr;
207      }
208  #endif
209    };
210    dispatcher lt(time);
211    if (!lt.run()) FMT_THROW(format_error(&quot;time_t value out of range&quot;));
212    return lt.tm_;
213  }
214  inline std::tm localtime(
215      std::chrono::time_point&lt;std::chrono::system_clock&gt; time_point) {
216    return localtime(std::chrono::system_clock::to_time_t(time_point));
217  }
218  inline std::tm gmtime(std::time_t time) {
219    struct dispatcher {
220      std::time_t time_;
221      std::tm tm_;
222      dispatcher(std::time_t t) : time_(t) {}
223      bool run() {
224        using namespace fmt::detail;
225        return handle(gmtime_r(&amp;time_, &amp;tm_));
226      }
227      bool handle(std::tm* tm) { return tm != nullptr; }
228      bool handle(detail::null&lt;&gt;) {
229        using namespace fmt::detail;
230        return fallback(gmtime_s(&amp;tm_, &amp;time_));
231      }
232      bool fallback(int res) { return res == 0; }
233  #if !FMT_MSC_VER
234      bool fallback(detail::null&lt;&gt;) {
235        std::tm* tm = std::gmtime(&amp;time_);
236        if (tm) tm_ = *tm;
237        return tm != nullptr;
238      }
239  #endif
240    };
241    dispatcher gt(time);
242    if (!gt.run()) FMT_THROW(format_error(&quot;time_t value out of range&quot;));
243    return gt.tm_;
244  }
245  inline std::tm gmtime(
246      std::chrono::time_point&lt;std::chrono::system_clock&gt; time_point) {
247    return gmtime(std::chrono::system_clock::to_time_t(time_point));
248  }
249  namespace detail {
250  inline size_t strftime(char* str, size_t count, const char* format,
251                         const std::tm* time) {
252    return std::strftime(str, count, format, time);
253  }
254  inline size_t strftime(wchar_t* str, size_t count, const wchar_t* format,
255                         const std::tm* time) {
256    return std::wcsftime(str, count, format, time);
257  }
258  }  
259  template &lt;typename Char&gt;
260  struct formatter&lt;std::chrono::time_point&lt;std::chrono::system_clock&gt;, Char&gt;
261      : formatter&lt;std::tm, Char&gt; {
262    template &lt;typename FormatContext&gt;
263    auto format(std::chrono::time_point&lt;std::chrono::system_clock&gt; val,
264                FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
265      std::tm time = localtime(val);
266      return formatter&lt;std::tm, Char&gt;::format(time, ctx);
267    }
268  };
269  template &lt;typename Char&gt; struct formatter&lt;std::tm, Char&gt; {
270    template &lt;typename ParseContext&gt;
271    auto parse(ParseContext&amp; ctx) -&gt; decltype(ctx.begin()) {
272      auto it = ctx.begin();
273      if (it != ctx.end() &amp;&amp; *it == &#x27;:&#x27;) ++it;
274      auto end = it;
275      while (end != ctx.end() &amp;&amp; *end != &#x27;}&#x27;) ++end;
276      tm_format.reserve(detail::to_unsigned(end - it + 1));
277      tm_format.append(it, end);
278      tm_format.push_back(&#x27;\0&#x27;);
279      return end;
280    }
281    template &lt;typename FormatContext&gt;
282    auto format(const std::tm&amp; tm, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
283      basic_memory_buffer&lt;Char&gt; buf;
284      size_t start = buf.size();
285      for (;;) {
286        size_t size = buf.capacity() - start;
287        size_t count = detail::strftime(&amp;buf[start], size, &amp;tm_format[0], &amp;tm);
288        if (count != 0) {
289          buf.resize(start + count);
290          break;
291        }
292        if (size &gt;= tm_format.size() * 256) {
293          break;
294        }
295        const size_t MIN_GROWTH = 10;
296        buf.reserve(buf.capacity() + (size &gt; MIN_GROWTH ? size : MIN_GROWTH));
297      }
298      return std::copy(buf.begin(), buf.end(), ctx.out());
299    }
300    basic_memory_buffer&lt;Char&gt; tm_format;
301  };
302  namespace detail {
303  template &lt;typename Period&gt; FMT_CONSTEXPR const char* get_units() {
304    return nullptr;
305  }
306  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::atto&gt;() { return &quot;as&quot;; }
307  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::femto&gt;() { return &quot;fs&quot;; }
308  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::pico&gt;() { return &quot;ps&quot;; }
309  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::nano&gt;() { return &quot;ns&quot;; }
310  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::micro&gt;() { return &quot;µs&quot;; }
311  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::milli&gt;() { return &quot;ms&quot;; }
312  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::centi&gt;() { return &quot;cs&quot;; }
313  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::deci&gt;() { return &quot;ds&quot;; }
314  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::ratio&lt;1&gt;&gt;() { return &quot;s&quot;; }
315  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::deca&gt;() { return &quot;das&quot;; }
316  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::hecto&gt;() { return &quot;hs&quot;; }
317  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::kilo&gt;() { return &quot;ks&quot;; }
318  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::mega&gt;() { return &quot;Ms&quot;; }
319  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::giga&gt;() { return &quot;Gs&quot;; }
320  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::tera&gt;() { return &quot;Ts&quot;; }
321  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::peta&gt;() { return &quot;Ps&quot;; }
322  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::exa&gt;() { return &quot;Es&quot;; }
323  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::ratio&lt;60&gt;&gt;() {
324    return &quot;m&quot;;
325  }
326  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::ratio&lt;3600&gt;&gt;() {
327    return &quot;h&quot;;
328  }
329  enum class numeric_system {
330    standard,
331    alternative
332  };
333  template &lt;typename Char, typename Handler&gt;
334  FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
335                                                const Char* end,
336                                                Handler&amp;&amp; handler) {
337    auto ptr = begin;
338    while (ptr != end) {
339      auto c = *ptr;
340      if (c == &#x27;}&#x27;) break;
341      if (c != &#x27;%&#x27;) {
342        ++ptr;
343        continue;
344      }
345      if (begin != ptr) handler.on_text(begin, ptr);
346      ++ptr;  
347      if (ptr == end) FMT_THROW(format_error(&quot;invalid format&quot;));
348      c = *ptr++;
349      switch (c) {
350      case &#x27;%&#x27;:
351        handler.on_text(ptr - 1, ptr);
352        break;
353      case &#x27;n&#x27;: {
354        const Char newline[] = {&#x27;\n&#x27;};
355        handler.on_text(newline, newline + 1);
356        break;
357      }
358      case &#x27;t&#x27;: {
359        const Char tab[] = {&#x27;\t&#x27;};
360        handler.on_text(tab, tab + 1);
361        break;
362      }
363      case &#x27;a&#x27;:
364        handler.on_abbr_weekday();
365        break;
366      case &#x27;A&#x27;:
367        handler.on_full_weekday();
368        break;
369      case &#x27;w&#x27;:
370        handler.on_dec0_weekday(numeric_system::standard);
371        break;
372      case &#x27;u&#x27;:
373        handler.on_dec1_weekday(numeric_system::standard);
374        break;
375      case &#x27;b&#x27;:
376        handler.on_abbr_month();
377        break;
378      case &#x27;B&#x27;:
379        handler.on_full_month();
380        break;
381      case &#x27;H&#x27;:
382        handler.on_24_hour(numeric_system::standard);
383        break;
384      case &#x27;I&#x27;:
385        handler.on_12_hour(numeric_system::standard);
386        break;
387      case &#x27;M&#x27;:
388        handler.on_minute(numeric_system::standard);
389        break;
390      case &#x27;S&#x27;:
391        handler.on_second(numeric_system::standard);
392        break;
393      case &#x27;c&#x27;:
394        handler.on_datetime(numeric_system::standard);
395        break;
396      case &#x27;x&#x27;:
397        handler.on_loc_date(numeric_system::standard);
398        break;
399      case &#x27;X&#x27;:
400        handler.on_loc_time(numeric_system::standard);
401        break;
402      case &#x27;D&#x27;:
403        handler.on_us_date();
404        break;
405      case &#x27;F&#x27;:
406        handler.on_iso_date();
407        break;
408      case &#x27;r&#x27;:
409        handler.on_12_hour_time();
410        break;
411      case &#x27;R&#x27;:
412        handler.on_24_hour_time();
413        break;
414      case &#x27;T&#x27;:
415        handler.on_iso_time();
416        break;
417      case &#x27;p&#x27;:
418        handler.on_am_pm();
419        break;
420      case &#x27;Q&#x27;:
421        handler.on_duration_value();
422        break;
423      case &#x27;q&#x27;:
424        handler.on_duration_unit();
425        break;
426      case &#x27;z&#x27;:
427        handler.on_utc_offset();
428        break;
429      case &#x27;Z&#x27;:
430        handler.on_tz_name();
431        break;
432      case &#x27;E&#x27;: {
433        if (ptr == end) FMT_THROW(format_error(&quot;invalid format&quot;));
434        c = *ptr++;
435        switch (c) {
436        case &#x27;c&#x27;:
437          handler.on_datetime(numeric_system::alternative);
438          break;
439        case &#x27;x&#x27;:
440          handler.on_loc_date(numeric_system::alternative);
441          break;
442        case &#x27;X&#x27;:
443          handler.on_loc_time(numeric_system::alternative);
444          break;
445        default:
446          FMT_THROW(format_error(&quot;invalid format&quot;));
447        }
448        break;
449      }
450      case &#x27;O&#x27;:
451        if (ptr == end) FMT_THROW(format_error(&quot;invalid format&quot;));
452        c = *ptr++;
453        switch (c) {
454        case &#x27;w&#x27;:
455          handler.on_dec0_weekday(numeric_system::alternative);
456          break;
457        case &#x27;u&#x27;:
458          handler.on_dec1_weekday(numeric_system::alternative);
459          break;
460        case &#x27;H&#x27;:
461          handler.on_24_hour(numeric_system::alternative);
462          break;
463        case &#x27;I&#x27;:
464          handler.on_12_hour(numeric_system::alternative);
465          break;
466        case &#x27;M&#x27;:
467          handler.on_minute(numeric_system::alternative);
468          break;
469        case &#x27;S&#x27;:
470          handler.on_second(numeric_system::alternative);
471          break;
472        default:
473          FMT_THROW(format_error(&quot;invalid format&quot;));
474        }
475        break;
476      default:
477        FMT_THROW(format_error(&quot;invalid format&quot;));
478      }
479      begin = ptr;
480    }
481    if (begin != ptr) handler.on_text(begin, ptr);
482    return ptr;
483  }
484  struct chrono_format_checker {
485    FMT_NORETURN void report_no_date() { FMT_THROW(format_error(&quot;no date&quot;)); }
486    template &lt;typename Char&gt; void on_text(const Char*, const Char*) {}
487    FMT_NORETURN void on_abbr_weekday() { report_no_date(); }
488    FMT_NORETURN void on_full_weekday() { report_no_date(); }
489    FMT_NORETURN void on_dec0_weekday(numeric_system) { report_no_date(); }
490    FMT_NORETURN void on_dec1_weekday(numeric_system) { report_no_date(); }
491    FMT_NORETURN void on_abbr_month() { report_no_date(); }
492    FMT_NORETURN void on_full_month() { report_no_date(); }
493    void on_24_hour(numeric_system) {}
494    void on_12_hour(numeric_system) {}
495    void on_minute(numeric_system) {}
496    void on_second(numeric_system) {}
497    FMT_NORETURN void on_datetime(numeric_system) { report_no_date(); }
498    FMT_NORETURN void on_loc_date(numeric_system) { report_no_date(); }
499    FMT_NORETURN void on_loc_time(numeric_system) { report_no_date(); }
500    FMT_NORETURN void on_us_date() { report_no_date(); }
501    FMT_NORETURN void on_iso_date() { report_no_date(); }
502    void on_12_hour_time() {}
503    void on_24_hour_time() {}
504    void on_iso_time() {}
505    void on_am_pm() {}
506    void on_duration_value() {}
507    void on_duration_unit() {}
508    FMT_NORETURN void on_utc_offset() { report_no_date(); }
509    FMT_NORETURN void on_tz_name() { report_no_date(); }
510  };
511  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
512  inline bool isnan(T) {
513    return false;
514  }
515  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
516  inline bool isnan(T value) {
517    return std::isnan(value);
518  }
519  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
520  inline bool isfinite(T) {
521    return true;
522  }
523  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
524  inline bool isfinite(T value) {
525    return std::isfinite(value);
526  }
527  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
528  inline int to_nonnegative_int(T value, int upper) {
529    FMT_ASSERT(value &gt;= 0 &amp;&amp; value &lt;= upper, &quot;invalid value&quot;);
530    (void)upper;
531    return static_cast&lt;int&gt;(value);
532  }
533  template &lt;typename T, FMT_ENABLE_IF(!std::is_integral&lt;T&gt;::value)&gt;
534  inline int to_nonnegative_int(T value, int upper) {
535    FMT_ASSERT(
536        std::isnan(value) || (value &gt;= 0 &amp;&amp; value &lt;= static_cast&lt;T&gt;(upper)),
537        &quot;invalid value&quot;);
538    (void)upper;
539    return static_cast&lt;int&gt;(value);
540  }
541  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
542  inline T mod(T x, int y) {
543    return x % static_cast&lt;T&gt;(y);
544  }
545  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
546  inline T mod(T x, int y) {
547    return std::fmod(x, static_cast&lt;T&gt;(y));
548  }
549  template &lt;typename T, bool INTEGRAL = std::is_integral&lt;T&gt;::value&gt;
550  struct make_unsigned_or_unchanged {
551    using type = T;
552  };
553  template &lt;typename T&gt; struct make_unsigned_or_unchanged&lt;T, true&gt; {
554    using type = typename std::make_unsigned&lt;T&gt;::type;
555  };
556  #if FMT_SAFE_DURATION_CAST
557  template &lt;typename To, typename FromRep, typename FromPeriod&gt;
558  To fmt_safe_duration_cast(std::chrono::duration&lt;FromRep, FromPeriod&gt; from) {
559    int ec;
560    To to = safe_duration_cast::safe_duration_cast&lt;To&gt;(from, ec);
561    if (ec) FMT_THROW(format_error(&quot;cannot format duration&quot;));
562    return to;
563  }
564  #endif
565  template &lt;typename Rep, typename Period,
566            FMT_ENABLE_IF(std::is_integral&lt;Rep&gt;::value)&gt;
567  inline std::chrono::duration&lt;Rep, std::milli&gt; get_milliseconds(
568      std::chrono::duration&lt;Rep, Period&gt; d) {
569  #if FMT_SAFE_DURATION_CAST
570    using CommonSecondsType =
571        typename std::common_type&lt;decltype(d), std::chrono::seconds&gt;::type;
572    const auto d_as_common = fmt_safe_duration_cast&lt;CommonSecondsType&gt;(d);
573    const auto d_as_whole_seconds =
574        fmt_safe_duration_cast&lt;std::chrono::seconds&gt;(d_as_common);
575    const auto diff = d_as_common - d_as_whole_seconds;
576    const auto ms =
577        fmt_safe_duration_cast&lt;std::chrono::duration&lt;Rep, std::milli&gt;&gt;(diff);
578    return ms;
579  #else
580    auto s = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(d);
581    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(d - s);
582  #endif
583  }
584  template &lt;typename Rep, typename Period,
585            FMT_ENABLE_IF(std::is_floating_point&lt;Rep&gt;::value)&gt;
586  inline std::chrono::duration&lt;Rep, std::milli&gt; get_milliseconds(
587      std::chrono::duration&lt;Rep, Period&gt; d) {
588    using common_type = typename std::common_type&lt;Rep, std::intmax_t&gt;::type;
589    auto ms = mod(d.count() * static_cast&lt;common_type&gt;(Period::num) /
590                      static_cast&lt;common_type&gt;(Period::den) * 1000,
591                  1000);
592    return std::chrono::duration&lt;Rep, std::milli&gt;(static_cast&lt;Rep&gt;(ms));
593  }
594  template &lt;typename Char, typename Rep, typename OutputIt&gt;
595  OutputIt format_duration_value(OutputIt out, Rep val, int precision) {
596    const Char pr_f[] = {&#x27;{&#x27;, &#x27;:&#x27;, &#x27;.&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;f&#x27;, &#x27;}&#x27;, 0};
597    if (precision &gt;= 0) return format_to(out, pr_f, val, precision);
598    const Char fp_f[] = {&#x27;{&#x27;, &#x27;:&#x27;, &#x27;g&#x27;, &#x27;}&#x27;, 0};
599    const Char format[] = {&#x27;{&#x27;, &#x27;}&#x27;, 0};
600    return format_to(out, std::is_floating_point&lt;Rep&gt;::value ? fp_f : format,
601                     val);
602  }
603  template &lt;typename Char, typename OutputIt&gt;
604  OutputIt copy_unit(string_view unit, OutputIt out, Char) {
605    return std::copy(unit.begin(), unit.end(), out);
606  }
607  template &lt;typename OutputIt&gt;
608  OutputIt copy_unit(string_view unit, OutputIt out, wchar_t) {
609    utf8_to_utf16 u(unit);
610    return std::copy(u.c_str(), u.c_str() + u.size(), out);
611  }
612  template &lt;typename Char, typename Period, typename OutputIt&gt;
613  OutputIt format_duration_unit(OutputIt out) {
614    if (const char* unit = get_units&lt;Period&gt;())
615      return copy_unit(string_view(unit), out, Char());
616    const Char num_f[] = {&#x27;[&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;]&#x27;, &#x27;s&#x27;, 0};
617    if (const_check(Period::den == 1)) return format_to(out, num_f, Period::num);
618    const Char num_def_f[] = {&#x27;[&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;/&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;]&#x27;, &#x27;s&#x27;, 0};
619    return format_to(out, num_def_f, Period::num, Period::den);
620  }
621  template &lt;typename FormatContext, typename OutputIt, typename Rep,
622            typename Period&gt;
623  struct chrono_formatter {
624    FormatContext&amp; context;
625    OutputIt out;
626    int precision;
627    using rep =
628        conditional_t&lt;std::is_integral&lt;Rep&gt;::value &amp;&amp; sizeof(Rep) &lt; sizeof(int),
629                      unsigned, typename make_unsigned_or_unchanged&lt;Rep&gt;::type&gt;;
630    rep val;
631    using seconds = std::chrono::duration&lt;rep&gt;;
632    seconds s;
633    using milliseconds = std::chrono::duration&lt;rep, std::milli&gt;;
634    bool negative;
635    using char_type = typename FormatContext::char_type;
636    explicit chrono_formatter(FormatContext&amp; ctx, OutputIt o,
637                              std::chrono::duration&lt;Rep, Period&gt; d)
638        : context(ctx),
639          out(o),
640          val(static_cast&lt;rep&gt;(d.count())),
641          negative(false) {
642      if (d.count() &lt; 0) {
643        val = 0 - val;
644        negative = true;
645      }
646  #if FMT_SAFE_DURATION_CAST
647      auto tmpval = std::chrono::duration&lt;rep, Period&gt;(val);
648      s = fmt_safe_duration_cast&lt;seconds&gt;(tmpval);
649  #else
650      s = std::chrono::duration_cast&lt;seconds&gt;(
651          std::chrono::duration&lt;rep, Period&gt;(val));
652  #endif
653    }
654    bool handle_nan_inf() {
655      if (isfinite(val)) {
656        return false;
657      }
658      if (isnan(val)) {
659        write_nan();
660        return true;
661      }
662      if (val &gt; 0) {
663        write_pinf();
664      } else {
665        write_ninf();
666      }
667      return true;
668    }
669    Rep hour() const { return static_cast&lt;Rep&gt;(mod((s.count() / 3600), 24)); }
670    Rep hour12() const {
671      Rep hour = static_cast&lt;Rep&gt;(mod((s.count() / 3600), 12));
672      return hour &lt;= 0 ? 12 : hour;
673    }
674    Rep minute() const { return static_cast&lt;Rep&gt;(mod((s.count() / 60), 60)); }
675    Rep second() const { return static_cast&lt;Rep&gt;(mod(s.count(), 60)); }
676    std::tm time() const {
677      auto time = std::tm();
678      time.tm_hour = to_nonnegative_int(hour(), 24);
679      time.tm_min = to_nonnegative_int(minute(), 60);
680      time.tm_sec = to_nonnegative_int(second(), 60);
681      return time;
682    }
683    void write_sign() {
684      if (negative) {
685        *out++ = &#x27;-&#x27;;
686        negative = false;
687      }
688    }
689    void write(Rep value, int width) {
690      write_sign();
691      if (isnan(value)) return write_nan();
692      uint32_or_64_or_128_t&lt;int&gt; n =
693          to_unsigned(to_nonnegative_int(value, max_value&lt;int&gt;()));
694      int num_digits = detail::count_digits(n);
695      if (width &gt; num_digits) out = std::fill_n(out, width - num_digits, &#x27;0&#x27;);
696      out = format_decimal&lt;char_type&gt;(out, n, num_digits).end;
697    }
698    void write_nan() { std::copy_n(&quot;nan&quot;, 3, out); }
699    void write_pinf() { std::copy_n(&quot;inf&quot;, 3, out); }
700    void write_ninf() { std::copy_n(&quot;-inf&quot;, 4, out); }
701    void format_localized(const tm&amp; time, char format, char modifier = 0) {
702      if (isnan(val)) return write_nan();
703      auto locale = context.locale().template get&lt;std::locale&gt;();
704      auto&amp; facet = std::use_facet&lt;std::time_put&lt;char_type&gt;&gt;(locale);
705      std::basic_ostringstream&lt;char_type&gt; os;
706      os.imbue(locale);
707      facet.put(os, os, &#x27; &#x27;, &amp;time, format, modifier);
708      auto str = os.str();
709      std::copy(str.begin(), str.end(), out);
710    }
711    void on_text(const char_type* begin, const char_type* end) {
712      std::copy(begin, end, out);
713    }
714    void on_abbr_weekday() {}
715    void on_full_weekday() {}
716    void on_dec0_weekday(numeric_system) {}
717    void on_dec1_weekday(numeric_system) {}
718    void on_abbr_month() {}
719    void on_full_month() {}
720    void on_datetime(numeric_system) {}
721    void on_loc_date(numeric_system) {}
722    void on_loc_time(numeric_system) {}
723    void on_us_date() {}
724    void on_iso_date() {}
725    void on_utc_offset() {}
726    void on_tz_name() {}
727    void on_24_hour(numeric_system ns) {
728      if (handle_nan_inf()) return;
729      if (ns == numeric_system::standard) return write(hour(), 2);
730      auto time = tm();
731      time.tm_hour = to_nonnegative_int(hour(), 24);
732      format_localized(time, &#x27;H&#x27;, &#x27;O&#x27;);
733    }
734    void on_12_hour(numeric_system ns) {
735      if (handle_nan_inf()) return;
736      if (ns == numeric_system::standard) return write(hour12(), 2);
737      auto time = tm();
738      time.tm_hour = to_nonnegative_int(hour12(), 12);
739      format_localized(time, &#x27;I&#x27;, &#x27;O&#x27;);
740    }
741    void on_minute(numeric_system ns) {
742      if (handle_nan_inf()) return;
743      if (ns == numeric_system::standard) return write(minute(), 2);
744      auto time = tm();
745      time.tm_min = to_nonnegative_int(minute(), 60);
746      format_localized(time, &#x27;M&#x27;, &#x27;O&#x27;);
747    }
748    void on_second(numeric_system ns) {
749      if (handle_nan_inf()) return;
750      if (ns == numeric_system::standard) {
751        write(second(), 2);
752  #if FMT_SAFE_DURATION_CAST
<span onclick='openModal()' class='match'>753        using duration_rep = std::chrono::duration&lt;rep, Period&gt;;
754        using duration_Rep = std::chrono::duration&lt;Rep, Period&gt;;
</span>755        auto tmpval = fmt_safe_duration_cast&lt;duration_Rep&gt;(duration_rep{val});
756  #else
757        auto tmpval = std::chrono::duration&lt;Rep, Period&gt;(val);
758  #endif
759        auto ms = get_milliseconds(tmpval);
760        if (ms != std::chrono::milliseconds(0)) {
761          *out++ = &#x27;.&#x27;;
762          write(ms.count(), 3);
763        }
764        return;
765      }
766      auto time = tm();
767      time.tm_sec = to_nonnegative_int(second(), 60);
768      format_localized(time, &#x27;S&#x27;, &#x27;O&#x27;);
769    }
770    void on_12_hour_time() {
771      if (handle_nan_inf()) return;
772      format_localized(time(), &#x27;r&#x27;);
773    }
774    void on_24_hour_time() {
775      if (handle_nan_inf()) {
776        *out++ = &#x27;:&#x27;;
777        handle_nan_inf();
778        return;
779      }
780      write(hour(), 2);
781      *out++ = &#x27;:&#x27;;
782      write(minute(), 2);
783    }
784    void on_iso_time() {
785      on_24_hour_time();
786      *out++ = &#x27;:&#x27;;
787      if (handle_nan_inf()) return;
788      write(second(), 2);
789    }
790    void on_am_pm() {
791      if (handle_nan_inf()) return;
792      format_localized(time(), &#x27;p&#x27;);
793    }
794    void on_duration_value() {
795      if (handle_nan_inf()) return;
796      write_sign();
797      out = format_duration_value&lt;char_type&gt;(out, val, precision);
798    }
799    void on_duration_unit() {
800      out = format_duration_unit&lt;char_type, Period&gt;(out);
801    }
802  };
803  }  
804  template &lt;typename Rep, typename Period, typename Char&gt;
805  struct formatter&lt;std::chrono::duration&lt;Rep, Period&gt;, Char&gt; {
806   private:
807    basic_format_specs&lt;Char&gt; specs;
808    int precision;
809    using arg_ref_type = detail::arg_ref&lt;Char&gt;;
810    arg_ref_type width_ref;
811    arg_ref_type precision_ref;
812    mutable basic_string_view&lt;Char&gt; format_str;
813    using duration = std::chrono::duration&lt;Rep, Period&gt;;
814    struct spec_handler {
815      formatter&amp; f;
816      basic_format_parse_context&lt;Char&gt;&amp; context;
817      basic_string_view&lt;Char&gt; format_str;
818      template &lt;typename Id&gt; FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
819        context.check_arg_id(arg_id);
820        return arg_ref_type(arg_id);
821      }
822      FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view&lt;Char&gt; arg_id) {
823        context.check_arg_id(arg_id);
824        return arg_ref_type(arg_id);
825      }
826      FMT_CONSTEXPR arg_ref_type make_arg_ref(detail::auto_id) {
827        return arg_ref_type(context.next_arg_id());
828      }
829      void on_error(const char* msg) { FMT_THROW(format_error(msg)); }
830      void on_fill(basic_string_view&lt;Char&gt; fill) { f.specs.fill = fill; }
831      void on_align(align_t align) { f.specs.align = align; }
832      void on_width(int width) { f.specs.width = width; }
833      void on_precision(int _precision) { f.precision = _precision; }
834      void end_precision() {}
835      template &lt;typename Id&gt; void on_dynamic_width(Id arg_id) {
836        f.width_ref = make_arg_ref(arg_id);
837      }
838      template &lt;typename Id&gt; void on_dynamic_precision(Id arg_id) {
839        f.precision_ref = make_arg_ref(arg_id);
840      }
841    };
842    using iterator = typename basic_format_parse_context&lt;Char&gt;::iterator;
843    struct parse_range {
844      iterator begin;
845      iterator end;
846    };
847    FMT_CONSTEXPR parse_range do_parse(basic_format_parse_context&lt;Char&gt;&amp; ctx) {
848      auto begin = ctx.begin(), end = ctx.end();
849      if (begin == end || *begin == &#x27;}&#x27;) return {begin, begin};
850      spec_handler handler{*this, ctx, format_str};
851      begin = detail::parse_align(begin, end, handler);
852      if (begin == end) return {begin, begin};
853      begin = detail::parse_width(begin, end, handler);
854      if (begin == end) return {begin, begin};
855      if (*begin == &#x27;.&#x27;) {
856        if (std::is_floating_point&lt;Rep&gt;::value)
857          begin = detail::parse_precision(begin, end, handler);
858        else
859          handler.on_error(&quot;precision not allowed for this argument type&quot;);
860      }
861      end = parse_chrono_format(begin, end, detail::chrono_format_checker());
862      return {begin, end};
863    }
864   public:
865    formatter() : precision(-1) {}
866    FMT_CONSTEXPR auto parse(basic_format_parse_context&lt;Char&gt;&amp; ctx)
867        -&gt; decltype(ctx.begin()) {
868      auto range = do_parse(ctx);
869      format_str = basic_string_view&lt;Char&gt;(
870          &amp;*range.begin, detail::to_unsigned(range.end - range.begin));
871      return range.end;
872    }
873    template &lt;typename FormatContext&gt;
874    auto format(const duration&amp; d, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
875      auto begin = format_str.begin(), end = format_str.end();
876      basic_memory_buffer&lt;Char&gt; buf;
877      auto out = std::back_inserter(buf);
878      detail::handle_dynamic_spec&lt;detail::width_checker&gt;(specs.width, width_ref,
879                                                         ctx);
880      detail::handle_dynamic_spec&lt;detail::precision_checker&gt;(precision,
881                                                             precision_ref, ctx);
882      if (begin == end || *begin == &#x27;}&#x27;) {
883        out = detail::format_duration_value&lt;Char&gt;(out, d.count(), precision);
884        detail::format_duration_unit&lt;Char, Period&gt;(out);
885      } else {
886        detail::chrono_formatter&lt;FormatContext, decltype(out), Rep, Period&gt; f(
887            ctx, out, d);
888        f.precision = precision;
889        parse_chrono_format(begin, end, f);
890      }
891      return detail::write(
892          ctx.out(), basic_string_view&lt;Char&gt;(buf.data(), buf.size()), specs);
893    }
894  };
895  FMT_END_NAMESPACE
896  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</h3>
            <pre><code>1  #ifndef FMT_CHRONO_H_
2  #define FMT_CHRONO_H_
3  #include &lt;chrono&gt;
4  #include &lt;ctime&gt;
5  #include &lt;locale&gt;
6  #include &lt;sstream&gt;
7  #include &quot;format.h&quot;
8  #include &quot;locale.h&quot;
9  FMT_BEGIN_NAMESPACE
10  #ifndef FMT_SAFE_DURATION_CAST
11  #  define FMT_SAFE_DURATION_CAST 1
12  #endif
13  #if FMT_SAFE_DURATION_CAST
14  namespace safe_duration_cast {
15  template &lt;typename To, typename From,
16            FMT_ENABLE_IF(!std::is_same&lt;From, To&gt;::value &amp;&amp;
17                          std::numeric_limits&lt;From&gt;::is_signed ==
18                              std::numeric_limits&lt;To&gt;::is_signed)&gt;
19  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int&amp; ec) {
20    ec = 0;
21    using F = std::numeric_limits&lt;From&gt;;
22    using T = std::numeric_limits&lt;To&gt;;
23    static_assert(F::is_integer, &quot;From must be integral&quot;);
24    static_assert(T::is_integer, &quot;To must be integral&quot;);
25    if (F::digits &lt;= T::digits) {
26    } else {
27      if (from &lt; (T::min)() || from &gt; (T::max)()) {
28        ec = 1;
29        return {};
30      }
31    }
32    return static_cast&lt;To&gt;(from);
33  }
34  template &lt;typename To, typename From,
35            FMT_ENABLE_IF(!std::is_same&lt;From, To&gt;::value &amp;&amp;
36                          std::numeric_limits&lt;From&gt;::is_signed !=
37                              std::numeric_limits&lt;To&gt;::is_signed)&gt;
38  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int&amp; ec) {
39    ec = 0;
40    using F = std::numeric_limits&lt;From&gt;;
41    using T = std::numeric_limits&lt;To&gt;;
42    static_assert(F::is_integer, &quot;From must be integral&quot;);
43    static_assert(T::is_integer, &quot;To must be integral&quot;);
44    if (detail::const_check(F::is_signed &amp;&amp; !T::is_signed)) {
45      if (fmt::detail::is_negative(from)) {
46        ec = 1;
47        return {};
48      }
49      if (F::digits &gt; T::digits &amp;&amp;
50          from &gt; static_cast&lt;From&gt;(detail::max_value&lt;To&gt;())) {
51        ec = 1;
52        return {};
53      }
54    }
55    if (!F::is_signed &amp;&amp; T::is_signed &amp;&amp; F::digits &gt;= T::digits &amp;&amp;
56        from &gt; static_cast&lt;From&gt;(detail::max_value&lt;To&gt;())) {
57      ec = 1;
58      return {};
59    }
60    return static_cast&lt;To&gt;(from);  
61  }
62  template &lt;typename To, typename From,
63            FMT_ENABLE_IF(std::is_same&lt;From, To&gt;::value)&gt;
64  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int&amp; ec) {
65    ec = 0;
66    return from;
67  }  
68  template &lt;typename To, typename From,
69            FMT_ENABLE_IF(!std::is_same&lt;From, To&gt;::value)&gt;
70  FMT_CONSTEXPR To safe_float_conversion(const From from, int&amp; ec) {
71    ec = 0;
72    using T = std::numeric_limits&lt;To&gt;;
73    static_assert(std::is_floating_point&lt;From&gt;::value, &quot;From must be floating&quot;);
74    static_assert(std::is_floating_point&lt;To&gt;::value, &quot;To must be floating&quot;);
75    if (std::isfinite(from)) {
76      if (from &gt;= T::lowest() &amp;&amp; from &lt;= (T::max)()) {
77        return static_cast&lt;To&gt;(from);
78      }
79      ec = 1;
80      return {};
81    }
82    return static_cast&lt;To&gt;(from);
83  }  
84  template &lt;typename To, typename From,
85            FMT_ENABLE_IF(std::is_same&lt;From, To&gt;::value)&gt;
86  FMT_CONSTEXPR To safe_float_conversion(const From from, int&amp; ec) {
87    ec = 0;
88    static_assert(std::is_floating_point&lt;From&gt;::value, &quot;From must be floating&quot;);
89    return from;
90  }
91  template &lt;typename To, typename FromRep, typename FromPeriod,
92            FMT_ENABLE_IF(std::is_integral&lt;FromRep&gt;::value),
93            FMT_ENABLE_IF(std::is_integral&lt;typename To::rep&gt;::value)&gt;
94  To safe_duration_cast(std::chrono::duration&lt;FromRep, FromPeriod&gt; from,
95                        int&amp; ec) {
96    using From = std::chrono::duration&lt;FromRep, FromPeriod&gt;;
97    ec = 0;
98    struct Factor
99        : std::ratio_divide&lt;typename From::period, typename To::period&gt; {};
100    static_assert(Factor::num &gt; 0, &quot;num must be positive&quot;);
101    static_assert(Factor::den &gt; 0, &quot;den must be positive&quot;);
102    using IntermediateRep =
103        typename std::common_type&lt;typename From::rep, typename To::rep,
104                                  decltype(Factor::num)&gt;::type;
105    IntermediateRep count =
106        lossless_integral_conversion&lt;IntermediateRep&gt;(from.count(), ec);
107    if (ec) return {};
108    if (detail::const_check(Factor::num != 1)) {
109      const auto max1 = detail::max_value&lt;IntermediateRep&gt;() / Factor::num;
110      if (count &gt; max1) {
111        ec = 1;
112        return {};
113      }
114      const auto min1 =
115          (std::numeric_limits&lt;IntermediateRep&gt;::min)() / Factor::num;
116      if (count &lt; min1) {
117        ec = 1;
118        return {};
119      }
120      count *= Factor::num;
121    }
122    if (detail::const_check(Factor::den != 1)) count /= Factor::den;
123    auto tocount = lossless_integral_conversion&lt;typename To::rep&gt;(count, ec);
124    return ec ? To() : To(tocount);
125  }
126  template &lt;typename To, typename FromRep, typename FromPeriod,
127            FMT_ENABLE_IF(std::is_floating_point&lt;FromRep&gt;::value),
128            FMT_ENABLE_IF(std::is_floating_point&lt;typename To::rep&gt;::value)&gt;
129  To safe_duration_cast(std::chrono::duration&lt;FromRep, FromPeriod&gt; from,
130                        int&amp; ec) {
<span onclick='openModal()' class='match'>131    using From = std::chrono::duration&lt;FromRep, FromPeriod&gt;;
132    ec = 0;
</span>133    if (std::isnan(from.count())) {
134      return To{std::numeric_limits&lt;typename To::rep&gt;::quiet_NaN()};
135    }
136    if (std::isinf(from.count())) {
137      return To{from.count()};
138    }
139    struct Factor
140        : std::ratio_divide&lt;typename From::period, typename To::period&gt; {};
141    static_assert(Factor::num &gt; 0, &quot;num must be positive&quot;);
142    static_assert(Factor::den &gt; 0, &quot;den must be positive&quot;);
143    using IntermediateRep =
144        typename std::common_type&lt;typename From::rep, typename To::rep,
145                                  decltype(Factor::num)&gt;::type;
146    IntermediateRep count =
147        safe_float_conversion&lt;IntermediateRep&gt;(from.count(), ec);
148    if (ec) {
149      return {};
150    }
151    if (Factor::num != 1) {
152      constexpr auto max1 = detail::max_value&lt;IntermediateRep&gt;() /
153                            static_cast&lt;IntermediateRep&gt;(Factor::num);
154      if (count &gt; max1) {
155        ec = 1;
156        return {};
157      }
158      constexpr auto min1 = std::numeric_limits&lt;IntermediateRep&gt;::lowest() /
159                            static_cast&lt;IntermediateRep&gt;(Factor::num);
160      if (count &lt; min1) {
161        ec = 1;
162        return {};
163      }
164      count *= static_cast&lt;IntermediateRep&gt;(Factor::num);
165    }
166    if (Factor::den != 1) {
167      using common_t = typename std::common_type&lt;IntermediateRep, intmax_t&gt;::type;
168      count /= static_cast&lt;common_t&gt;(Factor::den);
169    }
170    using ToRep = typename To::rep;
171    const ToRep tocount = safe_float_conversion&lt;ToRep&gt;(count, ec);
172    if (ec) {
173      return {};
174    }
175    return To{tocount};
176  }
177  }  
178  #endif
179  #define FMT_NOMACRO
180  namespace detail {
181  inline null&lt;&gt; localtime_r FMT_NOMACRO(...) { return null&lt;&gt;(); }
182  inline null&lt;&gt; localtime_s(...) { return null&lt;&gt;(); }
183  inline null&lt;&gt; gmtime_r(...) { return null&lt;&gt;(); }
184  inline null&lt;&gt; gmtime_s(...) { return null&lt;&gt;(); }
185  }  
186  inline std::tm localtime(std::time_t time) {
187    struct dispatcher {
188      std::time_t time_;
189      std::tm tm_;
190      dispatcher(std::time_t t) : time_(t) {}
191      bool run() {
192        using namespace fmt::detail;
193        return handle(localtime_r(&amp;time_, &amp;tm_));
194      }
195      bool handle(std::tm* tm) { return tm != nullptr; }
196      bool handle(detail::null&lt;&gt;) {
197        using namespace fmt::detail;
198        return fallback(localtime_s(&amp;tm_, &amp;time_));
199      }
200      bool fallback(int res) { return res == 0; }
201  #if !FMT_MSC_VER
202      bool fallback(detail::null&lt;&gt;) {
203        using namespace fmt::detail;
204        std::tm* tm = std::localtime(&amp;time_);
205        if (tm) tm_ = *tm;
206        return tm != nullptr;
207      }
208  #endif
209    };
210    dispatcher lt(time);
211    if (!lt.run()) FMT_THROW(format_error(&quot;time_t value out of range&quot;));
212    return lt.tm_;
213  }
214  inline std::tm localtime(
215      std::chrono::time_point&lt;std::chrono::system_clock&gt; time_point) {
216    return localtime(std::chrono::system_clock::to_time_t(time_point));
217  }
218  inline std::tm gmtime(std::time_t time) {
219    struct dispatcher {
220      std::time_t time_;
221      std::tm tm_;
222      dispatcher(std::time_t t) : time_(t) {}
223      bool run() {
224        using namespace fmt::detail;
225        return handle(gmtime_r(&amp;time_, &amp;tm_));
226      }
227      bool handle(std::tm* tm) { return tm != nullptr; }
228      bool handle(detail::null&lt;&gt;) {
229        using namespace fmt::detail;
230        return fallback(gmtime_s(&amp;tm_, &amp;time_));
231      }
232      bool fallback(int res) { return res == 0; }
233  #if !FMT_MSC_VER
234      bool fallback(detail::null&lt;&gt;) {
235        std::tm* tm = std::gmtime(&amp;time_);
236        if (tm) tm_ = *tm;
237        return tm != nullptr;
238      }
239  #endif
240    };
241    dispatcher gt(time);
242    if (!gt.run()) FMT_THROW(format_error(&quot;time_t value out of range&quot;));
243    return gt.tm_;
244  }
245  inline std::tm gmtime(
246      std::chrono::time_point&lt;std::chrono::system_clock&gt; time_point) {
247    return gmtime(std::chrono::system_clock::to_time_t(time_point));
248  }
249  namespace detail {
250  inline size_t strftime(char* str, size_t count, const char* format,
251                         const std::tm* time) {
252    return std::strftime(str, count, format, time);
253  }
254  inline size_t strftime(wchar_t* str, size_t count, const wchar_t* format,
255                         const std::tm* time) {
256    return std::wcsftime(str, count, format, time);
257  }
258  }  
259  template &lt;typename Char&gt;
260  struct formatter&lt;std::chrono::time_point&lt;std::chrono::system_clock&gt;, Char&gt;
261      : formatter&lt;std::tm, Char&gt; {
262    template &lt;typename FormatContext&gt;
263    auto format(std::chrono::time_point&lt;std::chrono::system_clock&gt; val,
264                FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
265      std::tm time = localtime(val);
266      return formatter&lt;std::tm, Char&gt;::format(time, ctx);
267    }
268  };
269  template &lt;typename Char&gt; struct formatter&lt;std::tm, Char&gt; {
270    template &lt;typename ParseContext&gt;
271    auto parse(ParseContext&amp; ctx) -&gt; decltype(ctx.begin()) {
272      auto it = ctx.begin();
273      if (it != ctx.end() &amp;&amp; *it == &#x27;:&#x27;) ++it;
274      auto end = it;
275      while (end != ctx.end() &amp;&amp; *end != &#x27;}&#x27;) ++end;
276      tm_format.reserve(detail::to_unsigned(end - it + 1));
277      tm_format.append(it, end);
278      tm_format.push_back(&#x27;\0&#x27;);
279      return end;
280    }
281    template &lt;typename FormatContext&gt;
282    auto format(const std::tm&amp; tm, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
283      basic_memory_buffer&lt;Char&gt; buf;
284      size_t start = buf.size();
285      for (;;) {
286        size_t size = buf.capacity() - start;
287        size_t count = detail::strftime(&amp;buf[start], size, &amp;tm_format[0], &amp;tm);
288        if (count != 0) {
289          buf.resize(start + count);
290          break;
291        }
292        if (size &gt;= tm_format.size() * 256) {
293          break;
294        }
295        const size_t MIN_GROWTH = 10;
296        buf.reserve(buf.capacity() + (size &gt; MIN_GROWTH ? size : MIN_GROWTH));
297      }
298      return std::copy(buf.begin(), buf.end(), ctx.out());
299    }
300    basic_memory_buffer&lt;Char&gt; tm_format;
301  };
302  namespace detail {
303  template &lt;typename Period&gt; FMT_CONSTEXPR const char* get_units() {
304    return nullptr;
305  }
306  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::atto&gt;() { return &quot;as&quot;; }
307  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::femto&gt;() { return &quot;fs&quot;; }
308  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::pico&gt;() { return &quot;ps&quot;; }
309  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::nano&gt;() { return &quot;ns&quot;; }
310  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::micro&gt;() { return &quot;µs&quot;; }
311  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::milli&gt;() { return &quot;ms&quot;; }
312  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::centi&gt;() { return &quot;cs&quot;; }
313  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::deci&gt;() { return &quot;ds&quot;; }
314  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::ratio&lt;1&gt;&gt;() { return &quot;s&quot;; }
315  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::deca&gt;() { return &quot;das&quot;; }
316  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::hecto&gt;() { return &quot;hs&quot;; }
317  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::kilo&gt;() { return &quot;ks&quot;; }
318  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::mega&gt;() { return &quot;Ms&quot;; }
319  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::giga&gt;() { return &quot;Gs&quot;; }
320  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::tera&gt;() { return &quot;Ts&quot;; }
321  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::peta&gt;() { return &quot;Ps&quot;; }
322  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::exa&gt;() { return &quot;Es&quot;; }
323  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::ratio&lt;60&gt;&gt;() {
324    return &quot;m&quot;;
325  }
326  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::ratio&lt;3600&gt;&gt;() {
327    return &quot;h&quot;;
328  }
329  enum class numeric_system {
330    standard,
331    alternative
332  };
333  template &lt;typename Char, typename Handler&gt;
334  FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
335                                                const Char* end,
336                                                Handler&amp;&amp; handler) {
337    auto ptr = begin;
338    while (ptr != end) {
339      auto c = *ptr;
340      if (c == &#x27;}&#x27;) break;
341      if (c != &#x27;%&#x27;) {
342        ++ptr;
343        continue;
344      }
345      if (begin != ptr) handler.on_text(begin, ptr);
346      ++ptr;  
347      if (ptr == end) FMT_THROW(format_error(&quot;invalid format&quot;));
348      c = *ptr++;
349      switch (c) {
350      case &#x27;%&#x27;:
351        handler.on_text(ptr - 1, ptr);
352        break;
353      case &#x27;n&#x27;: {
354        const Char newline[] = {&#x27;\n&#x27;};
355        handler.on_text(newline, newline + 1);
356        break;
357      }
358      case &#x27;t&#x27;: {
359        const Char tab[] = {&#x27;\t&#x27;};
360        handler.on_text(tab, tab + 1);
361        break;
362      }
363      case &#x27;a&#x27;:
364        handler.on_abbr_weekday();
365        break;
366      case &#x27;A&#x27;:
367        handler.on_full_weekday();
368        break;
369      case &#x27;w&#x27;:
370        handler.on_dec0_weekday(numeric_system::standard);
371        break;
372      case &#x27;u&#x27;:
373        handler.on_dec1_weekday(numeric_system::standard);
374        break;
375      case &#x27;b&#x27;:
376        handler.on_abbr_month();
377        break;
378      case &#x27;B&#x27;:
379        handler.on_full_month();
380        break;
381      case &#x27;H&#x27;:
382        handler.on_24_hour(numeric_system::standard);
383        break;
384      case &#x27;I&#x27;:
385        handler.on_12_hour(numeric_system::standard);
386        break;
387      case &#x27;M&#x27;:
388        handler.on_minute(numeric_system::standard);
389        break;
390      case &#x27;S&#x27;:
391        handler.on_second(numeric_system::standard);
392        break;
393      case &#x27;c&#x27;:
394        handler.on_datetime(numeric_system::standard);
395        break;
396      case &#x27;x&#x27;:
397        handler.on_loc_date(numeric_system::standard);
398        break;
399      case &#x27;X&#x27;:
400        handler.on_loc_time(numeric_system::standard);
401        break;
402      case &#x27;D&#x27;:
403        handler.on_us_date();
404        break;
405      case &#x27;F&#x27;:
406        handler.on_iso_date();
407        break;
408      case &#x27;r&#x27;:
409        handler.on_12_hour_time();
410        break;
411      case &#x27;R&#x27;:
412        handler.on_24_hour_time();
413        break;
414      case &#x27;T&#x27;:
415        handler.on_iso_time();
416        break;
417      case &#x27;p&#x27;:
418        handler.on_am_pm();
419        break;
420      case &#x27;Q&#x27;:
421        handler.on_duration_value();
422        break;
423      case &#x27;q&#x27;:
424        handler.on_duration_unit();
425        break;
426      case &#x27;z&#x27;:
427        handler.on_utc_offset();
428        break;
429      case &#x27;Z&#x27;:
430        handler.on_tz_name();
431        break;
432      case &#x27;E&#x27;: {
433        if (ptr == end) FMT_THROW(format_error(&quot;invalid format&quot;));
434        c = *ptr++;
435        switch (c) {
436        case &#x27;c&#x27;:
437          handler.on_datetime(numeric_system::alternative);
438          break;
439        case &#x27;x&#x27;:
440          handler.on_loc_date(numeric_system::alternative);
441          break;
442        case &#x27;X&#x27;:
443          handler.on_loc_time(numeric_system::alternative);
444          break;
445        default:
446          FMT_THROW(format_error(&quot;invalid format&quot;));
447        }
448        break;
449      }
450      case &#x27;O&#x27;:
451        if (ptr == end) FMT_THROW(format_error(&quot;invalid format&quot;));
452        c = *ptr++;
453        switch (c) {
454        case &#x27;w&#x27;:
455          handler.on_dec0_weekday(numeric_system::alternative);
456          break;
457        case &#x27;u&#x27;:
458          handler.on_dec1_weekday(numeric_system::alternative);
459          break;
460        case &#x27;H&#x27;:
461          handler.on_24_hour(numeric_system::alternative);
462          break;
463        case &#x27;I&#x27;:
464          handler.on_12_hour(numeric_system::alternative);
465          break;
466        case &#x27;M&#x27;:
467          handler.on_minute(numeric_system::alternative);
468          break;
469        case &#x27;S&#x27;:
470          handler.on_second(numeric_system::alternative);
471          break;
472        default:
473          FMT_THROW(format_error(&quot;invalid format&quot;));
474        }
475        break;
476      default:
477        FMT_THROW(format_error(&quot;invalid format&quot;));
478      }
479      begin = ptr;
480    }
481    if (begin != ptr) handler.on_text(begin, ptr);
482    return ptr;
483  }
484  struct chrono_format_checker {
485    FMT_NORETURN void report_no_date() { FMT_THROW(format_error(&quot;no date&quot;)); }
486    template &lt;typename Char&gt; void on_text(const Char*, const Char*) {}
487    FMT_NORETURN void on_abbr_weekday() { report_no_date(); }
488    FMT_NORETURN void on_full_weekday() { report_no_date(); }
489    FMT_NORETURN void on_dec0_weekday(numeric_system) { report_no_date(); }
490    FMT_NORETURN void on_dec1_weekday(numeric_system) { report_no_date(); }
491    FMT_NORETURN void on_abbr_month() { report_no_date(); }
492    FMT_NORETURN void on_full_month() { report_no_date(); }
493    void on_24_hour(numeric_system) {}
494    void on_12_hour(numeric_system) {}
495    void on_minute(numeric_system) {}
496    void on_second(numeric_system) {}
497    FMT_NORETURN void on_datetime(numeric_system) { report_no_date(); }
498    FMT_NORETURN void on_loc_date(numeric_system) { report_no_date(); }
499    FMT_NORETURN void on_loc_time(numeric_system) { report_no_date(); }
500    FMT_NORETURN void on_us_date() { report_no_date(); }
501    FMT_NORETURN void on_iso_date() { report_no_date(); }
502    void on_12_hour_time() {}
503    void on_24_hour_time() {}
504    void on_iso_time() {}
505    void on_am_pm() {}
506    void on_duration_value() {}
507    void on_duration_unit() {}
508    FMT_NORETURN void on_utc_offset() { report_no_date(); }
509    FMT_NORETURN void on_tz_name() { report_no_date(); }
510  };
511  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
512  inline bool isnan(T) {
513    return false;
514  }
515  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
516  inline bool isnan(T value) {
517    return std::isnan(value);
518  }
519  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
520  inline bool isfinite(T) {
521    return true;
522  }
523  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
524  inline bool isfinite(T value) {
525    return std::isfinite(value);
526  }
527  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
528  inline int to_nonnegative_int(T value, int upper) {
529    FMT_ASSERT(value &gt;= 0 &amp;&amp; value &lt;= upper, &quot;invalid value&quot;);
530    (void)upper;
531    return static_cast&lt;int&gt;(value);
532  }
533  template &lt;typename T, FMT_ENABLE_IF(!std::is_integral&lt;T&gt;::value)&gt;
534  inline int to_nonnegative_int(T value, int upper) {
535    FMT_ASSERT(
536        std::isnan(value) || (value &gt;= 0 &amp;&amp; value &lt;= static_cast&lt;T&gt;(upper)),
537        &quot;invalid value&quot;);
538    (void)upper;
539    return static_cast&lt;int&gt;(value);
540  }
541  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
542  inline T mod(T x, int y) {
543    return x % static_cast&lt;T&gt;(y);
544  }
545  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
546  inline T mod(T x, int y) {
547    return std::fmod(x, static_cast&lt;T&gt;(y));
548  }
549  template &lt;typename T, bool INTEGRAL = std::is_integral&lt;T&gt;::value&gt;
550  struct make_unsigned_or_unchanged {
551    using type = T;
552  };
553  template &lt;typename T&gt; struct make_unsigned_or_unchanged&lt;T, true&gt; {
554    using type = typename std::make_unsigned&lt;T&gt;::type;
555  };
556  #if FMT_SAFE_DURATION_CAST
557  template &lt;typename To, typename FromRep, typename FromPeriod&gt;
558  To fmt_safe_duration_cast(std::chrono::duration&lt;FromRep, FromPeriod&gt; from) {
559    int ec;
560    To to = safe_duration_cast::safe_duration_cast&lt;To&gt;(from, ec);
561    if (ec) FMT_THROW(format_error(&quot;cannot format duration&quot;));
562    return to;
563  }
564  #endif
565  template &lt;typename Rep, typename Period,
566            FMT_ENABLE_IF(std::is_integral&lt;Rep&gt;::value)&gt;
567  inline std::chrono::duration&lt;Rep, std::milli&gt; get_milliseconds(
568      std::chrono::duration&lt;Rep, Period&gt; d) {
569  #if FMT_SAFE_DURATION_CAST
570    using CommonSecondsType =
571        typename std::common_type&lt;decltype(d), std::chrono::seconds&gt;::type;
572    const auto d_as_common = fmt_safe_duration_cast&lt;CommonSecondsType&gt;(d);
573    const auto d_as_whole_seconds =
574        fmt_safe_duration_cast&lt;std::chrono::seconds&gt;(d_as_common);
575    const auto diff = d_as_common - d_as_whole_seconds;
576    const auto ms =
577        fmt_safe_duration_cast&lt;std::chrono::duration&lt;Rep, std::milli&gt;&gt;(diff);
578    return ms;
579  #else
580    auto s = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(d);
581    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(d - s);
582  #endif
583  }
584  template &lt;typename Rep, typename Period,
585            FMT_ENABLE_IF(std::is_floating_point&lt;Rep&gt;::value)&gt;
586  inline std::chrono::duration&lt;Rep, std::milli&gt; get_milliseconds(
587      std::chrono::duration&lt;Rep, Period&gt; d) {
588    using common_type = typename std::common_type&lt;Rep, std::intmax_t&gt;::type;
589    auto ms = mod(d.count() * static_cast&lt;common_type&gt;(Period::num) /
590                      static_cast&lt;common_type&gt;(Period::den) * 1000,
591                  1000);
592    return std::chrono::duration&lt;Rep, std::milli&gt;(static_cast&lt;Rep&gt;(ms));
593  }
594  template &lt;typename Char, typename Rep, typename OutputIt&gt;
595  OutputIt format_duration_value(OutputIt out, Rep val, int precision) {
596    const Char pr_f[] = {&#x27;{&#x27;, &#x27;:&#x27;, &#x27;.&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;f&#x27;, &#x27;}&#x27;, 0};
597    if (precision &gt;= 0) return format_to(out, pr_f, val, precision);
598    const Char fp_f[] = {&#x27;{&#x27;, &#x27;:&#x27;, &#x27;g&#x27;, &#x27;}&#x27;, 0};
599    const Char format[] = {&#x27;{&#x27;, &#x27;}&#x27;, 0};
600    return format_to(out, std::is_floating_point&lt;Rep&gt;::value ? fp_f : format,
601                     val);
602  }
603  template &lt;typename Char, typename OutputIt&gt;
604  OutputIt copy_unit(string_view unit, OutputIt out, Char) {
605    return std::copy(unit.begin(), unit.end(), out);
606  }
607  template &lt;typename OutputIt&gt;
608  OutputIt copy_unit(string_view unit, OutputIt out, wchar_t) {
609    utf8_to_utf16 u(unit);
610    return std::copy(u.c_str(), u.c_str() + u.size(), out);
611  }
612  template &lt;typename Char, typename Period, typename OutputIt&gt;
613  OutputIt format_duration_unit(OutputIt out) {
614    if (const char* unit = get_units&lt;Period&gt;())
615      return copy_unit(string_view(unit), out, Char());
616    const Char num_f[] = {&#x27;[&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;]&#x27;, &#x27;s&#x27;, 0};
617    if (const_check(Period::den == 1)) return format_to(out, num_f, Period::num);
618    const Char num_def_f[] = {&#x27;[&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;/&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;]&#x27;, &#x27;s&#x27;, 0};
619    return format_to(out, num_def_f, Period::num, Period::den);
620  }
621  template &lt;typename FormatContext, typename OutputIt, typename Rep,
622            typename Period&gt;
623  struct chrono_formatter {
624    FormatContext&amp; context;
625    OutputIt out;
626    int precision;
627    using rep =
628        conditional_t&lt;std::is_integral&lt;Rep&gt;::value &amp;&amp; sizeof(Rep) &lt; sizeof(int),
629                      unsigned, typename make_unsigned_or_unchanged&lt;Rep&gt;::type&gt;;
630    rep val;
631    using seconds = std::chrono::duration&lt;rep&gt;;
632    seconds s;
633    using milliseconds = std::chrono::duration&lt;rep, std::milli&gt;;
634    bool negative;
635    using char_type = typename FormatContext::char_type;
636    explicit chrono_formatter(FormatContext&amp; ctx, OutputIt o,
637                              std::chrono::duration&lt;Rep, Period&gt; d)
638        : context(ctx),
639          out(o),
640          val(static_cast&lt;rep&gt;(d.count())),
641          negative(false) {
642      if (d.count() &lt; 0) {
643        val = 0 - val;
644        negative = true;
645      }
646  #if FMT_SAFE_DURATION_CAST
647      auto tmpval = std::chrono::duration&lt;rep, Period&gt;(val);
648      s = fmt_safe_duration_cast&lt;seconds&gt;(tmpval);
649  #else
650      s = std::chrono::duration_cast&lt;seconds&gt;(
651          std::chrono::duration&lt;rep, Period&gt;(val));
652  #endif
653    }
654    bool handle_nan_inf() {
655      if (isfinite(val)) {
656        return false;
657      }
658      if (isnan(val)) {
659        write_nan();
660        return true;
661      }
662      if (val &gt; 0) {
663        write_pinf();
664      } else {
665        write_ninf();
666      }
667      return true;
668    }
669    Rep hour() const { return static_cast&lt;Rep&gt;(mod((s.count() / 3600), 24)); }
670    Rep hour12() const {
671      Rep hour = static_cast&lt;Rep&gt;(mod((s.count() / 3600), 12));
672      return hour &lt;= 0 ? 12 : hour;
673    }
674    Rep minute() const { return static_cast&lt;Rep&gt;(mod((s.count() / 60), 60)); }
675    Rep second() const { return static_cast&lt;Rep&gt;(mod(s.count(), 60)); }
676    std::tm time() const {
677      auto time = std::tm();
678      time.tm_hour = to_nonnegative_int(hour(), 24);
679      time.tm_min = to_nonnegative_int(minute(), 60);
680      time.tm_sec = to_nonnegative_int(second(), 60);
681      return time;
682    }
683    void write_sign() {
684      if (negative) {
685        *out++ = &#x27;-&#x27;;
686        negative = false;
687      }
688    }
689    void write(Rep value, int width) {
690      write_sign();
691      if (isnan(value)) return write_nan();
692      uint32_or_64_or_128_t&lt;int&gt; n =
693          to_unsigned(to_nonnegative_int(value, max_value&lt;int&gt;()));
694      int num_digits = detail::count_digits(n);
695      if (width &gt; num_digits) out = std::fill_n(out, width - num_digits, &#x27;0&#x27;);
696      out = format_decimal&lt;char_type&gt;(out, n, num_digits).end;
697    }
698    void write_nan() { std::copy_n(&quot;nan&quot;, 3, out); }
699    void write_pinf() { std::copy_n(&quot;inf&quot;, 3, out); }
700    void write_ninf() { std::copy_n(&quot;-inf&quot;, 4, out); }
701    void format_localized(const tm&amp; time, char format, char modifier = 0) {
702      if (isnan(val)) return write_nan();
703      auto locale = context.locale().template get&lt;std::locale&gt;();
704      auto&amp; facet = std::use_facet&lt;std::time_put&lt;char_type&gt;&gt;(locale);
705      std::basic_ostringstream&lt;char_type&gt; os;
706      os.imbue(locale);
707      facet.put(os, os, &#x27; &#x27;, &amp;time, format, modifier);
708      auto str = os.str();
709      std::copy(str.begin(), str.end(), out);
710    }
711    void on_text(const char_type* begin, const char_type* end) {
712      std::copy(begin, end, out);
713    }
714    void on_abbr_weekday() {}
715    void on_full_weekday() {}
716    void on_dec0_weekday(numeric_system) {}
717    void on_dec1_weekday(numeric_system) {}
718    void on_abbr_month() {}
719    void on_full_month() {}
720    void on_datetime(numeric_system) {}
721    void on_loc_date(numeric_system) {}
722    void on_loc_time(numeric_system) {}
723    void on_us_date() {}
724    void on_iso_date() {}
725    void on_utc_offset() {}
726    void on_tz_name() {}
727    void on_24_hour(numeric_system ns) {
728      if (handle_nan_inf()) return;
729      if (ns == numeric_system::standard) return write(hour(), 2);
730      auto time = tm();
731      time.tm_hour = to_nonnegative_int(hour(), 24);
732      format_localized(time, &#x27;H&#x27;, &#x27;O&#x27;);
733    }
734    void on_12_hour(numeric_system ns) {
735      if (handle_nan_inf()) return;
736      if (ns == numeric_system::standard) return write(hour12(), 2);
737      auto time = tm();
738      time.tm_hour = to_nonnegative_int(hour12(), 12);
739      format_localized(time, &#x27;I&#x27;, &#x27;O&#x27;);
740    }
741    void on_minute(numeric_system ns) {
742      if (handle_nan_inf()) return;
743      if (ns == numeric_system::standard) return write(minute(), 2);
744      auto time = tm();
745      time.tm_min = to_nonnegative_int(minute(), 60);
746      format_localized(time, &#x27;M&#x27;, &#x27;O&#x27;);
747    }
748    void on_second(numeric_system ns) {
749      if (handle_nan_inf()) return;
750      if (ns == numeric_system::standard) {
751        write(second(), 2);
752  #if FMT_SAFE_DURATION_CAST
753        using duration_rep = std::chrono::duration&lt;rep, Period&gt;;
754        using duration_Rep = std::chrono::duration&lt;Rep, Period&gt;;
755        auto tmpval = fmt_safe_duration_cast&lt;duration_Rep&gt;(duration_rep{val});
756  #else
757        auto tmpval = std::chrono::duration&lt;Rep, Period&gt;(val);
758  #endif
759        auto ms = get_milliseconds(tmpval);
760        if (ms != std::chrono::milliseconds(0)) {
761          *out++ = &#x27;.&#x27;;
762          write(ms.count(), 3);
763        }
764        return;
765      }
766      auto time = tm();
767      time.tm_sec = to_nonnegative_int(second(), 60);
768      format_localized(time, &#x27;S&#x27;, &#x27;O&#x27;);
769    }
770    void on_12_hour_time() {
771      if (handle_nan_inf()) return;
772      format_localized(time(), &#x27;r&#x27;);
773    }
774    void on_24_hour_time() {
775      if (handle_nan_inf()) {
776        *out++ = &#x27;:&#x27;;
777        handle_nan_inf();
778        return;
779      }
780      write(hour(), 2);
781      *out++ = &#x27;:&#x27;;
782      write(minute(), 2);
783    }
784    void on_iso_time() {
785      on_24_hour_time();
786      *out++ = &#x27;:&#x27;;
787      if (handle_nan_inf()) return;
788      write(second(), 2);
789    }
790    void on_am_pm() {
791      if (handle_nan_inf()) return;
792      format_localized(time(), &#x27;p&#x27;);
793    }
794    void on_duration_value() {
795      if (handle_nan_inf()) return;
796      write_sign();
797      out = format_duration_value&lt;char_type&gt;(out, val, precision);
798    }
799    void on_duration_unit() {
800      out = format_duration_unit&lt;char_type, Period&gt;(out);
801    }
802  };
803  }  
804  template &lt;typename Rep, typename Period, typename Char&gt;
805  struct formatter&lt;std::chrono::duration&lt;Rep, Period&gt;, Char&gt; {
806   private:
807    basic_format_specs&lt;Char&gt; specs;
808    int precision;
809    using arg_ref_type = detail::arg_ref&lt;Char&gt;;
810    arg_ref_type width_ref;
811    arg_ref_type precision_ref;
812    mutable basic_string_view&lt;Char&gt; format_str;
813    using duration = std::chrono::duration&lt;Rep, Period&gt;;
814    struct spec_handler {
815      formatter&amp; f;
816      basic_format_parse_context&lt;Char&gt;&amp; context;
817      basic_string_view&lt;Char&gt; format_str;
818      template &lt;typename Id&gt; FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
819        context.check_arg_id(arg_id);
820        return arg_ref_type(arg_id);
821      }
822      FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view&lt;Char&gt; arg_id) {
823        context.check_arg_id(arg_id);
824        return arg_ref_type(arg_id);
825      }
826      FMT_CONSTEXPR arg_ref_type make_arg_ref(detail::auto_id) {
827        return arg_ref_type(context.next_arg_id());
828      }
829      void on_error(const char* msg) { FMT_THROW(format_error(msg)); }
830      void on_fill(basic_string_view&lt;Char&gt; fill) { f.specs.fill = fill; }
831      void on_align(align_t align) { f.specs.align = align; }
832      void on_width(int width) { f.specs.width = width; }
833      void on_precision(int _precision) { f.precision = _precision; }
834      void end_precision() {}
835      template &lt;typename Id&gt; void on_dynamic_width(Id arg_id) {
836        f.width_ref = make_arg_ref(arg_id);
837      }
838      template &lt;typename Id&gt; void on_dynamic_precision(Id arg_id) {
839        f.precision_ref = make_arg_ref(arg_id);
840      }
841    };
842    using iterator = typename basic_format_parse_context&lt;Char&gt;::iterator;
843    struct parse_range {
844      iterator begin;
845      iterator end;
846    };
847    FMT_CONSTEXPR parse_range do_parse(basic_format_parse_context&lt;Char&gt;&amp; ctx) {
848      auto begin = ctx.begin(), end = ctx.end();
849      if (begin == end || *begin == &#x27;}&#x27;) return {begin, begin};
850      spec_handler handler{*this, ctx, format_str};
851      begin = detail::parse_align(begin, end, handler);
852      if (begin == end) return {begin, begin};
853      begin = detail::parse_width(begin, end, handler);
854      if (begin == end) return {begin, begin};
855      if (*begin == &#x27;.&#x27;) {
856        if (std::is_floating_point&lt;Rep&gt;::value)
857          begin = detail::parse_precision(begin, end, handler);
858        else
859          handler.on_error(&quot;precision not allowed for this argument type&quot;);
860      }
861      end = parse_chrono_format(begin, end, detail::chrono_format_checker());
862      return {begin, end};
863    }
864   public:
865    formatter() : precision(-1) {}
866    FMT_CONSTEXPR auto parse(basic_format_parse_context&lt;Char&gt;&amp; ctx)
867        -&gt; decltype(ctx.begin()) {
868      auto range = do_parse(ctx);
869      format_str = basic_string_view&lt;Char&gt;(
870          &amp;*range.begin, detail::to_unsigned(range.end - range.begin));
871      return range.end;
872    }
873    template &lt;typename FormatContext&gt;
874    auto format(const duration&amp; d, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
875      auto begin = format_str.begin(), end = format_str.end();
876      basic_memory_buffer&lt;Char&gt; buf;
877      auto out = std::back_inserter(buf);
878      detail::handle_dynamic_spec&lt;detail::width_checker&gt;(specs.width, width_ref,
879                                                         ctx);
880      detail::handle_dynamic_spec&lt;detail::precision_checker&gt;(precision,
881                                                             precision_ref, ctx);
882      if (begin == end || *begin == &#x27;}&#x27;) {
883        out = detail::format_duration_value&lt;Char&gt;(out, d.count(), precision);
884        detail::format_duration_unit&lt;Char, Period&gt;(out);
885      } else {
886        detail::chrono_formatter&lt;FormatContext, decltype(out), Rep, Period&gt; f(
887            ctx, out, d);
888        f.precision = precision;
889        parse_chrono_format(begin, end, f);
890      }
891      return detail::write(
892          ctx.out(), basic_string_view&lt;Char&gt;(buf.data(), buf.size()), specs);
893    }
894  };
895  FMT_END_NAMESPACE
896  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</div>
                </div>
                <div class="column column_space"><pre><code>753        using duration_rep = std::chrono::duration&lt;rep, Period&gt;;
754        using duration_Rep = std::chrono::duration&lt;Rep, Period&gt;;
</pre></code></div>
                <div class="column column_space"><pre><code>131    using From = std::chrono::duration&lt;FromRep, FromPeriod&gt;;
132    ec = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    