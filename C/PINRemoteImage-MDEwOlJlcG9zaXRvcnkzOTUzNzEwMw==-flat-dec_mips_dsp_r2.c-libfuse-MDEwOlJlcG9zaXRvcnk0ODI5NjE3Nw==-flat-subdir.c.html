
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.0606060606060606%, Tokens: 26</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_mips_dsp_r2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MIPS_DSP_R2)
3  #include "src/dsp/mips_macro.h"
4  static const int kC1 = 20091 + (1 << 16);
5  static const int kC2 = 35468;
6  #define MUL(a, b) (((a) * (b)) >> 16)
7  static void TransformDC(const int16_t* in, uint8_t* dst) {
8    int temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9, temp10;
9    __asm__ volatile (
10      LOAD_WITH_OFFSET_X4(temp1, temp2, temp3, temp4, dst,
11                          0, 0, 0, 0,
12                          0, 1, 2, 3,
13                          BPS)
14      "lh               %[temp5],  0(%[in])               \n\t"
15      "addiu            %[temp5],  %[temp5],  4           \n\t"
16      "ins              %[temp5],  %[temp5],  16, 16      \n\t"
17      "shra.ph          %[temp5],  %[temp5],  3           \n\t"
18      CONVERT_2_BYTES_TO_HALF(temp6, temp7, temp8, temp9, temp10, temp1, temp2,
19                              temp3, temp1, temp2, temp3, temp4)
20      STORE_SAT_SUM_X2(temp6, temp7, temp8, temp9, temp10, temp1, temp2, temp3,
21                       temp5, temp5, temp5, temp5, temp5, temp5, temp5, temp5,
22                       dst, 0, 1, 2, 3, BPS)
23      OUTPUT_EARLY_CLOBBER_REGS_10()
24      : [in]"r"(in), [dst]"r"(dst)
25      : "memory"
26    );
27  }
28  static void TransformAC3(const int16_t* in, uint8_t* dst) {
29    const int a = in[0] + 4;
30    int c4 = MUL(in[4], kC2);
31    const int d4 = MUL(in[4], kC1);
32    const int c1 = MUL(in[1], kC2);
33    const int d1 = MUL(in[1], kC1);
34    int temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9;
35    int temp10, temp11, temp12, temp13, temp14, temp15, temp16, temp17, temp18;
36    __asm__ volatile (
37      "ins              %[c4],      %[d4],     16,       16    \n\t"
38      "replv.ph         %[temp1],   %[a]                       \n\t"
39      "replv.ph         %[temp4],   %[d1]                      \n\t"
40      ADD_SUB_HALVES(temp2, temp3, temp1, c4)
41      "replv.ph         %[temp5],   %[c1]                      \n\t"
42      SHIFT_R_SUM_X2(temp1, temp6, temp7, temp8, temp2, temp9, temp10, temp4,
43                     temp2, temp2, temp3, temp3, temp4, temp5, temp4, temp5)
44      LOAD_WITH_OFFSET_X4(temp3, temp5, temp11, temp12, dst,
45                          0, 0, 0, 0,
46                          0, 1, 2, 3,
47                          BPS)
48      CONVERT_2_BYTES_TO_HALF(temp13, temp14, temp3, temp15, temp5, temp16,
49                              temp11, temp17, temp3, temp5, temp11, temp12)
50      PACK_2_HALVES_TO_WORD(temp12, temp18, temp7, temp6, temp1, temp8, temp2,
51                            temp4, temp7, temp6, temp10, temp9)
52      STORE_SAT_SUM_X2(temp13, temp14, temp3, temp15, temp5, temp16, temp11,
53                       temp17, temp12, temp18, temp1, temp8, temp2, temp4,
54                       temp7, temp6, dst, 0, 1, 2, 3, BPS)
55      OUTPUT_EARLY_CLOBBER_REGS_18(),
56        [c4]"+&r"(c4)
57      : [dst]"r"(dst), [a]"r"(a), [d1]"r"(d1), [d4]"r"(d4), [c1]"r"(c1)
58      : "memory"
59    );
60  }
61  static void TransformOne(const int16_t* in, uint8_t* dst) {
62    int temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9;
63    int temp10, temp11, temp12, temp13, temp14, temp15, temp16, temp17, temp18;
64    __asm__ volatile (
65      "ulw              %[temp1],   0(%[in])                 \n\t"
66      "ulw              %[temp2],   16(%[in])                \n\t"
67      LOAD_IN_X2(temp5, temp6, 24, 26)
68      ADD_SUB_HALVES(temp3, temp4, temp1, temp2)
69      LOAD_IN_X2(temp1, temp2, 8, 10)
70      MUL_SHIFT_SUM(temp7, temp8, temp9, temp10, temp11, temp12, temp13, temp14,
71                    temp10, temp8, temp9, temp7, temp1, temp2, temp5, temp6,
72                    temp13, temp11, temp14, temp12)
73      INSERT_HALF_X2(temp8, temp7, temp10, temp9)
74      "ulw              %[temp17],  4(%[in])                 \n\t"
75      "ulw              %[temp18],  20(%[in])                \n\t"
76      ADD_SUB_HALVES(temp1, temp2, temp3, temp8)
77      ADD_SUB_HALVES(temp5, temp6, temp4, temp7)
78      ADD_SUB_HALVES(temp7, temp8, temp17, temp18)
79      LOAD_IN_X2(temp17, temp18, 12, 14)
80      LOAD_IN_X2(temp9, temp10, 28, 30)
81      MUL_SHIFT_SUM(temp11, temp12, temp13, temp14, temp15, temp16, temp4, temp17,
82                    temp12, temp14, temp11, temp13, temp17, temp18, temp9, temp10,
83                    temp15, temp4, temp16, temp17)
84      INSERT_HALF_X2(temp11, temp12, temp13, temp14)
85      ADD_SUB_HALVES(temp17, temp8, temp8, temp11)
86      ADD_SUB_HALVES(temp3, temp4, temp7, temp12)
87      SRA_16(temp9, temp10, temp11, temp12, temp1, temp2, temp5, temp6)
88      INSERT_HALF_X2(temp1, temp6, temp5, temp2)
89      SRA_16(temp13, temp14, temp15, temp16, temp3, temp4, temp17, temp8)
90      "repl.ph          %[temp2],   0x4                      \n\t"
91      INSERT_HALF_X2(temp3, temp8, temp17, temp4)
92      "addq.ph          %[temp1],   %[temp1],  %[temp2]      \n\t"
93      "addq.ph          %[temp6],   %[temp6],  %[temp2]      \n\t"
94      ADD_SUB_HALVES(temp2, temp4, temp1, temp3)
95      ADD_SUB_HALVES(temp5, temp7, temp6, temp8)
96      MUL_SHIFT_SUM(temp1, temp3, temp6, temp8, temp9, temp13, temp17, temp18,
97                    temp3, temp13, temp1, temp9, temp9, temp13, temp11, temp15,
98                    temp6, temp17, temp8, temp18)
99      MUL_SHIFT_SUM(temp6, temp8, temp18, temp17, temp11, temp15, temp12, temp16,
100                    temp8, temp15, temp6, temp11, temp12, temp16, temp10, temp14,
101                    temp18, temp12, temp17, temp16)
102      INSERT_HALF_X2(temp1, temp3, temp9, temp13)
103      INSERT_HALF_X2(temp6, temp8, temp11, temp15)
104      SHIFT_R_SUM_X2(temp9, temp10, temp11, temp12, temp13, temp14, temp15,
105                     temp16, temp2, temp4, temp5, temp7, temp3, temp1, temp8,
106                     temp6)
107      PACK_2_HALVES_TO_WORD(temp1, temp2, temp3, temp4, temp9, temp12, temp13,
108                            temp16, temp11, temp10, temp15, temp14)
109      LOAD_WITH_OFFSET_X4(temp10, temp11, temp14, temp15, dst,
110                          0, 0, 0, 0,
111                          0, 1, 2, 3,
112                          BPS)
113      CONVERT_2_BYTES_TO_HALF(temp5, temp6, temp7, temp8, temp17, temp18, temp10,
114                              temp11, temp10, temp11, temp14, temp15)
115      STORE_SAT_SUM_X2(temp5, temp6, temp7, temp8, temp17, temp18, temp10, temp11,
116                       temp9, temp12, temp1, temp2, temp13, temp16, temp3, temp4,
117                       dst, 0, 1, 2, 3, BPS)
118      OUTPUT_EARLY_CLOBBER_REGS_18()
119      : [dst]"r"(dst), [in]"r"(in), [kC1]"r"(kC1), [kC2]"r"(kC2)
120      : "memory", "hi", "lo"
121    );
122  }
123  static void TransformTwo(const int16_t* in, uint8_t* dst, int do_two) {
124    TransformOne(in, dst);
125    if (do_two) {
126      TransformOne(in + 16, dst + 4);
127    }
128  }
129  static WEBP_INLINE void FilterLoop26(uint8_t* p,
130                                       int hstride, int vstride, int size,
131                                       int thresh, int ithresh, int hev_thresh) {
132    const int thresh2 = 2 * thresh + 1;
133    int temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9;
134    int temp10, temp11, temp12, temp13, temp14, temp15;
135    __asm__ volatile (
136      ".set      push                                      \n\t"
137      ".set      noreorder                                 \n\t"
138    "1:                                                    \n\t"
139      "negu      %[temp1],  %[hstride]                     \n\t"
140      "addiu     %[size],   %[size],        -1             \n\t"
141      "sll       %[temp2],  %[hstride],     1              \n\t"
142      "sll       %[temp3],  %[temp1],       1              \n\t"
143      "addu      %[temp4],  %[temp2],       %[hstride]     \n\t"
144      "addu      %[temp5],  %[temp3],       %[temp1]       \n\t"
145      "lbu       %[temp7],  0(%[p])                        \n\t"
146      "sll       %[temp6],  %[temp3],       1              \n\t"
147      "lbux      %[temp8],  %[temp5](%[p])                 \n\t"
148      "lbux      %[temp9],  %[temp3](%[p])                 \n\t"
149      "lbux      %[temp10], %[temp1](%[p])                 \n\t"
150      "lbux      %[temp11], %[temp6](%[p])                 \n\t"
151      "lbux      %[temp12], %[hstride](%[p])               \n\t"
152      "lbux      %[temp13], %[temp2](%[p])                 \n\t"
153      "lbux      %[temp14], %[temp4](%[p])                 \n\t"
154      "subu      %[temp1],  %[temp10],      %[temp7]       \n\t"
155      "subu      %[temp2],  %[temp9],       %[temp12]      \n\t"
156      "absq_s.w  %[temp3],  %[temp1]                       \n\t"
157      "absq_s.w  %[temp4],  %[temp2]                       \n\t"
158      "negu      %[temp1],  %[temp1]                       \n\t"
159      "sll       %[temp3],  %[temp3],       2              \n\t"
160      "addu      %[temp15], %[temp3],       %[temp4]       \n\t"
161      "subu      %[temp3],  %[temp15],      %[thresh2]     \n\t"
162      "sll       %[temp6],  %[temp1],       1              \n\t"
163      "bgtz      %[temp3],  3f                             \n\t"
164      " subu     %[temp4],  %[temp11],      %[temp8]       \n\t"
165      "absq_s.w  %[temp4],  %[temp4]                       \n\t"
166      "shll_s.w  %[temp2],  %[temp2],       24             \n\t"
167      "subu      %[temp4],  %[temp4],       %[ithresh]     \n\t"
168      "bgtz      %[temp4],  3f                             \n\t"
169      " subu     %[temp3],  %[temp8],       %[temp9]       \n\t"
170      "absq_s.w  %[temp3],  %[temp3]                       \n\t"
171      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
172      "bgtz      %[temp3],  3f                             \n\t"
173      " subu     %[temp5],  %[temp9],       %[temp10]      \n\t"
174      "absq_s.w  %[temp3],  %[temp5]                       \n\t"
175      "absq_s.w  %[temp5],  %[temp5]                       \n\t"
176      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
177      "bgtz      %[temp3],  3f                             \n\t"
178      " subu     %[temp3],  %[temp14],      %[temp13]      \n\t"
179      "absq_s.w  %[temp3],  %[temp3]                       \n\t"
180      "slt       %[temp5],  %[hev_thresh],  %[temp5]       \n\t"
181      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
182      "bgtz      %[temp3],  3f                             \n\t"
183      " subu     %[temp3],  %[temp13],      %[temp12]      \n\t"
184      "absq_s.w  %[temp3],  %[temp3]                       \n\t"
185      "sra       %[temp4],  %[temp2],       24             \n\t"
186      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
187      "bgtz      %[temp3],  3f                             \n\t"
188      " subu     %[temp15], %[temp12],      %[temp7]       \n\t"
189      "absq_s.w  %[temp3],  %[temp15]                      \n\t"
190      "absq_s.w  %[temp15], %[temp15]                      \n\t"
191      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
192      "bgtz      %[temp3],  3f                             \n\t"
193      " slt      %[temp15], %[hev_thresh],  %[temp15]      \n\t"
194      "addu      %[temp3],  %[temp6],       %[temp1]       \n\t"
195      "or        %[temp2],  %[temp5],       %[temp15]      \n\t"
196      "addu      %[temp5],  %[temp4],       %[temp3]       \n\t"
197      "beqz      %[temp2],  4f                             \n\t"
198      " shra_r.w %[temp1],  %[temp5],       3              \n\t"
199      "addiu     %[temp2],  %[temp5],       3              \n\t"
200      "sra       %[temp2],  %[temp2],       3              \n\t"
201      "shll_s.w  %[temp1],  %[temp1],       27             \n\t"
202      "shll_s.w  %[temp2],  %[temp2],       27             \n\t"
203      "subu      %[temp3],  %[p],           %[hstride]     \n\t"
204      "sra       %[temp1],  %[temp1],       27             \n\t"
205      "sra       %[temp2],  %[temp2],       27             \n\t"
206      "subu      %[temp1],  %[temp7],       %[temp1]       \n\t"
207      "addu      %[temp2],  %[temp10],      %[temp2]       \n\t"
208      "lbux      %[temp2],  %[temp2](%[VP8kclip1])         \n\t"
209      "lbux      %[temp1],  %[temp1](%[VP8kclip1])         \n\t"
210      "sb        %[temp2],  0(%[temp3])                    \n\t"
211      "j         3f                                        \n\t"
212      " sb       %[temp1],  0(%[p])                        \n\t"
213    "4:                                                    \n\t"
214      "shll_s.w  %[temp5],  %[temp5],       24             \n\t"
215      "subu      %[temp14], %[p],           %[hstride]     \n\t"
216      "subu      %[temp11], %[temp14],      %[hstride]     \n\t"
217      "sra       %[temp6],  %[temp5],       24             \n\t"
218      "sll       %[temp1],  %[temp6],       3              \n\t"
219      "subu      %[temp15], %[temp11],      %[hstride]     \n\t"
220      "addu      %[temp2],  %[temp6],       %[temp1]       \n\t"
221      "sll       %[temp3],  %[temp2],       1              \n\t"
222      "addu      %[temp4],  %[temp3],       %[temp2]       \n\t"
223      "addiu     %[temp2],  %[temp2],       63             \n\t"
224      "addiu     %[temp3],  %[temp3],       63             \n\t"
225      "addiu     %[temp4],  %[temp4],       63             \n\t"
226      "sra       %[temp2],  %[temp2],       7              \n\t"
227      "sra       %[temp3],  %[temp3],       7              \n\t"
228      "sra       %[temp4],  %[temp4],       7              \n\t"
229      "addu      %[temp1],  %[temp8],       %[temp2]       \n\t"
230      "addu      %[temp5],  %[temp9],       %[temp3]       \n\t"
231      "addu      %[temp6],  %[temp10],      %[temp4]       \n\t"
232      "subu      %[temp8],  %[temp7],       %[temp4]       \n\t"
233      "subu      %[temp7],  %[temp12],      %[temp3]       \n\t"
234      "addu      %[temp10], %[p],           %[hstride]     \n\t"
235      "subu      %[temp9],  %[temp13],      %[temp2]       \n\t"
236      "addu      %[temp12], %[temp10],      %[hstride]     \n\t"
237      "lbux      %[temp2],  %[temp1](%[VP8kclip1])         \n\t"
238      "lbux      %[temp3],  %[temp5](%[VP8kclip1])         \n\t"
239      "lbux      %[temp4],  %[temp6](%[VP8kclip1])         \n\t"
240      "lbux      %[temp5],  %[temp8](%[VP8kclip1])         \n\t"
241      "lbux      %[temp6],  %[temp7](%[VP8kclip1])         \n\t"
242      "lbux      %[temp8],  %[temp9](%[VP8kclip1])         \n\t"
243      "sb        %[temp2],  0(%[temp15])                   \n\t"
244      "sb        %[temp3],  0(%[temp11])                   \n\t"
245      "sb        %[temp4],  0(%[temp14])                   \n\t"
246      "sb        %[temp5],  0(%[p])                        \n\t"
247      "sb        %[temp6],  0(%[temp10])                   \n\t"
248      "sb        %[temp8],  0(%[temp12])                   \n\t"
249    "3:                                                    \n\t"
250      "bgtz      %[size],   1b                             \n\t"
251      " addu     %[p],      %[p],           %[vstride]     \n\t"
252      ".set      pop                                       \n\t"
253      : [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),[temp3]"=&r"(temp3),
254        [temp4]"=&r"(temp4), [temp5]"=&r"(temp5), [temp6]"=&r"(temp6),
255        [temp7]"=&r"(temp7),[temp8]"=&r"(temp8),[temp9]"=&r"(temp9),
256        [temp10]"=&r"(temp10),[temp11]"=&r"(temp11),[temp12]"=&r"(temp12),
257        [temp13]"=&r"(temp13),[temp14]"=&r"(temp14),[temp15]"=&r"(temp15),
258        [size]"+&r"(size), [p]"+&r"(p)
259      : [hstride]"r"(hstride), [thresh2]"r"(thresh2),
260        [ithresh]"r"(ithresh),[vstride]"r"(vstride), [hev_thresh]"r"(hev_thresh),
261        [VP8kclip1]"r"(VP8kclip1)
262      : "memory"
263    );
264  }
265  static WEBP_INLINE void FilterLoop24(uint8_t* p,
266                                       int hstride, int vstride, int size,
267                                       int thresh, int ithresh, int hev_thresh) {
268    int p0, q0, p1, q1, p2, q2, p3, q3;
269    int step1, step2, temp1, temp2, temp3, temp4;
270    uint8_t* pTemp0;
271    uint8_t* pTemp1;
272    const int thresh2 = 2 * thresh + 1;
273    __asm__ volatile (
274      ".set      push                                   \n\t"
275      ".set      noreorder                              \n\t"
276      "bltz      %[size],    3f                         \n\t"
277      " nop                                             \n\t"
278    "2:                                                 \n\t"
279      "negu      %[step1],   %[hstride]                 \n\t"
280      "lbu       %[q0],      0(%[p])                    \n\t"
281      "lbux      %[p0],      %[step1](%[p])             \n\t"
282      "subu      %[step1],   %[step1],      %[hstride]  \n\t"
283      "lbux      %[q1],      %[hstride](%[p])           \n\t"
284      "subu      %[temp1],   %[p0],         %[q0]       \n\t"
285      "lbux      %[p1],      %[step1](%[p])             \n\t"
286      "addu      %[step2],   %[hstride],    %[hstride]  \n\t"
287      "absq_s.w  %[temp2],   %[temp1]                   \n\t"
288      "subu      %[temp3],   %[p1],         %[q1]       \n\t"
289      "absq_s.w  %[temp4],   %[temp3]                   \n\t"
290      "sll       %[temp2],   %[temp2],      2           \n\t"
291      "addu      %[temp2],   %[temp2],      %[temp4]    \n\t"
292      "subu      %[temp4],   %[temp2],      %[thresh2]  \n\t"
293      "subu      %[step1],   %[step1],      %[hstride]  \n\t"
294      "bgtz      %[temp4],   0f                         \n\t"
295      " lbux     %[p2],      %[step1](%[p])             \n\t"
296      "subu      %[step1],   %[step1],      %[hstride]  \n\t"
297      "lbux      %[q2],      %[step2](%[p])             \n\t"
298      "lbux      %[p3],      %[step1](%[p])             \n\t"
299      "subu      %[temp4],   %[p2],         %[p1]       \n\t"
300      "addu      %[step2],   %[step2],      %[hstride]  \n\t"
301      "subu      %[temp2],   %[p3],         %[p2]       \n\t"
302      "absq_s.w  %[temp4],   %[temp4]                   \n\t"
303      "absq_s.w  %[temp2],   %[temp2]                   \n\t"
304      "lbux      %[q3],      %[step2](%[p])             \n\t"
305      "subu      %[temp4],   %[temp4],      %[ithresh]  \n\t"
306      "negu      %[temp1],   %[temp1]                   \n\t"
307      "bgtz      %[temp4],   0f                         \n\t"
308      " subu     %[temp2],   %[temp2],      %[ithresh]  \n\t"
309      "subu      %[p3],      %[p1],         %[p0]       \n\t"
310      "bgtz      %[temp2],   0f                         \n\t"
311      " absq_s.w %[p3],      %[p3]                      \n\t"
312      "subu      %[temp4],   %[q3],         %[q2]       \n\t"
313      "subu      %[pTemp0],  %[p],          %[hstride]  \n\t"
314      "absq_s.w  %[temp4],   %[temp4]                   \n\t"
315      "subu      %[temp2],   %[p3],         %[ithresh]  \n\t"
316      "sll       %[step1],   %[temp1],      1           \n\t"
317      "bgtz      %[temp2],   0f                         \n\t"
318      " subu     %[temp4],   %[temp4],      %[ithresh]  \n\t"
319      "subu      %[temp2],   %[q2],         %[q1]       \n\t"
320      "bgtz      %[temp4],   0f                         \n\t"
321      " absq_s.w %[temp2],   %[temp2]                   \n\t"
322      "subu      %[q3],      %[q1],         %[q0]       \n\t"
323      "absq_s.w  %[q3],      %[q3]                      \n\t"
324      "subu      %[temp2],   %[temp2],      %[ithresh]  \n\t"
325      "addu      %[temp1],   %[temp1],      %[step1]    \n\t"
326      "bgtz      %[temp2],   0f                         \n\t"
327      " subu     %[temp4],   %[q3],         %[ithresh]  \n\t"
328      "slt       %[p3],      %[hev_thresh], %[p3]       \n\t"
329      "bgtz      %[temp4],   0f                         \n\t"
330      " slt      %[q3],      %[hev_thresh], %[q3]       \n\t"
331      "or        %[q3],      %[q3],         %[p3]       \n\t"
332      "bgtz      %[q3],      1f                         \n\t"
333      " shra_r.w %[temp2],   %[temp1],      3           \n\t"
334      "addiu     %[temp1],   %[temp1],      3           \n\t"
335      "sra       %[temp1],   %[temp1],      3           \n\t"
336      "shll_s.w  %[temp2],   %[temp2],      27          \n\t"
337      "shll_s.w  %[temp1],   %[temp1],      27          \n\t"
338      "addu      %[pTemp1],  %[p],          %[hstride]  \n\t"
339      "sra       %[temp2],   %[temp2],      27          \n\t"
340      "sra       %[temp1],   %[temp1],      27          \n\t"
341      "addiu     %[step1],   %[temp2],      1           \n\t"
342      "sra       %[step1],   %[step1],      1           \n\t"
343      "addu      %[p0],      %[p0],         %[temp1]    \n\t"
344      "addu      %[p1],      %[p1],         %[step1]    \n\t"
345      "subu      %[q0],      %[q0],         %[temp2]    \n\t"
346      "subu      %[q1],      %[q1],         %[step1]    \n\t"
347      "lbux      %[temp2],   %[p0](%[VP8kclip1])        \n\t"
348      "lbux      %[temp3],   %[q0](%[VP8kclip1])        \n\t"
349      "lbux      %[temp4],   %[q1](%[VP8kclip1])        \n\t"
350      "sb        %[temp2],   0(%[pTemp0])               \n\t"
351      "lbux      %[temp1],   %[p1](%[VP8kclip1])        \n\t"
352      "subu      %[pTemp0],  %[pTemp0],    %[hstride]   \n\t"
353      "sb        %[temp3],   0(%[p])                    \n\t"
354      "sb        %[temp4],   0(%[pTemp1])               \n\t"
355      "j         0f                                     \n\t"
356      " sb       %[temp1],   0(%[pTemp0])               \n\t"
357    "1:                                                 \n\t"
358      "shll_s.w  %[temp3],   %[temp3],      24          \n\t"
359      "sra       %[temp3],   %[temp3],      24          \n\t"
360      "addu      %[temp1],   %[temp1],      %[temp3]    \n\t"
361      "shra_r.w  %[temp2],   %[temp1],      3           \n\t"
362      "addiu     %[temp1],   %[temp1],      3           \n\t"
363      "shll_s.w  %[temp2],   %[temp2],      27          \n\t"
364      "sra       %[temp1],   %[temp1],      3           \n\t"
365      "shll_s.w  %[temp1],   %[temp1],      27          \n\t"
366      "sra       %[temp2],   %[temp2],      27          \n\t"
367      "sra       %[temp1],   %[temp1],      27          \n\t"
368      "addu      %[p0],      %[p0],         %[temp1]    \n\t"
369      "subu      %[q0],      %[q0],         %[temp2]    \n\t"
370      "lbux      %[temp1],   %[p0](%[VP8kclip1])        \n\t"
371      "lbux      %[temp2],   %[q0](%[VP8kclip1])        \n\t"
372      "sb        %[temp2],   0(%[p])                    \n\t"
373      "sb        %[temp1],   0(%[pTemp0])               \n\t"
374    "0:                                                 \n\t"
375      "subu      %[size],    %[size],       1           \n\t"
376      "bgtz      %[size],    2b                         \n\t"
377      " addu     %[p],       %[p],          %[vstride]  \n\t"
378    "3:                                                 \n\t"
379      ".set      pop                                    \n\t"
380      : [p0]"=&r"(p0), [q0]"=&r"(q0), [p1]"=&r"(p1), [q1]"=&r"(q1),
381        [p2]"=&r"(p2), [q2]"=&r"(q2), [p3]"=&r"(p3), [q3]"=&r"(q3),
382        [step2]"=&r"(step2), [step1]"=&r"(step1), [temp1]"=&r"(temp1),
383        [temp2]"=&r"(temp2), [temp3]"=&r"(temp3), [temp4]"=&r"(temp4),
384        [pTemp0]"=&r"(pTemp0), [pTemp1]"=&r"(pTemp1), [p]"+&r"(p),
385        [size]"+&r"(size)
386      : [vstride]"r"(vstride), [ithresh]"r"(ithresh),
387        [hev_thresh]"r"(hev_thresh), [hstride]"r"(hstride),
388        [VP8kclip1]"r"(VP8kclip1), [thresh2]"r"(thresh2)
389      : "memory"
390    );
391  }
392  static void VFilter16(uint8_t* p, int stride,
393                        int thresh, int ithresh, int hev_thresh) {
394    FilterLoop26(p, stride, 1, 16, thresh, ithresh, hev_thresh);
395  }
396  static void HFilter16(uint8_t* p, int stride,
397                        int thresh, int ithresh, int hev_thresh) {
398    FilterLoop26(p, 1, stride, 16, thresh, ithresh, hev_thresh);
399  }
400  static void VFilter8(uint8_t* u, uint8_t* v, int stride,
401                       int thresh, int ithresh, int hev_thresh) {
402    FilterLoop26(u, stride, 1, 8, thresh, ithresh, hev_thresh);
403    FilterLoop26(v, stride, 1, 8, thresh, ithresh, hev_thresh);
404  }
405  static void HFilter8(uint8_t* u, uint8_t* v, int stride,
406                       int thresh, int ithresh, int hev_thresh) {
407    FilterLoop26(u, 1, stride, 8, thresh, ithresh, hev_thresh);
408    FilterLoop26(v, 1, stride, 8, thresh, ithresh, hev_thresh);
409  }
410  static void VFilter16i(uint8_t* p, int stride,
411                         int thresh, int ithresh, int hev_thresh) {
412    int k;
413    for (k = 3; k > 0; --k) {
414      p += 4 * stride;
415      FilterLoop24(p, stride, 1, 16, thresh, ithresh, hev_thresh);
416    }
417  }
418  static void HFilter16i(uint8_t* p, int stride,
419                         int thresh, int ithresh, int hev_thresh) {
420    int k;
421    for (k = 3; k > 0; --k) {
422      p += 4;
423      FilterLoop24(p, 1, stride, 16, thresh, ithresh, hev_thresh);
424    }
425  }
426  static void VFilter8i(uint8_t* u, uint8_t* v, int stride,
427                        int thresh, int ithresh, int hev_thresh) {
428    FilterLoop24(u + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
429    FilterLoop24(v + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
430  }
431  static void HFilter8i(uint8_t* u, uint8_t* v, int stride,
432                        int thresh, int ithresh, int hev_thresh) {
433    FilterLoop24(u + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
434    FilterLoop24(v + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
435  }
436  #undef MUL
437  static void SimpleVFilter16(uint8_t* p, int stride, int thresh) {
438    int i;
439    const int thresh2 = 2 * thresh + 1;
440    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
441    uint8_t* p1 = p - stride;
442    __asm__ volatile (
443      ".set      push                                      \n\t"
444      ".set      noreorder                                 \n\t"
445      "li        %[i],        16                           \n\t"
446    "0:                                                    \n\t"
447      "negu      %[temp4],    %[stride]                    \n\t"
448      "sll       %[temp5],    %[temp4],       1            \n\t"
449      "lbu       %[temp2],    0(%[p])                      \n\t"
450      "lbux      %[temp3],    %[stride](%[p])              \n\t"
451      "lbux      %[temp1],    %[temp4](%[p])               \n\t"
452      "lbux      %[temp0],    %[temp5](%[p])               \n\t"
453      "subu      %[temp7],    %[temp1],       %[temp2]     \n\t"
454      "subu      %[temp6],    %[temp0],       %[temp3]     \n\t"
455      "absq_s.w  %[temp4],    %[temp7]                     \n\t"
456      "absq_s.w  %[temp5],    %[temp6]                     \n\t"
457      "sll       %[temp4],    %[temp4],       2            \n\t"
458      "subu      %[temp5],    %[temp5],       %[thresh2]   \n\t"
459      "addu      %[temp5],    %[temp4],       %[temp5]     \n\t"
460      "negu      %[temp8],    %[temp7]                     \n\t"
461      "bgtz      %[temp5],    1f                           \n\t"
462      " addiu    %[i],        %[i],           -1           \n\t"
463      "sll       %[temp4],    %[temp8],       1            \n\t"
464      "shll_s.w  %[temp5],    %[temp6],       24           \n\t"
465      "addu      %[temp3],    %[temp4],       %[temp8]     \n\t"
466      "sra       %[temp5],    %[temp5],       24           \n\t"
467      "addu      %[temp3],    %[temp3],       %[temp5]     \n\t"
468      "addiu     %[temp7],    %[temp3],       3            \n\t"
469      "sra       %[temp7],    %[temp7],       3            \n\t"
470      "shra_r.w  %[temp8],    %[temp3],       3            \n\t"
471      "shll_s.w  %[temp0],    %[temp7],       27           \n\t"
472      "shll_s.w  %[temp4],    %[temp8],       27           \n\t"
473      "sra       %[temp0],    %[temp0],       27           \n\t"
474      "sra       %[temp4],    %[temp4],       27           \n\t"
475      "addu      %[temp7],    %[temp1],       %[temp0]     \n\t"
476      "subu      %[temp2],    %[temp2],       %[temp4]     \n\t"
477      "lbux      %[temp3],    %[temp7](%[VP8kclip1])       \n\t"
478      "lbux      %[temp4],    %[temp2](%[VP8kclip1])       \n\t"
479      "sb        %[temp3],    0(%[p1])                     \n\t"
480      "sb        %[temp4],    0(%[p])                      \n\t"
481    "1:                                                    \n\t"
482      "addiu     %[p1],       %[p1],          1            \n\t"
483      "bgtz      %[i],        0b                           \n\t"
484      " addiu    %[p],        %[p],           1            \n\t"
485      " .set     pop                                       \n\t"
486      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
487        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
488        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
489        [p]"+&r"(p), [i]"=&r"(i), [p1]"+&r"(p1)
490      : [stride]"r"(stride), [VP8kclip1]"r"(VP8kclip1), [thresh2]"r"(thresh2)
491      : "memory"
492    );
493  }
494  #define LOAD_4_BYTES(TEMP0, TEMP1, TEMP2, TEMP3,                               \
495                       A, A1, B, B1, C, C1, D, D1, SRC)                          \
496    "lbu      %[" #TEMP0 "],   " #A "+" #A1 "*" XSTR(BPS) "(%[" #SRC "]) \n\t"   \
497    "lbu      %[" #TEMP1 "],   " #B "+" #B1 "*" XSTR(BPS) "(%[" #SRC "]) \n\t"   \
498    "lbu      %[" #TEMP2 "],   " #C "+" #C1 "*" XSTR(BPS) "(%[" #SRC "]) \n\t"   \
499    "lbu      %[" #TEMP3 "],   " #D "+" #D1 "*" XSTR(BPS) "(%[" #SRC "]) \n\t"   \
500  
501  static void SimpleHFilter16(uint8_t* p, int stride, int thresh) {
502    int i;
503    const int thresh2 = 2 * thresh + 1;
504    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
505    __asm__ volatile (
506      ".set      push                                     \n\t"
507      ".set      noreorder                                \n\t"
508      "li        %[i],       16                           \n\t"
509    "0:                                                   \n\t"
510      LOAD_4_BYTES(temp0, temp1, temp2, temp3, -2, 0, -1, 0, 0, 0, 1, 0, p)
511      "subu      %[temp7],    %[temp1],       %[temp2]    \n\t"
512      "subu      %[temp6],    %[temp0],       %[temp3]    \n\t"
513      "absq_s.w  %[temp4],    %[temp7]                    \n\t"
514      "absq_s.w  %[temp5],    %[temp6]                    \n\t"
515      "sll       %[temp4],    %[temp4],       2           \n\t"
516      "addu      %[temp5],    %[temp4],       %[temp5]    \n\t"
517      "subu      %[temp5],    %[temp5],       %[thresh2]  \n\t"
518      "negu      %[temp8],    %[temp7]                    \n\t"
519      "bgtz      %[temp5],    1f                          \n\t"
520      " addiu    %[i],        %[i],           -1          \n\t"
521      "sll       %[temp4],    %[temp8],       1           \n\t"
522      "shll_s.w  %[temp5],    %[temp6],       24          \n\t"
523      "addu      %[temp3],    %[temp4],       %[temp8]    \n\t"
524      "sra       %[temp5],    %[temp5],       24          \n\t"
525      "addu      %[temp3],    %[temp3],       %[temp5]    \n\t"
526      "addiu     %[temp7],    %[temp3],       3           \n\t"
527      "sra       %[temp7],    %[temp7],       3           \n\t"
528      "shra_r.w  %[temp8],    %[temp3],       3           \n\t"
529      "shll_s.w  %[temp0],    %[temp7],       27          \n\t"
530      "shll_s.w  %[temp4],    %[temp8],       27          \n\t"
531      "sra       %[temp0],    %[temp0],       27          \n\t"
532      "sra       %[temp4],    %[temp4],       27          \n\t"
533      "addu      %[temp7],    %[temp1],       %[temp0]    \n\t"
534      "subu      %[temp2],    %[temp2],       %[temp4]    \n\t"
535      "lbux      %[temp3],    %[temp7](%[VP8kclip1])      \n\t"
536      "lbux      %[temp4],    %[temp2](%[VP8kclip1])      \n\t"
537      "sb        %[temp3],    -1(%[p])                    \n\t"
538      "sb        %[temp4],    0(%[p])                     \n\t"
539    "1:                                                   \n\t"
540      "bgtz      %[i],        0b                          \n\t"
541      " addu     %[p],        %[p],           %[stride]   \n\t"
542      ".set      pop                                      \n\t"
543      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
544        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
545        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
546        [p]"+&r"(p), [i]"=&r"(i)
547      : [stride]"r"(stride), [VP8kclip1]"r"(VP8kclip1), [thresh2]"r"(thresh2)
548      : "memory"
549    );
550  }
551  static void SimpleVFilter16i(uint8_t* p, int stride, int thresh) {
552    int k;
553    for (k = 3; k > 0; --k) {
554      p += 4 * stride;
555      SimpleVFilter16(p, stride, thresh);
556    }
557  }
558  static void SimpleHFilter16i(uint8_t* p, int stride, int thresh) {
559    int k;
560    for (k = 3; k > 0; --k) {
561      p += 4;
562      SimpleHFilter16(p, stride, thresh);
563    }
564  }
565  #define STORE_8_BYTES(TEMP0, TEMP1, A, B, C, DST)                              \
566    "usw    %[" #TEMP0 "],   " #A "*" XSTR(BPS) "(%[" #DST "])         \n\t"     \
567    "usw    %[" #TEMP1 "],   " #B "+" #C "*" XSTR(BPS) "(%[" #DST "])  \n\t"
568  static void VE4(uint8_t* dst) {    
569    const uint8_t* top = dst - BPS;
570    int temp0, temp1, temp2, temp3, temp4, temp5, temp6;
571    __asm__ volatile (
572      "ulw             %[temp0],   -1(%[top])              \n\t"
573      "ulh             %[temp1],   3(%[top])               \n\t"
574      "preceu.ph.qbr   %[temp2],   %[temp0]                \n\t"
575      "preceu.ph.qbl   %[temp3],   %[temp0]                \n\t"
576      "preceu.ph.qbr   %[temp4],   %[temp1]                \n\t"
577      "packrl.ph       %[temp5],   %[temp3],    %[temp2]   \n\t"
578      "packrl.ph       %[temp6],   %[temp4],    %[temp3]   \n\t"
579      "shll.ph         %[temp5],   %[temp5],    1          \n\t"
580      "shll.ph         %[temp6],   %[temp6],    1          \n\t"
581      "addq.ph         %[temp2],   %[temp5],    %[temp2]   \n\t"
582      "addq.ph         %[temp6],   %[temp6],    %[temp4]   \n\t"
583      "addq.ph         %[temp2],   %[temp2],    %[temp3]   \n\t"
584      "addq.ph         %[temp6],   %[temp6],    %[temp3]   \n\t"
585      "shra_r.ph       %[temp2],   %[temp2],    2          \n\t"
586      "shra_r.ph       %[temp6],   %[temp6],    2          \n\t"
587      "precr.qb.ph     %[temp4],   %[temp6],    %[temp2]   \n\t"
588      STORE_8_BYTES(temp4, temp4, 0, 0, 1, dst)
589      STORE_8_BYTES(temp4, temp4, 2, 0, 3, dst)
590      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
591        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
592        [temp6]"=&r"(temp6)
593      : [top]"r"(top), [dst]"r"(dst)
594      : "memory"
595    );
596  }
597  static void DC4(uint8_t* dst) {   
598    int temp0, temp1, temp2, temp3, temp4;
599    __asm__ volatile (
600      "ulw          %[temp0],   -1*" XSTR(BPS) "(%[dst]) \n\t"
601      LOAD_4_BYTES(temp1, temp2, temp3, temp4, -1, 0, -1, 1, -1, 2, -1, 3, dst)
602      "ins          %[temp1],   %[temp2],    8,     8    \n\t"
603      "ins          %[temp1],   %[temp3],    16,    8    \n\t"
604      "ins          %[temp1],   %[temp4],    24,    8    \n\t"
605      "raddu.w.qb   %[temp0],   %[temp0]                 \n\t"
606      "raddu.w.qb   %[temp1],   %[temp1]                 \n\t"
607      "addu         %[temp0],   %[temp0],    %[temp1]    \n\t"
608      "shra_r.w     %[temp0],   %[temp0],    3           \n\t"
609      "replv.qb     %[temp0],   %[temp0]                 \n\t"
610      STORE_8_BYTES(temp0, temp0, 0, 0, 1, dst)
611      STORE_8_BYTES(temp0, temp0, 2, 0, 3, dst)
612      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
613        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4)
614      : [dst]"r"(dst)
615      : "memory"
616    );
617  }
618  static void RD4(uint8_t* dst) {   
619    int temp0, temp1, temp2, temp3, temp4;
620    int temp5, temp6, temp7, temp8;
621    __asm__ volatile (
622      LOAD_4_BYTES(temp0, temp1, temp2, temp3, -1, 0, -1, 1, -1, 2, -1, 3, dst)
623      "ulw            %[temp7],   -1-" XSTR(BPS) "(%[dst])       \n\t"
624      "ins            %[temp1],   %[temp0], 16, 16               \n\t"
625      "preceu.ph.qbr  %[temp5],   %[temp7]                       \n\t"
626      "ins            %[temp2],   %[temp1], 16, 16               \n\t"
627      "preceu.ph.qbl  %[temp4],   %[temp7]                       \n\t"
628      "ins            %[temp3],   %[temp2], 16, 16               \n\t"
629      "shll.ph        %[temp2],   %[temp2], 1                    \n\t"
630      "addq.ph        %[temp3],   %[temp3], %[temp1]             \n\t"
631      "packrl.ph      %[temp6],   %[temp5], %[temp1]             \n\t"
632      "addq.ph        %[temp3],   %[temp3], %[temp2]             \n\t"
633      "addq.ph        %[temp1],   %[temp1], %[temp5]             \n\t"
634      "shll.ph        %[temp6],   %[temp6], 1                    \n\t"
635      "addq.ph        %[temp1],   %[temp1], %[temp6]             \n\t"
636      "packrl.ph      %[temp0],   %[temp4], %[temp5]             \n\t"
637      "addq.ph        %[temp8],   %[temp5], %[temp4]             \n\t"
638      "shra_r.ph      %[temp3],   %[temp3], 2                    \n\t"
639      "shll.ph        %[temp0],   %[temp0], 1                    \n\t"
640      "shra_r.ph      %[temp1],   %[temp1], 2                    \n\t"
641      "addq.ph        %[temp8],   %[temp0], %[temp8]             \n\t"
642      "lbu            %[temp5],   3-" XSTR(BPS) "(%[dst])        \n\t"
643      "precrq.ph.w    %[temp7],   %[temp7], %[temp7]             \n\t"
644      "shra_r.ph      %[temp8],   %[temp8], 2                    \n\t"
645      "ins            %[temp7],   %[temp5], 0,  8                \n\t"
646      "precr.qb.ph    %[temp2],   %[temp1], %[temp3]             \n\t"
647      "raddu.w.qb     %[temp4],   %[temp7]                       \n\t"
648      "precr.qb.ph    %[temp6],   %[temp8], %[temp1]             \n\t"
649      "shra_r.w       %[temp4],   %[temp4], 2                    \n\t"
650      STORE_8_BYTES(temp2, temp6, 3, 0, 1, dst)
651      "prepend        %[temp2],   %[temp8], 8                    \n\t"
652      "prepend        %[temp6],   %[temp4], 8                    \n\t"
653      STORE_8_BYTES(temp2, temp6, 2, 0, 0, dst)
654      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
655        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
656        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8)
657      : [dst]"r"(dst)
658      : "memory"
659    );
660  }
661  #define LOAD_8_BYTES(TEMP0, TEMP1, A, B, C, SRC)                               \
662    "ulw    %[" #TEMP0 "],   " #A "*" XSTR(BPS) "(%[" #SRC "])         \n\t"     \
663    "ulw    %[" #TEMP1 "],   " #B "+" #C "*" XSTR(BPS) "(%[" #SRC "])  \n\t"
664  static void LD4(uint8_t* dst) {   
665    int temp0, temp1, temp2, temp3, temp4;
666    int temp5, temp6, temp7, temp8, temp9;
667    __asm__ volatile (
668      LOAD_8_BYTES(temp0, temp1, -1, 4, -1, dst)
669      "preceu.ph.qbl   %[temp2],    %[temp0]                     \n\t"
670      "preceu.ph.qbr   %[temp3],    %[temp0]                     \n\t"
671      "preceu.ph.qbr   %[temp4],    %[temp1]                     \n\t"
672      "preceu.ph.qbl   %[temp5],    %[temp1]                     \n\t"
673      "packrl.ph       %[temp6],    %[temp2],    %[temp3]        \n\t"
674      "packrl.ph       %[temp7],    %[temp4],    %[temp2]        \n\t"
675      "packrl.ph       %[temp8],    %[temp5],    %[temp4]        \n\t"
676      "shll.ph         %[temp6],    %[temp6],    1               \n\t"
677      "addq.ph         %[temp9],    %[temp2],    %[temp6]        \n\t"
678      "shll.ph         %[temp7],    %[temp7],    1               \n\t"
679      "addq.ph         %[temp9],    %[temp9],    %[temp3]        \n\t"
680      "shll.ph         %[temp8],    %[temp8],    1               \n\t"
681      "shra_r.ph       %[temp9],    %[temp9],    2               \n\t"
682      "addq.ph         %[temp3],    %[temp4],    %[temp7]        \n\t"
683      "addq.ph         %[temp0],    %[temp5],    %[temp8]        \n\t"
684      "addq.ph         %[temp3],    %[temp3],    %[temp2]        \n\t"
685      "addq.ph         %[temp0],    %[temp0],    %[temp4]        \n\t"
686      "shra_r.ph       %[temp3],    %[temp3],    2               \n\t"
687      "shra_r.ph       %[temp0],    %[temp0],    2               \n\t"
688      "srl             %[temp1],    %[temp1],    24              \n\t"
689      "sll             %[temp1],    %[temp1],    1               \n\t"
690      "raddu.w.qb      %[temp5],    %[temp5]                     \n\t"
691      "precr.qb.ph     %[temp9],    %[temp3],    %[temp9]        \n\t"
692      "precr.qb.ph     %[temp3],    %[temp0],    %[temp3]        \n\t"
693      "addu            %[temp1],    %[temp1],    %[temp5]        \n\t"
694      "shra_r.w        %[temp1],    %[temp1],    2               \n\t"
695      STORE_8_BYTES(temp9, temp3, 0, 0, 2, dst)
696      "prepend         %[temp9],    %[temp0],    8               \n\t"
697      "prepend         %[temp3],    %[temp1],    8               \n\t"
698      STORE_8_BYTES(temp9, temp3, 1, 0, 3, dst)
699      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
700        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
701        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
702        [temp9]"=&r"(temp9)
703      : [dst]"r"(dst)
704      : "memory"
705    );
706  }
707  static void DC8uv(uint8_t* dst) {     
708    int temp0, temp1, temp2, temp3, temp4;
709    int temp5, temp6, temp7, temp8, temp9;
710    __asm__ volatile (
711      LOAD_8_BYTES(temp0, temp1, -1, 4, -1, dst)
712      LOAD_4_BYTES(temp2, temp3, temp4, temp5, -1, 0, -1, 1, -1, 2, -1, 3, dst)
713      LOAD_4_BYTES(temp6, temp7, temp8, temp9, -1, 4, -1, 5, -1, 6, -1, 7, dst)
714      "raddu.w.qb   %[temp0],   %[temp0]                   \n\t"
715      "raddu.w.qb   %[temp1],   %[temp1]                   \n\t"
716      "addu         %[temp2],   %[temp2],    %[temp3]      \n\t"
717      "addu         %[temp4],   %[temp4],    %[temp5]      \n\t"
718      "addu         %[temp6],   %[temp6],    %[temp7]      \n\t"
719      "addu         %[temp8],   %[temp8],    %[temp9]      \n\t"
720      "addu         %[temp0],   %[temp0],    %[temp1]      \n\t"
721      "addu         %[temp2],   %[temp2],    %[temp4]      \n\t"
722      "addu         %[temp6],   %[temp6],    %[temp8]      \n\t"
723      "addu         %[temp0],   %[temp0],    %[temp2]      \n\t"
724      "addu         %[temp0],   %[temp0],    %[temp6]      \n\t"
725      "shra_r.w     %[temp0],   %[temp0],    4             \n\t"
726      "replv.qb     %[temp0],   %[temp0]                   \n\t"
727      STORE_8_BYTES(temp0, temp0, 0, 4, 0, dst)
728      STORE_8_BYTES(temp0, temp0, 1, 4, 1, dst)
729      STORE_8_BYTES(temp0, temp0, 2, 4, 2, dst)
730      STORE_8_BYTES(temp0, temp0, 3, 4, 3, dst)
731      STORE_8_BYTES(temp0, temp0, 4, 4, 4, dst)
732      STORE_8_BYTES(temp0, temp0, 5, 4, 5, dst)
733      STORE_8_BYTES(temp0, temp0, 6, 4, 6, dst)
734      STORE_8_BYTES(temp0, temp0, 7, 4, 7, dst)
735      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
736        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
737        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
738        [temp9]"=&r"(temp9)
739      : [dst]"r"(dst)
740      : "memory"
741    );
742  }
743  static void DC8uvNoLeft(uint8_t* dst) {   
744    int temp0, temp1;
745    __asm__ volatile (
746      LOAD_8_BYTES(temp0, temp1, -1, 4, -1, dst)
747      "raddu.w.qb   %[temp0],   %[temp0]                   \n\t"
748      "raddu.w.qb   %[temp1],   %[temp1]                   \n\t"
749      "addu         %[temp0],   %[temp0],    %[temp1]      \n\t"
750      "shra_r.w     %[temp0],   %[temp0],    3             \n\t"
751      "replv.qb     %[temp0],   %[temp0]                   \n\t"
752      STORE_8_BYTES(temp0, temp0, 0, 4, 0, dst)
753      STORE_8_BYTES(temp0, temp0, 1, 4, 1, dst)
754      STORE_8_BYTES(temp0, temp0, 2, 4, 2, dst)
755      STORE_8_BYTES(temp0, temp0, 3, 4, 3, dst)
756      STORE_8_BYTES(temp0, temp0, 4, 4, 4, dst)
757      STORE_8_BYTES(temp0, temp0, 5, 4, 5, dst)
758      STORE_8_BYTES(temp0, temp0, 6, 4, 6, dst)
759      STORE_8_BYTES(temp0, temp0, 7, 4, 7, dst)
760      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1)
761      : [dst]"r"(dst)
762      : "memory"
763    );
764  }
765  static void DC8uvNoTop(uint8_t* dst) {  
766    int temp0, temp1, temp2, temp3, temp4;
767    int temp5, temp6, temp7, temp8;
768    __asm__ volatile (
769      LOAD_4_BYTES(temp2, temp3, temp4, temp5, -1, 0, -1, 1, -1, 2, -1, 3, dst)
770      LOAD_4_BYTES(temp6, temp7, temp8, temp1, -1, 4, -1, 5, -1, 6, -1, 7, dst)
771      "addu         %[temp2],   %[temp2],    %[temp3]      \n\t"
772      "addu         %[temp4],   %[temp4],    %[temp5]      \n\t"
773      "addu         %[temp6],   %[temp6],    %[temp7]      \n\t"
774      "addu         %[temp8],   %[temp8],    %[temp1]      \n\t"
775      "addu         %[temp2],   %[temp2],    %[temp4]      \n\t"
776      "addu         %[temp6],   %[temp6],    %[temp8]      \n\t"
777      "addu         %[temp0],   %[temp6],    %[temp2]      \n\t"
778      "shra_r.w     %[temp0],   %[temp0],    3             \n\t"
779      "replv.qb     %[temp0],   %[temp0]                   \n\t"
780      STORE_8_BYTES(temp0, temp0, 0, 4, 0, dst)
781      STORE_8_BYTES(temp0, temp0, 1, 4, 1, dst)
782      STORE_8_BYTES(temp0, temp0, 2, 4, 2, dst)
783      STORE_8_BYTES(temp0, temp0, 3, 4, 3, dst)
784      STORE_8_BYTES(temp0, temp0, 4, 4, 4, dst)
785      STORE_8_BYTES(temp0, temp0, 5, 4, 5, dst)
786      STORE_8_BYTES(temp0, temp0, 6, 4, 6, dst)
787      STORE_8_BYTES(temp0, temp0, 7, 4, 7, dst)
788      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
789        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
790        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8)
791      : [dst]"r"(dst)
792      : "memory"
793    );
794  }
795  #undef LOAD_8_BYTES
796  #undef STORE_8_BYTES
797  #undef LOAD_4_BYTES
798  #define CLIPPING(SIZE)                                                         \
799    "preceu.ph.qbl   %[temp2],   %[temp0]                  \n\t"                 \
800    "preceu.ph.qbr   %[temp0],   %[temp0]                  \n\t"                 \
801  ".if " #SIZE " == 8                                      \n\t"                 \
802    "preceu.ph.qbl   %[temp3],   %[temp1]                  \n\t"                 \
803    "preceu.ph.qbr   %[temp1],   %[temp1]                  \n\t"                 \
804  ".endif                                                  \n\t"                 \
805    "addu.ph         %[temp2],   %[temp2],   %[dst_1]      \n\t"                 \
806    "addu.ph         %[temp0],   %[temp0],   %[dst_1]      \n\t"                 \
807  ".if " #SIZE " == 8                                      \n\t"                 \
808    "addu.ph         %[temp3],   %[temp3],   %[dst_1]      \n\t"                 \
809    "addu.ph         %[temp1],   %[temp1],   %[dst_1]      \n\t"                 \
810  ".endif                                                  \n\t"                 \
811    "shll_s.ph       %[temp2],   %[temp2],   7             \n\t"                 \
812    "shll_s.ph       %[temp0],   %[temp0],   7             \n\t"                 \
813  ".if " #SIZE " == 8                                      \n\t"                 \
814    "shll_s.ph       %[temp3],   %[temp3],   7             \n\t"                 \
815    "shll_s.ph       %[temp1],   %[temp1],   7             \n\t"                 \
816  ".endif                                                  \n\t"                 \
817    "precrqu_s.qb.ph %[temp0],   %[temp2],   %[temp0]      \n\t"                 \
818  ".if " #SIZE " == 8                                      \n\t"                 \
819    "precrqu_s.qb.ph %[temp1],   %[temp3],   %[temp1]      \n\t"                 \
820  ".endif                                                  \n\t"
821  #define CLIP_8B_TO_DST(DST, TOP, SIZE) do {                                    \
822    int dst_1 = ((int)(DST)[-1] << 16) + (DST)[-1];                              \
823    int temp0, temp1, temp2, temp3;                                              \
824    __asm__ volatile (                                                           \
825    ".if " #SIZE " < 8                                     \n\t"                 \
826      "ulw             %[temp0],   0(%[top])               \n\t"                 \
827      "subu.ph         %[dst_1],   %[dst_1],    %[top_1]   \n\t"                 \
828      CLIPPING(4)                                                                \
829      "usw             %[temp0],   0(%[dst])               \n\t"                 \
830    ".else                                                 \n\t"                 \
831      "ulw             %[temp0],   0(%[top])               \n\t"                 \
832      "ulw             %[temp1],   4(%[top])               \n\t"                 \
833      "subu.ph         %[dst_1],   %[dst_1],    %[top_1]   \n\t"                 \
834      CLIPPING(8)                                                                \
835      "usw             %[temp0],   0(%[dst])               \n\t"                 \
836      "usw             %[temp1],   4(%[dst])               \n\t"                 \
837    ".if " #SIZE " == 16                                   \n\t"                 \
838      "ulw             %[temp0],   8(%[top])               \n\t"                 \
839      "ulw             %[temp1],   12(%[top])              \n\t"                 \
840      CLIPPING(8)                                                                \
841      "usw             %[temp0],   8(%[dst])               \n\t"                 \
842      "usw             %[temp1],   12(%[dst])              \n\t"                 \
843    ".endif                                                \n\t"                 \
844    ".endif                                                \n\t"                 \
845      : [dst_1]"+&r"(dst_1), [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),           \
846        [temp2]"=&r"(temp2), [temp3]"=&r"(temp3)                                 \
847      : [top_1]"r"(top_1), [top]"r"((TOP)), [dst]"r"((DST))                      \
848      : "memory"                                                                 \
849    );                                                                           \
850  } while (0)
851  #define CLIP_TO_DST(DST, SIZE) do {                                            \
852    int y;                                                                       \
853    const uint8_t* top = (DST) - BPS;                                            \
854    const int top_1 = ((int)top[-1] << 16) + top[-1];                            \
855    for (y = 0; y < (SIZE); ++y) {                                               \
856      CLIP_8B_TO_DST((DST), top, (SIZE));                                        \
857      (DST) += BPS;                                                              \
858    }                                                                            \
859  } while (0)
860  #define TRUE_MOTION(DST, SIZE)                                                 \
861  static void TrueMotion##SIZE(uint8_t* (DST)) {                                 \
862    CLIP_TO_DST((DST), (SIZE));                                                  \
863  }
864  TRUE_MOTION(dst, 4)
865  TRUE_MOTION(dst, 8)
866  TRUE_MOTION(dst, 16)
867  #undef TRUE_MOTION
868  #undef CLIP_TO_DST
869  #undef CLIP_8B_TO_DST
870  #undef CLIPPING
871  extern void VP8DspInitMIPSdspR2(void);
<span onclick='openModal()' class='match'>872  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitMIPSdspR2(void) {
873    VP8TransformDC = TransformDC;
874    VP8TransformAC3 = TransformAC3;
875    VP8Transform = TransformTwo;
876    VP8VFilter16 = VFilter16;
877    VP8HFilter16 = HFilter16;
878    VP8VFilter8 = VFilter8;
879    VP8HFilter8 = HFilter8;
880    VP8VFilter16i = VFilter16i;
881    VP8HFilter16i = HFilter16i;
882    VP8VFilter8i = VFilter8i;
883    VP8HFilter8i = HFilter8i;
884    VP8SimpleVFilter16 = SimpleVFilter16;
885    VP8SimpleHFilter16 = SimpleHFilter16;
886    VP8SimpleVFilter16i = SimpleVFilter16i;
887    VP8SimpleHFilter16i = SimpleHFilter16i;
888    VP8PredLuma4[0] = DC4;
889    VP8PredLuma4[1] = TrueMotion4;
890    VP8PredLuma4[2] = VE4;
891    VP8PredLuma4[4] = RD4;
892    VP8PredLuma4[6] = LD4;
893    VP8PredChroma8[0] = DC8uv;
894    VP8PredChroma8[1] = TrueMotion8;
895    VP8PredChroma8[4] = DC8uvNoTop;
896    VP8PredChroma8[5] = DC8uvNoLeft;
897    VP8PredLuma16[1] = TrueMotion16;
</span>898  }
899  #else  
900  WEBP_DSP_INIT_STUB(VP8DspInitMIPSdspR2)
901  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-subdir.c</h3>
            <pre><code>1  #include <fuse_config.h>
2  #include <fuse.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <stddef.h>
6  #include <string.h>
7  #include <errno.h>
8  struct subdir {
9  	char *base;
10  	size_t baselen;
11  	int rellinks;
12  	struct fuse_fs *next;
13  };
14  static struct subdir *subdir_get(void)
15  {
16  	return fuse_get_context()->private_data;
17  }
18  static int subdir_addpath(struct subdir *d, const char *path, char **newpathp)
19  {
20  	char *newpath = NULL;
21  	if (path != NULL) {
22  		unsigned newlen = d->baselen + strlen(path);
23  		newpath = malloc(newlen + 2);
24  		if (!newpath)
25  			return -ENOMEM;
26  		if (path[0] == '/')
27  			path++;
28  		strcpy(newpath, d->base);
29  		strcpy(newpath + d->baselen, path);
30  		if (!newpath[0])
31  			strcpy(newpath, ".");
32  	}
33  	*newpathp = newpath;
34  	return 0;
35  }
36  static int subdir_getattr(const char *path, struct stat *stbuf,
37  			  struct fuse_file_info *fi)
38  {
39  	struct subdir *d = subdir_get();
40  	char *newpath;
41  	int err = subdir_addpath(d, path, &newpath);
42  	if (!err) {
43  		err = fuse_fs_getattr(d->next, newpath, stbuf, fi);
44  		free(newpath);
45  	}
46  	return err;
47  }
48  static int subdir_access(const char *path, int mask)
49  {
50  	struct subdir *d = subdir_get();
51  	char *newpath;
52  	int err = subdir_addpath(d, path, &newpath);
53  	if (!err) {
54  		err = fuse_fs_access(d->next, newpath, mask);
55  		free(newpath);
56  	}
57  	return err;
58  }
59  static int count_components(const char *p)
60  {
61  	int ctr;
62  	for (; *p == '/'; p++);
63  	for (ctr = 0; *p; ctr++) {
64  		for (; *p && *p != '/'; p++);
65  		for (; *p == '/'; p++);
66  	}
67  	return ctr;
68  }
69  static void strip_common(const char **sp, const char **tp)
70  {
71  	const char *s = *sp;
72  	const char *t = *tp;
73  	do {
74  		for (; *s == '/'; s++);
75  		for (; *t == '/'; t++);
76  		*tp = t;
77  		*sp = s;
78  		for (; *s == *t && *s && *s != '/'; s++, t++);
79  	} while ((*s == *t && *s) || (!*s && *t == '/') || (*s == '/' && !*t));
80  }
81  static void transform_symlink(struct subdir *d, const char *path,
82  			      char *buf, size_t size)
83  {
84  	const char *l = buf;
85  	size_t llen;
86  	char *s;
87  	int dotdots;
88  	int i;
89  	if (l[0] != '/' || d->base[0] != '/')
90  		return;
91  	strip_common(&l, &path);
92  	if (l - buf < (long) d->baselen)
93  		return;
94  	dotdots = count_components(path);
95  	if (!dotdots)
96  		return;
97  	dotdots--;
98  	llen = strlen(l);
99  	if (dotdots * 3 + llen + 2 > size)
100  		return;
101  	s = buf + dotdots * 3;
102  	if (llen)
103  		memmove(s, l, llen + 1);
104  	else if (!dotdots)
105  		strcpy(s, ".");
106  	else
107  		*s = '\0';
108  	for (s = buf, i = 0; i < dotdots; i++, s += 3)
109  		memcpy(s, "../", 3);
110  }
111  static int subdir_readlink(const char *path, char *buf, size_t size)
112  {
113  	struct subdir *d = subdir_get();
114  	char *newpath;
115  	int err = subdir_addpath(d, path, &newpath);
116  	if (!err) {
117  		err = fuse_fs_readlink(d->next, newpath, buf, size);
118  		if (!err && d->rellinks)
119  			transform_symlink(d, newpath, buf, size);
120  		free(newpath);
121  	}
122  	return err;
123  }
124  static int subdir_opendir(const char *path, struct fuse_file_info *fi)
125  {
126  	struct subdir *d = subdir_get();
127  	char *newpath;
128  	int err = subdir_addpath(d, path, &newpath);
129  	if (!err) {
130  		err = fuse_fs_opendir(d->next, newpath, fi);
131  		free(newpath);
132  	}
133  	return err;
134  }
135  static int subdir_readdir(const char *path, void *buf,
136  			  fuse_fill_dir_t filler, off_t offset,
137  			  struct fuse_file_info *fi,
138  			  enum fuse_readdir_flags flags)
139  {
140  	struct subdir *d = subdir_get();
141  	char *newpath;
142  	int err = subdir_addpath(d, path, &newpath);
143  	if (!err) {
144  		err = fuse_fs_readdir(d->next, newpath, buf, filler, offset,
145  				      fi, flags);
146  		free(newpath);
147  	}
148  	return err;
149  }
150  static int subdir_releasedir(const char *path, struct fuse_file_info *fi)
151  {
152  	struct subdir *d = subdir_get();
153  	char *newpath;
154  	int err = subdir_addpath(d, path, &newpath);
155  	if (!err) {
156  		err = fuse_fs_releasedir(d->next, newpath, fi);
157  		free(newpath);
158  	}
159  	return err;
160  }
161  static int subdir_mknod(const char *path, mode_t mode, dev_t rdev)
162  {
163  	struct subdir *d = subdir_get();
164  	char *newpath;
165  	int err = subdir_addpath(d, path, &newpath);
166  	if (!err) {
167  		err = fuse_fs_mknod(d->next, newpath, mode, rdev);
168  		free(newpath);
169  	}
170  	return err;
171  }
172  static int subdir_mkdir(const char *path, mode_t mode)
173  {
174  	struct subdir *d = subdir_get();
175  	char *newpath;
176  	int err = subdir_addpath(d, path, &newpath);
177  	if (!err) {
178  		err = fuse_fs_mkdir(d->next, newpath, mode);
179  		free(newpath);
180  	}
181  	return err;
182  }
183  static int subdir_unlink(const char *path)
184  {
185  	struct subdir *d = subdir_get();
186  	char *newpath;
187  	int err = subdir_addpath(d, path, &newpath);
188  	if (!err) {
189  		err = fuse_fs_unlink(d->next, newpath);
190  		free(newpath);
191  	}
192  	return err;
193  }
194  static int subdir_rmdir(const char *path)
195  {
196  	struct subdir *d = subdir_get();
197  	char *newpath;
198  	int err = subdir_addpath(d, path, &newpath);
199  	if (!err) {
200  		err = fuse_fs_rmdir(d->next, newpath);
201  		free(newpath);
202  	}
203  	return err;
204  }
205  static int subdir_symlink(const char *from, const char *path)
206  {
207  	struct subdir *d = subdir_get();
208  	char *newpath;
209  	int err = subdir_addpath(d, path, &newpath);
210  	if (!err) {
211  		err = fuse_fs_symlink(d->next, from, newpath);
212  		free(newpath);
213  	}
214  	return err;
215  }
216  static int subdir_rename(const char *from, const char *to, unsigned int flags)
217  {
218  	struct subdir *d = subdir_get();
219  	char *newfrom;
220  	char *newto;
221  	int err = subdir_addpath(d, from, &newfrom);
222  	if (!err) {
223  		err = subdir_addpath(d, to, &newto);
224  		if (!err) {
225  			err = fuse_fs_rename(d->next, newfrom, newto, flags);
226  			free(newto);
227  		}
228  		free(newfrom);
229  	}
230  	return err;
231  }
232  static int subdir_link(const char *from, const char *to)
233  {
234  	struct subdir *d = subdir_get();
235  	char *newfrom;
236  	char *newto;
237  	int err = subdir_addpath(d, from, &newfrom);
238  	if (!err) {
239  		err = subdir_addpath(d, to, &newto);
240  		if (!err) {
241  			err = fuse_fs_link(d->next, newfrom, newto);
242  			free(newto);
243  		}
244  		free(newfrom);
245  	}
246  	return err;
247  }
248  static int subdir_chmod(const char *path, mode_t mode,
249  			struct fuse_file_info *fi)
250  {
251  	struct subdir *d = subdir_get();
252  	char *newpath;
253  	int err = subdir_addpath(d, path, &newpath);
254  	if (!err) {
255  		err = fuse_fs_chmod(d->next, newpath, mode, fi);
256  		free(newpath);
257  	}
258  	return err;
259  }
260  static int subdir_chown(const char *path, uid_t uid, gid_t gid,
261  			struct fuse_file_info *fi)
262  {
263  	struct subdir *d = subdir_get();
264  	char *newpath;
265  	int err = subdir_addpath(d, path, &newpath);
266  	if (!err) {
267  		err = fuse_fs_chown(d->next, newpath, uid, gid, fi);
268  		free(newpath);
269  	}
270  	return err;
271  }
272  static int subdir_truncate(const char *path, off_t size,
273  			   struct fuse_file_info *fi)
274  {
275  	struct subdir *d = subdir_get();
276  	char *newpath;
277  	int err = subdir_addpath(d, path, &newpath);
278  	if (!err) {
279  		err = fuse_fs_truncate(d->next, newpath, size, fi);
280  		free(newpath);
281  	}
282  	return err;
283  }
284  static int subdir_utimens(const char *path, const struct timespec ts[2],
285  			  struct fuse_file_info *fi)
286  {
287  	struct subdir *d = subdir_get();
288  	char *newpath;
289  	int err = subdir_addpath(d, path, &newpath);
290  	if (!err) {
291  		err = fuse_fs_utimens(d->next, newpath, ts, fi);
292  		free(newpath);
293  	}
294  	return err;
295  }
296  static int subdir_create(const char *path, mode_t mode,
297  			 struct fuse_file_info *fi)
298  {
299  	struct subdir *d = subdir_get();
300  	char *newpath;
301  	int err = subdir_addpath(d, path, &newpath);
302  	if (!err) {
303  		err = fuse_fs_create(d->next, newpath, mode, fi);
304  		free(newpath);
305  	}
306  	return err;
307  }
308  static int subdir_open(const char *path, struct fuse_file_info *fi)
309  {
310  	struct subdir *d = subdir_get();
311  	char *newpath;
312  	int err = subdir_addpath(d, path, &newpath);
313  	if (!err) {
314  		err = fuse_fs_open(d->next, newpath, fi);
315  		free(newpath);
316  	}
317  	return err;
318  }
319  static int subdir_read_buf(const char *path, struct fuse_bufvec **bufp,
320  			   size_t size, off_t offset, struct fuse_file_info *fi)
321  {
322  	struct subdir *d = subdir_get();
323  	char *newpath;
324  	int err = subdir_addpath(d, path, &newpath);
325  	if (!err) {
326  		err = fuse_fs_read_buf(d->next, newpath, bufp, size, offset, fi);
327  		free(newpath);
328  	}
329  	return err;
330  }
331  static int subdir_write_buf(const char *path, struct fuse_bufvec *buf,
332  			off_t offset, struct fuse_file_info *fi)
333  {
334  	struct subdir *d = subdir_get();
335  	char *newpath;
336  	int err = subdir_addpath(d, path, &newpath);
337  	if (!err) {
338  		err = fuse_fs_write_buf(d->next, newpath, buf, offset, fi);
339  		free(newpath);
340  	}
341  	return err;
342  }
343  static int subdir_statfs(const char *path, struct statvfs *stbuf)
344  {
345  	struct subdir *d = subdir_get();
346  	char *newpath;
347  	int err = subdir_addpath(d, path, &newpath);
348  	if (!err) {
349  		err = fuse_fs_statfs(d->next, newpath, stbuf);
350  		free(newpath);
351  	}
352  	return err;
353  }
354  static int subdir_flush(const char *path, struct fuse_file_info *fi)
355  {
356  	struct subdir *d = subdir_get();
357  	char *newpath;
358  	int err = subdir_addpath(d, path, &newpath);
359  	if (!err) {
360  		err = fuse_fs_flush(d->next, newpath, fi);
361  		free(newpath);
362  	}
363  	return err;
364  }
365  static int subdir_release(const char *path, struct fuse_file_info *fi)
366  {
367  	struct subdir *d = subdir_get();
368  	char *newpath;
369  	int err = subdir_addpath(d, path, &newpath);
370  	if (!err) {
371  		err = fuse_fs_release(d->next, newpath, fi);
372  		free(newpath);
373  	}
374  	return err;
375  }
376  static int subdir_fsync(const char *path, int isdatasync,
377  			struct fuse_file_info *fi)
378  {
379  	struct subdir *d = subdir_get();
380  	char *newpath;
381  	int err = subdir_addpath(d, path, &newpath);
382  	if (!err) {
383  		err = fuse_fs_fsync(d->next, newpath, isdatasync, fi);
384  		free(newpath);
385  	}
386  	return err;
387  }
388  static int subdir_fsyncdir(const char *path, int isdatasync,
389  			   struct fuse_file_info *fi)
390  {
391  	struct subdir *d = subdir_get();
392  	char *newpath;
393  	int err = subdir_addpath(d, path, &newpath);
394  	if (!err) {
395  		err = fuse_fs_fsyncdir(d->next, newpath, isdatasync, fi);
396  		free(newpath);
397  	}
398  	return err;
399  }
400  static int subdir_setxattr(const char *path, const char *name,
401  			   const char *value, size_t size, int flags)
402  {
403  	struct subdir *d = subdir_get();
404  	char *newpath;
405  	int err = subdir_addpath(d, path, &newpath);
406  	if (!err) {
407  		err = fuse_fs_setxattr(d->next, newpath, name, value, size,
408  				       flags);
409  		free(newpath);
410  	}
411  	return err;
412  }
413  static int subdir_getxattr(const char *path, const char *name, char *value,
414  			   size_t size)
415  {
416  	struct subdir *d = subdir_get();
417  	char *newpath;
418  	int err = subdir_addpath(d, path, &newpath);
419  	if (!err) {
420  		err = fuse_fs_getxattr(d->next, newpath, name, value, size);
421  		free(newpath);
422  	}
423  	return err;
424  }
425  static int subdir_listxattr(const char *path, char *list, size_t size)
426  {
427  	struct subdir *d = subdir_get();
428  	char *newpath;
429  	int err = subdir_addpath(d, path, &newpath);
430  	if (!err) {
431  		err = fuse_fs_listxattr(d->next, newpath, list, size);
432  		free(newpath);
433  	}
434  	return err;
435  }
436  static int subdir_removexattr(const char *path, const char *name)
437  {
438  	struct subdir *d = subdir_get();
439  	char *newpath;
440  	int err = subdir_addpath(d, path, &newpath);
441  	if (!err) {
442  		err = fuse_fs_removexattr(d->next, newpath, name);
443  		free(newpath);
444  	}
445  	return err;
446  }
447  static int subdir_lock(const char *path, struct fuse_file_info *fi, int cmd,
448  		       struct flock *lock)
449  {
450  	struct subdir *d = subdir_get();
451  	char *newpath;
452  	int err = subdir_addpath(d, path, &newpath);
453  	if (!err) {
454  		err = fuse_fs_lock(d->next, newpath, fi, cmd, lock);
455  		free(newpath);
456  	}
457  	return err;
458  }
459  static int subdir_flock(const char *path, struct fuse_file_info *fi, int op)
460  {
461  	struct subdir *d = subdir_get();
462  	char *newpath;
463  	int err = subdir_addpath(d, path, &newpath);
464  	if (!err) {
465  		err = fuse_fs_flock(d->next, newpath, fi, op);
466  		free(newpath);
467  	}
468  	return err;
469  }
470  static int subdir_bmap(const char *path, size_t blocksize, uint64_t *idx)
471  {
472  	struct subdir *d = subdir_get();
473  	char *newpath;
474  	int err = subdir_addpath(d, path, &newpath);
475  	if (!err) {
476  		err = fuse_fs_bmap(d->next, newpath, blocksize, idx);
477  		free(newpath);
478  	}
479  	return err;
480  }
481  static off_t subdir_lseek(const char *path, off_t off, int whence,
482  			  struct fuse_file_info *fi)
483  {
484  	struct subdir *ic = subdir_get();
485  	char *newpath;
486  	int res = subdir_addpath(ic, path, &newpath);
487  	if (!res) {
488  		res = fuse_fs_lseek(ic->next, newpath, off, whence, fi);
489  		free(newpath);
490  	}
491  	return res;
492  }
493  static void *subdir_init(struct fuse_conn_info *conn,
494  			 struct fuse_config *cfg)
495  {
496  	struct subdir *d = subdir_get();
497  	fuse_fs_init(d->next, conn, cfg);
498  	return d;
499  }
500  static void subdir_destroy(void *data)
501  {
502  	struct subdir *d = data;
503  	fuse_fs_destroy(d->next);
504  	free(d->base);
505  	free(d);
506  }
<span onclick='openModal()' class='match'>507  static const struct fuse_operations subdir_oper = {
508  	.destroy	= subdir_destroy,
509  	.init		= subdir_init,
510  	.getattr	= subdir_getattr,
511  	.access		= subdir_access,
512  	.readlink	= subdir_readlink,
513  	.opendir	= subdir_opendir,
514  	.readdir	= subdir_readdir,
515  	.releasedir	= subdir_releasedir,
516  	.mknod		= subdir_mknod,
517  	.mkdir		= subdir_mkdir,
518  	.symlink	= subdir_symlink,
519  	.unlink		= subdir_unlink,
520  	.rmdir		= subdir_rmdir,
521  	.rename		= subdir_rename,
522  	.link		= subdir_link,
523  	.chmod		= subdir_chmod,
524  	.chown		= subdir_chown,
525  	.truncate	= subdir_truncate,
526  	.utimens	= subdir_utimens,
527  	.create		= subdir_create,
528  	.open		= subdir_open,
529  	.read_buf	= subdir_read_buf,
530  	.write_buf	= subdir_write_buf,
531  	.statfs		= subdir_statfs,
532  	.flush		= subdir_flush,
</span>533  	.release	= subdir_release,
534  	.fsync		= subdir_fsync,
535  	.fsyncdir	= subdir_fsyncdir,
536  	.setxattr	= subdir_setxattr,
537  	.getxattr	= subdir_getxattr,
538  	.listxattr	= subdir_listxattr,
539  	.removexattr	= subdir_removexattr,
540  	.lock		= subdir_lock,
541  	.flock		= subdir_flock,
542  	.bmap		= subdir_bmap,
543  	.lseek		= subdir_lseek,
544  };
545  static const struct fuse_opt subdir_opts[] = {
546  	FUSE_OPT_KEY("-h", 0),
547  	FUSE_OPT_KEY("--help", 0),
548  	{ "subdir=%s", offsetof(struct subdir, base), 0 },
549  	{ "rellinks", offsetof(struct subdir, rellinks), 1 },
550  	{ "norellinks", offsetof(struct subdir, rellinks), 0 },
551  	FUSE_OPT_END
552  };
553  static void subdir_help(void)
554  {
555  	printf(
556  "    -o subdir=DIR	    prepend this directory to all paths (mandatory)\n"
557  "    -o [no]rellinks	    transform absolute symlinks to relative\n");
558  }
559  static int subdir_opt_proc(void *data, const char *arg, int key,
560  			   struct fuse_args *outargs)
561  {
562  	(void) data; (void) arg; (void) outargs;
563  	if (!key) {
564  		subdir_help();
565  		return -1;
566  	}
567  	return 1;
568  }
569  static struct fuse_fs *subdir_new(struct fuse_args *args,
570  				  struct fuse_fs *next[])
571  {
572  	struct fuse_fs *fs;
573  	struct subdir *d;
574  	d = calloc(1, sizeof(struct subdir));
575  	if (d == NULL) {
576  		fuse_log(FUSE_LOG_ERR, "fuse-subdir: memory allocation failed\n");
577  		return NULL;
578  	}
579  	if (fuse_opt_parse(args, d, subdir_opts, subdir_opt_proc) == -1)
580  		goto out_free;
581  	if (!next[0] || next[1]) {
582  		fuse_log(FUSE_LOG_ERR, "fuse-subdir: exactly one next filesystem required\n");
583  		goto out_free;
584  	}
585  	if (!d->base) {
586  		fuse_log(FUSE_LOG_ERR, "fuse-subdir: missing 'subdir' option\n");
587  		goto out_free;
588  	}
589  	if (d->base[0] && d->base[strlen(d->base)-1] != '/') {
590  		char *tmp = realloc(d->base, strlen(d->base) + 2);
591  		if (!tmp) {
592  			fuse_log(FUSE_LOG_ERR, "fuse-subdir: memory allocation failed\n");
593  			goto out_free;
594  		}
595  		d->base = tmp;
596  		strcat(d->base, "/");
597  	}
598  	d->baselen = strlen(d->base);
599  	d->next = next[0];
600  	fs = fuse_fs_new(&subdir_oper, sizeof(subdir_oper), d);
601  	if (!fs)
602  		goto out_free;
603  	return fs;
604  out_free:
605  	free(d->base);
606  	free(d);
607  	return NULL;
608  }
609  FUSE_REGISTER_MODULE(subdir, subdir_new);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_mips_dsp_r2.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-subdir.c</div>
                <div class="column column_space"><pre><code>872  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitMIPSdspR2(void) {
873    VP8TransformDC = TransformDC;
874    VP8TransformAC3 = TransformAC3;
875    VP8Transform = TransformTwo;
876    VP8VFilter16 = VFilter16;
877    VP8HFilter16 = HFilter16;
878    VP8VFilter8 = VFilter8;
879    VP8HFilter8 = HFilter8;
880    VP8VFilter16i = VFilter16i;
881    VP8HFilter16i = HFilter16i;
882    VP8VFilter8i = VFilter8i;
883    VP8HFilter8i = HFilter8i;
884    VP8SimpleVFilter16 = SimpleVFilter16;
885    VP8SimpleHFilter16 = SimpleHFilter16;
886    VP8SimpleVFilter16i = SimpleVFilter16i;
887    VP8SimpleHFilter16i = SimpleHFilter16i;
888    VP8PredLuma4[0] = DC4;
889    VP8PredLuma4[1] = TrueMotion4;
890    VP8PredLuma4[2] = VE4;
891    VP8PredLuma4[4] = RD4;
892    VP8PredLuma4[6] = LD4;
893    VP8PredChroma8[0] = DC8uv;
894    VP8PredChroma8[1] = TrueMotion8;
895    VP8PredChroma8[4] = DC8uvNoTop;
896    VP8PredChroma8[5] = DC8uvNoLeft;
897    VP8PredLuma16[1] = TrueMotion16;
</pre></code></div>
                <div class="column column_space"><pre><code>507  static const struct fuse_operations subdir_oper = {
508  	.destroy	= subdir_destroy,
509  	.init		= subdir_init,
510  	.getattr	= subdir_getattr,
511  	.access		= subdir_access,
512  	.readlink	= subdir_readlink,
513  	.opendir	= subdir_opendir,
514  	.readdir	= subdir_readdir,
515  	.releasedir	= subdir_releasedir,
516  	.mknod		= subdir_mknod,
517  	.mkdir		= subdir_mkdir,
518  	.symlink	= subdir_symlink,
519  	.unlink		= subdir_unlink,
520  	.rmdir		= subdir_rmdir,
521  	.rename		= subdir_rename,
522  	.link		= subdir_link,
523  	.chmod		= subdir_chmod,
524  	.chown		= subdir_chown,
525  	.truncate	= subdir_truncate,
526  	.utimens	= subdir_utimens,
527  	.create		= subdir_create,
528  	.open		= subdir_open,
529  	.read_buf	= subdir_read_buf,
530  	.write_buf	= subdir_write_buf,
531  	.statfs		= subdir_statfs,
532  	.flush		= subdir_flush,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    