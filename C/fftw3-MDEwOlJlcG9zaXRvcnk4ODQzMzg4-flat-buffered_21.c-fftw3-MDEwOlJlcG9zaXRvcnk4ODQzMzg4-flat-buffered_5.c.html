
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 34, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered_21.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4       size_t maxnbuf_ndx;
5  } S;
6  static const INT maxnbufs[] = { 8, 256 };
7  typedef struct {
8       plan_rdft super;
9       plan *cld, *cldcpy, *cldrest;
10       INT n, vl, nbuf, bufdist;
11       INT ivs_by_nbuf, ovs_by_nbuf;
12  } P;
13  static void apply(const plan *ego_, R *I, R *O)
14  {
15       const P *ego = (const P *) ego_;
16       plan_rdft *cld = (plan_rdft *) ego->cld;
17       plan_rdft *cldcpy = (plan_rdft *) ego->cldcpy;
18       plan_rdft *cldrest;
19       INT i, vl = ego->vl, nbuf = ego->nbuf;
20       INT ivs_by_nbuf = ego->ivs_by_nbuf, ovs_by_nbuf = ego->ovs_by_nbuf;
21       R *bufs;
22       bufs = (R *)MALLOC(sizeof(R) * nbuf * ego->bufdist, BUFFERS);
23       for (i = nbuf; i <= vl; i += nbuf) {
24            cld->apply((plan *) cld, I, bufs);
25  	  I += ivs_by_nbuf;
26            cldcpy->apply((plan *) cldcpy, bufs, O);
27  	  O += ovs_by_nbuf;
28       }
29       X(ifree)(bufs);
30       cldrest = (plan_rdft *) ego->cldrest;
31       cldrest->apply((plan *) cldrest, I, O);
32  }
33  static void apply_hc2r(const plan *ego_, R *I, R *O)
34  {
35       const P *ego = (const P *) ego_;
36       plan_rdft *cld = (plan_rdft *) ego->cld;
37       plan_rdft *cldcpy = (plan_rdft *) ego->cldcpy;
38       plan_rdft *cldrest;
39       INT i, vl = ego->vl, nbuf = ego->nbuf;
40       INT ivs_by_nbuf = ego->ivs_by_nbuf, ovs_by_nbuf = ego->ovs_by_nbuf;
41       R *bufs;
42       bufs = (R *)MALLOC(sizeof(R) * nbuf * ego->bufdist, BUFFERS);
43       for (i = nbuf; i <= vl; i += nbuf) {
44            cldcpy->apply((plan *) cldcpy, I, bufs);
45  	  I += ivs_by_nbuf;
46            cld->apply((plan *) cld, bufs, O);
47  	  O += ovs_by_nbuf;
48       }
49       X(ifree)(bufs);
50       cldrest = (plan_rdft *) ego->cldrest;
51       cldrest->apply((plan *) cldrest, I, O);
52  }
53  static void awake(plan *ego_, enum wakefulness wakefulness)
54  {
55       P *ego = (P *) ego_;
56       X(plan_awake)(ego->cld, wakefulness);
57       X(plan_awake)(ego->cldcpy, wakefulness);
58       X(plan_awake)(ego->cldrest, wakefulness);
59  }
60  static void destroy(plan *ego_)
61  {
62       P *ego = (P *) ego_;
63       X(plan_destroy_internal)(ego->cldrest);
64       X(plan_destroy_internal)(ego->cldcpy);
65       X(plan_destroy_internal)(ego->cld);
66  }
67  static void print(const plan *ego_, printer *p)
68  {
69       const P *ego = (const P *) ego_;
70       p->print(p, "(rdft-buffered-%D%v/%D-%D%(%p%)%(%p%)%(%p%))",
71                ego->n, ego->nbuf,
72                ego->vl, ego->bufdist % ego->n,
73                ego->cld, ego->cldcpy, ego->cldrest);
74  }
75  static int applicable0(const S *ego, const problem *p_, const planner *plnr)
76  {
77       const problem_rdft *p = (const problem_rdft *) p_;
78       iodim *d = p->sz->dims;
79       if (1
80  	 && p->vecsz->rnk <= 1
81  	 && p->sz->rnk == 1
82  	  ) {
83  	  INT vl, ivs, ovs;
84  	  X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
85  	  if (X(toobig)(d[0].n) && CONSERVE_MEMORYP(plnr))
86  	       return 0;
87  	  if (X(nbuf_redundant)(d[0].n, vl,
88  				ego->maxnbuf_ndx,
89  				maxnbufs, NELEM(maxnbufs)))
90  	       return 0;
91  	  if (p->I != p->O) {
92  	       if (p->kind[0] == HC2R) {
93  		    return (NO_DESTROY_INPUTP(plnr));
94  	       } else {
95  		    return (d[0].os > 1);
96  	       }
97  	  }
98  	  if (X(tensor_inplace_strides2)(p->sz, p->vecsz))
99  	       return 1;
100  	  if (&bsol;* fits into buffer: */
101  	       ((p->vecsz->rnk == 0)
102  		||
103  		(X(nbuf)(d[0].n, p->vecsz->dims[0].n, 
104  			 maxnbufs[ego->maxnbuf_ndx]) 
105  		 == p->vecsz->dims[0].n)))
106  	       return 1;
107       }
108       return 0;
109  }
110  static int applicable(const S *ego, const problem *p_, const planner *plnr)
111  {
112       const problem_rdft *p;
113       if (NO_BUFFERINGP(plnr)) return 0;
114       if (!applicable0(ego, p_, plnr)) return 0;
115       p = (const problem_rdft *) p_;
116       if (p->kind[0] == HC2R) {
117  	  if (NO_UGLYP(plnr)) {
118  	       if (p->I == p->O && X(toobig)(p->sz->dims[0].n)) 
119  		    return 0;
120  	  }
121       } else {
122  	  if (NO_UGLYP(plnr)) {
123  	       if (p->I != p->O) return 0;
124  	       if (X(toobig)(p->sz->dims[0].n)) return 0;
125  	  }
126       }
127       return 1;
128  }
129  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
130  {
131       P *pln;
132       const S *ego = (const S *)ego_;
133       plan *cld = (plan *) 0;
134       plan *cldcpy = (plan *) 0;
135       plan *cldrest = (plan *) 0;
136       const problem_rdft *p = (const problem_rdft *) p_;
137       R *bufs = (R *) 0;
138       INT nbuf = 0, bufdist, n, vl;
139       INT ivs, ovs;
140       int hc2rp;
141       static const plan_adt padt = {
142  	  X(rdft_solve), awake, print, destroy
143       };
144       if (!applicable(ego, p_, plnr))
145            goto nada;
146       n = X(tensor_sz)(p->sz);
147       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
148       hc2rp = (p->kind[0] == HC2R);
149       nbuf = X(nbuf)(n, vl, maxnbufs[ego->maxnbuf_ndx]);
150       bufdist = X(bufdist)(n, vl);
151       A(nbuf > 0);
152       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
153       if (hc2rp) {
154  	  cld = X(mkplan_f_d)(plnr, 
155  			      X(mkproblem_rdft_d)(
156  				   X(mktensor_1d)(n, 1, p->sz->dims[0].os),
157  				   X(mktensor_1d)(nbuf, bufdist, ovs),
158  				   bufs, TAINT(p->O, ovs * nbuf), p->kind),
159  			      0, 0, NO_DESTROY_INPUT);
160  	  if (!cld) goto nada;
161  	  cldcpy = X(mkplan_d)(plnr, 
162  			       X(mkproblem_rdft_0_d)(
163  				    X(mktensor_2d)(nbuf, ivs, bufdist,
164  						   n, p->sz->dims[0].is, 1),
165  				    TAINT(p->I, ivs * nbuf), bufs));
166  	  if (!cldcpy) goto nada;
167       } else {
168  	  cld = X(mkplan_f_d)(plnr, 
169  			      X(mkproblem_rdft_d)(
170  				   X(mktensor_1d)(n, p->sz->dims[0].is, 1),
171  				   X(mktensor_1d)(nbuf, ivs, bufdist),
172  				   TAINT(p->I, ivs * nbuf), bufs, p->kind),
173  			      0, 0, (p->I == p->O) ? NO_DESTROY_INPUT : 0);
174  	  if (!cld) goto nada;
175  	  cldcpy = X(mkplan_d)(plnr, 
176  			       X(mkproblem_rdft_0_d)(
177  				    X(mktensor_2d)(nbuf, bufdist, ovs,
178  						   n, 1, p->sz->dims[0].os),
179  				    bufs, TAINT(p->O, ovs * nbuf)));
180  	  if (!cldcpy) goto nada;
181       }
182       X(ifree)(bufs);
183       bufs = 0;
184       {
185  	  INT id = ivs * (nbuf * (vl / nbuf));
186  	  INT od = ovs * (nbuf * (vl / nbuf));
187  	  cldrest = X(mkplan_d)(plnr, 
188  				X(mkproblem_rdft_d)(
189  				     X(tensor_copy)(p->sz),
190  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
191  				     p->I + id, p->O + od, p->kind));
192       }
193       if (!cldrest) goto nada;
194       pln = MKPLAN_RDFT(P, &padt, hc2rp ? apply_hc2r : apply);
195       pln->cld = cld;
196       pln->cldcpy = cldcpy;
197       pln->cldrest = cldrest;
198       pln->n = n;
<span onclick='openModal()' class='match'>199       pln->vl = vl;
200       pln->ivs_by_nbuf = ivs * nbuf;
201       pln->ovs_by_nbuf = ovs * nbuf;
202       pln->nbuf = nbuf;
203       pln->bufdist = bufdist;
204       {
</span>205  	  opcnt t;
206  	  X(ops_add)(&cld->ops, &cldcpy->ops, &t);
207  	  X(ops_madd)(vl / nbuf, &t, &cldrest->ops, &pln->super.super.ops);
208       }
209       return &(pln->super.super);
210   nada:
211       X(ifree0)(bufs);
212       X(plan_destroy_internal)(cldrest);
213       X(plan_destroy_internal)(cldcpy);
214       X(plan_destroy_internal)(cld);
215       return (plan *) 0;
216  }
217  static solver *mksolver(size_t maxnbuf_ndx)
218  {
219       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
220       S *slv = MKSOLVER(S, &sadt);
221       slv->maxnbuf_ndx = maxnbuf_ndx;
222       return &(slv->super);
223  }
224  void X(rdft_buffered_register)(planner *p)
225  {
226       size_t i;
227       for (i = 0; i < NELEM(maxnbufs); ++i)
228  	  REGISTER_SOLVER(p, mksolver(i));
229  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered_5.c</h3>
            <pre><code>1  #include "dft/dft.h"
2  typedef struct {
3       solver super;
4       size_t maxnbuf_ndx;
5  } S;
6  static const INT maxnbufs[] = { 8, 256 };
7  typedef struct {
8       plan_dft super;
9       plan *cld, *cldcpy, *cldrest;
10       INT n, vl, nbuf, bufdist;
11       INT ivs_by_nbuf, ovs_by_nbuf;
12       INT roffset, ioffset;
13  } P;
14  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
15  {
16       const P *ego = (const P *) ego_;
17       INT nbuf = ego->nbuf;
18       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * ego->bufdist * 2, BUFFERS);
19       plan_dft *cld = (plan_dft *) ego->cld;
20       plan_dft *cldcpy = (plan_dft *) ego->cldcpy;
21       plan_dft *cldrest;
22       INT i, vl = ego->vl;
23       INT ivs_by_nbuf = ego->ivs_by_nbuf, ovs_by_nbuf = ego->ovs_by_nbuf;
24       INT roffset = ego->roffset, ioffset = ego->ioffset;
25       for (i = nbuf; i <= vl; i += nbuf) {
26            cld->apply((plan *) cld, ri, ii, bufs + roffset, bufs + ioffset);
27  	  ri += ivs_by_nbuf; ii += ivs_by_nbuf;
28            cldcpy->apply((plan *) cldcpy, bufs+roffset, bufs+ioffset, ro, io);
29  	  ro += ovs_by_nbuf; io += ovs_by_nbuf;
30       }
31       X(ifree)(bufs);
32       cldrest = (plan_dft *) ego->cldrest;
33       cldrest->apply((plan *) cldrest, ri, ii, ro, io);
34  }
35  static void awake(plan *ego_, enum wakefulness wakefulness)
36  {
37       P *ego = (P *) ego_;
38       X(plan_awake)(ego->cld, wakefulness);
39       X(plan_awake)(ego->cldcpy, wakefulness);
40       X(plan_awake)(ego->cldrest, wakefulness);
41  }
42  static void destroy(plan *ego_)
43  {
44       P *ego = (P *) ego_;
45       X(plan_destroy_internal)(ego->cldrest);
46       X(plan_destroy_internal)(ego->cldcpy);
47       X(plan_destroy_internal)(ego->cld);
48  }
49  static void print(const plan *ego_, printer *p)
50  {
51       const P *ego = (const P *) ego_;
52       p->print(p, "(dft-buffered-%D%v/%D-%D%(%p%)%(%p%)%(%p%))",
53                ego->n, ego->nbuf,
54                ego->vl, ego->bufdist % ego->n,
55                ego->cld, ego->cldcpy, ego->cldrest);
56  }
57  static int applicable0(const S *ego, const problem *p_, const planner *plnr)
58  {
59       const problem_dft *p = (const problem_dft *) p_;
60       const iodim *d = p->sz->dims;
61       if (1
62  	 && p->vecsz->rnk <= 1
63  	 && p->sz->rnk == 1
64  	  ) {
65  	  INT vl, ivs, ovs;
66  	  X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
67  	  if (X(toobig)(p->sz->dims[0].n) && CONSERVE_MEMORYP(plnr))
68  	       return 0;
69  	  if (X(nbuf_redundant)(d[0].n, vl, 
70  				ego->maxnbuf_ndx,
71  				maxnbufs, NELEM(maxnbufs)))
72  	       return 0;
73  	  if (p->ri != p->ro)
74  	       return (d[0].os > 2);
75  	  if (X(tensor_inplace_strides2)(p->sz, p->vecsz))
76  	       return 1;
77  	  if (&bsol;* fits into buffer: */
78  	       ((p->vecsz->rnk == 0)
79  		||
80  		(X(nbuf)(d[0].n, p->vecsz->dims[0].n, 
81  			 maxnbufs[ego->maxnbuf_ndx]) 
82  		 == p->vecsz->dims[0].n)))
83  	       return 1;
84       }
85       return 0;
86  }
87  static int applicable(const S *ego, const problem *p_, const planner *plnr)
88  {
89       if (NO_BUFFERINGP(plnr)) return 0;
90       if (!applicable0(ego, p_, plnr)) return 0;
91       if (NO_UGLYP(plnr)) {
92  	  const problem_dft *p = (const problem_dft *) p_;
93  	  if (p->ri != p->ro) return 0;
94  	  if (X(toobig)(p->sz->dims[0].n)) return 0;
95       }
96       return 1;
97  }
98  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
99  {
100       P *pln;
101       const S *ego = (const S *)ego_;
102       plan *cld = (plan *) 0;
103       plan *cldcpy = (plan *) 0;
104       plan *cldrest = (plan *) 0;
105       const problem_dft *p = (const problem_dft *) p_;
106       R *bufs = (R *) 0;
107       INT nbuf = 0, bufdist, n, vl;
108       INT ivs, ovs, roffset, ioffset;
109       static const plan_adt padt = {
110  	  X(dft_solve), awake, print, destroy
111       };
112       if (!applicable(ego, p_, plnr))
113            goto nada;
114       n = X(tensor_sz)(p->sz);
115       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
116       nbuf = X(nbuf)(n, vl, maxnbufs[ego->maxnbuf_ndx]);
117       bufdist = X(bufdist)(n, vl);
118       A(nbuf > 0);
119       roffset = (p->ri - p->ii > 0) ? (INT)1 : (INT)0;
120       ioffset = 1 - roffset;
121       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist * 2, BUFFERS);
122       cld = X(mkplan_f_d)(plnr,
123  			 X(mkproblem_dft_d)(
124  			      X(mktensor_1d)(n, p->sz->dims[0].is, 2),
125  			      X(mktensor_1d)(nbuf, ivs, bufdist * 2),
126  			      TAINT(p->ri, ivs * nbuf),
127  			      TAINT(p->ii, ivs * nbuf),
128  			      bufs + roffset, 
129  			      bufs + ioffset),
130  			 0, 0, (p->ri == p->ro) ? NO_DESTROY_INPUT : 0);
131       if (!cld)
132            goto nada;
133       cldcpy = X(mkplan_d)(plnr,
134  			  X(mkproblem_dft_d)(
135  			       X(mktensor_0d)(),
136  			       X(mktensor_2d)(nbuf, bufdist * 2, ovs,
137  					      n, 2, p->sz->dims[0].os),
138  			       bufs + roffset, 
139  			       bufs + ioffset, 
140  			       TAINT(p->ro, ovs * nbuf), 
141  			       TAINT(p->io, ovs * nbuf)));
142       if (!cldcpy)
143            goto nada;
144       X(ifree)(bufs);
145       bufs = 0;
146       {
147  	  INT id = ivs * (nbuf * (vl / nbuf));
148  	  INT od = ovs * (nbuf * (vl / nbuf));
149  	  cldrest = X(mkplan_d)(plnr, 
150  				X(mkproblem_dft_d)(
151  				     X(tensor_copy)(p->sz),
152  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
153  				     p->ri+id, p->ii+id, p->ro+od, p->io+od));
154       }
155       if (!cldrest)
156            goto nada;
157       pln = MKPLAN_DFT(P, &padt, apply);
158       pln->cld = cld;
159       pln->cldcpy = cldcpy;
160       pln->cldrest = cldrest;
161       pln->n = n;
<span onclick='openModal()' class='match'>162       pln->vl = vl;
163       pln->ivs_by_nbuf = ivs * nbuf;
164       pln->ovs_by_nbuf = ovs * nbuf;
165       pln->roffset = roffset;
166       pln->ioffset = ioffset;
167       pln->nbuf = nbuf;
</span>168       pln->bufdist = bufdist;
169       {
170  	  opcnt t;
171  	  X(ops_add)(&cld->ops, &cldcpy->ops, &t);
172  	  X(ops_madd)(vl / nbuf, &t, &cldrest->ops, &pln->super.super.ops);
173       }
174       return &(pln->super.super);
175   nada:
176       X(ifree0)(bufs);
177       X(plan_destroy_internal)(cldrest);
178       X(plan_destroy_internal)(cldcpy);
179       X(plan_destroy_internal)(cld);
180       return (plan *) 0;
181  }
182  static solver *mksolver(size_t maxnbuf_ndx)
183  {
184       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
185       S *slv = MKSOLVER(S, &sadt);
186       slv->maxnbuf_ndx = maxnbuf_ndx;
187       return &(slv->super);
188  }
189  void X(dft_buffered_register)(planner *p)
190  {
191       size_t i;
192       for (i = 0; i < NELEM(maxnbufs); ++i)
193  	  REGISTER_SOLVER(p, mksolver(i));
194  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered_21.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered_5.c</div>
                </div>
                <div class="column column_space"><pre><code>199       pln->vl = vl;
200       pln->ivs_by_nbuf = ivs * nbuf;
201       pln->ovs_by_nbuf = ovs * nbuf;
202       pln->nbuf = nbuf;
203       pln->bufdist = bufdist;
204       {
</pre></code></div>
                <div class="column column_space"><pre><code>162       pln->vl = vl;
163       pln->ivs_by_nbuf = ivs * nbuf;
164       pln->ovs_by_nbuf = ovs * nbuf;
165       pln->roffset = roffset;
166       pln->ioffset = ioffset;
167       pln->nbuf = nbuf;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    