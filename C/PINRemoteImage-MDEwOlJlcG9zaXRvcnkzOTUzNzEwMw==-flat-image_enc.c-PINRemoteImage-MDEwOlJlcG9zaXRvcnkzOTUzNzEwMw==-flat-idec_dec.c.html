
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.189910979228486%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-image_enc.c</h3>
            <pre><code>1  #include "./image_enc.h"
2  #include <assert.h>
3  #include <string.h>
4  #ifdef WEBP_HAVE_PNG
5  #include <png.h>
6  #include <setjmp.h>   
7  #endif
8  #ifdef HAVE_WINCODEC_H
9  #ifdef __MINGW32__
10  #define INITGUID  
11  #endif
12  #define CINTERFACE
13  #define COBJMACROS
14  #define _WIN32_IE 0x500  
15  #include <ole2.h>  
16  #include <shlwapi.h>
17  #include <tchar.h>
18  #include <windows.h>
19  #include <wincodec.h>
20  #endif
21  #include "./imageio_util.h"
22  #include "../examples/unicode.h"
23  #ifdef HAVE_WINCODEC_H
24  #define IFS(fn)                                                     \
25    do {                                                              \
26      if (SUCCEEDED(hr)) {                                            \
27        hr = (fn);                                                    \
28        if (FAILED(hr)) fprintf(stderr, #fn " failed %08lx\n", hr);   \
29      }                                                               \
30    } while (0)
31  #ifdef __cplusplus
32  #define MAKE_REFGUID(x) (x)
33  #else
34  #define MAKE_REFGUID(x) &(x)
35  #endif
36  static HRESULT CreateOutputStream(const char* out_file_name,
37                                    int write_to_mem, IStream** stream) {
38    HRESULT hr = S_OK;
39    if (write_to_mem) {
40      IFS(CreateStreamOnHGlobal(NULL, TRUE, stream));
41    } else {
42      IFS(SHCreateStreamOnFile((const LPTSTR)out_file_name,
43                               STGM_WRITE | STGM_CREATE, stream));
44    }
45    if (FAILED(hr)) {
46      _ftprintf(stderr, _T("Error opening output file %s (%08lx)\n"),
47                (const LPTSTR)out_file_name, hr);
48    }
49    return hr;
50  }
51  static HRESULT WriteUsingWIC(const char* out_file_name, int use_stdout,
52                               REFGUID container_guid,
53                               uint8_t* rgb, int stride,
54                               uint32_t width, uint32_t height, int has_alpha) {
55    HRESULT hr = S_OK;
56    IWICImagingFactory* factory = NULL;
57    IWICBitmapFrameEncode* frame = NULL;
58    IWICBitmapEncoder* encoder = NULL;
59    IStream* stream = NULL;
60    WICPixelFormatGUID pixel_format = has_alpha ? GUID_WICPixelFormat32bppBGRA
61                                                : GUID_WICPixelFormat24bppBGR;
62    if (out_file_name == NULL || rgb == NULL) return E_INVALIDARG;
63    IFS(CoInitialize(NULL));
64    IFS(CoCreateInstance(MAKE_REFGUID(CLSID_WICImagingFactory), NULL,
65                         CLSCTX_INPROC_SERVER,
66                         MAKE_REFGUID(IID_IWICImagingFactory),
67                         (LPVOID*)&factory));
68    if (hr == REGDB_E_CLASSNOTREG) {
69      fprintf(stderr,
70              "Couldn't access Windows Imaging Component (are you running "
71              "Windows XP SP3 or newer?). PNG support not available. "
72              "Use -ppm or -pgm for available PPM and PGM formats.\n");
73    }
74    IFS(CreateOutputStream(out_file_name, use_stdout, &stream));
75    IFS(IWICImagingFactory_CreateEncoder(factory, container_guid, NULL,
76                                         &encoder));
77    IFS(IWICBitmapEncoder_Initialize(encoder, stream,
78                                     WICBitmapEncoderNoCache));
79    IFS(IWICBitmapEncoder_CreateNewFrame(encoder, &frame, NULL));
80    IFS(IWICBitmapFrameEncode_Initialize(frame, NULL));
81    IFS(IWICBitmapFrameEncode_SetSize(frame, width, height));
82    IFS(IWICBitmapFrameEncode_SetPixelFormat(frame, &pixel_format));
83    IFS(IWICBitmapFrameEncode_WritePixels(frame, height, stride,
84                                          height * stride, rgb));
85    IFS(IWICBitmapFrameEncode_Commit(frame));
86    IFS(IWICBitmapEncoder_Commit(encoder));
87    if (SUCCEEDED(hr) && use_stdout) {
88      HGLOBAL image;
89      IFS(GetHGlobalFromStream(stream, &image));
90      if (SUCCEEDED(hr)) {
91        HANDLE std_output = GetStdHandle(STD_OUTPUT_HANDLE);
92        DWORD mode;
93        const BOOL update_mode = GetConsoleMode(std_output, &mode);
94        const void* const image_mem = GlobalLock(image);
95        DWORD bytes_written = 0;
96        if (update_mode) SetConsoleMode(std_output, 0);
97        if (!WriteFile(std_output, image_mem, (DWORD)GlobalSize(image),
98                       &bytes_written, NULL) ||
99            bytes_written != GlobalSize(image)) {
100          hr = E_FAIL;
101        }
102        if (update_mode) SetConsoleMode(std_output, mode);
103        GlobalUnlock(image);
104      }
105    }
106    if (frame != NULL) IUnknown_Release(frame);
107    if (encoder != NULL) IUnknown_Release(encoder);
108    if (factory != NULL) IUnknown_Release(factory);
109    if (stream != NULL) IUnknown_Release(stream);
110    return hr;
111  }
112  int WebPWritePNG(const char* out_file_name, int use_stdout,
113                   const WebPDecBuffer* const buffer) {
114    const uint32_t width = buffer->width;
115    const uint32_t height = buffer->height;
116    uint8_t* const rgb = buffer->u.RGBA.rgba;
117    const int stride = buffer->u.RGBA.stride;
118    const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
119    return SUCCEEDED(WriteUsingWIC(out_file_name, use_stdout,
120                                   MAKE_REFGUID(GUID_ContainerFormatPng),
121                                   rgb, stride, width, height, has_alpha));
122  }
123  #elif defined(WEBP_HAVE_PNG)    
124  static void PNGAPI PNGErrorFunction(png_structp png, png_const_charp dummy) {
125    (void)dummy;  
126    longjmp(png_jmpbuf(png), 1);
127  }
128  int WebPWritePNG(FILE* out_file, const WebPDecBuffer* const buffer) {
129    volatile png_structp png;
130    volatile png_infop info;
131    if (out_file == NULL || buffer == NULL) return 0;
132    png = png_create_write_struct(PNG_LIBPNG_VER_STRING,
133                                  NULL, PNGErrorFunction, NULL);
134    if (png == NULL) {
135      return 0;
136    }
137    info = png_create_info_struct(png);
138    if (info == NULL) {
139      png_destroy_write_struct((png_structpp)&png, NULL);
140      return 0;
141    }
142    if (setjmp(png_jmpbuf(png))) {
143      png_destroy_write_struct((png_structpp)&png, (png_infopp)&info);
144      return 0;
145    }
146    png_init_io(png, out_file);
147    {
148      const uint32_t width = buffer->width;
149      const uint32_t height = buffer->height;
150      png_bytep row = buffer->u.RGBA.rgba;
151      const int stride = buffer->u.RGBA.stride;
152      const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
153      uint32_t y;
154      png_set_IHDR(png, info, width, height, 8,
155                   has_alpha ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_RGB,
156                   PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,
157                   PNG_FILTER_TYPE_DEFAULT);
158      png_write_info(png, info);
159      for (y = 0; y < height; ++y) {
160        png_write_rows(png, &row, 1);
161        row += stride;
162      }
163    }
164    png_write_end(png, info);
165    png_destroy_write_struct((png_structpp)&png, (png_infopp)&info);
166    return 1;
167  }
168  #else    
169  int WebPWritePNG(FILE* fout, const WebPDecBuffer* const buffer) {
170    if (fout == NULL || buffer == NULL) return 0;
171    fprintf(stderr, "PNG support not compiled. Please install the libpng "
172            "development package before building.\n");
173    fprintf(stderr, "You can run with -ppm flag to decode in PPM format.\n");
174    return 0;
175  }
176  #endif
177  static int WritePPMPAM(FILE* fout, const WebPDecBuffer* const buffer,
178                         int alpha) {
179    if (fout == NULL || buffer == NULL) {
180      return 0;
181    } else {
182      const uint32_t width = buffer->width;
183      const uint32_t height = buffer->height;
184      const uint8_t* row = buffer->u.RGBA.rgba;
185      const int stride = buffer->u.RGBA.stride;
186      const size_t bytes_per_px = alpha ? 4 : 3;
187      uint32_t y;
188      if (row == NULL) return 0;
189      if (alpha) {
190        fprintf(fout, "P7\nWIDTH %u\nHEIGHT %u\nDEPTH 4\nMAXVAL 255\n"
191                      "TUPLTYPE RGB_ALPHA\nENDHDR\n", width, height);
192      } else {
193        fprintf(fout, "P6\n%u %u\n255\n", width, height);
194      }
195      for (y = 0; y < height; ++y) {
196        if (fwrite(row, width, bytes_per_px, fout) != bytes_per_px) {
197          return 0;
198        }
199        row += stride;
200      }
201    }
202    return 1;
203  }
204  int WebPWritePPM(FILE* fout, const WebPDecBuffer* const buffer) {
205    return WritePPMPAM(fout, buffer, 0);
206  }
207  int WebPWritePAM(FILE* fout, const WebPDecBuffer* const buffer) {
208    return WritePPMPAM(fout, buffer, 1);
209  }
210  int WebPWrite16bAsPGM(FILE* fout, const WebPDecBuffer* const buffer) {
211    const uint32_t width = buffer->width;
212    const uint32_t height = buffer->height;
213    const uint8_t* rgba = buffer->u.RGBA.rgba;
214    const int stride = buffer->u.RGBA.stride;
215    const uint32_t bytes_per_px = 2;
216    uint32_t y;
217    if (fout == NULL || buffer == NULL || rgba == NULL) return 0;
218    fprintf(fout, "P5\n%u %u\n255\n", width * bytes_per_px, height);
219    for (y = 0; y < height; ++y) {
220      if (fwrite(rgba, width, bytes_per_px, fout) != bytes_per_px) {
221        return 0;
222      }
223      rgba += stride;
224    }
225    return 1;
226  }
227  static void PutLE16(uint8_t* const dst, uint32_t value) {
228    dst[0] = (value >> 0) & 0xff;
229    dst[1] = (value >> 8) & 0xff;
230  }
231  static void PutLE32(uint8_t* const dst, uint32_t value) {
232    PutLE16(dst + 0, (value >>  0) & 0xffff);
233    PutLE16(dst + 2, (value >> 16) & 0xffff);
234  }
235  #define BMP_HEADER_SIZE 54
236  int WebPWriteBMP(FILE* fout, const WebPDecBuffer* const buffer) {
237    const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
238    const uint32_t width = buffer->width;
239    const uint32_t height = buffer->height;
240    const uint8_t* rgba = buffer->u.RGBA.rgba;
241    const int stride = buffer->u.RGBA.stride;
242    const uint32_t bytes_per_px = has_alpha ? 4 : 3;
243    uint32_t y;
244    const uint32_t line_size = bytes_per_px * width;
245    const uint32_t bmp_stride = (line_size + 3) & ~3;   
246    const uint32_t total_size = bmp_stride * height + BMP_HEADER_SIZE;
247    uint8_t bmp_header[BMP_HEADER_SIZE] = { 0 };
248    if (fout == NULL || buffer == NULL || rgba == NULL) return 0;
249    PutLE16(bmp_header + 0, 0x4d42);                
250    PutLE32(bmp_header + 2, total_size);            
251    PutLE32(bmp_header + 6, 0);                     
252    PutLE32(bmp_header + 10, BMP_HEADER_SIZE);      
253    PutLE32(bmp_header + 14, 40);                   
254    PutLE32(bmp_header + 18, width);                
255    PutLE32(bmp_header + 22, -(int)height);         
256    PutLE16(bmp_header + 26, 1);                    
257    PutLE16(bmp_header + 28, bytes_per_px * 8);     
258    PutLE32(bmp_header + 30, 0);                    
259    PutLE32(bmp_header + 34, 0);                    
260    PutLE32(bmp_header + 38, 2400);                 
261    PutLE32(bmp_header + 42, 2400);                 
262    PutLE32(bmp_header + 46, 0);                    
263    PutLE32(bmp_header + 50, 0);                    
264    if (fwrite(bmp_header, sizeof(bmp_header), 1, fout) != 1) {
265      return 0;
266    }
267    for (y = 0; y < height; ++y) {
268      if (fwrite(rgba, line_size, 1, fout) != 1) {
269        return 0;
270      }
271      if (bmp_stride != line_size) {
272        const uint8_t zeroes[3] = { 0 };
273        if (fwrite(zeroes, bmp_stride - line_size, 1, fout) != 1) {
274          return 0;
275        }
276      }
277      rgba += stride;
278    }
279    return 1;
280  }
281  #undef BMP_HEADER_SIZE
282  #define NUM_IFD_ENTRIES 15
283  #define EXTRA_DATA_SIZE 16
284  #define EXTRA_DATA_OFFSET (10 + 12 * NUM_IFD_ENTRIES + 4)
285  #define TIFF_HEADER_SIZE (EXTRA_DATA_OFFSET + EXTRA_DATA_SIZE)
286  int WebPWriteTIFF(FILE* fout, const WebPDecBuffer* const buffer) {
287    const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
288    const uint32_t width = buffer->width;
289    const uint32_t height = buffer->height;
290    const uint8_t* rgba = buffer->u.RGBA.rgba;
291    const int stride = buffer->u.RGBA.stride;
292    const uint8_t bytes_per_px = has_alpha ? 4 : 3;
293    const uint8_t assoc_alpha =
294        WebPIsPremultipliedMode(buffer->colorspace) ? 1 : 2;
295    const uint8_t num_ifd_entries = has_alpha ? NUM_IFD_ENTRIES
296                                              : NUM_IFD_ENTRIES - 1;
297    uint8_t tiff_header[TIFF_HEADER_SIZE] = {
298      0x49, 0x49, 0x2a, 0x00,   
299      8, 0, 0, 0,               
300      num_ifd_entries, 0,       
301      0x00, 0x01, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
302      0x01, 0x01, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
303      0x02, 0x01, 3, 0, bytes_per_px, 0, 0, 0,     
304          EXTRA_DATA_OFFSET + 0, 0, 0, 0,
305      0x03, 0x01, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0,    
306      0x06, 0x01, 3, 0, 1, 0, 0, 0, 2, 0, 0, 0,    
307      0x11, 0x01, 4, 0, 1, 0, 0, 0,                
308          TIFF_HEADER_SIZE, 0, 0, 0,               
309      0x12, 0x01, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0,    
310      0x15, 0x01, 3, 0, 1, 0, 0, 0,                
311          bytes_per_px, 0, 0, 0,
312      0x16, 0x01, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
313      0x17, 0x01, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
314      0x1a, 0x01, 5, 0, 1, 0, 0, 0,                
315          EXTRA_DATA_OFFSET + 8, 0, 0, 0,
316      0x1b, 0x01, 5, 0, 1, 0, 0, 0,                
317          EXTRA_DATA_OFFSET + 8, 0, 0, 0,
318      0x1c, 0x01, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0,    
319      0x28, 0x01, 3, 0, 1, 0, 0, 0, 2, 0, 0, 0,    
320      0x52, 0x01, 3, 0, 1, 0, 0, 0,
321          assoc_alpha, 0, 0, 0,                    
322      0, 0, 0, 0,                                  
323      8, 0, 8, 0, 8, 0, 8, 0,      
324      72, 0, 0, 0, 1, 0, 0, 0      
325    };
326    uint32_t y;
327    if (fout == NULL || buffer == NULL || rgba == NULL) return 0;
328    PutLE32(tiff_header + 10 + 8, width);
329    PutLE32(tiff_header + 22 + 8, height);
330    PutLE32(tiff_header + 106 + 8, height);
331    PutLE32(tiff_header + 118 + 8, width * bytes_per_px * height);
332    if (!has_alpha) PutLE32(tiff_header + 178, 0);  
333    if (fwrite(tiff_header, sizeof(tiff_header), 1, fout) != 1) {
334      return 0;
335    }
336    for (y = 0; y < height; ++y) {
337      if (fwrite(rgba, bytes_per_px, width, fout) != width) {
338        return 0;
339      }
340      rgba += stride;
341    }
342    return 1;
343  }
344  #undef TIFF_HEADER_SIZE
345  #undef EXTRA_DATA_OFFSET
346  #undef EXTRA_DATA_SIZE
347  #undef NUM_IFD_ENTRIES
<span onclick='openModal()' class='match'>348  int WebPWriteAlphaPlane(FILE* fout, const WebPDecBuffer* const buffer) {
349    if (fout == NULL || buffer == NULL) {
350      return 0;
</span>351    } else {
352      const uint32_t width = buffer->width;
353      const uint32_t height = buffer->height;
354      const uint8_t* a = buffer->u.YUVA.a;
355      const int a_stride = buffer->u.YUVA.a_stride;
356      uint32_t y;
357      if (a == NULL) return 0;
358      fprintf(fout, "P5\n%u %u\n255\n", width, height);
359      for (y = 0; y < height; ++y) {
360        if (fwrite(a, width, 1, fout) != 1) return 0;
361        a += a_stride;
362      }
363      return 1;
364    }
365  }
366  int WebPWritePGM(FILE* fout, const WebPDecBuffer* const buffer) {
367    if (fout == NULL || buffer == NULL) {
368      return 0;
369    } else {
370      const int width = buffer->width;
371      const int height = buffer->height;
372      const WebPYUVABuffer* const yuv = &buffer->u.YUVA;
373      const uint8_t* src_y = yuv->y;
374      const uint8_t* src_u = yuv->u;
375      const uint8_t* src_v = yuv->v;
376      const uint8_t* src_a = yuv->a;
377      const int uv_width = (width + 1) / 2;
378      const int uv_height = (height + 1) / 2;
379      const int a_height = (src_a != NULL) ? height : 0;
380      int ok = 1;
381      int y;
382      if (src_y == NULL || src_u == NULL || src_v == NULL) return 0;
383      fprintf(fout, "P5\n%d %d\n255\n",
384              (width + 1) & ~1, height + uv_height + a_height);
385      for (y = 0; ok && y < height; ++y) {
386        ok &= (fwrite(src_y, width, 1, fout) == 1);
387        if (width & 1) fputc(0, fout);    
388        src_y += yuv->y_stride;
389      }
390      for (y = 0; ok && y < uv_height; ++y) {
391        ok &= (fwrite(src_u, uv_width, 1, fout) == 1);
392        ok &= (fwrite(src_v, uv_width, 1, fout) == 1);
393        src_u += yuv->u_stride;
394        src_v += yuv->v_stride;
395      }
396      for (y = 0; ok && y < a_height; ++y) {
397        ok &= (fwrite(src_a, width, 1, fout) == 1);
398        if (width & 1) fputc(0, fout);    
399        src_a += yuv->a_stride;
400      }
401      return ok;
402    }
403  }
404  int WebPWriteYUV(FILE* fout, const WebPDecBuffer* const buffer) {
405    if (fout == NULL || buffer == NULL) {
406      return 0;
407    } else {
408      const int width = buffer->width;
409      const int height = buffer->height;
410      const WebPYUVABuffer* const yuv = &buffer->u.YUVA;
411      const uint8_t* src_y = yuv->y;
412      const uint8_t* src_u = yuv->u;
413      const uint8_t* src_v = yuv->v;
414      const uint8_t* src_a = yuv->a;
415      const int uv_width = (width + 1) / 2;
416      const int uv_height = (height + 1) / 2;
417      const int a_height = (src_a != NULL) ? height : 0;
418      int ok = 1;
419      int y;
420      if (src_y == NULL || src_u == NULL || src_v == NULL) return 0;
421      for (y = 0; ok && y < height; ++y) {
422        ok &= (fwrite(src_y, width, 1, fout) == 1);
423        src_y += yuv->y_stride;
424      }
425      for (y = 0; ok && y < uv_height; ++y) {
426        ok &= (fwrite(src_u, uv_width, 1, fout) == 1);
427        src_u += yuv->u_stride;
428      }
429      for (y = 0; ok && y < uv_height; ++y) {
430        ok &= (fwrite(src_v, uv_width, 1, fout) == 1);
431        src_v += yuv->v_stride;
432      }
433      for (y = 0; ok && y < a_height; ++y) {
434        ok &= (fwrite(src_a, width, 1, fout) == 1);
435        src_a += yuv->a_stride;
436      }
437      return ok;
438    }
439  }
440  int WebPSaveImage(const WebPDecBuffer* const buffer,
441                    WebPOutputFileFormat format,
442                    const char* const out_file_name) {
443    FILE* fout = NULL;
444    int needs_open_file = 1;
445    const int use_stdout =
446        (out_file_name != NULL) && !WSTRCMP(out_file_name, "-");
447    int ok = 1;
448    if (buffer == NULL || out_file_name == NULL) return 0;
449  #ifdef HAVE_WINCODEC_H
450    needs_open_file = (format != PNG);
451  #endif
452    if (needs_open_file) {
453      fout = use_stdout ? ImgIoUtilSetBinaryMode(stdout)
454                        : WFOPEN(out_file_name, "wb");
455      if (fout == NULL) {
456        WFPRINTF(stderr, "Error opening output file %s\n",
457                 (const W_CHAR*)out_file_name);
458        return 0;
459      }
460    }
461    if (format == PNG ||
462        format == RGBA || format == BGRA || format == ARGB ||
463        format == rgbA || format == bgrA || format == Argb) {
464  #ifdef HAVE_WINCODEC_H
465      ok &= WebPWritePNG(out_file_name, use_stdout, buffer);
466  #else
467      ok &= WebPWritePNG(fout, buffer);
468  #endif
469    } else if (format == PAM) {
470      ok &= WebPWritePAM(fout, buffer);
471    } else if (format == PPM || format == RGB || format == BGR) {
472      ok &= WebPWritePPM(fout, buffer);
473    } else if (format == RGBA_4444 || format == RGB_565 || format == rgbA_4444) {
474      ok &= WebPWrite16bAsPGM(fout, buffer);
475    } else if (format == BMP) {
476      ok &= WebPWriteBMP(fout, buffer);
477    } else if (format == TIFF) {
478      ok &= WebPWriteTIFF(fout, buffer);
479    } else if (format == RAW_YUV) {
480      ok &= WebPWriteYUV(fout, buffer);
481    } else if (format == PGM || format == YUV || format == YUVA) {
482      ok &= WebPWritePGM(fout, buffer);
483    } else if (format == ALPHA_PLANE_ONLY) {
484      ok &= WebPWriteAlphaPlane(fout, buffer);
485    }
486    if (fout != NULL && fout != stdout) {
487      fclose(fout);
488    }
489    return ok;
490  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-idec_dec.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <string.h>
3  #include <stdlib.h>
4  #include "src/dec/alphai_dec.h"
5  #include "src/dec/webpi_dec.h"
6  #include "src/dec/vp8i_dec.h"
7  #include "src/utils/utils.h"
8  #define CHUNK_SIZE 4096
9  #define MAX_MB_SIZE 4096
10  typedef enum {
11    STATE_WEBP_HEADER,  
12    STATE_VP8_HEADER,   
13    STATE_VP8_PARTS0,
14    STATE_VP8_DATA,
15    STATE_VP8L_HEADER,
16    STATE_VP8L_DATA,
17    STATE_DONE,
18    STATE_ERROR
19  } DecState;
20  typedef enum {
21    MEM_MODE_NONE = 0,
22    MEM_MODE_APPEND,
23    MEM_MODE_MAP
24  } MemBufferMode;
25  typedef struct {
26    MemBufferMode mode_;  
27    size_t start_;        
28    size_t end_;          
29    size_t buf_size_;     
30    uint8_t* buf_;        
31    size_t part0_size_;         
32    const uint8_t* part0_buf_;  
33  } MemBuffer;
34  struct WebPIDecoder {
35    DecState state_;         
36    WebPDecParams params_;   
37    int is_lossless_;        
38    void* dec_;              
39    VP8Io io_;
40    MemBuffer mem_;          
41    WebPDecBuffer output_;   
42    WebPDecBuffer* final_output_;  
43    size_t chunk_size_;      
44    int last_mb_y_;          
45  };
46  typedef struct {
47    VP8MB left_;
48    VP8MB info_;
49    VP8BitReader token_br_;
50  } MBContext;
51  static WEBP_INLINE size_t MemDataSize(const MemBuffer* mem) {
52    return (mem->end_ - mem->start_);
53  }
54  static int NeedCompressedAlpha(const WebPIDecoder* const idec) {
55    if (idec->state_ == STATE_WEBP_HEADER) {
56      return 0;
57    }
58    if (idec->is_lossless_) {
59      return 0;  
60    } else {
61      const VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
62      assert(dec != NULL);  
63      return (dec->alpha_data_ != NULL) && !dec->is_alpha_decoded_;
64    }
65  }
66  static void DoRemap(WebPIDecoder* const idec, ptrdiff_t offset) {
67    MemBuffer* const mem = &idec->mem_;
68    const uint8_t* const new_base = mem->buf_ + mem->start_;
69    idec->io_.data = new_base;
70    idec->io_.data_size = MemDataSize(mem);
71    if (idec->dec_ != NULL) {
72      if (!idec->is_lossless_) {
73        VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
74        const uint32_t last_part = dec->num_parts_minus_one_;
75        if (offset != 0) {
76          uint32_t p;
77          for (p = 0; p <= last_part; ++p) {
78            VP8RemapBitReader(dec->parts_ + p, offset);
79          }
80          if (mem->mode_ == MEM_MODE_MAP) {
81            VP8RemapBitReader(&dec->br_, offset);
82          }
83        }
84        {
85          const uint8_t* const last_start = dec->parts_[last_part].buf_;
86          VP8BitReaderSetBuffer(&dec->parts_[last_part], last_start,
87                                mem->buf_ + mem->end_ - last_start);
88        }
89        if (NeedCompressedAlpha(idec)) {
90          ALPHDecoder* const alph_dec = dec->alph_dec_;
91          dec->alpha_data_ += offset;
92          if (alph_dec != NULL && alph_dec->vp8l_dec_ != NULL) {
93            if (alph_dec->method_ == ALPHA_LOSSLESS_COMPRESSION) {
94              VP8LDecoder* const alph_vp8l_dec = alph_dec->vp8l_dec_;
95              assert(dec->alpha_data_size_ >= ALPHA_HEADER_LEN);
96              VP8LBitReaderSetBuffer(&alph_vp8l_dec->br_,
97                                     dec->alpha_data_ + ALPHA_HEADER_LEN,
98                                     dec->alpha_data_size_ - ALPHA_HEADER_LEN);
99            } else {  
100            }
101          }
102        }
103      } else {    
104        VP8LDecoder* const dec = (VP8LDecoder*)idec->dec_;
105        VP8LBitReaderSetBuffer(&dec->br_, new_base, MemDataSize(mem));
106      }
107    }
108  }
109  static int AppendToMemBuffer(WebPIDecoder* const idec,
110                               const uint8_t* const data, size_t data_size) {
111    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
112    MemBuffer* const mem = &idec->mem_;
113    const int need_compressed_alpha = NeedCompressedAlpha(idec);
114    const uint8_t* const old_start =
115        (mem->buf_ == NULL) ? NULL : mem->buf_ + mem->start_;
116    const uint8_t* const old_base =
117        need_compressed_alpha ? dec->alpha_data_ : old_start;
118    assert(mem->buf_ != NULL || mem->start_ == 0);
119    assert(mem->mode_ == MEM_MODE_APPEND);
120    if (data_size > MAX_CHUNK_PAYLOAD) {
121      return 0;
122    }
123    if (mem->end_ + data_size > mem->buf_size_) {  
124      const size_t new_mem_start = old_start - old_base;
125      const size_t current_size = MemDataSize(mem) + new_mem_start;
126      const uint64_t new_size = (uint64_t)current_size + data_size;
127      const uint64_t extra_size = (new_size + CHUNK_SIZE - 1) & ~(CHUNK_SIZE - 1);
128      uint8_t* const new_buf =
129          (uint8_t*)WebPSafeMalloc(extra_size, sizeof(*new_buf));
130      if (new_buf == NULL) return 0;
131      if (old_base != NULL) memcpy(new_buf, old_base, current_size);
132      WebPSafeFree(mem->buf_);
133      mem->buf_ = new_buf;
134      mem->buf_size_ = (size_t)extra_size;
135      mem->start_ = new_mem_start;
136      mem->end_ = current_size;
137    }
138    assert(mem->buf_ != NULL);
139    memcpy(mem->buf_ + mem->end_, data, data_size);
140    mem->end_ += data_size;
141    assert(mem->end_ <= mem->buf_size_);
142    DoRemap(idec, mem->buf_ + mem->start_ - old_start);
143    return 1;
144  }
145  static int RemapMemBuffer(WebPIDecoder* const idec,
146                            const uint8_t* const data, size_t data_size) {
147    MemBuffer* const mem = &idec->mem_;
148    const uint8_t* const old_buf = mem->buf_;
149    const uint8_t* const old_start =
150        (old_buf == NULL) ? NULL : old_buf + mem->start_;
151    assert(old_buf != NULL || mem->start_ == 0);
152    assert(mem->mode_ == MEM_MODE_MAP);
153    if (data_size < mem->buf_size_) return 0;  
154    mem->buf_ = (uint8_t*)data;
155    mem->end_ = mem->buf_size_ = data_size;
156    DoRemap(idec, mem->buf_ + mem->start_ - old_start);
157    return 1;
158  }
159  static void InitMemBuffer(MemBuffer* const mem) {
160    mem->mode_       = MEM_MODE_NONE;
161    mem->buf_        = NULL;
162    mem->buf_size_   = 0;
163    mem->part0_buf_  = NULL;
164    mem->part0_size_ = 0;
165  }
166  static void ClearMemBuffer(MemBuffer* const mem) {
167    assert(mem);
168    if (mem->mode_ == MEM_MODE_APPEND) {
169      WebPSafeFree(mem->buf_);
170      WebPSafeFree((void*)mem->part0_buf_);
171    }
172  }
173  static int CheckMemBufferMode(MemBuffer* const mem, MemBufferMode expected) {
174    if (mem->mode_ == MEM_MODE_NONE) {
175      mem->mode_ = expected;    
176    } else if (mem->mode_ != expected) {
177      return 0;         
178    }
179    assert(mem->mode_ == expected);   
180    return 1;
181  }
182  static VP8StatusCode FinishDecoding(WebPIDecoder* const idec) {
183    const WebPDecoderOptions* const options = idec->params_.options;
184    WebPDecBuffer* const output = idec->params_.output;
185    idec->state_ = STATE_DONE;
186    if (options != NULL && options->flip) {
187      const VP8StatusCode status = WebPFlipBuffer(output);
188      if (status != VP8_STATUS_OK) return status;
189    }
190    if (idec->final_output_ != NULL) {
191      WebPCopyDecBufferPixels(output, idec->final_output_);  
192      WebPFreeDecBuffer(&idec->output_);
193      *output = *idec->final_output_;
194      idec->final_output_ = NULL;
195    }
196    return VP8_STATUS_OK;
197  }
198  static void SaveContext(const VP8Decoder* dec, const VP8BitReader* token_br,
199                          MBContext* const context) {
200    context->left_ = dec->mb_info_[-1];
201    context->info_ = dec->mb_info_[dec->mb_x_];
202    context->token_br_ = *token_br;
203  }
204  static void RestoreContext(const MBContext* context, VP8Decoder* const dec,
205                             VP8BitReader* const token_br) {
206    dec->mb_info_[-1] = context->left_;
207    dec->mb_info_[dec->mb_x_] = context->info_;
208    *token_br = context->token_br_;
209  }
210  static VP8StatusCode IDecError(WebPIDecoder* const idec, VP8StatusCode error) {
211    if (idec->state_ == STATE_VP8_DATA) {
212      VP8ExitCritical((VP8Decoder*)idec->dec_, &idec->io_);
213    }
214    idec->state_ = STATE_ERROR;
215    return error;
216  }
217  static void ChangeState(WebPIDecoder* const idec, DecState new_state,
218                          size_t consumed_bytes) {
219    MemBuffer* const mem = &idec->mem_;
220    idec->state_ = new_state;
221    mem->start_ += consumed_bytes;
222    assert(mem->start_ <= mem->end_);
223    idec->io_.data = mem->buf_ + mem->start_;
224    idec->io_.data_size = MemDataSize(mem);
225  }
226  static VP8StatusCode DecodeWebPHeaders(WebPIDecoder* const idec) {
227    MemBuffer* const mem = &idec->mem_;
228    const uint8_t* data = mem->buf_ + mem->start_;
229    size_t curr_size = MemDataSize(mem);
230    VP8StatusCode status;
231    WebPHeaderStructure headers;
232    headers.data = data;
233    headers.data_size = curr_size;
234    headers.have_all_data = 0;
235    status = WebPParseHeaders(&headers);
236    if (status == VP8_STATUS_NOT_ENOUGH_DATA) {
237      return VP8_STATUS_SUSPENDED;  
238    } else if (status != VP8_STATUS_OK) {
239      return IDecError(idec, status);
240    }
241    idec->chunk_size_ = headers.compressed_size;
242    idec->is_lossless_ = headers.is_lossless;
243    if (!idec->is_lossless_) {
244      VP8Decoder* const dec = VP8New();
245      if (dec == NULL) {
246        return VP8_STATUS_OUT_OF_MEMORY;
247      }
248      idec->dec_ = dec;
249      dec->alpha_data_ = headers.alpha_data;
250      dec->alpha_data_size_ = headers.alpha_data_size;
251      ChangeState(idec, STATE_VP8_HEADER, headers.offset);
252    } else {
253      VP8LDecoder* const dec = VP8LNew();
254      if (dec == NULL) {
255        return VP8_STATUS_OUT_OF_MEMORY;
256      }
257      idec->dec_ = dec;
258      ChangeState(idec, STATE_VP8L_HEADER, headers.offset);
259    }
260    return VP8_STATUS_OK;
261  }
262  static VP8StatusCode DecodeVP8FrameHeader(WebPIDecoder* const idec) {
263    const uint8_t* data = idec->mem_.buf_ + idec->mem_.start_;
264    const size_t curr_size = MemDataSize(&idec->mem_);
265    int width, height;
266    uint32_t bits;
267    if (curr_size < VP8_FRAME_HEADER_SIZE) {
268      return VP8_STATUS_SUSPENDED;
269    }
270    if (!VP8GetInfo(data, curr_size, idec->chunk_size_, &width, &height)) {
271      return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
272    }
273    bits = data[0] | (data[1] << 8) | (data[2] << 16);
274    idec->mem_.part0_size_ = (bits >> 5) + VP8_FRAME_HEADER_SIZE;
275    idec->io_.data = data;
276    idec->io_.data_size = curr_size;
277    idec->state_ = STATE_VP8_PARTS0;
278    return VP8_STATUS_OK;
279  }
280  static VP8StatusCode CopyParts0Data(WebPIDecoder* const idec) {
281    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
282    VP8BitReader* const br = &dec->br_;
283    const size_t part_size = br->buf_end_ - br->buf_;
284    MemBuffer* const mem = &idec->mem_;
285    assert(!idec->is_lossless_);
286    assert(mem->part0_buf_ == NULL);
287    assert(part_size <= mem->part0_size_);
288    if (part_size == 0) {   
289      return VP8_STATUS_BITSTREAM_ERROR;
290    }
291    if (mem->mode_ == MEM_MODE_APPEND) {
292      uint8_t* const part0_buf = (uint8_t*)WebPSafeMalloc(1ULL, part_size);
293      if (part0_buf == NULL) {
294        return VP8_STATUS_OUT_OF_MEMORY;
295      }
296      memcpy(part0_buf, br->buf_, part_size);
297      mem->part0_buf_ = part0_buf;
298      VP8BitReaderSetBuffer(br, part0_buf, part_size);
299    } else {
300    }
301    mem->start_ += part_size;
302    return VP8_STATUS_OK;
303  }
304  static VP8StatusCode DecodePartition0(WebPIDecoder* const idec) {
305    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
306    VP8Io* const io = &idec->io_;
307    const WebPDecParams* const params = &idec->params_;
308    WebPDecBuffer* const output = params->output;
309    if (MemDataSize(&idec->mem_) < idec->mem_.part0_size_) {
310      return VP8_STATUS_SUSPENDED;
311    }
312    if (!VP8GetHeaders(dec, io)) {
313      const VP8StatusCode status = dec->status_;
314      if (status == VP8_STATUS_SUSPENDED ||
315          status == VP8_STATUS_NOT_ENOUGH_DATA) {
316        return VP8_STATUS_SUSPENDED;
317      }
318      return IDecError(idec, status);
319    }
320    dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options,
321                                         output);
322    if (dec->status_ != VP8_STATUS_OK) {
323      return IDecError(idec, dec->status_);
324    }
325    dec->mt_method_ = VP8GetThreadMethod(params->options, NULL,
326                                         io->width, io->height);
327    VP8InitDithering(params->options, dec);
328    dec->status_ = CopyParts0Data(idec);
329    if (dec->status_ != VP8_STATUS_OK) {
330      return IDecError(idec, dec->status_);
331    }
332    if (VP8EnterCritical(dec, io) != VP8_STATUS_OK) {
333      return IDecError(idec, dec->status_);
334    }
335    idec->state_ = STATE_VP8_DATA;
336    if (!VP8InitFrame(dec, io)) {
337      return IDecError(idec, dec->status_);
338    }
339    return VP8_STATUS_OK;
340  }
341  static VP8StatusCode DecodeRemaining(WebPIDecoder* const idec) {
342    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
343    VP8Io* const io = &idec->io_;
344    if (!dec->ready_) {
345      return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
346    }
347    for (; dec->mb_y_ < dec->mb_h_; ++dec->mb_y_) {
348      if (idec->last_mb_y_ != dec->mb_y_) {
349        if (!VP8ParseIntraModeRow(&dec->br_, dec)) {
350          return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
351        }
352        idec->last_mb_y_ = dec->mb_y_;
353      }
354      for (; dec->mb_x_ < dec->mb_w_; ++dec->mb_x_) {
355        VP8BitReader* const token_br =
356            &dec->parts_[dec->mb_y_ & dec->num_parts_minus_one_];
357        MBContext context;
358        SaveContext(dec, token_br, &context);
359        if (!VP8DecodeMB(dec, token_br)) {
360          if (dec->num_parts_minus_one_ == 0 &&
361              MemDataSize(&idec->mem_) > MAX_MB_SIZE) {
362            return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
363          }
364          if (dec->mt_method_ > 0) {
365            if (!WebPGetWorkerInterface()->Sync(&dec->worker_)) {
366              return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
367            }
368          }
369          RestoreContext(&context, dec, token_br);
370          return VP8_STATUS_SUSPENDED;
371        }
372        if (dec->num_parts_minus_one_ == 0) {
373          idec->mem_.start_ = token_br->buf_ - idec->mem_.buf_;
374          assert(idec->mem_.start_ <= idec->mem_.end_);
375        }
376      }
377      VP8InitScanline(dec);   
378      if (!VP8ProcessRow(dec, io)) {
379        return IDecError(idec, VP8_STATUS_USER_ABORT);
380      }
381    }
382    if (!VP8ExitCritical(dec, io)) {
383      idec->state_ = STATE_ERROR;  
384      return IDecError(idec, VP8_STATUS_USER_ABORT);
385    }
386    dec->ready_ = 0;
387    return FinishDecoding(idec);
388  }
389  static VP8StatusCode ErrorStatusLossless(WebPIDecoder* const idec,
390                                           VP8StatusCode status) {
391    if (status == VP8_STATUS_SUSPENDED || status == VP8_STATUS_NOT_ENOUGH_DATA) {
392      return VP8_STATUS_SUSPENDED;
393    }
394    return IDecError(idec, status);
395  }
396  static VP8StatusCode DecodeVP8LHeader(WebPIDecoder* const idec) {
397    VP8Io* const io = &idec->io_;
398    VP8LDecoder* const dec = (VP8LDecoder*)idec->dec_;
399    const WebPDecParams* const params = &idec->params_;
400    WebPDecBuffer* const output = params->output;
401    size_t curr_size = MemDataSize(&idec->mem_);
402    assert(idec->is_lossless_);
403    if (curr_size < (idec->chunk_size_ >> 3)) {
404      dec->status_ = VP8_STATUS_SUSPENDED;
405      return ErrorStatusLossless(idec, dec->status_);
406    }
407    if (!VP8LDecodeHeader(dec, io)) {
408      if (dec->status_ == VP8_STATUS_BITSTREAM_ERROR &&
409          curr_size < idec->chunk_size_) {
410        dec->status_ = VP8_STATUS_SUSPENDED;
411      }
412      return ErrorStatusLossless(idec, dec->status_);
413    }
414    dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options,
415                                         output);
416    if (dec->status_ != VP8_STATUS_OK) {
417      return IDecError(idec, dec->status_);
418    }
419    idec->state_ = STATE_VP8L_DATA;
420    return VP8_STATUS_OK;
421  }
422  static VP8StatusCode DecodeVP8LData(WebPIDecoder* const idec) {
423    VP8LDecoder* const dec = (VP8LDecoder*)idec->dec_;
424    const size_t curr_size = MemDataSize(&idec->mem_);
425    assert(idec->is_lossless_);
426    dec->incremental_ = (curr_size < idec->chunk_size_);
427    if (!VP8LDecodeImage(dec)) {
428      return ErrorStatusLossless(idec, dec->status_);
429    }
430    assert(dec->status_ == VP8_STATUS_OK || dec->status_ == VP8_STATUS_SUSPENDED);
431    return (dec->status_ == VP8_STATUS_SUSPENDED) ? dec->status_
432                                                  : FinishDecoding(idec);
433  }
434  static VP8StatusCode IDecode(WebPIDecoder* idec) {
435    VP8StatusCode status = VP8_STATUS_SUSPENDED;
436    if (idec->state_ == STATE_WEBP_HEADER) {
437      status = DecodeWebPHeaders(idec);
438    } else {
439      if (idec->dec_ == NULL) {
440        return VP8_STATUS_SUSPENDED;    
441      }
442    }
443    if (idec->state_ == STATE_VP8_HEADER) {
444      status = DecodeVP8FrameHeader(idec);
445    }
446    if (idec->state_ == STATE_VP8_PARTS0) {
447      status = DecodePartition0(idec);
448    }
449    if (idec->state_ == STATE_VP8_DATA) {
450      const VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
451      if (dec == NULL) {
452        return VP8_STATUS_SUSPENDED;  
453      }
454      status = DecodeRemaining(idec);
455    }
456    if (idec->state_ == STATE_VP8L_HEADER) {
457      status = DecodeVP8LHeader(idec);
458    }
459    if (idec->state_ == STATE_VP8L_DATA) {
460      status = DecodeVP8LData(idec);
461    }
462    return status;
463  }
464  static WebPIDecoder* NewDecoder(WebPDecBuffer* const output_buffer,
465                                  const WebPBitstreamFeatures* const features) {
466    WebPIDecoder* idec = (WebPIDecoder*)WebPSafeCalloc(1ULL, sizeof(*idec));
467    if (idec == NULL) {
468      return NULL;
469    }
470    idec->state_ = STATE_WEBP_HEADER;
471    idec->chunk_size_ = 0;
472    idec->last_mb_y_ = -1;
473    InitMemBuffer(&idec->mem_);
474    WebPInitDecBuffer(&idec->output_);
475    VP8InitIo(&idec->io_);
476    WebPResetDecParams(&idec->params_);
477    if (output_buffer == NULL || WebPAvoidSlowMemory(output_buffer, features)) {
478      idec->params_.output = &idec->output_;
479      idec->final_output_ = output_buffer;
480      if (output_buffer != NULL) {
481        idec->params_.output->colorspace = output_buffer->colorspace;
482      }
483    } else {
484      idec->params_.output = output_buffer;
485      idec->final_output_ = NULL;
486    }
487    WebPInitCustomIo(&idec->params_, &idec->io_);  
488    return idec;
489  }
490  WebPIDecoder* WebPINewDecoder(WebPDecBuffer* output_buffer) {
491    return NewDecoder(output_buffer, NULL);
492  }
493  WebPIDecoder* WebPIDecode(const uint8_t* data, size_t data_size,
494                            WebPDecoderConfig* config) {
495    WebPIDecoder* idec;
496    WebPBitstreamFeatures tmp_features;
497    WebPBitstreamFeatures* const features =
498        (config == NULL) ? &tmp_features : &config->input;
499    memset(&tmp_features, 0, sizeof(tmp_features));
500    if (data != NULL && data_size > 0) {
501      if (WebPGetFeatures(data, data_size, features) != VP8_STATUS_OK) {
502        return NULL;
503      }
504    }
505    idec = (config != NULL) ? NewDecoder(&config->output, features)
506                            : NewDecoder(NULL, features);
507    if (idec == NULL) {
508      return NULL;
509    }
510    if (config != NULL) {
511      idec->params_.options = &config->options;
512    }
513    return idec;
514  }
515  void WebPIDelete(WebPIDecoder* idec) {
516    if (idec == NULL) return;
517    if (idec->dec_ != NULL) {
518      if (!idec->is_lossless_) {
519        if (idec->state_ == STATE_VP8_DATA) {
520          VP8ExitCritical((VP8Decoder*)idec->dec_, &idec->io_);
521        }
522        VP8Delete((VP8Decoder*)idec->dec_);
523      } else {
524        VP8LDelete((VP8LDecoder*)idec->dec_);
525      }
526    }
527    ClearMemBuffer(&idec->mem_);
528    WebPFreeDecBuffer(&idec->output_);
529    WebPSafeFree(idec);
530  }
531  WebPIDecoder* WebPINewRGB(WEBP_CSP_MODE csp, uint8_t* output_buffer,
532                            size_t output_buffer_size, int output_stride) {
533    const int is_external_memory = (output_buffer != NULL) ? 1 : 0;
534    WebPIDecoder* idec;
535    if (csp >= MODE_YUV) return NULL;
536    if (is_external_memory == 0) {    
537      output_buffer_size = 0;
538      output_stride = 0;
539    } else {  
540      if (output_stride == 0 || output_buffer_size == 0) {
541        return NULL;   
542      }
543    }
544    idec = WebPINewDecoder(NULL);
545    if (idec == NULL) return NULL;
546    idec->output_.colorspace = csp;
547    idec->output_.is_external_memory = is_external_memory;
548    idec->output_.u.RGBA.rgba = output_buffer;
549    idec->output_.u.RGBA.stride = output_stride;
550    idec->output_.u.RGBA.size = output_buffer_size;
551    return idec;
552  }
553  WebPIDecoder* WebPINewYUVA(uint8_t* luma, size_t luma_size, int luma_stride,
554                             uint8_t* u, size_t u_size, int u_stride,
555                             uint8_t* v, size_t v_size, int v_stride,
556                             uint8_t* a, size_t a_size, int a_stride) {
557    const int is_external_memory = (luma != NULL) ? 1 : 0;
558    WebPIDecoder* idec;
559    WEBP_CSP_MODE colorspace;
560    if (is_external_memory == 0) {    
561      luma_size = u_size = v_size = a_size = 0;
562      luma_stride = u_stride = v_stride = a_stride = 0;
563      u = v = a = NULL;
564      colorspace = MODE_YUVA;
565    } else {  
566      if (u == NULL || v == NULL) return NULL;
567      if (luma_size == 0 || u_size == 0 || v_size == 0) return NULL;
568      if (luma_stride == 0 || u_stride == 0 || v_stride == 0) return NULL;
569      if (a != NULL) {
570        if (a_size == 0 || a_stride == 0) return NULL;
571      }
572      colorspace = (a == NULL) ? MODE_YUV : MODE_YUVA;
573    }
574    idec = WebPINewDecoder(NULL);
575    if (idec == NULL) return NULL;
576    idec->output_.colorspace = colorspace;
577    idec->output_.is_external_memory = is_external_memory;
578    idec->output_.u.YUVA.y = luma;
579    idec->output_.u.YUVA.y_stride = luma_stride;
580    idec->output_.u.YUVA.y_size = luma_size;
581    idec->output_.u.YUVA.u = u;
582    idec->output_.u.YUVA.u_stride = u_stride;
583    idec->output_.u.YUVA.u_size = u_size;
584    idec->output_.u.YUVA.v = v;
585    idec->output_.u.YUVA.v_stride = v_stride;
586    idec->output_.u.YUVA.v_size = v_size;
587    idec->output_.u.YUVA.a = a;
588    idec->output_.u.YUVA.a_stride = a_stride;
589    idec->output_.u.YUVA.a_size = a_size;
590    return idec;
591  }
592  WebPIDecoder* WebPINewYUV(uint8_t* luma, size_t luma_size, int luma_stride,
593                            uint8_t* u, size_t u_size, int u_stride,
594                            uint8_t* v, size_t v_size, int v_stride) {
595    return WebPINewYUVA(luma, luma_size, luma_stride,
596                        u, u_size, u_stride,
597                        v, v_size, v_stride,
598                        NULL, 0, 0);
599  }
600  static VP8StatusCode IDecCheckStatus(const WebPIDecoder* const idec) {
601    assert(idec);
602    if (idec->state_ == STATE_ERROR) {
603      return VP8_STATUS_BITSTREAM_ERROR;
604    }
605    if (idec->state_ == STATE_DONE) {
606      return VP8_STATUS_OK;
607    }
608    return VP8_STATUS_SUSPENDED;
609  }
610  VP8StatusCode WebPIAppend(WebPIDecoder* idec,
611                            const uint8_t* data, size_t data_size) {
612    VP8StatusCode status;
613    if (idec == NULL || data == NULL) {
614      return VP8_STATUS_INVALID_PARAM;
615    }
616    status = IDecCheckStatus(idec);
617    if (status != VP8_STATUS_SUSPENDED) {
618      return status;
619    }
620    if (!CheckMemBufferMode(&idec->mem_, MEM_MODE_APPEND)) {
621      return VP8_STATUS_INVALID_PARAM;
622    }
623    if (!AppendToMemBuffer(idec, data, data_size)) {
624      return VP8_STATUS_OUT_OF_MEMORY;
625    }
626    return IDecode(idec);
627  }
628  VP8StatusCode WebPIUpdate(WebPIDecoder* idec,
629                            const uint8_t* data, size_t data_size) {
630    VP8StatusCode status;
631    if (idec == NULL || data == NULL) {
632      return VP8_STATUS_INVALID_PARAM;
633    }
634    status = IDecCheckStatus(idec);
635    if (status != VP8_STATUS_SUSPENDED) {
636      return status;
637    }
638    if (!CheckMemBufferMode(&idec->mem_, MEM_MODE_MAP)) {
639      return VP8_STATUS_INVALID_PARAM;
640    }
641    if (!RemapMemBuffer(idec, data, data_size)) {
642      return VP8_STATUS_INVALID_PARAM;
643    }
644    return IDecode(idec);
645  }
<span onclick='openModal()' class='match'>646  static const WebPDecBuffer* GetOutputBuffer(const WebPIDecoder* const idec) {
647    if (idec == NULL || idec->dec_ == NULL) {
648      return NULL;
</span>649    }
650    if (idec->state_ <= STATE_VP8_PARTS0) {
651      return NULL;
652    }
653    if (idec->final_output_ != NULL) {
654      return NULL;   
655    }
656    return idec->params_.output;
657  }
658  const WebPDecBuffer* WebPIDecodedArea(const WebPIDecoder* idec,
659                                        int* left, int* top,
660                                        int* width, int* height) {
661    const WebPDecBuffer* const src = GetOutputBuffer(idec);
662    if (left != NULL) *left = 0;
663    if (top != NULL) *top = 0;
664    if (src != NULL) {
665      if (width != NULL) *width = src->width;
666      if (height != NULL) *height = idec->params_.last_y;
667    } else {
668      if (width != NULL) *width = 0;
669      if (height != NULL) *height = 0;
670    }
671    return src;
672  }
673  uint8_t* WebPIDecGetRGB(const WebPIDecoder* idec, int* last_y,
674                          int* width, int* height, int* stride) {
675    const WebPDecBuffer* const src = GetOutputBuffer(idec);
676    if (src == NULL) return NULL;
677    if (src->colorspace >= MODE_YUV) {
678      return NULL;
679    }
680    if (last_y != NULL) *last_y = idec->params_.last_y;
681    if (width != NULL) *width = src->width;
682    if (height != NULL) *height = src->height;
683    if (stride != NULL) *stride = src->u.RGBA.stride;
684    return src->u.RGBA.rgba;
685  }
686  uint8_t* WebPIDecGetYUVA(const WebPIDecoder* idec, int* last_y,
687                           uint8_t** u, uint8_t** v, uint8_t** a,
688                           int* width, int* height,
689                           int* stride, int* uv_stride, int* a_stride) {
690    const WebPDecBuffer* const src = GetOutputBuffer(idec);
691    if (src == NULL) return NULL;
692    if (src->colorspace < MODE_YUV) {
693      return NULL;
694    }
695    if (last_y != NULL) *last_y = idec->params_.last_y;
696    if (u != NULL) *u = src->u.YUVA.u;
697    if (v != NULL) *v = src->u.YUVA.v;
698    if (a != NULL) *a = src->u.YUVA.a;
699    if (width != NULL) *width = src->width;
700    if (height != NULL) *height = src->height;
701    if (stride != NULL) *stride = src->u.YUVA.y_stride;
702    if (uv_stride != NULL) *uv_stride = src->u.YUVA.u_stride;
703    if (a_stride != NULL) *a_stride = src->u.YUVA.a_stride;
704    return src->u.YUVA.y;
705  }
706  int WebPISetIOHooks(WebPIDecoder* const idec,
707                      VP8IoPutHook put,
708                      VP8IoSetupHook setup,
709                      VP8IoTeardownHook teardown,
710                      void* user_data) {
711    if (idec == NULL || idec->state_ > STATE_WEBP_HEADER) {
712      return 0;
713    }
714    idec->io_.put = put;
715    idec->io_.setup = setup;
716    idec->io_.teardown = teardown;
717    idec->io_.opaque = user_data;
718    return 1;
719  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-image_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-idec_dec.c</div>
                </div>
                <div class="column column_space"><pre><code>348  int WebPWriteAlphaPlane(FILE* fout, const WebPDecBuffer* const buffer) {
349    if (fout == NULL || buffer == NULL) {
350      return 0;
</pre></code></div>
                <div class="column column_space"><pre><code>646  static const WebPDecBuffer* GetOutputBuffer(const WebPIDecoder* const idec) {
647    if (idec == NULL || idec->dec_ == NULL) {
648      return NULL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    