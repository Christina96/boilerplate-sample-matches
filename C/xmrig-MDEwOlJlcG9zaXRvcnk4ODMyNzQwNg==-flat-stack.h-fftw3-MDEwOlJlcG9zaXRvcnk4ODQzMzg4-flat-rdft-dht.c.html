
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.187319884726225%, Tokens: 9</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-stack.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_INTERNAL_STACK_H_
2  #define RAPIDJSON_INTERNAL_STACK_H_
3  #include "../allocators.h"
4  #include "swap.h"
5  #include <cstddef>
6  #if defined(__clang__)
7  RAPIDJSON_DIAG_PUSH
8  RAPIDJSON_DIAG_OFF(c++98-compat)
9  #endif
10  RAPIDJSON_NAMESPACE_BEGIN
11  namespace internal {
12  template <typename Allocator>
13  class Stack {
14  public:
15      Stack(Allocator* allocator, size_t stackCapacity) : allocator_(allocator), ownAllocator_(0), stack_(0), stackTop_(0), stackEnd_(0), initialCapacity_(stackCapacity) {
16      }
17  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
18      Stack(Stack&& rhs)
19          : allocator_(rhs.allocator_),
20            ownAllocator_(rhs.ownAllocator_),
21            stack_(rhs.stack_),
22            stackTop_(rhs.stackTop_),
23            stackEnd_(rhs.stackEnd_),
24            initialCapacity_(rhs.initialCapacity_)
<span onclick='openModal()' class='match'>25      {
26          rhs.allocator_ = 0;
27          rhs.ownAllocator_ = 0;
28          rhs.stack_ = 0;
29          rhs.stackTop_ = 0;
30          rhs.stackEnd_ = 0;
31          rhs.initialCapacity_ = 0;
32      }
33  #endif
34      ~Stack() {
</span>35          Destroy();
36      }
37  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
38      Stack& operator=(Stack&& rhs) {
39          if (&rhs != this)
40          {
41              Destroy();
42              allocator_ = rhs.allocator_;
43              ownAllocator_ = rhs.ownAllocator_;
44              stack_ = rhs.stack_;
45              stackTop_ = rhs.stackTop_;
46              stackEnd_ = rhs.stackEnd_;
47              initialCapacity_ = rhs.initialCapacity_;
48              rhs.allocator_ = 0;
49              rhs.ownAllocator_ = 0;
50              rhs.stack_ = 0;
51              rhs.stackTop_ = 0;
52              rhs.stackEnd_ = 0;
53              rhs.initialCapacity_ = 0;
54          }
55          return *this;
56      }
57  #endif
58      void Swap(Stack& rhs) RAPIDJSON_NOEXCEPT {
59          internal::Swap(allocator_, rhs.allocator_);
60          internal::Swap(ownAllocator_, rhs.ownAllocator_);
61          internal::Swap(stack_, rhs.stack_);
62          internal::Swap(stackTop_, rhs.stackTop_);
63          internal::Swap(stackEnd_, rhs.stackEnd_);
64          internal::Swap(initialCapacity_, rhs.initialCapacity_);
65      }
66      void Clear() { stackTop_ = stack_; }
67      void ShrinkToFit() {
68          if (Empty()) {
69              Allocator::Free(stack_); 
70              stack_ = 0;
71              stackTop_ = 0;
72              stackEnd_ = 0;
73          }
74          else
75              Resize(GetSize());
76      }
77      template<typename T>
78      RAPIDJSON_FORCEINLINE void Reserve(size_t count = 1) {
79          if (RAPIDJSON_UNLIKELY(static_cast<std::ptrdiff_t>(sizeof(T) * count) > (stackEnd_ - stackTop_)))
80              Expand<T>(count);
81      }
82      template<typename T>
83      RAPIDJSON_FORCEINLINE T* Push(size_t count = 1) {
84          Reserve<T>(count);
85          return PushUnsafe<T>(count);
86      }
87      template<typename T>
88      RAPIDJSON_FORCEINLINE T* PushUnsafe(size_t count = 1) {
89          RAPIDJSON_ASSERT(stackTop_);
90          RAPIDJSON_ASSERT(static_cast<std::ptrdiff_t>(sizeof(T) * count) <= (stackEnd_ - stackTop_));
91          T* ret = reinterpret_cast<T*>(stackTop_);
92          stackTop_ += sizeof(T) * count;
93          return ret;
94      }
95      template<typename T>
96      T* Pop(size_t count) {
97          RAPIDJSON_ASSERT(GetSize() >= count * sizeof(T));
98          stackTop_ -= count * sizeof(T);
99          return reinterpret_cast<T*>(stackTop_);
100      }
101      template<typename T>
102      T* Top() {
103          RAPIDJSON_ASSERT(GetSize() >= sizeof(T));
104          return reinterpret_cast<T*>(stackTop_ - sizeof(T));
105      }
106      template<typename T>
107      const T* Top() const {
108          RAPIDJSON_ASSERT(GetSize() >= sizeof(T));
109          return reinterpret_cast<T*>(stackTop_ - sizeof(T));
110      }
111      template<typename T>
112      T* End() { return reinterpret_cast<T*>(stackTop_); }
113      template<typename T>
114      const T* End() const { return reinterpret_cast<T*>(stackTop_); }
115      template<typename T>
116      T* Bottom() { return reinterpret_cast<T*>(stack_); }
117      template<typename T>
118      const T* Bottom() const { return reinterpret_cast<T*>(stack_); }
119      bool HasAllocator() const {
120          return allocator_ != 0;
121      }
122      Allocator& GetAllocator() {
123          RAPIDJSON_ASSERT(allocator_);
124          return *allocator_;
125      }
126      bool Empty() const { return stackTop_ == stack_; }
127      size_t GetSize() const { return static_cast<size_t>(stackTop_ - stack_); }
128      size_t GetCapacity() const { return static_cast<size_t>(stackEnd_ - stack_); }
129  private:
130      template<typename T>
131      void Expand(size_t count) {
132          size_t newCapacity;
133          if (stack_ == 0) {
134              if (!allocator_)
135                  ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
136              newCapacity = initialCapacity_;
137          } else {
138              newCapacity = GetCapacity();
139              newCapacity += (newCapacity + 1) / 2;
140          }
141          size_t newSize = GetSize() + sizeof(T) * count;
142          if (newCapacity < newSize)
143              newCapacity = newSize;
144          Resize(newCapacity);
145      }
146      void Resize(size_t newCapacity) {
147          const size_t size = GetSize();  
148          stack_ = static_cast<char*>(allocator_->Realloc(stack_, GetCapacity(), newCapacity));
149          stackTop_ = stack_ + size;
150          stackEnd_ = stack_ + newCapacity;
151      }
152      void Destroy() {
153          Allocator::Free(stack_);
154          RAPIDJSON_DELETE(ownAllocator_); 
155      }
156      Stack(const Stack&);
157      Stack& operator=(const Stack&);
158      Allocator* allocator_;
159      Allocator* ownAllocator_;
160      char *stack_;
161      char *stackTop_;
162      char *stackEnd_;
163      size_t initialCapacity_;
164  };
165  } 
166  RAPIDJSON_NAMESPACE_END
167  #if defined(__clang__)
168  RAPIDJSON_DIAG_POP
169  #endif
170  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-dht.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft super;
7       plan *cld;
8       INT is, os;
9       INT n;
10  } P;
11  static void apply_r2hc(const plan *ego_, R *I, R *O)
12  {
13       const P *ego = (const P *) ego_;
14       INT os;
15       INT i, n;
16       {
17  	  plan_rdft *cld = (plan_rdft *) ego->cld;
18  	  cld->apply((plan *) cld, I, O);
19       }
20       n = ego->n;
21       os = ego->os;
22       for (i = 1; i < n - i; ++i) {
23  	  E a, b;
24  	  a = K(0.5) * O[os * i];
25  	  b = K(0.5) * O[os * (n - i)];
26  	  O[os * i] = a + b;
27  #if FFT_SIGN == -1
28  	  O[os * (n - i)] = b - a;
29  #else
30  	  O[os * (n - i)] = a - b;
31  #endif
32       }
33  }
34  static void apply_hc2r(const plan *ego_, R *I, R *O)
35  {
36       const P *ego = (const P *) ego_;
37       INT is = ego->is;
38       INT i, n = ego->n;
<span onclick='openModal()' class='match'>39       for (i = 1; i < n - i; ++i) {
40  	  E a, b;
41  	  a = I[is * i];
42  	  b = I[is * (n - i)];
43  #if FFT_SIGN == -1
44  	  I[is * i] = a - b;
45  	  I[is * (n - i)] = a + b;
46  #else
47  	  I[is * i] = a + b;
48  	  I[is * (n - i)] = a - b;
49  #endif
50       }
51       {
</span>52  	  plan_rdft *cld = (plan_rdft *) ego->cld;
53  	  cld->apply((plan *) cld, I, O);
54       }
55  }
56  static void apply_hc2r_save(const plan *ego_, R *I, R *O)
57  {
58       const P *ego = (const P *) ego_;
59       INT is = ego->is, os = ego->os;
60       INT i, n = ego->n;
61       O[0] = I[0];
62       for (i = 1; i < n - i; ++i) {
63  	  E a, b;
64  	  a = I[is * i];
65  	  b = I[is * (n - i)];
66  #if FFT_SIGN == -1
67  	  O[os * i] = a - b;
68  	  O[os * (n - i)] = a + b;
69  #else
70  	  O[os * i] = a + b;
71  	  O[os * (n - i)] = a - b;
72  #endif
73       }
74       if (i == n - i)
75  	  O[os * i] = I[is * i];
76       {
77  	  plan_rdft *cld = (plan_rdft *) ego->cld;
78  	  cld->apply((plan *) cld, O, O);
79       }
80  }
81  static void awake(plan *ego_, enum wakefulness wakefulness)
82  {
83       P *ego = (P *) ego_;
84       X(plan_awake)(ego->cld, wakefulness);
85  }
86  static void destroy(plan *ego_)
87  {
88       P *ego = (P *) ego_;
89       X(plan_destroy_internal)(ego->cld);
90  }
91  static void print(const plan *ego_, printer *p)
92  {
93       const P *ego = (const P *) ego_;
94       p->print(p, "(%s-dht-%D%(%p%))", 
95  	      ego->super.apply == apply_r2hc ? "r2hc" : "hc2r",
96  	      ego->n, ego->cld);
97  }
98  static int applicable0(const solver *ego_, const problem *p_)
99  {
100       const problem_rdft *p = (const problem_rdft *) p_;
101       UNUSED(ego_);
102       return (1
103  	     && p->sz->rnk == 1
104  	     && p->vecsz->rnk == 0
105  	     && (p->kind[0] == R2HC || p->kind[0] == HC2R)
106  	     && p->sz->dims[0].n > 2
107  	  );
108  }
109  static int applicable(const solver *ego, const problem *p_, 
110  		      const planner *plnr)
111  {
112       return (!NO_SLOWP(plnr) && applicable0(ego, p_));
113  }
114  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
115  {
116       P *pln;
117       const problem_rdft *p;
118       problem *cldp;
119       plan *cld;
120       static const plan_adt padt = {
121  	  X(rdft_solve), awake, print, destroy
122       };
123       if (!applicable(ego_, p_, plnr))
124            return (plan *)0;
125       p = (const problem_rdft *) p_;
126       if (p->kind[0] == R2HC || !NO_DESTROY_INPUTP(plnr))
127  	  cldp = X(mkproblem_rdft_1)(p->sz, p->vecsz, p->I, p->O, DHT);
128       else {
129  	  tensor *sz = X(tensor_copy_inplace)(p->sz, INPLACE_OS);
130  	  cldp = X(mkproblem_rdft_1)(sz, p->vecsz, p->O, p->O, DHT);
131  	  X(tensor_destroy)(sz);
132       }
133       cld = X(mkplan_d)(plnr, cldp);
134       if (!cld) return (plan *)0;
135       pln = MKPLAN_RDFT(P, &padt, p->kind[0] == R2HC ? 
136  		       apply_r2hc : (NO_DESTROY_INPUTP(plnr) ?
137  				     apply_hc2r_save : apply_hc2r));
138       pln->n = p->sz->dims[0].n;
139       pln->is = p->sz->dims[0].is;
140       pln->os = p->sz->dims[0].os;
141       pln->cld = cld;
142       pln->super.super.ops = cld->ops;
143       pln->super.super.ops.other += 4 * ((pln->n - 1)/2);
144       pln->super.super.ops.add += 2 * ((pln->n - 1)/2);
145       if (p->kind[0] == R2HC)
146  	  pln->super.super.ops.mul += 2 * ((pln->n - 1)/2);
147       if (pln->super.apply == apply_hc2r_save)
148  	  pln->super.super.ops.other += 2 + (pln->n % 2 ? 0 : 2);
149       return &(pln->super.super);
150  }
151  static solver *mksolver(void)
152  {
153       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
154       S *slv = MKSOLVER(S, &sadt);
155       return &(slv->super);
156  }
157  void X(rdft_dht_register)(planner *p)
158  {
159       REGISTER_SOLVER(p, mksolver());
160  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-stack.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-dht.c</div>
                <div class="column column_space"><pre><code>25      {
26          rhs.allocator_ = 0;
27          rhs.ownAllocator_ = 0;
28          rhs.stack_ = 0;
29          rhs.stackTop_ = 0;
30          rhs.stackEnd_ = 0;
31          rhs.initialCapacity_ = 0;
32      }
33  #endif
34      ~Stack() {
</pre></code></div>
                <div class="column column_space"><pre><code>39       for (i = 1; i < n - i; ++i) {
40  	  E a, b;
41  	  a = I[is * i];
42  	  b = I[is * (n - i)];
43  #if FFT_SIGN == -1
44  	  I[is * i] = a - b;
45  	  I[is * (n - i)] = a + b;
46  #else
47  	  I[is * i] = a + b;
48  	  I[is * (n - i)] = a - b;
49  #endif
50       }
51       {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    