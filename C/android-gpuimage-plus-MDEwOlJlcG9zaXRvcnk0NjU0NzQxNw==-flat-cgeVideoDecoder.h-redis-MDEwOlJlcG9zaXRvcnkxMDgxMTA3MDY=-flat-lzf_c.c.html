
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.092198581560284%, Tokens: 10</h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeVideoDecoder.h</h3>
            <pre><code>1  #if !defined(_CGEVIDEODECODER_H_) && defined(CGE_USE_FFMPEG)
2  #define _CGEVIDEODECODER_H_
3  #include "cgeCommonDefine.h"
4  struct AVFrame;
5  struct AVDictionary;
6  class CGEVideoDecodeContext;
7  namespace CGE
8  {
9  struct CGEVideoDecodeContext;
10  enum CGEVideoFormat
11  {
12      CGE_VIDEO_FORMAT_NONE = -1,
13      CGE_VIDEO_FORMAT_YUV420P,
14      CGE_VIDEO_FORMAT_YUYV422,
15      CGE_VIDEO_FORMAT_RGB24,
16      CGE_VIDEO_FORMAT_BGR24,
17      CGE_VIDEO_FORMAT_YUV422P,
18      CGE_VIDEO_FORMAT_YUV444P,
19      CGE_VIDEO_FORMAT_YUV410P,
20      CGE_VIDEO_FORMAT_YUV411P,
21      CGE_VIDEO_FORMAT_GRAY8,
22      CGE_VIDEO_FORMAT_MONOWHITE,
23      CGE_VIDEO_FORMAT_MONOBLACK,
24      CGE_VIDEO_FORMAT_PAL8,
25      CGE_VIDEO_FORMAT_YUVJ420P,
26      CGE_VIDEO_FORMAT_YUVJ422P,
27      CGE_VIDEO_FORMAT_YUVJ444P,
28      CGE_VIDEO_FORMAT_XVMC_MPEG2_MC,
29      CGE_VIDEO_FORMAT_XVMC_MPEG2_IDCT,
30      CGE_VIDEO_FORMAT_UYVY422,
31      CGE_VIDEO_FORMAT_UYYVYY411,
32      CGE_VIDEO_FORMAT_BGR8,
33      CGE_VIDEO_FORMAT_BGR4,
34      CGE_VIDEO_FORMAT_BGR4_BYTE,
35      CGE_VIDEO_FORMAT_RGB8,
36      CGE_VIDEO_FORMAT_RGB4,
37      CGE_VIDEO_FORMAT_RGB4_BYTE,
38      CGE_VIDEO_FORMAT_NV12,
39      CGE_VIDEO_FORMAT_NV21,
40      CGE_VIDEO_FORMAT_ARGB,
41      CGE_VIDEO_FORMAT_RGBA,
42      CGE_VIDEO_FORMAT_ABGR,
43      CGE_VIDEO_FORMAT_BGRA,
44      CGE_VIDEO_FORMAT_GRAY16BE,
45      CGE_VIDEO_FORMAT_GRAY16LE,
46      CGE_VIDEO_FORMAT_YUV440P,
47      CGE_VIDEO_FORMAT_YUVJ440P,
48      CGE_VIDEO_FORMAT_YUVA420P,
49      CGE_VIDEO_FORMAT_VDPAU_H264,
50      CGE_VIDEO_FORMAT_VDPAU_MPEG1,
51      CGE_VIDEO_FORMAT_VDPAU_MPEG2,
52      CGE_VIDEO_FORMAT_VDPAU_WMV3,
53      CGE_VIDEO_FORMAT_VDPAU_VC1,
54      CGE_VIDEO_FORMAT_RGB48BE,
55      CGE_VIDEO_FORMAT_RGB48LE,
56      CGE_VIDEO_FORMAT_RGB565BE,
57      CGE_VIDEO_FORMAT_RGB565LE,
58      CGE_VIDEO_FORMAT_RGB555BE,
59      CGE_VIDEO_FORMAT_RGB555LE,
60      CGE_VIDEO_FORMAT_BGR565BE,
61      CGE_VIDEO_FORMAT_BGR565LE,
62      CGE_VIDEO_FORMAT_BGR555BE,
63      CGE_VIDEO_FORMAT_BGR555LE,
64      CGE_VIDEO_FORMAT_VAAPI_MOCO,
65      CGE_VIDEO_FORMAT_VAAPI_IDCT,
66      CGE_VIDEO_FORMAT_VAAPI_VLD,
67      CGE_VIDEO_FORMAT_YUV420P16LE,
68      CGE_VIDEO_FORMAT_YUV420P16BE,
69      CGE_VIDEO_FORMAT_YUV422P16LE,
70      CGE_VIDEO_FORMAT_YUV422P16BE,
71      CGE_VIDEO_FORMAT_YUV444P16LE,
72      CGE_VIDEO_FORMAT_YUV444P16BE,
73      CGE_VIDEO_FORMAT_VDPAU_MPEG4,
74      CGE_VIDEO_FORMAT_DXVA2_VLD,
75      CGE_VIDEO_FORMAT_RGB444LE,
76      CGE_VIDEO_FORMAT_RGB444BE,
77      CGE_VIDEO_FORMAT_BGR444LE,
78      CGE_VIDEO_FORMAT_BGR444BE,
79      CGE_VIDEO_FORMAT_YA8,
80      CGE_VIDEO_FORMAT_Y400A = CGE_VIDEO_FORMAT_YA8,
81      CGE_VIDEO_FORMAT_GRAY8A = CGE_VIDEO_FORMAT_YA8,
82      CGE_VIDEO_FORMAT_BGR48BE,
83      CGE_VIDEO_FORMAT_BGR48LE,
84      CGE_VIDEO_FORMAT_YUV420P9BE,
85      CGE_VIDEO_FORMAT_YUV420P9LE,
86      CGE_VIDEO_FORMAT_YUV420P10BE,
87      CGE_VIDEO_FORMAT_YUV420P10LE,
88      CGE_VIDEO_FORMAT_YUV422P10BE,
89      CGE_VIDEO_FORMAT_YUV422P10LE,
90      CGE_VIDEO_FORMAT_YUV444P9BE,
91      CGE_VIDEO_FORMAT_YUV444P9LE,
92      CGE_VIDEO_FORMAT_YUV444P10BE,
93      CGE_VIDEO_FORMAT_YUV444P10LE,
94      CGE_VIDEO_FORMAT_YUV422P9BE,
95      CGE_VIDEO_FORMAT_YUV422P9LE,
96      CGE_VIDEO_FORMAT_VDA_VLD,
97      CGE_VIDEO_FORMAT_RGBA64BE,
98      CGE_VIDEO_FORMAT_RGBA64LE,
99      CGE_VIDEO_FORMAT_BGRA64BE,
100      CGE_VIDEO_FORMAT_BGRA64LE,
101      CGE_VIDEO_FORMAT_GBRP,
102      CGE_VIDEO_FORMAT_GBRP9BE,
103      CGE_VIDEO_FORMAT_GBRP9LE,
104      CGE_VIDEO_FORMAT_GBRP10BE,
105      CGE_VIDEO_FORMAT_GBRP10LE,
106      CGE_VIDEO_FORMAT_GBRP16BE,
107      CGE_VIDEO_FORMAT_GBRP16LE,
108      CGE_VIDEO_FORMAT_YUVA422P_LIBAV,
109      CGE_VIDEO_FORMAT_YUVA444P_LIBAV,
110      CGE_VIDEO_FORMAT_YUVA420P9BE,
111      CGE_VIDEO_FORMAT_YUVA420P9LE,
112      CGE_VIDEO_FORMAT_YUVA422P9BE,
113      CGE_VIDEO_FORMAT_YUVA422P9LE,
114      CGE_VIDEO_FORMAT_YUVA444P9BE,
115      CGE_VIDEO_FORMAT_YUVA444P9LE,
116      CGE_VIDEO_FORMAT_YUVA420P10BE,
117      CGE_VIDEO_FORMAT_YUVA420P10LE,
118      CGE_VIDEO_FORMAT_YUVA422P10BE,
119      CGE_VIDEO_FORMAT_YUVA422P10LE,
120      CGE_VIDEO_FORMAT_YUVA444P10BE,
121      CGE_VIDEO_FORMAT_YUVA444P10LE,
122      CGE_VIDEO_FORMAT_YUVA420P16BE,
123      CGE_VIDEO_FORMAT_YUVA420P16LE,
124      CGE_VIDEO_FORMAT_YUVA422P16BE,
125      CGE_VIDEO_FORMAT_YUVA422P16LE,
126      CGE_VIDEO_FORMAT_YUVA444P16BE,
127      CGE_VIDEO_FORMAT_YUVA444P16LE,
128      CGE_VIDEO_FORMAT_VDPAU,
129      CGE_VIDEO_FORMAT_XYZ12LE,
130      CGE_VIDEO_FORMAT_XYZ12BE,
131      CGE_VIDEO_FORMAT_NV16,
132      CGE_VIDEO_FORMAT_NV20LE,
133      CGE_VIDEO_FORMAT_NV20BE,
134      CGE_VIDEO_FORMAT_RGBA64BE_LIBAV,
135      CGE_VIDEO_FORMAT_RGBA64LE_LIBAV,
136      CGE_VIDEO_FORMAT_BGRA64BE_LIBAV,
137      CGE_VIDEO_FORMAT_BGRA64LE_LIBAV,
138      CGE_VIDEO_FORMAT_YVYU422,
139      CGE_VIDEO_FORMAT_VDA,
140      CGE_VIDEO_FORMAT_YA16BE,
141      CGE_VIDEO_FORMAT_YA16LE,
142  };
143  enum CGESampleFormat
144  {
145      CGE_SAMPLE_FMT_NONE = -1,
146      CGE_SAMPLE_FMT_U8,  
147      CGE_SAMPLE_FMT_S16, 
148      CGE_SAMPLE_FMT_S32, 
149      CGE_SAMPLE_FMT_FLT, 
150      CGE_SAMPLE_FMT_DBL, 
151      CGE_SAMPLE_FMT_U8P,  
152      CGE_SAMPLE_FMT_S16P, 
153      CGE_SAMPLE_FMT_S32P, 
154      CGE_SAMPLE_FMT_FLTP, 
155      CGE_SAMPLE_FMT_DBLP, 
156      CGE_SAMPLE_FMT_NB 
157  };
158  struct CGEVideoFrameBufferData
159  {
160      const unsigned char* data[8]; 
161      int linesize[8];
162      double timestamp;
163      int width;
164      int height;
165      CGEVideoFormat format;
166  };
167  struct CGEAudioFrameBufferData
168  {
169      double timestamp;
170      const unsigned char* data; 
171      int nbSamples;             
172      int bytesPerSample;        
173      int channels;              
174      int linesize;              
175      CGESampleFormat format;
176  };
177  enum CGEFrameTypeNext
178  {
179      FrameType_NoFrame,
180      FrameType_VideoFrame,
181      FrameType_AudioFrame
182  };
183  class CGEVideoDecodeHandler
184  {
185  public:
186      CGEVideoDecodeHandler();
187      ~CGEVideoDecodeHandler();
188      enum SamplingStyle
189      {
<span onclick='openModal()' class='match'>190          ssFastBilinear = 1,
191          ssBilinear = 2,
192          ssBicubic = 4,
193          ssX = 8,
194          ssPoint = 0x10,
195          ssArea = 0x20,
196          ssBicublin = 0x40,
197          ssGauss = 0x80,
198          ssSinc = 0x100,
199          ssLanczos = 0x200,
</span>200          ssSpline = 0x400
201      };
202      bool initFrameRGB();
203      bool open(const char* filename);
204      void close();
205      void start();
206      void end();
207      CGEFrameTypeNext queryNextFrame();
208      const CGEVideoFrameBufferData* getNextVideoFrame();    
209      const CGEVideoFrameBufferData* getCurrentVideoFrame(); 
210      AVFrame* getCurrentVideoAVFrame();
211      const CGEAudioFrameBufferData* getNextAudio();
212      const CGEAudioFrameBufferData* getCurrentAudioFrame();
213      AVFrame* getCurrentAudioAVFrame();
214      CGEVideoFrameBufferData getNextVideoFrameRGB();    
215      CGEVideoFrameBufferData getCurrentVideoFrameRGB(); 
216      void setSamplingStyle(SamplingStyle style) { m_samplingStyle = style; }
217      int getWidth() { return m_width; }
218      int getHeight() { return m_height; }
219      double getTotalTime();
220      double getCurrentTimestamp();
221      int getAudioSampleRate();
222      AVDictionary* getOptions();
223      const char* getRotation();
224  protected:
225      CGEVideoDecodeContext* m_context;
226      int m_width, m_height;
227      SamplingStyle m_samplingStyle;
228      CGEVideoFrameBufferData m_cachedVideoFrame;
229      CGEAudioFrameBufferData m_cachedAudioFrame;
230      double m_currentTimestamp;
231  private:
232      unsigned char* m_bufferPtr; 
233      const char* extractMetadataInternal(const char* key);
234  };
235  } 
236  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lzf_c.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/win32_types.h"
4  #endif
5  #include "lzfP.h"
6  #define HSIZE (1 << (HLOG))
7  #ifndef FRST
8  # define FRST(p) (((p[0]) << 8) | p[1])
9  # define NEXT(v,p) (((v) << 8) | p[2])
10  # if ULTRA_FAST
11  #  define IDX(h) ((( h             >> (3*8 - HLOG)) - h  ) & (HSIZE - 1))
12  # elif VERY_FAST
13  #  define IDX(h) ((( h             >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))
14  # else
15  #  define IDX(h) ((((h ^ (h << 5)) >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))
16  # endif
17  #endif
18  #if 0
19  # define FRST(p) (p[0] << 5) ^ p[1]
20  # define NEXT(v,p) ((v) << 5) ^ p[2]
21  # define IDX(h) ((h) & (HSIZE - 1))
22  #endif
23  #define        MAX_LIT        (1 <<  5)
24  #define        MAX_OFF        (1 << 13)
25  #define        MAX_REF        ((1 << 8) + (1 << 3))
26  #if __GNUC__ >= 3
27  # define expect(expr,value)         __builtin_expect ((expr),(value))
28  # define inline                     inline
29  #else
30  # define expect(expr,value)         (expr)
31  POSIX_ONLY(# define inline                     static)
32  #endif
33  #define expect_false(expr) expect ((expr) != 0, 0)
34  #define expect_true(expr)  expect ((expr) != 0, 1)
35  unsigned int
36  lzf_compress (const void *const in_data, unsigned int in_len,
37  	      void *out_data, unsigned int out_len
38  #if LZF_STATE_ARG
39                , LZF_STATE htab
40  #endif
41                )
42  {
43  #if !LZF_STATE_ARG
44    LZF_STATE htab;
45  #endif
46    const u8 *ip = (const u8 *)in_data;
47          u8 *op = (u8 *)out_data;
48    const u8 *in_end  = ip + in_len;
49          u8 *out_end = op + out_len;
50    const u8 *ref;
51  #if defined (WIN32) && defined (_M_X64)
52    unsigned _int64 off; &bsol;* workaround for missing POSIX compliance */
53  #else
54    PORT_ULONG off;
55  #endif
56    unsigned int hval;
57    int lit;
58    if (!in_len || !out_len)
59      return 0;
60  #if INIT_HTAB
61    memset (htab, 0, sizeof (htab));
62  #endif
63    lit = 0; op++; &bsol;* start run */
64    hval = FRST (ip);
65    while (ip < in_end - 2)
66      {
67        LZF_HSLOT *hslot;
68        hval = NEXT (hval, ip);
69        hslot = htab + IDX (hval);
70        ref = *hslot + LZF_HSLOT_BIAS; *hslot = ip - LZF_HSLOT_BIAS;
71        if (1
72  #if INIT_HTAB
73            && ref < ip &bsol;* the next test will actually take care of this, but this is faster */
74  #endif
75            && (off = ip - ref - 1) < MAX_OFF
76            && ref > (u8 *)in_data
77            && ref[2] == ip[2]
78  #if STRICT_ALIGN
79            && ((ref[1] << 8) | ref[0]) == ((ip[1] << 8) | ip[0])
80  #else
81            && *(u16 *)ref == *(u16 *)ip
82  #endif
83          )
84          {
85            unsigned int len = 2;
86            unsigned int maxlen = (unsigned int)(in_end - ip - len);              WIN_PORT_FIX &bsol;* cast (unsigned int) */
87            maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;
88            if (expect_false (op + 3 + 1 >= out_end)) &bsol;* first a faster conservative test */
89              if (op - !lit + 3 + 1 >= out_end) &bsol;* second the exact but rare test */
90                return 0;
91            op [- lit - 1] = lit - 1; &bsol;* stop run */
92            op -= !lit; &bsol;* undo run if length is zero */
93            for (;;)
94              {
95                if (expect_true (maxlen > 16))
96                  {
97                    len++; if (ref [len] != ip [len]) break;
98                    len++; if (ref [len] != ip [len]) break;
99                    len++; if (ref [len] != ip [len]) break;
100                    len++; if (ref [len] != ip [len]) break;
101                    len++; if (ref [len] != ip [len]) break;
102                    len++; if (ref [len] != ip [len]) break;
103                    len++; if (ref [len] != ip [len]) break;
104                    len++; if (ref [len] != ip [len]) break;
105                    len++; if (ref [len] != ip [len]) break;
106                    len++; if (ref [len] != ip [len]) break;
107                    len++; if (ref [len] != ip [len]) break;
108                    len++; if (ref [len] != ip [len]) break;
109                    len++; if (ref [len] != ip [len]) break;
110                    len++; if (ref [len] != ip [len]) break;
111                    len++; if (ref [len] != ip [len]) break;
112                    len++; if (ref [len] != ip [len]) break;
113                  }
114                do
115                  len++;
116                while (len < maxlen && ref[len] == ip[len]);
117                break;
118              }
119            len -= 2; &bsol;* len is now #octets - 1 */
120            ip++;
121            if (len < 7)
122              {
123                *op++ = (u8)((off >> 8) + (len << 5));                            WIN_PORT_FIX &bsol;* cast (u8) */
124              }
125            else
126              {
127                *op++ = (u8)((off >> 8) + (  7 << 5));                            WIN_PORT_FIX &bsol;* cast (u8) */
128                *op++ = len - 7;
129              }
130            *op++ = (u8)(off);                                                    WIN_PORT_FIX &bsol;* cast (u8) */
131            lit = 0; op++; &bsol;* start run */
132            ip += len + 1;
133            if (expect_false (ip >= in_end - 2))
134              break;
135  #if ULTRA_FAST || VERY_FAST
<span onclick='openModal()' class='match'>136            --ip;
137  # if VERY_FAST && !ULTRA_FAST
138            --ip;
139  # endif
140            hval = FRST (ip);
141            hval = NEXT (hval, ip);
142            htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
143            ip++;
144  # if VERY_FAST && !ULTRA_FAST
145            hval = NEXT (hval, ip);
146            htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
147            ip++;
148  # endif
149  #else
150            ip -= len + 1;
</span>151            do
152              {
153                hval = NEXT (hval, ip);
154                htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
155                ip++;
156              }
157            while (len--);
158  #endif
159          }
160        else
161          {
162            if (expect_false (op >= out_end))
163              return 0;
164            lit++; *op++ = *ip++;
165            if (expect_false (lit == MAX_LIT))
166              {
167                op [- lit - 1] = lit - 1; &bsol;* stop run */
168                lit = 0; op++; &bsol;* start run */
169              }
170          }
171      }
172    if (op + 3 > out_end) &bsol;* at most 3 bytes can be missing here */
173      return 0;
174    while (ip < in_end)
175      {
176        lit++; *op++ = *ip++;
177        if (expect_false (lit == MAX_LIT))
178          {
179            op [- lit - 1] = lit - 1; &bsol;* stop run */
180            lit = 0; op++; &bsol;* start run */
181          }
182      }
183    op [- lit - 1] = lit - 1; &bsol;* end run */
184    op -= !lit; &bsol;* undo run if length is zero */
185    return (unsigned int)(op - (u8 *)out_data);                                   WIN_PORT_FIX &bsol;* cast (unsigned int) */
186  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeVideoDecoder.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lzf_c.c</div>
                <div class="column column_space"><pre><code>190          ssFastBilinear = 1,
191          ssBilinear = 2,
192          ssBicubic = 4,
193          ssX = 8,
194          ssPoint = 0x10,
195          ssArea = 0x20,
196          ssBicublin = 0x40,
197          ssGauss = 0x80,
198          ssSinc = 0x100,
199          ssLanczos = 0x200,
</pre></code></div>
                <div class="column column_space"><pre><code>136            --ip;
137  # if VERY_FAST && !ULTRA_FAST
138            --ip;
139  # endif
140            hval = FRST (ip);
141            hval = NEXT (hval, ip);
142            htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
143            ip++;
144  # if VERY_FAST && !ULTRA_FAST
145            hval = NEXT (hval, ip);
146            htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
147            ip++;
148  # endif
149  #else
150            ip -= len + 1;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    