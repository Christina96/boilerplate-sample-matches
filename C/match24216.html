<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ifthenelse.c &amp; heifsave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ifthenelse.c &amp; heifsave.c
      </h3>
<h1 align="center">
        4.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ifthenelse.c (5.0898204%)<th>heifsave.c (4.4736843%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(457-479)<td><a href="#" name="0">(589-608)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ifthenelse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #include &lt;vips/debug.h&gt;
10 #include "pconversion.h"
11 typedef struct _VipsIfthenelse {
12 	VipsConversion parent_instance;
13 	VipsImage *cond;
14 	VipsImage *in1;
15 	VipsImage *in2;
16 	gboolean blend;
17 } VipsIfthenelse;
18 typedef VipsConversionClass VipsIfthenelseClass;
19 G_DEFINE_TYPE( VipsIfthenelse, vips_ifthenelse, VIPS_TYPE_CONVERSION );
20 #define IBLEND1( TYPE ) { \
21 	TYPE *a = (TYPE *) ap; \
22 	TYPE *b = (TYPE *) bp; \
23 	TYPE *q = (TYPE *) qp; \
24  	\
25 	for( i = 0, x = 0; x &lt; n; i++, x += bands ) { \
26 		const int v = c[i]; \
27  		\
28 		for( z = x; z &lt; x + bands; z++ )  \
29 			q[z] = (v * a[z] + (255 - v) * b[z] + 128) / 255; \
30 	} \
31 }
32 #define IBLENDN( TYPE ) { \
33 	TYPE *a = (TYPE *) ap; \
34 	TYPE *b = (TYPE *) bp; \
35 	TYPE *q = (TYPE *) qp; \
36  	\
37 	for( x = 0; x &lt; n; x += bands ) { \
38 		for( z = x; z &lt; x + bands; z++ ) { \
39 			const int v = c[z]; \
40  			\
41 			q[z] = (v * a[z] + (255 - v) * b[z] + 128) / 255; \
42 		} \
43 	} \
44 }
45 #define FBLEND1( TYPE ) { \
46 	TYPE *a = (TYPE *) ap; \
47 	TYPE *b = (TYPE *) bp; \
48 	TYPE *q = (TYPE *) qp; \
49  	\
50 	for( i = 0, x = 0; x &lt; n; i++, x += bands ) { \
51 		const double v = c[i] / 255.0; \
52  		\
53 		for( z = x; z &lt; x + bands; z++ )  \
54 			q[z] = v * a[z] + (1.0 - v) * b[z]; \
55 	} \
56 }
57 #define FBLENDN( TYPE ) { \
58 	TYPE *a = (TYPE *) ap; \
59 	TYPE *b = (TYPE *) bp; \
60 	TYPE *q = (TYPE *) qp; \
61  	\
62 	for( x = 0; x &lt; n; x += bands ) { \
63 		for( z = x; z &lt; x + bands; z++ ) { \
64 			const double v = c[z] / 255.0; \
65  			\
66 			q[z] = v * a[z] + (1.0 - v) * b[z]; \
67 		} \
68 	} \
69 }
70 #define CBLEND1( TYPE ) { \
71 	TYPE *a = (TYPE *) ap; \
72 	TYPE *b = (TYPE *) bp; \
73 	TYPE *q = (TYPE *) qp; \
74  	\
75 	for( i = 0, x = 0; x &lt; n; i++, x += bands ) { \
76 		const double v = c[i] / 255.0; \
77  		\
78 		for( z = x; z &lt; x + 2 * bands; z++ )  \
79 			q[z] = v * a[z] + (1.0 - v) * b[z]; \
80 	} \
81 }
82 #define CBLENDN( TYPE ) { \
83 	TYPE *a = (TYPE *) ap; \
84 	TYPE *b = (TYPE *) bp; \
85 	TYPE *q = (TYPE *) qp; \
86  	\
87 	for( x = 0; x &lt; n; x += bands ) { \
88 		for( z = x; z &lt; x + bands; z++ ) { \
89 			const double v = c[z] / 255.0; \
90  			\
91 			q[2 * z] = v * a[2 * z] + (1.0 - v) * b[2 * z]; \
92 			q[2 * z + 1] = v * a[2 * z + 1] + \
93 				(1.0 - v) * b[2 * z + 1]; \
94 		} \
95 	} \
96 }
97 static void
98 vips_blend1_buffer( VipsPel *qp, 
99 	VipsPel *c, VipsPel *ap, VipsPel *bp, int width, 
100 	VipsImage *im )
101 {
102 	int i, x, z;
103 	const int bands = im-&gt;Bands;
104 	const int n = width * bands;
105 	switch( im-&gt;BandFmt ) {
106 	case VIPS_FORMAT_UCHAR: 	IBLEND1( unsigned char ); break;
107 	case VIPS_FORMAT_CHAR: 		IBLEND1( signed char ); break;
108 	case VIPS_FORMAT_USHORT: 	IBLEND1( unsigned short ); break;
109 	case VIPS_FORMAT_SHORT: 	IBLEND1( signed short ); break;
110 	case VIPS_FORMAT_UINT: 		IBLEND1( unsigned int ); break;
111 	case VIPS_FORMAT_INT: 		IBLEND1( signed int );  break;
112 	case VIPS_FORMAT_FLOAT: 	FBLEND1( float ); break;
113 	case VIPS_FORMAT_DOUBLE: 	FBLEND1( double ); break;
114 	case VIPS_FORMAT_COMPLEX: 	CBLEND1( float ); break;
115 	case VIPS_FORMAT_DPCOMPLEX: 	CBLEND1( double ); break;
116 	default:
117 		g_assert_not_reached();
118 	}
119 }
120 static void
121 vips_blendn_buffer( VipsPel *qp, 
122 	VipsPel *c, VipsPel *ap, VipsPel *bp, int width, 
123 	VipsImage *im )
124 {
125 	int x, z;
126 	const int bands = im-&gt;Bands;
127 	const int n = width * bands;
128 	switch( im-&gt;BandFmt ) {
129 	case VIPS_FORMAT_UCHAR: 	IBLENDN( unsigned char ); break;
130 	case VIPS_FORMAT_CHAR: 		IBLENDN( signed char ); break;
131 	case VIPS_FORMAT_USHORT: 	IBLENDN( unsigned short ); break;
132 	case VIPS_FORMAT_SHORT: 	IBLENDN( signed short ); break;
133 	case VIPS_FORMAT_UINT: 		IBLENDN( unsigned int ); break;
134 	case VIPS_FORMAT_INT: 		IBLENDN( signed int );  break;
135 	case VIPS_FORMAT_FLOAT: 	FBLENDN( float ); break;
136 	case VIPS_FORMAT_DOUBLE: 	FBLENDN( double ); break;
137 	case VIPS_FORMAT_COMPLEX: 	CBLENDN( float ); break;
138 	case VIPS_FORMAT_DPCOMPLEX: 	CBLENDN( double ); break;
139 	default:
140 		g_assert_not_reached();
141 	}
142 }
143 static int
144 vips_blend_gen( VipsRegion *or, void *seq, void *client1, void *client2,
145 	gboolean *stop )
146 {
147 	VipsRegion **ir = (VipsRegion **) seq;
148 	VipsRect *r = &amp;or-&gt;valid;
149 	int le = r-&gt;left;
150 	int to = r-&gt;top;
151 	int bo = VIPS_RECT_BOTTOM( r );
152 	VipsImage *c = ir[2]-&gt;im;
153 	VipsImage *a = ir[0]-&gt;im;
154 	int x, y;
155 	int all0, all255;
156 	if( vips_region_prepare( ir[2], r ) )
157 		return( -1 );
158 	all0 = *VIPS_REGION_ADDR( ir[2], le, to ) == 0;
159 	all255 = *VIPS_REGION_ADDR( ir[2], le, to ) == 255;
160 	for( y = to; y &lt; bo; y++ ) {
161 		VipsPel *p = VIPS_REGION_ADDR( ir[2], le, y );
162 		int width = r-&gt;width * c-&gt;Bands;
163 		for( x = 0; x &lt; width; x++ ) {
164 			all0 &amp;= p[x] == 0;
165 			all255 &amp;= p[x] == 255;
166 		}
167 		if( !all0 &amp;&amp; !all255 )
168 			break;
169 	}
170 	if( all255 ) {
171 		if( vips_region_prepare( ir[0], r ) ||
172 			vips_region_region( or, ir[0], r, r-&gt;left, r-&gt;top ) )
173 			return( -1 );
174 	}
175 	else if( all0 ) {
176 		if( vips_region_prepare( ir[1], r ) ||
177 			vips_region_region( or, ir[1], r, r-&gt;left, r-&gt;top ) )
178 			return( -1 );
179 	}
180 	else {
181 		if( vips_region_prepare( ir[0], r ) || 
182 			vips_region_prepare( ir[1], r ) ) 
183 			return( -1 );
184 		for( y = to; y &lt; bo; y++ ) {
185 			VipsPel *ap = VIPS_REGION_ADDR( ir[0], le, y );
186 			VipsPel *bp = VIPS_REGION_ADDR( ir[1], le, y );
187 			VipsPel *cp = VIPS_REGION_ADDR( ir[2], le, y );
188 			VipsPel *q = VIPS_REGION_ADDR( or, le, y );
189 			if( c-&gt;Bands == 1 ) 
190 				vips_blend1_buffer( q, cp, ap, bp, 
191 					r-&gt;width, a );
192 			else
193 				vips_blendn_buffer( q, cp, ap, bp, 
194 					r-&gt;width, a );
195 		}
196 	}
197 	return( 0 );
198 }
199 static int
200 vips_ifthenelse_gen( VipsRegion *or, void *seq, void *client1, void *client2,
201 	gboolean *stop )
202 {
203 	VipsRegion **ir = (VipsRegion **) seq;
204 	VipsRect *r = &amp;or-&gt;valid;
205 	int le = r-&gt;left;
206 	int to = r-&gt;top;
207 	int bo = VIPS_RECT_BOTTOM( r );
208 	VipsImage *c = ir[2]-&gt;im;
209 	VipsImage *a = ir[0]-&gt;im;
210 	int size, width;
211 	int i, x, y, z;
212 	int all0, alln0;
213 	if( c-&gt;Bands == 1 ) {
214 		size = VIPS_IMAGE_SIZEOF_PEL( a );
215 		width = r-&gt;width;
216 	}
217 	else {
218 		size = VIPS_IMAGE_SIZEOF_ELEMENT( a );
219 		width = r-&gt;width * a-&gt;Bands;
220 	}
221 	if( vips_region_prepare( ir[2], r ) )
222 		return( -1 );
223 	all0 = *VIPS_REGION_ADDR( ir[2], le, to ) == 0;
224 	alln0 = *VIPS_REGION_ADDR( ir[2], le, to ) != 0;
225 	for( y = to; y &lt; bo; y++ ) {
226 		VipsPel *p = VIPS_REGION_ADDR( ir[2], le, y );
227 		for( x = 0; x &lt; width; x++ ) {
228 			all0 &amp;= p[x] == 0;
229 			alln0 &amp;= p[x] != 0;
230 		}
231 		if( !all0 &amp;&amp; !alln0 )
232 			break;
233 	}
234 	if( alln0 ) {
235 		if( vips_region_prepare( ir[0], r ) ||
236 			vips_region_region( or, ir[0], r, r-&gt;left, r-&gt;top ) )
237 			return( -1 );
238 	}
239 	else if( all0 ) {
240 		if( vips_region_prepare( ir[1], r ) ||
241 			vips_region_region( or, ir[1], r, r-&gt;left, r-&gt;top ) )
242 			return( -1 );
243 	}
244 	else {
245 		if( vips_region_prepare( ir[0], r ) || 
246 			vips_region_prepare( ir[1], r ) ) 
247 			return( -1 );
248 		for( y = to; y &lt; bo; y++ ) {
249 			VipsPel *ap = VIPS_REGION_ADDR( ir[0], le, y );
250 			VipsPel *bp = VIPS_REGION_ADDR( ir[1], le, y );
251 			VipsPel *cp = VIPS_REGION_ADDR( ir[2], le, y );
252 			VipsPel *q = VIPS_REGION_ADDR( or, le, y );
253 			for( x = 0, i = 0; i &lt; width; i++, x += size ) 
254 				if( cp[i] )
255 					for( z = x; z &lt; x + size; z++ )
256 						q[z] = ap[z];
257 				else
258 					for( z = x; z &lt; x + size; z++ )
259 						q[z] = bp[z];
260 		}
261 	}
262 	return( 0 );
263 }
264 static int
265 vips_ifthenelse_build( VipsObject *object )
266 {
267 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
268 	VipsConversion *conversion = VIPS_CONVERSION( object );
269 	VipsIfthenelse *ifthenelse = (VipsIfthenelse *) object;
270 	VipsGenerateFn generate_fn = ifthenelse-&gt;blend ? 
271 		vips_blend_gen : vips_ifthenelse_gen;
272 	VipsImage **band = (VipsImage **) vips_object_local_array( object, 3 );
273 	VipsImage **size = (VipsImage **) vips_object_local_array( object, 3 );
274 	VipsImage **format = 
275 		(VipsImage **) vips_object_local_array( object, 3 );
276 	VipsImage *all[3];
277 	if( VIPS_OBJECT_CLASS( vips_ifthenelse_parent_class )-&gt;build( object ) )
278 		return( -1 );
279 	all[0] = ifthenelse-&gt;in1;
280 	all[1] = ifthenelse-&gt;in2;
281 	all[2] = ifthenelse-&gt;cond;
282 	if( vips__bandalike_vec( class-&gt;nickname, all, band, 3, 0 ) ||
283 		vips__sizealike_vec( band, size, 3 ) )
284 		return( -1 );
285 	if( size[2]-&gt;BandFmt != VIPS_FORMAT_UCHAR ) { 
286 		if( vips_cast( size[2], &amp;format[2], VIPS_FORMAT_UCHAR, NULL ) )
287 			return( -1 );
288 	}
289 	else {
290 		format[2] = size[2];
291 		g_object_ref( format[2] ); 
292 	}
293 	if( vips__formatalike_vec( size, format, 2 ) ) 
294 		return( -1 ); 
295 <a name="0"></a>
296 	if( vips_image_pipeline_array( conversion-&gt;out, 
297 		VIPS_DEMAND_STYLE_SMALLTILE, format ) )
298 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );
299 	if( vips_image_generate( conversion-&gt;out,
300 		vips_start_many, generate_fn, vips_stop_many, 
301 		format, ifthenelse ) )
302 		return( -1 );
303 	return( 0 );
304 }
305 static void
306 vips_ifthenelse_class_init( VipsIfthenelseClass *class )
307 {
308 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
309 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
310 	VIPS_DEBUG_MSG( "vips_ifthenelse_class_init\n" );
311 	gobject_class-&gt;set_property = vips_object_set_property;
312 	gobject_class-&gt;get_property = vips_object_get_property;
313 	vobject_class-&gt;nickname = "ifthenelse";
314 	vobject_class-&gt;description = _( "ifthenelse an image" );</b></font>
315 	vobject_class-&gt;build = vips_ifthenelse_build;
316 	VIPS_ARG_IMAGE( class, "cond", -2, 
317 		_( "Condition" ), 
318 		_( "Condition input image" ),
319 		VIPS_ARGUMENT_REQUIRED_INPUT,
320 		G_STRUCT_OFFSET( VipsIfthenelse, cond ) );
321 	VIPS_ARG_IMAGE( class, "in1", -1, 
322 		_( "Then image" ), 
323 		_( "Source for TRUE pixels" ),
324 		VIPS_ARGUMENT_REQUIRED_INPUT,
325 		G_STRUCT_OFFSET( VipsIfthenelse, in1 ) );
326 	VIPS_ARG_IMAGE( class, "in2", 0, 
327 		_( "Else image" ), 
328 		_( "Source for FALSE pixels" ),
329 		VIPS_ARGUMENT_REQUIRED_INPUT,
330 		G_STRUCT_OFFSET( VipsIfthenelse, in2 ) );
331 	VIPS_ARG_BOOL( class, "blend", 4, 
332 		_( "blend" ), 
333 		_( "Blend smoothly between then and else parts" ),
334 		VIPS_ARGUMENT_OPTIONAL_INPUT,
335 		G_STRUCT_OFFSET( VipsIfthenelse, blend ),
336 		FALSE );
337 }
338 static void
339 vips_ifthenelse_init( VipsIfthenelse *ifthenelse )
340 {
341 }
342 int
343 vips_ifthenelse( VipsImage *cond, VipsImage *in1, VipsImage *in2, 
344 	VipsImage **out, ... )
345 {
346 	va_list ap;
347 	int result;
348 	va_start( ap, out );
349 	result = vips_call_split( "ifthenelse", ap, cond, in1, in2, out );
350 	va_end( ap );
351 	return( result );
352 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>heifsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #ifdef HAVE_HEIF_ENCODER
5 #include &lt;stdio.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include "pforeign.h"
11 #include &lt;libheif/heif.h&gt;
12 typedef struct _VipsForeignSaveHeif {
13 	VipsForeignSave parent_object;
14 	VipsTarget *target;
15 	int Q;
16 	gboolean lossless;
17 	VipsForeignHeifCompression compression;
18 	int effort;
19 	VipsForeignSubsample subsample_mode;
20 	VipsImage *image;
21 	int page_width;
22 	int page_height;
23 	int n_pages;
24 	struct heif_context *ctx;
25 	struct heif_encoder *encoder;
26 	struct heif_image_handle *handle;
27 	struct heif_image *img;
28 	uint8_t *data;
29 	int stride;
30 	int speed;
31 } VipsForeignSaveHeif;
32 typedef VipsForeignSaveClass VipsForeignSaveHeifClass;
33 void vips__heif_error( struct heif_error *error );
34 void vips__heif_image_print( struct heif_image *img );
35 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveHeif, vips_foreign_save_heif, 
36 	VIPS_TYPE_FOREIGN_SAVE );
37 static void
38 vips_foreign_save_heif_dispose( GObject *gobject )
39 {
40 	VipsForeignSaveHeif *heif = (VipsForeignSaveHeif *) gobject;
41 	VIPS_UNREF( heif-&gt;target );
42 	VIPS_UNREF( heif-&gt;image );
43 	VIPS_FREEF( heif_image_release, heif-&gt;img );
44 	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
45 	VIPS_FREEF( heif_encoder_release, heif-&gt;encoder );
46 	VIPS_FREEF( heif_context_free, heif-&gt;ctx );
47 	G_OBJECT_CLASS( vips_foreign_save_heif_parent_class )-&gt;
48 		dispose( gobject );
49 }
50 typedef struct heif_error (*libheif_metadata_fn)( struct heif_context *,
51 	 const struct heif_image_handle *,
52 	 const void *, int );
53 struct _VipsForeignSaveHeifMetadata {
54 	const char *name;
55 	libheif_metadata_fn saver;
56 } libheif_metadata[] = {
57 	{ VIPS_META_EXIF_NAME, heif_context_add_exif_metadata },
58 	{ VIPS_META_XMP_NAME, heif_context_add_XMP_metadata }
59 };
60 static int
61 vips_foreign_save_heif_write_metadata( VipsForeignSaveHeif *heif )
62 {
63 	int i;
64 	struct heif_error error;
65 	if( vips_image_get_typeof( heif-&gt;image, VIPS_META_EXIF_NAME ) ) 
66 		if( vips__exif_update( heif-&gt;image ) )
67 			return( -1 );
68 	for( i = 0; i &lt; VIPS_NUMBER( libheif_metadata ); i++ )  
69 		if( vips_image_get_typeof( heif-&gt;image, 
70 			libheif_metadata[i].name ) ) {
71 			const void *data;
72 			size_t length;
73 #ifdef DEBUG
74 			printf( "attaching %s ..\n", 
75 				libheif_metadata[i].name ); 
76 			if( vips_image_get_blob( heif-&gt;image, 
77 				libheif_metadata[i].name, &amp;data, &amp;length ) )
78 				return( -1 );
79 			error = libheif_metadata[i].saver( heif-&gt;ctx, 
80 				heif-&gt;handle, data, length );
81 			if( error.code ) {
82 				vips__heif_error( &amp;error );
83 				return( -1 );
84 			}
85 		}
86 	return( 0 );
87 }
88 static int
89 vips_foreign_save_heif_write_page( VipsForeignSaveHeif *heif, int page )
90 {
91 	VipsForeignSave *save = (VipsForeignSave *) heif;
92 	struct heif_error error;
93 	struct heif_encoding_options *options;
94 #ifdef HAVE_HEIF_COLOR_PROFILE
95 	if( !save-&gt;strip &amp;&amp;
96 		vips_image_get_typeof( heif-&gt;image, VIPS_META_ICC_NAME ) ) {
97 		const void *data;
98 		size_t length;
99 #ifdef DEBUG
100 		printf( "attaching profile ..\n" ); 
101 		if( vips_image_get_blob( heif-&gt;image, 
102 			VIPS_META_ICC_NAME, &amp;data, &amp;length ) )
103 			return( -1 );
104 		error = heif_image_set_raw_color_profile( heif-&gt;img, 
105 			"rICC", data, length );
106 		if( error.code ) {
107 			vips__heif_error( &amp;error );
108 			return( -1 );
109 		}
110 	}
111 	options = heif_encoding_options_alloc();
112 	if( vips_image_hasalpha( heif-&gt;image ) )
113 		options-&gt;save_alpha_channel = 1;
114 #ifdef DEBUG
115 	printf( "encoding ..\n" ); 
116 	error = heif_context_encode_image( heif-&gt;ctx, 
117 		heif-&gt;img, heif-&gt;encoder, options, &amp;heif-&gt;handle );
118 	heif_encoding_options_free( options );
119 	if( error.code ) {
120 		vips__heif_error( &amp;error );
121 		return( -1 );
122 	}
123 	if( vips_image_get_typeof( heif-&gt;image, "heif-primary" ) ) { 
124 		int primary;
125 		if( vips_image_get_int( heif-&gt;image, 
126 			"heif-primary", &amp;primary ) ) 
127 			return( -1 ); 	
128 		if( page == primary ) { 
129 			error = heif_context_set_primary_image( heif-&gt;ctx, 
130 				heif-&gt;handle );
131 			if( error.code ) {
132 				vips__heif_error( &amp;error );
133 				return( -1 );
134 			}
135 		}
136 	}
137 	if( !save-&gt;strip &amp;&amp;
138 		vips_foreign_save_heif_write_metadata( heif ) )
139 		return( -1 );
140 	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
141 	return( 0 );
142 }
143 static int
144 vips_foreign_save_heif_write_block( VipsRegion *region, VipsRect *area, 
145 	void *a )
146 {
147 	VipsForeignSaveHeif *heif = (VipsForeignSaveHeif *) a;
148 	int y;
149 #ifdef DEBUG
150 	printf( "vips_foreign_save_heif_write_block: y = %d\n", area-&gt;top );
151 	for( y = 0; y &lt; area-&gt;height; y++ ) {
152 		int page = (area-&gt;top + y) / heif-&gt;page_height;
153 		int line = (area-&gt;top + y) % heif-&gt;page_height;
154 		VipsPel *p = VIPS_REGION_ADDR( region, 0, area-&gt;top + y );
155 		VipsPel *q = heif-&gt;data + line * heif-&gt;stride;
156 		memcpy( q, p, VIPS_IMAGE_SIZEOF_LINE( region-&gt;im ) );
157 		if( line == heif-&gt;page_height - 1 )
158 			if( vips_foreign_save_heif_write_page( heif, page ) )
159 				return( -1 );
160 	}
161 	return( 0 );
162 }
163 struct heif_error 
164 vips_foreign_save_heif_write( struct heif_context *ctx, 
165 	const void *data, size_t length, void *userdata )
166 {
167 	VipsForeignSaveHeif *heif = (VipsForeignSaveHeif *) userdata;
168 	struct heif_error error;
169 	error.code = 0;
170 	if( vips_target_write( heif-&gt;target, data, length ) )
171 		error.code = -1;
172 	return( error );
173 }
174 static int
175 vips_foreign_save_heif_build( VipsObject *object )
176 {
177 	VipsForeignSave *save = (VipsForeignSave *) object;
178 	VipsForeignSaveHeif *heif = (VipsForeignSaveHeif *) object;
179 	const char *filename;
180 	struct heif_error error;
181 	struct heif_writer writer;
182 	char *chroma;
183 	if( VIPS_OBJECT_CLASS( vips_foreign_save_heif_parent_class )-&gt;
184 		build( object ) )
185 		return( -1 );
186 	if( vips_object_argument_isset( object, "speed" ) &amp;&amp;
187 		!vips_object_argument_isset( object, "effort" ) )
188 		heif-&gt;effort = 9 - heif-&gt;speed;
189 	if( vips_copy( save-&gt;ready, &amp;heif-&gt;image, NULL ) ) 
190 		return( -1 );
191 	filename = vips_connection_filename( VIPS_CONNECTION( heif-&gt;target ) );
192 	if( !vips_object_argument_isset( object, "compression" ) &amp;&amp;
193 		filename &amp;&amp;
194 		vips_iscasepostfix( filename, ".avif" ) )
195 		heif-&gt;compression = VIPS_FOREIGN_HEIF_COMPRESSION_AV1;
196 	error = heif_context_get_encoder_for_format( heif-&gt;ctx, 
197 		(enum heif_compression_format) heif-&gt;compression, 
198 		&amp;heif-&gt;encoder );
199 	if( error.code ) {
200 		if( error.code == heif_error_Unsupported_filetype ) 
201 			vips_error( "heifsave", 
202 				"%s", _( "Unsupported compression" ) );
203 		else 
204 			vips__heif_error( &amp;error );
205 		return( -1 );
206 	}
207 	error = heif_encoder_set_lossy_quality( heif-&gt;encoder, heif-&gt;Q );
208 	if( error.code ) {
209 		vips__heif_error( &amp;error );
210 		return( -1 );
211 	}
212 	error = heif_encoder_set_lossless( heif-&gt;encoder, heif-&gt;lossless );
213 	if( error.code ) {
214 		vips__heif_error( &amp;error );
215 		return( -1 );
216 	}
217 	error = heif_encoder_set_parameter_integer( heif-&gt;encoder,
218 		"speed", 9 - heif-&gt;effort );
219 	if( error.code &amp;&amp;
220 		error.subcode != heif_suberror_Unsupported_parameter ) {
221 		vips__heif_error( &amp;error );
222 		return( -1 );
223 	}
224 	chroma = heif-&gt;subsample_mode == VIPS_FOREIGN_SUBSAMPLE_OFF ||
225 		( heif-&gt;subsample_mode == VIPS_FOREIGN_SUBSAMPLE_AUTO &amp;&amp;
226 			heif-&gt;Q &gt;= 90 ) ? "444" : "420";
227 	error = heif_encoder_set_parameter_string( heif-&gt;encoder,
228 		"chroma", chroma );
229 	if( error.code &amp;&amp;
230 		error.subcode != heif_suberror_Unsupported_parameter ) {
231 		vips__heif_error( &amp;error );
232 		return( -1 );
233 	}
234 	heif-&gt;page_width = heif-&gt;image-&gt;Xsize;
235 	heif-&gt;page_height = vips_image_get_page_height( heif-&gt;image );
236 	heif-&gt;n_pages = heif-&gt;image-&gt;Ysize / heif-&gt;page_height;
237 #ifdef DEBUG
238 	printf( "vips_foreign_save_heif_build:\n" );
239 	printf( "\twidth = %d\n", heif-&gt;page_width );
240 	printf( "\theight = %d\n", heif-&gt;page_height );
241 	printf( "\talpha = %d\n", vips_image_hasalpha( heif-&gt;image ) );
242 	error = heif_image_create( heif-&gt;page_width, heif-&gt;page_height, 
243 		heif_colorspace_RGB, 
244 		vips_image_hasalpha( heif-&gt;image ) ?
245 			heif_chroma_interleaved_RGBA : 
246 			heif_chroma_interleaved_RGB,
247 		&amp;heif-&gt;img );
248 	if( error.code ) {
249 		vips__heif_error( &amp;error );
250 		return( -1 );
251 	}
252 	error = heif_image_add_plane( heif-&gt;img, heif_channel_interleaved, 
253 		heif-&gt;page_width, heif-&gt;page_height, 
254 		vips_image_hasalpha( heif-&gt;image ) ? 32 : 24 );
255 	if( error.code ) {
256 		vips__heif_error( &amp;error );
257 		return( -1 );
258 	}
259 #ifdef DEBUG
260 	vips__heif_image_print( heif-&gt;img );
261 	heif-&gt;data = heif_image_get_plane( heif-&gt;img, 
262 		heif_channel_interleaved, &amp;heif-&gt;stride );
263 	if( vips_sink_disc( heif-&gt;image, 
264 		vips_foreign_save_heif_write_block, heif ) )
265 		return( -1 );
266 	writer.writer_api_version = 1;
267 	writer.write = vips_foreign_save_heif_write;
268 	error = heif_context_write( heif-&gt;ctx, &amp;writer, heif );
269 	if( error.code ) {
270 		vips__heif_error( &amp;error );
271 		return( -1 );
272 	}
273 	vips_target_finish( heif-&gt;target );
274 	return( 0 );
275 }
276 #define UC VIPS_FORMAT_UCHAR
277 static int vips_heif_bandfmt[10] = {
278    UC, UC, UC, UC, UC, UC, UC, UC, UC, UC
279 };
280 static void
281 vips_foreign_save_heif_class_init( VipsForeignSaveHeifClass *class )
282 {
283 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
284 	VipsObjectClass *object_class = (VipsObjectClass *) class;
285 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
286 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
287 	gobject_class-&gt;dispose = vips_foreign_save_heif_dispose;
288 	gobject_class-&gt;set_property = vips_object_set_property;
289 	gobject_class-&gt;get_property = vips_object_get_property;
290 	object_class-&gt;nickname = "heifsave_base";
291 	object_class-&gt;description = _( "save image in HEIF format" );
292 	object_class-&gt;build = vips_foreign_save_heif_build;
293 	foreign_class-&gt;suffs = vips__heif_suffs;
294 	save_class-&gt;saveable = VIPS_SAVEABLE_RGBA_ONLY;
295 	save_class-&gt;format_table = vips_heif_bandfmt;
296 	VIPS_ARG_INT( class, "Q", 10, 
297 		_( "Q" ), 
298 		_( "Q factor" ),
299 		VIPS_ARGUMENT_OPTIONAL_INPUT,
300 		G_STRUCT_OFFSET( VipsForeignSaveHeif, Q ),
301 		1, 100, 50 );
302 	VIPS_ARG_BOOL( class, "lossless", 13,
303 		_( "Lossless" ),
304 		_( "Enable lossless compression" ),
305 		VIPS_ARGUMENT_OPTIONAL_INPUT,
306 		G_STRUCT_OFFSET( VipsForeignSaveHeif, lossless ),
307 		FALSE );
308 	VIPS_ARG_ENUM( class, "compression", 14,
309 		_( "Compression" ),
310 		_( "Compression format" ),
311 		VIPS_ARGUMENT_OPTIONAL_INPUT,
312 		G_STRUCT_OFFSET( VipsForeignSaveHeif, compression ),
313 		VIPS_TYPE_FOREIGN_HEIF_COMPRESSION,
314 		VIPS_FOREIGN_HEIF_COMPRESSION_HEVC );
315 	VIPS_ARG_INT( class, "effort", 15,
316 		_( "Effort" ),
317 		_( "CPU effort" ),
318 		VIPS_ARGUMENT_OPTIONAL_INPUT,
319 		G_STRUCT_OFFSET( VipsForeignSaveHeif, effort ),
320 		0, 9, 4 );
321 	VIPS_ARG_ENUM( class, "subsample_mode", 16,
322 		_( "Subsample mode" ),
323 		_( "Select chroma subsample operation mode" ),
324 		VIPS_ARGUMENT_OPTIONAL_INPUT,
325 		G_STRUCT_OFFSET( VipsForeignSaveHeif, subsample_mode ),
326 		VIPS_TYPE_FOREIGN_SUBSAMPLE,
327 		VIPS_FOREIGN_SUBSAMPLE_AUTO );
328 	VIPS_ARG_INT( class, "speed", 17,
329 		_( "Speed" ),
330 		_( "CPU effort" ),
331 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
332 		G_STRUCT_OFFSET( VipsForeignSaveHeif, speed ),
333 		0, 9, 5 );
334 }
335 static void
336 vips_foreign_save_heif_init( VipsForeignSaveHeif *heif )
337 {
338 	heif-&gt;ctx = heif_context_alloc();
339 	heif-&gt;Q = 50;
340 	heif-&gt;compression = VIPS_FOREIGN_HEIF_COMPRESSION_HEVC;
341 	heif-&gt;effort = 4;
342 	heif-&gt;subsample_mode = VIPS_FOREIGN_SUBSAMPLE_AUTO;
343 	heif-&gt;speed = 5;
344 }
345 typedef struct _VipsForeignSaveHeifFile {
346 	VipsForeignSaveHeif parent_object;
347 	char *filename; 
348 } VipsForeignSaveHeifFile;
349 typedef VipsForeignSaveHeifClass VipsForeignSaveHeifFileClass;
350 G_DEFINE_TYPE( VipsForeignSaveHeifFile, vips_foreign_save_heif_file, 
351 	vips_foreign_save_heif_get_type() );
352 static int
353 vips_foreign_save_heif_file_build( VipsObject *object )
354 {
355 	VipsForeignSaveHeif *heif = (VipsForeignSaveHeif *) object;
356 <a name="0"></a>	VipsForeignSaveHeifFile *file = (VipsForeignSaveHeifFile *) object;
357 	if( !(heif-&gt;target = vips_target_new_to_file( file-&gt;filename )) )
358 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );
359 	if( VIPS_OBJECT_CLASS( vips_foreign_save_heif_file_parent_class )-&gt;
360 		build( object ) )
361 		return( -1 );
362 	return( 0 );
363 }
364 static void
365 vips_foreign_save_heif_file_class_init( VipsForeignSaveHeifFileClass *class )
366 {
367 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
368 	VipsObjectClass *object_class = (VipsObjectClass *) class;
369 	gobject_class-&gt;set_property = vips_object_set_property;
370 	gobject_class-&gt;get_property = vips_object_get_property;
371 	object_class-&gt;nickname = "heifsave";
372 	object_class-&gt;build = vips_foreign_save_heif_file_build;</b></font>
373 	VIPS_ARG_STRING( class, "filename", 1, 
374 		_( "Filename" ),
375 		_( "Filename to save to" ),
376 		VIPS_ARGUMENT_REQUIRED_INPUT, 
377 		G_STRUCT_OFFSET( VipsForeignSaveHeifFile, filename ),
378 		NULL );
379 }
380 static void
381 vips_foreign_save_heif_file_init( VipsForeignSaveHeifFile *file )
382 {
383 }
384 typedef struct _VipsForeignSaveHeifBuffer {
385 	VipsForeignSaveHeif parent_object;
386 	VipsArea *buf;
387 } VipsForeignSaveHeifBuffer;
388 typedef VipsForeignSaveHeifClass VipsForeignSaveHeifBufferClass;
389 G_DEFINE_TYPE( VipsForeignSaveHeifBuffer, vips_foreign_save_heif_buffer, 
390 	vips_foreign_save_heif_get_type() );
391 static int
392 vips_foreign_save_heif_buffer_build( VipsObject *object )
393 {
394 	VipsForeignSaveHeif *heif = (VipsForeignSaveHeif *) object;
395 	VipsForeignSaveHeifBuffer *buffer = 
396 		(VipsForeignSaveHeifBuffer *) object;
397 	VipsBlob *blob;
398 	if( !(heif-&gt;target = vips_target_new_to_memory()) )
399 		return( -1 );
400 	if( VIPS_OBJECT_CLASS( vips_foreign_save_heif_buffer_parent_class )-&gt;
401 		build( object ) )
402 		return( -1 );
403 	g_object_get( heif-&gt;target, "blob", &amp;blob, NULL );
404 	g_object_set( buffer, "buffer", blob, NULL );
405 	vips_area_unref( VIPS_AREA( blob ) );
406 	return( 0 );
407 }
408 static void
409 vips_foreign_save_heif_buffer_class_init( 
410 	VipsForeignSaveHeifBufferClass *class )
411 {
412 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
413 	VipsObjectClass *object_class = (VipsObjectClass *) class;
414 	gobject_class-&gt;set_property = vips_object_set_property;
415 	gobject_class-&gt;get_property = vips_object_get_property;
416 	object_class-&gt;nickname = "heifsave_buffer";
417 	object_class-&gt;build = vips_foreign_save_heif_buffer_build;
418 	VIPS_ARG_BOXED( class, "buffer", 1, 
419 		_( "Buffer" ),
420 		_( "Buffer to save to" ),
421 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
422 		G_STRUCT_OFFSET( VipsForeignSaveHeifBuffer, buf ),
423 		VIPS_TYPE_BLOB );
424 }
425 static void
426 vips_foreign_save_heif_buffer_init( VipsForeignSaveHeifBuffer *buffer )
427 {
428 }
429 typedef struct _VipsForeignSaveHeifTarget {
430 	VipsForeignSaveHeif parent_object;
431 	VipsTarget *target;
432 } VipsForeignSaveHeifTarget;
433 typedef VipsForeignSaveHeifClass VipsForeignSaveHeifTargetClass;
434 G_DEFINE_TYPE( VipsForeignSaveHeifTarget, vips_foreign_save_heif_target, 
435 	vips_foreign_save_heif_get_type() );
436 static int
437 vips_foreign_save_heif_target_build( VipsObject *object )
438 {
439 	VipsForeignSaveHeif *heif = (VipsForeignSaveHeif *) object;
440 	VipsForeignSaveHeifTarget *target = 
441 		(VipsForeignSaveHeifTarget *) object;
442 	if( target-&gt;target ) {
443 		heif-&gt;target = target-&gt;target;
444 		g_object_ref( heif-&gt;target );
445 	}
446 	if( VIPS_OBJECT_CLASS( vips_foreign_save_heif_target_parent_class )-&gt;
447 		build( object ) )
448 		return( -1 );
449 	return( 0 );
450 }
451 static void
452 vips_foreign_save_heif_target_class_init( 
453 	VipsForeignSaveHeifTargetClass *class )
454 {
455 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
456 	VipsObjectClass *object_class = (VipsObjectClass *) class;
457 	gobject_class-&gt;set_property = vips_object_set_property;
458 	gobject_class-&gt;get_property = vips_object_get_property;
459 	object_class-&gt;nickname = "heifsave_target";
460 	object_class-&gt;build = vips_foreign_save_heif_target_build;
461 	VIPS_ARG_OBJECT( class, "target", 1,
462 		_( "Target" ),
463 		_( "Target to save to" ),
464 		VIPS_ARGUMENT_REQUIRED_INPUT, 
465 		G_STRUCT_OFFSET( VipsForeignSaveHeifTarget, target ),
466 		VIPS_TYPE_TARGET );
467 }
468 static void
469 vips_foreign_save_heif_target_init( VipsForeignSaveHeifTarget *target )
470 {
471 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
