
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-upsampling_msa.c</h3>
            <pre><code>1  #include &lt;string.h&gt;
2  #include &quot;src/dsp/dsp.h&quot;
3  #if defined(WEBP_USE_MSA)
4  #include &quot;src/dsp/msa_macro.h&quot;
5  #include &quot;src/dsp/yuv.h&quot;
6  #ifdef FANCY_UPSAMPLING
7  #define ILVR_UW2(in, out0, out1) do {                            \
8    const v8i16 t0 = (v8i16)__msa_ilvr_b((v16i8)zero, (v16i8)in);  \
9    out0 = (v4u32)__msa_ilvr_h((v8i16)zero, t0);                   \
10    out1 = (v4u32)__msa_ilvl_h((v8i16)zero, t0);                   \
11  } while (0)
12  #define ILVRL_UW4(in, out0, out1, out2, out3) do {  \
13    v16u8 t0, t1;                                     \
14    ILVRL_B2_UB(zero, in, t0, t1);                    \
15    ILVRL_H2_UW(zero, t0, out0, out1);                \
16    ILVRL_H2_UW(zero, t1, out2, out3);                \
17  } while (0)
18  #define MULTHI_16(in0, in1, in2, in3, cnst, out0, out1) do {   \
19    const v4i32 const0 = (v4i32)__msa_fill_w(cnst * 256);        \
20    v4u32 temp0, temp1, temp2, temp3;                            \
21    MUL4(in0, const0, in1, const0, in2, const0, in3, const0,     \
22         temp0, temp1, temp2, temp3);                            \
23    PCKOD_H2_UH(temp1, temp0, temp3, temp2, out0, out1);         \
24  } while (0)
25  #define MULTHI_8(in0, in1, cnst, out0) do {                 \
26    const v4i32 const0 = (v4i32)__msa_fill_w(cnst * 256);     \
27    v4u32 temp0, temp1;                                       \
28    MUL2(in0, const0, in1, const0, temp0, temp1);             \
29    out0 = (v8u16)__msa_pckod_h((v8i16)temp1, (v8i16)temp0);  \
30  } while (0)
31  #define CALC_R16(y0, y1, v0, v1, dst) do {                \
32    const v8i16 const_a = (v8i16)__msa_fill_h(14234);       \
33    const v8i16 a0 = __msa_adds_s_h((v8i16)y0, (v8i16)v0);  \
34    const v8i16 a1 = __msa_adds_s_h((v8i16)y1, (v8i16)v1);  \
35    v8i16 b0 = __msa_subs_s_h(a0, const_a);                 \
36    v8i16 b1 = __msa_subs_s_h(a1, const_a);                 \
37    SRAI_H2_SH(b0, b1, 6);                                  \
38    CLIP_SH2_0_255(b0, b1);                                 \
39    dst = (v16u8)__msa_pckev_b((v16i8)b1, (v16i8)b0);       \
40  } while (0)
41  #define CALC_R8(y0, v0, dst) do {                         \
42    const v8i16 const_a = (v8i16)__msa_fill_h(14234);       \
43    const v8i16 a0 = __msa_adds_s_h((v8i16)y0, (v8i16)v0);  \
44    v8i16 b0 = __msa_subs_s_h(a0, const_a);                 \
45    b0 = SRAI_H(b0, 6);                                     \
46    CLIP_SH_0_255(b0);                                      \
47    dst = (v16u8)__msa_pckev_b((v16i8)b0, (v16i8)b0);       \
48  } while (0)
49  #define CALC_G16(y0, y1, u0, u1, v0, v1, dst) do {   \
50    const v8i16 const_a = (v8i16)__msa_fill_h(8708);   \
51    v8i16 a0 = __msa_subs_s_h((v8i16)y0, (v8i16)u0);   \
52    v8i16 a1 = __msa_subs_s_h((v8i16)y1, (v8i16)u1);   \
53    const v8i16 b0 = __msa_subs_s_h(a0, (v8i16)v0);    \
54    const v8i16 b1 = __msa_subs_s_h(a1, (v8i16)v1);    \
55    a0 = __msa_adds_s_h(b0, const_a);                  \
56    a1 = __msa_adds_s_h(b1, const_a);                  \
57    SRAI_H2_SH(a0, a1, 6);                             \
58    CLIP_SH2_0_255(a0, a1);                            \
59    dst = (v16u8)__msa_pckev_b((v16i8)a1, (v16i8)a0);  \
60  } while (0)
61  #define CALC_G8(y0, u0, v0, dst) do {                \
62    const v8i16 const_a = (v8i16)__msa_fill_h(8708);   \
63    v8i16 a0 = __msa_subs_s_h((v8i16)y0, (v8i16)u0);   \
64    const v8i16 b0 = __msa_subs_s_h(a0, (v8i16)v0);    \
65    a0 = __msa_adds_s_h(b0, const_a);                  \
66    a0 = SRAI_H(a0, 6);                                \
67    CLIP_SH_0_255(a0);                                 \
68    dst = (v16u8)__msa_pckev_b((v16i8)a0, (v16i8)a0);  \
69  } while (0)
70  #define CALC_B16(y0, y1, u0, u1, dst) do {           \
71    const v8u16 const_a = (v8u16)__msa_fill_h(17685);  \
72    const v8u16 a0 = __msa_adds_u_h((v8u16)y0, u0);    \
73    const v8u16 a1 = __msa_adds_u_h((v8u16)y1, u1);    \
74    v8u16 b0 = __msa_subs_u_h(a0, const_a);            \
75    v8u16 b1 = __msa_subs_u_h(a1, const_a);            \
76    SRAI_H2_UH(b0, b1, 6);                             \
77    CLIP_UH2_0_255(b0, b1);                            \
78    dst = (v16u8)__msa_pckev_b((v16i8)b1, (v16i8)b0);  \
79  } while (0)
80  #define CALC_B8(y0, u0, dst) do {                    \
81    const v8u16 const_a = (v8u16)__msa_fill_h(17685);  \
82    const v8u16 a0 = __msa_adds_u_h((v8u16)y0, u0);    \
83    v8u16 b0 = __msa_subs_u_h(a0, const_a);            \
84    b0 = SRAI_H(b0, 6);                                \
85    CLIP_UH_0_255(b0);                                 \
86    dst = (v16u8)__msa_pckev_b((v16i8)b0, (v16i8)b0);  \
87  } while (0)
88  #define CALC_RGB16(y, u, v, R, G, B) do {    \
89    const v16u8 zero = { 0 };                  \
90    v8u16 y0, y1, u0, u1, v0, v1;              \
91    v4u32 p0, p1, p2, p3;                      \
92    const v16u8 in_y = LD_UB(y);               \
93    const v16u8 in_u = LD_UB(u);               \
94    const v16u8 in_v = LD_UB(v);               \
95    ILVRL_UW4(in_y, p0, p1, p2, p3);           \
96    MULTHI_16(p0, p1, p2, p3, 19077, y0, y1);  \
97    ILVRL_UW4(in_v, p0, p1, p2, p3);           \
98    MULTHI_16(p0, p1, p2, p3, 26149, v0, v1);  \
99    CALC_R16(y0, y1, v0, v1, R);               \
100    MULTHI_16(p0, p1, p2, p3, 13320, v0, v1);  \
101    ILVRL_UW4(in_u, p0, p1, p2, p3);           \
102    MULTHI_16(p0, p1, p2, p3, 6419, u0, u1);   \
103    CALC_G16(y0, y1, u0, u1, v0, v1, G);       \
<span onclick='openModal()' class='match'>104    MULTHI_16(p0, p1, p2, p3, 33050, u0, u1);  \
105    CALC_B16(y0, y1, u0, u1, B);               \
</span>106  } while (0)
107  #define CALC_RGB8(y, u, v, R, G, B) do {  \
108    const v16u8 zero = { 0 };               \
109    v8u16 y0, u0, v0;                       \
110    v4u32 p0, p1;                           \
111    const v16u8 in_y = LD_UB(y);            \
112    const v16u8 in_u = LD_UB(u);            \
113    const v16u8 in_v = LD_UB(v);            \
114    ILVR_UW2(in_y, p0, p1);                 \
115    MULTHI_8(p0, p1, 19077, y0);            \
116    ILVR_UW2(in_v, p0, p1);                 \
117    MULTHI_8(p0, p1, 26149, v0);            \
118    CALC_R8(y0, v0, R);                     \
119    MULTHI_8(p0, p1, 13320, v0);            \
120    ILVR_UW2(in_u, p0, p1);                 \
121    MULTHI_8(p0, p1, 6419, u0);             \
122    CALC_G8(y0, u0, v0, G);                 \
123    MULTHI_8(p0, p1, 33050, u0);            \
124    CALC_B8(y0, u0, B);                     \
125  } while (0)
126  #define STORE16_3(a0, a1, a2, dst) do {                          \
127    const v16u8 mask0 = { 0, 1, 16, 2, 3, 17, 4, 5, 18, 6, 7, 19,  \
128                          8, 9, 20, 10 };                          \
129    const v16u8 mask1 = { 0, 21, 1, 2, 22, 3, 4, 23, 5, 6, 24, 7,  \
130                          8, 25, 9, 10 };                          \
131    const v16u8 mask2 = { 26, 0, 1, 27, 2, 3, 28, 4, 5, 29, 6, 7,  \
132                          30, 8, 9, 31 };                          \
133    v16u8 out0, out1, out2, tmp0, tmp1, tmp2;                      \
134    ILVRL_B2_UB(a1, a0, tmp0, tmp1);                               \
135    out0 = VSHF_UB(tmp0, a2, mask0);                               \
136    tmp2 = SLDI_UB(tmp1, tmp0, 11);                                \
137    out1 = VSHF_UB(tmp2, a2, mask1);                               \
138    tmp2 = SLDI_UB(tmp1, tmp1, 6);                                 \
139    out2 = VSHF_UB(tmp2, a2, mask2);                               \
140    ST_UB(out0, dst +  0);                                         \
141    ST_UB(out1, dst + 16);                                         \
142    ST_UB(out2, dst + 32);                                         \
143  } while (0)
144  #define STORE8_3(a0, a1, a2, dst) do {                             \
145    int64_t out_m;                                                   \
146    const v16u8 mask0 = { 0, 1, 16, 2, 3, 17, 4, 5, 18, 6, 7, 19,    \
147                          8, 9, 20, 10 };                            \
148    const v16u8 mask1 = { 11, 21, 12, 13, 22, 14, 15, 23,            \
149                          255, 255, 255, 255, 255, 255, 255, 255 };  \
150    const v16u8 tmp0 = (v16u8)__msa_ilvr_b((v16i8)a1, (v16i8)a0);    \
151    v16u8 out0, out1;                                                \
152    VSHF_B2_UB(tmp0, a2, tmp0, a2, mask0, mask1, out0, out1);        \
153    ST_UB(out0, dst);                                                \
154    out_m = __msa_copy_s_d((v2i64)out1, 0);                          \
155    SD(out_m, dst + 16);                                             \
156  } while (0)
157  #define STORE16_4(a0, a1, a2, a3, dst) do {  \
158    v16u8 tmp0, tmp1, tmp2, tmp3;              \
159    v16u8 out0, out1, out2, out3;              \
160    ILVRL_B2_UB(a1, a0, tmp0, tmp1);           \
161    ILVRL_B2_UB(a3, a2, tmp2, tmp3);           \
162    ILVRL_H2_UB(tmp2, tmp0, out0, out1);       \
163    ILVRL_H2_UB(tmp3, tmp1, out2, out3);       \
164    ST_UB(out0, dst +  0);                     \
165    ST_UB(out1, dst + 16);                     \
166    ST_UB(out2, dst + 32);                     \
167    ST_UB(out3, dst + 48);                     \
168  } while (0)
169  #define STORE8_4(a0, a1, a2, a3, dst) do {  \
170    v16u8 tmp0, tmp1, tmp2, tmp3;             \
171    ILVR_B2_UB(a1, a0, a3, a2, tmp0, tmp1);   \
172    ILVRL_H2_UB(tmp1, tmp0, tmp2, tmp3);      \
173    ST_UB(tmp2, dst +  0);                    \
174    ST_UB(tmp3, dst + 16);                    \
175  } while (0)
176  #define STORE2_16(a0, a1, dst) do {  \
177    v16u8 out0, out1;                  \
178    ILVRL_B2_UB(a1, a0, out0, out1);   \
179    ST_UB(out0, dst +  0);             \
180    ST_UB(out1, dst + 16);             \
181  } while (0)
182  #define STORE2_8(a0, a1, dst) do {                               \
183    const v16u8 out0 = (v16u8)__msa_ilvr_b((v16i8)a1, (v16i8)a0);  \
184    ST_UB(out0, dst);                                              \
185  } while (0)
186  #define CALC_RGBA4444(y, u, v, out0, out1, N, dst) do {  \
187    CALC_RGB##N(y, u, v, R, G, B);                         \
188    tmp0 = ANDI_B(R, 0xf0);                                \
189    tmp1 = SRAI_B(G, 4);                                   \
190    RG = tmp0 | tmp1;                                      \
191    tmp0 = ANDI_B(B, 0xf0);                                \
192    BA = ORI_B(tmp0, 0x0f);                                \
193    STORE2_##N(out0, out1, dst);                           \
194  } while (0)
195  #define CALC_RGB565(y, u, v, out0, out1, N, dst) do {  \
196    CALC_RGB##N(y, u, v, R, G, B);                       \
197    tmp0 = ANDI_B(R, 0xf8);                              \
198    tmp1 = SRAI_B(G, 5);                                 \
199    RG = tmp0 | tmp1;                                    \
200    tmp0 = SLLI_B(G, 3);                                 \
201    tmp1 = ANDI_B(tmp0, 0xe0);                           \
202    tmp0 = SRAI_B(B, 3);                                 \
203    GB = tmp0 | tmp1;                                    \
204    STORE2_##N(out0, out1, dst);                         \
205  } while (0)
206  static WEBP_INLINE int Clip8(int v) {
207    return v &lt; 0 ? 0 : v &gt; 255 ? 255 : v;
208  }
209  static void YuvToRgb(int y, int u, int v, uint8_t* const rgb) {
210    const int y1 = MultHi(y, 19077);
211    const int r1 = y1 + MultHi(v, 26149) - 14234;
212    const int g1 = y1 - MultHi(u, 6419) - MultHi(v, 13320) + 8708;
213    const int b1 = y1 + MultHi(u, 33050) - 17685;
214    rgb[0] = Clip8(r1 &gt;&gt; 6);
215    rgb[1] = Clip8(g1 &gt;&gt; 6);
216    rgb[2] = Clip8(b1 &gt;&gt; 6);
217  }
218  static void YuvToBgr(int y, int u, int v, uint8_t* const bgr) {
219    const int y1 = MultHi(y, 19077);
220    const int r1 = y1 + MultHi(v, 26149) - 14234;
221    const int g1 = y1 - MultHi(u, 6419) - MultHi(v, 13320) + 8708;
222    const int b1 = y1 + MultHi(u, 33050) - 17685;
223    bgr[0] = Clip8(b1 &gt;&gt; 6);
224    bgr[1] = Clip8(g1 &gt;&gt; 6);
225    bgr[2] = Clip8(r1 &gt;&gt; 6);
226  }
227  #if !defined(WEBP_REDUCE_CSP)
228  static void YuvToRgb565(int y, int u, int v, uint8_t* const rgb) {
229    const int y1 = MultHi(y, 19077);
230    const int r1 = y1 + MultHi(v, 26149) - 14234;
231    const int g1 = y1 - MultHi(u, 6419) - MultHi(v, 13320) + 8708;
232    const int b1 = y1 + MultHi(u, 33050) - 17685;
233    const int r = Clip8(r1 &gt;&gt; 6);
234    const int g = Clip8(g1 &gt;&gt; 6);
235    const int b = Clip8(b1 &gt;&gt; 6);
236    const int rg = (r &amp; 0xf8) | (g &gt;&gt; 5);
237    const int gb = ((g &lt;&lt; 3) &amp; 0xe0) | (b &gt;&gt; 3);
238  #if (WEBP_SWAP_16BIT_CSP == 1)
239    rgb[0] = gb;
240    rgb[1] = rg;
241  #else
242    rgb[0] = rg;
243    rgb[1] = gb;
244  #endif
245  }
246  static void YuvToRgba4444(int y, int u, int v, uint8_t* const argb) {
247    const int y1 = MultHi(y, 19077);
248    const int r1 = y1 + MultHi(v, 26149) - 14234;
249    const int g1 = y1 - MultHi(u, 6419) - MultHi(v, 13320) + 8708;
250    const int b1 = y1 + MultHi(u, 33050) - 17685;
251    const int r = Clip8(r1 &gt;&gt; 6);
252    const int g = Clip8(g1 &gt;&gt; 6);
253    const int b = Clip8(b1 &gt;&gt; 6);
254    const int rg = (r &amp; 0xf0) | (g &gt;&gt; 4);
255    const int ba = (b &amp; 0xf0) | 0x0f;     
256  #if (WEBP_SWAP_16BIT_CSP == 1)
257    argb[0] = ba;
258    argb[1] = rg;
259  #else
260    argb[0] = rg;
261    argb[1] = ba;
262  #endif
263  }
264  static void YuvToArgb(uint8_t y, uint8_t u, uint8_t v, uint8_t* const argb) {
265    argb[0] = 0xff;
266    YuvToRgb(y, u, v, argb + 1);
267  }
268  #endif  
269  static void YuvToBgra(uint8_t y, uint8_t u, uint8_t v, uint8_t* const bgra) {
270    YuvToBgr(y, u, v, bgra);
271    bgra[3] = 0xff;
272  }
273  static void YuvToRgba(uint8_t y, uint8_t u, uint8_t v, uint8_t* const rgba) {
274    YuvToRgb(y, u, v, rgba);
275    rgba[3] = 0xff;
276  }
277  #if !defined(WEBP_REDUCE_CSP)
278  static void YuvToRgbLine(const uint8_t* y, const uint8_t* u,
279                           const uint8_t* v, uint8_t* dst, int length) {
280    v16u8 R, G, B;
281    while (length &gt;= 16) {
282      CALC_RGB16(y, u, v, R, G, B);
283      STORE16_3(R, G, B, dst);
284      y      += 16;
285      u      += 16;
286      v      += 16;
287      dst    += 16 * 3;
288      length -= 16;
289    }
290    if (length &gt; 8) {
291      uint8_t temp[3 * 16] = { 0 };
292      memcpy(temp, y, length * sizeof(*temp));
293      CALC_RGB16(temp, u, v, R, G, B);
294      STORE16_3(R, G, B, temp);
295      memcpy(dst, temp, length * 3 * sizeof(*dst));
296    } else if (length &gt; 0) {
297      uint8_t temp[3 * 8] = { 0 };
298      memcpy(temp, y, length * sizeof(*temp));
299      CALC_RGB8(temp, u, v, R, G, B);
300      STORE8_3(R, G, B, temp);
301      memcpy(dst, temp, length * 3 * sizeof(*dst));
302    }
303  }
304  static void YuvToBgrLine(const uint8_t* y, const uint8_t* u,
305                           const uint8_t* v, uint8_t* dst, int length) {
306    v16u8 R, G, B;
307    while (length &gt;= 16) {
308      CALC_RGB16(y, u, v, R, G, B);
309      STORE16_3(B, G, R, dst);
310      y      += 16;
311      u      += 16;
312      v      += 16;
313      dst    += 16 * 3;
314      length -= 16;
315    }
316    if (length &gt; 8) {
317      uint8_t temp[3 * 16] = { 0 };
318      memcpy(temp, y, length * sizeof(*temp));
319      CALC_RGB16(temp, u, v, R, G, B);
320      STORE16_3(B, G, R, temp);
321      memcpy(dst, temp, length * 3 * sizeof(*dst));
322    } else if (length &gt; 0) {
323      uint8_t temp[3 * 8] = { 0 };
324      memcpy(temp, y, length * sizeof(*temp));
325      CALC_RGB8(temp, u, v, R, G, B);
326      STORE8_3(B, G, R, temp);
327      memcpy(dst, temp, length * 3 * sizeof(*dst));
328    }
329  }
330  #endif  
331  static void YuvToRgbaLine(const uint8_t* y, const uint8_t* u,
332                            const uint8_t* v, uint8_t* dst, int length) {
333    v16u8 R, G, B;
334    const v16u8 A = (v16u8)__msa_ldi_b(ALPHAVAL);
335    while (length &gt;= 16) {
336      CALC_RGB16(y, u, v, R, G, B);
337      STORE16_4(R, G, B, A, dst);
338      y      += 16;
339      u      += 16;
340      v      += 16;
341      dst    += 16 * 4;
342      length -= 16;
343    }
344    if (length &gt; 8) {
345      uint8_t temp[4 * 16] = { 0 };
346      memcpy(temp, y, length * sizeof(*temp));
347      CALC_RGB16(&amp;temp[0], u, v, R, G, B);
348      STORE16_4(R, G, B, A, temp);
349      memcpy(dst, temp, length * 4 * sizeof(*dst));
350    } else if (length &gt; 0) {
351      uint8_t temp[4 * 8] = { 0 };
352      memcpy(temp, y, length * sizeof(*temp));
353      CALC_RGB8(temp, u, v, R, G, B);
354      STORE8_4(R, G, B, A, temp);
355      memcpy(dst, temp, length * 4 * sizeof(*dst));
356    }
357  }
358  static void YuvToBgraLine(const uint8_t* y, const uint8_t* u,
359                            const uint8_t* v, uint8_t* dst, int length) {
360    v16u8 R, G, B;
361    const v16u8 A = (v16u8)__msa_ldi_b(ALPHAVAL);
362    while (length &gt;= 16) {
363      CALC_RGB16(y, u, v, R, G, B);
364      STORE16_4(B, G, R, A, dst);
365      y      += 16;
366      u      += 16;
367      v      += 16;
368      dst    += 16 * 4;
369      length -= 16;
370    }
371    if (length &gt; 8) {
372      uint8_t temp[4 * 16] = { 0 };
373      memcpy(temp, y, length * sizeof(*temp));
374      CALC_RGB16(temp, u, v, R, G, B);
375      STORE16_4(B, G, R, A, temp);
376      memcpy(dst, temp, length * 4 * sizeof(*dst));
377    } else if (length &gt; 0) {
378      uint8_t temp[4 * 8] = { 0 };
379      memcpy(temp, y, length * sizeof(*temp));
380      CALC_RGB8(temp, u, v, R, G, B);
381      STORE8_4(B, G, R, A, temp);
382      memcpy(dst, temp, length * 4 * sizeof(*dst));
383    }
384  }
385  #if !defined(WEBP_REDUCE_CSP)
386  static void YuvToArgbLine(const uint8_t* y, const uint8_t* u,
387                            const uint8_t* v, uint8_t* dst, int length) {
388    v16u8 R, G, B;
389    const v16u8 A = (v16u8)__msa_ldi_b(ALPHAVAL);
390    while (length &gt;= 16) {
391      CALC_RGB16(y, u, v, R, G, B);
392      STORE16_4(A, R, G, B, dst);
393      y      += 16;
394      u      += 16;
395      v      += 16;
396      dst    += 16 * 4;
397      length -= 16;
398    }
399    if (length &gt; 8) {
400      uint8_t temp[4 * 16] = { 0 };
401      memcpy(temp, y, length * sizeof(*temp));
402      CALC_RGB16(temp, u, v, R, G, B);
403      STORE16_4(A, R, G, B, temp);
404      memcpy(dst, temp, length * 4 * sizeof(*dst));
405    } else if (length &gt; 0) {
406      uint8_t temp[4 * 8] = { 0 };
407      memcpy(temp, y, length * sizeof(*temp));
408      CALC_RGB8(temp, u, v, R, G, B);
409      STORE8_4(A, R, G, B, temp);
410      memcpy(dst, temp, length * 4 * sizeof(*dst));
411    }
412  }
413  static void YuvToRgba4444Line(const uint8_t* y, const uint8_t* u,
414                                const uint8_t* v, uint8_t* dst, int length) {
415    v16u8 R, G, B, RG, BA, tmp0, tmp1;
416    while (length &gt;= 16) {
417  #if (WEBP_SWAP_16BIT_CSP == 1)
418      CALC_RGBA4444(y, u, v, BA, RG, 16, dst);
419  #else
420      CALC_RGBA4444(y, u, v, RG, BA, 16, dst);
421  #endif
422      y      += 16;
423      u      += 16;
424      v      += 16;
425      dst    += 16 * 2;
426      length -= 16;
427    }
428    if (length &gt; 8) {
429      uint8_t temp[2 * 16] = { 0 };
430      memcpy(temp, y, length * sizeof(*temp));
431  #if (WEBP_SWAP_16BIT_CSP == 1)
432      CALC_RGBA4444(temp, u, v, BA, RG, 16, temp);
433  #else
434      CALC_RGBA4444(temp, u, v, RG, BA, 16, temp);
435  #endif
436      memcpy(dst, temp, length * 2 * sizeof(*dst));
437    } else if (length &gt; 0) {
438      uint8_t temp[2 * 8] = { 0 };
439      memcpy(temp, y, length * sizeof(*temp));
440  #if (WEBP_SWAP_16BIT_CSP == 1)
441      CALC_RGBA4444(temp, u, v, BA, RG, 8, temp);
442  #else
443      CALC_RGBA4444(temp, u, v, RG, BA, 8, temp);
444  #endif
445      memcpy(dst, temp, length * 2 * sizeof(*dst));
446    }
447  }
448  static void YuvToRgb565Line(const uint8_t* y, const uint8_t* u,
449                              const uint8_t* v, uint8_t* dst, int length) {
450    v16u8 R, G, B, RG, GB, tmp0, tmp1;
451    while (length &gt;= 16) {
452  #if (WEBP_SWAP_16BIT_CSP == 1)
453      CALC_RGB565(y, u, v, GB, RG, 16, dst);
454  #else
455      CALC_RGB565(y, u, v, RG, GB, 16, dst);
456  #endif
457      y      += 16;
458      u      += 16;
459      v      += 16;
460      dst    += 16 * 2;
461      length -= 16;
462    }
463    if (length &gt; 8) {
464      uint8_t temp[2 * 16] = { 0 };
465      memcpy(temp, y, length * sizeof(*temp));
466  #if (WEBP_SWAP_16BIT_CSP == 1)
467      CALC_RGB565(temp, u, v, GB, RG, 16, temp);
468  #else
469      CALC_RGB565(temp, u, v, RG, GB, 16, temp);
470  #endif
471      memcpy(dst, temp, length * 2 * sizeof(*dst));
472    } else if (length &gt; 0) {
473      uint8_t temp[2 * 8] = { 0 };
474      memcpy(temp, y, length * sizeof(*temp));
475  #if (WEBP_SWAP_16BIT_CSP == 1)
476      CALC_RGB565(temp, u, v, GB, RG, 8, temp);
477  #else
478      CALC_RGB565(temp, u, v, RG, GB, 8, temp);
479  #endif
480      memcpy(dst, temp, length * 2 * sizeof(*dst));
481    }
482  }
483  #endif  
484  #define UPSAMPLE_32PIXELS(a, b, c, d) do {    \
485    v16u8 s = __msa_aver_u_b(a, d);             \
486    v16u8 t = __msa_aver_u_b(b, c);             \
487    const v16u8 st = s ^ t;                     \
488    v16u8 ad = a ^ d;                           \
489    v16u8 bc = b ^ c;                           \
490    v16u8 t0 = ad | bc;                         \
491    v16u8 t1 = t0 | st;                         \
492    v16u8 t2 = ANDI_B(t1, 1);                   \
493    v16u8 t3 = __msa_aver_u_b(s, t);            \
494    const v16u8 k = t3 - t2;                    \
495    v16u8 diag1, diag2;                         \
496    AVER_UB2_UB(t, k, s, k, t0, t1);            \
497    bc = bc &amp; st;                               \
498    ad = ad &amp; st;                               \
499    t = t ^ k;                                  \
500    s = s ^ k;                                  \
501    t2 = bc | t;                                \
502    t3 = ad | s;                                \
503    t2 = ANDI_B(t2, 1);                         \
504    t3 = ANDI_B(t3, 1);                         \
505    SUB2(t0, t2, t1, t3, diag1, diag2);         \
506    AVER_UB2_UB(a, diag1, b, diag2, t0, t1);    \
507    ILVRL_B2_UB(t1, t0, a, b);                  \
508    if (pbot_y != NULL) {                       \
509      AVER_UB2_UB(c, diag2, d, diag1, t0, t1);  \
510      ILVRL_B2_UB(t1, t0, c, d);                \
511    }                                           \
512  } while (0)
513  #define UPSAMPLE_FUNC(FUNC_NAME, FUNC, XSTEP)                            \
514  static void FUNC_NAME(const uint8_t* top_y, const uint8_t* bot_y,        \
515                        const uint8_t* top_u, const uint8_t* top_v,        \
516                        const uint8_t* cur_u, const uint8_t* cur_v,        \
517                        uint8_t* top_dst, uint8_t* bot_dst, int len)       \
518  {                                                                        \
519    int size = (len - 1) &gt;&gt; 1;                                             \
520    uint8_t temp_u[64];                                                    \
521    uint8_t temp_v[64];                                                    \
522    const uint32_t tl_uv = ((top_u[0]) | ((top_v[0]) &lt;&lt; 16));              \
523    const uint32_t l_uv = ((cur_u[0]) | ((cur_v[0]) &lt;&lt; 16));               \
524    const uint32_t uv0 = (3 * tl_uv + l_uv + 0x00020002u) &gt;&gt; 2;            \
525    const uint8_t* ptop_y = &amp;top_y[1];                                     \
526    uint8_t* ptop_dst = top_dst + XSTEP;                                   \
527    const uint8_t* pbot_y = &amp;bot_y[1];                                     \
528    uint8_t* pbot_dst = bot_dst + XSTEP;                                   \
529                                                                           \
530    FUNC(top_y[0], uv0 &amp; 0xff, (uv0 &gt;&gt; 16), top_dst);                      \
531    if (bot_y != NULL) {                                                   \
532      const uint32_t uv1 = (3 * l_uv + tl_uv + 0x00020002u) &gt;&gt; 2;          \
533      FUNC(bot_y[0], uv1 &amp; 0xff, (uv1 &gt;&gt; 16), bot_dst);                    \
534    }                                                                      \
535    while (size &gt;= 16) {                                                   \
536      v16u8 tu0, tu1, tv0, tv1, cu0, cu1, cv0, cv1;                        \
537      LD_UB2(top_u, 1, tu0, tu1);                                          \
538      LD_UB2(cur_u, 1, cu0, cu1);                                          \
539      LD_UB2(top_v, 1, tv0, tv1);                                          \
540      LD_UB2(cur_v, 1, cv0, cv1);                                          \
541      UPSAMPLE_32PIXELS(tu0, tu1, cu0, cu1);                               \
542      UPSAMPLE_32PIXELS(tv0, tv1, cv0, cv1);                               \
543      ST_UB4(tu0, tu1, cu0, cu1, &amp;temp_u[0], 16);                          \
544      ST_UB4(tv0, tv1, cv0, cv1, &amp;temp_v[0], 16);                          \
545      FUNC##Line(ptop_y, &amp;temp_u[ 0], &amp;temp_v[0], ptop_dst, 32);           \
546      if (bot_y != NULL) {                                                 \
547        FUNC##Line(pbot_y, &amp;temp_u[32], &amp;temp_v[32], pbot_dst, 32);        \
548      }                                                                    \
549      ptop_y   += 32;                                                      \
550      pbot_y   += 32;                                                      \
551      ptop_dst += XSTEP * 32;                                              \
552      pbot_dst += XSTEP * 32;                                              \
553      top_u    += 16;                                                      \
554      top_v    += 16;                                                      \
555      cur_u    += 16;                                                      \
556      cur_v    += 16;                                                      \
557      size     -= 16;                                                      \
558    }                                                                      \
559    if (size &gt; 0) {                                                        \
560      v16u8 tu0, tu1, tv0, tv1, cu0, cu1, cv0, cv1;                        \
561      memcpy(&amp;temp_u[ 0], top_u, 17 * sizeof(uint8_t));                    \
562      memcpy(&amp;temp_u[32], cur_u, 17 * sizeof(uint8_t));                    \
563      memcpy(&amp;temp_v[ 0], top_v, 17 * sizeof(uint8_t));                    \
564      memcpy(&amp;temp_v[32], cur_v, 17 * sizeof(uint8_t));                    \
565      LD_UB2(&amp;temp_u[ 0], 1, tu0, tu1);                                    \
566      LD_UB2(&amp;temp_u[32], 1, cu0, cu1);                                    \
567      LD_UB2(&amp;temp_v[ 0], 1, tv0, tv1);                                    \
568      LD_UB2(&amp;temp_v[32], 1, cv0, cv1);                                    \
569      UPSAMPLE_32PIXELS(tu0, tu1, cu0, cu1);                               \
570      UPSAMPLE_32PIXELS(tv0, tv1, cv0, cv1);                               \
571      ST_UB4(tu0, tu1, cu0, cu1, &amp;temp_u[0], 16);                          \
572      ST_UB4(tv0, tv1, cv0, cv1, &amp;temp_v[0], 16);                          \
573      FUNC##Line(ptop_y, &amp;temp_u[ 0], &amp;temp_v[0], ptop_dst, size * 2);     \
574      if (bot_y != NULL) {                                                 \
575        FUNC##Line(pbot_y, &amp;temp_u[32], &amp;temp_v[32], pbot_dst, size * 2);  \
576      }                                                                    \
577      top_u += size;                                                       \
578      top_v += size;                                                       \
579      cur_u += size;                                                       \
580      cur_v += size;                                                       \
581    }                                                                      \
582    if (!(len &amp; 1)) {                                                      \
583      const uint32_t t0 = ((top_u[0]) | ((top_v[0]) &lt;&lt; 16));               \
584      const uint32_t c0  = ((cur_u[0]) | ((cur_v[0]) &lt;&lt; 16));              \
585      const uint32_t tmp0 = (3 * t0 + c0 + 0x00020002u) &gt;&gt; 2;              \
586      FUNC(top_y[len - 1], tmp0 &amp; 0xff, (tmp0 &gt;&gt; 16),                      \
587                  top_dst + (len - 1) * XSTEP);                            \
588      if (bot_y != NULL) {                                                 \
589        const uint32_t tmp1 = (3 * c0 + t0 + 0x00020002u) &gt;&gt; 2;            \
590        FUNC(bot_y[len - 1], tmp1 &amp; 0xff, (tmp1 &gt;&gt; 16),                    \
591             bot_dst + (len - 1) * XSTEP);                                 \
592      }                                                                    \
593    }                                                                      \
594  }
595  UPSAMPLE_FUNC(UpsampleRgbaLinePair,     YuvToRgba,     4)
596  UPSAMPLE_FUNC(UpsampleBgraLinePair,     YuvToBgra,     4)
597  #if !defined(WEBP_REDUCE_CSP)
598  UPSAMPLE_FUNC(UpsampleRgbLinePair,      YuvToRgb,      3)
599  UPSAMPLE_FUNC(UpsampleBgrLinePair,      YuvToBgr,      3)
600  UPSAMPLE_FUNC(UpsampleArgbLinePair,     YuvToArgb,     4)
601  UPSAMPLE_FUNC(UpsampleRgba4444LinePair, YuvToRgba4444, 2)
602  UPSAMPLE_FUNC(UpsampleRgb565LinePair,   YuvToRgb565,   2)
603  #endif   
604  extern WebPUpsampleLinePairFunc WebPUpsamplers[&amp;bsol;* MODE_LAST */];
605  extern void WebPInitUpsamplersMSA(void);
606  WEBP_TSAN_IGNORE_FUNCTION void WebPInitUpsamplersMSA(void) {
607    WebPUpsamplers[MODE_RGBA]      = UpsampleRgbaLinePair;
608    WebPUpsamplers[MODE_BGRA]      = UpsampleBgraLinePair;
609    WebPUpsamplers[MODE_rgbA]      = UpsampleRgbaLinePair;
610    WebPUpsamplers[MODE_bgrA]      = UpsampleBgraLinePair;
611  #if !defined(WEBP_REDUCE_CSP)
612    WebPUpsamplers[MODE_RGB]       = UpsampleRgbLinePair;
613    WebPUpsamplers[MODE_BGR]       = UpsampleBgrLinePair;
614    WebPUpsamplers[MODE_ARGB]      = UpsampleArgbLinePair;
615    WebPUpsamplers[MODE_Argb]      = UpsampleArgbLinePair;
616    WebPUpsamplers[MODE_RGB_565]   = UpsampleRgb565LinePair;
617    WebPUpsamplers[MODE_RGBA_4444] = UpsampleRgba4444LinePair;
618    WebPUpsamplers[MODE_rgbA_4444] = UpsampleRgba4444LinePair;
619  #endif   
620  }
621  #endif  
622  #endif  
623  #if !(defined(FANCY_UPSAMPLING) &amp;&amp; defined(WEBP_USE_MSA))
624  WEBP_DSP_INIT_STUB(WebPInitUpsamplersMSA)
625  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-upsampling_msa.c</h3>
            <pre><code>1  #include &lt;string.h&gt;
2  #include &quot;src/dsp/dsp.h&quot;
3  #if defined(WEBP_USE_MSA)
4  #include &quot;src/dsp/msa_macro.h&quot;
5  #include &quot;src/dsp/yuv.h&quot;
6  #ifdef FANCY_UPSAMPLING
7  #define ILVR_UW2(in, out0, out1) do {                            \
8    const v8i16 t0 = (v8i16)__msa_ilvr_b((v16i8)zero, (v16i8)in);  \
9    out0 = (v4u32)__msa_ilvr_h((v8i16)zero, t0);                   \
10    out1 = (v4u32)__msa_ilvl_h((v8i16)zero, t0);                   \
11  } while (0)
12  #define ILVRL_UW4(in, out0, out1, out2, out3) do {  \
13    v16u8 t0, t1;                                     \
14    ILVRL_B2_UB(zero, in, t0, t1);                    \
15    ILVRL_H2_UW(zero, t0, out0, out1);                \
16    ILVRL_H2_UW(zero, t1, out2, out3);                \
17  } while (0)
18  #define MULTHI_16(in0, in1, in2, in3, cnst, out0, out1) do {   \
19    const v4i32 const0 = (v4i32)__msa_fill_w(cnst * 256);        \
20    v4u32 temp0, temp1, temp2, temp3;                            \
21    MUL4(in0, const0, in1, const0, in2, const0, in3, const0,     \
22         temp0, temp1, temp2, temp3);                            \
23    PCKOD_H2_UH(temp1, temp0, temp3, temp2, out0, out1);         \
24  } while (0)
25  #define MULTHI_8(in0, in1, cnst, out0) do {                 \
26    const v4i32 const0 = (v4i32)__msa_fill_w(cnst * 256);     \
27    v4u32 temp0, temp1;                                       \
28    MUL2(in0, const0, in1, const0, temp0, temp1);             \
29    out0 = (v8u16)__msa_pckod_h((v8i16)temp1, (v8i16)temp0);  \
30  } while (0)
31  #define CALC_R16(y0, y1, v0, v1, dst) do {                \
32    const v8i16 const_a = (v8i16)__msa_fill_h(14234);       \
33    const v8i16 a0 = __msa_adds_s_h((v8i16)y0, (v8i16)v0);  \
34    const v8i16 a1 = __msa_adds_s_h((v8i16)y1, (v8i16)v1);  \
35    v8i16 b0 = __msa_subs_s_h(a0, const_a);                 \
36    v8i16 b1 = __msa_subs_s_h(a1, const_a);                 \
37    SRAI_H2_SH(b0, b1, 6);                                  \
38    CLIP_SH2_0_255(b0, b1);                                 \
39    dst = (v16u8)__msa_pckev_b((v16i8)b1, (v16i8)b0);       \
40  } while (0)
41  #define CALC_R8(y0, v0, dst) do {                         \
42    const v8i16 const_a = (v8i16)__msa_fill_h(14234);       \
43    const v8i16 a0 = __msa_adds_s_h((v8i16)y0, (v8i16)v0);  \
44    v8i16 b0 = __msa_subs_s_h(a0, const_a);                 \
45    b0 = SRAI_H(b0, 6);                                     \
46    CLIP_SH_0_255(b0);                                      \
47    dst = (v16u8)__msa_pckev_b((v16i8)b0, (v16i8)b0);       \
48  } while (0)
49  #define CALC_G16(y0, y1, u0, u1, v0, v1, dst) do {   \
50    const v8i16 const_a = (v8i16)__msa_fill_h(8708);   \
51    v8i16 a0 = __msa_subs_s_h((v8i16)y0, (v8i16)u0);   \
52    v8i16 a1 = __msa_subs_s_h((v8i16)y1, (v8i16)u1);   \
53    const v8i16 b0 = __msa_subs_s_h(a0, (v8i16)v0);    \
54    const v8i16 b1 = __msa_subs_s_h(a1, (v8i16)v1);    \
55    a0 = __msa_adds_s_h(b0, const_a);                  \
56    a1 = __msa_adds_s_h(b1, const_a);                  \
57    SRAI_H2_SH(a0, a1, 6);                             \
58    CLIP_SH2_0_255(a0, a1);                            \
59    dst = (v16u8)__msa_pckev_b((v16i8)a1, (v16i8)a0);  \
60  } while (0)
61  #define CALC_G8(y0, u0, v0, dst) do {                \
62    const v8i16 const_a = (v8i16)__msa_fill_h(8708);   \
63    v8i16 a0 = __msa_subs_s_h((v8i16)y0, (v8i16)u0);   \
64    const v8i16 b0 = __msa_subs_s_h(a0, (v8i16)v0);    \
65    a0 = __msa_adds_s_h(b0, const_a);                  \
66    a0 = SRAI_H(a0, 6);                                \
67    CLIP_SH_0_255(a0);                                 \
68    dst = (v16u8)__msa_pckev_b((v16i8)a0, (v16i8)a0);  \
69  } while (0)
70  #define CALC_B16(y0, y1, u0, u1, dst) do {           \
71    const v8u16 const_a = (v8u16)__msa_fill_h(17685);  \
72    const v8u16 a0 = __msa_adds_u_h((v8u16)y0, u0);    \
73    const v8u16 a1 = __msa_adds_u_h((v8u16)y1, u1);    \
74    v8u16 b0 = __msa_subs_u_h(a0, const_a);            \
75    v8u16 b1 = __msa_subs_u_h(a1, const_a);            \
76    SRAI_H2_UH(b0, b1, 6);                             \
77    CLIP_UH2_0_255(b0, b1);                            \
78    dst = (v16u8)__msa_pckev_b((v16i8)b1, (v16i8)b0);  \
79  } while (0)
80  #define CALC_B8(y0, u0, dst) do {                    \
81    const v8u16 const_a = (v8u16)__msa_fill_h(17685);  \
82    const v8u16 a0 = __msa_adds_u_h((v8u16)y0, u0);    \
83    v8u16 b0 = __msa_subs_u_h(a0, const_a);            \
84    b0 = SRAI_H(b0, 6);                                \
85    CLIP_UH_0_255(b0);                                 \
86    dst = (v16u8)__msa_pckev_b((v16i8)b0, (v16i8)b0);  \
87  } while (0)
88  #define CALC_RGB16(y, u, v, R, G, B) do {    \
89    const v16u8 zero = { 0 };                  \
90    v8u16 y0, y1, u0, u1, v0, v1;              \
91    v4u32 p0, p1, p2, p3;                      \
92    const v16u8 in_y = LD_UB(y);               \
93    const v16u8 in_u = LD_UB(u);               \
94    const v16u8 in_v = LD_UB(v);               \
95    ILVRL_UW4(in_y, p0, p1, p2, p3);           \
96    MULTHI_16(p0, p1, p2, p3, 19077, y0, y1);  \
97    ILVRL_UW4(in_v, p0, p1, p2, p3);           \
98    MULTHI_16(p0, p1, p2, p3, 26149, v0, v1);  \
99    CALC_R16(y0, y1, v0, v1, R);               \
<span onclick='openModal()' class='match'>100    MULTHI_16(p0, p1, p2, p3, 13320, v0, v1);  \
101    ILVRL_UW4(in_u, p0, p1, p2, p3);           \
</span>102    MULTHI_16(p0, p1, p2, p3, 6419, u0, u1);   \
103    CALC_G16(y0, y1, u0, u1, v0, v1, G);       \
104    MULTHI_16(p0, p1, p2, p3, 33050, u0, u1);  \
105    CALC_B16(y0, y1, u0, u1, B);               \
106  } while (0)
107  #define CALC_RGB8(y, u, v, R, G, B) do {  \
108    const v16u8 zero = { 0 };               \
109    v8u16 y0, u0, v0;                       \
110    v4u32 p0, p1;                           \
111    const v16u8 in_y = LD_UB(y);            \
112    const v16u8 in_u = LD_UB(u);            \
113    const v16u8 in_v = LD_UB(v);            \
114    ILVR_UW2(in_y, p0, p1);                 \
115    MULTHI_8(p0, p1, 19077, y0);            \
116    ILVR_UW2(in_v, p0, p1);                 \
117    MULTHI_8(p0, p1, 26149, v0);            \
118    CALC_R8(y0, v0, R);                     \
119    MULTHI_8(p0, p1, 13320, v0);            \
120    ILVR_UW2(in_u, p0, p1);                 \
121    MULTHI_8(p0, p1, 6419, u0);             \
122    CALC_G8(y0, u0, v0, G);                 \
123    MULTHI_8(p0, p1, 33050, u0);            \
124    CALC_B8(y0, u0, B);                     \
125  } while (0)
126  #define STORE16_3(a0, a1, a2, dst) do {                          \
127    const v16u8 mask0 = { 0, 1, 16, 2, 3, 17, 4, 5, 18, 6, 7, 19,  \
128                          8, 9, 20, 10 };                          \
129    const v16u8 mask1 = { 0, 21, 1, 2, 22, 3, 4, 23, 5, 6, 24, 7,  \
130                          8, 25, 9, 10 };                          \
131    const v16u8 mask2 = { 26, 0, 1, 27, 2, 3, 28, 4, 5, 29, 6, 7,  \
132                          30, 8, 9, 31 };                          \
133    v16u8 out0, out1, out2, tmp0, tmp1, tmp2;                      \
134    ILVRL_B2_UB(a1, a0, tmp0, tmp1);                               \
135    out0 = VSHF_UB(tmp0, a2, mask0);                               \
136    tmp2 = SLDI_UB(tmp1, tmp0, 11);                                \
137    out1 = VSHF_UB(tmp2, a2, mask1);                               \
138    tmp2 = SLDI_UB(tmp1, tmp1, 6);                                 \
139    out2 = VSHF_UB(tmp2, a2, mask2);                               \
140    ST_UB(out0, dst +  0);                                         \
141    ST_UB(out1, dst + 16);                                         \
142    ST_UB(out2, dst + 32);                                         \
143  } while (0)
144  #define STORE8_3(a0, a1, a2, dst) do {                             \
145    int64_t out_m;                                                   \
146    const v16u8 mask0 = { 0, 1, 16, 2, 3, 17, 4, 5, 18, 6, 7, 19,    \
147                          8, 9, 20, 10 };                            \
148    const v16u8 mask1 = { 11, 21, 12, 13, 22, 14, 15, 23,            \
149                          255, 255, 255, 255, 255, 255, 255, 255 };  \
150    const v16u8 tmp0 = (v16u8)__msa_ilvr_b((v16i8)a1, (v16i8)a0);    \
151    v16u8 out0, out1;                                                \
152    VSHF_B2_UB(tmp0, a2, tmp0, a2, mask0, mask1, out0, out1);        \
153    ST_UB(out0, dst);                                                \
154    out_m = __msa_copy_s_d((v2i64)out1, 0);                          \
155    SD(out_m, dst + 16);                                             \
156  } while (0)
157  #define STORE16_4(a0, a1, a2, a3, dst) do {  \
158    v16u8 tmp0, tmp1, tmp2, tmp3;              \
159    v16u8 out0, out1, out2, out3;              \
160    ILVRL_B2_UB(a1, a0, tmp0, tmp1);           \
161    ILVRL_B2_UB(a3, a2, tmp2, tmp3);           \
162    ILVRL_H2_UB(tmp2, tmp0, out0, out1);       \
163    ILVRL_H2_UB(tmp3, tmp1, out2, out3);       \
164    ST_UB(out0, dst +  0);                     \
165    ST_UB(out1, dst + 16);                     \
166    ST_UB(out2, dst + 32);                     \
167    ST_UB(out3, dst + 48);                     \
168  } while (0)
169  #define STORE8_4(a0, a1, a2, a3, dst) do {  \
170    v16u8 tmp0, tmp1, tmp2, tmp3;             \
171    ILVR_B2_UB(a1, a0, a3, a2, tmp0, tmp1);   \
172    ILVRL_H2_UB(tmp1, tmp0, tmp2, tmp3);      \
173    ST_UB(tmp2, dst +  0);                    \
174    ST_UB(tmp3, dst + 16);                    \
175  } while (0)
176  #define STORE2_16(a0, a1, dst) do {  \
177    v16u8 out0, out1;                  \
178    ILVRL_B2_UB(a1, a0, out0, out1);   \
179    ST_UB(out0, dst +  0);             \
180    ST_UB(out1, dst + 16);             \
181  } while (0)
182  #define STORE2_8(a0, a1, dst) do {                               \
183    const v16u8 out0 = (v16u8)__msa_ilvr_b((v16i8)a1, (v16i8)a0);  \
184    ST_UB(out0, dst);                                              \
185  } while (0)
186  #define CALC_RGBA4444(y, u, v, out0, out1, N, dst) do {  \
187    CALC_RGB##N(y, u, v, R, G, B);                         \
188    tmp0 = ANDI_B(R, 0xf0);                                \
189    tmp1 = SRAI_B(G, 4);                                   \
190    RG = tmp0 | tmp1;                                      \
191    tmp0 = ANDI_B(B, 0xf0);                                \
192    BA = ORI_B(tmp0, 0x0f);                                \
193    STORE2_##N(out0, out1, dst);                           \
194  } while (0)
195  #define CALC_RGB565(y, u, v, out0, out1, N, dst) do {  \
196    CALC_RGB##N(y, u, v, R, G, B);                       \
197    tmp0 = ANDI_B(R, 0xf8);                              \
198    tmp1 = SRAI_B(G, 5);                                 \
199    RG = tmp0 | tmp1;                                    \
200    tmp0 = SLLI_B(G, 3);                                 \
201    tmp1 = ANDI_B(tmp0, 0xe0);                           \
202    tmp0 = SRAI_B(B, 3);                                 \
203    GB = tmp0 | tmp1;                                    \
204    STORE2_##N(out0, out1, dst);                         \
205  } while (0)
206  static WEBP_INLINE int Clip8(int v) {
207    return v &lt; 0 ? 0 : v &gt; 255 ? 255 : v;
208  }
209  static void YuvToRgb(int y, int u, int v, uint8_t* const rgb) {
210    const int y1 = MultHi(y, 19077);
211    const int r1 = y1 + MultHi(v, 26149) - 14234;
212    const int g1 = y1 - MultHi(u, 6419) - MultHi(v, 13320) + 8708;
213    const int b1 = y1 + MultHi(u, 33050) - 17685;
214    rgb[0] = Clip8(r1 &gt;&gt; 6);
215    rgb[1] = Clip8(g1 &gt;&gt; 6);
216    rgb[2] = Clip8(b1 &gt;&gt; 6);
217  }
218  static void YuvToBgr(int y, int u, int v, uint8_t* const bgr) {
219    const int y1 = MultHi(y, 19077);
220    const int r1 = y1 + MultHi(v, 26149) - 14234;
221    const int g1 = y1 - MultHi(u, 6419) - MultHi(v, 13320) + 8708;
222    const int b1 = y1 + MultHi(u, 33050) - 17685;
223    bgr[0] = Clip8(b1 &gt;&gt; 6);
224    bgr[1] = Clip8(g1 &gt;&gt; 6);
225    bgr[2] = Clip8(r1 &gt;&gt; 6);
226  }
227  #if !defined(WEBP_REDUCE_CSP)
228  static void YuvToRgb565(int y, int u, int v, uint8_t* const rgb) {
229    const int y1 = MultHi(y, 19077);
230    const int r1 = y1 + MultHi(v, 26149) - 14234;
231    const int g1 = y1 - MultHi(u, 6419) - MultHi(v, 13320) + 8708;
232    const int b1 = y1 + MultHi(u, 33050) - 17685;
233    const int r = Clip8(r1 &gt;&gt; 6);
234    const int g = Clip8(g1 &gt;&gt; 6);
235    const int b = Clip8(b1 &gt;&gt; 6);
236    const int rg = (r &amp; 0xf8) | (g &gt;&gt; 5);
237    const int gb = ((g &lt;&lt; 3) &amp; 0xe0) | (b &gt;&gt; 3);
238  #if (WEBP_SWAP_16BIT_CSP == 1)
239    rgb[0] = gb;
240    rgb[1] = rg;
241  #else
242    rgb[0] = rg;
243    rgb[1] = gb;
244  #endif
245  }
246  static void YuvToRgba4444(int y, int u, int v, uint8_t* const argb) {
247    const int y1 = MultHi(y, 19077);
248    const int r1 = y1 + MultHi(v, 26149) - 14234;
249    const int g1 = y1 - MultHi(u, 6419) - MultHi(v, 13320) + 8708;
250    const int b1 = y1 + MultHi(u, 33050) - 17685;
251    const int r = Clip8(r1 &gt;&gt; 6);
252    const int g = Clip8(g1 &gt;&gt; 6);
253    const int b = Clip8(b1 &gt;&gt; 6);
254    const int rg = (r &amp; 0xf0) | (g &gt;&gt; 4);
255    const int ba = (b &amp; 0xf0) | 0x0f;     
256  #if (WEBP_SWAP_16BIT_CSP == 1)
257    argb[0] = ba;
258    argb[1] = rg;
259  #else
260    argb[0] = rg;
261    argb[1] = ba;
262  #endif
263  }
264  static void YuvToArgb(uint8_t y, uint8_t u, uint8_t v, uint8_t* const argb) {
265    argb[0] = 0xff;
266    YuvToRgb(y, u, v, argb + 1);
267  }
268  #endif  
269  static void YuvToBgra(uint8_t y, uint8_t u, uint8_t v, uint8_t* const bgra) {
270    YuvToBgr(y, u, v, bgra);
271    bgra[3] = 0xff;
272  }
273  static void YuvToRgba(uint8_t y, uint8_t u, uint8_t v, uint8_t* const rgba) {
274    YuvToRgb(y, u, v, rgba);
275    rgba[3] = 0xff;
276  }
277  #if !defined(WEBP_REDUCE_CSP)
278  static void YuvToRgbLine(const uint8_t* y, const uint8_t* u,
279                           const uint8_t* v, uint8_t* dst, int length) {
280    v16u8 R, G, B;
281    while (length &gt;= 16) {
282      CALC_RGB16(y, u, v, R, G, B);
283      STORE16_3(R, G, B, dst);
284      y      += 16;
285      u      += 16;
286      v      += 16;
287      dst    += 16 * 3;
288      length -= 16;
289    }
290    if (length &gt; 8) {
291      uint8_t temp[3 * 16] = { 0 };
292      memcpy(temp, y, length * sizeof(*temp));
293      CALC_RGB16(temp, u, v, R, G, B);
294      STORE16_3(R, G, B, temp);
295      memcpy(dst, temp, length * 3 * sizeof(*dst));
296    } else if (length &gt; 0) {
297      uint8_t temp[3 * 8] = { 0 };
298      memcpy(temp, y, length * sizeof(*temp));
299      CALC_RGB8(temp, u, v, R, G, B);
300      STORE8_3(R, G, B, temp);
301      memcpy(dst, temp, length * 3 * sizeof(*dst));
302    }
303  }
304  static void YuvToBgrLine(const uint8_t* y, const uint8_t* u,
305                           const uint8_t* v, uint8_t* dst, int length) {
306    v16u8 R, G, B;
307    while (length &gt;= 16) {
308      CALC_RGB16(y, u, v, R, G, B);
309      STORE16_3(B, G, R, dst);
310      y      += 16;
311      u      += 16;
312      v      += 16;
313      dst    += 16 * 3;
314      length -= 16;
315    }
316    if (length &gt; 8) {
317      uint8_t temp[3 * 16] = { 0 };
318      memcpy(temp, y, length * sizeof(*temp));
319      CALC_RGB16(temp, u, v, R, G, B);
320      STORE16_3(B, G, R, temp);
321      memcpy(dst, temp, length * 3 * sizeof(*dst));
322    } else if (length &gt; 0) {
323      uint8_t temp[3 * 8] = { 0 };
324      memcpy(temp, y, length * sizeof(*temp));
325      CALC_RGB8(temp, u, v, R, G, B);
326      STORE8_3(B, G, R, temp);
327      memcpy(dst, temp, length * 3 * sizeof(*dst));
328    }
329  }
330  #endif  
331  static void YuvToRgbaLine(const uint8_t* y, const uint8_t* u,
332                            const uint8_t* v, uint8_t* dst, int length) {
333    v16u8 R, G, B;
334    const v16u8 A = (v16u8)__msa_ldi_b(ALPHAVAL);
335    while (length &gt;= 16) {
336      CALC_RGB16(y, u, v, R, G, B);
337      STORE16_4(R, G, B, A, dst);
338      y      += 16;
339      u      += 16;
340      v      += 16;
341      dst    += 16 * 4;
342      length -= 16;
343    }
344    if (length &gt; 8) {
345      uint8_t temp[4 * 16] = { 0 };
346      memcpy(temp, y, length * sizeof(*temp));
347      CALC_RGB16(&amp;temp[0], u, v, R, G, B);
348      STORE16_4(R, G, B, A, temp);
349      memcpy(dst, temp, length * 4 * sizeof(*dst));
350    } else if (length &gt; 0) {
351      uint8_t temp[4 * 8] = { 0 };
352      memcpy(temp, y, length * sizeof(*temp));
353      CALC_RGB8(temp, u, v, R, G, B);
354      STORE8_4(R, G, B, A, temp);
355      memcpy(dst, temp, length * 4 * sizeof(*dst));
356    }
357  }
358  static void YuvToBgraLine(const uint8_t* y, const uint8_t* u,
359                            const uint8_t* v, uint8_t* dst, int length) {
360    v16u8 R, G, B;
361    const v16u8 A = (v16u8)__msa_ldi_b(ALPHAVAL);
362    while (length &gt;= 16) {
363      CALC_RGB16(y, u, v, R, G, B);
364      STORE16_4(B, G, R, A, dst);
365      y      += 16;
366      u      += 16;
367      v      += 16;
368      dst    += 16 * 4;
369      length -= 16;
370    }
371    if (length &gt; 8) {
372      uint8_t temp[4 * 16] = { 0 };
373      memcpy(temp, y, length * sizeof(*temp));
374      CALC_RGB16(temp, u, v, R, G, B);
375      STORE16_4(B, G, R, A, temp);
376      memcpy(dst, temp, length * 4 * sizeof(*dst));
377    } else if (length &gt; 0) {
378      uint8_t temp[4 * 8] = { 0 };
379      memcpy(temp, y, length * sizeof(*temp));
380      CALC_RGB8(temp, u, v, R, G, B);
381      STORE8_4(B, G, R, A, temp);
382      memcpy(dst, temp, length * 4 * sizeof(*dst));
383    }
384  }
385  #if !defined(WEBP_REDUCE_CSP)
386  static void YuvToArgbLine(const uint8_t* y, const uint8_t* u,
387                            const uint8_t* v, uint8_t* dst, int length) {
388    v16u8 R, G, B;
389    const v16u8 A = (v16u8)__msa_ldi_b(ALPHAVAL);
390    while (length &gt;= 16) {
391      CALC_RGB16(y, u, v, R, G, B);
392      STORE16_4(A, R, G, B, dst);
393      y      += 16;
394      u      += 16;
395      v      += 16;
396      dst    += 16 * 4;
397      length -= 16;
398    }
399    if (length &gt; 8) {
400      uint8_t temp[4 * 16] = { 0 };
401      memcpy(temp, y, length * sizeof(*temp));
402      CALC_RGB16(temp, u, v, R, G, B);
403      STORE16_4(A, R, G, B, temp);
404      memcpy(dst, temp, length * 4 * sizeof(*dst));
405    } else if (length &gt; 0) {
406      uint8_t temp[4 * 8] = { 0 };
407      memcpy(temp, y, length * sizeof(*temp));
408      CALC_RGB8(temp, u, v, R, G, B);
409      STORE8_4(A, R, G, B, temp);
410      memcpy(dst, temp, length * 4 * sizeof(*dst));
411    }
412  }
413  static void YuvToRgba4444Line(const uint8_t* y, const uint8_t* u,
414                                const uint8_t* v, uint8_t* dst, int length) {
415    v16u8 R, G, B, RG, BA, tmp0, tmp1;
416    while (length &gt;= 16) {
417  #if (WEBP_SWAP_16BIT_CSP == 1)
418      CALC_RGBA4444(y, u, v, BA, RG, 16, dst);
419  #else
420      CALC_RGBA4444(y, u, v, RG, BA, 16, dst);
421  #endif
422      y      += 16;
423      u      += 16;
424      v      += 16;
425      dst    += 16 * 2;
426      length -= 16;
427    }
428    if (length &gt; 8) {
429      uint8_t temp[2 * 16] = { 0 };
430      memcpy(temp, y, length * sizeof(*temp));
431  #if (WEBP_SWAP_16BIT_CSP == 1)
432      CALC_RGBA4444(temp, u, v, BA, RG, 16, temp);
433  #else
434      CALC_RGBA4444(temp, u, v, RG, BA, 16, temp);
435  #endif
436      memcpy(dst, temp, length * 2 * sizeof(*dst));
437    } else if (length &gt; 0) {
438      uint8_t temp[2 * 8] = { 0 };
439      memcpy(temp, y, length * sizeof(*temp));
440  #if (WEBP_SWAP_16BIT_CSP == 1)
441      CALC_RGBA4444(temp, u, v, BA, RG, 8, temp);
442  #else
443      CALC_RGBA4444(temp, u, v, RG, BA, 8, temp);
444  #endif
445      memcpy(dst, temp, length * 2 * sizeof(*dst));
446    }
447  }
448  static void YuvToRgb565Line(const uint8_t* y, const uint8_t* u,
449                              const uint8_t* v, uint8_t* dst, int length) {
450    v16u8 R, G, B, RG, GB, tmp0, tmp1;
451    while (length &gt;= 16) {
452  #if (WEBP_SWAP_16BIT_CSP == 1)
453      CALC_RGB565(y, u, v, GB, RG, 16, dst);
454  #else
455      CALC_RGB565(y, u, v, RG, GB, 16, dst);
456  #endif
457      y      += 16;
458      u      += 16;
459      v      += 16;
460      dst    += 16 * 2;
461      length -= 16;
462    }
463    if (length &gt; 8) {
464      uint8_t temp[2 * 16] = { 0 };
465      memcpy(temp, y, length * sizeof(*temp));
466  #if (WEBP_SWAP_16BIT_CSP == 1)
467      CALC_RGB565(temp, u, v, GB, RG, 16, temp);
468  #else
469      CALC_RGB565(temp, u, v, RG, GB, 16, temp);
470  #endif
471      memcpy(dst, temp, length * 2 * sizeof(*dst));
472    } else if (length &gt; 0) {
473      uint8_t temp[2 * 8] = { 0 };
474      memcpy(temp, y, length * sizeof(*temp));
475  #if (WEBP_SWAP_16BIT_CSP == 1)
476      CALC_RGB565(temp, u, v, GB, RG, 8, temp);
477  #else
478      CALC_RGB565(temp, u, v, RG, GB, 8, temp);
479  #endif
480      memcpy(dst, temp, length * 2 * sizeof(*dst));
481    }
482  }
483  #endif  
484  #define UPSAMPLE_32PIXELS(a, b, c, d) do {    \
485    v16u8 s = __msa_aver_u_b(a, d);             \
486    v16u8 t = __msa_aver_u_b(b, c);             \
487    const v16u8 st = s ^ t;                     \
488    v16u8 ad = a ^ d;                           \
489    v16u8 bc = b ^ c;                           \
490    v16u8 t0 = ad | bc;                         \
491    v16u8 t1 = t0 | st;                         \
492    v16u8 t2 = ANDI_B(t1, 1);                   \
493    v16u8 t3 = __msa_aver_u_b(s, t);            \
494    const v16u8 k = t3 - t2;                    \
495    v16u8 diag1, diag2;                         \
496    AVER_UB2_UB(t, k, s, k, t0, t1);            \
497    bc = bc &amp; st;                               \
498    ad = ad &amp; st;                               \
499    t = t ^ k;                                  \
500    s = s ^ k;                                  \
501    t2 = bc | t;                                \
502    t3 = ad | s;                                \
503    t2 = ANDI_B(t2, 1);                         \
504    t3 = ANDI_B(t3, 1);                         \
505    SUB2(t0, t2, t1, t3, diag1, diag2);         \
506    AVER_UB2_UB(a, diag1, b, diag2, t0, t1);    \
507    ILVRL_B2_UB(t1, t0, a, b);                  \
508    if (pbot_y != NULL) {                       \
509      AVER_UB2_UB(c, diag2, d, diag1, t0, t1);  \
510      ILVRL_B2_UB(t1, t0, c, d);                \
511    }                                           \
512  } while (0)
513  #define UPSAMPLE_FUNC(FUNC_NAME, FUNC, XSTEP)                            \
514  static void FUNC_NAME(const uint8_t* top_y, const uint8_t* bot_y,        \
515                        const uint8_t* top_u, const uint8_t* top_v,        \
516                        const uint8_t* cur_u, const uint8_t* cur_v,        \
517                        uint8_t* top_dst, uint8_t* bot_dst, int len)       \
518  {                                                                        \
519    int size = (len - 1) &gt;&gt; 1;                                             \
520    uint8_t temp_u[64];                                                    \
521    uint8_t temp_v[64];                                                    \
522    const uint32_t tl_uv = ((top_u[0]) | ((top_v[0]) &lt;&lt; 16));              \
523    const uint32_t l_uv = ((cur_u[0]) | ((cur_v[0]) &lt;&lt; 16));               \
524    const uint32_t uv0 = (3 * tl_uv + l_uv + 0x00020002u) &gt;&gt; 2;            \
525    const uint8_t* ptop_y = &amp;top_y[1];                                     \
526    uint8_t* ptop_dst = top_dst + XSTEP;                                   \
527    const uint8_t* pbot_y = &amp;bot_y[1];                                     \
528    uint8_t* pbot_dst = bot_dst + XSTEP;                                   \
529                                                                           \
530    FUNC(top_y[0], uv0 &amp; 0xff, (uv0 &gt;&gt; 16), top_dst);                      \
531    if (bot_y != NULL) {                                                   \
532      const uint32_t uv1 = (3 * l_uv + tl_uv + 0x00020002u) &gt;&gt; 2;          \
533      FUNC(bot_y[0], uv1 &amp; 0xff, (uv1 &gt;&gt; 16), bot_dst);                    \
534    }                                                                      \
535    while (size &gt;= 16) {                                                   \
536      v16u8 tu0, tu1, tv0, tv1, cu0, cu1, cv0, cv1;                        \
537      LD_UB2(top_u, 1, tu0, tu1);                                          \
538      LD_UB2(cur_u, 1, cu0, cu1);                                          \
539      LD_UB2(top_v, 1, tv0, tv1);                                          \
540      LD_UB2(cur_v, 1, cv0, cv1);                                          \
541      UPSAMPLE_32PIXELS(tu0, tu1, cu0, cu1);                               \
542      UPSAMPLE_32PIXELS(tv0, tv1, cv0, cv1);                               \
543      ST_UB4(tu0, tu1, cu0, cu1, &amp;temp_u[0], 16);                          \
544      ST_UB4(tv0, tv1, cv0, cv1, &amp;temp_v[0], 16);                          \
545      FUNC##Line(ptop_y, &amp;temp_u[ 0], &amp;temp_v[0], ptop_dst, 32);           \
546      if (bot_y != NULL) {                                                 \
547        FUNC##Line(pbot_y, &amp;temp_u[32], &amp;temp_v[32], pbot_dst, 32);        \
548      }                                                                    \
549      ptop_y   += 32;                                                      \
550      pbot_y   += 32;                                                      \
551      ptop_dst += XSTEP * 32;                                              \
552      pbot_dst += XSTEP * 32;                                              \
553      top_u    += 16;                                                      \
554      top_v    += 16;                                                      \
555      cur_u    += 16;                                                      \
556      cur_v    += 16;                                                      \
557      size     -= 16;                                                      \
558    }                                                                      \
559    if (size &gt; 0) {                                                        \
560      v16u8 tu0, tu1, tv0, tv1, cu0, cu1, cv0, cv1;                        \
561      memcpy(&amp;temp_u[ 0], top_u, 17 * sizeof(uint8_t));                    \
562      memcpy(&amp;temp_u[32], cur_u, 17 * sizeof(uint8_t));                    \
563      memcpy(&amp;temp_v[ 0], top_v, 17 * sizeof(uint8_t));                    \
564      memcpy(&amp;temp_v[32], cur_v, 17 * sizeof(uint8_t));                    \
565      LD_UB2(&amp;temp_u[ 0], 1, tu0, tu1);                                    \
566      LD_UB2(&amp;temp_u[32], 1, cu0, cu1);                                    \
567      LD_UB2(&amp;temp_v[ 0], 1, tv0, tv1);                                    \
568      LD_UB2(&amp;temp_v[32], 1, cv0, cv1);                                    \
569      UPSAMPLE_32PIXELS(tu0, tu1, cu0, cu1);                               \
570      UPSAMPLE_32PIXELS(tv0, tv1, cv0, cv1);                               \
571      ST_UB4(tu0, tu1, cu0, cu1, &amp;temp_u[0], 16);                          \
572      ST_UB4(tv0, tv1, cv0, cv1, &amp;temp_v[0], 16);                          \
573      FUNC##Line(ptop_y, &amp;temp_u[ 0], &amp;temp_v[0], ptop_dst, size * 2);     \
574      if (bot_y != NULL) {                                                 \
575        FUNC##Line(pbot_y, &amp;temp_u[32], &amp;temp_v[32], pbot_dst, size * 2);  \
576      }                                                                    \
577      top_u += size;                                                       \
578      top_v += size;                                                       \
579      cur_u += size;                                                       \
580      cur_v += size;                                                       \
581    }                                                                      \
582    if (!(len &amp; 1)) {                                                      \
583      const uint32_t t0 = ((top_u[0]) | ((top_v[0]) &lt;&lt; 16));               \
584      const uint32_t c0  = ((cur_u[0]) | ((cur_v[0]) &lt;&lt; 16));              \
585      const uint32_t tmp0 = (3 * t0 + c0 + 0x00020002u) &gt;&gt; 2;              \
586      FUNC(top_y[len - 1], tmp0 &amp; 0xff, (tmp0 &gt;&gt; 16),                      \
587                  top_dst + (len - 1) * XSTEP);                            \
588      if (bot_y != NULL) {                                                 \
589        const uint32_t tmp1 = (3 * c0 + t0 + 0x00020002u) &gt;&gt; 2;            \
590        FUNC(bot_y[len - 1], tmp1 &amp; 0xff, (tmp1 &gt;&gt; 16),                    \
591             bot_dst + (len - 1) * XSTEP);                                 \
592      }                                                                    \
593    }                                                                      \
594  }
595  UPSAMPLE_FUNC(UpsampleRgbaLinePair,     YuvToRgba,     4)
596  UPSAMPLE_FUNC(UpsampleBgraLinePair,     YuvToBgra,     4)
597  #if !defined(WEBP_REDUCE_CSP)
598  UPSAMPLE_FUNC(UpsampleRgbLinePair,      YuvToRgb,      3)
599  UPSAMPLE_FUNC(UpsampleBgrLinePair,      YuvToBgr,      3)
600  UPSAMPLE_FUNC(UpsampleArgbLinePair,     YuvToArgb,     4)
601  UPSAMPLE_FUNC(UpsampleRgba4444LinePair, YuvToRgba4444, 2)
602  UPSAMPLE_FUNC(UpsampleRgb565LinePair,   YuvToRgb565,   2)
603  #endif   
604  extern WebPUpsampleLinePairFunc WebPUpsamplers[&amp;bsol;* MODE_LAST */];
605  extern void WebPInitUpsamplersMSA(void);
606  WEBP_TSAN_IGNORE_FUNCTION void WebPInitUpsamplersMSA(void) {
607    WebPUpsamplers[MODE_RGBA]      = UpsampleRgbaLinePair;
608    WebPUpsamplers[MODE_BGRA]      = UpsampleBgraLinePair;
609    WebPUpsamplers[MODE_rgbA]      = UpsampleRgbaLinePair;
610    WebPUpsamplers[MODE_bgrA]      = UpsampleBgraLinePair;
611  #if !defined(WEBP_REDUCE_CSP)
612    WebPUpsamplers[MODE_RGB]       = UpsampleRgbLinePair;
613    WebPUpsamplers[MODE_BGR]       = UpsampleBgrLinePair;
614    WebPUpsamplers[MODE_ARGB]      = UpsampleArgbLinePair;
615    WebPUpsamplers[MODE_Argb]      = UpsampleArgbLinePair;
616    WebPUpsamplers[MODE_RGB_565]   = UpsampleRgb565LinePair;
617    WebPUpsamplers[MODE_RGBA_4444] = UpsampleRgba4444LinePair;
618    WebPUpsamplers[MODE_rgbA_4444] = UpsampleRgba4444LinePair;
619  #endif   
620  }
621  #endif  
622  #endif  
623  #if !(defined(FANCY_UPSAMPLING) &amp;&amp; defined(WEBP_USE_MSA))
624  WEBP_DSP_INIT_STUB(WebPInitUpsamplersMSA)
625  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-upsampling_msa.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-upsampling_msa.c</div>
                </div>
                <div class="column column_space"><pre><code>104    MULTHI_16(p0, p1, p2, p3, 33050, u0, u1);  \
105    CALC_B16(y0, y1, u0, u1, B);               \
</pre></code></div>
                <div class="column column_space"><pre><code>100    MULTHI_16(p0, p1, p2, p3, 13320, v0, v1);  \
101    ILVRL_UW4(in_u, p0, p1, p2, p3);           \
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    