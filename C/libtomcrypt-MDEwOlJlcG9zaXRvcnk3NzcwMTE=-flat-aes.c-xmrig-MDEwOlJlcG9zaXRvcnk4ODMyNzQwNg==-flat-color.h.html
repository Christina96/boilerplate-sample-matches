
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.397163120567376%, Tokens: 19</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-aes.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RIJNDAEL
3  #ifndef ENCRYPT_ONLY
4  #define SETUP    rijndael_setup
5  #define ECB_ENC  rijndael_ecb_encrypt
6  #define ECB_DEC  rijndael_ecb_decrypt
7  #define ECB_DONE rijndael_done
8  #define ECB_TEST rijndael_test
9  #define ECB_KS   rijndael_keysize
10  const struct ltc_cipher_descriptor rijndael_desc =
11  {
12      "rijndael",
13      6,
14      16, 32, 16, 10,
15      SETUP, ECB_ENC, ECB_DEC, ECB_TEST, ECB_DONE, ECB_KS,
16      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
17  };
18  const struct ltc_cipher_descriptor aes_desc =
19  {
20      "aes",
21      6,
22      16, 32, 16, 10,
23      SETUP, ECB_ENC, ECB_DEC, ECB_TEST, ECB_DONE, ECB_KS,
24      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
25  };
26  #else
27  #define SETUP    rijndael_enc_setup
28  #define ECB_ENC  rijndael_enc_ecb_encrypt
29  #define ECB_KS   rijndael_enc_keysize
30  #define ECB_DONE rijndael_enc_done
31  const struct ltc_cipher_descriptor rijndael_enc_desc =
32  {
33      "rijndael",
34      6,
35      16, 32, 16, 10,
36      SETUP, ECB_ENC, NULL, NULL, ECB_DONE, ECB_KS,
37      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
38  };
39  const struct ltc_cipher_descriptor aes_enc_desc =
40  {
41      "aes",
42      6,
43      16, 32, 16, 10,
44      SETUP, ECB_ENC, NULL, NULL, ECB_DONE, ECB_KS,
45      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
46  };
47  #endif
48  #define LTC_AES_TAB_C
49  #include "aes_tab.c"
50  static ulong32 setup_mix(ulong32 temp)
51  {
52     return (Te4_3[LTC_BYTE(temp, 2)]) ^
53            (Te4_2[LTC_BYTE(temp, 1)]) ^
54            (Te4_1[LTC_BYTE(temp, 0)]) ^
55            (Te4_0[LTC_BYTE(temp, 3)]);
56  }
57  #ifndef ENCRYPT_ONLY
58  #ifdef LTC_SMALL_CODE
59  static ulong32 setup_mix2(ulong32 temp)
60  {
61     return Td0(255 & Te4[LTC_BYTE(temp, 3)]) ^
62            Td1(255 & Te4[LTC_BYTE(temp, 2)]) ^
63            Td2(255 & Te4[LTC_BYTE(temp, 1)]) ^
64            Td3(255 & Te4[LTC_BYTE(temp, 0)]);
65  }
66  #endif
67  #endif
68  int SETUP(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
69  {
70      int i;
71      ulong32 temp, *rk;
72  #ifndef ENCRYPT_ONLY
73      ulong32 *rrk;
74  #endif
75      LTC_ARGCHK(key  != NULL);
76      LTC_ARGCHK(skey != NULL);
77      if (keylen != 16 && keylen != 24 && keylen != 32) {
78         return CRYPT_INVALID_KEYSIZE;
79      }
80      if (num_rounds != 0 && num_rounds != (10 + ((keylen/8)-2)*2)) {
81         return CRYPT_INVALID_ROUNDS;
82      }
83      skey->rijndael.Nr = 10 + ((keylen/8)-2)*2;
84      i                 = 0;
85      rk                = skey->rijndael.eK;
86      LOAD32H(rk[0], key     );
87      LOAD32H(rk[1], key +  4);
88      LOAD32H(rk[2], key +  8);
89      LOAD32H(rk[3], key + 12);
90      if (keylen == 16) {
91          for (;;) {
92              temp  = rk[3];
93              rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
94              rk[5] = rk[1] ^ rk[4];
95              rk[6] = rk[2] ^ rk[5];
96              rk[7] = rk[3] ^ rk[6];
97              if (++i == 10) {
98                 break;
99              }
100              rk += 4;
101          }
102      } else if (keylen == 24) {
103          LOAD32H(rk[4], key + 16);
104          LOAD32H(rk[5], key + 20);
105          for (;;) {
106          #ifdef _MSC_VER
107              temp = skey->rijndael.eK[rk - skey->rijndael.eK + 5];
108          #else
109              temp = rk[5];
110          #endif
111              rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
112              rk[ 7] = rk[ 1] ^ rk[ 6];
113              rk[ 8] = rk[ 2] ^ rk[ 7];
114              rk[ 9] = rk[ 3] ^ rk[ 8];
115              if (++i == 8) {
116                  break;
117              }
118              rk[10] = rk[ 4] ^ rk[ 9];
119              rk[11] = rk[ 5] ^ rk[10];
120              rk += 6;
121          }
122      } else if (keylen == 32) {
123          LOAD32H(rk[4], key + 16);
124          LOAD32H(rk[5], key + 20);
125          LOAD32H(rk[6], key + 24);
126          LOAD32H(rk[7], key + 28);
127          for (;;) {
128          #ifdef _MSC_VER
129              temp = skey->rijndael.eK[rk - skey->rijndael.eK + 7];
130          #else
131              temp = rk[7];
132          #endif
133              rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
134              rk[ 9] = rk[ 1] ^ rk[ 8];
135              rk[10] = rk[ 2] ^ rk[ 9];
136              rk[11] = rk[ 3] ^ rk[10];
137              if (++i == 7) {
138                  break;
139              }
140              temp = rk[11];
141              rk[12] = rk[ 4] ^ setup_mix(RORc(temp, 8));
142              rk[13] = rk[ 5] ^ rk[12];
143              rk[14] = rk[ 6] ^ rk[13];
144              rk[15] = rk[ 7] ^ rk[14];
145              rk += 8;
146          }
147      } else {
148         return CRYPT_ERROR;
149      }
150  #ifndef ENCRYPT_ONLY
151      rk   = skey->rijndael.dK;
152      rrk  = skey->rijndael.eK + (28 + keylen) - 4;
153      *rk++ = *rrk++;
154      *rk++ = *rrk++;
155      *rk++ = *rrk++;
156      *rk   = *rrk;
157      rk -= 3; rrk -= 3;
<span onclick='openModal()' class='match'>158      for (i = 1; i < skey->rijndael.Nr; i++) {
159          rrk -= 4;
160          rk  += 4;
161      #ifdef LTC_SMALL_CODE
162          temp = rrk[0];
163          rk[0] = setup_mix2(temp);
164          temp = rrk[1];
165          rk[1] = setup_mix2(temp);
166          temp = rrk[2];
167          rk[2] = setup_mix2(temp);
168          temp = rrk[3];
169          rk[3] = setup_mix2(temp);
170       #else
171          temp = rrk[0];
172          rk[0] =
173              Tks0[LTC_BYTE(temp, 3)] ^
174              Tks1[LTC_BYTE(temp, 2)] ^
175              Tks2[LTC_BYTE(temp, 1)] ^
176              Tks3[LTC_BYTE(temp, 0)];
177          temp = rrk[1];
178          rk[1] =
179              Tks0[LTC_BYTE(temp, 3)] ^
180              Tks1[LTC_BYTE(temp, 2)] ^
181              Tks2[LTC_BYTE(temp, 1)] ^
182              Tks3[LTC_BYTE(temp, 0)];
183          temp = rrk[2];
184          rk[2] =
185              Tks0[LTC_BYTE(temp, 3)] ^
186              Tks1[LTC_BYTE(temp, 2)] ^
187              Tks2[LTC_BYTE(temp, 1)] ^
188              Tks3[LTC_BYTE(temp, 0)];
189          temp = rrk[3];
190          rk[3] =
</span>191              Tks0[LTC_BYTE(temp, 3)] ^
192              Tks1[LTC_BYTE(temp, 2)] ^
193              Tks2[LTC_BYTE(temp, 1)] ^
194              Tks3[LTC_BYTE(temp, 0)];
195        #endif
196      }
197      rrk -= 4;
198      rk  += 4;
199      *rk++ = *rrk++;
200      *rk++ = *rrk++;
201      *rk++ = *rrk++;
202      *rk   = *rrk;
203  #endif &bsol;* ENCRYPT_ONLY */
204      return CRYPT_OK;
205  }
206  #ifdef LTC_CLEAN_STACK
207  static int s_rijndael_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
208  #else
209  int ECB_ENC(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
210  #endif
211  {
212      ulong32 s0, s1, s2, s3, t0, t1, t2, t3;
213      const ulong32 *rk;
214      int Nr, r;
215      LTC_ARGCHK(pt != NULL);
216      LTC_ARGCHK(ct != NULL);
217      LTC_ARGCHK(skey != NULL);
218      Nr = skey->rijndael.Nr;
219      if (Nr < 2 || Nr > 16)
220          return CRYPT_INVALID_ROUNDS;
221      rk = skey->rijndael.eK;
222      LOAD32H(s0, pt      ); s0 ^= rk[0];
223      LOAD32H(s1, pt  +  4); s1 ^= rk[1];
224      LOAD32H(s2, pt  +  8); s2 ^= rk[2];
225      LOAD32H(s3, pt  + 12); s3 ^= rk[3];
226  #ifdef LTC_SMALL_CODE
227      for (r = 0; ; r++) {
228          rk += 4;
229          t0 =
230              Te0(LTC_BYTE(s0, 3)) ^
231              Te1(LTC_BYTE(s1, 2)) ^
232              Te2(LTC_BYTE(s2, 1)) ^
233              Te3(LTC_BYTE(s3, 0)) ^
234              rk[0];
235          t1 =
236              Te0(LTC_BYTE(s1, 3)) ^
237              Te1(LTC_BYTE(s2, 2)) ^
238              Te2(LTC_BYTE(s3, 1)) ^
239              Te3(LTC_BYTE(s0, 0)) ^
240              rk[1];
241          t2 =
242              Te0(LTC_BYTE(s2, 3)) ^
243              Te1(LTC_BYTE(s3, 2)) ^
244              Te2(LTC_BYTE(s0, 1)) ^
245              Te3(LTC_BYTE(s1, 0)) ^
246              rk[2];
247          t3 =
248              Te0(LTC_BYTE(s3, 3)) ^
249              Te1(LTC_BYTE(s0, 2)) ^
250              Te2(LTC_BYTE(s1, 1)) ^
251              Te3(LTC_BYTE(s2, 0)) ^
252              rk[3];
253          if (r == Nr-2) {
254             break;
255          }
256          s0 = t0; s1 = t1; s2 = t2; s3 = t3;
257      }
258      rk += 4;
259  #else
260      r = Nr >> 1;
261      for (;;) {
262          t0 =
263              Te0(LTC_BYTE(s0, 3)) ^
264              Te1(LTC_BYTE(s1, 2)) ^
265              Te2(LTC_BYTE(s2, 1)) ^
266              Te3(LTC_BYTE(s3, 0)) ^
267              rk[4];
268          t1 =
269              Te0(LTC_BYTE(s1, 3)) ^
270              Te1(LTC_BYTE(s2, 2)) ^
271              Te2(LTC_BYTE(s3, 1)) ^
272              Te3(LTC_BYTE(s0, 0)) ^
273              rk[5];
274          t2 =
275              Te0(LTC_BYTE(s2, 3)) ^
276              Te1(LTC_BYTE(s3, 2)) ^
277              Te2(LTC_BYTE(s0, 1)) ^
278              Te3(LTC_BYTE(s1, 0)) ^
279              rk[6];
280          t3 =
281              Te0(LTC_BYTE(s3, 3)) ^
282              Te1(LTC_BYTE(s0, 2)) ^
283              Te2(LTC_BYTE(s1, 1)) ^
284              Te3(LTC_BYTE(s2, 0)) ^
285              rk[7];
286          rk += 8;
287          if (--r == 0) {
288              break;
289          }
290          s0 =
291              Te0(LTC_BYTE(t0, 3)) ^
292              Te1(LTC_BYTE(t1, 2)) ^
293              Te2(LTC_BYTE(t2, 1)) ^
294              Te3(LTC_BYTE(t3, 0)) ^
295              rk[0];
296          s1 =
297              Te0(LTC_BYTE(t1, 3)) ^
298              Te1(LTC_BYTE(t2, 2)) ^
299              Te2(LTC_BYTE(t3, 1)) ^
300              Te3(LTC_BYTE(t0, 0)) ^
301              rk[1];
302          s2 =
303              Te0(LTC_BYTE(t2, 3)) ^
304              Te1(LTC_BYTE(t3, 2)) ^
305              Te2(LTC_BYTE(t0, 1)) ^
306              Te3(LTC_BYTE(t1, 0)) ^
307              rk[2];
308          s3 =
309              Te0(LTC_BYTE(t3, 3)) ^
310              Te1(LTC_BYTE(t0, 2)) ^
311              Te2(LTC_BYTE(t1, 1)) ^
312              Te3(LTC_BYTE(t2, 0)) ^
313              rk[3];
314      }
315  #endif
316      s0 =
317          (Te4_3[LTC_BYTE(t0, 3)]) ^
318          (Te4_2[LTC_BYTE(t1, 2)]) ^
319          (Te4_1[LTC_BYTE(t2, 1)]) ^
320          (Te4_0[LTC_BYTE(t3, 0)]) ^
321          rk[0];
322      STORE32H(s0, ct);
323      s1 =
324          (Te4_3[LTC_BYTE(t1, 3)]) ^
325          (Te4_2[LTC_BYTE(t2, 2)]) ^
326          (Te4_1[LTC_BYTE(t3, 1)]) ^
327          (Te4_0[LTC_BYTE(t0, 0)]) ^
328          rk[1];
329      STORE32H(s1, ct+4);
330      s2 =
331          (Te4_3[LTC_BYTE(t2, 3)]) ^
332          (Te4_2[LTC_BYTE(t3, 2)]) ^
333          (Te4_1[LTC_BYTE(t0, 1)]) ^
334          (Te4_0[LTC_BYTE(t1, 0)]) ^
335          rk[2];
336      STORE32H(s2, ct+8);
337      s3 =
338          (Te4_3[LTC_BYTE(t3, 3)]) ^
339          (Te4_2[LTC_BYTE(t0, 2)]) ^
340          (Te4_1[LTC_BYTE(t1, 1)]) ^
341          (Te4_0[LTC_BYTE(t2, 0)]) ^
342          rk[3];
343      STORE32H(s3, ct+12);
344      return CRYPT_OK;
345  }
346  #ifdef LTC_CLEAN_STACK
347  int ECB_ENC(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
348  {
349     int err = s_rijndael_ecb_encrypt(pt, ct, skey);
350     burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
351     return err;
352  }
353  #endif
354  #ifndef ENCRYPT_ONLY
355  #ifdef LTC_CLEAN_STACK
356  static int s_rijndael_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
357  #else
358  int ECB_DEC(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
359  #endif
360  {
361      ulong32 s0, s1, s2, s3, t0, t1, t2, t3;
362      const ulong32 *rk;
363      int Nr, r;
364      LTC_ARGCHK(pt != NULL);
365      LTC_ARGCHK(ct != NULL);
366      LTC_ARGCHK(skey != NULL);
367      Nr = skey->rijndael.Nr;
368      if (Nr < 2 || Nr > 16)
369          return CRYPT_INVALID_ROUNDS;
370      rk = skey->rijndael.dK;
371      LOAD32H(s0, ct      ); s0 ^= rk[0];
372      LOAD32H(s1, ct  +  4); s1 ^= rk[1];
373      LOAD32H(s2, ct  +  8); s2 ^= rk[2];
374      LOAD32H(s3, ct  + 12); s3 ^= rk[3];
375  #ifdef LTC_SMALL_CODE
376      for (r = 0; ; r++) {
377          rk += 4;
378          t0 =
379              Td0(LTC_BYTE(s0, 3)) ^
380              Td1(LTC_BYTE(s3, 2)) ^
381              Td2(LTC_BYTE(s2, 1)) ^
382              Td3(LTC_BYTE(s1, 0)) ^
383              rk[0];
384          t1 =
385              Td0(LTC_BYTE(s1, 3)) ^
386              Td1(LTC_BYTE(s0, 2)) ^
387              Td2(LTC_BYTE(s3, 1)) ^
388              Td3(LTC_BYTE(s2, 0)) ^
389              rk[1];
390          t2 =
391              Td0(LTC_BYTE(s2, 3)) ^
392              Td1(LTC_BYTE(s1, 2)) ^
393              Td2(LTC_BYTE(s0, 1)) ^
394              Td3(LTC_BYTE(s3, 0)) ^
395              rk[2];
396          t3 =
397              Td0(LTC_BYTE(s3, 3)) ^
398              Td1(LTC_BYTE(s2, 2)) ^
399              Td2(LTC_BYTE(s1, 1)) ^
400              Td3(LTC_BYTE(s0, 0)) ^
401              rk[3];
402          if (r == Nr-2) {
403             break;
404          }
405          s0 = t0; s1 = t1; s2 = t2; s3 = t3;
406      }
407      rk += 4;
408  #else
409      r = Nr >> 1;
410      for (;;) {
411          t0 =
412              Td0(LTC_BYTE(s0, 3)) ^
413              Td1(LTC_BYTE(s3, 2)) ^
414              Td2(LTC_BYTE(s2, 1)) ^
415              Td3(LTC_BYTE(s1, 0)) ^
416              rk[4];
417          t1 =
418              Td0(LTC_BYTE(s1, 3)) ^
419              Td1(LTC_BYTE(s0, 2)) ^
420              Td2(LTC_BYTE(s3, 1)) ^
421              Td3(LTC_BYTE(s2, 0)) ^
422              rk[5];
423          t2 =
424              Td0(LTC_BYTE(s2, 3)) ^
425              Td1(LTC_BYTE(s1, 2)) ^
426              Td2(LTC_BYTE(s0, 1)) ^
427              Td3(LTC_BYTE(s3, 0)) ^
428              rk[6];
429          t3 =
430              Td0(LTC_BYTE(s3, 3)) ^
431              Td1(LTC_BYTE(s2, 2)) ^
432              Td2(LTC_BYTE(s1, 1)) ^
433              Td3(LTC_BYTE(s0, 0)) ^
434              rk[7];
435          rk += 8;
436          if (--r == 0) {
437              break;
438          }
439          s0 =
440              Td0(LTC_BYTE(t0, 3)) ^
441              Td1(LTC_BYTE(t3, 2)) ^
442              Td2(LTC_BYTE(t2, 1)) ^
443              Td3(LTC_BYTE(t1, 0)) ^
444              rk[0];
445          s1 =
446              Td0(LTC_BYTE(t1, 3)) ^
447              Td1(LTC_BYTE(t0, 2)) ^
448              Td2(LTC_BYTE(t3, 1)) ^
449              Td3(LTC_BYTE(t2, 0)) ^
450              rk[1];
451          s2 =
452              Td0(LTC_BYTE(t2, 3)) ^
453              Td1(LTC_BYTE(t1, 2)) ^
454              Td2(LTC_BYTE(t0, 1)) ^
455              Td3(LTC_BYTE(t3, 0)) ^
456              rk[2];
457          s3 =
458              Td0(LTC_BYTE(t3, 3)) ^
459              Td1(LTC_BYTE(t2, 2)) ^
460              Td2(LTC_BYTE(t1, 1)) ^
461              Td3(LTC_BYTE(t0, 0)) ^
462              rk[3];
463      }
464  #endif
465      s0 =
466          (Td4[LTC_BYTE(t0, 3)] & 0xff000000) ^
467          (Td4[LTC_BYTE(t3, 2)] & 0x00ff0000) ^
468          (Td4[LTC_BYTE(t2, 1)] & 0x0000ff00) ^
469          (Td4[LTC_BYTE(t1, 0)] & 0x000000ff) ^
470          rk[0];
471      STORE32H(s0, pt);
472      s1 =
473          (Td4[LTC_BYTE(t1, 3)] & 0xff000000) ^
474          (Td4[LTC_BYTE(t0, 2)] & 0x00ff0000) ^
475          (Td4[LTC_BYTE(t3, 1)] & 0x0000ff00) ^
476          (Td4[LTC_BYTE(t2, 0)] & 0x000000ff) ^
477          rk[1];
478      STORE32H(s1, pt+4);
479      s2 =
480          (Td4[LTC_BYTE(t2, 3)] & 0xff000000) ^
481          (Td4[LTC_BYTE(t1, 2)] & 0x00ff0000) ^
482          (Td4[LTC_BYTE(t0, 1)] & 0x0000ff00) ^
483          (Td4[LTC_BYTE(t3, 0)] & 0x000000ff) ^
484          rk[2];
485      STORE32H(s2, pt+8);
486      s3 =
487          (Td4[LTC_BYTE(t3, 3)] & 0xff000000) ^
488          (Td4[LTC_BYTE(t2, 2)] & 0x00ff0000) ^
489          (Td4[LTC_BYTE(t1, 1)] & 0x0000ff00) ^
490          (Td4[LTC_BYTE(t0, 0)] & 0x000000ff) ^
491          rk[3];
492      STORE32H(s3, pt+12);
493      return CRYPT_OK;
494  }
495  #ifdef LTC_CLEAN_STACK
496  int ECB_DEC(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
497  {
498     int err = s_rijndael_ecb_decrypt(ct, pt, skey);
499     burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
500     return err;
501  }
502  #endif
503  int ECB_TEST(void)
504  {
505   #ifndef LTC_TEST
506      return CRYPT_NOP;
507   #else
508   int err;
509   static const struct {
510       int keylen;
511       unsigned char key[32], pt[16], ct[16];
512   } tests[] = {
513      { 16,
514        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
515          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
516        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
517          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
518        { 0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
519          0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a }
520      }, {
521        24,
522        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
523          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
524          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 },
525        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
526          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
527        { 0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0,
528          0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91 }
529      }, {
530        32,
531        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
532          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
533          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
534          0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
535        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
536          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
537        { 0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf,
538          0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89 }
539      }
540   };
541    symmetric_key key;
542    unsigned char tmp[2][16];
543    int i, y;
544    for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
545      zeromem(&key, sizeof(key));
546      if ((err = rijndael_setup(tests[i].key, tests[i].keylen, 0, &key)) != CRYPT_OK) {
547         return err;
548      }
549      rijndael_ecb_encrypt(tests[i].pt, tmp[0], &key);
550      rijndael_ecb_decrypt(tmp[0], tmp[1], &key);
551      if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "AES Encrypt", i) ||
552            compare_testvector(tmp[1], 16, tests[i].pt, 16, "AES Decrypt", i)) {
553          return CRYPT_FAIL_TESTVECTOR;
554      }
555      for (y = 0; y < 16; y++) tmp[0][y] = 0;
556      for (y = 0; y < 1000; y++) rijndael_ecb_encrypt(tmp[0], tmp[0], &key);
557      for (y = 0; y < 1000; y++) rijndael_ecb_decrypt(tmp[0], tmp[0], &key);
558      for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
559    }
560    return CRYPT_OK;
561   #endif
562  }
563  #endif &bsol;* ENCRYPT_ONLY */
564  void ECB_DONE(symmetric_key *skey)
565  {
566    LTC_UNUSED_PARAM(skey);
567  }
568  int ECB_KS(int *keysize)
569  {
570     LTC_ARGCHK(keysize != NULL);
571     if (*keysize < 16) {
572        return CRYPT_INVALID_KEYSIZE;
573     }
574     if (*keysize < 24) {
575        *keysize = 16;
576        return CRYPT_OK;
577     }
578     if (*keysize < 32) {
579        *keysize = 24;
580        return CRYPT_OK;
581     }
582     *keysize = 32;
583     return CRYPT_OK;
584  }
585  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-color.h</h3>
            <pre><code>1  #ifndef FMT_COLOR_H_
2  #define FMT_COLOR_H_
3  #include "format.h"
4  FMT_BEGIN_NAMESPACE
<span onclick='openModal()' class='match'>5  enum class color : uint32_t {
6    alice_blue = 0xF0F8FF,               
7    antique_white = 0xFAEBD7,            
8    aqua = 0x00FFFF,                     
9    aquamarine = 0x7FFFD4,               
10    azure = 0xF0FFFF,                    
11    beige = 0xF5F5DC,                    
12    bisque = 0xFFE4C4,                   
13    black = 0x000000,                    
14    blanched_almond = 0xFFEBCD,          
15    blue = 0x0000FF,                     
16    blue_violet = 0x8A2BE2,              
17    brown = 0xA52A2A,                    
18    burly_wood = 0xDEB887,               
19    cadet_blue = 0x5F9EA0,               
20    chartreuse = 0x7FFF00,               
21    chocolate = 0xD2691E,                
22    coral = 0xFF7F50,                    
23    cornflower_blue = 0x6495ED,          
</span>24    cornsilk = 0xFFF8DC,                 
25    crimson = 0xDC143C,                  
26    cyan = 0x00FFFF,                     
27    dark_blue = 0x00008B,                
28    dark_cyan = 0x008B8B,                
29    dark_golden_rod = 0xB8860B,          
30    dark_gray = 0xA9A9A9,                
31    dark_green = 0x006400,               
32    dark_khaki = 0xBDB76B,               
33    dark_magenta = 0x8B008B,             
34    dark_olive_green = 0x556B2F,         
35    dark_orange = 0xFF8C00,              
36    dark_orchid = 0x9932CC,              
37    dark_red = 0x8B0000,                 
38    dark_salmon = 0xE9967A,              
39    dark_sea_green = 0x8FBC8F,           
40    dark_slate_blue = 0x483D8B,          
41    dark_slate_gray = 0x2F4F4F,          
42    dark_turquoise = 0x00CED1,           
43    dark_violet = 0x9400D3,              
44    deep_pink = 0xFF1493,                
45    deep_sky_blue = 0x00BFFF,            
46    dim_gray = 0x696969,                 
47    dodger_blue = 0x1E90FF,              
48    fire_brick = 0xB22222,               
49    floral_white = 0xFFFAF0,             
50    forest_green = 0x228B22,             
51    fuchsia = 0xFF00FF,                  
52    gainsboro = 0xDCDCDC,                
53    ghost_white = 0xF8F8FF,              
54    gold = 0xFFD700,                     
55    golden_rod = 0xDAA520,               
56    gray = 0x808080,                     
57    green = 0x008000,                    
58    green_yellow = 0xADFF2F,             
59    honey_dew = 0xF0FFF0,                
60    hot_pink = 0xFF69B4,                 
61    indian_red = 0xCD5C5C,               
62    indigo = 0x4B0082,                   
63    ivory = 0xFFFFF0,                    
64    khaki = 0xF0E68C,                    
65    lavender = 0xE6E6FA,                 
66    lavender_blush = 0xFFF0F5,           
67    lawn_green = 0x7CFC00,               
68    lemon_chiffon = 0xFFFACD,            
69    light_blue = 0xADD8E6,               
70    light_coral = 0xF08080,              
71    light_cyan = 0xE0FFFF,               
72    light_golden_rod_yellow = 0xFAFAD2,  
73    light_gray = 0xD3D3D3,               
74    light_green = 0x90EE90,              
75    light_pink = 0xFFB6C1,               
76    light_salmon = 0xFFA07A,             
77    light_sea_green = 0x20B2AA,          
78    light_sky_blue = 0x87CEFA,           
79    light_slate_gray = 0x778899,         
80    light_steel_blue = 0xB0C4DE,         
81    light_yellow = 0xFFFFE0,             
82    lime = 0x00FF00,                     
83    lime_green = 0x32CD32,               
84    linen = 0xFAF0E6,                    
85    magenta = 0xFF00FF,                  
86    maroon = 0x800000,                   
87    medium_aquamarine = 0x66CDAA,        
88    medium_blue = 0x0000CD,              
89    medium_orchid = 0xBA55D3,            
90    medium_purple = 0x9370DB,            
91    medium_sea_green = 0x3CB371,         
92    medium_slate_blue = 0x7B68EE,        
93    medium_spring_green = 0x00FA9A,      
94    medium_turquoise = 0x48D1CC,         
95    medium_violet_red = 0xC71585,        
96    midnight_blue = 0x191970,            
97    mint_cream = 0xF5FFFA,               
98    misty_rose = 0xFFE4E1,               
99    moccasin = 0xFFE4B5,                 
100    navajo_white = 0xFFDEAD,             
101    navy = 0x000080,                     
102    old_lace = 0xFDF5E6,                 
103    olive = 0x808000,                    
104    olive_drab = 0x6B8E23,               
105    orange = 0xFFA500,                   
106    orange_red = 0xFF4500,               
107    orchid = 0xDA70D6,                   
108    pale_golden_rod = 0xEEE8AA,          
109    pale_green = 0x98FB98,               
110    pale_turquoise = 0xAFEEEE,           
111    pale_violet_red = 0xDB7093,          
112    papaya_whip = 0xFFEFD5,              
113    peach_puff = 0xFFDAB9,               
114    peru = 0xCD853F,                     
115    pink = 0xFFC0CB,                     
116    plum = 0xDDA0DD,                     
117    powder_blue = 0xB0E0E6,              
118    purple = 0x800080,                   
119    rebecca_purple = 0x663399,           
120    red = 0xFF0000,                      
121    rosy_brown = 0xBC8F8F,               
122    royal_blue = 0x4169E1,               
123    saddle_brown = 0x8B4513,             
124    salmon = 0xFA8072,                   
125    sandy_brown = 0xF4A460,              
126    sea_green = 0x2E8B57,                
127    sea_shell = 0xFFF5EE,                
128    sienna = 0xA0522D,                   
129    silver = 0xC0C0C0,                   
130    sky_blue = 0x87CEEB,                 
131    slate_blue = 0x6A5ACD,               
132    slate_gray = 0x708090,               
133    snow = 0xFFFAFA,                     
134    spring_green = 0x00FF7F,             
135    steel_blue = 0x4682B4,               
136    tan = 0xD2B48C,                      
137    teal = 0x008080,                     
138    thistle = 0xD8BFD8,                  
139    tomato = 0xFF6347,                   
140    turquoise = 0x40E0D0,                
141    violet = 0xEE82EE,                   
142    wheat = 0xF5DEB3,                    
143    white = 0xFFFFFF,                    
144    white_smoke = 0xF5F5F5,              
145    yellow = 0xFFFF00,                   
146    yellow_green = 0x9ACD32              
147  };                                     
148  enum class terminal_color : uint8_t {
149    black = 30,
150    red,
151    green,
152    yellow,
153    blue,
154    magenta,
155    cyan,
156    white,
157    bright_black = 90,
158    bright_red,
159    bright_green,
160    bright_yellow,
161    bright_blue,
162    bright_magenta,
163    bright_cyan,
164    bright_white
165  };
166  enum class emphasis : uint8_t {
167    bold = 1,
168    italic = 1 << 1,
169    underline = 1 << 2,
170    strikethrough = 1 << 3
171  };
172  struct rgb {
173    FMT_CONSTEXPR rgb() : r(0), g(0), b(0) {}
174    FMT_CONSTEXPR rgb(uint8_t r_, uint8_t g_, uint8_t b_) : r(r_), g(g_), b(b_) {}
175    FMT_CONSTEXPR rgb(uint32_t hex)
176        : r((hex >> 16) & 0xFF), g((hex >> 8) & 0xFF), b(hex & 0xFF) {}
177    FMT_CONSTEXPR rgb(color hex)
178        : r((uint32_t(hex) >> 16) & 0xFF),
179          g((uint32_t(hex) >> 8) & 0xFF),
180          b(uint32_t(hex) & 0xFF) {}
181    uint8_t r;
182    uint8_t g;
183    uint8_t b;
184  };
185  namespace detail {
186  struct color_type {
187    FMT_CONSTEXPR color_type() FMT_NOEXCEPT : is_rgb(), value{} {}
188    FMT_CONSTEXPR color_type(color rgb_color) FMT_NOEXCEPT : is_rgb(true),
189                                                             value{} {
190      value.rgb_color = static_cast<uint32_t>(rgb_color);
191    }
192    FMT_CONSTEXPR color_type(rgb rgb_color) FMT_NOEXCEPT : is_rgb(true), value{} {
193      value.rgb_color = (static_cast<uint32_t>(rgb_color.r) << 16) |
194                        (static_cast<uint32_t>(rgb_color.g) << 8) | rgb_color.b;
195    }
196    FMT_CONSTEXPR color_type(terminal_color term_color) FMT_NOEXCEPT : is_rgb(),
197                                                                       value{} {
198      value.term_color = static_cast<uint8_t>(term_color);
199    }
200    bool is_rgb;
201    union color_union {
202      uint8_t term_color;
203      uint32_t rgb_color;
204    } value;
205  };
206  }  
207  class text_style {
208   public:
209    FMT_CONSTEXPR text_style(emphasis em = emphasis()) FMT_NOEXCEPT
210        : set_foreground_color(),
211          set_background_color(),
212          ems(em) {}
213    FMT_CONSTEXPR text_style& operator|=(const text_style& rhs) {
214      if (!set_foreground_color) {
215        set_foreground_color = rhs.set_foreground_color;
216        foreground_color = rhs.foreground_color;
217      } else if (rhs.set_foreground_color) {
218        if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
219          FMT_THROW(format_error("can't OR a terminal color"));
220        foreground_color.value.rgb_color |= rhs.foreground_color.value.rgb_color;
221      }
222      if (!set_background_color) {
223        set_background_color = rhs.set_background_color;
224        background_color = rhs.background_color;
225      } else if (rhs.set_background_color) {
226        if (!background_color.is_rgb || !rhs.background_color.is_rgb)
227          FMT_THROW(format_error("can't OR a terminal color"));
228        background_color.value.rgb_color |= rhs.background_color.value.rgb_color;
229      }
230      ems = static_cast<emphasis>(static_cast<uint8_t>(ems) |
231                                  static_cast<uint8_t>(rhs.ems));
232      return *this;
233    }
234    friend FMT_CONSTEXPR text_style operator|(text_style lhs,
235                                              const text_style& rhs) {
236      return lhs |= rhs;
237    }
238    FMT_CONSTEXPR text_style& operator&=(const text_style& rhs) {
239      if (!set_foreground_color) {
240        set_foreground_color = rhs.set_foreground_color;
241        foreground_color = rhs.foreground_color;
242      } else if (rhs.set_foreground_color) {
243        if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
244          FMT_THROW(format_error("can't AND a terminal color"));
245        foreground_color.value.rgb_color &= rhs.foreground_color.value.rgb_color;
246      }
247      if (!set_background_color) {
248        set_background_color = rhs.set_background_color;
249        background_color = rhs.background_color;
250      } else if (rhs.set_background_color) {
251        if (!background_color.is_rgb || !rhs.background_color.is_rgb)
252          FMT_THROW(format_error("can't AND a terminal color"));
253        background_color.value.rgb_color &= rhs.background_color.value.rgb_color;
254      }
255      ems = static_cast<emphasis>(static_cast<uint8_t>(ems) &
256                                  static_cast<uint8_t>(rhs.ems));
257      return *this;
258    }
259    friend FMT_CONSTEXPR text_style operator&(text_style lhs,
260                                              const text_style& rhs) {
261      return lhs &= rhs;
262    }
263    FMT_CONSTEXPR bool has_foreground() const FMT_NOEXCEPT {
264      return set_foreground_color;
265    }
266    FMT_CONSTEXPR bool has_background() const FMT_NOEXCEPT {
267      return set_background_color;
268    }
269    FMT_CONSTEXPR bool has_emphasis() const FMT_NOEXCEPT {
270      return static_cast<uint8_t>(ems) != 0;
271    }
272    FMT_CONSTEXPR detail::color_type get_foreground() const FMT_NOEXCEPT {
273      FMT_ASSERT(has_foreground(), "no foreground specified for this style");
274      return foreground_color;
275    }
276    FMT_CONSTEXPR detail::color_type get_background() const FMT_NOEXCEPT {
277      FMT_ASSERT(has_background(), "no background specified for this style");
278      return background_color;
279    }
280    FMT_CONSTEXPR emphasis get_emphasis() const FMT_NOEXCEPT {
281      FMT_ASSERT(has_emphasis(), "no emphasis specified for this style");
282      return ems;
283    }
284   private:
285    FMT_CONSTEXPR text_style(bool is_foreground,
286                             detail::color_type text_color) FMT_NOEXCEPT
287        : set_foreground_color(),
288          set_background_color(),
289          ems() {
290      if (is_foreground) {
291        foreground_color = text_color;
292        set_foreground_color = true;
293      } else {
294        background_color = text_color;
295        set_background_color = true;
296      }
297    }
298    friend FMT_CONSTEXPR_DECL text_style fg(detail::color_type foreground)
299        FMT_NOEXCEPT;
300    friend FMT_CONSTEXPR_DECL text_style bg(detail::color_type background)
301        FMT_NOEXCEPT;
302    detail::color_type foreground_color;
303    detail::color_type background_color;
304    bool set_foreground_color;
305    bool set_background_color;
306    emphasis ems;
307  };
308  FMT_CONSTEXPR text_style fg(detail::color_type foreground) FMT_NOEXCEPT {
309    return text_style(&bsol;*is_foreground=*/true, foreground);
310  }
311  FMT_CONSTEXPR text_style bg(detail::color_type background) FMT_NOEXCEPT {
312    return text_style(&bsol;*is_foreground=*/false, background);
313  }
314  FMT_CONSTEXPR text_style operator|(emphasis lhs, emphasis rhs) FMT_NOEXCEPT {
315    return text_style(lhs) | rhs;
316  }
317  namespace detail {
318  template <typename Char> struct ansi_color_escape {
319    FMT_CONSTEXPR ansi_color_escape(detail::color_type text_color,
320                                    const char* esc) FMT_NOEXCEPT {
321      if (!text_color.is_rgb) {
322        bool is_background = esc == detail::data::background_color;
323        uint32_t value = text_color.value.term_color;
324        if (is_background) value += 10u;
325        size_t index = 0;
326        buffer[index++] = static_cast<Char>('\x1b');
327        buffer[index++] = static_cast<Char>('[');
328        if (value >= 100u) {
329          buffer[index++] = static_cast<Char>('1');
330          value %= 100u;
331        }
332        buffer[index++] = static_cast<Char>('0' + value / 10u);
333        buffer[index++] = static_cast<Char>('0' + value % 10u);
334        buffer[index++] = static_cast<Char>('m');
335        buffer[index++] = static_cast<Char>('\0');
336        return;
337      }
338      for (int i = 0; i < 7; i++) {
339        buffer[i] = static_cast<Char>(esc[i]);
340      }
341      rgb color(text_color.value.rgb_color);
342      to_esc(color.r, buffer + 7, ';');
343      to_esc(color.g, buffer + 11, ';');
344      to_esc(color.b, buffer + 15, 'm');
345      buffer[19] = static_cast<Char>(0);
346    }
347    FMT_CONSTEXPR ansi_color_escape(emphasis em) FMT_NOEXCEPT {
348      uint8_t em_codes[4] = {};
349      uint8_t em_bits = static_cast<uint8_t>(em);
350      if (em_bits & static_cast<uint8_t>(emphasis::bold)) em_codes[0] = 1;
351      if (em_bits & static_cast<uint8_t>(emphasis::italic)) em_codes[1] = 3;
352      if (em_bits & static_cast<uint8_t>(emphasis::underline)) em_codes[2] = 4;
353      if (em_bits & static_cast<uint8_t>(emphasis::strikethrough))
354        em_codes[3] = 9;
355      size_t index = 0;
356      for (int i = 0; i < 4; ++i) {
357        if (!em_codes[i]) continue;
358        buffer[index++] = static_cast<Char>('\x1b');
359        buffer[index++] = static_cast<Char>('[');
360        buffer[index++] = static_cast<Char>('0' + em_codes[i]);
361        buffer[index++] = static_cast<Char>('m');
362      }
363      buffer[index++] = static_cast<Char>(0);
364    }
365    FMT_CONSTEXPR operator const Char*() const FMT_NOEXCEPT { return buffer; }
366    FMT_CONSTEXPR const Char* begin() const FMT_NOEXCEPT { return buffer; }
367    FMT_CONSTEXPR const Char* end() const FMT_NOEXCEPT {
368      return buffer + std::char_traits<Char>::length(buffer);
369    }
370   private:
371    Char buffer[7u + 3u * 4u + 1u];
372    static FMT_CONSTEXPR void to_esc(uint8_t c, Char* out,
373                                     char delimiter) FMT_NOEXCEPT {
374      out[0] = static_cast<Char>('0' + c / 100);
375      out[1] = static_cast<Char>('0' + c / 10 % 10);
376      out[2] = static_cast<Char>('0' + c % 10);
377      out[3] = static_cast<Char>(delimiter);
378    }
379  };
380  template <typename Char>
381  FMT_CONSTEXPR ansi_color_escape<Char> make_foreground_color(
382      detail::color_type foreground) FMT_NOEXCEPT {
383    return ansi_color_escape<Char>(foreground, detail::data::foreground_color);
384  }
385  template <typename Char>
386  FMT_CONSTEXPR ansi_color_escape<Char> make_background_color(
387      detail::color_type background) FMT_NOEXCEPT {
388    return ansi_color_escape<Char>(background, detail::data::background_color);
389  }
390  template <typename Char>
391  FMT_CONSTEXPR ansi_color_escape<Char> make_emphasis(emphasis em) FMT_NOEXCEPT {
392    return ansi_color_escape<Char>(em);
393  }
394  template <typename Char>
395  inline void fputs(const Char* chars, FILE* stream) FMT_NOEXCEPT {
396    std::fputs(chars, stream);
397  }
398  template <>
399  inline void fputs<wchar_t>(const wchar_t* chars, FILE* stream) FMT_NOEXCEPT {
400    std::fputws(chars, stream);
401  }
402  template <typename Char> inline void reset_color(FILE* stream) FMT_NOEXCEPT {
403    fputs(detail::data::reset_color, stream);
404  }
405  template <> inline void reset_color<wchar_t>(FILE* stream) FMT_NOEXCEPT {
406    fputs(detail::data::wreset_color, stream);
407  }
408  template <typename Char>
409  inline void reset_color(buffer<Char>& buffer) FMT_NOEXCEPT {
410    const char* begin = data::reset_color;
411    const char* end = begin + sizeof(data::reset_color) - 1;
412    buffer.append(begin, end);
413  }
414  template <typename Char>
415  void vformat_to(buffer<Char>& buf, const text_style& ts,
416                  basic_string_view<Char> format_str,
417                  basic_format_args<buffer_context<type_identity_t<Char>>> args) {
418    bool has_style = false;
419    if (ts.has_emphasis()) {
420      has_style = true;
421      auto emphasis = detail::make_emphasis<Char>(ts.get_emphasis());
422      buf.append(emphasis.begin(), emphasis.end());
423    }
424    if (ts.has_foreground()) {
425      has_style = true;
426      auto foreground = detail::make_foreground_color<Char>(ts.get_foreground());
427      buf.append(foreground.begin(), foreground.end());
428    }
429    if (ts.has_background()) {
430      has_style = true;
431      auto background = detail::make_background_color<Char>(ts.get_background());
432      buf.append(background.begin(), background.end());
433    }
434    detail::vformat_to(buf, format_str, args);
435    if (has_style) detail::reset_color<Char>(buf);
436  }
437  }  
438  template <typename S, typename Char = char_t<S>>
439  void vprint(std::FILE* f, const text_style& ts, const S& format,
440              basic_format_args<buffer_context<type_identity_t<Char>>> args) {
441    basic_memory_buffer<Char> buf;
442    detail::vformat_to(buf, ts, to_string_view(format), args);
443    buf.push_back(Char(0));
444    detail::fputs(buf.data(), f);
445  }
446  template <typename S, typename... Args,
447            FMT_ENABLE_IF(detail::is_string<S>::value)>
448  void print(std::FILE* f, const text_style& ts, const S& format_str,
449             const Args&... args) {
450    vprint(f, ts, format_str,
451           fmt::make_args_checked<Args...>(format_str, args...));
452  }
453  template <typename S, typename... Args,
454            FMT_ENABLE_IF(detail::is_string<S>::value)>
455  void print(const text_style& ts, const S& format_str, const Args&... args) {
456    return print(stdout, ts, format_str, args...);
457  }
458  template <typename S, typename Char = char_t<S>>
459  inline std::basic_string<Char> vformat(
460      const text_style& ts, const S& format_str,
461      basic_format_args<buffer_context<type_identity_t<Char>>> args) {
462    basic_memory_buffer<Char> buf;
463    detail::vformat_to(buf, ts, to_string_view(format_str), args);
464    return fmt::to_string(buf);
465  }
466  template <typename S, typename... Args, typename Char = char_t<S>>
467  inline std::basic_string<Char> format(const text_style& ts, const S& format_str,
468                                        const Args&... args) {
469    return vformat(ts, to_string_view(format_str),
470                   fmt::make_args_checked<Args...>(format_str, args...));
471  }
472  template <typename OutputIt, typename Char,
473            FMT_ENABLE_IF(detail::is_output_iterator<OutputIt>::value)>
474  OutputIt vformat_to(
475      OutputIt out, const text_style& ts, basic_string_view<Char> format_str,
476      basic_format_args<buffer_context<type_identity_t<Char>>> args) {
477    decltype(detail::get_buffer<Char>(out)) buf(detail::get_buffer_init(out));
478    detail::vformat_to(buf, ts, format_str, args);
479    return detail::get_iterator(buf);
480  }
481  template <typename OutputIt, typename S, typename... Args,
482            FMT_ENABLE_IF(detail::is_output_iterator<OutputIt>::value&&
483                              detail::is_string<S>::value)>
484  inline OutputIt format_to(OutputIt out, const text_style& ts,
485                            const S& format_str, Args&&... args) {
486    return vformat_to(out, ts, to_string_view(format_str),
487                      fmt::make_args_checked<Args...>(format_str, args...));
488  }
489  FMT_END_NAMESPACE
490  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-aes.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-color.h</div>
                </div>
                <div class="column column_space"><pre><code>158      for (i = 1; i < skey->rijndael.Nr; i++) {
159          rrk -= 4;
160          rk  += 4;
161      #ifdef LTC_SMALL_CODE
162          temp = rrk[0];
163          rk[0] = setup_mix2(temp);
164          temp = rrk[1];
165          rk[1] = setup_mix2(temp);
166          temp = rrk[2];
167          rk[2] = setup_mix2(temp);
168          temp = rrk[3];
169          rk[3] = setup_mix2(temp);
170       #else
171          temp = rrk[0];
172          rk[0] =
173              Tks0[LTC_BYTE(temp, 3)] ^
174              Tks1[LTC_BYTE(temp, 2)] ^
175              Tks2[LTC_BYTE(temp, 1)] ^
176              Tks3[LTC_BYTE(temp, 0)];
177          temp = rrk[1];
178          rk[1] =
179              Tks0[LTC_BYTE(temp, 3)] ^
180              Tks1[LTC_BYTE(temp, 2)] ^
181              Tks2[LTC_BYTE(temp, 1)] ^
182              Tks3[LTC_BYTE(temp, 0)];
183          temp = rrk[2];
184          rk[2] =
185              Tks0[LTC_BYTE(temp, 3)] ^
186              Tks1[LTC_BYTE(temp, 2)] ^
187              Tks2[LTC_BYTE(temp, 1)] ^
188              Tks3[LTC_BYTE(temp, 0)];
189          temp = rrk[3];
190          rk[3] =
</pre></code></div>
                <div class="column column_space"><pre><code>5  enum class color : uint32_t {
6    alice_blue = 0xF0F8FF,               
7    antique_white = 0xFAEBD7,            
8    aqua = 0x00FFFF,                     
9    aquamarine = 0x7FFFD4,               
10    azure = 0xF0FFFF,                    
11    beige = 0xF5F5DC,                    
12    bisque = 0xFFE4C4,                   
13    black = 0x000000,                    
14    blanched_almond = 0xFFEBCD,          
15    blue = 0x0000FF,                     
16    blue_violet = 0x8A2BE2,              
17    brown = 0xA52A2A,                    
18    burly_wood = 0xDEB887,               
19    cadet_blue = 0x5F9EA0,               
20    chartreuse = 0x7FFF00,               
21    chocolate = 0xD2691E,                
22    coral = 0xFF7F50,                    
23    cornflower_blue = 0x6495ED,          
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    