<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for datetime.c &amp; rsconf.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for datetime.c &amp; rsconf.c
      </h3>
<h1 align="center">
        8.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>datetime.c (8.434959%)<th>rsconf.c (8.867521%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(877-898)<td><a href="#" name="0">(205-229)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(959-983)<td><a href="#" name="1">(1388-1421)</a><td align="center"><font color="#da0000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(851-867)<td><a href="#" name="2">(187-202)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1257-1274)<td><a href="#" name="3">(247-261)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1005-1011)<td><a href="#" name="4">(161-173)</a><td align="center"><font color="#9d0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>datetime.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#ifdef HAVE_SYS_TIME_H
#	include &lt;sys/time.h&gt;
#endif
#include "rsyslog.h"
#include "obj.h"
#include "modules.h"
#include "datetime.h"
#include "srUtils.h"
#include "stringbuf.h"
#include "errmsg.h"
#include "rsconf.h"
#include "timezones.h"
DEFobjStaticHelpers
static const int tenPowers[6] = { 1, 10, 100, 1000, 10000, 100000 };
static const int yearInSec_startYear = 1967;
static const long long yearInSecs[] = {
	-63158401, -31536001, -1, 31535999, 63071999, 94694399, 126230399,
	157766399, 189302399, 220924799, 252460799, 283996799, 315532799,
	347155199, 378691199, 410227199, 441763199, 473385599, 504921599,
	536457599, 567993599, 599615999, 631151999, 662687999, 694223999,
	725846399, 757382399, 788918399, 820454399, 852076799, 883612799,
	915148799, 946684799, 978307199, 1009843199, 1041379199, 1072915199,
	1104537599, 1136073599, 1167609599, 1199145599, 1230767999,
	1262303999, 1293839999, 1325375999, 1356998399, 1388534399,
	1420070399, 1451606399, 1483228799, 1514764799, 1546300799,
	1577836799, 1609459199, 1640995199, 1672531199, 1704067199,
	1735689599, 1767225599, 1798761599, 1830297599, 1861919999,
	1893455999, 1924991999, 1956527999, 1988150399, 2019686399,
	2051222399, 2082758399, 2114380799, 2145916799, 2177452799,
	2208988799, 2240611199, 2272147199, 2303683199, 2335219199,
	2366841599, 2398377599, 2429913599, 2461449599, 2493071999,
	2524607999, 2556143999, 2587679999, 2619302399, 2650838399,
	2682374399, 2713910399, 2745532799, 2777068799, 2808604799,
	2840140799, 2871763199, 2903299199, 2934835199, 2966371199,
	2997993599, 3029529599, 3061065599, 3092601599, 3124223999,
	3155759999, 3187295999, 3218831999, 3250454399, 3281990399,
	3313526399, 3345062399, 3376684799, 3408220799, 3439756799,
	3471292799, 3502915199, 3534451199, 3565987199, 3597523199,
	3629145599, 3660681599, 3692217599, 3723753599, 3755375999,
	3786911999, 3818447999, 3849983999, 3881606399, 3913142399,
	3944678399, 3976214399, 4007836799, 4039372799, 4070908799,
	4102444799};
static const int weeksInYear[] = {
	52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52,
	52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52,
	52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52,
};
static const char* monthNames[12] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};
static void
timeval2syslogTime(struct timeval *tp, struct syslogTime *t, const int inUTC)
{
	struct tm *tm;
	struct tm tmBuf;
	long lBias;
	time_t secs;
#if defined(__hpux)
	struct timezone tz;
#	endif
	secs = tp-&gt;tv_sec;
	if(inUTC)
		tm = gmtime_r(&amp;secs, &amp;tmBuf);
	else
		tm = localtime_r(&amp;secs, &amp;tmBuf);
	t-&gt;year = tm-&gt;tm_year + 1900;
	t-&gt;month = tm-&gt;tm_mon + 1;
	t-&gt;day = tm-&gt;tm_mday;
	t-&gt;wday = tm-&gt;tm_wday;
	t-&gt;hour = tm-&gt;tm_hour;
	t-&gt;minute = tm-&gt;tm_min;
	t-&gt;second = tm-&gt;tm_sec;
	t-&gt;secfrac = tp-&gt;tv_usec;
	t-&gt;secfracPrecision = 6;
	if(inUTC) {
		t-&gt;OffsetMode = '+';
		lBias = 0;
	} else {
#		if defined(__sun)
			lBias = -(tm-&gt;tm_isdst ? altzone : timezone);
#		elif defined(__hpux)
			lBias = tz.tz_dsttime ? - tz.tz_minuteswest : 0;
#		elif defined(_AIX)
			if (tm-&gt;tm_isdst) tzset();
			lBias = - timezone;
#		else
			lBias = tm-&gt;tm_gmtoff;
#		endif
		if(lBias &lt; 0) {
			t-&gt;OffsetMode = '-';
			lBias *= -1;
		} else
			t-&gt;OffsetMode = '+';
	}
	t-&gt;OffsetHour = lBias / 3600;
	t-&gt;OffsetMinute = (lBias % 3600) / 60;
	t-&gt;timeType = TIME_TYPE_RFC5424; 	t-&gt;inUTC = inUTC;
}
static void getCurrTime(struct syslogTime *t, time_t *ttSeconds, const int inUTC)
{
	struct timeval tp;
#if defined(__hpux) || defined(_AIX)
	struct timezone tz;
#	endif
	assert(t != NULL);
#if defined(__hpux) || defined(_AIX)
		gettimeofday(&amp;tp, &amp;tz);
#	else
		gettimeofday(&amp;tp, NULL);
#	endif
	if(ttSeconds != NULL)
		*ttSeconds = tp.tv_sec;
	timeval2syslogTime(&amp;tp, t, inUTC);
}
time_t
getTime(time_t *ttSeconds)
{
	struct timeval tp;
	if(gettimeofday(&amp;tp, NULL) == -1)
		return -1;
	if(ttSeconds != NULL)
		*ttSeconds = tp.tv_sec;
	return tp.tv_sec;
}
dateTimeFormat_t getDateTimeFormatFromStr(const char * const __restrict__ s) {
	assert(s != NULL);
	if (strcmp(s, "date-rfc3164") == 0)
		return DATE_RFC3164;
	if (strcmp(s, "date-rfc3339") == 0)
		return DATE_RFC3339;
	if (strcmp(s, "date-unix") == 0)
		return DATE_UNIX;
	return DATE_INVALID;
}
static int
srSLMGParseInt32(uchar** ppsz, int *pLenStr)
{
	register int i;
	i = 0;
	while(*pLenStr &gt; 0 &amp;&amp; **ppsz &gt;= '0' &amp;&amp; **ppsz &lt;= '9' &amp;&amp; i &lt; INT_MAX/10-1) {
		i = i * 10 + **ppsz - '0';
		++(*ppsz);
		--(*pLenStr);
	}
	return i;
}
static rsRetVal
ParseTIMESTAMP3339(struct syslogTime *pTime, uchar** ppszTS, int *pLenStr)
{
	uchar *pszTS = *ppszTS;
	int year;
	int month;
	int day;
	int hour; 	int minute;
	int second;
	int secfrac;		int secfracPrecision;
	char OffsetMode;		int OffsetHour;		int OffsetMinute;		int lenStr;
	DEFiRet;
	assert(pTime != NULL);
	assert(ppszTS != NULL);
	assert(pszTS != NULL);
	lenStr = *pLenStr;
	year = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(lenStr == 0 || *pszTS++ != '-' || year &lt; 0 || year &gt;= 2100) {
		DBGPRINTF("ParseTIMESTAMP3339: invalid year: %d, pszTS: '%c'\n", year, *pszTS);
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	}
	--lenStr;
	month = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(month &lt; 1 || month &gt; 12)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(lenStr == 0 || *pszTS++ != '-')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	day = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(day &lt; 1 || day &gt; 31)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(lenStr == 0 || *pszTS++ != 'T')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	hour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(hour &lt; 0 || hour &gt; 23)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(lenStr == 0 || *pszTS++ != ':')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	minute = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(minute &lt; 0 || minute &gt; 59)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(lenStr == 0 || *pszTS++ != ':')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	second = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(second &lt; 0 || second &gt; 60)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(lenStr &gt; 0 &amp;&amp; *pszTS == '.') {
		--lenStr;
		uchar *pszStart = ++pszTS;
		secfrac = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		secfracPrecision = (int) (pszTS - pszStart);
	} else {
		secfracPrecision = 0;
		secfrac = 0;
	}
	if(lenStr == 0)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(*pszTS == 'Z') {
		--lenStr;
		pszTS++; 		OffsetMode = 'Z';
		OffsetHour = 0;
		OffsetMinute = 0;
	} else if((*pszTS == '+') || (*pszTS == '-')) {
		OffsetMode = *pszTS;
		--lenStr;
		pszTS++;
		OffsetHour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		if(OffsetHour &lt; 0 || OffsetHour &gt; 23)
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		if(lenStr == 0 || *pszTS != ':')
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		--lenStr;
		pszTS++;
		OffsetMinute = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		if(OffsetMinute &lt; 0 || OffsetMinute &gt; 59)
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
	} else {
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	}
	if(lenStr &gt; 0) {
		if(*pszTS != ' ') 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		++pszTS; 		--lenStr;
	}
	*ppszTS = pszTS;
	pTime-&gt;timeType = 2;
	pTime-&gt;year = year;
	pTime-&gt;month = month;
	pTime-&gt;day = day;
	pTime-&gt;hour = hour;
	pTime-&gt;minute = minute;
	pTime-&gt;second = second;
	pTime-&gt;secfrac = secfrac;
	pTime-&gt;secfracPrecision = secfracPrecision;
	pTime-&gt;OffsetMode = OffsetMode;
	pTime-&gt;OffsetHour = OffsetHour;
	pTime-&gt;OffsetMinute = OffsetMinute;
	*pLenStr = lenStr;
finalize_it:
	RETiRet;
}
static rsRetVal
ParseTIMESTAMP3164(struct syslogTime *pTime, uchar** ppszTS, int *pLenStr,
	const int bParseTZ,
	const int bDetectYearAfterTime)
{
	int month;
	int day;
	int year = 0; 	int hour; 	int minute;
	int second;
	int secfrac;		int secfracPrecision;
	char tzstring[16];
	char OffsetMode = '\0';		char OffsetHour = '\0';		int OffsetMinute = 0;		int lenStr;
	uchar *pszTS;
	DEFiRet;
	assert(ppszTS != NULL);
	pszTS = *ppszTS;
	assert(pszTS != NULL);
	assert(pTime != NULL);
	assert(pLenStr != NULL);
	lenStr = *pLenStr;
	if(lenStr &lt; 3)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(*pszTS &gt;= '0' &amp;&amp; *pszTS &lt;= '9') {
		year = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		if(year &lt; 1970 || year &gt; 2100 || *pszTS != ' ')
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		++pszTS; 	}
	switch(*pszTS++)
	{
	case 'j':
	case 'J':
		if(*pszTS == 'a' || *pszTS == 'A') {
			++pszTS;
			if(*pszTS == 'n' || *pszTS == 'N') {
				++pszTS;
				month = 1;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else if(*pszTS == 'u' || *pszTS == 'U') {
			++pszTS;
			if(*pszTS == 'n' || *pszTS == 'N') {
				++pszTS;
				month = 6;
			} else if(*pszTS == 'l' || *pszTS == 'L') {
				++pszTS;
				month = 7;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'f':
	case 'F':
		if(*pszTS == 'e' || *pszTS == 'E') {
			++pszTS;
			if(*pszTS == 'b' || *pszTS == 'B') {
				++pszTS;
				month = 2;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'm':
	case 'M':
		if(*pszTS == 'a' || *pszTS == 'A') {
			++pszTS;
			if(*pszTS == 'r' || *pszTS == 'R') {
				++pszTS;
				month = 3;
			} else if(*pszTS == 'y' || *pszTS == 'Y') {
				++pszTS;
				month = 5;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'a':
	case 'A':
		if(*pszTS == 'p' || *pszTS == 'P') {
			++pszTS;
			if(*pszTS == 'r' || *pszTS == 'R') {
				++pszTS;
				month = 4;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else if(*pszTS == 'u' || *pszTS == 'U') {
			++pszTS;
			if(*pszTS == 'g' || *pszTS == 'G') {
				++pszTS;
				month = 8;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 's':
	case 'S':
		if(*pszTS == 'e' || *pszTS == 'E') {
			++pszTS;
			if(*pszTS == 'p' || *pszTS == 'P') {
				++pszTS;
				month = 9;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'o':
	case 'O':
		if(*pszTS == 'c' || *pszTS == 'C') {
			++pszTS;
			if(*pszTS == 't' || *pszTS == 'T') {
				++pszTS;
				month = 10;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'n':
	case 'N':
		if(*pszTS == 'o' || *pszTS == 'O') {
			++pszTS;
			if(*pszTS == 'v' || *pszTS == 'V') {
				++pszTS;
				month = 11;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'd':
	case 'D':
		if(*pszTS == 'e' || *pszTS == 'E') {
			++pszTS;
			if(*pszTS == 'c' || *pszTS == 'C') {
				++pszTS;
				month = 12;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	default:
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	}
	lenStr -= 3;
	if(lenStr == 0 || *pszTS++ != ' ')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	if(*pszTS == ' ') {
		--lenStr;
		++pszTS;
	}
	day = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(day &lt; 1 || day &gt; 31)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(lenStr == 0 || *pszTS++ != ' ')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	hour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(year == 0 &amp;&amp; hour &gt; 1970 &amp;&amp; hour &lt; 2100) {
		year = hour;
		if(lenStr == 0 || *pszTS++ != ' ')
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		--lenStr;
		hour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	}
	if(hour &lt; 0 || hour &gt; 23)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(lenStr == 0 || *pszTS++ != ':')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	minute = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(minute &lt; 0 || minute &gt; 59)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(lenStr == 0 || *pszTS++ != ':')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	second = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(second &lt; 0 || second &gt; 60)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	if(lenStr &gt; 0 &amp;&amp; *pszTS == '.') {
		--lenStr;
		uchar *pszStart = ++pszTS;
		secfrac = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		secfracPrecision = (int) (pszTS - pszStart);
	} else {
		secfracPrecision = 0;
		secfrac = 0;
	}
	if(bParseTZ &amp;&amp; lenStr &gt; 2 &amp;&amp; *pszTS == ' ') {
		int i;
		for(  ++pszTS, --lenStr, i = 0
		    ; lenStr &gt; 0 &amp;&amp; i &lt; (int) sizeof(tzstring) - 1 &amp;&amp; *pszTS != ':' &amp;&amp; *pszTS != ' '
		    ; --lenStr)
			tzstring[i++] = *pszTS++;
		if(i &gt; 0) {
			tzinfo_t* tzinfo;
			tzstring[i] = '\0';
			if((tzinfo = glblFindTimezone(runConf, (char*) tzstring)) == NULL) {
				DBGPRINTF("ParseTIMESTAMP3164: invalid TZ string '%s' -- ignored\n",
					  tzstring);
			} else {
				OffsetMode = tzinfo-&gt;offsMode;
				OffsetHour = tzinfo-&gt;offsHour;
				OffsetMinute = tzinfo-&gt;offsMin;
			}
		}
	}
	if(bDetectYearAfterTime &amp;&amp; year == 0 &amp;&amp; lenStr &gt; 5 &amp;&amp; *pszTS == ' ') {
		int j;
		int y = 0;
		for(j = 1 ; j &lt; 5 ; ++j) {
			if(pszTS[j] &lt; '0' || pszTS[j] &gt; '9')
				break;
			y = 10 * y + pszTS[j] - '0';
		}
		if(lenStr &gt; 6 &amp;&amp; pszTS[5] != ' ')
			y = 0; 		if(2000 &lt;= y &amp;&amp; y &lt; 2100) {
			year = y;
			pszTS += 5; 			lenStr -= 5;
		}
	}
	if(lenStr &gt; 0 &amp;&amp; *pszTS == ':') {
		++pszTS; 		--lenStr;
	}
	if(lenStr &gt; 0) {
		if(*pszTS != ' ') 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		++pszTS; 		--lenStr;
	}
	*ppszTS = pszTS; 	pTime-&gt;timeType = 1;
	pTime-&gt;month = month;
	if(year &gt; 0)
		pTime-&gt;year = year; 	pTime-&gt;day = day;
	pTime-&gt;hour = hour;
	pTime-&gt;minute = minute;
	pTime-&gt;second = second;
	pTime-&gt;secfrac = secfrac;
	pTime-&gt;secfracPrecision = secfracPrecision;
	if(OffsetMode != '\0') { 		pTime-&gt;OffsetMode = OffsetMode;
		pTime-&gt;OffsetHour = OffsetHour;
		pTime-&gt;OffsetMinute = OffsetMinute;
	}
	*pLenStr = lenStr;
finalize_it:
	RETiRet;
}
void
applyDfltTZ(struct syslogTime *pTime, char *tz)
{
	pTime-&gt;OffsetMode = tz[0];
	pTime-&gt;OffsetHour = (tz[1] - '0') * 10 + (tz[2] - '0');
	pTime-&gt;OffsetMinute = (tz[4] - '0') * 10 + (tz[5] - '0');
}
static int
formatTimestampToMySQL(struct syslogTime *ts, char* pBuf)
{
	assert(ts != NULL);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	assert(pBuf != NULL);
	pBuf[0] = (ts-&gt;year / 1000) % 10 + '0';
	pBuf[1] = (ts-&gt;year / 100) % 10 + '0';
	pBuf[2] = (ts-&gt;year / 10) % 10 + '0';
	pBuf[3] = ts-&gt;year % 10 + '0';
	pBuf[4] = (ts-&gt;month / 10) % 10 + '0';
	pBuf[5] = ts-&gt;month % 10 + '0';
	pBuf[6] = (ts-&gt;day / 10) % 10 + '0';
	pBuf[7] = ts-&gt;day % 10 + '0';
	pBuf[8] = (ts-&gt;hour / 10) % 10 + '0';
	pBuf[9] = ts-&gt;hour % 10 + '0';
	pBuf[10] = (ts-&gt;minute / 10) % 10 + '0';
	pBuf[11] = ts-&gt;minute % 10 + '0';
	pBuf[12] = (ts-&gt;second / 10) % 10 + '0';
	pBuf[13] = ts-&gt;second % 10 + '0';
	pBuf[14] = '\0';</b></font>
	return 15;
}
static int
formatTimestampToPgSQL(struct syslogTime *ts, char *pBuf)
<a name="0"></a>{
	assert(ts != NULL);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	assert(pBuf != NULL);
	pBuf[0] = (ts-&gt;year / 1000) % 10 + '0';
	pBuf[1] = (ts-&gt;year / 100) % 10 + '0';
	pBuf[2] = (ts-&gt;year / 10) % 10 + '0';
	pBuf[3] = ts-&gt;year % 10 + '0';
	pBuf[4] = '-';
	pBuf[5] = (ts-&gt;month / 10) % 10 + '0';
	pBuf[6] = ts-&gt;month % 10 + '0';
	pBuf[7] = '-';
	pBuf[8] = (ts-&gt;day / 10) % 10 + '0';
	pBuf[9] = ts-&gt;day % 10 + '0';
	pBuf[10] = ' ';
	pBuf[11] = (ts-&gt;hour / 10) % 10 + '0';
	pBuf[12] = ts-&gt;hour % 10 + '0';
	pBuf[13] = ':';
	pBuf[14] = (ts-&gt;minute / 10) % 10 + '0';
	pBuf[15] = ts-&gt;minute % 10 + '0';
	pBuf[16] = ':';
	pBuf[17] = (ts-&gt;second / 10) % 10 + '0';
	pBuf[18] = ts-&gt;second % 10 + '0';
	pBuf[19] = '\0';</b></font>
	return 19;
}
static int
formatTimestampSecFrac(struct syslogTime *ts, char* pBuf)
{
	int iBuf;
	int power;
	int secfrac;
	short digit;
	assert(ts != NULL);
	assert(pBuf != NULL);
	iBuf = 0;
	if(ts-&gt;secfracPrecision &gt; 0)
	{
		power = tenPowers[(ts-&gt;secfracPrecision - 1) % 6];
		secfrac = ts-&gt;secfrac;
		while(power &gt; 0) {
			digit = secfrac / power;
			secfrac -= digit * power;
			power /= 10;
			pBuf[iBuf++] = digit + '0';
		}
	} else {
		pBuf[iBuf++] = '0';
	}
	pBuf[iBuf] = '\0';
	return iBuf;
}
static int
formatTimestamp3339(struct syslogTime *ts, char* pBuf)
{
	int iBuf;
	int power;
<a name="1"></a>	int secfrac;
	short digit;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	assert(ts != NULL);
	assert(pBuf != NULL);
	pBuf[0] = (ts-&gt;year / 1000) % 10 + '0';
	pBuf[1] = (ts-&gt;year / 100) % 10 + '0';
	pBuf[2] = (ts-&gt;year / 10) % 10 + '0';
	pBuf[3] = ts-&gt;year % 10 + '0';
	pBuf[4] = '-';
	pBuf[5] = (ts-&gt;month / 10) % 10 + '0';
	pBuf[6] = ts-&gt;month % 10 + '0';
	pBuf[7] = '-';
	pBuf[8] = (ts-&gt;day / 10) % 10 + '0';
	pBuf[9] = ts-&gt;day % 10 + '0';
	pBuf[10] = 'T';
	pBuf[11] = (ts-&gt;hour / 10) % 10 + '0';
	pBuf[12] = ts-&gt;hour % 10 + '0';
	pBuf[13] = ':';
	pBuf[14] = (ts-&gt;minute / 10) % 10 + '0';
	pBuf[15] = ts-&gt;minute % 10 + '0';</b></font>
	pBuf[16] = ':';
	pBuf[17] = (ts-&gt;second / 10) % 10 + '0';
	pBuf[18] = ts-&gt;second % 10 + '0';
	iBuf = 19; 
	if(ts-&gt;secfracPrecision &gt; 0) {
		pBuf[iBuf++] = '.';
		power = tenPowers[(ts-&gt;secfracPrecision - 1) % 6];
		secfrac = ts-&gt;secfrac;
		while(power &gt; 0) {
			digit = secfrac / power;
			secfrac -= digit * power;
			power /= 10;
			pBuf[iBuf++] = digit + '0';
		}
	}
<a name="4"></a>
	if(ts-&gt;OffsetMode == 'Z') {
		pBuf[iBuf++] = 'Z';
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	} else {
		pBuf[iBuf++] = ts-&gt;OffsetMode;
		pBuf[iBuf++] = (ts-&gt;OffsetHour / 10) % 10 + '0';
		pBuf[iBuf++] = ts-&gt;OffsetHour % 10 + '0';
		pBuf[iBuf++] = ':';
		pBuf[iBuf++] = (ts-&gt;OffsetMinute / 10) % 10 + '0';
		pBuf[iBuf++] = ts-&gt;OffsetMinute % 10 + '0';</b></font>
	}
	pBuf[iBuf] = '\0';
	return iBuf;
}
static int
formatTimestamp3164(struct syslogTime *ts, char* pBuf, int bBuggyDay)
{
	int iDay;
	assert(ts != NULL);
	assert(pBuf != NULL);
	pBuf[0] = monthNames[(ts-&gt;month - 1)% 12][0];
	pBuf[1] = monthNames[(ts-&gt;month - 1) % 12][1];
	pBuf[2] = monthNames[(ts-&gt;month - 1) % 12][2];
	pBuf[3] = ' ';
	iDay = (ts-&gt;day / 10) % 10; 	pBuf[4] = (bBuggyDay || iDay &gt; 0) ? iDay + '0' : ' ';
	pBuf[5] = ts-&gt;day % 10 + '0';
	pBuf[6] = ' ';
	pBuf[7] = (ts-&gt;hour / 10) % 10 + '0';
	pBuf[8] = ts-&gt;hour % 10 + '0';
	pBuf[9] = ':';
	pBuf[10] = (ts-&gt;minute / 10) % 10 + '0';
	pBuf[11] = ts-&gt;minute % 10 + '0';
	pBuf[12] = ':';
	pBuf[13] = (ts-&gt;second / 10) % 10 + '0';
	pBuf[14] = ts-&gt;second % 10 + '0';
	pBuf[15] = '\0';
	return 16;	}
static time_t
syslogTime2time_t(const struct syslogTime *ts)
{
	long MonthInDays, NumberOfYears, NumberOfDays;
	int utcOffset;
	time_t TimeInUnixFormat;
	if(ts-&gt;year &lt; 1970 || ts-&gt;year &gt; 2100) {
		TimeInUnixFormat = 0;
		LogError(0, RS_RET_ERR, "syslogTime2time_t: invalid year %d "
			"in timestamp - returning 1970-01-01 instead", ts-&gt;year);
		goto done;
	}
	switch(ts-&gt;month)
	{
		case 1:
			MonthInDays = 0;         //until 01 of January
			break;
		case 2:
			MonthInDays = 31;        //until 01 of February - leap year handling down below!
			break;
		case 3:
			MonthInDays = 59;        //until 01 of March
			break;
		case 4:
			MonthInDays = 90;        //until 01 of April
			break;
		case 5:
			MonthInDays = 120;       //until 01 of Mai
			break;
		case 6:
			MonthInDays = 151;       //until 01 of June
			break;
		case 7:
			MonthInDays = 181;       //until 01 of July
			break;
		case 8:
			MonthInDays = 212;       //until 01 of August
			break;
		case 9:
			MonthInDays = 243;       //until 01 of September
			break;
		case 10:
			MonthInDays = 273;       //until 01 of Oktober
			break;
		case 11:
			MonthInDays = 304;       //until 01 of November
			break;
		case 12:
			MonthInDays = 334;       //until 01 of December
			break;
			MonthInDays = 0;				break;
	}
	if((ts-&gt;year % 100 != 0 &amp;&amp; ts-&gt;year % 4 == 0) || (ts-&gt;year == 2000)) {
		if(ts-&gt;month &gt; 2)
			MonthInDays++;
	}
	NumberOfYears = ts-&gt;year - yearInSec_startYear - 1;
	NumberOfDays = MonthInDays + ts-&gt;day - 1;
	TimeInUnixFormat = (time_t) (yearInSecs[NumberOfYears] + 1) + NumberOfDays * 86400;
	TimeInUnixFormat += ts-&gt;hour*60*60;
	TimeInUnixFormat += ts-&gt;minute*60;
	TimeInUnixFormat += ts-&gt;second;
	utcOffset = ts-&gt;OffsetHour*3600 + ts-&gt;OffsetMinute*60;
	if(ts-&gt;OffsetMode == '+')
		utcOffset *= -1; 	TimeInUnixFormat += utcOffset;
done:
	return TimeInUnixFormat;
}
static int
formatTimestampUnix(struct syslogTime *ts, char *pBuf)
{
	snprintf(pBuf, 11, "%u", (unsigned) syslogTime2time_t(ts));
	return 11;
}
int getWeekdayNbr(struct syslogTime *ts)
{
	int wday;
	int g, f;
	g = ts-&gt;year;
	if(ts-&gt;month &lt; 3) {
		g--;
		f = ts-&gt;month + 13;
	} else {
		f = ts-&gt;month + 1;
	}
	wday = ((36525*g)/100) + ((306*f)/10) + ts-&gt;day - 621049;
	wday %= 7;
	return wday;
}
int getOrdinal(struct syslogTime *ts)
{
	int yday;
	time_t thistime;
	time_t previousyears;
	int utcOffset;
	time_t seconds_into_year;
	if(ts-&gt;year &lt; 1970 || ts-&gt;year &gt; 2100) {
		yday = 0;
		LogError(0, RS_RET_ERR, "getOrdinal: invalid year %d "
			"in timestamp - returning 1970-01-01 instead", ts-&gt;year);
		goto done;
	}
	thistime = syslogTime2time_t(ts);
	previousyears = (time_t) yearInSecs[ts-&gt;year - yearInSec_startYear - 1];
	utcOffset = ts-&gt;OffsetHour*3600 + ts-&gt;OffsetMinute*60;
	if(ts-&gt;OffsetMode == '+')
		utcOffset += -1; 	previousyears += utcOffset;
	seconds_into_year = thistime - previousyears;
	yday = seconds_into_year / 86400;
done:
	return yday;
}
int getWeek(struct syslogTime *ts)
{
	int weekNum;
	struct syslogTime yt;
	int curDow;
	int jan1Dow;
<a name="3"></a>	int curYearDay;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	yt.year = ts-&gt;year;
	yt.month = 1;
	yt.day = 1;
	yt.hour = 0;
	yt.minute = 0;
	yt.second = 0;
	yt.secfracPrecision = 0;
	yt.secfrac = 0;
	yt.OffsetMinute = ts-&gt;OffsetMinute;
	yt.OffsetHour = ts-&gt;OffsetHour;
	yt.OffsetMode = ts-&gt;OffsetMode;
	yt.timeType = TIME_TYPE_RFC3164; 
	curYearDay = getOrdinal(ts);
	curDow = getWeekdayNbr(ts);
	jan1Dow = getWeekdayNbr(&amp;yt);</b></font>
	weekNum = ((curYearDay + 6) / 7);
	if (curDow &lt; jan1Dow) {
		++weekNum;
	}
	return weekNum;
}
int getISOWeek(struct syslogTime *ts, int *year)
{
	int weekNum;
	int curDow;
	int curYearDay;
	curYearDay = getOrdinal(ts);
	curDow = getWeekdayNbr(ts);
	if (curDow == 0) {
		curDow = 7;
	}
	curYearDay++;
	weekNum = (10 + curYearDay - curDow) / 7;
	*year = ts-&gt;year;
	if (weekNum == 0) {
		weekNum = weeksInYear[ts-&gt;year - 1 - 1969];
		*year = ts-&gt;year - 1;
	} else if (weekNum &gt; weeksInYear[ts-&gt;year - 1969]) {
		weekNum = 1;
		*year = ts-&gt;year + 1;
	}
	return weekNum;
}
void
timeConvertToUTC(const struct syslogTime *const __restrict__ local,
	struct syslogTime *const __restrict__ utc)
{
	struct timeval tp;
	tp.tv_sec = syslogTime2time_t(local);
	tp.tv_usec = local-&gt;secfrac;
	timeval2syslogTime(&amp;tp, utc, 1);
}
static int
formatUnixTimeFromTime_t(time_t unixtime, const char *format, char *pBuf,
	__attribute__((unused)) uint pBufMax) {
	struct tm lt;
	assert(format != NULL);
	assert(pBuf != NULL);
	if (gmtime_r(&amp;unixtime, &amp;lt) == NULL) {
		DBGPRINTF("Unexpected error calling gmtime_r().\n");
		return -1;
	}
	if (strcmp(format, "date-rfc3164") == 0) {
		assert(pBufMax &gt;= 16);
		if (lt.tm_mon &lt; 0 || lt.tm_mon &gt; 11) {
			DBGPRINTF("lt.tm_mon is out of range. Value: %d\n", lt.tm_mon);
			return -1;
		}
		sprintf(pBuf, "%s %2d %.2d:%.2d:%.2d",
			monthNames[lt.tm_mon], lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec
		);
	} else if (strcmp(format, "date-rfc3339") == 0) {
		assert(pBufMax &gt;= 26);
		sprintf(pBuf, "%d-%.2d-%.2dT%.2d:%.2d:%.2dZ",
			lt.tm_year + 1900, lt.tm_mon + 1, lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec
		);
	}
	return strlen(pBuf);
}
BEGINobjQueryInterface(datetime)
CODESTARTobjQueryInterface(datetime)
	if(pIf-&gt;ifVersion != datetimeCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;getCurrTime = getCurrTime;
	pIf-&gt;GetTime = getTime;
	pIf-&gt;timeval2syslogTime = timeval2syslogTime;
	pIf-&gt;ParseTIMESTAMP3339 = ParseTIMESTAMP3339;
	pIf-&gt;ParseTIMESTAMP3164 = ParseTIMESTAMP3164;
	pIf-&gt;formatTimestampToMySQL = formatTimestampToMySQL;
	pIf-&gt;formatTimestampToPgSQL = formatTimestampToPgSQL;
	pIf-&gt;formatTimestampSecFrac = formatTimestampSecFrac;
	pIf-&gt;formatTimestamp3339 = formatTimestamp3339;
	pIf-&gt;formatTimestamp3164 = formatTimestamp3164;
	pIf-&gt;formatTimestampUnix = formatTimestampUnix;
	pIf-&gt;syslogTime2time_t = syslogTime2time_t;
	pIf-&gt;formatUnixTimeFromTime_t = formatUnixTimeFromTime_t;
finalize_it:
ENDobjQueryInterface(datetime)
BEGINAbstractObjClassInit(datetime, 1, OBJ_IS_CORE_MODULE) ENDObjClassInit(datetime)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rsconf.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pwd.h&gt;
#include &lt;grp.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/socket.h&gt;
#include "rsyslog.h"
#include "obj.h"
#include "srUtils.h"
#include "ruleset.h"
#include "modules.h"
#include "conf.h"
#include "queue.h"
#include "rsconf.h"
#include "cfsysline.h"
#include "errmsg.h"
#include "action.h"
#include "glbl.h"
#include "unicode-helper.h"
#include "omshell.h"
#include "omusrmsg.h"
#include "omfwd.h"
#include "omfile.h"
#include "ompipe.h"
#include "omdiscard.h"
#include "pmrfc5424.h"
#include "pmrfc3164.h"
#include "smfile.h"
#include "smtradfile.h"
#include "smfwd.h"
#include "smtradfwd.h"
#include "parser.h"
#include "outchannel.h"
#include "threads.h"
#include "datetime.h"
#include "parserif.h"
#include "modules.h"
#include "dirty.h"
#include "template.h"
#include "timezones.h"
extern char* yytext;
DEFobjStaticHelpers
DEFobjCurrIf(ruleset)
DEFobjCurrIf(module)
DEFobjCurrIf(conf)
DEFobjCurrIf(glbl)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)
rsconf_t *runConf = NULL;rsconf_t *loadConf = NULL;
static uchar template_DebugFormat[] = "\"Debug line with all properties:\nFROMHOST: '%FROMHOST%', fromhost-ip: "
"'%fromhost-ip%', HOSTNAME: '%HOSTNAME%', PRI: %PRI%,\nsyslogtag '%syslogtag%', programname: '%programname%', "
"APP-NAME: '%APP-NAME%', PROCID: '%PROCID%', MSGID: '%MSGID%',\nTIMESTAMP: '%TIMESTAMP%', "
"STRUCTURED-DATA: '%STRUCTURED-DATA%',\nmsg: '%msg%'\nescaped msg: '%msg:::drop-cc%'\ninputname: %inputname% "
"rawmsg: '%rawmsg%'\n$!:%$!%\n$.:%$.%\n$/:%$/%\n\n\"";
static uchar template_SyslogProtocol23Format[] = "\"&lt;%PRI%&gt;1 %TIMESTAMP:::date-rfc3339% %HOSTNAME% %APP-NAME% "
"%PROCID% %MSGID% %STRUCTURED-DATA% %msg%\n\"";
static uchar template_SyslogRFC5424Format[] = "\"&lt;%PRI%&gt;1 %TIMESTAMP:::date-rfc3339% %HOSTNAME% %APP-NAME% "
"%PROCID% %MSGID% %STRUCTURED-DATA% %msg%\"";
static uchar template_TraditionalFileFormat[] = "=RSYSLOG_TraditionalFileFormat";
static uchar template_FileFormat[] = "=RSYSLOG_FileFormat";
static uchar template_ForwardFormat[] = "=RSYSLOG_ForwardFormat";
static uchar template_TraditionalForwardFormat[] = "=RSYSLOG_TraditionalForwardFormat";
static uchar template_WallFmt[] = "\"\r\n\7Message from syslogd@%HOSTNAME% at %timegenerated% ...\r\n "
"%syslogtag%%msg%\n\r\"";
static uchar template_StdUsrMsgFmt[] = "\" %syslogtag%%msg%\n\r\"";
static uchar template_StdDBFmt[] = "\"insert into SystemEvents (Message, Facility, FromHost, Priority, "
"DeviceReportedTime, ReceivedAt, InfoUnitID, SysLogTag) values ('%msg%', %syslogfacility%, "
"'%HOSTNAME%', %syslogpriority%, '%timereported:::date-mysql%', '%timegenerated:::date-mysql%', %iut%, "
"'%syslogtag%')\",SQL";
static uchar template_StdPgSQLFmt[] = "\"insert into SystemEvents (Message, Facility, FromHost, Priority, "
"DeviceReportedTime, ReceivedAt, InfoUnitID, SysLogTag) values ('%msg%', %syslogfacility%, "
"'%HOSTNAME%', %syslogpriority%, '%timereported:::date-pgsql%', '%timegenerated:::date-pgsql%', %iut%, "
"'%syslogtag%')\",STDSQL";
static uchar template_spoofadr[] = "\"%fromhost-ip%\"";
static uchar template_SysklogdFileFormat[] = "\"%TIMESTAMP% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg%\n\"";
static uchar template_StdJSONFmt[] = "\"{\\\"message\\\":\\\"%msg:::json%\\\",\\\"fromhost\\\":\\\""
"%HOSTNAME:::json%\\\",\\\"facility\\\":\\\"%syslogfacility-text%\\\",\\\"priority\\\":\\\""
"%syslogpriority-text%\\\",\\\"timereported\\\":\\\"%timereported:::date-rfc3339%\\\",\\\"timegenerated\\\":\\\""
"%timegenerated:::date-rfc3339%\\\"}\"";
static uchar template_FullJSONFmt[] = "\"{\\\"message\\\":\\\"%msg:::json%\\\","
"\\\"fromhost\\\":\\\"%HOSTNAME:::json%\\\","
"\\\"programname\\\":\\\"%programname%\\\","
"\\\"procid\\\":\\\"%PROCID%\\\","
"\\\"msgid\\\":\\\"%MSGID%\\\","
"\\\"facility\\\":\\\"%syslogfacility-text%\\\","
"\\\"priority\\\":\\\"%syslogpriority-text%\\\","
"\\\"timereported\\\":\\\"%timereported:::date-rfc3339%\\\","
"\\\"timegenerated\\\":\\\"%timegenerated:::date-rfc3339%\\\"}\"";
static uchar template_StdClickHouseFmt[] = "\"INSERT INTO rsyslog.SystemEvents (severity, facility, "
"timestamp, hostname, tag, message) VALUES (%syslogseverity%, %syslogfacility%, "
"'%timereported:::date-unixtimestamp%', '%hostname%', '%syslogtag%', '%msg%')\",STDSQL";
static struct cnfparamdescr inppdescr[] = {
	{ "type", eCmdHdlrString, CNFPARAM_REQUIRED }
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};
static struct cnfparamdescr parserpdescr[] = {
	{ "type", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "name", eCmdHdlrString, CNFPARAM_REQUIRED }
};
static struct cnfparamblk parserpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
	  parserpdescr
	};
void cnfDoCfsysline(char *ln);
int rsconfNeedDropPriv(rsconf_t *const cnf)
{
	return ((cnf-&gt;globals.gidDropPriv != 0) || (cnf-&gt;globals.uidDropPriv != 0));
<a name="4"></a>}
static void cnfSetDefaults(rsconf_t *pThis)
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
	pThis-&gt;globals.bAbortOnUncleanConfig = 0;
	pThis-&gt;globals.bReduceRepeatMsgs = 0;
	pThis-&gt;globals.bDebugPrintTemplateList = 1;
	pThis-&gt;globals.bDebugPrintModuleList = 0;
	pThis-&gt;globals.bDebugPrintCfSysLineHandlerList = 0;
	pThis-&gt;globals.bLogStatusMsgs = DFLT_bLogStatusMsgs;
	pThis-&gt;globals.bErrMsgToStderr = 1;
	pThis-&gt;globals.maxErrMsgToStderr = -1;
	pThis-&gt;globals.umask = -1;
	pThis-&gt;globals.gidDropPrivKeepSupplemental = 0;
	pThis-&gt;globals.abortOnIDResolutionFail = 1;
	pThis-&gt;templates.root = NULL;</b></font>
	pThis-&gt;templates.last = NULL;
	pThis-&gt;templates.lastStatic = NULL;
	pThis-&gt;actions.nbrActions = 0;
	pThis-&gt;actions.iActionNbr = 0;
	pThis-&gt;globals.pszWorkDir = NULL;
	pThis-&gt;globals.bDropMalPTRMsgs = 0;
	pThis-&gt;globals.operatingStateFile = NULL;
	pThis-&gt;globals.iGnuTLSLoglevel = 0;
	pThis-&gt;globals.debugOnShutdown = 0;
	pThis-&gt;globals.pszDfltNetstrmDrvrCAF = NULL;
<a name="2"></a>	pThis-&gt;globals.pszDfltNetstrmDrvrCertFile = NULL;
	pThis-&gt;globals.pszDfltNetstrmDrvrKeyFile = NULL;
	pThis-&gt;globals.pszDfltNetstrmDrvr = NULL;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pThis-&gt;globals.oversizeMsgErrorFile = NULL;
	pThis-&gt;globals.reportOversizeMsg = 1;
	pThis-&gt;globals.oversizeMsgInputMode = 0;
	pThis-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_ERRORS;
	pThis-&gt;globals.bActionReportSuspension = 1;
	pThis-&gt;globals.bActionReportSuspensionCont = 0;
	pThis-&gt;globals.janitorInterval = 10;
	pThis-&gt;globals.reportNewSenders = 0;
	pThis-&gt;globals.reportGoneAwaySenders = 0;
	pThis-&gt;globals.senderStatsTimeout = 12 * 60 * 60; 	pThis-&gt;globals.senderKeepTrack = 0;
	pThis-&gt;globals.inputTimeoutShutdown = 1000;
	pThis-&gt;globals.iDefPFFamily = PF_UNSPEC;
	pThis-&gt;globals.ACLAddHostnameOnFail = 0;
	pThis-&gt;globals.ACLDontResolve = 0;
<a name="0"></a>	pThis-&gt;globals.bDisableDNS = 0;</b></font>
	pThis-&gt;globals.bProcessInternalMessages = 0;
	const char *const log_dflt = getenv("RSYSLOG_DFLT_LOG_INTERNAL");
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(log_dflt != NULL &amp;&amp; !strcmp(log_dflt, "1"))
		pThis-&gt;globals.bProcessInternalMessages = 1;
	pThis-&gt;globals.glblDevOptions = 0;
	pThis-&gt;globals.intMsgRateLimitItv = 5;
	pThis-&gt;globals.intMsgRateLimitBurst = 500;
	pThis-&gt;globals.intMsgsSeverityFilter = DFLT_INT_MSGS_SEV_FILTER;
	pThis-&gt;globals.permitCtlC = glblPermitCtlC;
	pThis-&gt;globals.actq_dflt_toQShutdown = 10;
	pThis-&gt;globals.actq_dflt_toActShutdown = 1000;
	pThis-&gt;globals.actq_dflt_toEnq = 2000;
	pThis-&gt;globals.actq_dflt_toWrkShutdown = 60000;
	pThis-&gt;globals.ruleset_dflt_toQShutdown = 1500;
	pThis-&gt;globals.ruleset_dflt_toActShutdown = 1000;
	pThis-&gt;globals.ruleset_dflt_toEnq = 2000;
	pThis-&gt;globals.ruleset_dflt_toWrkShutdown = 60000;
	pThis-&gt;globals.dnscacheDefaultTTL = 24 * 60 * 60;
	pThis-&gt;globals.dnscacheEnableTTL = 0;
	pThis-&gt;globals.shutdownQueueDoubleSize = 0;
	pThis-&gt;globals.optionDisallowWarning = 1;
	pThis-&gt;globals.bSupportCompressionExtension = 1;
	#ifdef ENABLE_LIBLOGGING_STDLOG
		pThis-&gt;globals.stdlog_hdl = stdlog_open("rsyslogd", 0, STDLOG_SYSLOG, NULL);</b></font>
		pThis-&gt;globals.stdlog_chanspec = NULL;
	#endif
	pThis-&gt;globals.iMaxLine = 8096;
	pThis-&gt;timezones.tzinfos = NULL;
	pThis-&gt;timezones.ntzinfos = 0;
	pThis-&gt;globals.mainQ.iMainMsgQueueSize = 100000;
	pThis-&gt;globals.mainQ.iMainMsgQHighWtrMark = 80000;
	pThis-&gt;globals.mainQ.iMainMsgQLowWtrMark = 20000;
	pThis-&gt;globals.mainQ.iMainMsgQDiscardMark = 98000;
	pThis-&gt;globals.mainQ.iMainMsgQDiscardSeverity = 8;
<a name="3"></a>	pThis-&gt;globals.mainQ.iMainMsgQueueNumWorkers = 2;
	pThis-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
	pThis-&gt;globals.mainQ.pszMainMsgQFName = NULL;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pThis-&gt;globals.mainQ.iMainMsgQueMaxFileSize = 1024*1024;
	pThis-&gt;globals.mainQ.iMainMsgQPersistUpdCnt = 0;
	pThis-&gt;globals.mainQ.bMainMsgQSyncQeueFiles = 0;
	pThis-&gt;globals.mainQ.iMainMsgQtoQShutdown = 1500;
	pThis-&gt;globals.mainQ.iMainMsgQtoActShutdown = 1000;
	pThis-&gt;globals.mainQ.iMainMsgQtoEnq = 2000;
	pThis-&gt;globals.mainQ.iMainMsgQtoWrkShutdown = 60000;
	pThis-&gt;globals.mainQ.iMainMsgQWrkMinMsgs = 40000;
	pThis-&gt;globals.mainQ.iMainMsgQDeqSlowdown = 0;
	pThis-&gt;globals.mainQ.iMainMsgQueMaxDiskSpace = 0;
	pThis-&gt;globals.mainQ.iMainMsgQueDeqBatchSize = 256;
	pThis-&gt;globals.mainQ.bMainMsgQSaveOnShutdown = 1;
	pThis-&gt;globals.mainQ.iMainMsgQueueDeqtWinFromHr = 0;
	pThis-&gt;globals.mainQ.iMainMsgQueueDeqtWinToHr = 25;
	pThis-&gt;pMsgQueue = NULL;</b></font>
	pThis-&gt;globals.parser.cCCEscapeChar = '#';
	pThis-&gt;globals.parser.bDropTrailingLF = 1;
	pThis-&gt;globals.parser.bEscapeCCOnRcv = 1;
	pThis-&gt;globals.parser.bSpaceLFOnRcv = 0;
	pThis-&gt;globals.parser.bEscape8BitChars = 0;
	pThis-&gt;globals.parser.bEscapeTab = 1;
	pThis-&gt;globals.parser.bParserEscapeCCCStyle = 0;
	pThis-&gt;globals.parser.bPermitSlashInProgramname = 0;
	pThis-&gt;globals.parser.bParseHOSTNAMEandTAG = 1;
	pThis-&gt;parsers.pDfltParsLst = NULL;
	pThis-&gt;parsers.pParsLstRoot = NULL;
}
BEGINobjConstruct(rsconf) 	cnfSetDefaults(pThis);
	lookupInitCnf(&amp;pThis-&gt;lu_tabs);
	CHKiRet(dynstats_initCnf(&amp;pThis-&gt;dynstats_buckets));
	CHKiRet(perctile_initCnf(&amp;pThis-&gt;perctile_buckets));
	CHKiRet(llInit(&amp;pThis-&gt;rulesets.llRulesets, rulesetDestructForLinkedList,
			rulesetKeyDestruct, strcasecmp));
finalize_it:
ENDobjConstruct(rsconf)
static rsRetVal
rsconfConstructFinalize(rsconf_t __attribute__((unused)) *pThis)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, rsconf);
	RETiRet;
}
static void
freeCnf(rsconf_t *pThis)
{
	cfgmodules_etry_t *etry, *del;
	etry = pThis-&gt;modules.root;
	while(etry != NULL) {
		if(etry-&gt;pMod-&gt;beginCnfLoad != NULL) {
			dbgprintf("calling freeCnf(%p) for module '%s'\n",
				  etry-&gt;modCnf, (char*) module.GetName(etry-&gt;pMod));
			etry-&gt;pMod-&gt;freeCnf(etry-&gt;modCnf);
		}
		del = etry;
		etry = etry-&gt;next;
		free(del);
	}
}
PROTOTYPEobjDestruct(rsconf);
BEGINobjDestruct(rsconf) CODESTARTobjDestruct(rsconf)
	freeCnf(pThis);
	tplDeleteAll(pThis);
	dynstats_destroyAllBuckets();
	perctileBucketsDestruct();
	ochDeleteAll();
	freeTimezones(pThis);
	parser.DestructParserList(&amp;pThis-&gt;parsers.pDfltParsLst);
	parser.destroyMasterParserList(pThis-&gt;parsers.pParsLstRoot);
	free(pThis-&gt;globals.mainQ.pszMainMsgQFName);
	free(pThis-&gt;globals.pszConfDAGFile);
	free(pThis-&gt;globals.pszWorkDir);
	free(pThis-&gt;globals.operatingStateFile);
	free(pThis-&gt;globals.pszDfltNetstrmDrvrCAF);
	free(pThis-&gt;globals.pszDfltNetstrmDrvrCertFile);
	free(pThis-&gt;globals.pszDfltNetstrmDrvrKeyFile);
	free(pThis-&gt;globals.pszDfltNetstrmDrvr);
	free(pThis-&gt;globals.oversizeMsgErrorFile);
	#ifdef ENABLE_LIBLOGGING_STDLOG
		stdlog_close(pThis-&gt;globals.stdlog_hdl);
		free(pThis-&gt;globals.stdlog_chanspec);
	#endif
	lookupDestroyCnf();
	llDestroy(&amp;(pThis-&gt;rulesets.llRulesets));
ENDobjDestruct(rsconf)
PROTOTYPEObjDebugPrint(rsconf);
BEGINobjDebugPrint(rsconf) 	cfgmodules_etry_t *modNode;
	dbgprintf("configuration object %p\n", pThis);
	dbgprintf("Global Settings:\n");
	dbgprintf("  bDebugPrintTemplateList.............: %d\n",
		  pThis-&gt;globals.bDebugPrintTemplateList);
	dbgprintf("  bDebugPrintModuleList               : %d\n",
		  pThis-&gt;globals.bDebugPrintModuleList);
	dbgprintf("  bDebugPrintCfSysLineHandlerList.....: %d\n",
		  pThis-&gt;globals.bDebugPrintCfSysLineHandlerList);
	dbgprintf("  bLogStatusMsgs                      : %d\n",
		  pThis-&gt;globals.bLogStatusMsgs);
	dbgprintf("  bErrMsgToStderr.....................: %d\n",
		  pThis-&gt;globals.bErrMsgToStderr);
	dbgprintf("  drop Msgs with malicious PTR Record : %d\n",
		  glbl.GetDropMalPTRMsgs(pThis));
	ruleset.DebugPrintAll(pThis);
	dbgprintf("\n");
	if(pThis-&gt;globals.bDebugPrintTemplateList)
		tplPrintList(pThis);
	if(pThis-&gt;globals.bDebugPrintModuleList)
		module.PrintList();
	if(pThis-&gt;globals.bDebugPrintCfSysLineHandlerList)
		dbgPrintCfSysLineHandlers();
	dbgprintf("Main queue size %d messages.\n", pThis-&gt;globals.mainQ.iMainMsgQueueSize);
	dbgprintf("Main queue worker threads: %d, wThread shutdown: %d, Perists every %d updates.\n",
		  pThis-&gt;globals.mainQ.iMainMsgQueueNumWorkers,
		  pThis-&gt;globals.mainQ.iMainMsgQtoWrkShutdown, pThis-&gt;globals.mainQ.iMainMsgQPersistUpdCnt);
	dbgprintf("Main queue timeouts: shutdown: %d, action completion shutdown: %d, enq: %d\n",
		   pThis-&gt;globals.mainQ.iMainMsgQtoQShutdown,
		   pThis-&gt;globals.mainQ.iMainMsgQtoActShutdown, pThis-&gt;globals.mainQ.iMainMsgQtoEnq);
	dbgprintf("Main queue watermarks: high: %d, low: %d, discard: %d, discard-severity: %d\n",
		   pThis-&gt;globals.mainQ.iMainMsgQHighWtrMark, pThis-&gt;globals.mainQ.iMainMsgQLowWtrMark,
		   pThis-&gt;globals.mainQ.iMainMsgQDiscardMark, pThis-&gt;globals.mainQ.iMainMsgQDiscardSeverity);
	dbgprintf("Main queue save on shutdown %d, max disk space allowed %lld\n",
		   pThis-&gt;globals.mainQ.bMainMsgQSaveOnShutdown, pThis-&gt;globals.mainQ.iMainMsgQueMaxDiskSpace);
	dbgprintf("Work Directory: '%s'.\n", glbl.GetWorkDir(pThis));
	ochPrintList(pThis);
	dbgprintf("Modules used in this configuration:\n");
	for(modNode = pThis-&gt;modules.root ; modNode != NULL ; modNode = modNode-&gt;next) {
		dbgprintf("    %s\n", module.GetName(modNode-&gt;pMod));
	}
CODESTARTobjDebugPrint(rsconf)
ENDobjDebugPrint(rsconf)
static rsRetVal
parserProcessCnf(struct cnfobj *o)
{
	struct cnfparamvals *pvals;
	modInfo_t *pMod;
	uchar *cnfModName = NULL;
	uchar *parserName = NULL;
	int paramIdx;
	void *parserInst;
	parser_t *myparser;
	DEFiRet;
	pvals = nvlstGetParams(o-&gt;nvlst, &amp;parserpblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	DBGPRINTF("input param blk after parserProcessCnf:\n");
	cnfparamsPrint(&amp;parserpblk, pvals);
	paramIdx = cnfparamGetIdx(&amp;parserpblk, "name");
	parserName = (uchar*)es_str2cstr(pvals[paramIdx].val.d.estr, NULL);
	if(parser.FindParser(loadConf-&gt;parsers.pParsLstRoot, &amp;myparser, parserName) != RS_RET_PARSER_NOT_FOUND) {
		LogError(0, RS_RET_PARSER_NAME_EXISTS,
			"parser module name '%s' already exists", parserName);
		ABORT_FINALIZE(RS_RET_PARSER_NAME_EXISTS);
	}
	paramIdx = cnfparamGetIdx(&amp;parserpblk, "type");
	cnfModName = (uchar*)es_str2cstr(pvals[paramIdx].val.d.estr, NULL);
	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_PARSER)) == NULL) {
		LogError(0, RS_RET_MOD_UNKNOWN, "parser module name '%s' is unknown", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
	}
	if(pMod-&gt;mod.pm.newParserInst == NULL) {
		LogError(0, RS_RET_MOD_NO_PARSER_STMT,
				"parser module '%s' does not support parser() statement", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_NO_INPUT_STMT);
	}
	CHKiRet(pMod-&gt;mod.pm.newParserInst(o-&gt;nvlst, &amp;parserInst));
	CHKiRet(parserConstructViaModAndName(pMod, parserName, parserInst));
finalize_it:
	free(cnfModName);
	free(parserName);
	cnfparamvalsDestruct(pvals, &amp;parserpblk);
	RETiRet;
}
static rsRetVal
inputProcessCnf(struct cnfobj *o)
{
	struct cnfparamvals *pvals;
	modInfo_t *pMod;
	uchar *cnfModName = NULL;
	int typeIdx;
	DEFiRet;
	pvals = nvlstGetParams(o-&gt;nvlst, &amp;inppblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	DBGPRINTF("input param blk after inputProcessCnf:\n");
	cnfparamsPrint(&amp;inppblk, pvals);
	typeIdx = cnfparamGetIdx(&amp;inppblk, "type");
	cnfModName = (uchar*)es_str2cstr(pvals[typeIdx].val.d.estr, NULL);
	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_IN)) == NULL) {
		LogError(0, RS_RET_MOD_UNKNOWN, "input module name '%s' is unknown", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
	}
	if(pMod-&gt;mod.im.newInpInst == NULL) {
		LogError(0, RS_RET_MOD_NO_INPUT_STMT,
				"input module '%s' does not support input() statement", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_NO_INPUT_STMT);
	}
	iRet = pMod-&gt;mod.im.newInpInst(o-&gt;nvlst);
finalize_it:
	free(cnfModName);
	cnfparamvalsDestruct(pvals, &amp;inppblk);
	RETiRet;
}
extern int yylineno;
void
parser_warnmsg(const char *fmt, ...)
{
	va_list ap;
	char errBuf[1024];
	va_start(ap, fmt);
	if(vsnprintf(errBuf, sizeof(errBuf), fmt, ap) == sizeof(errBuf))
		errBuf[sizeof(errBuf)-1] = '\0';
	LogMsg(0, RS_RET_CONF_PARSE_WARNING, LOG_WARNING,
			"warning during parsing file %s, on or before line %d: %s",
			cnfcurrfn, yylineno, errBuf);
	va_end(ap);
}
void
parser_errmsg(const char *fmt, ...)
{
	va_list ap;
	char errBuf[1024];
	va_start(ap, fmt);
	if(vsnprintf(errBuf, sizeof(errBuf), fmt, ap) == sizeof(errBuf))
		errBuf[sizeof(errBuf)-1] = '\0';
	if(cnfcurrfn == NULL) {
		LogError(0, RS_RET_CONF_PARSE_ERROR,
				"error during config processing: %s", errBuf);
	} else {
		LogError(0, RS_RET_CONF_PARSE_ERROR,
				"error during parsing file %s, on or before line %d: %s",
				cnfcurrfn, yylineno, errBuf);
	}
	va_end(ap);
}
int yyerror(const char *s); int
yyerror(const char *s)
{
	parser_errmsg("%s on token '%s'", s, yytext);
	return 0;
}
void ATTR_NONNULL()
cnfDoObj(struct cnfobj *const o)
{
	int bDestructObj = 1;
	int bChkUnuse = 1;
	assert(o != NULL);
	dbgprintf("cnf:global:obj: ");
	cnfobjPrint(o);
	if (nvlstChkDisabled(o-&gt;nvlst)) {
		dbgprintf("object disabled by configuration\n");
		return;
	}
	switch(o-&gt;objType) {
	case CNFOBJ_GLOBAL:
		glblProcessCnf(o);
		break;
	case CNFOBJ_TIMEZONE:
		glblProcessTimezone(o);
		break;
	case CNFOBJ_MAINQ:
		glblProcessMainQCnf(o);
		bDestructObj = 0;
		break;
	case CNFOBJ_MODULE:
		modulesProcessCnf(o);
		break;
	case CNFOBJ_INPUT:
		inputProcessCnf(o);
		break;
	case CNFOBJ_LOOKUP_TABLE:
		lookupTableDefProcessCnf(o);
		break;
	case CNFOBJ_DYN_STATS:
		dynstats_processCnf(o);
		break;
	case CNFOBJ_PERCTILE_STATS:
		perctile_processCnf(o);
		break;
	case CNFOBJ_PARSER:
		parserProcessCnf(o);
		break;
	case CNFOBJ_TPL:
		if(tplProcessCnf(o) != RS_RET_OK)
			parser_errmsg("error processing template object");
		break;
	case CNFOBJ_RULESET:
		rulesetProcessCnf(o);
		break;
	case CNFOBJ_PROPERTY:
	case CNFOBJ_CONSTANT:
		bChkUnuse = 0;
		break;
	case CNFOBJ_ACTION:
	default:
		dbgprintf("cnfDoObj program error: unexpected object type %u\n",
			 o-&gt;objType);
		break;
	}
	if(bDestructObj) {
		if(bChkUnuse)
			nvlstChkUnused(o-&gt;nvlst);
		cnfobjDestruct(o);
	 }
}
void cnfDoScript(struct cnfstmt *script)
{
	dbgprintf("cnf:global:script\n");
	ruleset.AddScript(ruleset.GetCurrent(loadConf), script);
}
void cnfDoCfsysline(char *ln)
{
	DBGPRINTF("cnf:global:cfsysline: %s\n", ln);
	conf.cfsysline((uchar*) ln+1);
	free(ln);
}
void cnfDoBSDTag(char *ln)
{
	DBGPRINTF("cnf:global:BSD tag: %s\n", ln);
	LogError(0, RS_RET_BSD_BLOCKS_UNSUPPORTED,
			"BSD-style blocks are no longer supported in rsyslog, "
			"see https://www.rsyslog.com/g/BSD for details and a "
			"solution (Block '%s')", ln);
	free(ln);
}
void cnfDoBSDHost(char *ln)
{
	DBGPRINTF("cnf:global:BSD host: %s\n", ln);
	LogError(0, RS_RET_BSD_BLOCKS_UNSUPPORTED,
			"BSD-style blocks are no longer supported in rsyslog, "
			"see https://www.rsyslog.com/g/BSD for details and a "
			"solution (Block '%s')", ln);
	free(ln);
}
static
rsRetVal doDropPrivGid(rsconf_t *cnf)
{
	int res;
	uchar szBuf[1024];
	DEFiRet;
	if(!cnf-&gt;globals.gidDropPrivKeepSupplemental) {
		res = setgroups(0, NULL); 		if(res) {
			LogError(errno, RS_RET_ERR_DROP_PRIV,
					"could not remove supplemental group IDs");
			ABORT_FINALIZE(RS_RET_ERR_DROP_PRIV);
		}
		DBGPRINTF("setgroups(0, NULL): %d\n", res);
	}
	res = setgid(cnf-&gt;globals.gidDropPriv);
	if(res) {
		LogError(errno, RS_RET_ERR_DROP_PRIV,
				"could not set requested group id %d", cnf-&gt;globals.gidDropPriv);
		ABORT_FINALIZE(RS_RET_ERR_DROP_PRIV);
	}
	DBGPRINTF("setgid(%d): %d\n", cnf-&gt;globals.gidDropPriv, res);
	snprintf((char*)szBuf, sizeof(szBuf), "rsyslogd's groupid changed to %d",
		 cnf-&gt;globals.gidDropPriv);
	logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO, szBuf, 0);
finalize_it:
	RETiRet;
}
static void doDropPrivUid(rsconf_t *cnf)
{
	int res;
	uchar szBuf[1024];
	struct passwd *pw;
	gid_t gid;
	pw = getpwuid(cnf-&gt;globals.uidDropPriv);
	if (pw) {
		gid = getgid();
		res = initgroups(pw-&gt;pw_name, gid);
		DBGPRINTF("initgroups(%s, %ld): %d\n", pw-&gt;pw_name, (long) gid, res);
	} else {
		LogError(errno, NO_ERRCODE, "could not get username for userid '%d'",
			cnf-&gt;globals.uidDropPriv);
	}
	res = setuid(cnf-&gt;globals.uidDropPriv);
	if(res) {
		perror("could not set requested userid");
		exit(1);
	}
	DBGPRINTF("setuid(%d): %d\n", cnf-&gt;globals.uidDropPriv, res);
	snprintf((char*)szBuf, sizeof(szBuf), "rsyslogd's userid changed to %d", cnf-&gt;globals.uidDropPriv);
	logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO, szBuf, 0);
}
static rsRetVal
dropPrivileges(rsconf_t *cnf)
{
	DEFiRet;
	if(cnf-&gt;globals.gidDropPriv != 0) {
		CHKiRet(doDropPrivGid(cnf));
		DBGPRINTF("group privileges have been dropped to gid %u\n", (unsigned)
			  cnf-&gt;globals.gidDropPriv);
	}
	if(cnf-&gt;globals.uidDropPriv != 0) {
		doDropPrivUid(cnf);
		DBGPRINTF("user privileges have been dropped to uid %u\n", (unsigned)
			  cnf-&gt;globals.uidDropPriv);
	}
finalize_it:
	RETiRet;
}
static inline rsRetVal
tellCoreConfigLoadDone(void)
{
	DBGPRINTF("telling rsyslog core that config load for %p is done\n", loadConf);
	return glblDoneLoadCnf();
}
static rsRetVal
tellModulesConfigLoadDone(void)
{
	cfgmodules_etry_t *node;
	DBGPRINTF("telling modules that config load for %p is done\n", loadConf);
	node = module.GetNxtCnfType(loadConf, NULL, eMOD_ANY);
	while(node != NULL) {
		DBGPRINTF("beginCnfLoad(%p) for module '%s'\n", node-&gt;pMod-&gt;beginCnfLoad, node-&gt;pMod-&gt;pszName);
		if(node-&gt;pMod-&gt;beginCnfLoad != NULL) {
			DBGPRINTF("calling endCnfLoad() for module '%s'\n", node-&gt;pMod-&gt;pszName);
			node-&gt;pMod-&gt;endCnfLoad(node-&gt;modCnf);
		}
		node = module.GetNxtCnfType(loadConf, node, eMOD_ANY); 	}
	return RS_RET_OK; }
static rsRetVal
tellModulesCheckConfig(void)
{
	cfgmodules_etry_t *node;
	rsRetVal localRet;
	DBGPRINTF("telling modules to check config %p\n", loadConf);
	node = module.GetNxtCnfType(loadConf, NULL, eMOD_ANY);
	while(node != NULL) {
		if(node-&gt;pMod-&gt;beginCnfLoad != NULL) {
			localRet = node-&gt;pMod-&gt;checkCnf(node-&gt;modCnf);
			DBGPRINTF("module %s tells us config can %sbe activated\n",
					  node-&gt;pMod-&gt;pszName, (localRet == RS_RET_OK) ? "" : "NOT ");
			if(localRet == RS_RET_OK) {
				node-&gt;canActivate = 1;
			} else {
				node-&gt;canActivate = 0;
			}
		}
		node = module.GetNxtCnfType(loadConf, node, eMOD_ANY); 	}
	return RS_RET_OK; }
static rsRetVal
tellModulesActivateConfigPrePrivDrop(void)
{
	cfgmodules_etry_t *node;
	rsRetVal localRet;
	DBGPRINTF("telling modules to activate config (before dropping privs) %p\n", runConf);
	node = module.GetNxtCnfType(runConf, NULL, eMOD_ANY);
	while(node != NULL) {
		if(   node-&gt;pMod-&gt;beginCnfLoad != NULL
		   &amp;&amp; node-&gt;pMod-&gt;activateCnfPrePrivDrop != NULL
		   &amp;&amp; node-&gt;canActivate) {
			DBGPRINTF("pre priv drop activating config %p for module %s\n",
				  runConf, node-&gt;pMod-&gt;pszName);
			localRet = node-&gt;pMod-&gt;activateCnfPrePrivDrop(node-&gt;modCnf);
			if(localRet != RS_RET_OK) {
				LogError(0, localRet, "activation of module %s failed",
						node-&gt;pMod-&gt;pszName);
			node-&gt;canActivate = 0; 			}
		}
		node = module.GetNxtCnfType(runConf, node, eMOD_ANY);
	}
	return RS_RET_OK; }
static rsRetVal
tellModulesActivateConfig(void)
{
	cfgmodules_etry_t *node;
	rsRetVal localRet;
	DBGPRINTF("telling modules to activate config %p\n", runConf);
	node = module.GetNxtCnfType(runConf, NULL, eMOD_ANY);
	while(node != NULL) {
		if(node-&gt;pMod-&gt;beginCnfLoad != NULL &amp;&amp; node-&gt;canActivate) {
			DBGPRINTF("activating config %p for module %s\n",
				  runConf, node-&gt;pMod-&gt;pszName);
			localRet = node-&gt;pMod-&gt;activateCnf(node-&gt;modCnf);
			if(localRet != RS_RET_OK) {
				LogError(0, localRet, "activation of module %s failed",
						node-&gt;pMod-&gt;pszName);
			node-&gt;canActivate = 0; 			}
		}
		node = module.GetNxtCnfType(runConf, node, eMOD_ANY);
	}
	return RS_RET_OK; }
static rsRetVal
runInputModules(void)
{
	cfgmodules_etry_t *node;
	int bNeedsCancel;
	node = module.GetNxtCnfType(runConf, NULL, eMOD_IN);
	while(node != NULL) {
		if(node-&gt;canRun) {
			bNeedsCancel = (node-&gt;pMod-&gt;isCompatibleWithFeature(sFEATURENonCancelInputTermination)
			== RS_RET_OK) ? 0 : 1;
			DBGPRINTF("running module %s with config %p, term mode: %s\n", node-&gt;pMod-&gt;pszName, node,
				  bNeedsCancel ? "cancel" : "cooperative/SIGTTIN");
			thrdCreate(node-&gt;pMod-&gt;mod.im.runInput, node-&gt;pMod-&gt;mod.im.afterRun, bNeedsCancel,
			           (node-&gt;pMod-&gt;cnfName == NULL) ? node-&gt;pMod-&gt;pszName : node-&gt;pMod-&gt;cnfName);
		}
		node = module.GetNxtCnfType(runConf, node, eMOD_IN);
	}
	return RS_RET_OK; }
static rsRetVal
startInputModules(void)
{
	DEFiRet;
	cfgmodules_etry_t *node;
	node = module.GetNxtCnfType(runConf, NULL, eMOD_IN);
	while(node != NULL) {
		if(node-&gt;canActivate) {
			iRet = node-&gt;pMod-&gt;mod.im.willRun();
			node-&gt;canRun = (iRet == RS_RET_OK);
			if(!node-&gt;canRun) {
				DBGPRINTF("module %s will not run, iRet %d\n", node-&gt;pMod-&gt;pszName, iRet);
			}
		} else {
			node-&gt;canRun = 0;
		}
		node = module.GetNxtCnfType(runConf, node, eMOD_IN);
	}
	return RS_RET_OK; }
static rsRetVal
loadMainQueue(void)
{
	DEFiRet;
	struct cnfobj *mainqCnfObj;
	mainqCnfObj = glbl.GetmainqCnfObj();
	DBGPRINTF("loadMainQueue: mainq cnf obj ptr is %p\n", mainqCnfObj);
	iRet = createMainQueue(&amp;loadConf-&gt;pMsgQueue, UCHAR_CONSTANT("main Q"),
		    		(mainqCnfObj == NULL) ? NULL : mainqCnfObj-&gt;nvlst);
	if (iRet == RS_RET_OK) {
		if (runConf != NULL) { 			int areEqual = queuesEqual(loadConf-&gt;pMsgQueue, runConf-&gt;pMsgQueue);
			DBGPRINTF("Comparison of old and new main queues: %d\n", areEqual);
			if (areEqual) { 				qqueueDestruct(&amp;loadConf-&gt;pMsgQueue);
				loadConf-&gt;pMsgQueue = runConf-&gt;pMsgQueue;
			}
		}
	}
	if(iRet != RS_RET_OK) {
		fprintf(stderr, "fatal error %d: could not create message queue - rsyslogd can not run!\n", iRet);
		FINALIZE;
	}
finalize_it:
	glblDestructMainqCnfObj();
	RETiRet;
}
static rsRetVal
activateMainQueue(void)
{
	DEFiRet;
	DBGPRINTF("activateMainQueue: will try to activate main queue %p\n", runConf-&gt;pMsgQueue);
	iRet = startMainQueue(runConf, runConf-&gt;pMsgQueue);
	if(iRet != RS_RET_OK) {
		fprintf(stderr, "fatal error %d: could not create message queue - rsyslogd can not run!\n", iRet);
		FINALIZE;
	}
	if(runConf-&gt;globals.mainQ.MainMsgQueType == QUEUETYPE_DIRECT) {
		PREFER_STORE_0_TO_INT(&amp;bHaveMainQueue);
	} else {
		PREFER_STORE_1_TO_INT(&amp;bHaveMainQueue);
	}
	DBGPRINTF("Main processing queue is initialized and running\n");
finalize_it:
	RETiRet;
}
static inline rsRetVal
setUmask(int iUmask)
{
	if(iUmask != -1) {
		umask(iUmask);
		DBGPRINTF("umask set to 0%3.3o.\n", iUmask);
	}
	return RS_RET_OK;
}
static void
cleanupOldCnf(rsconf_t *cnf)
{
	if (cnf == NULL)
		FINALIZE;
	if (runConf-&gt;pMsgQueue != cnf-&gt;pMsgQueue)
		qqueueDestruct(&amp;cnf-&gt;pMsgQueue);
finalize_it:
	return;
}
static rsRetVal
activate(rsconf_t *cnf)
{
	DEFiRet;
	rsconf_t *runCnfOld = runConf;
	runConf = cnf;
	loadConf = NULL;
#	if	0 	if(ourConf-&gt;globals.pszConfDAGFile != NULL)
		generateConfigDAG(ourConf-&gt;globals.pszConfDAGFile);
#	endif
	setUmask(cnf-&gt;globals.umask);
	tellModulesActivateConfigPrePrivDrop();
	CHKiRet(dropPrivileges(cnf));
	tellModulesActivateConfig();
	startInputModules();
	CHKiRet(activateActions());
	CHKiRet(activateRulesetQueues());
	CHKiRet(activateMainQueue());
	runInputModules();
	qqueueDoneLoadCnf(); 
	dbgprintf("configuration %p activated\n", cnf);
	cleanupOldCnf(runCnfOld);
finalize_it:
	RETiRet;
}
static rsRetVal setActionResumeInterval(void __attribute__((unused)) *pVal, int iNewVal)
{
	return actionSetGlobalResumeInterval(iNewVal);
}
static rsRetVal
setDefaultRuleset(void __attribute__((unused)) *pVal, uchar *pszName)
{
	DEFiRet;
	CHKiRet(ruleset.SetDefaultRuleset(ourConf, pszName));
finalize_it:
	free(pszName); 	RETiRet;
}
static rsRetVal
setCurrRuleset(void __attribute__((unused)) *pVal, uchar *pszName)
{
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;
	localRet = ruleset.SetCurrRuleset(ourConf, pszName);
	if(localRet == RS_RET_NOT_FOUND) {
		DBGPRINTF("begin new current rule set '%s'\n", pszName);
		CHKiRet(ruleset.Construct(&amp;pRuleset));
		CHKiRet(ruleset.SetName(pRuleset, pszName));
		CHKiRet(ruleset.ConstructFinalize(ourConf, pRuleset));
		rulesetSetCurrRulesetPtr(pRuleset);
	} else {
		ABORT_FINALIZE(localRet);
	}
finalize_it:
	free(pszName); 	RETiRet;
}
static rsRetVal setMainMsgQueType(void __attribute__((unused)) *pVal, uchar *pszType)
{
	DEFiRet;
	if (!strcasecmp((char *) pszType, "fixedarray")) {
		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
		DBGPRINTF("main message queue type set to FIXED_ARRAY\n");
	} else if (!strcasecmp((char *) pszType, "linkedlist")) {
		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_LINKEDLIST;
		DBGPRINTF("main message queue type set to LINKEDLIST\n");
	} else if (!strcasecmp((char *) pszType, "disk")) {
		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_DISK;
		DBGPRINTF("main message queue type set to DISK\n");
	} else if (!strcasecmp((char *) pszType, "direct")) {
		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_DIRECT;
		DBGPRINTF("main message queue type set to DIRECT (no queueing at all)\n");
	} else {
		LogError(0, RS_RET_INVALID_PARAMS, "unknown mainmessagequeuetype parameter: %s",
			(char *) pszType);
		iRet = RS_RET_INVALID_PARAMS;
	}
	free(pszType); 
	RETiRet;
}
static rsRetVal setMaxFiles(void __attribute__((unused)) *pVal, int iFiles)
{
	struct rlimit maxFiles;
	char errStr[1024];
	DEFiRet;
	maxFiles.rlim_cur = iFiles;
	maxFiles.rlim_max = iFiles;
	if(setrlimit(RLIMIT_NOFILE, &amp;maxFiles) &lt; 0) {
		rs_strerror_r(errno, errStr, sizeof(errStr));
		LogError(0, RS_RET_ERR_RLIM_NOFILE, "could not set process file limit to %d: %s "
			"[kernel max %ld]", iFiles, errStr, (long) maxFiles.rlim_max);
		ABORT_FINALIZE(RS_RET_ERR_RLIM_NOFILE);
	}
#ifdef USE_UNLIMITED_SELECT
	glbl.SetFdSetSize(howmany(iFiles, __NFDBITS) * sizeof (fd_mask));
#endif
	DBGPRINTF("Max number of files set to %d [kernel max %ld].\n", iFiles, (long) maxFiles.rlim_max);
finalize_it:
	RETiRet;
}
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	free(loadConf-&gt;globals.mainQ.pszMainMsgQFName);
	cnfSetDefaults(loadConf);
	return RS_RET_OK;
}
static rsRetVal
setModDir(void __attribute__((unused)) *pVal, uchar* pszNewVal)
{
	DEFiRet;
	iRet = module.SetModDir(pszNewVal);
	free(pszNewVal);
	RETiRet;
}
static rsRetVal
regBuildInModule(rsRetVal (*modInit)(), uchar *name, void *pModHdlr)
{
	cfgmodules_etry_t *pNew;
	cfgmodules_etry_t *pLast;
	modInfo_t *pMod;
	DEFiRet;
	CHKiRet(module.doModInit(modInit, name, pModHdlr, &amp;pMod));
	readyModForCnf(pMod, &amp;pNew, &amp;pLast);
	addModToCnfList(&amp;pNew, pLast);
finalize_it:
	RETiRet;
}
static rsRetVal
loadBuildInModules(void)
{
	DEFiRet;
	CHKiRet(regBuildInModule(modInitFile, UCHAR_CONSTANT("builtin:omfile"), NULL));
	CHKiRet(regBuildInModule(modInitPipe, UCHAR_CONSTANT("builtin:ompipe"), NULL));
	CHKiRet(regBuildInModule(modInitShell, UCHAR_CONSTANT("builtin-shell"), NULL));
	CHKiRet(regBuildInModule(modInitDiscard, UCHAR_CONSTANT("builtin:omdiscard"), NULL));
#	ifdef SYSLOG_INET
	CHKiRet(regBuildInModule(modInitFwd, UCHAR_CONSTANT("builtin:omfwd"), NULL));
#	endif
	CHKiRet(regBuildInModule(modInitUsrMsg, (uchar*) "builtin:omusrmsg", NULL));
	CHKiRet(regBuildInModule(modInitpmrfc5424, UCHAR_CONSTANT("builtin:pmrfc5424"), NULL));
	CHKiRet(regBuildInModule(modInitpmrfc3164, UCHAR_CONSTANT("builtin:pmrfc3164"), NULL));
	CHKiRet(parser.AddDfltParser(UCHAR_CONSTANT("rsyslog.rfc5424")));
	CHKiRet(parser.AddDfltParser(UCHAR_CONSTANT("rsyslog.rfc3164")));
	CHKiRet(regBuildInModule(modInitsmfile, UCHAR_CONSTANT("builtin:smfile"), NULL));
	CHKiRet(regBuildInModule(modInitsmtradfile, UCHAR_CONSTANT("builtin:smtradfile"), NULL));
	CHKiRet(regBuildInModule(modInitsmfwd, UCHAR_CONSTANT("builtin:smfwd"), NULL));
	CHKiRet(regBuildInModule(modInitsmtradfwd, UCHAR_CONSTANT("builtin:smtradfwd"), NULL));
finalize_it:
	if(iRet != RS_RET_OK) {
		fprintf(stderr, "fatal error: could not activate built-in modules. Error code %d.\n",
			iRet);
	}
	RETiRet;
}
static rsRetVal
initLegacyConf(void)
{
	DEFiRet;
	uchar *pTmp;
	ruleset_t *pRuleset;
	DBGPRINTF("doing legacy config system init\n");
	ruleset.Construct(&amp;pRuleset);
	ruleset.SetName(pRuleset, UCHAR_CONSTANT("RSYSLOG_DefaultRuleset"));
	ruleset.ConstructFinalize(loadConf, pRuleset);
	rulesetSetCurrRulesetPtr(pRuleset);
	CHKiRet(regCfSysLineHdlr((uchar *)"sleep", 0, eCmdHdlrGoneAway,
		NULL, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"logrsyslogstatusmessages", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.bLogStatusMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"errormessagestostderr", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.bErrMsgToStderr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"abortonuncleanconfig", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.bAbortOnUncleanConfig, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"repeatedmsgreduction", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.bReduceRepeatMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"debugprinttemplatelist", 0, eCmdHdlrBinary,
		NULL, &amp;(loadConf-&gt;globals.bDebugPrintTemplateList), NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"debugprintmodulelist", 0, eCmdHdlrBinary,
		NULL, &amp;(loadConf-&gt;globals.bDebugPrintModuleList), NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"debugprintcfsyslinehandlerlist", 0, eCmdHdlrBinary,
		 NULL, &amp;(loadConf-&gt;globals.bDebugPrintCfSysLineHandlerList), NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptouser", 0, eCmdHdlrUID,
		NULL, &amp;loadConf-&gt;globals.uidDropPriv, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptouserid", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.uidDropPriv, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptogroup", 0, eCmdHdlrGID,
		NULL, &amp;loadConf-&gt;globals.gidDropPriv, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptogroupid", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.gidDropPriv, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"generateconfiggraph", 0, eCmdHdlrGetWord,
		NULL, &amp;loadConf-&gt;globals.pszConfDAGFile, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"umask", 0, eCmdHdlrFileCreateMode,
		NULL, &amp;loadConf-&gt;globals.umask, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"maxopenfiles", 0, eCmdHdlrInt,
		setMaxFiles, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionresumeinterval", 0, eCmdHdlrInt,
		setActionResumeInterval, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"modload", 0, eCmdHdlrCustomHandler,
		conf.doModLoad, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"defaultruleset", 0, eCmdHdlrGetWord,
		setDefaultRuleset, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"ruleset", 0, eCmdHdlrGetWord,
		setCurrRuleset, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"template", 0, eCmdHdlrCustomHandler,
		conf.doNameLine, (void*)DIR_TEMPLATE, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"outchannel", 0, eCmdHdlrCustomHandler,
		conf.doNameLine, (void*)DIR_OUTCHANNEL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"allowedsender", 0, eCmdHdlrCustomHandler,
		conf.doNameLine, (void*)DIR_ALLOWEDSENDER, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuefilename", 0, eCmdHdlrGetWord,
		NULL, &amp;loadConf-&gt;globals.mainQ.pszMainMsgQFName, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuesize", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuehighwatermark", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQHighWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuelowwatermark", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQLowWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuediscardmark", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQDiscardMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuediscardseverity", 0, eCmdHdlrSeverity,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQDiscardSeverity, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuecheckpointinterval", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQPersistUpdCnt, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuesyncqueuefiles", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.mainQ.bMainMsgQSyncQeueFiles, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetype", 0, eCmdHdlrGetWord,
		setMainMsgQueType, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueueworkerthreads", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueNumWorkers, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetimeoutshutdown", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoQShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetimeoutactioncompletion", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoActShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetimeoutenqueue", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoEnq, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueueworkertimeoutthreadshutdown", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoWrkShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeueslowdown", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQDeqSlowdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueueworkerthreadminimummessages", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQWrkMinMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuemaxfilesize", 0, eCmdHdlrSize,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueMaxFileSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeuebatchsize", 0, eCmdHdlrSize,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueDeqBatchSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuemaxdiskspace", 0, eCmdHdlrSize,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueMaxDiskSpace, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuesaveonshutdown", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.mainQ.bMainMsgQSaveOnShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeuetimebegin", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueDeqtWinFromHr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeuetimeend", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueDeqtWinToHr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"moddir", 0, eCmdHdlrGetWord,
		setModDir, NULL, NULL));
<a name="1"></a>
	CHKiRet(regCfSysLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		resetConfigVariables, NULL, NULL));
	pTmp = template_DebugFormat;
	tplAddLine(ourConf, "RSYSLOG_DebugFormat", &amp;pTmp);
	pTmp = template_SyslogProtocol23Format;
	tplAddLine(ourConf, "RSYSLOG_SyslogProtocol23Format", &amp;pTmp);
	pTmp = template_SyslogRFC5424Format;
	tplAddLine(ourConf, "RSYSLOG_SyslogRFC5424Format", &amp;pTmp);
	pTmp = template_FileFormat; 	tplAddLine(ourConf, "RSYSLOG_FileFormat", &amp;pTmp);
	pTmp = template_TraditionalFileFormat;
	tplAddLine(ourConf, "RSYSLOG_TraditionalFileFormat", &amp;pTmp);
	pTmp = template_WallFmt;
	tplAddLine(ourConf, " WallFmt", &amp;pTmp);
	pTmp = template_ForwardFormat;
	tplAddLine(ourConf, "RSYSLOG_ForwardFormat", &amp;pTmp);
	pTmp = template_TraditionalForwardFormat;
	tplAddLine(ourConf, "RSYSLOG_TraditionalForwardFormat", &amp;pTmp);
	pTmp = template_StdUsrMsgFmt;
	tplAddLine(ourConf, " StdUsrMsgFmt", &amp;pTmp);
	pTmp = template_StdDBFmt;
	tplAddLine(ourConf, " StdDBFmt", &amp;pTmp);
	pTmp = template_SysklogdFileFormat;
	tplAddLine(ourConf, "RSYSLOG_SysklogdFileFormat", &amp;pTmp);
	pTmp = template_StdPgSQLFmt;
	tplAddLine(ourConf, " StdPgSQLFmt", &amp;pTmp);
	pTmp = template_StdJSONFmt;
	tplAddLine(ourConf, " StdJSONFmt", &amp;pTmp);
	pTmp = template_FullJSONFmt;
	tplAddLine(ourConf, " FullJSONFmt", &amp;pTmp);
	pTmp = template_StdClickHouseFmt;
	tplAddLine(ourConf, " StdClickHouseFmt", &amp;pTmp);
	pTmp = template_spoofadr;</b></font>
	tplLastStaticInit(ourConf, tplAddLine(ourConf, "RSYSLOG_omudpspoofDfltSourceTpl", &amp;pTmp));
finalize_it:
	RETiRet;
}
static rsRetVal
validateConf(rsconf_t *cnf)
{
	DEFiRet;
	if(cnf-&gt;globals.mainQ.iMainMsgQueueNumWorkers &lt; 1) {
		LogError(0, NO_ERRCODE, "$MainMsgQueueNumWorkers must be at least 1! Set to 1.\n");
		cnf-&gt;globals.mainQ.iMainMsgQueueNumWorkers = 1;
	}
	if(cnf-&gt;globals.mainQ.MainMsgQueType == QUEUETYPE_DISK) {
		errno = 0;			if(glbl.GetWorkDir(cnf) == NULL) {
			LogError(0, NO_ERRCODE, "No $WorkDirectory specified - can not run main "
					"message queue in 'disk' mode. Using 'FixedArray' instead.\n");
			cnf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
		}
		if(cnf-&gt;globals.mainQ.pszMainMsgQFName == NULL) {
			LogError(0, NO_ERRCODE, "No $MainMsgQueueFileName specified - can not run main "
				"message queue in 'disk' mode. Using 'FixedArray' instead.\n");
			cnf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
		}
	}
	RETiRet;
}
static rsRetVal
load(rsconf_t **cnf, uchar *confFile)
{
	int iNbrActions = 0;
	int r;
	rsRetVal delayed_iRet = RS_RET_OK;
	DEFiRet;
	CHKiRet(rsconfConstruct(&amp;loadConf));
	ourConf = loadConf; 
	CHKiRet(loadBuildInModules());
	CHKiRet(initLegacyConf());
	r = cnfSetLexFile((char*)confFile);
	if(r == 0) {
		r = yyparse();
		conf.GetNbrActActions(loadConf, &amp;iNbrActions);
	}
	rulesetOptimizeAll(loadConf);
	if(r == 1) {
		LogError(0, RS_RET_CONF_PARSE_ERROR, "could not interpret master "
			"config file '%s'.", confFile);
		delayed_iRet = RS_RET_CONF_PARSE_ERROR;
	} else if(r == 2) { 		LogError(errno, RS_RET_CONF_FILE_NOT_FOUND, "could not open config file '%s'",
		        confFile);
		ABORT_FINALIZE(RS_RET_CONF_FILE_NOT_FOUND);
	} else if(    (iNbrActions == 0)
		  &amp;&amp; !(iConfigVerify &amp; CONF_VERIFY_PARTIAL_CONF)) {
		LogError(0, RS_RET_NO_ACTIONS, "there are no active actions configured. "
			"Inputs would run, but no output whatsoever were created.");
		ABORT_FINALIZE(RS_RET_NO_ACTIONS);
	}
	tellLexEndParsing();
	DBGPRINTF("Number of actions in this configuration: %d\n", loadConf-&gt;actions.iActionNbr);
	CHKiRet(tellCoreConfigLoadDone());
	tellModulesConfigLoadDone();
	tellModulesCheckConfig();
	CHKiRet(validateConf(loadConf));
	CHKiRet(loadMainQueue());
	if(iConfigVerify) {
		if(iRet == RS_RET_OK)
			iRet = RS_RET_VALIDATION_RUN;
		FINALIZE;
	}
	*cnf = loadConf;
	dbgprintf("rsyslog finished loading master config %p\n", loadConf);
	rsconfDebugPrint(loadConf);
finalize_it:
	if(iRet == RS_RET_OK &amp;&amp; delayed_iRet != RS_RET_OK) {
		iRet = delayed_iRet;
	}
	RETiRet;
}
BEGINobjQueryInterface(rsconf)
CODESTARTobjQueryInterface(rsconf)
	if(pIf-&gt;ifVersion != rsconfCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;Destruct = rsconfDestruct;
	pIf-&gt;DebugPrint = rsconfDebugPrint;
	pIf-&gt;Load = load;
	pIf-&gt;Activate = activate;
finalize_it:
ENDobjQueryInterface(rsconf)
BEGINObjClassInit(rsconf, 1, OBJ_IS_CORE_MODULE) 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(module, CORE_COMPONENT));
	CHKiRet(objUse(conf, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));
	OBJSetMethodHandler(objMethod_DEBUGPRINT, rsconfDebugPrint);
	OBJSetMethodHandler(objMethod_CONSTRUCTION_FINALIZER, rsconfConstructFinalize);
ENDObjClassInit(rsconf)
BEGINObjClassExit(rsconf, OBJ_IS_CORE_MODULE) 	objRelease(ruleset, CORE_COMPONENT);
	objRelease(module, CORE_COMPONENT);
	objRelease(conf, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(parser, CORE_COMPONENT);
ENDObjClassExit(rsconf)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
