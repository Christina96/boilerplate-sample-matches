<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for datetime.c &amp; rsconf.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for datetime.c &amp; rsconf.c
      </h3>
<h1 align="center">
        8.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>datetime.c (8.434959%)<th>rsconf.c (8.867521%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(877-898)<td><a href="#" name="0">(205-229)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(959-983)<td><a href="#" name="1">(1388-1421)</a><td align="center"><font color="#da0000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(851-867)<td><a href="#" name="2">(187-202)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1257-1274)<td><a href="#" name="3">(247-261)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1005-1011)<td><a href="#" name="4">(161-173)</a><td align="center"><font color="#9d0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>datetime.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;ctype.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;string.h&gt;
8 #ifdef HAVE_SYS_TIME_H
9 #	include &lt;sys/time.h&gt;
10 #endif
11 #include "rsyslog.h"
12 #include "obj.h"
13 #include "modules.h"
14 #include "datetime.h"
15 #include "srUtils.h"
16 #include "stringbuf.h"
17 #include "errmsg.h"
18 #include "rsconf.h"
19 #include "timezones.h"
20 DEFobjStaticHelpers
21 static const int tenPowers[6] = { 1, 10, 100, 1000, 10000, 100000 };
22 static const int yearInSec_startYear = 1967;
23 static const long long yearInSecs[] = {
24 	-63158401, -31536001, -1, 31535999, 63071999, 94694399, 126230399,
25 	157766399, 189302399, 220924799, 252460799, 283996799, 315532799,
26 	347155199, 378691199, 410227199, 441763199, 473385599, 504921599,
27 	536457599, 567993599, 599615999, 631151999, 662687999, 694223999,
28 	725846399, 757382399, 788918399, 820454399, 852076799, 883612799,
29 	915148799, 946684799, 978307199, 1009843199, 1041379199, 1072915199,
30 	1104537599, 1136073599, 1167609599, 1199145599, 1230767999,
31 	1262303999, 1293839999, 1325375999, 1356998399, 1388534399,
32 	1420070399, 1451606399, 1483228799, 1514764799, 1546300799,
33 	1577836799, 1609459199, 1640995199, 1672531199, 1704067199,
34 	1735689599, 1767225599, 1798761599, 1830297599, 1861919999,
35 	1893455999, 1924991999, 1956527999, 1988150399, 2019686399,
36 	2051222399, 2082758399, 2114380799, 2145916799, 2177452799,
37 	2208988799, 2240611199, 2272147199, 2303683199, 2335219199,
38 	2366841599, 2398377599, 2429913599, 2461449599, 2493071999,
39 	2524607999, 2556143999, 2587679999, 2619302399, 2650838399,
40 	2682374399, 2713910399, 2745532799, 2777068799, 2808604799,
41 	2840140799, 2871763199, 2903299199, 2934835199, 2966371199,
42 	2997993599, 3029529599, 3061065599, 3092601599, 3124223999,
43 	3155759999, 3187295999, 3218831999, 3250454399, 3281990399,
44 	3313526399, 3345062399, 3376684799, 3408220799, 3439756799,
45 	3471292799, 3502915199, 3534451199, 3565987199, 3597523199,
46 	3629145599, 3660681599, 3692217599, 3723753599, 3755375999,
47 	3786911999, 3818447999, 3849983999, 3881606399, 3913142399,
48 	3944678399, 3976214399, 4007836799, 4039372799, 4070908799,
49 	4102444799};
50 static const int weeksInYear[] = {
51 	52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52,
52 	52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52,
53 	52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52,
54 	53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52,
55 	53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52,
56 	53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52,
57 	53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52,
58 	53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52,
59 };
60 static const char* monthNames[12] = {
61 	"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
62 };
63 static void
64 timeval2syslogTime(struct timeval *tp, struct syslogTime *t, const int inUTC)
65 {
66 	struct tm *tm;
67 	struct tm tmBuf;
68 	long lBias;
69 	time_t secs;
70 #if defined(__hpux)
71 	struct timezone tz;
72 #	endif
73 	secs = tp-&gt;tv_sec;
74 	if(inUTC)
75 		tm = gmtime_r(&amp;secs, &amp;tmBuf);
76 	else
77 		tm = localtime_r(&amp;secs, &amp;tmBuf);
78 	t-&gt;year = tm-&gt;tm_year + 1900;
79 	t-&gt;month = tm-&gt;tm_mon + 1;
80 	t-&gt;day = tm-&gt;tm_mday;
81 	t-&gt;wday = tm-&gt;tm_wday;
82 	t-&gt;hour = tm-&gt;tm_hour;
83 	t-&gt;minute = tm-&gt;tm_min;
84 	t-&gt;second = tm-&gt;tm_sec;
85 	t-&gt;secfrac = tp-&gt;tv_usec;
86 	t-&gt;secfracPrecision = 6;
87 	if(inUTC) {
88 		t-&gt;OffsetMode = '+';
89 		lBias = 0;
90 	} else {
91 #		if defined(__sun)
92 			lBias = -(tm-&gt;tm_isdst ? altzone : timezone);
93 #		elif defined(__hpux)
94 			lBias = tz.tz_dsttime ? - tz.tz_minuteswest : 0;
95 #		elif defined(_AIX)
96 			if (tm-&gt;tm_isdst) tzset();
97 			lBias = - timezone;
98 #		else
99 			lBias = tm-&gt;tm_gmtoff;
100 #		endif
101 		if(lBias &lt; 0) {
102 			t-&gt;OffsetMode = '-';
103 			lBias *= -1;
104 		} else
105 			t-&gt;OffsetMode = '+';
106 	}
107 	t-&gt;OffsetHour = lBias / 3600;
108 	t-&gt;OffsetMinute = (lBias % 3600) / 60;
109 	t-&gt;timeType = TIME_TYPE_RFC5424; 	t-&gt;inUTC = inUTC;
110 }
111 static void getCurrTime(struct syslogTime *t, time_t *ttSeconds, const int inUTC)
112 {
113 	struct timeval tp;
114 #if defined(__hpux) || defined(_AIX)
115 	struct timezone tz;
116 #	endif
117 	assert(t != NULL);
118 #if defined(__hpux) || defined(_AIX)
119 		gettimeofday(&amp;tp, &amp;tz);
120 #	else
121 		gettimeofday(&amp;tp, NULL);
122 #	endif
123 	if(ttSeconds != NULL)
124 		*ttSeconds = tp.tv_sec;
125 	timeval2syslogTime(&amp;tp, t, inUTC);
126 }
127 time_t
128 getTime(time_t *ttSeconds)
129 {
130 	struct timeval tp;
131 	if(gettimeofday(&amp;tp, NULL) == -1)
132 		return -1;
133 	if(ttSeconds != NULL)
134 		*ttSeconds = tp.tv_sec;
135 	return tp.tv_sec;
136 }
137 dateTimeFormat_t getDateTimeFormatFromStr(const char * const __restrict__ s) {
138 	assert(s != NULL);
139 	if (strcmp(s, "date-rfc3164") == 0)
140 		return DATE_RFC3164;
141 	if (strcmp(s, "date-rfc3339") == 0)
142 		return DATE_RFC3339;
143 	if (strcmp(s, "date-unix") == 0)
144 		return DATE_UNIX;
145 	return DATE_INVALID;
146 }
147 static int
148 srSLMGParseInt32(uchar** ppsz, int *pLenStr)
149 {
150 	register int i;
151 	i = 0;
152 	while(*pLenStr &gt; 0 &amp;&amp; **ppsz &gt;= '0' &amp;&amp; **ppsz &lt;= '9' &amp;&amp; i &lt; INT_MAX/10-1) {
153 		i = i * 10 + **ppsz - '0';
154 		++(*ppsz);
155 		--(*pLenStr);
156 	}
157 	return i;
158 }
159 static rsRetVal
160 ParseTIMESTAMP3339(struct syslogTime *pTime, uchar** ppszTS, int *pLenStr)
161 {
162 	uchar *pszTS = *ppszTS;
163 	int year;
164 	int month;
165 	int day;
166 	int hour; 	int minute;
167 	int second;
168 	int secfrac;		int secfracPrecision;
169 	char OffsetMode;		int OffsetHour;		int OffsetMinute;		int lenStr;
170 	DEFiRet;
171 	assert(pTime != NULL);
172 	assert(ppszTS != NULL);
173 	assert(pszTS != NULL);
174 	lenStr = *pLenStr;
175 	year = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
176 	if(lenStr == 0 || *pszTS++ != '-' || year &lt; 0 || year &gt;= 2100) {
177 		DBGPRINTF("ParseTIMESTAMP3339: invalid year: %d, pszTS: '%c'\n", year, *pszTS);
178 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
179 	}
180 	--lenStr;
181 	month = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
182 	if(month &lt; 1 || month &gt; 12)
183 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
184 	if(lenStr == 0 || *pszTS++ != '-')
185 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
186 	--lenStr;
187 	day = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
188 	if(day &lt; 1 || day &gt; 31)
189 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
190 	if(lenStr == 0 || *pszTS++ != 'T')
191 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
192 	--lenStr;
193 	hour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
194 	if(hour &lt; 0 || hour &gt; 23)
195 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
196 	if(lenStr == 0 || *pszTS++ != ':')
197 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
198 	--lenStr;
199 	minute = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
200 	if(minute &lt; 0 || minute &gt; 59)
201 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
202 	if(lenStr == 0 || *pszTS++ != ':')
203 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
204 	--lenStr;
205 	second = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
206 	if(second &lt; 0 || second &gt; 60)
207 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
208 	if(lenStr &gt; 0 &amp;&amp; *pszTS == '.') {
209 		--lenStr;
210 		uchar *pszStart = ++pszTS;
211 		secfrac = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
212 		secfracPrecision = (int) (pszTS - pszStart);
213 	} else {
214 		secfracPrecision = 0;
215 		secfrac = 0;
216 	}
217 	if(lenStr == 0)
218 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
219 	if(*pszTS == 'Z') {
220 		--lenStr;
221 		pszTS++; 		OffsetMode = 'Z';
222 		OffsetHour = 0;
223 		OffsetMinute = 0;
224 	} else if((*pszTS == '+') || (*pszTS == '-')) {
225 		OffsetMode = *pszTS;
226 		--lenStr;
227 		pszTS++;
228 		OffsetHour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
229 		if(OffsetHour &lt; 0 || OffsetHour &gt; 23)
230 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
231 		if(lenStr == 0 || *pszTS != ':')
232 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
233 		--lenStr;
234 		pszTS++;
235 		OffsetMinute = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
236 		if(OffsetMinute &lt; 0 || OffsetMinute &gt; 59)
237 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
238 	} else {
239 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
240 	}
241 	if(lenStr &gt; 0) {
242 		if(*pszTS != ' ') 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
243 		++pszTS; 		--lenStr;
244 	}
245 	*ppszTS = pszTS;
246 	pTime-&gt;timeType = 2;
247 	pTime-&gt;year = year;
248 	pTime-&gt;month = month;
249 	pTime-&gt;day = day;
250 	pTime-&gt;hour = hour;
251 	pTime-&gt;minute = minute;
252 	pTime-&gt;second = second;
253 	pTime-&gt;secfrac = secfrac;
254 	pTime-&gt;secfracPrecision = secfracPrecision;
255 	pTime-&gt;OffsetMode = OffsetMode;
256 	pTime-&gt;OffsetHour = OffsetHour;
257 	pTime-&gt;OffsetMinute = OffsetMinute;
258 	*pLenStr = lenStr;
259 finalize_it:
260 	RETiRet;
261 }
262 static rsRetVal
263 ParseTIMESTAMP3164(struct syslogTime *pTime, uchar** ppszTS, int *pLenStr,
264 	const int bParseTZ,
265 	const int bDetectYearAfterTime)
266 {
267 	int month;
268 	int day;
269 	int year = 0; 	int hour; 	int minute;
270 	int second;
271 	int secfrac;		int secfracPrecision;
272 	char tzstring[16];
273 	char OffsetMode = '\0';		char OffsetHour = '\0';		int OffsetMinute = 0;		int lenStr;
274 	uchar *pszTS;
275 	DEFiRet;
276 	assert(ppszTS != NULL);
277 	pszTS = *ppszTS;
278 	assert(pszTS != NULL);
279 	assert(pTime != NULL);
280 	assert(pLenStr != NULL);
281 	lenStr = *pLenStr;
282 	if(lenStr &lt; 3)
283 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
284 	if(*pszTS &gt;= '0' &amp;&amp; *pszTS &lt;= '9') {
285 		year = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
286 		if(year &lt; 1970 || year &gt; 2100 || *pszTS != ' ')
287 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
288 		++pszTS; 	}
289 	switch(*pszTS++)
290 	{
291 	case 'j':
292 	case 'J':
293 		if(*pszTS == 'a' || *pszTS == 'A') {
294 			++pszTS;
295 			if(*pszTS == 'n' || *pszTS == 'N') {
296 				++pszTS;
297 				month = 1;
298 			} else
299 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
300 		} else if(*pszTS == 'u' || *pszTS == 'U') {
301 			++pszTS;
302 			if(*pszTS == 'n' || *pszTS == 'N') {
303 				++pszTS;
304 				month = 6;
305 			} else if(*pszTS == 'l' || *pszTS == 'L') {
306 				++pszTS;
307 				month = 7;
308 			} else
309 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
310 		} else
311 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
312 		break;
313 	case 'f':
314 	case 'F':
315 		if(*pszTS == 'e' || *pszTS == 'E') {
316 			++pszTS;
317 			if(*pszTS == 'b' || *pszTS == 'B') {
318 				++pszTS;
319 				month = 2;
320 			} else
321 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
322 		} else
323 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
324 		break;
325 	case 'm':
326 	case 'M':
327 		if(*pszTS == 'a' || *pszTS == 'A') {
328 			++pszTS;
329 			if(*pszTS == 'r' || *pszTS == 'R') {
330 				++pszTS;
331 				month = 3;
332 			} else if(*pszTS == 'y' || *pszTS == 'Y') {
333 				++pszTS;
334 				month = 5;
335 			} else
336 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
337 		} else
338 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
339 		break;
340 	case 'a':
341 	case 'A':
342 		if(*pszTS == 'p' || *pszTS == 'P') {
343 			++pszTS;
344 			if(*pszTS == 'r' || *pszTS == 'R') {
345 				++pszTS;
346 				month = 4;
347 			} else
348 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
349 		} else if(*pszTS == 'u' || *pszTS == 'U') {
350 			++pszTS;
351 			if(*pszTS == 'g' || *pszTS == 'G') {
352 				++pszTS;
353 				month = 8;
354 			} else
355 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
356 		} else
357 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
358 		break;
359 	case 's':
360 	case 'S':
361 		if(*pszTS == 'e' || *pszTS == 'E') {
362 			++pszTS;
363 			if(*pszTS == 'p' || *pszTS == 'P') {
364 				++pszTS;
365 				month = 9;
366 			} else
367 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
368 		} else
369 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
370 		break;
371 	case 'o':
372 	case 'O':
373 		if(*pszTS == 'c' || *pszTS == 'C') {
374 			++pszTS;
375 			if(*pszTS == 't' || *pszTS == 'T') {
376 				++pszTS;
377 				month = 10;
378 			} else
379 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
380 		} else
381 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
382 		break;
383 	case 'n':
384 	case 'N':
385 		if(*pszTS == 'o' || *pszTS == 'O') {
386 			++pszTS;
387 			if(*pszTS == 'v' || *pszTS == 'V') {
388 				++pszTS;
389 				month = 11;
390 			} else
391 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
392 		} else
393 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
394 		break;
395 	case 'd':
396 	case 'D':
397 		if(*pszTS == 'e' || *pszTS == 'E') {
398 			++pszTS;
399 			if(*pszTS == 'c' || *pszTS == 'C') {
400 				++pszTS;
401 				month = 12;
402 			} else
403 				ABORT_FINALIZE(RS_RET_INVLD_TIME);
404 		} else
405 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
406 		break;
407 	default:
408 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
409 	}
410 	lenStr -= 3;
411 	if(lenStr == 0 || *pszTS++ != ' ')
412 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
413 	--lenStr;
414 	if(*pszTS == ' ') {
415 		--lenStr;
416 		++pszTS;
417 	}
418 	day = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
419 	if(day &lt; 1 || day &gt; 31)
420 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
421 	if(lenStr == 0 || *pszTS++ != ' ')
422 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
423 	--lenStr;
424 	hour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
425 	if(year == 0 &amp;&amp; hour &gt; 1970 &amp;&amp; hour &lt; 2100) {
426 		year = hour;
427 		if(lenStr == 0 || *pszTS++ != ' ')
428 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
429 		--lenStr;
430 		hour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
431 	}
432 	if(hour &lt; 0 || hour &gt; 23)
433 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
434 	if(lenStr == 0 || *pszTS++ != ':')
435 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
436 	--lenStr;
437 	minute = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
438 	if(minute &lt; 0 || minute &gt; 59)
439 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
440 	if(lenStr == 0 || *pszTS++ != ':')
441 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
442 	--lenStr;
443 	second = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
444 	if(second &lt; 0 || second &gt; 60)
445 		ABORT_FINALIZE(RS_RET_INVLD_TIME);
446 	if(lenStr &gt; 0 &amp;&amp; *pszTS == '.') {
447 		--lenStr;
448 		uchar *pszStart = ++pszTS;
449 		secfrac = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
450 		secfracPrecision = (int) (pszTS - pszStart);
451 	} else {
452 		secfracPrecision = 0;
453 		secfrac = 0;
454 	}
455 	if(bParseTZ &amp;&amp; lenStr &gt; 2 &amp;&amp; *pszTS == ' ') {
456 		int i;
457 		for(  ++pszTS, --lenStr, i = 0
458 		    ; lenStr &gt; 0 &amp;&amp; i &lt; (int) sizeof(tzstring) - 1 &amp;&amp; *pszTS != ':' &amp;&amp; *pszTS != ' '
459 		    ; --lenStr)
460 			tzstring[i++] = *pszTS++;
461 		if(i &gt; 0) {
462 			tzinfo_t* tzinfo;
463 			tzstring[i] = '\0';
464 			if((tzinfo = glblFindTimezone(runConf, (char*) tzstring)) == NULL) {
465 				DBGPRINTF("ParseTIMESTAMP3164: invalid TZ string '%s' -- ignored\n",
466 					  tzstring);
467 			} else {
468 				OffsetMode = tzinfo-&gt;offsMode;
469 				OffsetHour = tzinfo-&gt;offsHour;
470 				OffsetMinute = tzinfo-&gt;offsMin;
471 			}
472 		}
473 	}
474 	if(bDetectYearAfterTime &amp;&amp; year == 0 &amp;&amp; lenStr &gt; 5 &amp;&amp; *pszTS == ' ') {
475 		int j;
476 		int y = 0;
477 		for(j = 1 ; j &lt; 5 ; ++j) {
478 			if(pszTS[j] &lt; '0' || pszTS[j] &gt; '9')
479 				break;
480 			y = 10 * y + pszTS[j] - '0';
481 		}
482 		if(lenStr &gt; 6 &amp;&amp; pszTS[5] != ' ')
483 			y = 0; 		if(2000 &lt;= y &amp;&amp; y &lt; 2100) {
484 			year = y;
485 			pszTS += 5; 			lenStr -= 5;
486 		}
487 	}
488 	if(lenStr &gt; 0 &amp;&amp; *pszTS == ':') {
489 		++pszTS; 		--lenStr;
490 	}
491 	if(lenStr &gt; 0) {
492 		if(*pszTS != ' ') 			ABORT_FINALIZE(RS_RET_INVLD_TIME);
493 		++pszTS; 		--lenStr;
494 	}
495 	*ppszTS = pszTS; 	pTime-&gt;timeType = 1;
496 	pTime-&gt;month = month;
497 	if(year &gt; 0)
498 		pTime-&gt;year = year; 	pTime-&gt;day = day;
499 	pTime-&gt;hour = hour;
500 	pTime-&gt;minute = minute;
501 	pTime-&gt;second = second;
502 	pTime-&gt;secfrac = secfrac;
503 	pTime-&gt;secfracPrecision = secfracPrecision;
504 	if(OffsetMode != '\0') { 		pTime-&gt;OffsetMode = OffsetMode;
505 		pTime-&gt;OffsetHour = OffsetHour;
506 		pTime-&gt;OffsetMinute = OffsetMinute;
507 	}
508 	*pLenStr = lenStr;
509 finalize_it:
510 	RETiRet;
511 }
512 void
513 applyDfltTZ(struct syslogTime *pTime, char *tz)
514 {
515 	pTime-&gt;OffsetMode = tz[0];
516 	pTime-&gt;OffsetHour = (tz[1] - '0') * 10 + (tz[2] - '0');
517 	pTime-&gt;OffsetMinute = (tz[4] - '0') * 10 + (tz[5] - '0');
518 }
519 static int
520 formatTimestampToMySQL(struct syslogTime *ts, char* pBuf)
521 {
522 	assert(ts != NULL);
523 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	assert(pBuf != NULL);
524 	pBuf[0] = (ts-&gt;year / 1000) % 10 + '0';
525 	pBuf[1] = (ts-&gt;year / 100) % 10 + '0';
526 	pBuf[2] = (ts-&gt;year / 10) % 10 + '0';
527 	pBuf[3] = ts-&gt;year % 10 + '0';
528 	pBuf[4] = (ts-&gt;month / 10) % 10 + '0';
529 	pBuf[5] = ts-&gt;month % 10 + '0';
530 	pBuf[6] = (ts-&gt;day / 10) % 10 + '0';
531 	pBuf[7] = ts-&gt;day % 10 + '0';
532 	pBuf[8] = (ts-&gt;hour / 10) % 10 + '0';
533 	pBuf[9] = ts-&gt;hour % 10 + '0';
534 	pBuf[10] = (ts-&gt;minute / 10) % 10 + '0';
535 	pBuf[11] = ts-&gt;minute % 10 + '0';
536 	pBuf[12] = (ts-&gt;second / 10) % 10 + '0';
537 	pBuf[13] = ts-&gt;second % 10 + '0';
538 	pBuf[14] = '\0';</b></font>
539 	return 15;
540 }
541 static int
542 formatTimestampToPgSQL(struct syslogTime *ts, char *pBuf)
543 <a name="0"></a>{
544 	assert(ts != NULL);
545 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	assert(pBuf != NULL);
546 	pBuf[0] = (ts-&gt;year / 1000) % 10 + '0';
547 	pBuf[1] = (ts-&gt;year / 100) % 10 + '0';
548 	pBuf[2] = (ts-&gt;year / 10) % 10 + '0';
549 	pBuf[3] = ts-&gt;year % 10 + '0';
550 	pBuf[4] = '-';
551 	pBuf[5] = (ts-&gt;month / 10) % 10 + '0';
552 	pBuf[6] = ts-&gt;month % 10 + '0';
553 	pBuf[7] = '-';
554 	pBuf[8] = (ts-&gt;day / 10) % 10 + '0';
555 	pBuf[9] = ts-&gt;day % 10 + '0';
556 	pBuf[10] = ' ';
557 	pBuf[11] = (ts-&gt;hour / 10) % 10 + '0';
558 	pBuf[12] = ts-&gt;hour % 10 + '0';
559 	pBuf[13] = ':';
560 	pBuf[14] = (ts-&gt;minute / 10) % 10 + '0';
561 	pBuf[15] = ts-&gt;minute % 10 + '0';
562 	pBuf[16] = ':';
563 	pBuf[17] = (ts-&gt;second / 10) % 10 + '0';
564 	pBuf[18] = ts-&gt;second % 10 + '0';
565 	pBuf[19] = '\0';</b></font>
566 	return 19;
567 }
568 static int
569 formatTimestampSecFrac(struct syslogTime *ts, char* pBuf)
570 {
571 	int iBuf;
572 	int power;
573 	int secfrac;
574 	short digit;
575 	assert(ts != NULL);
576 	assert(pBuf != NULL);
577 	iBuf = 0;
578 	if(ts-&gt;secfracPrecision &gt; 0)
579 	{
580 		power = tenPowers[(ts-&gt;secfracPrecision - 1) % 6];
581 		secfrac = ts-&gt;secfrac;
582 		while(power &gt; 0) {
583 			digit = secfrac / power;
584 			secfrac -= digit * power;
585 			power /= 10;
586 			pBuf[iBuf++] = digit + '0';
587 		}
588 	} else {
589 		pBuf[iBuf++] = '0';
590 	}
591 	pBuf[iBuf] = '\0';
592 	return iBuf;
593 }
594 static int
595 formatTimestamp3339(struct syslogTime *ts, char* pBuf)
596 {
597 	int iBuf;
598 	int power;
599 <a name="1"></a>	int secfrac;
600 	short digit;
601 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	assert(ts != NULL);
602 	assert(pBuf != NULL);
603 	pBuf[0] = (ts-&gt;year / 1000) % 10 + '0';
604 	pBuf[1] = (ts-&gt;year / 100) % 10 + '0';
605 	pBuf[2] = (ts-&gt;year / 10) % 10 + '0';
606 	pBuf[3] = ts-&gt;year % 10 + '0';
607 	pBuf[4] = '-';
608 	pBuf[5] = (ts-&gt;month / 10) % 10 + '0';
609 	pBuf[6] = ts-&gt;month % 10 + '0';
610 	pBuf[7] = '-';
611 	pBuf[8] = (ts-&gt;day / 10) % 10 + '0';
612 	pBuf[9] = ts-&gt;day % 10 + '0';
613 	pBuf[10] = 'T';
614 	pBuf[11] = (ts-&gt;hour / 10) % 10 + '0';
615 	pBuf[12] = ts-&gt;hour % 10 + '0';
616 	pBuf[13] = ':';
617 	pBuf[14] = (ts-&gt;minute / 10) % 10 + '0';
618 	pBuf[15] = ts-&gt;minute % 10 + '0';</b></font>
619 	pBuf[16] = ':';
620 	pBuf[17] = (ts-&gt;second / 10) % 10 + '0';
621 	pBuf[18] = ts-&gt;second % 10 + '0';
622 	iBuf = 19; 
623 	if(ts-&gt;secfracPrecision &gt; 0) {
624 		pBuf[iBuf++] = '.';
625 		power = tenPowers[(ts-&gt;secfracPrecision - 1) % 6];
626 		secfrac = ts-&gt;secfrac;
627 		while(power &gt; 0) {
628 			digit = secfrac / power;
629 			secfrac -= digit * power;
630 			power /= 10;
631 			pBuf[iBuf++] = digit + '0';
632 		}
633 	}
634 <a name="4"></a>
635 	if(ts-&gt;OffsetMode == 'Z') {
636 		pBuf[iBuf++] = 'Z';
637 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	} else {
638 		pBuf[iBuf++] = ts-&gt;OffsetMode;
639 		pBuf[iBuf++] = (ts-&gt;OffsetHour / 10) % 10 + '0';
640 		pBuf[iBuf++] = ts-&gt;OffsetHour % 10 + '0';
641 		pBuf[iBuf++] = ':';
642 		pBuf[iBuf++] = (ts-&gt;OffsetMinute / 10) % 10 + '0';
643 		pBuf[iBuf++] = ts-&gt;OffsetMinute % 10 + '0';</b></font>
644 	}
645 	pBuf[iBuf] = '\0';
646 	return iBuf;
647 }
648 static int
649 formatTimestamp3164(struct syslogTime *ts, char* pBuf, int bBuggyDay)
650 {
651 	int iDay;
652 	assert(ts != NULL);
653 	assert(pBuf != NULL);
654 	pBuf[0] = monthNames[(ts-&gt;month - 1)% 12][0];
655 	pBuf[1] = monthNames[(ts-&gt;month - 1) % 12][1];
656 	pBuf[2] = monthNames[(ts-&gt;month - 1) % 12][2];
657 	pBuf[3] = ' ';
658 	iDay = (ts-&gt;day / 10) % 10; 	pBuf[4] = (bBuggyDay || iDay &gt; 0) ? iDay + '0' : ' ';
659 	pBuf[5] = ts-&gt;day % 10 + '0';
660 	pBuf[6] = ' ';
661 	pBuf[7] = (ts-&gt;hour / 10) % 10 + '0';
662 	pBuf[8] = ts-&gt;hour % 10 + '0';
663 	pBuf[9] = ':';
664 	pBuf[10] = (ts-&gt;minute / 10) % 10 + '0';
665 	pBuf[11] = ts-&gt;minute % 10 + '0';
666 	pBuf[12] = ':';
667 	pBuf[13] = (ts-&gt;second / 10) % 10 + '0';
668 	pBuf[14] = ts-&gt;second % 10 + '0';
669 	pBuf[15] = '\0';
670 	return 16;	}
671 static time_t
672 syslogTime2time_t(const struct syslogTime *ts)
673 {
674 	long MonthInDays, NumberOfYears, NumberOfDays;
675 	int utcOffset;
676 	time_t TimeInUnixFormat;
677 	if(ts-&gt;year &lt; 1970 || ts-&gt;year &gt; 2100) {
678 		TimeInUnixFormat = 0;
679 		LogError(0, RS_RET_ERR, "syslogTime2time_t: invalid year %d "
680 			"in timestamp - returning 1970-01-01 instead", ts-&gt;year);
681 		goto done;
682 	}
683 	switch(ts-&gt;month)
684 	{
685 		case 1:
686 			MonthInDays = 0;         //until 01 of January
687 			break;
688 		case 2:
689 			MonthInDays = 31;        //until 01 of February - leap year handling down below!
690 			break;
691 		case 3:
692 			MonthInDays = 59;        //until 01 of March
693 			break;
694 		case 4:
695 			MonthInDays = 90;        //until 01 of April
696 			break;
697 		case 5:
698 			MonthInDays = 120;       //until 01 of Mai
699 			break;
700 		case 6:
701 			MonthInDays = 151;       //until 01 of June
702 			break;
703 		case 7:
704 			MonthInDays = 181;       //until 01 of July
705 			break;
706 		case 8:
707 			MonthInDays = 212;       //until 01 of August
708 			break;
709 		case 9:
710 			MonthInDays = 243;       //until 01 of September
711 			break;
712 		case 10:
713 			MonthInDays = 273;       //until 01 of Oktober
714 			break;
715 		case 11:
716 			MonthInDays = 304;       //until 01 of November
717 			break;
718 		case 12:
719 			MonthInDays = 334;       //until 01 of December
720 			break;
721 			MonthInDays = 0;				break;
722 	}
723 	if((ts-&gt;year % 100 != 0 &amp;&amp; ts-&gt;year % 4 == 0) || (ts-&gt;year == 2000)) {
724 		if(ts-&gt;month &gt; 2)
725 			MonthInDays++;
726 	}
727 	NumberOfYears = ts-&gt;year - yearInSec_startYear - 1;
728 	NumberOfDays = MonthInDays + ts-&gt;day - 1;
729 	TimeInUnixFormat = (time_t) (yearInSecs[NumberOfYears] + 1) + NumberOfDays * 86400;
730 	TimeInUnixFormat += ts-&gt;hour*60*60;
731 	TimeInUnixFormat += ts-&gt;minute*60;
732 	TimeInUnixFormat += ts-&gt;second;
733 	utcOffset = ts-&gt;OffsetHour*3600 + ts-&gt;OffsetMinute*60;
734 	if(ts-&gt;OffsetMode == '+')
735 		utcOffset *= -1; 	TimeInUnixFormat += utcOffset;
736 done:
737 	return TimeInUnixFormat;
738 }
739 static int
740 formatTimestampUnix(struct syslogTime *ts, char *pBuf)
741 {
742 	snprintf(pBuf, 11, "%u", (unsigned) syslogTime2time_t(ts));
743 	return 11;
744 }
745 int getWeekdayNbr(struct syslogTime *ts)
746 {
747 	int wday;
748 	int g, f;
749 	g = ts-&gt;year;
750 	if(ts-&gt;month &lt; 3) {
751 		g--;
752 		f = ts-&gt;month + 13;
753 	} else {
754 		f = ts-&gt;month + 1;
755 	}
756 	wday = ((36525*g)/100) + ((306*f)/10) + ts-&gt;day - 621049;
757 	wday %= 7;
758 	return wday;
759 }
760 int getOrdinal(struct syslogTime *ts)
761 {
762 	int yday;
763 	time_t thistime;
764 	time_t previousyears;
765 	int utcOffset;
766 	time_t seconds_into_year;
767 	if(ts-&gt;year &lt; 1970 || ts-&gt;year &gt; 2100) {
768 		yday = 0;
769 		LogError(0, RS_RET_ERR, "getOrdinal: invalid year %d "
770 			"in timestamp - returning 1970-01-01 instead", ts-&gt;year);
771 		goto done;
772 	}
773 	thistime = syslogTime2time_t(ts);
774 	previousyears = (time_t) yearInSecs[ts-&gt;year - yearInSec_startYear - 1];
775 	utcOffset = ts-&gt;OffsetHour*3600 + ts-&gt;OffsetMinute*60;
776 	if(ts-&gt;OffsetMode == '+')
777 		utcOffset += -1; 	previousyears += utcOffset;
778 	seconds_into_year = thistime - previousyears;
779 	yday = seconds_into_year / 86400;
780 done:
781 	return yday;
782 }
783 int getWeek(struct syslogTime *ts)
784 {
785 	int weekNum;
786 	struct syslogTime yt;
787 	int curDow;
788 	int jan1Dow;
789 <a name="3"></a>	int curYearDay;
790 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	yt.year = ts-&gt;year;
791 	yt.month = 1;
792 	yt.day = 1;
793 	yt.hour = 0;
794 	yt.minute = 0;
795 	yt.second = 0;
796 	yt.secfracPrecision = 0;
797 	yt.secfrac = 0;
798 	yt.OffsetMinute = ts-&gt;OffsetMinute;
799 	yt.OffsetHour = ts-&gt;OffsetHour;
800 	yt.OffsetMode = ts-&gt;OffsetMode;
801 	yt.timeType = TIME_TYPE_RFC3164; 
802 	curYearDay = getOrdinal(ts);
803 	curDow = getWeekdayNbr(ts);
804 	jan1Dow = getWeekdayNbr(&amp;yt);</b></font>
805 	weekNum = ((curYearDay + 6) / 7);
806 	if (curDow &lt; jan1Dow) {
807 		++weekNum;
808 	}
809 	return weekNum;
810 }
811 int getISOWeek(struct syslogTime *ts, int *year)
812 {
813 	int weekNum;
814 	int curDow;
815 	int curYearDay;
816 	curYearDay = getOrdinal(ts);
817 	curDow = getWeekdayNbr(ts);
818 	if (curDow == 0) {
819 		curDow = 7;
820 	}
821 	curYearDay++;
822 	weekNum = (10 + curYearDay - curDow) / 7;
823 	*year = ts-&gt;year;
824 	if (weekNum == 0) {
825 		weekNum = weeksInYear[ts-&gt;year - 1 - 1969];
826 		*year = ts-&gt;year - 1;
827 	} else if (weekNum &gt; weeksInYear[ts-&gt;year - 1969]) {
828 		weekNum = 1;
829 		*year = ts-&gt;year + 1;
830 	}
831 	return weekNum;
832 }
833 void
834 timeConvertToUTC(const struct syslogTime *const __restrict__ local,
835 	struct syslogTime *const __restrict__ utc)
836 {
837 	struct timeval tp;
838 	tp.tv_sec = syslogTime2time_t(local);
839 	tp.tv_usec = local-&gt;secfrac;
840 	timeval2syslogTime(&amp;tp, utc, 1);
841 }
842 static int
843 formatUnixTimeFromTime_t(time_t unixtime, const char *format, char *pBuf,
844 	__attribute__((unused)) uint pBufMax) {
845 	struct tm lt;
846 	assert(format != NULL);
847 	assert(pBuf != NULL);
848 	if (gmtime_r(&amp;unixtime, &amp;lt) == NULL) {
849 		DBGPRINTF("Unexpected error calling gmtime_r().\n");
850 		return -1;
851 	}
852 	if (strcmp(format, "date-rfc3164") == 0) {
853 		assert(pBufMax &gt;= 16);
854 		if (lt.tm_mon &lt; 0 || lt.tm_mon &gt; 11) {
855 			DBGPRINTF("lt.tm_mon is out of range. Value: %d\n", lt.tm_mon);
856 			return -1;
857 		}
858 		sprintf(pBuf, "%s %2d %.2d:%.2d:%.2d",
859 			monthNames[lt.tm_mon], lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec
860 		);
861 	} else if (strcmp(format, "date-rfc3339") == 0) {
862 		assert(pBufMax &gt;= 26);
863 		sprintf(pBuf, "%d-%.2d-%.2dT%.2d:%.2d:%.2dZ",
864 			lt.tm_year + 1900, lt.tm_mon + 1, lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec
865 		);
866 	}
867 	return strlen(pBuf);
868 }
869 BEGINobjQueryInterface(datetime)
870 CODESTARTobjQueryInterface(datetime)
871 	if(pIf-&gt;ifVersion != datetimeCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
872 	}
873 	pIf-&gt;getCurrTime = getCurrTime;
874 	pIf-&gt;GetTime = getTime;
875 	pIf-&gt;timeval2syslogTime = timeval2syslogTime;
876 	pIf-&gt;ParseTIMESTAMP3339 = ParseTIMESTAMP3339;
877 	pIf-&gt;ParseTIMESTAMP3164 = ParseTIMESTAMP3164;
878 	pIf-&gt;formatTimestampToMySQL = formatTimestampToMySQL;
879 	pIf-&gt;formatTimestampToPgSQL = formatTimestampToPgSQL;
880 	pIf-&gt;formatTimestampSecFrac = formatTimestampSecFrac;
881 	pIf-&gt;formatTimestamp3339 = formatTimestamp3339;
882 	pIf-&gt;formatTimestamp3164 = formatTimestamp3164;
883 	pIf-&gt;formatTimestampUnix = formatTimestampUnix;
884 	pIf-&gt;syslogTime2time_t = syslogTime2time_t;
885 	pIf-&gt;formatUnixTimeFromTime_t = formatUnixTimeFromTime_t;
886 finalize_it:
887 ENDobjQueryInterface(datetime)
888 BEGINAbstractObjClassInit(datetime, 1, OBJ_IS_CORE_MODULE) ENDObjClassInit(datetime)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rsconf.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;unistd.h&gt;
8 #include &lt;pwd.h&gt;
9 #include &lt;grp.h&gt;
10 #include &lt;stdarg.h&gt;
11 #include &lt;sys/resource.h&gt;
12 #include &lt;sys/types.h&gt;
13 #include &lt;sys/stat.h&gt;
14 #include &lt;sys/socket.h&gt;
15 #include "rsyslog.h"
16 #include "obj.h"
17 #include "srUtils.h"
18 #include "ruleset.h"
19 #include "modules.h"
20 #include "conf.h"
21 #include "queue.h"
22 #include "rsconf.h"
23 #include "cfsysline.h"
24 #include "errmsg.h"
25 #include "action.h"
26 #include "glbl.h"
27 #include "unicode-helper.h"
28 #include "omshell.h"
29 #include "omusrmsg.h"
30 #include "omfwd.h"
31 #include "omfile.h"
32 #include "ompipe.h"
33 #include "omdiscard.h"
34 #include "pmrfc5424.h"
35 #include "pmrfc3164.h"
36 #include "smfile.h"
37 #include "smtradfile.h"
38 #include "smfwd.h"
39 #include "smtradfwd.h"
40 #include "parser.h"
41 #include "outchannel.h"
42 #include "threads.h"
43 #include "datetime.h"
44 #include "parserif.h"
45 #include "modules.h"
46 #include "dirty.h"
47 #include "template.h"
48 #include "timezones.h"
49 extern char* yytext;
50 DEFobjStaticHelpers
51 DEFobjCurrIf(ruleset)
52 DEFobjCurrIf(module)
53 DEFobjCurrIf(conf)
54 DEFobjCurrIf(glbl)
55 DEFobjCurrIf(parser)
56 DEFobjCurrIf(datetime)
57 rsconf_t *runConf = NULL;rsconf_t *loadConf = NULL;
58 static uchar template_DebugFormat[] = "\"Debug line with all properties:\nFROMHOST: '%FROMHOST%', fromhost-ip: "
59 "'%fromhost-ip%', HOSTNAME: '%HOSTNAME%', PRI: %PRI%,\nsyslogtag '%syslogtag%', programname: '%programname%', "
60 "APP-NAME: '%APP-NAME%', PROCID: '%PROCID%', MSGID: '%MSGID%',\nTIMESTAMP: '%TIMESTAMP%', "
61 "STRUCTURED-DATA: '%STRUCTURED-DATA%',\nmsg: '%msg%'\nescaped msg: '%msg:::drop-cc%'\ninputname: %inputname% "
62 "rawmsg: '%rawmsg%'\n$!:%$!%\n$.:%$.%\n$/:%$/%\n\n\"";
63 static uchar template_SyslogProtocol23Format[] = "\"&lt;%PRI%&gt;1 %TIMESTAMP:::date-rfc3339% %HOSTNAME% %APP-NAME% "
64 "%PROCID% %MSGID% %STRUCTURED-DATA% %msg%\n\"";
65 static uchar template_SyslogRFC5424Format[] = "\"&lt;%PRI%&gt;1 %TIMESTAMP:::date-rfc3339% %HOSTNAME% %APP-NAME% "
66 "%PROCID% %MSGID% %STRUCTURED-DATA% %msg%\"";
67 static uchar template_TraditionalFileFormat[] = "=RSYSLOG_TraditionalFileFormat";
68 static uchar template_FileFormat[] = "=RSYSLOG_FileFormat";
69 static uchar template_ForwardFormat[] = "=RSYSLOG_ForwardFormat";
70 static uchar template_TraditionalForwardFormat[] = "=RSYSLOG_TraditionalForwardFormat";
71 static uchar template_WallFmt[] = "\"\r\n\7Message from syslogd@%HOSTNAME% at %timegenerated% ...\r\n "
72 "%syslogtag%%msg%\n\r\"";
73 static uchar template_StdUsrMsgFmt[] = "\" %syslogtag%%msg%\n\r\"";
74 static uchar template_StdDBFmt[] = "\"insert into SystemEvents (Message, Facility, FromHost, Priority, "
75 "DeviceReportedTime, ReceivedAt, InfoUnitID, SysLogTag) values ('%msg%', %syslogfacility%, "
76 "'%HOSTNAME%', %syslogpriority%, '%timereported:::date-mysql%', '%timegenerated:::date-mysql%', %iut%, "
77 "'%syslogtag%')\",SQL";
78 static uchar template_StdPgSQLFmt[] = "\"insert into SystemEvents (Message, Facility, FromHost, Priority, "
79 "DeviceReportedTime, ReceivedAt, InfoUnitID, SysLogTag) values ('%msg%', %syslogfacility%, "
80 "'%HOSTNAME%', %syslogpriority%, '%timereported:::date-pgsql%', '%timegenerated:::date-pgsql%', %iut%, "
81 "'%syslogtag%')\",STDSQL";
82 static uchar template_spoofadr[] = "\"%fromhost-ip%\"";
83 static uchar template_SysklogdFileFormat[] = "\"%TIMESTAMP% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg%\n\"";
84 static uchar template_StdJSONFmt[] = "\"{\\\"message\\\":\\\"%msg:::json%\\\",\\\"fromhost\\\":\\\""
85 "%HOSTNAME:::json%\\\",\\\"facility\\\":\\\"%syslogfacility-text%\\\",\\\"priority\\\":\\\""
86 "%syslogpriority-text%\\\",\\\"timereported\\\":\\\"%timereported:::date-rfc3339%\\\",\\\"timegenerated\\\":\\\""
87 "%timegenerated:::date-rfc3339%\\\"}\"";
88 static uchar template_FullJSONFmt[] = "\"{\\\"message\\\":\\\"%msg:::json%\\\","
89 "\\\"fromhost\\\":\\\"%HOSTNAME:::json%\\\","
90 "\\\"programname\\\":\\\"%programname%\\\","
91 "\\\"procid\\\":\\\"%PROCID%\\\","
92 "\\\"msgid\\\":\\\"%MSGID%\\\","
93 "\\\"facility\\\":\\\"%syslogfacility-text%\\\","
94 "\\\"priority\\\":\\\"%syslogpriority-text%\\\","
95 "\\\"timereported\\\":\\\"%timereported:::date-rfc3339%\\\","
96 "\\\"timegenerated\\\":\\\"%timegenerated:::date-rfc3339%\\\"}\"";
97 static uchar template_StdClickHouseFmt[] = "\"INSERT INTO rsyslog.SystemEvents (severity, facility, "
98 "timestamp, hostname, tag, message) VALUES (%syslogseverity%, %syslogfacility%, "
99 "'%timereported:::date-unixtimestamp%', '%hostname%', '%syslogtag%', '%msg%')\",STDSQL";
100 static struct cnfparamdescr inppdescr[] = {
101 	{ "type", eCmdHdlrString, CNFPARAM_REQUIRED }
102 };
103 static struct cnfparamblk inppblk =
104 	{ CNFPARAMBLK_VERSION,
105 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
106 	  inppdescr
107 	};
108 static struct cnfparamdescr parserpdescr[] = {
109 	{ "type", eCmdHdlrString, CNFPARAM_REQUIRED },
110 	{ "name", eCmdHdlrString, CNFPARAM_REQUIRED }
111 };
112 static struct cnfparamblk parserpblk =
113 	{ CNFPARAMBLK_VERSION,
114 	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
115 	  parserpdescr
116 	};
117 void cnfDoCfsysline(char *ln);
118 int rsconfNeedDropPriv(rsconf_t *const cnf)
119 {
120 	return ((cnf-&gt;globals.gidDropPriv != 0) || (cnf-&gt;globals.uidDropPriv != 0));
121 <a name="4"></a>}
122 static void cnfSetDefaults(rsconf_t *pThis)
123 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
124 	pThis-&gt;globals.bAbortOnUncleanConfig = 0;
125 	pThis-&gt;globals.bReduceRepeatMsgs = 0;
126 	pThis-&gt;globals.bDebugPrintTemplateList = 1;
127 	pThis-&gt;globals.bDebugPrintModuleList = 0;
128 	pThis-&gt;globals.bDebugPrintCfSysLineHandlerList = 0;
129 	pThis-&gt;globals.bLogStatusMsgs = DFLT_bLogStatusMsgs;
130 	pThis-&gt;globals.bErrMsgToStderr = 1;
131 	pThis-&gt;globals.maxErrMsgToStderr = -1;
132 	pThis-&gt;globals.umask = -1;
133 	pThis-&gt;globals.gidDropPrivKeepSupplemental = 0;
134 	pThis-&gt;globals.abortOnIDResolutionFail = 1;
135 	pThis-&gt;templates.root = NULL;</b></font>
136 	pThis-&gt;templates.last = NULL;
137 	pThis-&gt;templates.lastStatic = NULL;
138 	pThis-&gt;actions.nbrActions = 0;
139 	pThis-&gt;actions.iActionNbr = 0;
140 	pThis-&gt;globals.pszWorkDir = NULL;
141 	pThis-&gt;globals.bDropMalPTRMsgs = 0;
142 	pThis-&gt;globals.operatingStateFile = NULL;
143 	pThis-&gt;globals.iGnuTLSLoglevel = 0;
144 	pThis-&gt;globals.debugOnShutdown = 0;
145 	pThis-&gt;globals.pszDfltNetstrmDrvrCAF = NULL;
146 <a name="2"></a>	pThis-&gt;globals.pszDfltNetstrmDrvrCertFile = NULL;
147 	pThis-&gt;globals.pszDfltNetstrmDrvrKeyFile = NULL;
148 	pThis-&gt;globals.pszDfltNetstrmDrvr = NULL;
149 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pThis-&gt;globals.oversizeMsgErrorFile = NULL;
150 	pThis-&gt;globals.reportOversizeMsg = 1;
151 	pThis-&gt;globals.oversizeMsgInputMode = 0;
152 	pThis-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_ERRORS;
153 	pThis-&gt;globals.bActionReportSuspension = 1;
154 	pThis-&gt;globals.bActionReportSuspensionCont = 0;
155 	pThis-&gt;globals.janitorInterval = 10;
156 	pThis-&gt;globals.reportNewSenders = 0;
157 	pThis-&gt;globals.reportGoneAwaySenders = 0;
158 	pThis-&gt;globals.senderStatsTimeout = 12 * 60 * 60; 	pThis-&gt;globals.senderKeepTrack = 0;
159 	pThis-&gt;globals.inputTimeoutShutdown = 1000;
160 	pThis-&gt;globals.iDefPFFamily = PF_UNSPEC;
161 	pThis-&gt;globals.ACLAddHostnameOnFail = 0;
162 	pThis-&gt;globals.ACLDontResolve = 0;
163 <a name="0"></a>	pThis-&gt;globals.bDisableDNS = 0;</b></font>
164 	pThis-&gt;globals.bProcessInternalMessages = 0;
165 	const char *const log_dflt = getenv("RSYSLOG_DFLT_LOG_INTERNAL");
166 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(log_dflt != NULL &amp;&amp; !strcmp(log_dflt, "1"))
167 		pThis-&gt;globals.bProcessInternalMessages = 1;
168 	pThis-&gt;globals.glblDevOptions = 0;
169 	pThis-&gt;globals.intMsgRateLimitItv = 5;
170 	pThis-&gt;globals.intMsgRateLimitBurst = 500;
171 	pThis-&gt;globals.intMsgsSeverityFilter = DFLT_INT_MSGS_SEV_FILTER;
172 	pThis-&gt;globals.permitCtlC = glblPermitCtlC;
173 	pThis-&gt;globals.actq_dflt_toQShutdown = 10;
174 	pThis-&gt;globals.actq_dflt_toActShutdown = 1000;
175 	pThis-&gt;globals.actq_dflt_toEnq = 2000;
176 	pThis-&gt;globals.actq_dflt_toWrkShutdown = 60000;
177 	pThis-&gt;globals.ruleset_dflt_toQShutdown = 1500;
178 	pThis-&gt;globals.ruleset_dflt_toActShutdown = 1000;
179 	pThis-&gt;globals.ruleset_dflt_toEnq = 2000;
180 	pThis-&gt;globals.ruleset_dflt_toWrkShutdown = 60000;
181 	pThis-&gt;globals.dnscacheDefaultTTL = 24 * 60 * 60;
182 	pThis-&gt;globals.dnscacheEnableTTL = 0;
183 	pThis-&gt;globals.shutdownQueueDoubleSize = 0;
184 	pThis-&gt;globals.optionDisallowWarning = 1;
185 	pThis-&gt;globals.bSupportCompressionExtension = 1;
186 	#ifdef ENABLE_LIBLOGGING_STDLOG
187 		pThis-&gt;globals.stdlog_hdl = stdlog_open("rsyslogd", 0, STDLOG_SYSLOG, NULL);</b></font>
188 		pThis-&gt;globals.stdlog_chanspec = NULL;
189 	#endif
190 	pThis-&gt;globals.iMaxLine = 8096;
191 	pThis-&gt;timezones.tzinfos = NULL;
192 	pThis-&gt;timezones.ntzinfos = 0;
193 	pThis-&gt;globals.mainQ.iMainMsgQueueSize = 100000;
194 	pThis-&gt;globals.mainQ.iMainMsgQHighWtrMark = 80000;
195 	pThis-&gt;globals.mainQ.iMainMsgQLowWtrMark = 20000;
196 	pThis-&gt;globals.mainQ.iMainMsgQDiscardMark = 98000;
197 	pThis-&gt;globals.mainQ.iMainMsgQDiscardSeverity = 8;
198 <a name="3"></a>	pThis-&gt;globals.mainQ.iMainMsgQueueNumWorkers = 2;
199 	pThis-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
200 	pThis-&gt;globals.mainQ.pszMainMsgQFName = NULL;
201 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pThis-&gt;globals.mainQ.iMainMsgQueMaxFileSize = 1024*1024;
202 	pThis-&gt;globals.mainQ.iMainMsgQPersistUpdCnt = 0;
203 	pThis-&gt;globals.mainQ.bMainMsgQSyncQeueFiles = 0;
204 	pThis-&gt;globals.mainQ.iMainMsgQtoQShutdown = 1500;
205 	pThis-&gt;globals.mainQ.iMainMsgQtoActShutdown = 1000;
206 	pThis-&gt;globals.mainQ.iMainMsgQtoEnq = 2000;
207 	pThis-&gt;globals.mainQ.iMainMsgQtoWrkShutdown = 60000;
208 	pThis-&gt;globals.mainQ.iMainMsgQWrkMinMsgs = 40000;
209 	pThis-&gt;globals.mainQ.iMainMsgQDeqSlowdown = 0;
210 	pThis-&gt;globals.mainQ.iMainMsgQueMaxDiskSpace = 0;
211 	pThis-&gt;globals.mainQ.iMainMsgQueDeqBatchSize = 256;
212 	pThis-&gt;globals.mainQ.bMainMsgQSaveOnShutdown = 1;
213 	pThis-&gt;globals.mainQ.iMainMsgQueueDeqtWinFromHr = 0;
214 	pThis-&gt;globals.mainQ.iMainMsgQueueDeqtWinToHr = 25;
215 	pThis-&gt;pMsgQueue = NULL;</b></font>
216 	pThis-&gt;globals.parser.cCCEscapeChar = '#';
217 	pThis-&gt;globals.parser.bDropTrailingLF = 1;
218 	pThis-&gt;globals.parser.bEscapeCCOnRcv = 1;
219 	pThis-&gt;globals.parser.bSpaceLFOnRcv = 0;
220 	pThis-&gt;globals.parser.bEscape8BitChars = 0;
221 	pThis-&gt;globals.parser.bEscapeTab = 1;
222 	pThis-&gt;globals.parser.bParserEscapeCCCStyle = 0;
223 	pThis-&gt;globals.parser.bPermitSlashInProgramname = 0;
224 	pThis-&gt;globals.parser.bParseHOSTNAMEandTAG = 1;
225 	pThis-&gt;parsers.pDfltParsLst = NULL;
226 	pThis-&gt;parsers.pParsLstRoot = NULL;
227 }
228 BEGINobjConstruct(rsconf) 	cnfSetDefaults(pThis);
229 	lookupInitCnf(&amp;pThis-&gt;lu_tabs);
230 	CHKiRet(dynstats_initCnf(&amp;pThis-&gt;dynstats_buckets));
231 	CHKiRet(perctile_initCnf(&amp;pThis-&gt;perctile_buckets));
232 	CHKiRet(llInit(&amp;pThis-&gt;rulesets.llRulesets, rulesetDestructForLinkedList,
233 			rulesetKeyDestruct, strcasecmp));
234 finalize_it:
235 ENDobjConstruct(rsconf)
236 static rsRetVal
237 rsconfConstructFinalize(rsconf_t __attribute__((unused)) *pThis)
238 {
239 	DEFiRet;
240 	ISOBJ_TYPE_assert(pThis, rsconf);
241 	RETiRet;
242 }
243 static void
244 freeCnf(rsconf_t *pThis)
245 {
246 	cfgmodules_etry_t *etry, *del;
247 	etry = pThis-&gt;modules.root;
248 	while(etry != NULL) {
249 		if(etry-&gt;pMod-&gt;beginCnfLoad != NULL) {
250 			dbgprintf("calling freeCnf(%p) for module '%s'\n",
251 				  etry-&gt;modCnf, (char*) module.GetName(etry-&gt;pMod));
252 			etry-&gt;pMod-&gt;freeCnf(etry-&gt;modCnf);
253 		}
254 		del = etry;
255 		etry = etry-&gt;next;
256 		free(del);
257 	}
258 }
259 PROTOTYPEobjDestruct(rsconf);
260 BEGINobjDestruct(rsconf) CODESTARTobjDestruct(rsconf)
261 	freeCnf(pThis);
262 	tplDeleteAll(pThis);
263 	dynstats_destroyAllBuckets();
264 	perctileBucketsDestruct();
265 	ochDeleteAll();
266 	freeTimezones(pThis);
267 	parser.DestructParserList(&amp;pThis-&gt;parsers.pDfltParsLst);
268 	parser.destroyMasterParserList(pThis-&gt;parsers.pParsLstRoot);
269 	free(pThis-&gt;globals.mainQ.pszMainMsgQFName);
270 	free(pThis-&gt;globals.pszConfDAGFile);
271 	free(pThis-&gt;globals.pszWorkDir);
272 	free(pThis-&gt;globals.operatingStateFile);
273 	free(pThis-&gt;globals.pszDfltNetstrmDrvrCAF);
274 	free(pThis-&gt;globals.pszDfltNetstrmDrvrCertFile);
275 	free(pThis-&gt;globals.pszDfltNetstrmDrvrKeyFile);
276 	free(pThis-&gt;globals.pszDfltNetstrmDrvr);
277 	free(pThis-&gt;globals.oversizeMsgErrorFile);
278 	#ifdef ENABLE_LIBLOGGING_STDLOG
279 		stdlog_close(pThis-&gt;globals.stdlog_hdl);
280 		free(pThis-&gt;globals.stdlog_chanspec);
281 	#endif
282 	lookupDestroyCnf();
283 	llDestroy(&amp;(pThis-&gt;rulesets.llRulesets));
284 ENDobjDestruct(rsconf)
285 PROTOTYPEObjDebugPrint(rsconf);
286 BEGINobjDebugPrint(rsconf) 	cfgmodules_etry_t *modNode;
287 	dbgprintf("configuration object %p\n", pThis);
288 	dbgprintf("Global Settings:\n");
289 	dbgprintf("  bDebugPrintTemplateList.............: %d\n",
290 		  pThis-&gt;globals.bDebugPrintTemplateList);
291 	dbgprintf("  bDebugPrintModuleList               : %d\n",
292 		  pThis-&gt;globals.bDebugPrintModuleList);
293 	dbgprintf("  bDebugPrintCfSysLineHandlerList.....: %d\n",
294 		  pThis-&gt;globals.bDebugPrintCfSysLineHandlerList);
295 	dbgprintf("  bLogStatusMsgs                      : %d\n",
296 		  pThis-&gt;globals.bLogStatusMsgs);
297 	dbgprintf("  bErrMsgToStderr.....................: %d\n",
298 		  pThis-&gt;globals.bErrMsgToStderr);
299 	dbgprintf("  drop Msgs with malicious PTR Record : %d\n",
300 		  glbl.GetDropMalPTRMsgs(pThis));
301 	ruleset.DebugPrintAll(pThis);
302 	dbgprintf("\n");
303 	if(pThis-&gt;globals.bDebugPrintTemplateList)
304 		tplPrintList(pThis);
305 	if(pThis-&gt;globals.bDebugPrintModuleList)
306 		module.PrintList();
307 	if(pThis-&gt;globals.bDebugPrintCfSysLineHandlerList)
308 		dbgPrintCfSysLineHandlers();
309 	dbgprintf("Main queue size %d messages.\n", pThis-&gt;globals.mainQ.iMainMsgQueueSize);
310 	dbgprintf("Main queue worker threads: %d, wThread shutdown: %d, Perists every %d updates.\n",
311 		  pThis-&gt;globals.mainQ.iMainMsgQueueNumWorkers,
312 		  pThis-&gt;globals.mainQ.iMainMsgQtoWrkShutdown, pThis-&gt;globals.mainQ.iMainMsgQPersistUpdCnt);
313 	dbgprintf("Main queue timeouts: shutdown: %d, action completion shutdown: %d, enq: %d\n",
314 		   pThis-&gt;globals.mainQ.iMainMsgQtoQShutdown,
315 		   pThis-&gt;globals.mainQ.iMainMsgQtoActShutdown, pThis-&gt;globals.mainQ.iMainMsgQtoEnq);
316 	dbgprintf("Main queue watermarks: high: %d, low: %d, discard: %d, discard-severity: %d\n",
317 		   pThis-&gt;globals.mainQ.iMainMsgQHighWtrMark, pThis-&gt;globals.mainQ.iMainMsgQLowWtrMark,
318 		   pThis-&gt;globals.mainQ.iMainMsgQDiscardMark, pThis-&gt;globals.mainQ.iMainMsgQDiscardSeverity);
319 	dbgprintf("Main queue save on shutdown %d, max disk space allowed %lld\n",
320 		   pThis-&gt;globals.mainQ.bMainMsgQSaveOnShutdown, pThis-&gt;globals.mainQ.iMainMsgQueMaxDiskSpace);
321 	dbgprintf("Work Directory: '%s'.\n", glbl.GetWorkDir(pThis));
322 	ochPrintList(pThis);
323 	dbgprintf("Modules used in this configuration:\n");
324 	for(modNode = pThis-&gt;modules.root ; modNode != NULL ; modNode = modNode-&gt;next) {
325 		dbgprintf("    %s\n", module.GetName(modNode-&gt;pMod));
326 	}
327 CODESTARTobjDebugPrint(rsconf)
328 ENDobjDebugPrint(rsconf)
329 static rsRetVal
330 parserProcessCnf(struct cnfobj *o)
331 {
332 	struct cnfparamvals *pvals;
333 	modInfo_t *pMod;
334 	uchar *cnfModName = NULL;
335 	uchar *parserName = NULL;
336 	int paramIdx;
337 	void *parserInst;
338 	parser_t *myparser;
339 	DEFiRet;
340 	pvals = nvlstGetParams(o-&gt;nvlst, &amp;parserpblk, NULL);
341 	if(pvals == NULL) {
342 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
343 	}
344 	DBGPRINTF("input param blk after parserProcessCnf:\n");
345 	cnfparamsPrint(&amp;parserpblk, pvals);
346 	paramIdx = cnfparamGetIdx(&amp;parserpblk, "name");
347 	parserName = (uchar*)es_str2cstr(pvals[paramIdx].val.d.estr, NULL);
348 	if(parser.FindParser(loadConf-&gt;parsers.pParsLstRoot, &amp;myparser, parserName) != RS_RET_PARSER_NOT_FOUND) {
349 		LogError(0, RS_RET_PARSER_NAME_EXISTS,
350 			"parser module name '%s' already exists", parserName);
351 		ABORT_FINALIZE(RS_RET_PARSER_NAME_EXISTS);
352 	}
353 	paramIdx = cnfparamGetIdx(&amp;parserpblk, "type");
354 	cnfModName = (uchar*)es_str2cstr(pvals[paramIdx].val.d.estr, NULL);
355 	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_PARSER)) == NULL) {
356 		LogError(0, RS_RET_MOD_UNKNOWN, "parser module name '%s' is unknown", cnfModName);
357 		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
358 	}
359 	if(pMod-&gt;mod.pm.newParserInst == NULL) {
360 		LogError(0, RS_RET_MOD_NO_PARSER_STMT,
361 				"parser module '%s' does not support parser() statement", cnfModName);
362 		ABORT_FINALIZE(RS_RET_MOD_NO_INPUT_STMT);
363 	}
364 	CHKiRet(pMod-&gt;mod.pm.newParserInst(o-&gt;nvlst, &amp;parserInst));
365 	CHKiRet(parserConstructViaModAndName(pMod, parserName, parserInst));
366 finalize_it:
367 	free(cnfModName);
368 	free(parserName);
369 	cnfparamvalsDestruct(pvals, &amp;parserpblk);
370 	RETiRet;
371 }
372 static rsRetVal
373 inputProcessCnf(struct cnfobj *o)
374 {
375 	struct cnfparamvals *pvals;
376 	modInfo_t *pMod;
377 	uchar *cnfModName = NULL;
378 	int typeIdx;
379 	DEFiRet;
380 	pvals = nvlstGetParams(o-&gt;nvlst, &amp;inppblk, NULL);
381 	if(pvals == NULL) {
382 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
383 	}
384 	DBGPRINTF("input param blk after inputProcessCnf:\n");
385 	cnfparamsPrint(&amp;inppblk, pvals);
386 	typeIdx = cnfparamGetIdx(&amp;inppblk, "type");
387 	cnfModName = (uchar*)es_str2cstr(pvals[typeIdx].val.d.estr, NULL);
388 	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_IN)) == NULL) {
389 		LogError(0, RS_RET_MOD_UNKNOWN, "input module name '%s' is unknown", cnfModName);
390 		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
391 	}
392 	if(pMod-&gt;mod.im.newInpInst == NULL) {
393 		LogError(0, RS_RET_MOD_NO_INPUT_STMT,
394 				"input module '%s' does not support input() statement", cnfModName);
395 		ABORT_FINALIZE(RS_RET_MOD_NO_INPUT_STMT);
396 	}
397 	iRet = pMod-&gt;mod.im.newInpInst(o-&gt;nvlst);
398 finalize_it:
399 	free(cnfModName);
400 	cnfparamvalsDestruct(pvals, &amp;inppblk);
401 	RETiRet;
402 }
403 extern int yylineno;
404 void
405 parser_warnmsg(const char *fmt, ...)
406 {
407 	va_list ap;
408 	char errBuf[1024];
409 	va_start(ap, fmt);
410 	if(vsnprintf(errBuf, sizeof(errBuf), fmt, ap) == sizeof(errBuf))
411 		errBuf[sizeof(errBuf)-1] = '\0';
412 	LogMsg(0, RS_RET_CONF_PARSE_WARNING, LOG_WARNING,
413 			"warning during parsing file %s, on or before line %d: %s",
414 			cnfcurrfn, yylineno, errBuf);
415 	va_end(ap);
416 }
417 void
418 parser_errmsg(const char *fmt, ...)
419 {
420 	va_list ap;
421 	char errBuf[1024];
422 	va_start(ap, fmt);
423 	if(vsnprintf(errBuf, sizeof(errBuf), fmt, ap) == sizeof(errBuf))
424 		errBuf[sizeof(errBuf)-1] = '\0';
425 	if(cnfcurrfn == NULL) {
426 		LogError(0, RS_RET_CONF_PARSE_ERROR,
427 				"error during config processing: %s", errBuf);
428 	} else {
429 		LogError(0, RS_RET_CONF_PARSE_ERROR,
430 				"error during parsing file %s, on or before line %d: %s",
431 				cnfcurrfn, yylineno, errBuf);
432 	}
433 	va_end(ap);
434 }
435 int yyerror(const char *s); int
436 yyerror(const char *s)
437 {
438 	parser_errmsg("%s on token '%s'", s, yytext);
439 	return 0;
440 }
441 void ATTR_NONNULL()
442 cnfDoObj(struct cnfobj *const o)
443 {
444 	int bDestructObj = 1;
445 	int bChkUnuse = 1;
446 	assert(o != NULL);
447 	dbgprintf("cnf:global:obj: ");
448 	cnfobjPrint(o);
449 	if (nvlstChkDisabled(o-&gt;nvlst)) {
450 		dbgprintf("object disabled by configuration\n");
451 		return;
452 	}
453 	switch(o-&gt;objType) {
454 	case CNFOBJ_GLOBAL:
455 		glblProcessCnf(o);
456 		break;
457 	case CNFOBJ_TIMEZONE:
458 		glblProcessTimezone(o);
459 		break;
460 	case CNFOBJ_MAINQ:
461 		glblProcessMainQCnf(o);
462 		bDestructObj = 0;
463 		break;
464 	case CNFOBJ_MODULE:
465 		modulesProcessCnf(o);
466 		break;
467 	case CNFOBJ_INPUT:
468 		inputProcessCnf(o);
469 		break;
470 	case CNFOBJ_LOOKUP_TABLE:
471 		lookupTableDefProcessCnf(o);
472 		break;
473 	case CNFOBJ_DYN_STATS:
474 		dynstats_processCnf(o);
475 		break;
476 	case CNFOBJ_PERCTILE_STATS:
477 		perctile_processCnf(o);
478 		break;
479 	case CNFOBJ_PARSER:
480 		parserProcessCnf(o);
481 		break;
482 	case CNFOBJ_TPL:
483 		if(tplProcessCnf(o) != RS_RET_OK)
484 			parser_errmsg("error processing template object");
485 		break;
486 	case CNFOBJ_RULESET:
487 		rulesetProcessCnf(o);
488 		break;
489 	case CNFOBJ_PROPERTY:
490 	case CNFOBJ_CONSTANT:
491 		bChkUnuse = 0;
492 		break;
493 	case CNFOBJ_ACTION:
494 	default:
495 		dbgprintf("cnfDoObj program error: unexpected object type %u\n",
496 			 o-&gt;objType);
497 		break;
498 	}
499 	if(bDestructObj) {
500 		if(bChkUnuse)
501 			nvlstChkUnused(o-&gt;nvlst);
502 		cnfobjDestruct(o);
503 	 }
504 }
505 void cnfDoScript(struct cnfstmt *script)
506 {
507 	dbgprintf("cnf:global:script\n");
508 	ruleset.AddScript(ruleset.GetCurrent(loadConf), script);
509 }
510 void cnfDoCfsysline(char *ln)
511 {
512 	DBGPRINTF("cnf:global:cfsysline: %s\n", ln);
513 	conf.cfsysline((uchar*) ln+1);
514 	free(ln);
515 }
516 void cnfDoBSDTag(char *ln)
517 {
518 	DBGPRINTF("cnf:global:BSD tag: %s\n", ln);
519 	LogError(0, RS_RET_BSD_BLOCKS_UNSUPPORTED,
520 			"BSD-style blocks are no longer supported in rsyslog, "
521 			"see https://www.rsyslog.com/g/BSD for details and a "
522 			"solution (Block '%s')", ln);
523 	free(ln);
524 }
525 void cnfDoBSDHost(char *ln)
526 {
527 	DBGPRINTF("cnf:global:BSD host: %s\n", ln);
528 	LogError(0, RS_RET_BSD_BLOCKS_UNSUPPORTED,
529 			"BSD-style blocks are no longer supported in rsyslog, "
530 			"see https://www.rsyslog.com/g/BSD for details and a "
531 			"solution (Block '%s')", ln);
532 	free(ln);
533 }
534 static
535 rsRetVal doDropPrivGid(rsconf_t *cnf)
536 {
537 	int res;
538 	uchar szBuf[1024];
539 	DEFiRet;
540 	if(!cnf-&gt;globals.gidDropPrivKeepSupplemental) {
541 		res = setgroups(0, NULL); 		if(res) {
542 			LogError(errno, RS_RET_ERR_DROP_PRIV,
543 					"could not remove supplemental group IDs");
544 			ABORT_FINALIZE(RS_RET_ERR_DROP_PRIV);
545 		}
546 		DBGPRINTF("setgroups(0, NULL): %d\n", res);
547 	}
548 	res = setgid(cnf-&gt;globals.gidDropPriv);
549 	if(res) {
550 		LogError(errno, RS_RET_ERR_DROP_PRIV,
551 				"could not set requested group id %d", cnf-&gt;globals.gidDropPriv);
552 		ABORT_FINALIZE(RS_RET_ERR_DROP_PRIV);
553 	}
554 	DBGPRINTF("setgid(%d): %d\n", cnf-&gt;globals.gidDropPriv, res);
555 	snprintf((char*)szBuf, sizeof(szBuf), "rsyslogd's groupid changed to %d",
556 		 cnf-&gt;globals.gidDropPriv);
557 	logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO, szBuf, 0);
558 finalize_it:
559 	RETiRet;
560 }
561 static void doDropPrivUid(rsconf_t *cnf)
562 {
563 	int res;
564 	uchar szBuf[1024];
565 	struct passwd *pw;
566 	gid_t gid;
567 	pw = getpwuid(cnf-&gt;globals.uidDropPriv);
568 	if (pw) {
569 		gid = getgid();
570 		res = initgroups(pw-&gt;pw_name, gid);
571 		DBGPRINTF("initgroups(%s, %ld): %d\n", pw-&gt;pw_name, (long) gid, res);
572 	} else {
573 		LogError(errno, NO_ERRCODE, "could not get username for userid '%d'",
574 			cnf-&gt;globals.uidDropPriv);
575 	}
576 	res = setuid(cnf-&gt;globals.uidDropPriv);
577 	if(res) {
578 		perror("could not set requested userid");
579 		exit(1);
580 	}
581 	DBGPRINTF("setuid(%d): %d\n", cnf-&gt;globals.uidDropPriv, res);
582 	snprintf((char*)szBuf, sizeof(szBuf), "rsyslogd's userid changed to %d", cnf-&gt;globals.uidDropPriv);
583 	logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO, szBuf, 0);
584 }
585 static rsRetVal
586 dropPrivileges(rsconf_t *cnf)
587 {
588 	DEFiRet;
589 	if(cnf-&gt;globals.gidDropPriv != 0) {
590 		CHKiRet(doDropPrivGid(cnf));
591 		DBGPRINTF("group privileges have been dropped to gid %u\n", (unsigned)
592 			  cnf-&gt;globals.gidDropPriv);
593 	}
594 	if(cnf-&gt;globals.uidDropPriv != 0) {
595 		doDropPrivUid(cnf);
596 		DBGPRINTF("user privileges have been dropped to uid %u\n", (unsigned)
597 			  cnf-&gt;globals.uidDropPriv);
598 	}
599 finalize_it:
600 	RETiRet;
601 }
602 static inline rsRetVal
603 tellCoreConfigLoadDone(void)
604 {
605 	DBGPRINTF("telling rsyslog core that config load for %p is done\n", loadConf);
606 	return glblDoneLoadCnf();
607 }
608 static rsRetVal
609 tellModulesConfigLoadDone(void)
610 {
611 	cfgmodules_etry_t *node;
612 	DBGPRINTF("telling modules that config load for %p is done\n", loadConf);
613 	node = module.GetNxtCnfType(loadConf, NULL, eMOD_ANY);
614 	while(node != NULL) {
615 		DBGPRINTF("beginCnfLoad(%p) for module '%s'\n", node-&gt;pMod-&gt;beginCnfLoad, node-&gt;pMod-&gt;pszName);
616 		if(node-&gt;pMod-&gt;beginCnfLoad != NULL) {
617 			DBGPRINTF("calling endCnfLoad() for module '%s'\n", node-&gt;pMod-&gt;pszName);
618 			node-&gt;pMod-&gt;endCnfLoad(node-&gt;modCnf);
619 		}
620 		node = module.GetNxtCnfType(loadConf, node, eMOD_ANY); 	}
621 	return RS_RET_OK; }
622 static rsRetVal
623 tellModulesCheckConfig(void)
624 {
625 	cfgmodules_etry_t *node;
626 	rsRetVal localRet;
627 	DBGPRINTF("telling modules to check config %p\n", loadConf);
628 	node = module.GetNxtCnfType(loadConf, NULL, eMOD_ANY);
629 	while(node != NULL) {
630 		if(node-&gt;pMod-&gt;beginCnfLoad != NULL) {
631 			localRet = node-&gt;pMod-&gt;checkCnf(node-&gt;modCnf);
632 			DBGPRINTF("module %s tells us config can %sbe activated\n",
633 					  node-&gt;pMod-&gt;pszName, (localRet == RS_RET_OK) ? "" : "NOT ");
634 			if(localRet == RS_RET_OK) {
635 				node-&gt;canActivate = 1;
636 			} else {
637 				node-&gt;canActivate = 0;
638 			}
639 		}
640 		node = module.GetNxtCnfType(loadConf, node, eMOD_ANY); 	}
641 	return RS_RET_OK; }
642 static rsRetVal
643 tellModulesActivateConfigPrePrivDrop(void)
644 {
645 	cfgmodules_etry_t *node;
646 	rsRetVal localRet;
647 	DBGPRINTF("telling modules to activate config (before dropping privs) %p\n", runConf);
648 	node = module.GetNxtCnfType(runConf, NULL, eMOD_ANY);
649 	while(node != NULL) {
650 		if(   node-&gt;pMod-&gt;beginCnfLoad != NULL
651 		   &amp;&amp; node-&gt;pMod-&gt;activateCnfPrePrivDrop != NULL
652 		   &amp;&amp; node-&gt;canActivate) {
653 			DBGPRINTF("pre priv drop activating config %p for module %s\n",
654 				  runConf, node-&gt;pMod-&gt;pszName);
655 			localRet = node-&gt;pMod-&gt;activateCnfPrePrivDrop(node-&gt;modCnf);
656 			if(localRet != RS_RET_OK) {
657 				LogError(0, localRet, "activation of module %s failed",
658 						node-&gt;pMod-&gt;pszName);
659 			node-&gt;canActivate = 0; 			}
660 		}
661 		node = module.GetNxtCnfType(runConf, node, eMOD_ANY);
662 	}
663 	return RS_RET_OK; }
664 static rsRetVal
665 tellModulesActivateConfig(void)
666 {
667 	cfgmodules_etry_t *node;
668 	rsRetVal localRet;
669 	DBGPRINTF("telling modules to activate config %p\n", runConf);
670 	node = module.GetNxtCnfType(runConf, NULL, eMOD_ANY);
671 	while(node != NULL) {
672 		if(node-&gt;pMod-&gt;beginCnfLoad != NULL &amp;&amp; node-&gt;canActivate) {
673 			DBGPRINTF("activating config %p for module %s\n",
674 				  runConf, node-&gt;pMod-&gt;pszName);
675 			localRet = node-&gt;pMod-&gt;activateCnf(node-&gt;modCnf);
676 			if(localRet != RS_RET_OK) {
677 				LogError(0, localRet, "activation of module %s failed",
678 						node-&gt;pMod-&gt;pszName);
679 			node-&gt;canActivate = 0; 			}
680 		}
681 		node = module.GetNxtCnfType(runConf, node, eMOD_ANY);
682 	}
683 	return RS_RET_OK; }
684 static rsRetVal
685 runInputModules(void)
686 {
687 	cfgmodules_etry_t *node;
688 	int bNeedsCancel;
689 	node = module.GetNxtCnfType(runConf, NULL, eMOD_IN);
690 	while(node != NULL) {
691 		if(node-&gt;canRun) {
692 			bNeedsCancel = (node-&gt;pMod-&gt;isCompatibleWithFeature(sFEATURENonCancelInputTermination)
693 			== RS_RET_OK) ? 0 : 1;
694 			DBGPRINTF("running module %s with config %p, term mode: %s\n", node-&gt;pMod-&gt;pszName, node,
695 				  bNeedsCancel ? "cancel" : "cooperative/SIGTTIN");
696 			thrdCreate(node-&gt;pMod-&gt;mod.im.runInput, node-&gt;pMod-&gt;mod.im.afterRun, bNeedsCancel,
697 			           (node-&gt;pMod-&gt;cnfName == NULL) ? node-&gt;pMod-&gt;pszName : node-&gt;pMod-&gt;cnfName);
698 		}
699 		node = module.GetNxtCnfType(runConf, node, eMOD_IN);
700 	}
701 	return RS_RET_OK; }
702 static rsRetVal
703 startInputModules(void)
704 {
705 	DEFiRet;
706 	cfgmodules_etry_t *node;
707 	node = module.GetNxtCnfType(runConf, NULL, eMOD_IN);
708 	while(node != NULL) {
709 		if(node-&gt;canActivate) {
710 			iRet = node-&gt;pMod-&gt;mod.im.willRun();
711 			node-&gt;canRun = (iRet == RS_RET_OK);
712 			if(!node-&gt;canRun) {
713 				DBGPRINTF("module %s will not run, iRet %d\n", node-&gt;pMod-&gt;pszName, iRet);
714 			}
715 		} else {
716 			node-&gt;canRun = 0;
717 		}
718 		node = module.GetNxtCnfType(runConf, node, eMOD_IN);
719 	}
720 	return RS_RET_OK; }
721 static rsRetVal
722 loadMainQueue(void)
723 {
724 	DEFiRet;
725 	struct cnfobj *mainqCnfObj;
726 	mainqCnfObj = glbl.GetmainqCnfObj();
727 	DBGPRINTF("loadMainQueue: mainq cnf obj ptr is %p\n", mainqCnfObj);
728 	iRet = createMainQueue(&amp;loadConf-&gt;pMsgQueue, UCHAR_CONSTANT("main Q"),
729 		    		(mainqCnfObj == NULL) ? NULL : mainqCnfObj-&gt;nvlst);
730 	if (iRet == RS_RET_OK) {
731 		if (runConf != NULL) { 			int areEqual = queuesEqual(loadConf-&gt;pMsgQueue, runConf-&gt;pMsgQueue);
732 			DBGPRINTF("Comparison of old and new main queues: %d\n", areEqual);
733 			if (areEqual) { 				qqueueDestruct(&amp;loadConf-&gt;pMsgQueue);
734 				loadConf-&gt;pMsgQueue = runConf-&gt;pMsgQueue;
735 			}
736 		}
737 	}
738 	if(iRet != RS_RET_OK) {
739 		fprintf(stderr, "fatal error %d: could not create message queue - rsyslogd can not run!\n", iRet);
740 		FINALIZE;
741 	}
742 finalize_it:
743 	glblDestructMainqCnfObj();
744 	RETiRet;
745 }
746 static rsRetVal
747 activateMainQueue(void)
748 {
749 	DEFiRet;
750 	DBGPRINTF("activateMainQueue: will try to activate main queue %p\n", runConf-&gt;pMsgQueue);
751 	iRet = startMainQueue(runConf, runConf-&gt;pMsgQueue);
752 	if(iRet != RS_RET_OK) {
753 		fprintf(stderr, "fatal error %d: could not create message queue - rsyslogd can not run!\n", iRet);
754 		FINALIZE;
755 	}
756 	if(runConf-&gt;globals.mainQ.MainMsgQueType == QUEUETYPE_DIRECT) {
757 		PREFER_STORE_0_TO_INT(&amp;bHaveMainQueue);
758 	} else {
759 		PREFER_STORE_1_TO_INT(&amp;bHaveMainQueue);
760 	}
761 	DBGPRINTF("Main processing queue is initialized and running\n");
762 finalize_it:
763 	RETiRet;
764 }
765 static inline rsRetVal
766 setUmask(int iUmask)
767 {
768 	if(iUmask != -1) {
769 		umask(iUmask);
770 		DBGPRINTF("umask set to 0%3.3o.\n", iUmask);
771 	}
772 	return RS_RET_OK;
773 }
774 static void
775 cleanupOldCnf(rsconf_t *cnf)
776 {
777 	if (cnf == NULL)
778 		FINALIZE;
779 	if (runConf-&gt;pMsgQueue != cnf-&gt;pMsgQueue)
780 		qqueueDestruct(&amp;cnf-&gt;pMsgQueue);
781 finalize_it:
782 	return;
783 }
784 static rsRetVal
785 activate(rsconf_t *cnf)
786 {
787 	DEFiRet;
788 	rsconf_t *runCnfOld = runConf;
789 	runConf = cnf;
790 	loadConf = NULL;
791 #	if	0 	if(ourConf-&gt;globals.pszConfDAGFile != NULL)
792 		generateConfigDAG(ourConf-&gt;globals.pszConfDAGFile);
793 #	endif
794 	setUmask(cnf-&gt;globals.umask);
795 	tellModulesActivateConfigPrePrivDrop();
796 	CHKiRet(dropPrivileges(cnf));
797 	tellModulesActivateConfig();
798 	startInputModules();
799 	CHKiRet(activateActions());
800 	CHKiRet(activateRulesetQueues());
801 	CHKiRet(activateMainQueue());
802 	runInputModules();
803 	qqueueDoneLoadCnf(); 
804 	dbgprintf("configuration %p activated\n", cnf);
805 	cleanupOldCnf(runCnfOld);
806 finalize_it:
807 	RETiRet;
808 }
809 static rsRetVal setActionResumeInterval(void __attribute__((unused)) *pVal, int iNewVal)
810 {
811 	return actionSetGlobalResumeInterval(iNewVal);
812 }
813 static rsRetVal
814 setDefaultRuleset(void __attribute__((unused)) *pVal, uchar *pszName)
815 {
816 	DEFiRet;
817 	CHKiRet(ruleset.SetDefaultRuleset(ourConf, pszName));
818 finalize_it:
819 	free(pszName); 	RETiRet;
820 }
821 static rsRetVal
822 setCurrRuleset(void __attribute__((unused)) *pVal, uchar *pszName)
823 {
824 	ruleset_t *pRuleset;
825 	rsRetVal localRet;
826 	DEFiRet;
827 	localRet = ruleset.SetCurrRuleset(ourConf, pszName);
828 	if(localRet == RS_RET_NOT_FOUND) {
829 		DBGPRINTF("begin new current rule set '%s'\n", pszName);
830 		CHKiRet(ruleset.Construct(&amp;pRuleset));
831 		CHKiRet(ruleset.SetName(pRuleset, pszName));
832 		CHKiRet(ruleset.ConstructFinalize(ourConf, pRuleset));
833 		rulesetSetCurrRulesetPtr(pRuleset);
834 	} else {
835 		ABORT_FINALIZE(localRet);
836 	}
837 finalize_it:
838 	free(pszName); 	RETiRet;
839 }
840 static rsRetVal setMainMsgQueType(void __attribute__((unused)) *pVal, uchar *pszType)
841 {
842 	DEFiRet;
843 	if (!strcasecmp((char *) pszType, "fixedarray")) {
844 		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
845 		DBGPRINTF("main message queue type set to FIXED_ARRAY\n");
846 	} else if (!strcasecmp((char *) pszType, "linkedlist")) {
847 		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_LINKEDLIST;
848 		DBGPRINTF("main message queue type set to LINKEDLIST\n");
849 	} else if (!strcasecmp((char *) pszType, "disk")) {
850 		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_DISK;
851 		DBGPRINTF("main message queue type set to DISK\n");
852 	} else if (!strcasecmp((char *) pszType, "direct")) {
853 		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_DIRECT;
854 		DBGPRINTF("main message queue type set to DIRECT (no queueing at all)\n");
855 	} else {
856 		LogError(0, RS_RET_INVALID_PARAMS, "unknown mainmessagequeuetype parameter: %s",
857 			(char *) pszType);
858 		iRet = RS_RET_INVALID_PARAMS;
859 	}
860 	free(pszType); 
861 	RETiRet;
862 }
863 static rsRetVal setMaxFiles(void __attribute__((unused)) *pVal, int iFiles)
864 {
865 	struct rlimit maxFiles;
866 	char errStr[1024];
867 	DEFiRet;
868 	maxFiles.rlim_cur = iFiles;
869 	maxFiles.rlim_max = iFiles;
870 	if(setrlimit(RLIMIT_NOFILE, &amp;maxFiles) &lt; 0) {
871 		rs_strerror_r(errno, errStr, sizeof(errStr));
872 		LogError(0, RS_RET_ERR_RLIM_NOFILE, "could not set process file limit to %d: %s "
873 			"[kernel max %ld]", iFiles, errStr, (long) maxFiles.rlim_max);
874 		ABORT_FINALIZE(RS_RET_ERR_RLIM_NOFILE);
875 	}
876 #ifdef USE_UNLIMITED_SELECT
877 	glbl.SetFdSetSize(howmany(iFiles, __NFDBITS) * sizeof (fd_mask));
878 #endif
879 	DBGPRINTF("Max number of files set to %d [kernel max %ld].\n", iFiles, (long) maxFiles.rlim_max);
880 finalize_it:
881 	RETiRet;
882 }
883 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
884 {
885 	free(loadConf-&gt;globals.mainQ.pszMainMsgQFName);
886 	cnfSetDefaults(loadConf);
887 	return RS_RET_OK;
888 }
889 static rsRetVal
890 setModDir(void __attribute__((unused)) *pVal, uchar* pszNewVal)
891 {
892 	DEFiRet;
893 	iRet = module.SetModDir(pszNewVal);
894 	free(pszNewVal);
895 	RETiRet;
896 }
897 static rsRetVal
898 regBuildInModule(rsRetVal (*modInit)(), uchar *name, void *pModHdlr)
899 {
900 	cfgmodules_etry_t *pNew;
901 	cfgmodules_etry_t *pLast;
902 	modInfo_t *pMod;
903 	DEFiRet;
904 	CHKiRet(module.doModInit(modInit, name, pModHdlr, &amp;pMod));
905 	readyModForCnf(pMod, &amp;pNew, &amp;pLast);
906 	addModToCnfList(&amp;pNew, pLast);
907 finalize_it:
908 	RETiRet;
909 }
910 static rsRetVal
911 loadBuildInModules(void)
912 {
913 	DEFiRet;
914 	CHKiRet(regBuildInModule(modInitFile, UCHAR_CONSTANT("builtin:omfile"), NULL));
915 	CHKiRet(regBuildInModule(modInitPipe, UCHAR_CONSTANT("builtin:ompipe"), NULL));
916 	CHKiRet(regBuildInModule(modInitShell, UCHAR_CONSTANT("builtin-shell"), NULL));
917 	CHKiRet(regBuildInModule(modInitDiscard, UCHAR_CONSTANT("builtin:omdiscard"), NULL));
918 #	ifdef SYSLOG_INET
919 	CHKiRet(regBuildInModule(modInitFwd, UCHAR_CONSTANT("builtin:omfwd"), NULL));
920 #	endif
921 	CHKiRet(regBuildInModule(modInitUsrMsg, (uchar*) "builtin:omusrmsg", NULL));
922 	CHKiRet(regBuildInModule(modInitpmrfc5424, UCHAR_CONSTANT("builtin:pmrfc5424"), NULL));
923 	CHKiRet(regBuildInModule(modInitpmrfc3164, UCHAR_CONSTANT("builtin:pmrfc3164"), NULL));
924 	CHKiRet(parser.AddDfltParser(UCHAR_CONSTANT("rsyslog.rfc5424")));
925 	CHKiRet(parser.AddDfltParser(UCHAR_CONSTANT("rsyslog.rfc3164")));
926 	CHKiRet(regBuildInModule(modInitsmfile, UCHAR_CONSTANT("builtin:smfile"), NULL));
927 	CHKiRet(regBuildInModule(modInitsmtradfile, UCHAR_CONSTANT("builtin:smtradfile"), NULL));
928 	CHKiRet(regBuildInModule(modInitsmfwd, UCHAR_CONSTANT("builtin:smfwd"), NULL));
929 	CHKiRet(regBuildInModule(modInitsmtradfwd, UCHAR_CONSTANT("builtin:smtradfwd"), NULL));
930 finalize_it:
931 	if(iRet != RS_RET_OK) {
932 		fprintf(stderr, "fatal error: could not activate built-in modules. Error code %d.\n",
933 			iRet);
934 	}
935 	RETiRet;
936 }
937 static rsRetVal
938 initLegacyConf(void)
939 {
940 	DEFiRet;
941 	uchar *pTmp;
942 	ruleset_t *pRuleset;
943 	DBGPRINTF("doing legacy config system init\n");
944 	ruleset.Construct(&amp;pRuleset);
945 	ruleset.SetName(pRuleset, UCHAR_CONSTANT("RSYSLOG_DefaultRuleset"));
946 	ruleset.ConstructFinalize(loadConf, pRuleset);
947 	rulesetSetCurrRulesetPtr(pRuleset);
948 	CHKiRet(regCfSysLineHdlr((uchar *)"sleep", 0, eCmdHdlrGoneAway,
949 		NULL, NULL, NULL));
950 	CHKiRet(regCfSysLineHdlr((uchar *)"logrsyslogstatusmessages", 0, eCmdHdlrBinary,
951 		NULL, &amp;loadConf-&gt;globals.bLogStatusMsgs, NULL));
952 	CHKiRet(regCfSysLineHdlr((uchar *)"errormessagestostderr", 0, eCmdHdlrBinary,
953 		NULL, &amp;loadConf-&gt;globals.bErrMsgToStderr, NULL));
954 	CHKiRet(regCfSysLineHdlr((uchar *)"abortonuncleanconfig", 0, eCmdHdlrBinary,
955 		NULL, &amp;loadConf-&gt;globals.bAbortOnUncleanConfig, NULL));
956 	CHKiRet(regCfSysLineHdlr((uchar *)"repeatedmsgreduction", 0, eCmdHdlrBinary,
957 		NULL, &amp;loadConf-&gt;globals.bReduceRepeatMsgs, NULL));
958 	CHKiRet(regCfSysLineHdlr((uchar *)"debugprinttemplatelist", 0, eCmdHdlrBinary,
959 		NULL, &amp;(loadConf-&gt;globals.bDebugPrintTemplateList), NULL));
960 	CHKiRet(regCfSysLineHdlr((uchar *)"debugprintmodulelist", 0, eCmdHdlrBinary,
961 		NULL, &amp;(loadConf-&gt;globals.bDebugPrintModuleList), NULL));
962 	CHKiRet(regCfSysLineHdlr((uchar *)"debugprintcfsyslinehandlerlist", 0, eCmdHdlrBinary,
963 		 NULL, &amp;(loadConf-&gt;globals.bDebugPrintCfSysLineHandlerList), NULL));
964 	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptouser", 0, eCmdHdlrUID,
965 		NULL, &amp;loadConf-&gt;globals.uidDropPriv, NULL));
966 	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptouserid", 0, eCmdHdlrInt,
967 		NULL, &amp;loadConf-&gt;globals.uidDropPriv, NULL));
968 	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptogroup", 0, eCmdHdlrGID,
969 		NULL, &amp;loadConf-&gt;globals.gidDropPriv, NULL));
970 	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptogroupid", 0, eCmdHdlrInt,
971 		NULL, &amp;loadConf-&gt;globals.gidDropPriv, NULL));
972 	CHKiRet(regCfSysLineHdlr((uchar *)"generateconfiggraph", 0, eCmdHdlrGetWord,
973 		NULL, &amp;loadConf-&gt;globals.pszConfDAGFile, NULL));
974 	CHKiRet(regCfSysLineHdlr((uchar *)"umask", 0, eCmdHdlrFileCreateMode,
975 		NULL, &amp;loadConf-&gt;globals.umask, NULL));
976 	CHKiRet(regCfSysLineHdlr((uchar *)"maxopenfiles", 0, eCmdHdlrInt,
977 		setMaxFiles, NULL, NULL));
978 	CHKiRet(regCfSysLineHdlr((uchar *)"actionresumeinterval", 0, eCmdHdlrInt,
979 		setActionResumeInterval, NULL, NULL));
980 	CHKiRet(regCfSysLineHdlr((uchar *)"modload", 0, eCmdHdlrCustomHandler,
981 		conf.doModLoad, NULL, NULL));
982 	CHKiRet(regCfSysLineHdlr((uchar *)"defaultruleset", 0, eCmdHdlrGetWord,
983 		setDefaultRuleset, NULL, NULL));
984 	CHKiRet(regCfSysLineHdlr((uchar *)"ruleset", 0, eCmdHdlrGetWord,
985 		setCurrRuleset, NULL, NULL));
986 	CHKiRet(regCfSysLineHdlr((uchar *)"template", 0, eCmdHdlrCustomHandler,
987 		conf.doNameLine, (void*)DIR_TEMPLATE, NULL));
988 	CHKiRet(regCfSysLineHdlr((uchar *)"outchannel", 0, eCmdHdlrCustomHandler,
989 		conf.doNameLine, (void*)DIR_OUTCHANNEL, NULL));
990 	CHKiRet(regCfSysLineHdlr((uchar *)"allowedsender", 0, eCmdHdlrCustomHandler,
991 		conf.doNameLine, (void*)DIR_ALLOWEDSENDER, NULL));
992 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuefilename", 0, eCmdHdlrGetWord,
993 		NULL, &amp;loadConf-&gt;globals.mainQ.pszMainMsgQFName, NULL));
994 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuesize", 0, eCmdHdlrInt,
995 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueSize, NULL));
996 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuehighwatermark", 0, eCmdHdlrInt,
997 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQHighWtrMark, NULL));
998 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuelowwatermark", 0, eCmdHdlrInt,
999 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQLowWtrMark, NULL));
1000 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuediscardmark", 0, eCmdHdlrInt,
1001 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQDiscardMark, NULL));
1002 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuediscardseverity", 0, eCmdHdlrSeverity,
1003 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQDiscardSeverity, NULL));
1004 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuecheckpointinterval", 0, eCmdHdlrInt,
1005 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQPersistUpdCnt, NULL));
1006 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuesyncqueuefiles", 0, eCmdHdlrBinary,
1007 		NULL, &amp;loadConf-&gt;globals.mainQ.bMainMsgQSyncQeueFiles, NULL));
1008 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetype", 0, eCmdHdlrGetWord,
1009 		setMainMsgQueType, NULL, NULL));
1010 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueueworkerthreads", 0, eCmdHdlrInt,
1011 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueNumWorkers, NULL));
1012 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetimeoutshutdown", 0, eCmdHdlrInt,
1013 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoQShutdown, NULL));
1014 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetimeoutactioncompletion", 0, eCmdHdlrInt,
1015 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoActShutdown, NULL));
1016 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetimeoutenqueue", 0, eCmdHdlrInt,
1017 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoEnq, NULL));
1018 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueueworkertimeoutthreadshutdown", 0, eCmdHdlrInt,
1019 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoWrkShutdown, NULL));
1020 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeueslowdown", 0, eCmdHdlrInt,
1021 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQDeqSlowdown, NULL));
1022 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueueworkerthreadminimummessages", 0, eCmdHdlrInt,
1023 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQWrkMinMsgs, NULL));
1024 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuemaxfilesize", 0, eCmdHdlrSize,
1025 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueMaxFileSize, NULL));
1026 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeuebatchsize", 0, eCmdHdlrSize,
1027 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueDeqBatchSize, NULL));
1028 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuemaxdiskspace", 0, eCmdHdlrSize,
1029 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueMaxDiskSpace, NULL));
1030 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuesaveonshutdown", 0, eCmdHdlrBinary,
1031 		NULL, &amp;loadConf-&gt;globals.mainQ.bMainMsgQSaveOnShutdown, NULL));
1032 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeuetimebegin", 0, eCmdHdlrInt,
1033 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueDeqtWinFromHr, NULL));
1034 	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeuetimeend", 0, eCmdHdlrInt,
1035 		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueDeqtWinToHr, NULL));
1036 	CHKiRet(regCfSysLineHdlr((uchar *)"moddir", 0, eCmdHdlrGetWord,
1037 		setModDir, NULL, NULL));
1038 <a name="1"></a>
1039 	CHKiRet(regCfSysLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
1040 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		resetConfigVariables, NULL, NULL));
1041 	pTmp = template_DebugFormat;
1042 	tplAddLine(ourConf, "RSYSLOG_DebugFormat", &amp;pTmp);
1043 	pTmp = template_SyslogProtocol23Format;
1044 	tplAddLine(ourConf, "RSYSLOG_SyslogProtocol23Format", &amp;pTmp);
1045 	pTmp = template_SyslogRFC5424Format;
1046 	tplAddLine(ourConf, "RSYSLOG_SyslogRFC5424Format", &amp;pTmp);
1047 	pTmp = template_FileFormat; 	tplAddLine(ourConf, "RSYSLOG_FileFormat", &amp;pTmp);
1048 	pTmp = template_TraditionalFileFormat;
1049 	tplAddLine(ourConf, "RSYSLOG_TraditionalFileFormat", &amp;pTmp);
1050 	pTmp = template_WallFmt;
1051 	tplAddLine(ourConf, " WallFmt", &amp;pTmp);
1052 	pTmp = template_ForwardFormat;
1053 	tplAddLine(ourConf, "RSYSLOG_ForwardFormat", &amp;pTmp);
1054 	pTmp = template_TraditionalForwardFormat;
1055 	tplAddLine(ourConf, "RSYSLOG_TraditionalForwardFormat", &amp;pTmp);
1056 	pTmp = template_StdUsrMsgFmt;
1057 	tplAddLine(ourConf, " StdUsrMsgFmt", &amp;pTmp);
1058 	pTmp = template_StdDBFmt;
1059 	tplAddLine(ourConf, " StdDBFmt", &amp;pTmp);
1060 	pTmp = template_SysklogdFileFormat;
1061 	tplAddLine(ourConf, "RSYSLOG_SysklogdFileFormat", &amp;pTmp);
1062 	pTmp = template_StdPgSQLFmt;
1063 	tplAddLine(ourConf, " StdPgSQLFmt", &amp;pTmp);
1064 	pTmp = template_StdJSONFmt;
1065 	tplAddLine(ourConf, " StdJSONFmt", &amp;pTmp);
1066 	pTmp = template_FullJSONFmt;
1067 	tplAddLine(ourConf, " FullJSONFmt", &amp;pTmp);
1068 	pTmp = template_StdClickHouseFmt;
1069 	tplAddLine(ourConf, " StdClickHouseFmt", &amp;pTmp);
1070 	pTmp = template_spoofadr;</b></font>
1071 	tplLastStaticInit(ourConf, tplAddLine(ourConf, "RSYSLOG_omudpspoofDfltSourceTpl", &amp;pTmp));
1072 finalize_it:
1073 	RETiRet;
1074 }
1075 static rsRetVal
1076 validateConf(rsconf_t *cnf)
1077 {
1078 	DEFiRet;
1079 	if(cnf-&gt;globals.mainQ.iMainMsgQueueNumWorkers &lt; 1) {
1080 		LogError(0, NO_ERRCODE, "$MainMsgQueueNumWorkers must be at least 1! Set to 1.\n");
1081 		cnf-&gt;globals.mainQ.iMainMsgQueueNumWorkers = 1;
1082 	}
1083 	if(cnf-&gt;globals.mainQ.MainMsgQueType == QUEUETYPE_DISK) {
1084 		errno = 0;			if(glbl.GetWorkDir(cnf) == NULL) {
1085 			LogError(0, NO_ERRCODE, "No $WorkDirectory specified - can not run main "
1086 					"message queue in 'disk' mode. Using 'FixedArray' instead.\n");
1087 			cnf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
1088 		}
1089 		if(cnf-&gt;globals.mainQ.pszMainMsgQFName == NULL) {
1090 			LogError(0, NO_ERRCODE, "No $MainMsgQueueFileName specified - can not run main "
1091 				"message queue in 'disk' mode. Using 'FixedArray' instead.\n");
1092 			cnf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
1093 		}
1094 	}
1095 	RETiRet;
1096 }
1097 static rsRetVal
1098 load(rsconf_t **cnf, uchar *confFile)
1099 {
1100 	int iNbrActions = 0;
1101 	int r;
1102 	rsRetVal delayed_iRet = RS_RET_OK;
1103 	DEFiRet;
1104 	CHKiRet(rsconfConstruct(&amp;loadConf));
1105 	ourConf = loadConf; 
1106 	CHKiRet(loadBuildInModules());
1107 	CHKiRet(initLegacyConf());
1108 	r = cnfSetLexFile((char*)confFile);
1109 	if(r == 0) {
1110 		r = yyparse();
1111 		conf.GetNbrActActions(loadConf, &amp;iNbrActions);
1112 	}
1113 	rulesetOptimizeAll(loadConf);
1114 	if(r == 1) {
1115 		LogError(0, RS_RET_CONF_PARSE_ERROR, "could not interpret master "
1116 			"config file '%s'.", confFile);
1117 		delayed_iRet = RS_RET_CONF_PARSE_ERROR;
1118 	} else if(r == 2) { 		LogError(errno, RS_RET_CONF_FILE_NOT_FOUND, "could not open config file '%s'",
1119 		        confFile);
1120 		ABORT_FINALIZE(RS_RET_CONF_FILE_NOT_FOUND);
1121 	} else if(    (iNbrActions == 0)
1122 		  &amp;&amp; !(iConfigVerify &amp; CONF_VERIFY_PARTIAL_CONF)) {
1123 		LogError(0, RS_RET_NO_ACTIONS, "there are no active actions configured. "
1124 			"Inputs would run, but no output whatsoever were created.");
1125 		ABORT_FINALIZE(RS_RET_NO_ACTIONS);
1126 	}
1127 	tellLexEndParsing();
1128 	DBGPRINTF("Number of actions in this configuration: %d\n", loadConf-&gt;actions.iActionNbr);
1129 	CHKiRet(tellCoreConfigLoadDone());
1130 	tellModulesConfigLoadDone();
1131 	tellModulesCheckConfig();
1132 	CHKiRet(validateConf(loadConf));
1133 	CHKiRet(loadMainQueue());
1134 	if(iConfigVerify) {
1135 		if(iRet == RS_RET_OK)
1136 			iRet = RS_RET_VALIDATION_RUN;
1137 		FINALIZE;
1138 	}
1139 	*cnf = loadConf;
1140 	dbgprintf("rsyslog finished loading master config %p\n", loadConf);
1141 	rsconfDebugPrint(loadConf);
1142 finalize_it:
1143 	if(iRet == RS_RET_OK &amp;&amp; delayed_iRet != RS_RET_OK) {
1144 		iRet = delayed_iRet;
1145 	}
1146 	RETiRet;
1147 }
1148 BEGINobjQueryInterface(rsconf)
1149 CODESTARTobjQueryInterface(rsconf)
1150 	if(pIf-&gt;ifVersion != rsconfCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
1151 	}
1152 	pIf-&gt;Destruct = rsconfDestruct;
1153 	pIf-&gt;DebugPrint = rsconfDebugPrint;
1154 	pIf-&gt;Load = load;
1155 	pIf-&gt;Activate = activate;
1156 finalize_it:
1157 ENDobjQueryInterface(rsconf)
1158 BEGINObjClassInit(rsconf, 1, OBJ_IS_CORE_MODULE) 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
1159 	CHKiRet(objUse(module, CORE_COMPONENT));
1160 	CHKiRet(objUse(conf, CORE_COMPONENT));
1161 	CHKiRet(objUse(glbl, CORE_COMPONENT));
1162 	CHKiRet(objUse(datetime, CORE_COMPONENT));
1163 	CHKiRet(objUse(parser, CORE_COMPONENT));
1164 	OBJSetMethodHandler(objMethod_DEBUGPRINT, rsconfDebugPrint);
1165 	OBJSetMethodHandler(objMethod_CONSTRUCTION_FINALIZER, rsconfConstructFinalize);
1166 ENDObjClassInit(rsconf)
1167 BEGINObjClassExit(rsconf, OBJ_IS_CORE_MODULE) 	objRelease(ruleset, CORE_COMPONENT);
1168 	objRelease(module, CORE_COMPONENT);
1169 	objRelease(conf, CORE_COMPONENT);
1170 	objRelease(glbl, CORE_COMPONENT);
1171 	objRelease(datetime, CORE_COMPONENT);
1172 	objRelease(parser, CORE_COMPONENT);
1173 ENDObjClassExit(rsconf)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
