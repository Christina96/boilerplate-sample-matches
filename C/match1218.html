<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for datetime.c &amp; rsconf.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for datetime.c &amp; rsconf.c
      </h3>
<h1 align="center">
        8.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>datetime.c (8.434959%)<th>rsconf.c (8.867521%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(877-898)<td><a href="#" name="0">(205-229)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(959-983)<td><a href="#" name="1">(1388-1421)</a><td align="center"><font color="#da0000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(851-867)<td><a href="#" name="2">(187-202)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1257-1274)<td><a href="#" name="3">(247-261)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1005-1011)<td><a href="#" name="4">(161-173)</a><td align="center"><font color="#9d0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>datetime.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* The datetime object. It contains date and time related functions.
 *
 * Module begun 2008-03-05 by Rainer Gerhards, based on some code
 * from syslogd.c. The main intension was to move code out of syslogd.c
 * in a useful manner. It is still undecided if all functions will continue
 * to stay here or some will be moved into parser modules (once we have them).
 *
 * Copyright 2008-2016 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#ifdef HAVE_SYS_TIME_H
#	include &lt;sys/time.h&gt;
#endif

#include "rsyslog.h"
#include "obj.h"
#include "modules.h"
#include "datetime.h"
#include "srUtils.h"
#include "stringbuf.h"
#include "errmsg.h"
#include "rsconf.h"
#include "timezones.h"

/* static data */
DEFobjStaticHelpers

/* the following table of ten powers saves us some computation */
static const int tenPowers[6] = { 1, 10, 100, 1000, 10000, 100000 };

/* the following table saves us from computing an additional date to get
 * the ordinal day of the year - at least from 1967-2099
 * Note: non-2038+ compliant systems (Solaris) will generate compiler
 * warnings on the post 2038-rollover years.
 */
static const int yearInSec_startYear = 1967;
/* for x in $(seq 1967 2099) ; do
 *   printf %s', ' $(date --date="Dec 31 ${x} UTC 23:59:59" +%s)
 * done |fold -w 70 -s */
static const long long yearInSecs[] = {
	-63158401, -31536001, -1, 31535999, 63071999, 94694399, 126230399,
	157766399, 189302399, 220924799, 252460799, 283996799, 315532799,
	347155199, 378691199, 410227199, 441763199, 473385599, 504921599,
	536457599, 567993599, 599615999, 631151999, 662687999, 694223999,
	725846399, 757382399, 788918399, 820454399, 852076799, 883612799,
	915148799, 946684799, 978307199, 1009843199, 1041379199, 1072915199,
	1104537599, 1136073599, 1167609599, 1199145599, 1230767999,
	1262303999, 1293839999, 1325375999, 1356998399, 1388534399,
	1420070399, 1451606399, 1483228799, 1514764799, 1546300799,
	1577836799, 1609459199, 1640995199, 1672531199, 1704067199,
	1735689599, 1767225599, 1798761599, 1830297599, 1861919999,
	1893455999, 1924991999, 1956527999, 1988150399, 2019686399,
	2051222399, 2082758399, 2114380799, 2145916799, 2177452799,
	2208988799, 2240611199, 2272147199, 2303683199, 2335219199,
	2366841599, 2398377599, 2429913599, 2461449599, 2493071999,
	2524607999, 2556143999, 2587679999, 2619302399, 2650838399,
	2682374399, 2713910399, 2745532799, 2777068799, 2808604799,
	2840140799, 2871763199, 2903299199, 2934835199, 2966371199,
	2997993599, 3029529599, 3061065599, 3092601599, 3124223999,
	3155759999, 3187295999, 3218831999, 3250454399, 3281990399,
	3313526399, 3345062399, 3376684799, 3408220799, 3439756799,
	3471292799, 3502915199, 3534451199, 3565987199, 3597523199,
	3629145599, 3660681599, 3692217599, 3723753599, 3755375999,
	3786911999, 3818447999, 3849983999, 3881606399, 3913142399,
	3944678399, 3976214399, 4007836799, 4039372799, 4070908799,
	4102444799};

/* note ramge is 1969 -&gt; 2100 because it needs to access previous/next year */
/* for x in $(seq 1969 2100) ; do
 *   printf %s', ' $(date --date="Dec 28 ${x} UTC 12:00:00" +%V)
 * done | fold -w 70 -s */
static const int weeksInYear[] = {
	52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52,
	52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52,
	52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52,
	53, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 53, 52,
};

static const char* monthNames[12] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

/* ------------------------------ methods ------------------------------ */


/**
 * Convert struct timeval to syslog_time
 */
static void
timeval2syslogTime(struct timeval *tp, struct syslogTime *t, const int inUTC)
{
	struct tm *tm;
	struct tm tmBuf;
	long lBias;
	time_t secs;

#if defined(__hpux)
	struct timezone tz;
#	endif
	secs = tp-&gt;tv_sec;
	if(inUTC)
		tm = gmtime_r(&amp;secs, &amp;tmBuf);
	else
		tm = localtime_r(&amp;secs, &amp;tmBuf);

	t-&gt;year = tm-&gt;tm_year + 1900;
	t-&gt;month = tm-&gt;tm_mon + 1;
	t-&gt;day = tm-&gt;tm_mday;
	t-&gt;wday = tm-&gt;tm_wday;
	t-&gt;hour = tm-&gt;tm_hour;
	t-&gt;minute = tm-&gt;tm_min;
	t-&gt;second = tm-&gt;tm_sec;
	t-&gt;secfrac = tp-&gt;tv_usec;
	t-&gt;secfracPrecision = 6;

	if(inUTC) {
		t-&gt;OffsetMode = '+';
		lBias = 0;
	} else {
#		if defined(__sun)
			/* Solaris uses a different method of exporting the time zone.
			 * It is UTC - localtime, which is the opposite sign of mins east of GMT.
			 */
			lBias = -(tm-&gt;tm_isdst ? altzone : timezone);
#		elif defined(__hpux)
			lBias = tz.tz_dsttime ? - tz.tz_minuteswest : 0;
#		elif defined(_AIX)
			/* AIXPORT : IBM documentation notice that 'extern long timezone'
			 * is setted after calling tzset.
			 * Recent version of AIX, localtime_r call inside tzset.
			 */
			if (tm-&gt;tm_isdst) tzset();
			lBias = - timezone;
#		else
			lBias = tm-&gt;tm_gmtoff;
#		endif
		if(lBias &lt; 0) {
			t-&gt;OffsetMode = '-';
			lBias *= -1;
		} else
			t-&gt;OffsetMode = '+';
	}
	t-&gt;OffsetHour = lBias / 3600;
	t-&gt;OffsetMinute = (lBias % 3600) / 60;
	t-&gt;timeType = TIME_TYPE_RFC5424; /* we have a high precision timestamp */
	t-&gt;inUTC = inUTC;
}

/**
 * Get the current date/time in the best resolution the operating
 * system has to offer (well, actually at most down to the milli-
 * second level.
 *
 * The date and time is returned in separate fields as this is
 * most portable and removes the need for additional structures
 * (but I have to admit it is somewhat "bulky";)).
 *
 * Obviously, *t must not be NULL...
 *
 * rgerhards, 2008-10-07: added ttSeconds to provide a way to
 * obtain the second-resolution UNIX timestamp. This is needed
 * in some situations to minimize time() calls (namely when doing
 * output processing). This can be left NULL if not needed.
 */
static void getCurrTime(struct syslogTime *t, time_t *ttSeconds, const int inUTC)
{
	struct timeval tp;
/* AIXPORT : fix build error : "tm_gmtoff" is not a member of "struct tm"
 *           Choose the HPUX code path, only for this function.
 *           This is achieved by adding a check to _AIX wherever _hpux is checked
 */


#if defined(__hpux) || defined(_AIX)
	struct timezone tz;
#	endif

	assert(t != NULL);
#if defined(__hpux) || defined(_AIX)
		/* TODO: check this: under HP UX, the tz information is actually valid
		 * data. So we need to obtain and process it there.
		 */
		gettimeofday(&amp;tp, &amp;tz);
#	else
		gettimeofday(&amp;tp, NULL);
#	endif
	if(ttSeconds != NULL)
		*ttSeconds = tp.tv_sec;

	timeval2syslogTime(&amp;tp, t, inUTC);
}


/* A fast alternative to getCurrTime() and time() that only obtains
 * a timestamp like time() does. I was told that gettimeofday(), at
 * least under Linux, is much faster than time() and I could confirm
 * this testing. So I created that function as a replacement.
 * rgerhards, 2009-11-12
 */
time_t
getTime(time_t *ttSeconds)
{
	struct timeval tp;

	if(gettimeofday(&amp;tp, NULL) == -1)
		return -1;

	if(ttSeconds != NULL)
		*ttSeconds = tp.tv_sec;
	return tp.tv_sec;
}

dateTimeFormat_t getDateTimeFormatFromStr(const char * const __restrict__ s) {
	assert(s != NULL);

	if (strcmp(s, "date-rfc3164") == 0)
		return DATE_RFC3164;
	if (strcmp(s, "date-rfc3339") == 0)
		return DATE_RFC3339;
	if (strcmp(s, "date-unix") == 0)
		return DATE_UNIX;

	return DATE_INVALID;
}

/*******************************************************************
 * BEGIN CODE-LIBLOGGING                                           *
 *******************************************************************
 * Code in this section is borrowed from liblogging. This is an
 * interim solution. Once liblogging is fully integrated, this is
 * to be removed (see http://www.monitorware.com/liblogging for
 * more details. 2004-11-16 rgerhards
 *
 * Please note that the orginal liblogging code is modified so that
 * it fits into the context of the current version of syslogd.c.
 *
 * DO NOT PUT ANY OTHER CODE IN THIS BEGIN ... END BLOCK!!!!
 */


/**
 * Parse a 32 bit integer number from a string. We do not permit
 * integer overruns, this the guard against INT_MAX.
 *
 * \param ppsz Pointer to the Pointer to the string being parsed. It
 *             must be positioned at the first digit. Will be updated
 *             so that on return it points to the first character AFTER
 *             the integer parsed.
 * \param pLenStr pointer to string length, decremented on exit by
 *                characters processed
 * 		  Note that if an empty string (len &lt; 1) is passed in,
 * 		  the method always returns zero.
 * \retval The number parsed.
 */
static int
srSLMGParseInt32(uchar** ppsz, int *pLenStr)
{
	register int i;

	i = 0;
	while(*pLenStr &gt; 0 &amp;&amp; **ppsz &gt;= '0' &amp;&amp; **ppsz &lt;= '9' &amp;&amp; i &lt; INT_MAX/10-1) {
		i = i * 10 + **ppsz - '0';
		++(*ppsz);
		--(*pLenStr);
	}

	return i;
}


/**
 * Parse a TIMESTAMP-3339.
 * updates the parse pointer position. The pTime parameter
 * is guranteed to be updated only if a new valid timestamp
 * could be obtained (restriction added 2008-09-16 by rgerhards).
 * This method now also checks the maximum string length it is passed.
 * If a *valid* timestamp is found, the string length is decremented
 * by the number of characters processed. If it is not a valid timestamp,
 * the length is kept unmodified. -- rgerhards, 2009-09-23
 */
static rsRetVal
ParseTIMESTAMP3339(struct syslogTime *pTime, uchar** ppszTS, int *pLenStr)
{
	uchar *pszTS = *ppszTS;
	/* variables to temporarily hold time information while we parse */
	int year;
	int month;
	int day;
	int hour; /* 24 hour clock */
	int minute;
	int second;
	int secfrac;	/* fractional seconds (must be 32 bit!) */
	int secfracPrecision;
	char OffsetMode;	/* UTC offset + or - */
	int OffsetHour;	/* UTC offset in hours */
	int OffsetMinute;	/* UTC offset in minutes */
	int lenStr;
	/* end variables to temporarily hold time information while we parse */
	DEFiRet;

	assert(pTime != NULL);
	assert(ppszTS != NULL);
	assert(pszTS != NULL);

	lenStr = *pLenStr;
	year = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);

	/* We take the liberty to accept slightly malformed timestamps e.g. in
	 * the format of 2003-9-1T1:0:0. This doesn't hurt on receiving. Of course,
	 * with the current state of affairs, we would never run into this code
	 * here because at postion 11, there is no "T" in such cases ;)
	 */
	if(lenStr == 0 || *pszTS++ != '-' || year &lt; 0 || year &gt;= 2100) {
		DBGPRINTF("ParseTIMESTAMP3339: invalid year: %d, pszTS: '%c'\n", year, *pszTS);
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	}
	--lenStr;
	month = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(month &lt; 1 || month &gt; 12)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	if(lenStr == 0 || *pszTS++ != '-')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	day = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(day &lt; 1 || day &gt; 31)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	if(lenStr == 0 || *pszTS++ != 'T')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;

	hour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(hour &lt; 0 || hour &gt; 23)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	if(lenStr == 0 || *pszTS++ != ':')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	minute = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(minute &lt; 0 || minute &gt; 59)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	if(lenStr == 0 || *pszTS++ != ':')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	second = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(second &lt; 0 || second &gt; 60)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	/* Now let's see if we have secfrac */
	if(lenStr &gt; 0 &amp;&amp; *pszTS == '.') {
		--lenStr;
		uchar *pszStart = ++pszTS;
		secfrac = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		secfracPrecision = (int) (pszTS - pszStart);
	} else {
		secfracPrecision = 0;
		secfrac = 0;
	}

	/* check the timezone */
	if(lenStr == 0)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	if(*pszTS == 'Z') {
		--lenStr;
		pszTS++; /* eat Z */
		OffsetMode = 'Z';
		OffsetHour = 0;
		OffsetMinute = 0;
	} else if((*pszTS == '+') || (*pszTS == '-')) {
		OffsetMode = *pszTS;
		--lenStr;
		pszTS++;

		OffsetHour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		if(OffsetHour &lt; 0 || OffsetHour &gt; 23)
			ABORT_FINALIZE(RS_RET_INVLD_TIME);

		if(lenStr == 0 || *pszTS != ':')
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		--lenStr;
		pszTS++;
		OffsetMinute = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		if(OffsetMinute &lt; 0 || OffsetMinute &gt; 59)
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
	} else {
		/* there MUST be TZ information */
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	}

	/* OK, we actually have a 3339 timestamp, so let's indicated this */
	if(lenStr &gt; 0) {
		if(*pszTS != ' ') /* if it is not a space, it can not be a "good" time - 2010-02-22 rgerhards */
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		++pszTS; /* just skip past it */
		--lenStr;
	}

	/* we had success, so update parse pointer and caller-provided timestamp */
	*ppszTS = pszTS;
	pTime-&gt;timeType = 2;
	pTime-&gt;year = year;
	pTime-&gt;month = month;
	pTime-&gt;day = day;
	pTime-&gt;hour = hour;
	pTime-&gt;minute = minute;
	pTime-&gt;second = second;
	pTime-&gt;secfrac = secfrac;
	pTime-&gt;secfracPrecision = secfracPrecision;
	pTime-&gt;OffsetMode = OffsetMode;
	pTime-&gt;OffsetHour = OffsetHour;
	pTime-&gt;OffsetMinute = OffsetMinute;
	*pLenStr = lenStr;

finalize_it:
	RETiRet;
}


/**
 * Parse a TIMESTAMP-3164. The pTime parameter
 * is guranteed to be updated only if a new valid timestamp
 * could be obtained (restriction added 2008-09-16 by rgerhards). This
 * also means the caller *must* provide a valid (probably current)
 * timstamp in pTime when calling this function. a 3164 timestamp contains
 * only partial information and only that partial information is updated.
 * So the "output timestamp" is a valid timestamp only if the "input
 * timestamp" was valid, too. The is actually an optimization, as it
 * permits us to use a pre-acquired timestamp and thus avoids to do
 * a (costly) time() call. Thanks to David Lang for insisting on
 * time() call reduction ;).
 * This method now also checks the maximum string length it is passed.
 * If a *valid* timestamp is found, the string length is decremented
 * by the number of characters processed. If it is not a valid timestamp,
 * the length is kept unmodified. -- rgerhards, 2009-09-23
 *
 * We support this format:
 * [yyyy] Mon mm [yyyy] hh:mm:ss[.subsec][ [yyyy ]/[TZSTRING:]]
 * Note that [yyyy] and [.subsec] are non-standard but frequently occur.
 * Also [yyyy] can only occur once -- if it occurs twice, we flag the
 * timestamp as invalid. if bParseTZ is true, we try to obtain a
 * TZSTRING. Note that in this case it MUST be terminated by a colon
 * (Cisco format). This option is a bit dangerous, as it could already
 * by the tag. So it MUST only be enabled in specialised parsers.
 * subsec, [yyyy] in front, TZSTRING was added in 2014-07-08 rgerhards
 * Similarly, we try to detect a year after the timestamp if
 * bDetectYearAfterTime is set. This is mutally exclusive with bParseTZ.
 * Note: bDetectYearAfterTime will misdetect hostnames in the range
 * 2000..2100 as years, so this option should explicitly be turned on
 * and is not meant for general consumption.
 */
static rsRetVal
ParseTIMESTAMP3164(struct syslogTime *pTime, uchar** ppszTS, int *pLenStr,
	const int bParseTZ,
	const int bDetectYearAfterTime)
{
	/* variables to temporarily hold time information while we parse */
	int month;
	int day;
	int year = 0; /* 0 means no year provided */
	int hour; /* 24 hour clock */
	int minute;
	int second;
	int secfrac;	/* fractional seconds (must be 32 bit!) */
	int secfracPrecision;
	char tzstring[16];
	char OffsetMode = '\0';	/* UTC offset: \0 -&gt; indicate no update */
	char OffsetHour = '\0';	/* UTC offset in hours */
	int OffsetMinute = 0;	/* UTC offset in minutes */
	/* end variables to temporarily hold time information while we parse */
	int lenStr;
	uchar *pszTS;
	DEFiRet;

	assert(ppszTS != NULL);
	pszTS = *ppszTS;
	assert(pszTS != NULL);
	assert(pTime != NULL);
	assert(pLenStr != NULL);
	lenStr = *pLenStr;

	if(lenStr &lt; 3)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	/* first check if we have a year in front of the timestamp. some devices (e.g. Brocade)
	 * do this. As it is pretty straightforward to detect and chance of misinterpretation
	 * is low, we try to parse it.
	 */
	if(*pszTS &gt;= '0' &amp;&amp; *pszTS &lt;= '9') {
		/* OK, either we have a prepended year or an invalid format! */
		year = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		if(year &lt; 1970 || year &gt; 2100 || *pszTS != ' ')
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		++pszTS; /* skip SP */
	}

	/* If we look at the month (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec),
	 * we may see the following character sequences occur:
	 *
	 * J(an/u(n/l)), Feb, Ma(r/y), A(pr/ug), Sep, Oct, Nov, Dec
	 *
	 * We will use this for parsing, as it probably is the
	 * fastest way to parse it.
	 *
	 * 2009-08-17: we now do case-insensitive comparisons, as some devices obviously do not
	 * obey to the RFC-specified case. As we need to guess in any case, we can ignore case
	 * in the first place -- rgerhards
	 *
	 * 2005-07-18, well sometimes it pays to be a bit more verbose, even in C...
	 * Fixed a bug that lead to invalid detection of the data. The issue was that
	 * we had an if(++pszTS == 'x') inside of some of the consturcts below. However,
	 * there were also some elseifs (doing the same ++), which than obviously did not
	 * check the orginal character but the next one. Now removed the ++ and put it
	 * into the statements below. Was a really nasty bug... I didn't detect it before
	 * june, when it first manifested. This also lead to invalid parsing of the rest
	 * of the message, as the time stamp was not detected to be correct. - rgerhards
	 */
	switch(*pszTS++)
	{
	case 'j':
	case 'J':
		if(*pszTS == 'a' || *pszTS == 'A') {
			++pszTS;
			if(*pszTS == 'n' || *pszTS == 'N') {
				++pszTS;
				month = 1;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else if(*pszTS == 'u' || *pszTS == 'U') {
			++pszTS;
			if(*pszTS == 'n' || *pszTS == 'N') {
				++pszTS;
				month = 6;
			} else if(*pszTS == 'l' || *pszTS == 'L') {
				++pszTS;
				month = 7;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'f':
	case 'F':
		if(*pszTS == 'e' || *pszTS == 'E') {
			++pszTS;
			if(*pszTS == 'b' || *pszTS == 'B') {
				++pszTS;
				month = 2;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'm':
	case 'M':
		if(*pszTS == 'a' || *pszTS == 'A') {
			++pszTS;
			if(*pszTS == 'r' || *pszTS == 'R') {
				++pszTS;
				month = 3;
			} else if(*pszTS == 'y' || *pszTS == 'Y') {
				++pszTS;
				month = 5;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'a':
	case 'A':
		if(*pszTS == 'p' || *pszTS == 'P') {
			++pszTS;
			if(*pszTS == 'r' || *pszTS == 'R') {
				++pszTS;
				month = 4;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else if(*pszTS == 'u' || *pszTS == 'U') {
			++pszTS;
			if(*pszTS == 'g' || *pszTS == 'G') {
				++pszTS;
				month = 8;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 's':
	case 'S':
		if(*pszTS == 'e' || *pszTS == 'E') {
			++pszTS;
			if(*pszTS == 'p' || *pszTS == 'P') {
				++pszTS;
				month = 9;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'o':
	case 'O':
		if(*pszTS == 'c' || *pszTS == 'C') {
			++pszTS;
			if(*pszTS == 't' || *pszTS == 'T') {
				++pszTS;
				month = 10;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'n':
	case 'N':
		if(*pszTS == 'o' || *pszTS == 'O') {
			++pszTS;
			if(*pszTS == 'v' || *pszTS == 'V') {
				++pszTS;
				month = 11;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	case 'd':
	case 'D':
		if(*pszTS == 'e' || *pszTS == 'E') {
			++pszTS;
			if(*pszTS == 'c' || *pszTS == 'C') {
				++pszTS;
				month = 12;
			} else
				ABORT_FINALIZE(RS_RET_INVLD_TIME);
		} else
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		break;
	default:
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	}

	lenStr -= 3;

	/* done month */

	if(lenStr == 0 || *pszTS++ != ' ')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;

	/* we accept a slightly malformed timestamp when receiving. This is
	 * we accept one-digit days
	 */
	if(*pszTS == ' ') {
		--lenStr;
		++pszTS;
	}

	day = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(day &lt; 1 || day &gt; 31)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	if(lenStr == 0 || *pszTS++ != ' ')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;

	/* time part */
	hour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(year == 0 &amp;&amp; hour &gt; 1970 &amp;&amp; hour &lt; 2100) {
		/* if so, we assume this actually is a year. This is a format found
		 * e.g. in Cisco devices.
		 * (if you read this 2100+ trying to fix a bug, congratulate me
		 * to how long the code survived - me no longer ;)) -- rgerhards, 2008-11-18
		 */
		year = hour;

		/* re-query the hour, this time it must be valid */
		if(lenStr == 0 || *pszTS++ != ' ')
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		--lenStr;
		hour = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	}

	if(hour &lt; 0 || hour &gt; 23)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	if(lenStr == 0 || *pszTS++ != ':')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	minute = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(minute &lt; 0 || minute &gt; 59)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	if(lenStr == 0 || *pszTS++ != ':')
		ABORT_FINALIZE(RS_RET_INVLD_TIME);
	--lenStr;
	second = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
	if(second &lt; 0 || second &gt; 60)
		ABORT_FINALIZE(RS_RET_INVLD_TIME);

	/* as an extension e.g. found in CISCO IOS, we support sub-second resultion.
	 * It's presence is indicated by a dot immediately following the second.
	 */
	if(lenStr &gt; 0 &amp;&amp; *pszTS == '.') {
		--lenStr;
		uchar *pszStart = ++pszTS;
		secfrac = srSLMGParseInt32(&amp;pszTS, &amp;lenStr);
		secfracPrecision = (int) (pszTS - pszStart);
	} else {
		secfracPrecision = 0;
		secfrac = 0;
	}

	/* try to parse the TZSTRING if we are instructed to do so */
	if(bParseTZ &amp;&amp; lenStr &gt; 2 &amp;&amp; *pszTS == ' ') {
		int i;
		for(  ++pszTS, --lenStr, i = 0
		    ; lenStr &gt; 0 &amp;&amp; i &lt; (int) sizeof(tzstring) - 1 &amp;&amp; *pszTS != ':' &amp;&amp; *pszTS != ' '
		    ; --lenStr)
			tzstring[i++] = *pszTS++;
		if(i &gt; 0) {
			/* found TZ, apply it */
			tzinfo_t* tzinfo;
			tzstring[i] = '\0';
			if((tzinfo = glblFindTimezone(runConf, (char*) tzstring)) == NULL) {
				DBGPRINTF("ParseTIMESTAMP3164: invalid TZ string '%s' -- ignored\n",
					  tzstring);
			} else {
				OffsetMode = tzinfo-&gt;offsMode;
				OffsetHour = tzinfo-&gt;offsHour;
				OffsetMinute = tzinfo-&gt;offsMin;
			}
		}
	}
	if(bDetectYearAfterTime &amp;&amp; year == 0 &amp;&amp; lenStr &gt; 5 &amp;&amp; *pszTS == ' ') {
		int j;
		int y = 0;
		for(j = 1 ; j &lt; 5 ; ++j) {
			if(pszTS[j] &lt; '0' || pszTS[j] &gt; '9')
				break;
			y = 10 * y + pszTS[j] - '0';
		}
		if(lenStr &gt; 6 &amp;&amp; pszTS[5] != ' ')
			y = 0; /* no year! */
		if(2000 &lt;= y &amp;&amp; y &lt; 2100) {
			year = y;
			pszTS += 5; /* we need to preserve the SP, checked below */
			lenStr -= 5;
		}
	}

	/* we provide support for an extra ":" after the date. While this is an
	 * invalid format, it occurs frequently enough (e.g. with Cisco devices)
	 * to permit it as a valid case. -- rgerhards, 2008-09-12
	 */
	if(lenStr &gt; 0 &amp;&amp; *pszTS == ':') {
		++pszTS; /* just skip past it */
		--lenStr;
	}
	if(lenStr &gt; 0) {
		if(*pszTS != ' ') /* if it is not a space, it can not be a "good" time - 2010-02-22 rgerhards */
			ABORT_FINALIZE(RS_RET_INVLD_TIME);
		++pszTS; /* just skip past it */
		--lenStr;
	}

	/* we had success, so update parse pointer and caller-provided timestamp
	 * fields we do not have are not updated in the caller's timestamp. This
	 * is the reason why the caller must pass in a correct timestamp.
	 */
	*ppszTS = pszTS; /* provide updated parse position back to caller */
	pTime-&gt;timeType = 1;
	pTime-&gt;month = month;
	if(year &gt; 0)
		pTime-&gt;year = year; /* persist year if detected */
	pTime-&gt;day = day;
	pTime-&gt;hour = hour;
	pTime-&gt;minute = minute;
	pTime-&gt;second = second;
	pTime-&gt;secfrac = secfrac;
	pTime-&gt;secfracPrecision = secfracPrecision;
	if(OffsetMode != '\0') { /* need to update TZ info? */
		pTime-&gt;OffsetMode = OffsetMode;
		pTime-&gt;OffsetHour = OffsetHour;
		pTime-&gt;OffsetMinute = OffsetMinute;
	}
	*pLenStr = lenStr;

finalize_it:
	RETiRet;
}

void
applyDfltTZ(struct syslogTime *pTime, char *tz)
{
	pTime-&gt;OffsetMode = tz[0];
	pTime-&gt;OffsetHour = (tz[1] - '0') * 10 + (tz[2] - '0');
	pTime-&gt;OffsetMinute = (tz[4] - '0') * 10 + (tz[5] - '0');

}

/*******************************************************************
 * END CODE-LIBLOGGING                                             *
 *******************************************************************/

/**
 * Format a syslogTimestamp into format required by MySQL.
 * We are using the 14 digits format. For example 20041111122600
 * is interpreted as '2004-11-11 12:26:00'.
 * The caller must provide the timestamp as well as a character
 * buffer that will receive the resulting string. The function
 * returns the size of the timestamp written in bytes (without
 * the string terminator). If 0 is returend, an error occurred.
 */
static int
formatTimestampToMySQL(struct syslogTime *ts, char* pBuf)
{
	/* currently we do not consider localtime/utc. This may later be
	 * added. If so, I recommend using a property replacer option
	 * and/or a global configuration option. However, we should wait
	 * on user requests for this feature before doing anything.
<a name="2"></a>	 * rgerhards, 2007-06-26
	 */
	assert(ts != NULL);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	assert(pBuf != NULL);

	pBuf[0] = (ts-&gt;year / 1000) % 10 + '0';
	pBuf[1] = (ts-&gt;year / 100) % 10 + '0';
	pBuf[2] = (ts-&gt;year / 10) % 10 + '0';
	pBuf[3] = ts-&gt;year % 10 + '0';
	pBuf[4] = (ts-&gt;month / 10) % 10 + '0';
	pBuf[5] = ts-&gt;month % 10 + '0';
	pBuf[6] = (ts-&gt;day / 10) % 10 + '0';
	pBuf[7] = ts-&gt;day % 10 + '0';
	pBuf[8] = (ts-&gt;hour / 10) % 10 + '0';
	pBuf[9] = ts-&gt;hour % 10 + '0';
	pBuf[10] = (ts-&gt;minute / 10) % 10 + '0';
	pBuf[11] = ts-&gt;minute % 10 + '0';
	pBuf[12] = (ts-&gt;second / 10) % 10 + '0';
	pBuf[13] = ts-&gt;second % 10 + '0';
	pBuf[14] = '\0';</b></font>
	return 15;

}

static int
formatTimestampToPgSQL(struct syslogTime *ts, char *pBuf)
<a name="0"></a>{
	/* see note in formatTimestampToMySQL, applies here as well */
	assert(ts != NULL);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	assert(pBuf != NULL);

	pBuf[0] = (ts-&gt;year / 1000) % 10 + '0';
	pBuf[1] = (ts-&gt;year / 100) % 10 + '0';
	pBuf[2] = (ts-&gt;year / 10) % 10 + '0';
	pBuf[3] = ts-&gt;year % 10 + '0';
	pBuf[4] = '-';
	pBuf[5] = (ts-&gt;month / 10) % 10 + '0';
	pBuf[6] = ts-&gt;month % 10 + '0';
	pBuf[7] = '-';
	pBuf[8] = (ts-&gt;day / 10) % 10 + '0';
	pBuf[9] = ts-&gt;day % 10 + '0';
	pBuf[10] = ' ';
	pBuf[11] = (ts-&gt;hour / 10) % 10 + '0';
	pBuf[12] = ts-&gt;hour % 10 + '0';
	pBuf[13] = ':';
	pBuf[14] = (ts-&gt;minute / 10) % 10 + '0';
	pBuf[15] = ts-&gt;minute % 10 + '0';
	pBuf[16] = ':';
	pBuf[17] = (ts-&gt;second / 10) % 10 + '0';
	pBuf[18] = ts-&gt;second % 10 + '0';
	pBuf[19] = '\0';</b></font>
	return 19;
}


/**
 * Format a syslogTimestamp to just the fractional seconds.
 * The caller must provide the timestamp as well as a character
 * buffer that will receive the resulting string. The function
 * returns the size of the timestamp written in bytes (without
 * the string terminator). If 0 is returend, an error occurred.
 * The buffer must be at least 7 bytes large.
 * rgerhards, 2008-06-06
 */
static int
formatTimestampSecFrac(struct syslogTime *ts, char* pBuf)
{
	int iBuf;
	int power;
	int secfrac;
	short digit;

	assert(ts != NULL);
	assert(pBuf != NULL);

	iBuf = 0;
	if(ts-&gt;secfracPrecision &gt; 0)
	{
		power = tenPowers[(ts-&gt;secfracPrecision - 1) % 6];
		secfrac = ts-&gt;secfrac;
		while(power &gt; 0) {
			digit = secfrac / power;
			secfrac -= digit * power;
			power /= 10;
			pBuf[iBuf++] = digit + '0';
		}
	} else {
		pBuf[iBuf++] = '0';
	}
	pBuf[iBuf] = '\0';

	return iBuf;
}


/**
 * Format a syslogTimestamp to a RFC3339 timestamp string (as
 * specified in syslog-protocol).
 * The caller must provide the timestamp as well as a character
 * buffer that will receive the resulting string. The function
 * returns the size of the timestamp written in bytes (without
 * the string terminator). If 0 is returend, an error occurred.
 */
static int
formatTimestamp3339(struct syslogTime *ts, char* pBuf)
{
	int iBuf;
	int power;
<a name="1"></a>	int secfrac;
	short digit;

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	assert(ts != NULL);
	assert(pBuf != NULL);

	/* start with fixed parts */
	/* year yyyy */
	pBuf[0] = (ts-&gt;year / 1000) % 10 + '0';
	pBuf[1] = (ts-&gt;year / 100) % 10 + '0';
	pBuf[2] = (ts-&gt;year / 10) % 10 + '0';
	pBuf[3] = ts-&gt;year % 10 + '0';
	pBuf[4] = '-';
	/* month */
	pBuf[5] = (ts-&gt;month / 10) % 10 + '0';
	pBuf[6] = ts-&gt;month % 10 + '0';
	pBuf[7] = '-';
	/* day */
	pBuf[8] = (ts-&gt;day / 10) % 10 + '0';
	pBuf[9] = ts-&gt;day % 10 + '0';
	pBuf[10] = 'T';
	/* hour */
	pBuf[11] = (ts-&gt;hour / 10) % 10 + '0';
	pBuf[12] = ts-&gt;hour % 10 + '0';
	pBuf[13] = ':';
	/* minute */
	pBuf[14] = (ts-&gt;minute / 10) % 10 + '0';
	pBuf[15] = ts-&gt;minute % 10 + '0';</b></font>
	pBuf[16] = ':';
	/* second */
	pBuf[17] = (ts-&gt;second / 10) % 10 + '0';
	pBuf[18] = ts-&gt;second % 10 + '0';

	iBuf = 19; /* points to next free entry, now it becomes dynamic! */

	if(ts-&gt;secfracPrecision &gt; 0) {
		pBuf[iBuf++] = '.';
		power = tenPowers[(ts-&gt;secfracPrecision - 1) % 6];
		secfrac = ts-&gt;secfrac;
		while(power &gt; 0) {
			digit = secfrac / power;
			secfrac -= digit * power;
			power /= 10;
			pBuf[iBuf++] = digit + '0';
		}
	}
<a name="4"></a>
	if(ts-&gt;OffsetMode == 'Z') {
		pBuf[iBuf++] = 'Z';
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	} else {
		pBuf[iBuf++] = ts-&gt;OffsetMode;
		pBuf[iBuf++] = (ts-&gt;OffsetHour / 10) % 10 + '0';
		pBuf[iBuf++] = ts-&gt;OffsetHour % 10 + '0';
		pBuf[iBuf++] = ':';
		pBuf[iBuf++] = (ts-&gt;OffsetMinute / 10) % 10 + '0';
		pBuf[iBuf++] = ts-&gt;OffsetMinute % 10 + '0';</b></font>
	}

	pBuf[iBuf] = '\0';

	return iBuf;
}

/**
 * Format a syslogTimestamp to a RFC3164 timestamp sring.
 * The caller must provide the timestamp as well as a character
 * buffer that will receive the resulting string. The function
 * returns the size of the timestamp written in bytes (without
 * the string termnator). If 0 is returend, an error occurred.
 * rgerhards, 2010-03-05: Added support to for buggy 3164 dates,
 * where a zero-digit is written instead of a space for the first
 * day character if day &lt; 10. syslog-ng seems to do that, and some
 * parsing scripts (in migration cases) rely on that.
 */
static int
formatTimestamp3164(struct syslogTime *ts, char* pBuf, int bBuggyDay)
{
	int iDay;
	assert(ts != NULL);
	assert(pBuf != NULL);

	pBuf[0] = monthNames[(ts-&gt;month - 1)% 12][0];
	pBuf[1] = monthNames[(ts-&gt;month - 1) % 12][1];
	pBuf[2] = monthNames[(ts-&gt;month - 1) % 12][2];
	pBuf[3] = ' ';
	iDay = (ts-&gt;day / 10) % 10; /* we need to write a space if the first digit is 0 */
	pBuf[4] = (bBuggyDay || iDay &gt; 0) ? iDay + '0' : ' ';
	pBuf[5] = ts-&gt;day % 10 + '0';
	pBuf[6] = ' ';
	pBuf[7] = (ts-&gt;hour / 10) % 10 + '0';
	pBuf[8] = ts-&gt;hour % 10 + '0';
	pBuf[9] = ':';
	pBuf[10] = (ts-&gt;minute / 10) % 10 + '0';
	pBuf[11] = ts-&gt;minute % 10 + '0';
	pBuf[12] = ':';
	pBuf[13] = (ts-&gt;second / 10) % 10 + '0';
	pBuf[14] = ts-&gt;second % 10 + '0';
	pBuf[15] = '\0';
	return 16;	/* traditional: number of bytes written */
}


/**
 * convert syslog timestamp to time_t
 * Note: it would be better to use something similar to mktime() here.
 * Unfortunately, mktime() semantics are problematic: first of all, it
 * works on local time, on the machine's time zone. In syslog, we have
 * to deal with multiple time zones at once, so we cannot plainly rely
 * on the local zone, and so we cannot rely on mktime(). One solution would
 * be to refactor all time-related functions so that they are all guarded
 * by a mutex to ensure TZ consistency (which would also enable us to
 * change the TZ at will for specific function calls). But that would
 * potentially mean a lot of overhead.
 * Also, mktime() has some side effects, at least setting of tzname. With
 * a refactoring as described above that should probably not be a problem,
 * but would also need more work. For some more thoughts on this topic,
 * have a look here:
 * http://stackoverflow.com/questions/18355101/is-standard-c-mktime-thread-safe-on-linux
 * In conclusion, we keep our own code for generating the unix timestamp.
 * rgerhards, 2016-03-02
 */
static time_t
syslogTime2time_t(const struct syslogTime *ts)
{
	long MonthInDays, NumberOfYears, NumberOfDays;
	int utcOffset;
	time_t TimeInUnixFormat;

	if(ts-&gt;year &lt; 1970 || ts-&gt;year &gt; 2100) {
		TimeInUnixFormat = 0;
		LogError(0, RS_RET_ERR, "syslogTime2time_t: invalid year %d "
			"in timestamp - returning 1970-01-01 instead", ts-&gt;year);
		goto done;
	}

	/* Counting how many Days have passed since the 01.01 of the
	 * selected Year (Month level), according to the selected Month*/

	switch(ts-&gt;month)
	{
		case 1:
			MonthInDays = 0;         //until 01 of January
			break;
		case 2:
			MonthInDays = 31;        //until 01 of February - leap year handling down below!
			break;
		case 3:
			MonthInDays = 59;        //until 01 of March
			break;
		case 4:
			MonthInDays = 90;        //until 01 of April
			break;
		case 5:
			MonthInDays = 120;       //until 01 of Mai
			break;
		case 6:
			MonthInDays = 151;       //until 01 of June
			break;
		case 7:
			MonthInDays = 181;       //until 01 of July
			break;
		case 8:
			MonthInDays = 212;       //until 01 of August
			break;
		case 9:
			MonthInDays = 243;       //until 01 of September
			break;
		case 10:
			MonthInDays = 273;       //until 01 of Oktober
			break;
		case 11:
			MonthInDays = 304;       //until 01 of November
			break;
		case 12:
			MonthInDays = 334;       //until 01 of December
			break;
		default: /* this cannot happen (and would be a program error)
		          * but we need the code to keep the compiler silent.
			  */
			MonthInDays = 0;	/* any value fits ;) */
			break;
	}
	/* adjust for leap years */
	if((ts-&gt;year % 100 != 0 &amp;&amp; ts-&gt;year % 4 == 0) || (ts-&gt;year == 2000)) {
		if(ts-&gt;month &gt; 2)
			MonthInDays++;
	}


	/*	1) Counting how many Years have passed since 1970
		2) Counting how many Days have passed since the 01.01 of the selected Year
			(Day level) according to the Selected Month and Day. Last day doesn't count,
			it should be until last day
		3) Calculating this period (NumberOfDays) in seconds*/

	NumberOfYears = ts-&gt;year - yearInSec_startYear - 1;
	NumberOfDays = MonthInDays + ts-&gt;day - 1;
	TimeInUnixFormat = (time_t) (yearInSecs[NumberOfYears] + 1) + NumberOfDays * 86400;

	/*Add Hours, minutes and seconds */
	TimeInUnixFormat += ts-&gt;hour*60*60;
	TimeInUnixFormat += ts-&gt;minute*60;
	TimeInUnixFormat += ts-&gt;second;
	/* do UTC offset */
	utcOffset = ts-&gt;OffsetHour*3600 + ts-&gt;OffsetMinute*60;
	if(ts-&gt;OffsetMode == '+')
		utcOffset *= -1; /* if timestamp is ahead, we need to "go back" to UTC */
	TimeInUnixFormat += utcOffset;
done:
	return TimeInUnixFormat;
}


/**
 * format a timestamp as a UNIX timestamp; subsecond resolution is
 * discarded.
 * Note that this code can use some refactoring. I decided to use it
 * because mktime() requires an upfront TZ update as it works on local
 * time. In any case, it is worth reconsidering to move to mktime() or
 * some other method.
 * Important: pBuf must point to a buffer of at least 11 bytes.
 * rgerhards, 2012-03-29
 */
static int
formatTimestampUnix(struct syslogTime *ts, char *pBuf)
{
	snprintf(pBuf, 11, "%u", (unsigned) syslogTime2time_t(ts));
	return 11;
}

/* 0 - Sunday, 1, Monday, ...
 * Note that we cannot use strftime() and helpers as they rely on the TZ
 * variable (again, arghhhh). So we need to do it ourselves...
 * Note: in the year 2100, this algorithm does not work correctly (due to
 * leap time rules. To fix it then (*IF* this code really still exists then),
 * just use 2100 as new anchor year and adapt the initial day number.
 */
int getWeekdayNbr(struct syslogTime *ts)
{
	int wday;
	int g, f;

	g = ts-&gt;year;
	if(ts-&gt;month &lt; 3) {
		g--;
		f = ts-&gt;month + 13;
	} else {
		f = ts-&gt;month + 1;
	}
	wday = ((36525*g)/100) + ((306*f)/10) + ts-&gt;day - 621049;
	wday %= 7;
	return wday;
}

/* getOrdinal - 1-366 day of the year
 * I've given little thought to leap seconds here.
 */
int getOrdinal(struct syslogTime *ts)
{
	int yday;
	time_t thistime;
	time_t previousyears;
	int utcOffset;
	time_t seconds_into_year;

	if(ts-&gt;year &lt; 1970 || ts-&gt;year &gt; 2100) {
		yday = 0;
		LogError(0, RS_RET_ERR, "getOrdinal: invalid year %d "
			"in timestamp - returning 1970-01-01 instead", ts-&gt;year);
		goto done;
	}

	thistime = syslogTime2time_t(ts);

	previousyears = (time_t) yearInSecs[ts-&gt;year - yearInSec_startYear - 1];

	/* adjust previous years to match UTC offset */
	utcOffset = ts-&gt;OffsetHour*3600 + ts-&gt;OffsetMinute*60;
	if(ts-&gt;OffsetMode == '+')
		utcOffset += -1; /* if timestamp is ahead, we need to "go back" to UTC */
	previousyears += utcOffset;

	/* subtract seconds from previous years */
	seconds_into_year = thistime - previousyears;

	/* divide by seconds in a day and truncate to int */
	yday = seconds_into_year / 86400;
done:
	return yday;
}

/* getWeek - 1-52 week of the year */
int getWeek(struct syslogTime *ts)
{
	int weekNum;
	struct syslogTime yt;
	int curDow;
	int jan1Dow;
<a name="3"></a>	int curYearDay;

	/* initialize a timestamp for january 1st of the current year */
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	yt.year = ts-&gt;year;
	yt.month = 1;
	yt.day = 1;
	yt.hour = 0;
	yt.minute = 0;
	yt.second = 0;
	yt.secfracPrecision = 0;
	yt.secfrac = 0;
	yt.OffsetMinute = ts-&gt;OffsetMinute;
	yt.OffsetHour = ts-&gt;OffsetHour;
	yt.OffsetMode = ts-&gt;OffsetMode;
	yt.timeType = TIME_TYPE_RFC3164; /* low-res time */

	/* get current day in year, current day of week
	 * and the day of week of 1/1 */
	curYearDay = getOrdinal(ts);
	curDow = getWeekdayNbr(ts);
	jan1Dow = getWeekdayNbr(&amp;yt);</b></font>

	/* calculate week of year for given date by pinning 1/1 as start
	 * of year, then going back and adjusting for the actual week day. */
	weekNum = ((curYearDay + 6) / 7);
	if (curDow &lt; jan1Dow) {
		++weekNum;
	}
	return weekNum;
}

/* getISOWeek - 1-53 week of the year */
int getISOWeek(struct syslogTime *ts, int *year)
{
	int weekNum;
	int curDow;
	int curYearDay;

	/* get current day in year, current day of week
	 * and the day of week of 1/1 */
	curYearDay = getOrdinal(ts);
	curDow = getWeekdayNbr(ts);

	/* map from 0 - Sunday, 1, Monday to 1, Monday, 7 - Sunday */
	if (curDow == 0) {
		curDow = 7;
	}
	/* make ordinal in range 1-366 */
	curYearDay++;

	weekNum = (10 + curYearDay - curDow) / 7;
	*year = ts-&gt;year;
	if (weekNum == 0) {
		/* this is actually W52 or W53 of previous year */
		weekNum = weeksInYear[ts-&gt;year - 1 - 1969];
		*year = ts-&gt;year - 1;
	} else if (weekNum &gt; weeksInYear[ts-&gt;year - 1969]) {
		/* this is actually W01 of next year */
		weekNum = 1;
		*year = ts-&gt;year + 1;
	}

	return weekNum;
}

void
timeConvertToUTC(const struct syslogTime *const __restrict__ local,
	struct syslogTime *const __restrict__ utc)
{
	struct timeval tp;
	tp.tv_sec = syslogTime2time_t(local);
	tp.tv_usec = local-&gt;secfrac;
	timeval2syslogTime(&amp;tp, utc, 1);
}

/**
 * Format a UNIX timestamp.
 */
static int
formatUnixTimeFromTime_t(time_t unixtime, const char *format, char *pBuf,
	__attribute__((unused)) uint pBufMax) {

	struct tm lt;

	assert(format != NULL);
	assert(pBuf != NULL);

	// Convert to struct tm
	if (gmtime_r(&amp;unixtime, &amp;lt) == NULL) {
		DBGPRINTF("Unexpected error calling gmtime_r().\n");
		return -1;
	}

	// Do our conversions
	if (strcmp(format, "date-rfc3164") == 0) {
		assert(pBufMax &gt;= 16);

		// Unlikely to run into this situation, but you never know...
		if (lt.tm_mon &lt; 0 || lt.tm_mon &gt; 11) {
			DBGPRINTF("lt.tm_mon is out of range. Value: %d\n", lt.tm_mon);
			return -1;
		}

		// MMM dd HH:mm:ss
		sprintf(pBuf, "%s %2d %.2d:%.2d:%.2d",
			monthNames[lt.tm_mon], lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec
		);
	} else if (strcmp(format, "date-rfc3339") == 0) {
		assert(pBufMax &gt;= 26);

		// YYYY-MM-DDTHH:mm:ss+00:00
		sprintf(pBuf, "%d-%.2d-%.2dT%.2d:%.2d:%.2dZ",
			lt.tm_year + 1900, lt.tm_mon + 1, lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec
		);
	}

	return strlen(pBuf);
}

/* queryInterface function
 * rgerhards, 2008-03-05
 */
BEGINobjQueryInterface(datetime)
CODESTARTobjQueryInterface(datetime)
	if(pIf-&gt;ifVersion != datetimeCURR_IF_VERSION) { /* check for current version, increment on each change */
		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}

	/* ok, we have the right interface, so let's fill it
	 * Please note that we may also do some backwards-compatibility
	 * work here (if we can support an older interface version - that,
	 * of course, also affects the "if" above).
	 */
	pIf-&gt;getCurrTime = getCurrTime;
	pIf-&gt;GetTime = getTime;
	pIf-&gt;timeval2syslogTime = timeval2syslogTime;
	pIf-&gt;ParseTIMESTAMP3339 = ParseTIMESTAMP3339;
	pIf-&gt;ParseTIMESTAMP3164 = ParseTIMESTAMP3164;
	pIf-&gt;formatTimestampToMySQL = formatTimestampToMySQL;
	pIf-&gt;formatTimestampToPgSQL = formatTimestampToPgSQL;
	pIf-&gt;formatTimestampSecFrac = formatTimestampSecFrac;
	pIf-&gt;formatTimestamp3339 = formatTimestamp3339;
	pIf-&gt;formatTimestamp3164 = formatTimestamp3164;
	pIf-&gt;formatTimestampUnix = formatTimestampUnix;
	pIf-&gt;syslogTime2time_t = syslogTime2time_t;
	pIf-&gt;formatUnixTimeFromTime_t = formatUnixTimeFromTime_t;
finalize_it:
ENDobjQueryInterface(datetime)


/* Initialize the datetime class. Must be called as the very first method
 * before anything else is called inside this class.
 * rgerhards, 2008-02-19
 */
BEGINAbstractObjClassInit(datetime, 1, OBJ_IS_CORE_MODULE) /* class, version */
	/* request objects we use */
ENDObjClassInit(datetime)

/* vi:set ai:
 */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rsconf.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* rsconf.c - the rsyslog configuration system.
 *
 * Module begun 2011-04-19 by Rainer Gerhards
 *
 * Copyright 2011-2020 Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pwd.h&gt;
#include &lt;grp.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/socket.h&gt;

#include "rsyslog.h"
#include "obj.h"
#include "srUtils.h"
#include "ruleset.h"
#include "modules.h"
#include "conf.h"
#include "queue.h"
#include "rsconf.h"
#include "cfsysline.h"
#include "errmsg.h"
#include "action.h"
#include "glbl.h"
#include "unicode-helper.h"
#include "omshell.h"
#include "omusrmsg.h"
#include "omfwd.h"
#include "omfile.h"
#include "ompipe.h"
#include "omdiscard.h"
#include "pmrfc5424.h"
#include "pmrfc3164.h"
#include "smfile.h"
#include "smtradfile.h"
#include "smfwd.h"
#include "smtradfwd.h"
#include "parser.h"
#include "outchannel.h"
#include "threads.h"
#include "datetime.h"
#include "parserif.h"
#include "modules.h"
#include "dirty.h"
#include "template.h"
#include "timezones.h"

extern char* yytext;
/* static data */
DEFobjStaticHelpers
DEFobjCurrIf(ruleset)
DEFobjCurrIf(module)
DEFobjCurrIf(conf)
DEFobjCurrIf(glbl)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)

/* exported static data */
rsconf_t *runConf = NULL;/* the currently running config */
rsconf_t *loadConf = NULL;/* the config currently being loaded (no concurrent config load supported!) */

/* hardcoded standard templates (used for defaults) */
static uchar template_DebugFormat[] = "\"Debug line with all properties:\nFROMHOST: '%FROMHOST%', fromhost-ip: "
"'%fromhost-ip%', HOSTNAME: '%HOSTNAME%', PRI: %PRI%,\nsyslogtag '%syslogtag%', programname: '%programname%', "
"APP-NAME: '%APP-NAME%', PROCID: '%PROCID%', MSGID: '%MSGID%',\nTIMESTAMP: '%TIMESTAMP%', "
"STRUCTURED-DATA: '%STRUCTURED-DATA%',\nmsg: '%msg%'\nescaped msg: '%msg:::drop-cc%'\ninputname: %inputname% "
"rawmsg: '%rawmsg%'\n$!:%$!%\n$.:%$.%\n$/:%$/%\n\n\"";
static uchar template_SyslogProtocol23Format[] = "\"&lt;%PRI%&gt;1 %TIMESTAMP:::date-rfc3339% %HOSTNAME% %APP-NAME% "
"%PROCID% %MSGID% %STRUCTURED-DATA% %msg%\n\"";
static uchar template_SyslogRFC5424Format[] = "\"&lt;%PRI%&gt;1 %TIMESTAMP:::date-rfc3339% %HOSTNAME% %APP-NAME% "
"%PROCID% %MSGID% %STRUCTURED-DATA% %msg%\"";
static uchar template_TraditionalFileFormat[] = "=RSYSLOG_TraditionalFileFormat";
static uchar template_FileFormat[] = "=RSYSLOG_FileFormat";
static uchar template_ForwardFormat[] = "=RSYSLOG_ForwardFormat";
static uchar template_TraditionalForwardFormat[] = "=RSYSLOG_TraditionalForwardFormat";
static uchar template_WallFmt[] = "\"\r\n\7Message from syslogd@%HOSTNAME% at %timegenerated% ...\r\n "
"%syslogtag%%msg%\n\r\"";
static uchar template_StdUsrMsgFmt[] = "\" %syslogtag%%msg%\n\r\"";
static uchar template_StdDBFmt[] = "\"insert into SystemEvents (Message, Facility, FromHost, Priority, "
"DeviceReportedTime, ReceivedAt, InfoUnitID, SysLogTag) values ('%msg%', %syslogfacility%, "
"'%HOSTNAME%', %syslogpriority%, '%timereported:::date-mysql%', '%timegenerated:::date-mysql%', %iut%, "
"'%syslogtag%')\",SQL";
static uchar template_StdPgSQLFmt[] = "\"insert into SystemEvents (Message, Facility, FromHost, Priority, "
"DeviceReportedTime, ReceivedAt, InfoUnitID, SysLogTag) values ('%msg%', %syslogfacility%, "
"'%HOSTNAME%', %syslogpriority%, '%timereported:::date-pgsql%', '%timegenerated:::date-pgsql%', %iut%, "
"'%syslogtag%')\",STDSQL";
static uchar template_spoofadr[] = "\"%fromhost-ip%\"";
static uchar template_SysklogdFileFormat[] = "\"%TIMESTAMP% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg%\n\"";
static uchar template_StdJSONFmt[] = "\"{\\\"message\\\":\\\"%msg:::json%\\\",\\\"fromhost\\\":\\\""
"%HOSTNAME:::json%\\\",\\\"facility\\\":\\\"%syslogfacility-text%\\\",\\\"priority\\\":\\\""
"%syslogpriority-text%\\\",\\\"timereported\\\":\\\"%timereported:::date-rfc3339%\\\",\\\"timegenerated\\\":\\\""
"%timegenerated:::date-rfc3339%\\\"}\"";
static uchar template_FullJSONFmt[] = "\"{\\\"message\\\":\\\"%msg:::json%\\\","
"\\\"fromhost\\\":\\\"%HOSTNAME:::json%\\\","
"\\\"programname\\\":\\\"%programname%\\\","
"\\\"procid\\\":\\\"%PROCID%\\\","
"\\\"msgid\\\":\\\"%MSGID%\\\","
"\\\"facility\\\":\\\"%syslogfacility-text%\\\","
"\\\"priority\\\":\\\"%syslogpriority-text%\\\","
"\\\"timereported\\\":\\\"%timereported:::date-rfc3339%\\\","
"\\\"timegenerated\\\":\\\"%timegenerated:::date-rfc3339%\\\"}\"";
static uchar template_StdClickHouseFmt[] = "\"INSERT INTO rsyslog.SystemEvents (severity, facility, "
"timestamp, hostname, tag, message) VALUES (%syslogseverity%, %syslogfacility%, "
"'%timereported:::date-unixtimestamp%', '%hostname%', '%syslogtag%', '%msg%')\",STDSQL";
/* end templates */

/* tables for interfacing with the v6 config system (as far as we need to) */
static struct cnfparamdescr inppdescr[] = {
	{ "type", eCmdHdlrString, CNFPARAM_REQUIRED }
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

static struct cnfparamdescr parserpdescr[] = {
	{ "type", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "name", eCmdHdlrString, CNFPARAM_REQUIRED }
};
static struct cnfparamblk parserpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
	  parserpdescr
	};

/* forward-definitions */
void cnfDoCfsysline(char *ln);

int rsconfNeedDropPriv(rsconf_t *const cnf)
{
	return ((cnf-&gt;globals.gidDropPriv != 0) || (cnf-&gt;globals.uidDropPriv != 0));
<a name="4"></a>}

static void cnfSetDefaults(rsconf_t *pThis)
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
	pThis-&gt;globals.bAbortOnUncleanConfig = 0;
	pThis-&gt;globals.bReduceRepeatMsgs = 0;
	pThis-&gt;globals.bDebugPrintTemplateList = 1;
	pThis-&gt;globals.bDebugPrintModuleList = 0;
	pThis-&gt;globals.bDebugPrintCfSysLineHandlerList = 0;
	pThis-&gt;globals.bLogStatusMsgs = DFLT_bLogStatusMsgs;
	pThis-&gt;globals.bErrMsgToStderr = 1;
	pThis-&gt;globals.maxErrMsgToStderr = -1;
	pThis-&gt;globals.umask = -1;
	pThis-&gt;globals.gidDropPrivKeepSupplemental = 0;
	pThis-&gt;globals.abortOnIDResolutionFail = 1;
	pThis-&gt;templates.root = NULL;</b></font>
	pThis-&gt;templates.last = NULL;
	pThis-&gt;templates.lastStatic = NULL;
	pThis-&gt;actions.nbrActions = 0;
	pThis-&gt;actions.iActionNbr = 0;
	pThis-&gt;globals.pszWorkDir = NULL;
	pThis-&gt;globals.bDropMalPTRMsgs = 0;
	pThis-&gt;globals.operatingStateFile = NULL;
	pThis-&gt;globals.iGnuTLSLoglevel = 0;
	pThis-&gt;globals.debugOnShutdown = 0;
	pThis-&gt;globals.pszDfltNetstrmDrvrCAF = NULL;
<a name="2"></a>	pThis-&gt;globals.pszDfltNetstrmDrvrCertFile = NULL;
	pThis-&gt;globals.pszDfltNetstrmDrvrKeyFile = NULL;
	pThis-&gt;globals.pszDfltNetstrmDrvr = NULL;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pThis-&gt;globals.oversizeMsgErrorFile = NULL;
	pThis-&gt;globals.reportOversizeMsg = 1;
	pThis-&gt;globals.oversizeMsgInputMode = 0;
	pThis-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_ERRORS;
	pThis-&gt;globals.bActionReportSuspension = 1;
	pThis-&gt;globals.bActionReportSuspensionCont = 0;
	pThis-&gt;globals.janitorInterval = 10;
	pThis-&gt;globals.reportNewSenders = 0;
	pThis-&gt;globals.reportGoneAwaySenders = 0;
	pThis-&gt;globals.senderStatsTimeout = 12 * 60 * 60; /* 12 hr timeout for senders */
	pThis-&gt;globals.senderKeepTrack = 0;
	pThis-&gt;globals.inputTimeoutShutdown = 1000;
	pThis-&gt;globals.iDefPFFamily = PF_UNSPEC;
	pThis-&gt;globals.ACLAddHostnameOnFail = 0;
	pThis-&gt;globals.ACLDontResolve = 0;
<a name="0"></a>	pThis-&gt;globals.bDisableDNS = 0;</b></font>
	pThis-&gt;globals.bProcessInternalMessages = 0;
	const char *const log_dflt = getenv("RSYSLOG_DFLT_LOG_INTERNAL");
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(log_dflt != NULL &amp;&amp; !strcmp(log_dflt, "1"))
		pThis-&gt;globals.bProcessInternalMessages = 1;
	pThis-&gt;globals.glblDevOptions = 0;
	pThis-&gt;globals.intMsgRateLimitItv = 5;
	pThis-&gt;globals.intMsgRateLimitBurst = 500;
	pThis-&gt;globals.intMsgsSeverityFilter = DFLT_INT_MSGS_SEV_FILTER;
	pThis-&gt;globals.permitCtlC = glblPermitCtlC;

	pThis-&gt;globals.actq_dflt_toQShutdown = 10;
	pThis-&gt;globals.actq_dflt_toActShutdown = 1000;
	pThis-&gt;globals.actq_dflt_toEnq = 2000;
	pThis-&gt;globals.actq_dflt_toWrkShutdown = 60000;

	pThis-&gt;globals.ruleset_dflt_toQShutdown = 1500;
	pThis-&gt;globals.ruleset_dflt_toActShutdown = 1000;
	pThis-&gt;globals.ruleset_dflt_toEnq = 2000;
	pThis-&gt;globals.ruleset_dflt_toWrkShutdown = 60000;

	pThis-&gt;globals.dnscacheDefaultTTL = 24 * 60 * 60;
	pThis-&gt;globals.dnscacheEnableTTL = 0;
	pThis-&gt;globals.shutdownQueueDoubleSize = 0;
	pThis-&gt;globals.optionDisallowWarning = 1;
	pThis-&gt;globals.bSupportCompressionExtension = 1;
	#ifdef ENABLE_LIBLOGGING_STDLOG
		pThis-&gt;globals.stdlog_hdl = stdlog_open("rsyslogd", 0, STDLOG_SYSLOG, NULL);</b></font>
		pThis-&gt;globals.stdlog_chanspec = NULL;
	#endif
	pThis-&gt;globals.iMaxLine = 8096;

	/* timezone specific*/
	pThis-&gt;timezones.tzinfos = NULL;
	pThis-&gt;timezones.ntzinfos = 0;

	/* queue params */
	pThis-&gt;globals.mainQ.iMainMsgQueueSize = 100000;
	pThis-&gt;globals.mainQ.iMainMsgQHighWtrMark = 80000;
	pThis-&gt;globals.mainQ.iMainMsgQLowWtrMark = 20000;
	pThis-&gt;globals.mainQ.iMainMsgQDiscardMark = 98000;
	pThis-&gt;globals.mainQ.iMainMsgQDiscardSeverity = 8;
<a name="3"></a>	pThis-&gt;globals.mainQ.iMainMsgQueueNumWorkers = 2;
	pThis-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
	pThis-&gt;globals.mainQ.pszMainMsgQFName = NULL;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pThis-&gt;globals.mainQ.iMainMsgQueMaxFileSize = 1024*1024;
	pThis-&gt;globals.mainQ.iMainMsgQPersistUpdCnt = 0;
	pThis-&gt;globals.mainQ.bMainMsgQSyncQeueFiles = 0;
	pThis-&gt;globals.mainQ.iMainMsgQtoQShutdown = 1500;
	pThis-&gt;globals.mainQ.iMainMsgQtoActShutdown = 1000;
	pThis-&gt;globals.mainQ.iMainMsgQtoEnq = 2000;
	pThis-&gt;globals.mainQ.iMainMsgQtoWrkShutdown = 60000;
	pThis-&gt;globals.mainQ.iMainMsgQWrkMinMsgs = 40000;
	pThis-&gt;globals.mainQ.iMainMsgQDeqSlowdown = 0;
	pThis-&gt;globals.mainQ.iMainMsgQueMaxDiskSpace = 0;
	pThis-&gt;globals.mainQ.iMainMsgQueDeqBatchSize = 256;
	pThis-&gt;globals.mainQ.bMainMsgQSaveOnShutdown = 1;
	pThis-&gt;globals.mainQ.iMainMsgQueueDeqtWinFromHr = 0;
	pThis-&gt;globals.mainQ.iMainMsgQueueDeqtWinToHr = 25;
	pThis-&gt;pMsgQueue = NULL;</b></font>

	pThis-&gt;globals.parser.cCCEscapeChar = '#';
	pThis-&gt;globals.parser.bDropTrailingLF = 1;
	pThis-&gt;globals.parser.bEscapeCCOnRcv = 1;
	pThis-&gt;globals.parser.bSpaceLFOnRcv = 0;
	pThis-&gt;globals.parser.bEscape8BitChars = 0;
	pThis-&gt;globals.parser.bEscapeTab = 1;
	pThis-&gt;globals.parser.bParserEscapeCCCStyle = 0;
	pThis-&gt;globals.parser.bPermitSlashInProgramname = 0;
	pThis-&gt;globals.parser.bParseHOSTNAMEandTAG = 1;

	pThis-&gt;parsers.pDfltParsLst = NULL;
	pThis-&gt;parsers.pParsLstRoot = NULL;
}


/* Standard-Constructor
 */
BEGINobjConstruct(rsconf) /* be sure to specify the object type also in END macro! */
	cnfSetDefaults(pThis);
	lookupInitCnf(&amp;pThis-&gt;lu_tabs);
	CHKiRet(dynstats_initCnf(&amp;pThis-&gt;dynstats_buckets));
	CHKiRet(perctile_initCnf(&amp;pThis-&gt;perctile_buckets));
	CHKiRet(llInit(&amp;pThis-&gt;rulesets.llRulesets, rulesetDestructForLinkedList,
			rulesetKeyDestruct, strcasecmp));
finalize_it:
ENDobjConstruct(rsconf)


/* ConstructionFinalizer
 */
static rsRetVal
rsconfConstructFinalize(rsconf_t __attribute__((unused)) *pThis)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, rsconf);
	RETiRet;
}


/* call freeCnf() module entry points AND free the module entries themselfes.
 */
static void
freeCnf(rsconf_t *pThis)
{
	cfgmodules_etry_t *etry, *del;
	etry = pThis-&gt;modules.root;
	while(etry != NULL) {
		if(etry-&gt;pMod-&gt;beginCnfLoad != NULL) {
			dbgprintf("calling freeCnf(%p) for module '%s'\n",
				  etry-&gt;modCnf, (char*) module.GetName(etry-&gt;pMod));
			etry-&gt;pMod-&gt;freeCnf(etry-&gt;modCnf);
		}
		del = etry;
		etry = etry-&gt;next;
		free(del);
	}
}

/* destructor for the rsconf object */
PROTOTYPEobjDestruct(rsconf);
BEGINobjDestruct(rsconf) /* be sure to specify the object type also in END and CODESTART macros! */
CODESTARTobjDestruct(rsconf)
	freeCnf(pThis);
	tplDeleteAll(pThis);
	dynstats_destroyAllBuckets();
	perctileBucketsDestruct();
	ochDeleteAll();
	freeTimezones(pThis);
	parser.DestructParserList(&amp;pThis-&gt;parsers.pDfltParsLst);
	parser.destroyMasterParserList(pThis-&gt;parsers.pParsLstRoot);
	free(pThis-&gt;globals.mainQ.pszMainMsgQFName);
	free(pThis-&gt;globals.pszConfDAGFile);
	free(pThis-&gt;globals.pszWorkDir);
	free(pThis-&gt;globals.operatingStateFile);
	free(pThis-&gt;globals.pszDfltNetstrmDrvrCAF);
	free(pThis-&gt;globals.pszDfltNetstrmDrvrCertFile);
	free(pThis-&gt;globals.pszDfltNetstrmDrvrKeyFile);
	free(pThis-&gt;globals.pszDfltNetstrmDrvr);
	free(pThis-&gt;globals.oversizeMsgErrorFile);
	#ifdef ENABLE_LIBLOGGING_STDLOG
		stdlog_close(pThis-&gt;globals.stdlog_hdl);
		free(pThis-&gt;globals.stdlog_chanspec);
	#endif
	lookupDestroyCnf();
	llDestroy(&amp;(pThis-&gt;rulesets.llRulesets));
ENDobjDestruct(rsconf)


/* DebugPrint support for the rsconf object */
PROTOTYPEObjDebugPrint(rsconf);
BEGINobjDebugPrint(rsconf) /* be sure to specify the object type also in END and CODESTART macros! */
	cfgmodules_etry_t *modNode;

	dbgprintf("configuration object %p\n", pThis);
	dbgprintf("Global Settings:\n");
	dbgprintf("  bDebugPrintTemplateList.............: %d\n",
		  pThis-&gt;globals.bDebugPrintTemplateList);
	dbgprintf("  bDebugPrintModuleList               : %d\n",
		  pThis-&gt;globals.bDebugPrintModuleList);
	dbgprintf("  bDebugPrintCfSysLineHandlerList.....: %d\n",
		  pThis-&gt;globals.bDebugPrintCfSysLineHandlerList);
	dbgprintf("  bLogStatusMsgs                      : %d\n",
		  pThis-&gt;globals.bLogStatusMsgs);
	dbgprintf("  bErrMsgToStderr.....................: %d\n",
		  pThis-&gt;globals.bErrMsgToStderr);
	dbgprintf("  drop Msgs with malicious PTR Record : %d\n",
		  glbl.GetDropMalPTRMsgs(pThis));
	ruleset.DebugPrintAll(pThis);
	dbgprintf("\n");
	if(pThis-&gt;globals.bDebugPrintTemplateList)
		tplPrintList(pThis);
	if(pThis-&gt;globals.bDebugPrintModuleList)
		module.PrintList();
	if(pThis-&gt;globals.bDebugPrintCfSysLineHandlerList)
		dbgPrintCfSysLineHandlers();
	// TODO: The following code needs to be "streamlined", so far just moved over...
	dbgprintf("Main queue size %d messages.\n", pThis-&gt;globals.mainQ.iMainMsgQueueSize);
	dbgprintf("Main queue worker threads: %d, wThread shutdown: %d, Perists every %d updates.\n",
		  pThis-&gt;globals.mainQ.iMainMsgQueueNumWorkers,
		  pThis-&gt;globals.mainQ.iMainMsgQtoWrkShutdown, pThis-&gt;globals.mainQ.iMainMsgQPersistUpdCnt);
	dbgprintf("Main queue timeouts: shutdown: %d, action completion shutdown: %d, enq: %d\n",
		   pThis-&gt;globals.mainQ.iMainMsgQtoQShutdown,
		   pThis-&gt;globals.mainQ.iMainMsgQtoActShutdown, pThis-&gt;globals.mainQ.iMainMsgQtoEnq);
	dbgprintf("Main queue watermarks: high: %d, low: %d, discard: %d, discard-severity: %d\n",
		   pThis-&gt;globals.mainQ.iMainMsgQHighWtrMark, pThis-&gt;globals.mainQ.iMainMsgQLowWtrMark,
		   pThis-&gt;globals.mainQ.iMainMsgQDiscardMark, pThis-&gt;globals.mainQ.iMainMsgQDiscardSeverity);
	dbgprintf("Main queue save on shutdown %d, max disk space allowed %lld\n",
		   pThis-&gt;globals.mainQ.bMainMsgQSaveOnShutdown, pThis-&gt;globals.mainQ.iMainMsgQueMaxDiskSpace);
	/* TODO: add
	iActionRetryCount = 0;
	iActionRetryInterval = 30000;
	static int iMainMsgQtoWrkMinMsgs = 100;
	static int iMainMsgQbSaveOnShutdown = 1;
	iMainMsgQueMaxDiskSpace = 0;
	setQPROP(qqueueSetiMinMsgsPerWrkr, "$MainMsgQueueWorkerThreadMinimumMessages", 100);
	setQPROP(qqueueSetbSaveOnShutdown, "$MainMsgQueueSaveOnShutdown", 1);
	 */
	dbgprintf("Work Directory: '%s'.\n", glbl.GetWorkDir(pThis));
	ochPrintList(pThis);
	dbgprintf("Modules used in this configuration:\n");
	for(modNode = pThis-&gt;modules.root ; modNode != NULL ; modNode = modNode-&gt;next) {
		dbgprintf("    %s\n", module.GetName(modNode-&gt;pMod));
	}
CODESTARTobjDebugPrint(rsconf)
ENDobjDebugPrint(rsconf)


static rsRetVal
parserProcessCnf(struct cnfobj *o)
{
	struct cnfparamvals *pvals;
	modInfo_t *pMod;
	uchar *cnfModName = NULL;
	uchar *parserName = NULL;
	int paramIdx;
	void *parserInst;
	parser_t *myparser;
	DEFiRet;

	pvals = nvlstGetParams(o-&gt;nvlst, &amp;parserpblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	DBGPRINTF("input param blk after parserProcessCnf:\n");
	cnfparamsPrint(&amp;parserpblk, pvals);
	paramIdx = cnfparamGetIdx(&amp;parserpblk, "name");
	parserName = (uchar*)es_str2cstr(pvals[paramIdx].val.d.estr, NULL);
	if(parser.FindParser(loadConf-&gt;parsers.pParsLstRoot, &amp;myparser, parserName) != RS_RET_PARSER_NOT_FOUND) {
		LogError(0, RS_RET_PARSER_NAME_EXISTS,
			"parser module name '%s' already exists", parserName);
		ABORT_FINALIZE(RS_RET_PARSER_NAME_EXISTS);
	}

	paramIdx = cnfparamGetIdx(&amp;parserpblk, "type");
	cnfModName = (uchar*)es_str2cstr(pvals[paramIdx].val.d.estr, NULL);
	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_PARSER)) == NULL) {
		LogError(0, RS_RET_MOD_UNKNOWN, "parser module name '%s' is unknown", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
	}
	if(pMod-&gt;mod.pm.newParserInst == NULL) {
		LogError(0, RS_RET_MOD_NO_PARSER_STMT,
				"parser module '%s' does not support parser() statement", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_NO_INPUT_STMT);
	}
	CHKiRet(pMod-&gt;mod.pm.newParserInst(o-&gt;nvlst, &amp;parserInst));

	/* all well, so let's (try) to add parser to config */
	CHKiRet(parserConstructViaModAndName(pMod, parserName, parserInst));
finalize_it:
	free(cnfModName);
	free(parserName);
	cnfparamvalsDestruct(pvals, &amp;parserpblk);
	RETiRet;
}


/* Process input() objects */
static rsRetVal
inputProcessCnf(struct cnfobj *o)
{
	struct cnfparamvals *pvals;
	modInfo_t *pMod;
	uchar *cnfModName = NULL;
	int typeIdx;
	DEFiRet;

	pvals = nvlstGetParams(o-&gt;nvlst, &amp;inppblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	DBGPRINTF("input param blk after inputProcessCnf:\n");
	cnfparamsPrint(&amp;inppblk, pvals);
	typeIdx = cnfparamGetIdx(&amp;inppblk, "type");
	cnfModName = (uchar*)es_str2cstr(pvals[typeIdx].val.d.estr, NULL);
	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_IN)) == NULL) {
		LogError(0, RS_RET_MOD_UNKNOWN, "input module name '%s' is unknown", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
	}
	if(pMod-&gt;mod.im.newInpInst == NULL) {
		LogError(0, RS_RET_MOD_NO_INPUT_STMT,
				"input module '%s' does not support input() statement", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_NO_INPUT_STMT);
	}
	iRet = pMod-&gt;mod.im.newInpInst(o-&gt;nvlst);
finalize_it:
	free(cnfModName);
	cnfparamvalsDestruct(pvals, &amp;inppblk);
	RETiRet;
}

/*------------------------------ interface to flex/bison parser ------------------------------*/
extern int yylineno;

void
parser_warnmsg(const char *fmt, ...)
{
	va_list ap;
	char errBuf[1024];

	va_start(ap, fmt);
	if(vsnprintf(errBuf, sizeof(errBuf), fmt, ap) == sizeof(errBuf))
		errBuf[sizeof(errBuf)-1] = '\0';
	LogMsg(0, RS_RET_CONF_PARSE_WARNING, LOG_WARNING,
			"warning during parsing file %s, on or before line %d: %s",
			cnfcurrfn, yylineno, errBuf);
	va_end(ap);
}

void
parser_errmsg(const char *fmt, ...)
{
	va_list ap;
	char errBuf[1024];

	va_start(ap, fmt);
	if(vsnprintf(errBuf, sizeof(errBuf), fmt, ap) == sizeof(errBuf))
		errBuf[sizeof(errBuf)-1] = '\0';
	if(cnfcurrfn == NULL) {
		LogError(0, RS_RET_CONF_PARSE_ERROR,
				"error during config processing: %s", errBuf);
	} else {
		LogError(0, RS_RET_CONF_PARSE_ERROR,
				"error during parsing file %s, on or before line %d: %s",
				cnfcurrfn, yylineno, errBuf);
	}
	va_end(ap);
}

int yyerror(const char *s); /* we need this prototype to make compiler happy */
int
yyerror(const char *s)
{
	parser_errmsg("%s on token '%s'", s, yytext);
	return 0;
}
void ATTR_NONNULL()
cnfDoObj(struct cnfobj *const o)
{
	int bDestructObj = 1;
	int bChkUnuse = 1;
	assert(o != NULL);

	dbgprintf("cnf:global:obj: ");
	cnfobjPrint(o);

	/* We need to check for object disabling as early as here to cover most
	 * of them at once and avoid needless initializations
	 * - jvymazal 2020-02-12
	 */
	if (nvlstChkDisabled(o-&gt;nvlst)) {
		dbgprintf("object disabled by configuration\n");
		return;
	}

	switch(o-&gt;objType) {
	case CNFOBJ_GLOBAL:
		glblProcessCnf(o);
		break;
	case CNFOBJ_TIMEZONE:
		glblProcessTimezone(o);
		break;
	case CNFOBJ_MAINQ:
		glblProcessMainQCnf(o);
		bDestructObj = 0;
		break;
	case CNFOBJ_MODULE:
		modulesProcessCnf(o);
		break;
	case CNFOBJ_INPUT:
		inputProcessCnf(o);
		break;
	case CNFOBJ_LOOKUP_TABLE:
		lookupTableDefProcessCnf(o);
		break;
	case CNFOBJ_DYN_STATS:
		dynstats_processCnf(o);
		break;
	case CNFOBJ_PERCTILE_STATS:
		perctile_processCnf(o);
		break;
	case CNFOBJ_PARSER:
		parserProcessCnf(o);
		break;
	case CNFOBJ_TPL:
		if(tplProcessCnf(o) != RS_RET_OK)
			parser_errmsg("error processing template object");
		break;
	case CNFOBJ_RULESET:
		rulesetProcessCnf(o);
		break;
	case CNFOBJ_PROPERTY:
	case CNFOBJ_CONSTANT:
		/* these types are processed at a later stage */
		bChkUnuse = 0;
		break;
	case CNFOBJ_ACTION:
	default:
		dbgprintf("cnfDoObj program error: unexpected object type %u\n",
			 o-&gt;objType);
		break;
	}
	if(bDestructObj) {
		if(bChkUnuse)
			nvlstChkUnused(o-&gt;nvlst);
		cnfobjDestruct(o);
	 }
}

void cnfDoScript(struct cnfstmt *script)
{
	dbgprintf("cnf:global:script\n");
	ruleset.AddScript(ruleset.GetCurrent(loadConf), script);
}

void cnfDoCfsysline(char *ln)
{
	DBGPRINTF("cnf:global:cfsysline: %s\n", ln);
	/* the legacy system needs the "$" stripped */
	conf.cfsysline((uchar*) ln+1);
	free(ln);
}

void cnfDoBSDTag(char *ln)
{
	DBGPRINTF("cnf:global:BSD tag: %s\n", ln);
	LogError(0, RS_RET_BSD_BLOCKS_UNSUPPORTED,
			"BSD-style blocks are no longer supported in rsyslog, "
			"see https://www.rsyslog.com/g/BSD for details and a "
			"solution (Block '%s')", ln);
	free(ln);
}

void cnfDoBSDHost(char *ln)
{
	DBGPRINTF("cnf:global:BSD host: %s\n", ln);
	LogError(0, RS_RET_BSD_BLOCKS_UNSUPPORTED,
			"BSD-style blocks are no longer supported in rsyslog, "
			"see https://www.rsyslog.com/g/BSD for details and a "
			"solution (Block '%s')", ln);
	free(ln);
}
/*------------------------------ end interface to flex/bison parser ------------------------------*/



/* drop to specified group
 * if something goes wrong, the function never returns
 */
static
rsRetVal doDropPrivGid(rsconf_t *cnf)
{
	int res;
	uchar szBuf[1024];
	DEFiRet;

	if(!cnf-&gt;globals.gidDropPrivKeepSupplemental) {
		res = setgroups(0, NULL); /* remove all supplemental group IDs */
		if(res) {
			LogError(errno, RS_RET_ERR_DROP_PRIV,
					"could not remove supplemental group IDs");
			ABORT_FINALIZE(RS_RET_ERR_DROP_PRIV);
		}
		DBGPRINTF("setgroups(0, NULL): %d\n", res);
	}
	res = setgid(cnf-&gt;globals.gidDropPriv);
	if(res) {
		LogError(errno, RS_RET_ERR_DROP_PRIV,
				"could not set requested group id %d", cnf-&gt;globals.gidDropPriv);
		ABORT_FINALIZE(RS_RET_ERR_DROP_PRIV);
	}
	DBGPRINTF("setgid(%d): %d\n", cnf-&gt;globals.gidDropPriv, res);
	snprintf((char*)szBuf, sizeof(szBuf), "rsyslogd's groupid changed to %d",
		 cnf-&gt;globals.gidDropPriv);
	logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO, szBuf, 0);
finalize_it:
	RETiRet;
}


/* drop to specified user
 * if something goes wrong, the function never returns
 * Note that such an abort can cause damage to on-disk structures, so we should
 * re-design the "interface" in the long term. -- rgerhards, 2008-11-19
 */
static void doDropPrivUid(rsconf_t *cnf)
{
	int res;
	uchar szBuf[1024];
	struct passwd *pw;
	gid_t gid;

	/* Try to set appropriate supplementary groups for this user.
	 * Failure is not fatal.
	 */
	pw = getpwuid(cnf-&gt;globals.uidDropPriv);
	if (pw) {
		gid = getgid();
		res = initgroups(pw-&gt;pw_name, gid);
		DBGPRINTF("initgroups(%s, %ld): %d\n", pw-&gt;pw_name, (long) gid, res);
	} else {
		LogError(errno, NO_ERRCODE, "could not get username for userid '%d'",
			cnf-&gt;globals.uidDropPriv);
	}

	res = setuid(cnf-&gt;globals.uidDropPriv);
	if(res) {
		/* if we can not set the userid, this is fatal, so let's unconditionally abort */
		perror("could not set requested userid");
		exit(1);
	}
	DBGPRINTF("setuid(%d): %d\n", cnf-&gt;globals.uidDropPriv, res);
	snprintf((char*)szBuf, sizeof(szBuf), "rsyslogd's userid changed to %d", cnf-&gt;globals.uidDropPriv);
	logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO, szBuf, 0);
}



/* drop privileges. This will drop to the configured privileges, if
 * set by the user. After this method has been executed, the previous
 * privileges can no be re-gained.
 */
static rsRetVal
dropPrivileges(rsconf_t *cnf)
{
	DEFiRet;

	if(cnf-&gt;globals.gidDropPriv != 0) {
		CHKiRet(doDropPrivGid(cnf));
		DBGPRINTF("group privileges have been dropped to gid %u\n", (unsigned)
			  cnf-&gt;globals.gidDropPriv);
	}

	if(cnf-&gt;globals.uidDropPriv != 0) {
		doDropPrivUid(cnf);
		DBGPRINTF("user privileges have been dropped to uid %u\n", (unsigned)
			  cnf-&gt;globals.uidDropPriv);
	}

finalize_it:
	RETiRet;
}


/* tell the rsysog core (including ourselfs) that the config load is done and
 * we need to prepare to move over to activate mode.
 */
static inline rsRetVal
tellCoreConfigLoadDone(void)
{
	DBGPRINTF("telling rsyslog core that config load for %p is done\n", loadConf);
	return glblDoneLoadCnf();
}


/* Tell input modules that the config parsing stage is over.  */
static rsRetVal
tellModulesConfigLoadDone(void)
{
	cfgmodules_etry_t *node;

	DBGPRINTF("telling modules that config load for %p is done\n", loadConf);
	node = module.GetNxtCnfType(loadConf, NULL, eMOD_ANY);
	while(node != NULL) {
		DBGPRINTF("beginCnfLoad(%p) for module '%s'\n", node-&gt;pMod-&gt;beginCnfLoad, node-&gt;pMod-&gt;pszName);
		if(node-&gt;pMod-&gt;beginCnfLoad != NULL) {
			DBGPRINTF("calling endCnfLoad() for module '%s'\n", node-&gt;pMod-&gt;pszName);
			node-&gt;pMod-&gt;endCnfLoad(node-&gt;modCnf);
		}
		node = module.GetNxtCnfType(loadConf, node, eMOD_ANY); // loadConf -&gt; runConf
	}

	return RS_RET_OK; /* intentional: we do not care about module errors */
}


/* Tell input modules to verify config object */
static rsRetVal
tellModulesCheckConfig(void)
{
	cfgmodules_etry_t *node;
	rsRetVal localRet;

	DBGPRINTF("telling modules to check config %p\n", loadConf);
	node = module.GetNxtCnfType(loadConf, NULL, eMOD_ANY);
	while(node != NULL) {
		if(node-&gt;pMod-&gt;beginCnfLoad != NULL) {
			localRet = node-&gt;pMod-&gt;checkCnf(node-&gt;modCnf);
			DBGPRINTF("module %s tells us config can %sbe activated\n",
					  node-&gt;pMod-&gt;pszName, (localRet == RS_RET_OK) ? "" : "NOT ");
			if(localRet == RS_RET_OK) {
				node-&gt;canActivate = 1;
			} else {
				node-&gt;canActivate = 0;
			}
		}
		node = module.GetNxtCnfType(loadConf, node, eMOD_ANY); // runConf -&gt; loadConf
	}

	return RS_RET_OK; /* intentional: we do not care about module errors */
}


/* Tell modules to activate current running config (pre privilege drop) */
static rsRetVal
tellModulesActivateConfigPrePrivDrop(void)
{
	cfgmodules_etry_t *node;
	rsRetVal localRet;

	DBGPRINTF("telling modules to activate config (before dropping privs) %p\n", runConf);
	node = module.GetNxtCnfType(runConf, NULL, eMOD_ANY);
	while(node != NULL) {
		if(   node-&gt;pMod-&gt;beginCnfLoad != NULL
		   &amp;&amp; node-&gt;pMod-&gt;activateCnfPrePrivDrop != NULL
		   &amp;&amp; node-&gt;canActivate) {
			DBGPRINTF("pre priv drop activating config %p for module %s\n",
				  runConf, node-&gt;pMod-&gt;pszName);
			localRet = node-&gt;pMod-&gt;activateCnfPrePrivDrop(node-&gt;modCnf);
			if(localRet != RS_RET_OK) {
				LogError(0, localRet, "activation of module %s failed",
						node-&gt;pMod-&gt;pszName);
			node-&gt;canActivate = 0; /* in a sense, could not activate... */
			}
		}
		node = module.GetNxtCnfType(runConf, node, eMOD_ANY);
	}

	return RS_RET_OK; /* intentional: we do not care about module errors */
}


/* Tell modules to activate current running config */
static rsRetVal
tellModulesActivateConfig(void)
{
	cfgmodules_etry_t *node;
	rsRetVal localRet;

	DBGPRINTF("telling modules to activate config %p\n", runConf);
	node = module.GetNxtCnfType(runConf, NULL, eMOD_ANY);
	while(node != NULL) {
		if(node-&gt;pMod-&gt;beginCnfLoad != NULL &amp;&amp; node-&gt;canActivate) {
			DBGPRINTF("activating config %p for module %s\n",
				  runConf, node-&gt;pMod-&gt;pszName);
			localRet = node-&gt;pMod-&gt;activateCnf(node-&gt;modCnf);
			if(localRet != RS_RET_OK) {
				LogError(0, localRet, "activation of module %s failed",
						node-&gt;pMod-&gt;pszName);
			node-&gt;canActivate = 0; /* in a sense, could not activate... */
			}
		}
		node = module.GetNxtCnfType(runConf, node, eMOD_ANY);
	}

	return RS_RET_OK; /* intentional: we do not care about module errors */
}


/* Actually run the input modules.  This happens after privileges are dropped,
 * if that is requested.
 */
static rsRetVal
runInputModules(void)
{
	cfgmodules_etry_t *node;
	int bNeedsCancel;

	node = module.GetNxtCnfType(runConf, NULL, eMOD_IN);
	while(node != NULL) {
		if(node-&gt;canRun) {
			bNeedsCancel = (node-&gt;pMod-&gt;isCompatibleWithFeature(sFEATURENonCancelInputTermination)
			== RS_RET_OK) ? 0 : 1;
			DBGPRINTF("running module %s with config %p, term mode: %s\n", node-&gt;pMod-&gt;pszName, node,
				  bNeedsCancel ? "cancel" : "cooperative/SIGTTIN");
			thrdCreate(node-&gt;pMod-&gt;mod.im.runInput, node-&gt;pMod-&gt;mod.im.afterRun, bNeedsCancel,
			           (node-&gt;pMod-&gt;cnfName == NULL) ? node-&gt;pMod-&gt;pszName : node-&gt;pMod-&gt;cnfName);
		}
		node = module.GetNxtCnfType(runConf, node, eMOD_IN);
	}

	return RS_RET_OK; /* intentional: we do not care about module errors */
}


/* Make the modules check if they are ready to start.
 */
static rsRetVal
startInputModules(void)
{
	DEFiRet;
	cfgmodules_etry_t *node;

	node = module.GetNxtCnfType(runConf, NULL, eMOD_IN);
	while(node != NULL) {
		if(node-&gt;canActivate) {
			iRet = node-&gt;pMod-&gt;mod.im.willRun();
			node-&gt;canRun = (iRet == RS_RET_OK);
			if(!node-&gt;canRun) {
				DBGPRINTF("module %s will not run, iRet %d\n", node-&gt;pMod-&gt;pszName, iRet);
			}
		} else {
			node-&gt;canRun = 0;
		}
		node = module.GetNxtCnfType(runConf, node, eMOD_IN);
	}

	return RS_RET_OK; /* intentional: we do not care about module errors */
}

/* load the main queue */
static rsRetVal
loadMainQueue(void)
{
	DEFiRet;
	struct cnfobj *mainqCnfObj;

	mainqCnfObj = glbl.GetmainqCnfObj();
	DBGPRINTF("loadMainQueue: mainq cnf obj ptr is %p\n", mainqCnfObj);
	/* create message queue */
	iRet = createMainQueue(&amp;loadConf-&gt;pMsgQueue, UCHAR_CONSTANT("main Q"),
		    		(mainqCnfObj == NULL) ? NULL : mainqCnfObj-&gt;nvlst);
	if (iRet == RS_RET_OK) {
		if (runConf != NULL) { /* dynamic config reload */
			int areEqual = queuesEqual(loadConf-&gt;pMsgQueue, runConf-&gt;pMsgQueue);
			DBGPRINTF("Comparison of old and new main queues: %d\n", areEqual);
			if (areEqual) { /* content of the new main queue is the same as it was in previous conf */
				qqueueDestruct(&amp;loadConf-&gt;pMsgQueue);
				loadConf-&gt;pMsgQueue = runConf-&gt;pMsgQueue;
			}
		}
	}

	if(iRet != RS_RET_OK) {
		/* no queue is fatal, we need to give up in that case... */
		fprintf(stderr, "fatal error %d: could not create message queue - rsyslogd can not run!\n", iRet);
		FINALIZE;
	}
finalize_it:
	glblDestructMainqCnfObj();
	RETiRet;
}

/* activate the main queue */
static rsRetVal
activateMainQueue(void)
{
	DEFiRet;

	DBGPRINTF("activateMainQueue: will try to activate main queue %p\n", runConf-&gt;pMsgQueue);

	iRet = startMainQueue(runConf, runConf-&gt;pMsgQueue);
	if(iRet != RS_RET_OK) {
		/* no queue is fatal, we need to give up in that case... */
		fprintf(stderr, "fatal error %d: could not create message queue - rsyslogd can not run!\n", iRet);
		FINALIZE;
	}

	if(runConf-&gt;globals.mainQ.MainMsgQueType == QUEUETYPE_DIRECT) {
		PREFER_STORE_0_TO_INT(&amp;bHaveMainQueue);
	} else {
		PREFER_STORE_1_TO_INT(&amp;bHaveMainQueue);
	}
	DBGPRINTF("Main processing queue is initialized and running\n");
finalize_it:
	RETiRet;
}


/* set the processes umask (upon configuration request) */
static inline rsRetVal
setUmask(int iUmask)
{
	if(iUmask != -1) {
		umask(iUmask);
		DBGPRINTF("umask set to 0%3.3o.\n", iUmask);
	}

	return RS_RET_OK;
}

/* Remove resources from previous config */
static void
cleanupOldCnf(rsconf_t *cnf)
{
	if (cnf == NULL)
		FINALIZE;

	if (runConf-&gt;pMsgQueue != cnf-&gt;pMsgQueue)
		qqueueDestruct(&amp;cnf-&gt;pMsgQueue);

finalize_it:
	return;
}


/* Activate an already-loaded configuration. The configuration will become
 * the new running conf (if successful). Note that in theory this method may
 * be called when there already is a running conf. In practice, the current
 * version of rsyslog does not support this. Future versions probably will.
 * Begun 2011-04-20, rgerhards
 */
static rsRetVal
activate(rsconf_t *cnf)
{
	DEFiRet;
	rsconf_t *runCnfOld = runConf;

	/* at this point, we "switch" over to the running conf */
	runConf = cnf;
	loadConf = NULL;
#	if	0 /* currently the DAG is not supported -- code missing! */
	/* TODO: re-enable this functionality some time later! */
	/* check if we need to generate a config DAG and, if so, do that */
	if(ourConf-&gt;globals.pszConfDAGFile != NULL)
		generateConfigDAG(ourConf-&gt;globals.pszConfDAGFile);
#	endif
	setUmask(cnf-&gt;globals.umask);

	/* the output part and the queue is now ready to run. So it is a good time
	 * to initialize the inputs. Please note that the net code above should be
	 * shuffled to down here once we have everything in input modules.
	 * rgerhards, 2007-12-14
	 * NOTE: as of 2009-06-29, the input modules are initialized, but not yet run.
	 * Keep in mind. though, that the outputs already run if the queue was
	 * persisted to disk. -- rgerhards
	 */
	tellModulesActivateConfigPrePrivDrop();

	CHKiRet(dropPrivileges(cnf));

	tellModulesActivateConfig();
	startInputModules();
	CHKiRet(activateActions());
	CHKiRet(activateRulesetQueues());
	CHKiRet(activateMainQueue());
	/* finally let the inputs run... */
	runInputModules();
	qqueueDoneLoadCnf(); /* we no longer need config-load-only data structures */

	dbgprintf("configuration %p activated\n", cnf);
	cleanupOldCnf(runCnfOld);

finalize_it:
	RETiRet;
}


/* -------------------- some legacy config handlers --------------------
 * TODO: move to conf.c?
 */

/* legacy config system: set the action resume interval */
static rsRetVal setActionResumeInterval(void __attribute__((unused)) *pVal, int iNewVal)
{
	return actionSetGlobalResumeInterval(iNewVal);
}


/* Switch the default ruleset (that, what servcies bind to if nothing specific
 * is specified).
 * rgerhards, 2009-06-12
 */
static rsRetVal
setDefaultRuleset(void __attribute__((unused)) *pVal, uchar *pszName)
{
	DEFiRet;

	CHKiRet(ruleset.SetDefaultRuleset(ourConf, pszName));

finalize_it:
	free(pszName); /* no longer needed */
	RETiRet;
}


/* Switch to either an already existing rule set or start a new one. The
 * named rule set becomes the new "current" rule set (what means that new
 * actions are added to it).
 * rgerhards, 2009-06-12
 */
static rsRetVal
setCurrRuleset(void __attribute__((unused)) *pVal, uchar *pszName)
{
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;

	localRet = ruleset.SetCurrRuleset(ourConf, pszName);

	if(localRet == RS_RET_NOT_FOUND) {
		DBGPRINTF("begin new current rule set '%s'\n", pszName);
		CHKiRet(ruleset.Construct(&amp;pRuleset));
		CHKiRet(ruleset.SetName(pRuleset, pszName));
		CHKiRet(ruleset.ConstructFinalize(ourConf, pRuleset));
		rulesetSetCurrRulesetPtr(pRuleset);
	} else {
		ABORT_FINALIZE(localRet);
	}

finalize_it:
	free(pszName); /* no longer needed */
	RETiRet;
}


/* set the main message queue mode
 * rgerhards, 2008-01-03
 */
static rsRetVal setMainMsgQueType(void __attribute__((unused)) *pVal, uchar *pszType)
{
	DEFiRet;

	if (!strcasecmp((char *) pszType, "fixedarray")) {
		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
		DBGPRINTF("main message queue type set to FIXED_ARRAY\n");
	} else if (!strcasecmp((char *) pszType, "linkedlist")) {
		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_LINKEDLIST;
		DBGPRINTF("main message queue type set to LINKEDLIST\n");
	} else if (!strcasecmp((char *) pszType, "disk")) {
		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_DISK;
		DBGPRINTF("main message queue type set to DISK\n");
	} else if (!strcasecmp((char *) pszType, "direct")) {
		loadConf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_DIRECT;
		DBGPRINTF("main message queue type set to DIRECT (no queueing at all)\n");
	} else {
		LogError(0, RS_RET_INVALID_PARAMS, "unknown mainmessagequeuetype parameter: %s",
			(char *) pszType);
		iRet = RS_RET_INVALID_PARAMS;
	}
	free(pszType); /* no longer needed */

	RETiRet;
}


/* -------------------- end legacy config handlers -------------------- */


/* set the processes max number ob files (upon configuration request)
 * 2009-04-14 rgerhards
 */
static rsRetVal setMaxFiles(void __attribute__((unused)) *pVal, int iFiles)
{
// TODO this must use a local var, then carry out action during activate!
	struct rlimit maxFiles;
	char errStr[1024];
	DEFiRet;

	maxFiles.rlim_cur = iFiles;
	maxFiles.rlim_max = iFiles;

	if(setrlimit(RLIMIT_NOFILE, &amp;maxFiles) &lt; 0) {
		/* NOTE: under valgrind, we seem to be unable to extend the size! */
		rs_strerror_r(errno, errStr, sizeof(errStr));
		LogError(0, RS_RET_ERR_RLIM_NOFILE, "could not set process file limit to %d: %s "
			"[kernel max %ld]", iFiles, errStr, (long) maxFiles.rlim_max);
		ABORT_FINALIZE(RS_RET_ERR_RLIM_NOFILE);
	}
#ifdef USE_UNLIMITED_SELECT
	glbl.SetFdSetSize(howmany(iFiles, __NFDBITS) * sizeof (fd_mask));
#endif
	DBGPRINTF("Max number of files set to %d [kernel max %ld].\n", iFiles, (long) maxFiles.rlim_max);

finalize_it:
	RETiRet;
}


/* legacy config system: reset config variables to default values.  */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	free(loadConf-&gt;globals.mainQ.pszMainMsgQFName);

	cnfSetDefaults(loadConf);

	return RS_RET_OK;
}


/* legacy config system: set the action resume interval */
static rsRetVal
setModDir(void __attribute__((unused)) *pVal, uchar* pszNewVal)
{
	DEFiRet;
	iRet = module.SetModDir(pszNewVal);
	free(pszNewVal);
	RETiRet;
}


/* "load" a build in module and register it for the current load config */
static rsRetVal
regBuildInModule(rsRetVal (*modInit)(), uchar *name, void *pModHdlr)
{
	cfgmodules_etry_t *pNew;
	cfgmodules_etry_t *pLast;
	modInfo_t *pMod;
	DEFiRet;
	CHKiRet(module.doModInit(modInit, name, pModHdlr, &amp;pMod));
	readyModForCnf(pMod, &amp;pNew, &amp;pLast);
	addModToCnfList(&amp;pNew, pLast);
finalize_it:
	RETiRet;
}


/* load build-in modules
 * very first version begun on 2007-07-23 by rgerhards
 */
static rsRetVal
loadBuildInModules(void)
{
	DEFiRet;

	CHKiRet(regBuildInModule(modInitFile, UCHAR_CONSTANT("builtin:omfile"), NULL));
	CHKiRet(regBuildInModule(modInitPipe, UCHAR_CONSTANT("builtin:ompipe"), NULL));
	CHKiRet(regBuildInModule(modInitShell, UCHAR_CONSTANT("builtin-shell"), NULL));
	CHKiRet(regBuildInModule(modInitDiscard, UCHAR_CONSTANT("builtin:omdiscard"), NULL));
#	ifdef SYSLOG_INET
	CHKiRet(regBuildInModule(modInitFwd, UCHAR_CONSTANT("builtin:omfwd"), NULL));
#	endif

	/* dirty, but this must be for the time being: the usrmsg module must always be
	 * loaded as last module. This is because it processes any type of action selector.
	 * If we load it before other modules, these others will never have a chance of
	 * working with the config file. We may change that implementation so that a user name
	 * must start with an alnum, that would definitely help (but would it break backwards
	 * compatibility?). * rgerhards, 2007-07-23
	 * User names now must begin with:
	 *   [a-zA-Z0-9_.]
	 */
	CHKiRet(regBuildInModule(modInitUsrMsg, (uchar*) "builtin:omusrmsg", NULL));

	/* load build-in parser modules */
	CHKiRet(regBuildInModule(modInitpmrfc5424, UCHAR_CONSTANT("builtin:pmrfc5424"), NULL));
	CHKiRet(regBuildInModule(modInitpmrfc3164, UCHAR_CONSTANT("builtin:pmrfc3164"), NULL));

	/* and set default parser modules. Order is *very* important, legacy
	 * (3164) parser needs to go last! */
	CHKiRet(parser.AddDfltParser(UCHAR_CONSTANT("rsyslog.rfc5424")));
	CHKiRet(parser.AddDfltParser(UCHAR_CONSTANT("rsyslog.rfc3164")));

	/* load build-in strgen modules */
	CHKiRet(regBuildInModule(modInitsmfile, UCHAR_CONSTANT("builtin:smfile"), NULL));
	CHKiRet(regBuildInModule(modInitsmtradfile, UCHAR_CONSTANT("builtin:smtradfile"), NULL));
	CHKiRet(regBuildInModule(modInitsmfwd, UCHAR_CONSTANT("builtin:smfwd"), NULL));
	CHKiRet(regBuildInModule(modInitsmtradfwd, UCHAR_CONSTANT("builtin:smtradfwd"), NULL));

finalize_it:
	if(iRet != RS_RET_OK) {
		/* we need to do fprintf, as we do not yet have an error reporting system
		 * in place.
		 */
		fprintf(stderr, "fatal error: could not activate built-in modules. Error code %d.\n",
			iRet);
	}
	RETiRet;
}


/* intialize the legacy config system */
static rsRetVal
initLegacyConf(void)
{
	DEFiRet;
	uchar *pTmp;
	ruleset_t *pRuleset;

	DBGPRINTF("doing legacy config system init\n");
	/* construct the default ruleset */
	ruleset.Construct(&amp;pRuleset);
	ruleset.SetName(pRuleset, UCHAR_CONSTANT("RSYSLOG_DefaultRuleset"));
	ruleset.ConstructFinalize(loadConf, pRuleset);
	rulesetSetCurrRulesetPtr(pRuleset);

	/* now register config handlers */
	CHKiRet(regCfSysLineHdlr((uchar *)"sleep", 0, eCmdHdlrGoneAway,
		NULL, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"logrsyslogstatusmessages", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.bLogStatusMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"errormessagestostderr", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.bErrMsgToStderr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"abortonuncleanconfig", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.bAbortOnUncleanConfig, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"repeatedmsgreduction", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.bReduceRepeatMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"debugprinttemplatelist", 0, eCmdHdlrBinary,
		NULL, &amp;(loadConf-&gt;globals.bDebugPrintTemplateList), NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"debugprintmodulelist", 0, eCmdHdlrBinary,
		NULL, &amp;(loadConf-&gt;globals.bDebugPrintModuleList), NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"debugprintcfsyslinehandlerlist", 0, eCmdHdlrBinary,
		 NULL, &amp;(loadConf-&gt;globals.bDebugPrintCfSysLineHandlerList), NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptouser", 0, eCmdHdlrUID,
		NULL, &amp;loadConf-&gt;globals.uidDropPriv, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptouserid", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.uidDropPriv, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptogroup", 0, eCmdHdlrGID,
		NULL, &amp;loadConf-&gt;globals.gidDropPriv, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"privdroptogroupid", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.gidDropPriv, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"generateconfiggraph", 0, eCmdHdlrGetWord,
		NULL, &amp;loadConf-&gt;globals.pszConfDAGFile, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"umask", 0, eCmdHdlrFileCreateMode,
		NULL, &amp;loadConf-&gt;globals.umask, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"maxopenfiles", 0, eCmdHdlrInt,
		setMaxFiles, NULL, NULL));

	CHKiRet(regCfSysLineHdlr((uchar *)"actionresumeinterval", 0, eCmdHdlrInt,
		setActionResumeInterval, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"modload", 0, eCmdHdlrCustomHandler,
		conf.doModLoad, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"defaultruleset", 0, eCmdHdlrGetWord,
		setDefaultRuleset, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"ruleset", 0, eCmdHdlrGetWord,
		setCurrRuleset, NULL, NULL));

	/* handler for "larger" config statements (tie into legacy conf system) */
	CHKiRet(regCfSysLineHdlr((uchar *)"template", 0, eCmdHdlrCustomHandler,
		conf.doNameLine, (void*)DIR_TEMPLATE, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"outchannel", 0, eCmdHdlrCustomHandler,
		conf.doNameLine, (void*)DIR_OUTCHANNEL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"allowedsender", 0, eCmdHdlrCustomHandler,
		conf.doNameLine, (void*)DIR_ALLOWEDSENDER, NULL));

	/* the following are parameters for the main message queue. I have the
	 * strong feeling that this needs to go to a different space, but that
	 * feeling may be wrong - we'll see how things evolve.
	 * rgerhards, 2011-04-21
	 */
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuefilename", 0, eCmdHdlrGetWord,
		NULL, &amp;loadConf-&gt;globals.mainQ.pszMainMsgQFName, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuesize", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuehighwatermark", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQHighWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuelowwatermark", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQLowWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuediscardmark", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQDiscardMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuediscardseverity", 0, eCmdHdlrSeverity,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQDiscardSeverity, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuecheckpointinterval", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQPersistUpdCnt, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuesyncqueuefiles", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.mainQ.bMainMsgQSyncQeueFiles, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetype", 0, eCmdHdlrGetWord,
		setMainMsgQueType, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueueworkerthreads", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueNumWorkers, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetimeoutshutdown", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoQShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetimeoutactioncompletion", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoActShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuetimeoutenqueue", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoEnq, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueueworkertimeoutthreadshutdown", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQtoWrkShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeueslowdown", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQDeqSlowdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueueworkerthreadminimummessages", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQWrkMinMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuemaxfilesize", 0, eCmdHdlrSize,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueMaxFileSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeuebatchsize", 0, eCmdHdlrSize,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueDeqBatchSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuemaxdiskspace", 0, eCmdHdlrSize,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueMaxDiskSpace, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuesaveonshutdown", 0, eCmdHdlrBinary,
		NULL, &amp;loadConf-&gt;globals.mainQ.bMainMsgQSaveOnShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeuetimebegin", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueDeqtWinFromHr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"mainmsgqueuedequeuetimeend", 0, eCmdHdlrInt,
		NULL, &amp;loadConf-&gt;globals.mainQ.iMainMsgQueueDeqtWinToHr, NULL));
	/* moddir is a bit hard problem -- because it actually needs to
	 * modify a setting that is specific to module.c. The important point
	 * is that this action MUST actually be carried out during config load,
	 * because we must load modules in order to get their config extensions
	 * (no way around).
	 * TODO: think about a clean solution
	 */
	CHKiRet(regCfSysLineHdlr((uchar *)"moddir", 0, eCmdHdlrGetWord,
		setModDir, NULL, NULL));
<a name="1"></a>
	/* finally, the reset handler */
	CHKiRet(regCfSysLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		resetConfigVariables, NULL, NULL));

	/* initialize the build-in templates */
	pTmp = template_DebugFormat;
	tplAddLine(ourConf, "RSYSLOG_DebugFormat", &amp;pTmp);
	pTmp = template_SyslogProtocol23Format;
	tplAddLine(ourConf, "RSYSLOG_SyslogProtocol23Format", &amp;pTmp);
	pTmp = template_SyslogRFC5424Format;
	tplAddLine(ourConf, "RSYSLOG_SyslogRFC5424Format", &amp;pTmp);
	pTmp = template_FileFormat; /* new format for files with high-precision stamp */
	tplAddLine(ourConf, "RSYSLOG_FileFormat", &amp;pTmp);
	pTmp = template_TraditionalFileFormat;
	tplAddLine(ourConf, "RSYSLOG_TraditionalFileFormat", &amp;pTmp);
	pTmp = template_WallFmt;
	tplAddLine(ourConf, " WallFmt", &amp;pTmp);
	pTmp = template_ForwardFormat;
	tplAddLine(ourConf, "RSYSLOG_ForwardFormat", &amp;pTmp);
	pTmp = template_TraditionalForwardFormat;
	tplAddLine(ourConf, "RSYSLOG_TraditionalForwardFormat", &amp;pTmp);
	pTmp = template_StdUsrMsgFmt;
	tplAddLine(ourConf, " StdUsrMsgFmt", &amp;pTmp);
	pTmp = template_StdDBFmt;
	tplAddLine(ourConf, " StdDBFmt", &amp;pTmp);
	pTmp = template_SysklogdFileFormat;
	tplAddLine(ourConf, "RSYSLOG_SysklogdFileFormat", &amp;pTmp);
	pTmp = template_StdPgSQLFmt;
	tplAddLine(ourConf, " StdPgSQLFmt", &amp;pTmp);
	pTmp = template_StdJSONFmt;
	tplAddLine(ourConf, " StdJSONFmt", &amp;pTmp);
	pTmp = template_FullJSONFmt;
	tplAddLine(ourConf, " FullJSONFmt", &amp;pTmp);
	pTmp = template_StdClickHouseFmt;
	tplAddLine(ourConf, " StdClickHouseFmt", &amp;pTmp);
	pTmp = template_spoofadr;</b></font>
	tplLastStaticInit(ourConf, tplAddLine(ourConf, "RSYSLOG_omudpspoofDfltSourceTpl", &amp;pTmp));

finalize_it:
	RETiRet;
}


/* validate the configuration pointed by conf, generate error messages, do
 * optimizations, etc, etc,...
 */
static rsRetVal
validateConf(rsconf_t *cnf)
{
	DEFiRet;

	/* some checks */
	if(cnf-&gt;globals.mainQ.iMainMsgQueueNumWorkers &lt; 1) {
		LogError(0, NO_ERRCODE, "$MainMsgQueueNumWorkers must be at least 1! Set to 1.\n");
		cnf-&gt;globals.mainQ.iMainMsgQueueNumWorkers = 1;
	}

	if(cnf-&gt;globals.mainQ.MainMsgQueType == QUEUETYPE_DISK) {
		errno = 0;	/* for logerror! */
		if(glbl.GetWorkDir(cnf) == NULL) {
			LogError(0, NO_ERRCODE, "No $WorkDirectory specified - can not run main "
					"message queue in 'disk' mode. Using 'FixedArray' instead.\n");
			cnf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
		}
		if(cnf-&gt;globals.mainQ.pszMainMsgQFName == NULL) {
			LogError(0, NO_ERRCODE, "No $MainMsgQueueFileName specified - can not run main "
				"message queue in 'disk' mode. Using 'FixedArray' instead.\n");
			cnf-&gt;globals.mainQ.MainMsgQueType = QUEUETYPE_FIXED_ARRAY;
		}
	}
	RETiRet;
}


/* Load a configuration. This will do all necessary steps to create
 * the in-memory representation of the configuration, including support
 * for multiple configuration languages.
 * Note that to support the legacy language we must provide some global
 * object that holds the currently-being-loaded config ptr.
 * Begun 2011-04-20, rgerhards
 */
static rsRetVal
load(rsconf_t **cnf, uchar *confFile)
{
	int iNbrActions = 0;
	int r;
	rsRetVal delayed_iRet = RS_RET_OK;
	DEFiRet;

	CHKiRet(rsconfConstruct(&amp;loadConf));
	ourConf = loadConf; // TODO: remove, once ourConf is gone!

	CHKiRet(loadBuildInModules());
	CHKiRet(initLegacyConf());

	/* open the configuration file */
	r = cnfSetLexFile((char*)confFile);
	if(r == 0) {
		r = yyparse();
		conf.GetNbrActActions(loadConf, &amp;iNbrActions);
	}

	/* we run the optimizer even if we have an error, as it may spit out
	 * additional error messages and we want to see these even if we abort.
	 */
	rulesetOptimizeAll(loadConf);

	if(r == 1) {
		LogError(0, RS_RET_CONF_PARSE_ERROR, "could not interpret master "
			"config file '%s'.", confFile);
		/* we usually keep running with the failure, so we need to continue for now */
		delayed_iRet = RS_RET_CONF_PARSE_ERROR;
	} else if(r == 2) { /* file not found? */
		LogError(errno, RS_RET_CONF_FILE_NOT_FOUND, "could not open config file '%s'",
		        confFile);
		ABORT_FINALIZE(RS_RET_CONF_FILE_NOT_FOUND);
	} else if(    (iNbrActions == 0)
		  &amp;&amp; !(iConfigVerify &amp; CONF_VERIFY_PARTIAL_CONF)) {
		LogError(0, RS_RET_NO_ACTIONS, "there are no active actions configured. "
			"Inputs would run, but no output whatsoever were created.");
		ABORT_FINALIZE(RS_RET_NO_ACTIONS);
	}
	tellLexEndParsing();
	DBGPRINTF("Number of actions in this configuration: %d\n", loadConf-&gt;actions.iActionNbr);

	CHKiRet(tellCoreConfigLoadDone());
	tellModulesConfigLoadDone();

	tellModulesCheckConfig();
	CHKiRet(validateConf(loadConf));
	CHKiRet(loadMainQueue());

	/* we are done checking the config - now validate if we should actually run or not.
	 * If not, terminate. -- rgerhards, 2008-07-25
	 * TODO: iConfigVerify -- should it be pulled from the config, or leave as is (option)?
	 */
	if(iConfigVerify) {
		if(iRet == RS_RET_OK)
			iRet = RS_RET_VALIDATION_RUN;
		FINALIZE;
	}

	/* all OK, pass loaded conf to caller */
	*cnf = loadConf;
	// TODO: enable this once all config code is moved to here!	loadConf = NULL;

	dbgprintf("rsyslog finished loading master config %p\n", loadConf);
	rsconfDebugPrint(loadConf);

finalize_it:
	if(iRet == RS_RET_OK &amp;&amp; delayed_iRet != RS_RET_OK) {
		iRet = delayed_iRet;
	}
	RETiRet;
}


/* queryInterface function
 */
BEGINobjQueryInterface(rsconf)
CODESTARTobjQueryInterface(rsconf)
	if(pIf-&gt;ifVersion != rsconfCURR_IF_VERSION) { /* check for current version, increment on each change */
		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}

	/* ok, we have the right interface, so let's fill it
	 * Please note that we may also do some backwards-compatibility
	 * work here (if we can support an older interface version - that,
	 * of course, also affects the "if" above).
	 */
	pIf-&gt;Destruct = rsconfDestruct;
	pIf-&gt;DebugPrint = rsconfDebugPrint;
	pIf-&gt;Load = load;
	pIf-&gt;Activate = activate;
finalize_it:
ENDobjQueryInterface(rsconf)


/* Initialize the rsconf class. Must be called as the very first method
 * before anything else is called inside this class.
 */
BEGINObjClassInit(rsconf, 1, OBJ_IS_CORE_MODULE) /* class, version */
	/* request objects we use */
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(module, CORE_COMPONENT));
	CHKiRet(objUse(conf, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));

	/* now set our own handlers */
	OBJSetMethodHandler(objMethod_DEBUGPRINT, rsconfDebugPrint);
	OBJSetMethodHandler(objMethod_CONSTRUCTION_FINALIZER, rsconfConstructFinalize);
ENDObjClassInit(rsconf)


/* De-initialize the rsconf class.
 */
BEGINObjClassExit(rsconf, OBJ_IS_CORE_MODULE) /* class, version */
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(module, CORE_COMPONENT);
	objRelease(conf, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(parser, CORE_COMPONENT);
ENDObjClassExit(rsconf)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
