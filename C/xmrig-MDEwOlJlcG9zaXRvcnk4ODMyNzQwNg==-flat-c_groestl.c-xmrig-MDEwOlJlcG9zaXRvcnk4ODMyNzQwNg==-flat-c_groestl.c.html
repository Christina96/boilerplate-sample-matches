
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 68, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-c_groestl.c</h3>
            <pre><code>1  #include "c_groestl.h"
2  #include "groestl_tables.h"
3  #define P_TYPE 0
4  #define Q_TYPE 1
5  const uint8_t shift_Values[2][8] = {{0,1,2,3,4,5,6,7},{1,3,5,7,0,2,4,6}};
6  const uint8_t indices_cyclic[15] = {0,1,2,3,4,5,6,7,0,1,2,3,4,5,6};
7  #define ROTATE_COLUMN_DOWN(v1, v2, amount_bytes, temp_var) {temp_var = (v1<<(8*amount_bytes))|(v2>>(8*(4-amount_bytes))); \
8  															v2 = (v2<<(8*amount_bytes))|(v1>>(8*(4-amount_bytes))); \
9  															v1 = temp_var;}
10  #define COLUMN(x,y,i,c0,c1,c2,c3,c4,c5,c6,c7,tv1,tv2,tu,tl,t)				\
11     tu = T[2*(uint32_t)x[4*c0+0]];			    \
12     tl = T[2*(uint32_t)x[4*c0+0]+1];		    \
13     tv1 = T[2*(uint32_t)x[4*c1+1]];			\
14     tv2 = T[2*(uint32_t)x[4*c1+1]+1];			\
15     ROTATE_COLUMN_DOWN(tv1,tv2,1,t)	\
16     tu ^= tv1;						\
17     tl ^= tv2;						\
18     tv1 = T[2*(uint32_t)x[4*c2+2]];			\
19     tv2 = T[2*(uint32_t)x[4*c2+2]+1];			\
20     ROTATE_COLUMN_DOWN(tv1,tv2,2,t)	\
21     tu ^= tv1;						\
22     tl ^= tv2;   					\
23     tv1 = T[2*(uint32_t)x[4*c3+3]];			\
24     tv2 = T[2*(uint32_t)x[4*c3+3]+1];			\
25     ROTATE_COLUMN_DOWN(tv1,tv2,3,t)	\
26     tu ^= tv1;						\
27     tl ^= tv2;						\
28     tl ^= T[2*(uint32_t)x[4*c4+0]];			\
29     tu ^= T[2*(uint32_t)x[4*c4+0]+1];			\
30     tv1 = T[2*(uint32_t)x[4*c5+1]];			\
31     tv2 = T[2*(uint32_t)x[4*c5+1]+1];			\
32     ROTATE_COLUMN_DOWN(tv1,tv2,1,t)	\
33     tl ^= tv1;						\
34     tu ^= tv2;						\
35     tv1 = T[2*(uint32_t)x[4*c6+2]];			\
36     tv2 = T[2*(uint32_t)x[4*c6+2]+1];			\
37     ROTATE_COLUMN_DOWN(tv1,tv2,2,t)	\
38     tl ^= tv1;						\
<span onclick='openModal()' class='match'>39     tu ^= tv2;   					\
40     tv1 = T[2*(uint32_t)x[4*c7+3]];			\
41     tv2 = T[2*(uint32_t)x[4*c7+3]+1];			\
42     ROTATE_COLUMN_DOWN(tv1,tv2,3,t)	\
43     tl ^= tv1;						\
44     tu ^= tv2;						\
45     y[i] = tu;						\
</span>46     y[i+1] = tl;
47  static void RND512P(uint8_t *x, uint32_t *y, uint32_t r) {
48    uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
49    uint32_t* x32 = (uint32_t*)x;
50    x32[ 0] ^= 0x00000000^r;
51    x32[ 2] ^= 0x00000010^r;
52    x32[ 4] ^= 0x00000020^r;
53    x32[ 6] ^= 0x00000030^r;
54    x32[ 8] ^= 0x00000040^r;
55    x32[10] ^= 0x00000050^r;
56    x32[12] ^= 0x00000060^r;
57    x32[14] ^= 0x00000070^r;
58    COLUMN(x,y, 0,  0,  2,  4,  6,  9, 11, 13, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
59    COLUMN(x,y, 2,  2,  4,  6,  8, 11, 13, 15,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
60    COLUMN(x,y, 4,  4,  6,  8, 10, 13, 15,  1,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
61    COLUMN(x,y, 6,  6,  8, 10, 12, 15,  1,  3,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
62    COLUMN(x,y, 8,  8, 10, 12, 14,  1,  3,  5,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
63    COLUMN(x,y,10, 10, 12, 14,  0,  3,  5,  7,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
64    COLUMN(x,y,12, 12, 14,  0,  2,  5,  7,  9, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
65    COLUMN(x,y,14, 14,  0,  2,  4,  7,  9, 11, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
66  }
67  static void RND512Q(uint8_t *x, uint32_t *y, uint32_t r) {
68    uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
69    uint32_t* x32 = (uint32_t*)x;
70    x32[ 0] = ~x32[ 0];
71    x32[ 1] ^= 0xffffffff^r;
72    x32[ 2] = ~x32[ 2];
73    x32[ 3] ^= 0xefffffff^r;
74    x32[ 4] = ~x32[ 4];
75    x32[ 5] ^= 0xdfffffff^r;
76    x32[ 6] = ~x32[ 6];
77    x32[ 7] ^= 0xcfffffff^r;
78    x32[ 8] = ~x32[ 8];
79    x32[ 9] ^= 0xbfffffff^r;
80    x32[10] = ~x32[10];
81    x32[11] ^= 0xafffffff^r;
82    x32[12] = ~x32[12];
83    x32[13] ^= 0x9fffffff^r;
84    x32[14] = ~x32[14];
85    x32[15] ^= 0x8fffffff^r;
86    COLUMN(x,y, 0,  2,  6, 10, 14,  1,  5,  9, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
87    COLUMN(x,y, 2,  4,  8, 12,  0,  3,  7, 11, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
88    COLUMN(x,y, 4,  6, 10, 14,  2,  5,  9, 13,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
89    COLUMN(x,y, 6,  8, 12,  0,  4,  7, 11, 15,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
90    COLUMN(x,y, 8, 10, 14,  2,  6,  9, 13,  1,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
91    COLUMN(x,y,10, 12,  0,  4,  8, 11, 15,  3,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
92    COLUMN(x,y,12, 14,  2,  6, 10, 13,  1,  5,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
93    COLUMN(x,y,14,  0,  4,  8, 12, 15,  3,  7, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
94  }
95  static void F512(uint32_t *h, const uint32_t *m) {
96    int i;
97    uint32_t Ptmp[2*COLS512];
98    uint32_t Qtmp[2*COLS512];
99    uint32_t y[2*COLS512];
100    uint32_t z[2*COLS512];
101    for (i = 0; i < 2*COLS512; i++) {
102      z[i] = m[i];
103      Ptmp[i] = h[i]^m[i];
104    }
105    RND512Q((uint8_t*)z, y, 0x00000000);
106    RND512Q((uint8_t*)y, z, 0x01000000);
107    RND512Q((uint8_t*)z, y, 0x02000000);
108    RND512Q((uint8_t*)y, z, 0x03000000);
109    RND512Q((uint8_t*)z, y, 0x04000000);
110    RND512Q((uint8_t*)y, z, 0x05000000);
111    RND512Q((uint8_t*)z, y, 0x06000000);
112    RND512Q((uint8_t*)y, z, 0x07000000);
113    RND512Q((uint8_t*)z, y, 0x08000000);
114    RND512Q((uint8_t*)y, Qtmp, 0x09000000);
115    RND512P((uint8_t*)Ptmp, y, 0x00000000);
116    RND512P((uint8_t*)y, z, 0x00000001);
117    RND512P((uint8_t*)z, y, 0x00000002);
118    RND512P((uint8_t*)y, z, 0x00000003);
119    RND512P((uint8_t*)z, y, 0x00000004);
120    RND512P((uint8_t*)y, z, 0x00000005);
121    RND512P((uint8_t*)z, y, 0x00000006);
122    RND512P((uint8_t*)y, z, 0x00000007);
123    RND512P((uint8_t*)z, y, 0x00000008);
124    RND512P((uint8_t*)y, Ptmp, 0x00000009);
125    for (i = 0; i < 2*COLS512; i++) {
126      h[i] ^= Ptmp[i]^Qtmp[i];
127    }
128  }
129  static void Transform(groestlHashState *ctx,
130  	       const uint8_t *input,
131  	       int msglen) {
132    for (; msglen >= SIZE512;
133         msglen -= SIZE512, input += SIZE512) {
134      F512(ctx->chaining,(uint32_t*)input);
135      ctx->block_counter1++;
136      if (ctx->block_counter1 == 0) ctx->block_counter2++;
137    }
138  }
139  static void OutputTransformation(groestlHashState *ctx) {
140    int j;
141    uint32_t temp[2*COLS512];
142    uint32_t y[2*COLS512];
143    uint32_t z[2*COLS512];
144  	for (j = 0; j < 2*COLS512; j++) {
145  	  temp[j] = ctx->chaining[j];
146  	}
147  	RND512P((uint8_t*)temp, y, 0x00000000);
148  	RND512P((uint8_t*)y, z, 0x00000001);
149  	RND512P((uint8_t*)z, y, 0x00000002);
150  	RND512P((uint8_t*)y, z, 0x00000003);
151  	RND512P((uint8_t*)z, y, 0x00000004);
152  	RND512P((uint8_t*)y, z, 0x00000005);
153  	RND512P((uint8_t*)z, y, 0x00000006);
154  	RND512P((uint8_t*)y, z, 0x00000007);
155  	RND512P((uint8_t*)z, y, 0x00000008);
156  	RND512P((uint8_t*)y, temp, 0x00000009);
157  	for (j = 0; j < 2*COLS512; j++) {
158  	  ctx->chaining[j] ^= temp[j];
159  	}									
160  }
161  static void Init(groestlHashState* ctx) {
162    int i = 0;
163    for(;i<(SIZE512/sizeof(uint32_t));i++)
164    {
165  	ctx->chaining[i] = 0;
166    }
167    ctx->chaining[2*COLS512-1] = u32BIG((uint32_t)HASH_BIT_LEN);
168    ctx->buf_ptr = 0;
169    ctx->block_counter1 = 0;
170    ctx->block_counter2 = 0;
171    ctx->bits_in_last_byte = 0;
172  }
173  static void Update(groestlHashState* ctx,
174  		  const BitSequence* input,
175  		  DataLength databitlen) {
176    int index = 0;
177    int msglen = (int)(databitlen/8);
178    int rem = (int)(databitlen%8);
179    if (ctx->buf_ptr) {
180      while (ctx->buf_ptr < SIZE512 && index < msglen) {
181        ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
182      }
183      if (ctx->buf_ptr < SIZE512) {
184        if (rem) {
185  	ctx->bits_in_last_byte = rem;
186  	ctx->buffer[(int)ctx->buf_ptr++] = input[index];
187        }
188        return;
189      }
190      ctx->buf_ptr = 0;
191      Transform(ctx, ctx->buffer, SIZE512);
192    }
193    Transform(ctx, input+index, msglen-index);
194    index += ((msglen-index)/SIZE512)*SIZE512;
195    while (index < msglen) {
196      ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
197    }
198    if (rem) {
199      ctx->bits_in_last_byte = rem;
200      ctx->buffer[(int)ctx->buf_ptr++] = input[index];
201    }
202  }
203  #define BILB ctx->bits_in_last_byte
204  static void Final(groestlHashState* ctx,
205  		 BitSequence* output) {
206    int i, j = 0, hashbytelen = HASH_BIT_LEN/8;
207    uint8_t *s = (BitSequence*)ctx->chaining;
208    if (BILB) {
209      ctx->buffer[(int)ctx->buf_ptr-1] &= ((1<<BILB)-1)<<(8-BILB);
210      ctx->buffer[(int)ctx->buf_ptr-1] ^= 0x1<<(7-BILB);
211      BILB = 0;
212    }
213    else ctx->buffer[(int)ctx->buf_ptr++] = 0x80;
214    if (ctx->buf_ptr > SIZE512-LENGTHFIELDLEN) {
215      while (ctx->buf_ptr < SIZE512) {
216        ctx->buffer[(int)ctx->buf_ptr++] = 0;
217      }
218      Transform(ctx, ctx->buffer, SIZE512);
219      ctx->buf_ptr = 0;
220    }
221    while (ctx->buf_ptr < SIZE512-LENGTHFIELDLEN) {
222      ctx->buffer[(int)ctx->buf_ptr++] = 0;
223    }
224    ctx->block_counter1++;
225    if (ctx->block_counter1 == 0) ctx->block_counter2++;
226    ctx->buf_ptr = SIZE512;
227    while (ctx->buf_ptr > SIZE512-(int)sizeof(uint32_t)) {
228      ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter1;
229      ctx->block_counter1 >>= 8;
230    }
231    while (ctx->buf_ptr > SIZE512-LENGTHFIELDLEN) {
232      ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter2;
233      ctx->block_counter2 >>= 8;
234    }
235    Transform(ctx, ctx->buffer, SIZE512);
236    OutputTransformation(ctx);
237    for (i = SIZE512-hashbytelen; i < SIZE512; i++,j++) {
238      output[j] = s[i];
239    }
240    for (i = 0; i < COLS512; i++) {
241      ctx->chaining[i] = 0;
242    }
243    for (i = 0; i < SIZE512; i++) {
244      ctx->buffer[i] = 0;
245    }
246  }
247  void groestl(const BitSequence* data,
248  		DataLength databitlen,
249  		BitSequence* hashval) {
250    groestlHashState context;
251      Init(&context);
252    Update(&context, data, databitlen);
253    Final(&context, hashval);
254  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-c_groestl.c</h3>
            <pre><code>1  #include "c_groestl.h"
2  #include "groestl_tables.h"
3  #define P_TYPE 0
4  #define Q_TYPE 1
5  const uint8_t shift_Values[2][8] = {{0,1,2,3,4,5,6,7},{1,3,5,7,0,2,4,6}};
6  const uint8_t indices_cyclic[15] = {0,1,2,3,4,5,6,7,0,1,2,3,4,5,6};
7  #define ROTATE_COLUMN_DOWN(v1, v2, amount_bytes, temp_var) {temp_var = (v1<<(8*amount_bytes))|(v2>>(8*(4-amount_bytes))); \
8  															v2 = (v2<<(8*amount_bytes))|(v1>>(8*(4-amount_bytes))); \
9  															v1 = temp_var;}
10  #define COLUMN(x,y,i,c0,c1,c2,c3,c4,c5,c6,c7,tv1,tv2,tu,tl,t)				\
11     tu = T[2*(uint32_t)x[4*c0+0]];			    \
12     tl = T[2*(uint32_t)x[4*c0+0]+1];		    \
13     tv1 = T[2*(uint32_t)x[4*c1+1]];			\
14     tv2 = T[2*(uint32_t)x[4*c1+1]+1];			\
15     ROTATE_COLUMN_DOWN(tv1,tv2,1,t)	\
16     tu ^= tv1;						\
<span onclick='openModal()' class='match'>17     tl ^= tv2;						\
18     tv1 = T[2*(uint32_t)x[4*c2+2]];			\
19     tv2 = T[2*(uint32_t)x[4*c2+2]+1];			\
20     ROTATE_COLUMN_DOWN(tv1,tv2,2,t)	\
21     tu ^= tv1;						\
22     tl ^= tv2;   					\
23     tv1 = T[2*(uint32_t)x[4*c3+3]];			\
</span>24     tv2 = T[2*(uint32_t)x[4*c3+3]+1];			\
25     ROTATE_COLUMN_DOWN(tv1,tv2,3,t)	\
26     tu ^= tv1;						\
27     tl ^= tv2;						\
28     tl ^= T[2*(uint32_t)x[4*c4+0]];			\
29     tu ^= T[2*(uint32_t)x[4*c4+0]+1];			\
30     tv1 = T[2*(uint32_t)x[4*c5+1]];			\
31     tv2 = T[2*(uint32_t)x[4*c5+1]+1];			\
32     ROTATE_COLUMN_DOWN(tv1,tv2,1,t)	\
33     tl ^= tv1;						\
34     tu ^= tv2;						\
35     tv1 = T[2*(uint32_t)x[4*c6+2]];			\
36     tv2 = T[2*(uint32_t)x[4*c6+2]+1];			\
37     ROTATE_COLUMN_DOWN(tv1,tv2,2,t)	\
38     tl ^= tv1;						\
39     tu ^= tv2;   					\
40     tv1 = T[2*(uint32_t)x[4*c7+3]];			\
41     tv2 = T[2*(uint32_t)x[4*c7+3]+1];			\
42     ROTATE_COLUMN_DOWN(tv1,tv2,3,t)	\
43     tl ^= tv1;						\
44     tu ^= tv2;						\
45     y[i] = tu;						\
46     y[i+1] = tl;
47  static void RND512P(uint8_t *x, uint32_t *y, uint32_t r) {
48    uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
49    uint32_t* x32 = (uint32_t*)x;
50    x32[ 0] ^= 0x00000000^r;
51    x32[ 2] ^= 0x00000010^r;
52    x32[ 4] ^= 0x00000020^r;
53    x32[ 6] ^= 0x00000030^r;
54    x32[ 8] ^= 0x00000040^r;
55    x32[10] ^= 0x00000050^r;
56    x32[12] ^= 0x00000060^r;
57    x32[14] ^= 0x00000070^r;
58    COLUMN(x,y, 0,  0,  2,  4,  6,  9, 11, 13, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
59    COLUMN(x,y, 2,  2,  4,  6,  8, 11, 13, 15,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
60    COLUMN(x,y, 4,  4,  6,  8, 10, 13, 15,  1,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
61    COLUMN(x,y, 6,  6,  8, 10, 12, 15,  1,  3,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
62    COLUMN(x,y, 8,  8, 10, 12, 14,  1,  3,  5,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
63    COLUMN(x,y,10, 10, 12, 14,  0,  3,  5,  7,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
64    COLUMN(x,y,12, 12, 14,  0,  2,  5,  7,  9, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
65    COLUMN(x,y,14, 14,  0,  2,  4,  7,  9, 11, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
66  }
67  static void RND512Q(uint8_t *x, uint32_t *y, uint32_t r) {
68    uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
69    uint32_t* x32 = (uint32_t*)x;
70    x32[ 0] = ~x32[ 0];
71    x32[ 1] ^= 0xffffffff^r;
72    x32[ 2] = ~x32[ 2];
73    x32[ 3] ^= 0xefffffff^r;
74    x32[ 4] = ~x32[ 4];
75    x32[ 5] ^= 0xdfffffff^r;
76    x32[ 6] = ~x32[ 6];
77    x32[ 7] ^= 0xcfffffff^r;
78    x32[ 8] = ~x32[ 8];
79    x32[ 9] ^= 0xbfffffff^r;
80    x32[10] = ~x32[10];
81    x32[11] ^= 0xafffffff^r;
82    x32[12] = ~x32[12];
83    x32[13] ^= 0x9fffffff^r;
84    x32[14] = ~x32[14];
85    x32[15] ^= 0x8fffffff^r;
86    COLUMN(x,y, 0,  2,  6, 10, 14,  1,  5,  9, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
87    COLUMN(x,y, 2,  4,  8, 12,  0,  3,  7, 11, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
88    COLUMN(x,y, 4,  6, 10, 14,  2,  5,  9, 13,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
89    COLUMN(x,y, 6,  8, 12,  0,  4,  7, 11, 15,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
90    COLUMN(x,y, 8, 10, 14,  2,  6,  9, 13,  1,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
91    COLUMN(x,y,10, 12,  0,  4,  8, 11, 15,  3,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
92    COLUMN(x,y,12, 14,  2,  6, 10, 13,  1,  5,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
93    COLUMN(x,y,14,  0,  4,  8, 12, 15,  3,  7, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
94  }
95  static void F512(uint32_t *h, const uint32_t *m) {
96    int i;
97    uint32_t Ptmp[2*COLS512];
98    uint32_t Qtmp[2*COLS512];
99    uint32_t y[2*COLS512];
100    uint32_t z[2*COLS512];
101    for (i = 0; i < 2*COLS512; i++) {
102      z[i] = m[i];
103      Ptmp[i] = h[i]^m[i];
104    }
105    RND512Q((uint8_t*)z, y, 0x00000000);
106    RND512Q((uint8_t*)y, z, 0x01000000);
107    RND512Q((uint8_t*)z, y, 0x02000000);
108    RND512Q((uint8_t*)y, z, 0x03000000);
109    RND512Q((uint8_t*)z, y, 0x04000000);
110    RND512Q((uint8_t*)y, z, 0x05000000);
111    RND512Q((uint8_t*)z, y, 0x06000000);
112    RND512Q((uint8_t*)y, z, 0x07000000);
113    RND512Q((uint8_t*)z, y, 0x08000000);
114    RND512Q((uint8_t*)y, Qtmp, 0x09000000);
115    RND512P((uint8_t*)Ptmp, y, 0x00000000);
116    RND512P((uint8_t*)y, z, 0x00000001);
117    RND512P((uint8_t*)z, y, 0x00000002);
118    RND512P((uint8_t*)y, z, 0x00000003);
119    RND512P((uint8_t*)z, y, 0x00000004);
120    RND512P((uint8_t*)y, z, 0x00000005);
121    RND512P((uint8_t*)z, y, 0x00000006);
122    RND512P((uint8_t*)y, z, 0x00000007);
123    RND512P((uint8_t*)z, y, 0x00000008);
124    RND512P((uint8_t*)y, Ptmp, 0x00000009);
125    for (i = 0; i < 2*COLS512; i++) {
126      h[i] ^= Ptmp[i]^Qtmp[i];
127    }
128  }
129  static void Transform(groestlHashState *ctx,
130  	       const uint8_t *input,
131  	       int msglen) {
132    for (; msglen >= SIZE512;
133         msglen -= SIZE512, input += SIZE512) {
134      F512(ctx->chaining,(uint32_t*)input);
135      ctx->block_counter1++;
136      if (ctx->block_counter1 == 0) ctx->block_counter2++;
137    }
138  }
139  static void OutputTransformation(groestlHashState *ctx) {
140    int j;
141    uint32_t temp[2*COLS512];
142    uint32_t y[2*COLS512];
143    uint32_t z[2*COLS512];
144  	for (j = 0; j < 2*COLS512; j++) {
145  	  temp[j] = ctx->chaining[j];
146  	}
147  	RND512P((uint8_t*)temp, y, 0x00000000);
148  	RND512P((uint8_t*)y, z, 0x00000001);
149  	RND512P((uint8_t*)z, y, 0x00000002);
150  	RND512P((uint8_t*)y, z, 0x00000003);
151  	RND512P((uint8_t*)z, y, 0x00000004);
152  	RND512P((uint8_t*)y, z, 0x00000005);
153  	RND512P((uint8_t*)z, y, 0x00000006);
154  	RND512P((uint8_t*)y, z, 0x00000007);
155  	RND512P((uint8_t*)z, y, 0x00000008);
156  	RND512P((uint8_t*)y, temp, 0x00000009);
157  	for (j = 0; j < 2*COLS512; j++) {
158  	  ctx->chaining[j] ^= temp[j];
159  	}									
160  }
161  static void Init(groestlHashState* ctx) {
162    int i = 0;
163    for(;i<(SIZE512/sizeof(uint32_t));i++)
164    {
165  	ctx->chaining[i] = 0;
166    }
167    ctx->chaining[2*COLS512-1] = u32BIG((uint32_t)HASH_BIT_LEN);
168    ctx->buf_ptr = 0;
169    ctx->block_counter1 = 0;
170    ctx->block_counter2 = 0;
171    ctx->bits_in_last_byte = 0;
172  }
173  static void Update(groestlHashState* ctx,
174  		  const BitSequence* input,
175  		  DataLength databitlen) {
176    int index = 0;
177    int msglen = (int)(databitlen/8);
178    int rem = (int)(databitlen%8);
179    if (ctx->buf_ptr) {
180      while (ctx->buf_ptr < SIZE512 && index < msglen) {
181        ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
182      }
183      if (ctx->buf_ptr < SIZE512) {
184        if (rem) {
185  	ctx->bits_in_last_byte = rem;
186  	ctx->buffer[(int)ctx->buf_ptr++] = input[index];
187        }
188        return;
189      }
190      ctx->buf_ptr = 0;
191      Transform(ctx, ctx->buffer, SIZE512);
192    }
193    Transform(ctx, input+index, msglen-index);
194    index += ((msglen-index)/SIZE512)*SIZE512;
195    while (index < msglen) {
196      ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
197    }
198    if (rem) {
199      ctx->bits_in_last_byte = rem;
200      ctx->buffer[(int)ctx->buf_ptr++] = input[index];
201    }
202  }
203  #define BILB ctx->bits_in_last_byte
204  static void Final(groestlHashState* ctx,
205  		 BitSequence* output) {
206    int i, j = 0, hashbytelen = HASH_BIT_LEN/8;
207    uint8_t *s = (BitSequence*)ctx->chaining;
208    if (BILB) {
209      ctx->buffer[(int)ctx->buf_ptr-1] &= ((1<<BILB)-1)<<(8-BILB);
210      ctx->buffer[(int)ctx->buf_ptr-1] ^= 0x1<<(7-BILB);
211      BILB = 0;
212    }
213    else ctx->buffer[(int)ctx->buf_ptr++] = 0x80;
214    if (ctx->buf_ptr > SIZE512-LENGTHFIELDLEN) {
215      while (ctx->buf_ptr < SIZE512) {
216        ctx->buffer[(int)ctx->buf_ptr++] = 0;
217      }
218      Transform(ctx, ctx->buffer, SIZE512);
219      ctx->buf_ptr = 0;
220    }
221    while (ctx->buf_ptr < SIZE512-LENGTHFIELDLEN) {
222      ctx->buffer[(int)ctx->buf_ptr++] = 0;
223    }
224    ctx->block_counter1++;
225    if (ctx->block_counter1 == 0) ctx->block_counter2++;
226    ctx->buf_ptr = SIZE512;
227    while (ctx->buf_ptr > SIZE512-(int)sizeof(uint32_t)) {
228      ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter1;
229      ctx->block_counter1 >>= 8;
230    }
231    while (ctx->buf_ptr > SIZE512-LENGTHFIELDLEN) {
232      ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter2;
233      ctx->block_counter2 >>= 8;
234    }
235    Transform(ctx, ctx->buffer, SIZE512);
236    OutputTransformation(ctx);
237    for (i = SIZE512-hashbytelen; i < SIZE512; i++,j++) {
238      output[j] = s[i];
239    }
240    for (i = 0; i < COLS512; i++) {
241      ctx->chaining[i] = 0;
242    }
243    for (i = 0; i < SIZE512; i++) {
244      ctx->buffer[i] = 0;
245    }
246  }
247  void groestl(const BitSequence* data,
248  		DataLength databitlen,
249  		BitSequence* hashval) {
250    groestlHashState context;
251      Init(&context);
252    Update(&context, data, databitlen);
253    Final(&context, hashval);
254  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-c_groestl.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-c_groestl.c</div>
                </div>
                <div class="column column_space"><pre><code>39     tu ^= tv2;   					\
40     tv1 = T[2*(uint32_t)x[4*c7+3]];			\
41     tv2 = T[2*(uint32_t)x[4*c7+3]+1];			\
42     ROTATE_COLUMN_DOWN(tv1,tv2,3,t)	\
43     tl ^= tv1;						\
44     tu ^= tv2;						\
45     y[i] = tu;						\
</pre></code></div>
                <div class="column column_space"><pre><code>17     tl ^= tv2;						\
18     tv1 = T[2*(uint32_t)x[4*c2+2]];			\
19     tv2 = T[2*(uint32_t)x[4*c2+2]+1];			\
20     ROTATE_COLUMN_DOWN(tv1,tv2,2,t)	\
21     tu ^= tv1;						\
22     tl ^= tv2;   					\
23     tv1 = T[2*(uint32_t)x[4*c3+3]];			\
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    