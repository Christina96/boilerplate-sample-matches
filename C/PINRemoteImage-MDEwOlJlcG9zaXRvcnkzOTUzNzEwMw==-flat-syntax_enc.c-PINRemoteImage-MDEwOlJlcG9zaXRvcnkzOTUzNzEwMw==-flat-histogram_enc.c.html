
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.400694846554718%, Tokens: 9</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-syntax_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/utils/utils.h"
3  #include "src/webp/format_constants.h"  
4  #include "src/webp/mux_types.h"         
5  #include "src/enc/vp8i_enc.h"
6  static int IsVP8XNeeded(const VP8Encoder* const enc) {
7    return !!enc->has_alpha_;  
8  }
9  static int PutPaddingByte(const WebPPicture* const pic) {
10    const uint8_t pad_byte[1] = { 0 };
11    return !!pic->writer(pad_byte, 1, pic);
12  }
13  static WebPEncodingError PutRIFFHeader(const VP8Encoder* const enc,
14                                         size_t riff_size) {
15    const WebPPicture* const pic = enc->pic_;
16    uint8_t riff[RIFF_HEADER_SIZE] = {
17      'R', 'I', 'F', 'F', 0, 0, 0, 0, 'W', 'E', 'B', 'P'
18    };
19    assert(riff_size == (uint32_t)riff_size);
20    PutLE32(riff + TAG_SIZE, (uint32_t)riff_size);
21    if (!pic->writer(riff, sizeof(riff), pic)) {
22      return VP8_ENC_ERROR_BAD_WRITE;
23    }
24    return VP8_ENC_OK;
25  }
26  static WebPEncodingError PutVP8XHeader(const VP8Encoder* const enc) {
27    const WebPPicture* const pic = enc->pic_;
28    uint8_t vp8x[CHUNK_HEADER_SIZE + VP8X_CHUNK_SIZE] = {
29      'V', 'P', '8', 'X'
30    };
31    uint32_t flags = 0;
32    assert(IsVP8XNeeded(enc));
33    assert(pic->width >= 1 && pic->height >= 1);
34    assert(pic->width <= MAX_CANVAS_SIZE && pic->height <= MAX_CANVAS_SIZE);
35    if (enc->has_alpha_) {
36      flags |= ALPHA_FLAG;
37    }
38    PutLE32(vp8x + TAG_SIZE,              VP8X_CHUNK_SIZE);
39    PutLE32(vp8x + CHUNK_HEADER_SIZE,     flags);
40    PutLE24(vp8x + CHUNK_HEADER_SIZE + 4, pic->width - 1);
41    PutLE24(vp8x + CHUNK_HEADER_SIZE + 7, pic->height - 1);
42    if (!pic->writer(vp8x, sizeof(vp8x), pic)) {
43      return VP8_ENC_ERROR_BAD_WRITE;
44    }
45    return VP8_ENC_OK;
46  }
47  static WebPEncodingError PutAlphaChunk(const VP8Encoder* const enc) {
48    const WebPPicture* const pic = enc->pic_;
49    uint8_t alpha_chunk_hdr[CHUNK_HEADER_SIZE] = {
50      'A', 'L', 'P', 'H'
51    };
52    assert(enc->has_alpha_);
53    PutLE32(alpha_chunk_hdr + TAG_SIZE, enc->alpha_data_size_);
54    if (!pic->writer(alpha_chunk_hdr, sizeof(alpha_chunk_hdr), pic)) {
55      return VP8_ENC_ERROR_BAD_WRITE;
56    }
57    if (!pic->writer(enc->alpha_data_, enc->alpha_data_size_, pic)) {
58      return VP8_ENC_ERROR_BAD_WRITE;
59    }
60    if ((enc->alpha_data_size_ & 1) && !PutPaddingByte(pic)) {
61      return VP8_ENC_ERROR_BAD_WRITE;
62    }
63    return VP8_ENC_OK;
64  }
65  static WebPEncodingError PutVP8Header(const WebPPicture* const pic,
66                                        size_t vp8_size) {
67    uint8_t vp8_chunk_hdr[CHUNK_HEADER_SIZE] = {
68      'V', 'P', '8', ' '
69    };
70    assert(vp8_size == (uint32_t)vp8_size);
71    PutLE32(vp8_chunk_hdr + TAG_SIZE, (uint32_t)vp8_size);
72    if (!pic->writer(vp8_chunk_hdr, sizeof(vp8_chunk_hdr), pic)) {
73      return VP8_ENC_ERROR_BAD_WRITE;
74    }
75    return VP8_ENC_OK;
76  }
77  static WebPEncodingError PutVP8FrameHeader(const WebPPicture* const pic,
78                                             int profile, size_t size0) {
79    uint8_t vp8_frm_hdr[VP8_FRAME_HEADER_SIZE];
80    uint32_t bits;
81    if (size0 >= VP8_MAX_PARTITION0_SIZE) {  
82      return VP8_ENC_ERROR_PARTITION0_OVERFLOW;
83    }
84    bits = 0                         
85         | (profile << 1)            
86         | (1 << 4)                  
87         | ((uint32_t)size0 << 5);   
88    vp8_frm_hdr[0] = (bits >>  0) & 0xff;
89    vp8_frm_hdr[1] = (bits >>  8) & 0xff;
90    vp8_frm_hdr[2] = (bits >> 16) & 0xff;
91    vp8_frm_hdr[3] = (VP8_SIGNATURE >> 16) & 0xff;
92    vp8_frm_hdr[4] = (VP8_SIGNATURE >>  8) & 0xff;
93    vp8_frm_hdr[5] = (VP8_SIGNATURE >>  0) & 0xff;
94    vp8_frm_hdr[6] = pic->width & 0xff;
95    vp8_frm_hdr[7] = pic->width >> 8;
96    vp8_frm_hdr[8] = pic->height & 0xff;
97    vp8_frm_hdr[9] = pic->height >> 8;
98    if (!pic->writer(vp8_frm_hdr, sizeof(vp8_frm_hdr), pic)) {
99      return VP8_ENC_ERROR_BAD_WRITE;
100    }
101    return VP8_ENC_OK;
102  }
103  static int PutWebPHeaders(const VP8Encoder* const enc, size_t size0,
104                            size_t vp8_size, size_t riff_size) {
105    WebPPicture* const pic = enc->pic_;
106    WebPEncodingError err = VP8_ENC_OK;
107    err = PutRIFFHeader(enc, riff_size);
108    if (err != VP8_ENC_OK) goto Error;
109    if (IsVP8XNeeded(enc)) {
110      err = PutVP8XHeader(enc);
111      if (err != VP8_ENC_OK) goto Error;
112    }
113    if (enc->has_alpha_) {
114      err = PutAlphaChunk(enc);
115      if (err != VP8_ENC_OK) goto Error;
116    }
117    err = PutVP8Header(pic, vp8_size);
118    if (err != VP8_ENC_OK) goto Error;
119    err = PutVP8FrameHeader(pic, enc->profile_, size0);
120    if (err != VP8_ENC_OK) goto Error;
121    return 1;
122   Error:
123    return WebPEncodingSetError(pic, err);
124  }
125  static void PutSegmentHeader(VP8BitWriter* const bw,
126                               const VP8Encoder* const enc) {
127    const VP8EncSegmentHeader* const hdr = &enc->segment_hdr_;
128    const VP8EncProba* const proba = &enc->proba_;
129    if (VP8PutBitUniform(bw, (hdr->num_segments_ > 1))) {
130      const int update_data = 1;
131      int s;
132      VP8PutBitUniform(bw, hdr->update_map_);
133      if (VP8PutBitUniform(bw, update_data)) {
134        VP8PutBitUniform(bw, 1);   
135        for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
136          VP8PutSignedBits(bw, enc->dqm_[s].quant_, 7);
137        }
138        for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
139          VP8PutSignedBits(bw, enc->dqm_[s].fstrength_, 6);
140        }
141      }
142      if (hdr->update_map_) {
143        for (s = 0; s < 3; ++s) {
144          if (VP8PutBitUniform(bw, (proba->segments_[s] != 255u))) {
145            VP8PutBits(bw, proba->segments_[s], 8);
146          }
147        }
148      }
149    }
150  }
151  static void PutFilterHeader(VP8BitWriter* const bw,
<span onclick='openModal()' class='match'>152                              const VP8EncFilterHeader* const hdr) {
153    const int use_lf_delta = (hdr->i4x4_lf_delta_ != 0);
154    VP8PutBitUniform(bw, hdr->simple_);
155    VP8PutBits(bw, hdr->level_, 6);
156    VP8PutBits(bw, hdr->sharpness_, 3);
157    if (VP8PutBitUniform(bw, use_lf_delta)) {
158      const int need_update = (hdr->i4x4_lf_delta_ != 0);
</span>159      if (VP8PutBitUniform(bw, need_update)) {
160        VP8PutBits(bw, 0, 4);
161        VP8PutSignedBits(bw, hdr->i4x4_lf_delta_, 6);
162        VP8PutBits(bw, 0, 3);    
163      }
164    }
165  }
166  static void PutQuant(VP8BitWriter* const bw,
167                       const VP8Encoder* const enc) {
168    VP8PutBits(bw, enc->base_quant_, 7);
169    VP8PutSignedBits(bw, enc->dq_y1_dc_, 4);
170    VP8PutSignedBits(bw, enc->dq_y2_dc_, 4);
171    VP8PutSignedBits(bw, enc->dq_y2_ac_, 4);
172    VP8PutSignedBits(bw, enc->dq_uv_dc_, 4);
173    VP8PutSignedBits(bw, enc->dq_uv_ac_, 4);
174  }
175  static int EmitPartitionsSize(const VP8Encoder* const enc,
176                                WebPPicture* const pic) {
177    uint8_t buf[3 * (MAX_NUM_PARTITIONS - 1)];
178    int p;
179    for (p = 0; p < enc->num_parts_ - 1; ++p) {
180      const size_t part_size = VP8BitWriterSize(enc->parts_ + p);
181      if (part_size >= VP8_MAX_PARTITION_SIZE) {
182        return WebPEncodingSetError(pic, VP8_ENC_ERROR_PARTITION_OVERFLOW);
183      }
184      buf[3 * p + 0] = (part_size >>  0) & 0xff;
185      buf[3 * p + 1] = (part_size >>  8) & 0xff;
186      buf[3 * p + 2] = (part_size >> 16) & 0xff;
187    }
188    return p ? pic->writer(buf, 3 * p, pic) : 1;
189  }
190  static int GeneratePartition0(VP8Encoder* const enc) {
191    VP8BitWriter* const bw = &enc->bw_;
192    const int mb_size = enc->mb_w_ * enc->mb_h_;
193    uint64_t pos1, pos2, pos3;
194    pos1 = VP8BitWriterPos(bw);
195    if (!VP8BitWriterInit(bw, mb_size * 7 / 8)) {        
196      return WebPEncodingSetError(enc->pic_, VP8_ENC_ERROR_OUT_OF_MEMORY);
197    }
198    VP8PutBitUniform(bw, 0);   
199    VP8PutBitUniform(bw, 0);   
200    PutSegmentHeader(bw, enc);
201    PutFilterHeader(bw, &enc->filter_hdr_);
202    VP8PutBits(bw, enc->num_parts_ == 8 ? 3 :
203                   enc->num_parts_ == 4 ? 2 :
204                   enc->num_parts_ == 2 ? 1 : 0, 2);
205    PutQuant(bw, enc);
206    VP8PutBitUniform(bw, 0);   
207    VP8WriteProbas(bw, &enc->proba_);
208    pos2 = VP8BitWriterPos(bw);
209    VP8CodeIntraModes(enc);
210    VP8BitWriterFinish(bw);
211    pos3 = VP8BitWriterPos(bw);
212  #if !defined(WEBP_DISABLE_STATS)
213    if (enc->pic_->stats) {
214      enc->pic_->stats->header_bytes[0] = (int)((pos2 - pos1 + 7) >> 3);
215      enc->pic_->stats->header_bytes[1] = (int)((pos3 - pos2 + 7) >> 3);
216      enc->pic_->stats->alpha_data_size = (int)enc->alpha_data_size_;
217    }
218  #else
219    (void)pos1;
220    (void)pos2;
221    (void)pos3;
222  #endif
223    if (bw->error_) {
224      return WebPEncodingSetError(enc->pic_, VP8_ENC_ERROR_OUT_OF_MEMORY);
225    }
226    return 1;
227  }
228  void VP8EncFreeBitWriters(VP8Encoder* const enc) {
229    int p;
230    VP8BitWriterWipeOut(&enc->bw_);
231    for (p = 0; p < enc->num_parts_; ++p) {
232      VP8BitWriterWipeOut(enc->parts_ + p);
233    }
234  }
235  int VP8EncWrite(VP8Encoder* const enc) {
236    WebPPicture* const pic = enc->pic_;
237    VP8BitWriter* const bw = &enc->bw_;
238    const int task_percent = 19;
239    const int percent_per_part = task_percent / enc->num_parts_;
240    const int final_percent = enc->percent_ + task_percent;
241    int ok = 0;
242    size_t vp8_size, pad, riff_size;
243    int p;
244    ok = GeneratePartition0(enc);
245    if (!ok) return 0;
246    vp8_size = VP8_FRAME_HEADER_SIZE +
247               VP8BitWriterSize(bw) +
248               3 * (enc->num_parts_ - 1);
249    for (p = 0; p < enc->num_parts_; ++p) {
250      vp8_size += VP8BitWriterSize(enc->parts_ + p);
251    }
252    pad = vp8_size & 1;
253    vp8_size += pad;
254    riff_size = TAG_SIZE + CHUNK_HEADER_SIZE + vp8_size;
255    if (IsVP8XNeeded(enc)) {  
256      riff_size += CHUNK_HEADER_SIZE + VP8X_CHUNK_SIZE;
257    }
258    if (enc->has_alpha_) {  
259      const uint32_t padded_alpha_size = enc->alpha_data_size_ +
260                                         (enc->alpha_data_size_ & 1);
261      riff_size += CHUNK_HEADER_SIZE + padded_alpha_size;
262    }
263    if (riff_size > 0xfffffffeU) {
264      return WebPEncodingSetError(pic, VP8_ENC_ERROR_FILE_TOO_BIG);
265    }
266    {
267      const uint8_t* const part0 = VP8BitWriterBuf(bw);
268      const size_t size0 = VP8BitWriterSize(bw);
269      ok = ok && PutWebPHeaders(enc, size0, vp8_size, riff_size)
270              && pic->writer(part0, size0, pic)
271              && EmitPartitionsSize(enc, pic);
272      VP8BitWriterWipeOut(bw);    
273    }
274    for (p = 0; p < enc->num_parts_; ++p) {
275      const uint8_t* const buf = VP8BitWriterBuf(enc->parts_ + p);
276      const size_t size = VP8BitWriterSize(enc->parts_ + p);
277      if (size) ok = ok && pic->writer(buf, size, pic);
278      VP8BitWriterWipeOut(enc->parts_ + p);    
279      ok = ok && WebPReportProgress(pic, enc->percent_ + percent_per_part,
280                                    &enc->percent_);
281    }
282    if (ok && pad) {
283      ok = PutPaddingByte(pic);
284    }
285    enc->coded_size_ = (int)(CHUNK_HEADER_SIZE + riff_size);
286    ok = ok && WebPReportProgress(pic, final_percent, &enc->percent_);
287    return ok;
288  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-histogram_enc.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "src/webp/config.h"
3  #endif
4  #include <math.h>
5  #include "src/enc/backward_references_enc.h"
6  #include "src/enc/histogram_enc.h"
7  #include "src/dsp/lossless.h"
8  #include "src/dsp/lossless_common.h"
9  #include "src/utils/utils.h"
10  #define MAX_COST 1.e38
11  #define NUM_PARTITIONS 4
12  #define BIN_SIZE (NUM_PARTITIONS * NUM_PARTITIONS * NUM_PARTITIONS)
13  #define MAX_HISTO_GREEDY 100
14  static void HistogramClear(VP8LHistogram* const p) {
15    uint32_t* const literal = p->literal_;
16    const int cache_bits = p->palette_code_bits_;
17    const int histo_size = VP8LGetHistogramSize(cache_bits);
18    memset(p, 0, histo_size);
19    p->palette_code_bits_ = cache_bits;
20    p->literal_ = literal;
21  }
22  static void HistogramSwap(VP8LHistogram** const A, VP8LHistogram** const B) {
23    VP8LHistogram* const tmp = *A;
24    *A = *B;
25    *B = tmp;
26  }
27  static void HistogramCopy(const VP8LHistogram* const src,
28                            VP8LHistogram* const dst) {
29    uint32_t* const dst_literal = dst->literal_;
30    const int dst_cache_bits = dst->palette_code_bits_;
31    const int literal_size = VP8LHistogramNumCodes(dst_cache_bits);
32    const int histo_size = VP8LGetHistogramSize(dst_cache_bits);
33    assert(src->palette_code_bits_ == dst_cache_bits);
34    memcpy(dst, src, histo_size);
35    dst->literal_ = dst_literal;
36    memcpy(dst->literal_, src->literal_, literal_size * sizeof(*dst->literal_));
37  }
38  int VP8LGetHistogramSize(int cache_bits) {
39    const int literal_size = VP8LHistogramNumCodes(cache_bits);
40    const size_t total_size = sizeof(VP8LHistogram) + sizeof(int) * literal_size;
41    assert(total_size <= (size_t)0x7fffffff);
42    return (int)total_size;
43  }
44  void VP8LFreeHistogram(VP8LHistogram* const histo) {
45    WebPSafeFree(histo);
46  }
47  void VP8LFreeHistogramSet(VP8LHistogramSet* const histo) {
48    WebPSafeFree(histo);
49  }
50  void VP8LHistogramStoreRefs(const VP8LBackwardRefs* const refs,
51                              VP8LHistogram* const histo) {
52    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
53    while (VP8LRefsCursorOk(&c)) {
54      VP8LHistogramAddSinglePixOrCopy(histo, c.cur_pos, NULL, 0);
55      VP8LRefsCursorNext(&c);
56    }
57  }
58  void VP8LHistogramCreate(VP8LHistogram* const p,
59                           const VP8LBackwardRefs* const refs,
60                           int palette_code_bits) {
61    if (palette_code_bits >= 0) {
62      p->palette_code_bits_ = palette_code_bits;
63    }
64    HistogramClear(p);
65    VP8LHistogramStoreRefs(refs, p);
66  }
67  void VP8LHistogramInit(VP8LHistogram* const p, int palette_code_bits,
68                         int init_arrays) {
69    p->palette_code_bits_ = palette_code_bits;
70    if (init_arrays) {
71      HistogramClear(p);
72    } else {
73      p->trivial_symbol_ = 0;
74      p->bit_cost_ = 0.;
75      p->literal_cost_ = 0.;
76      p->red_cost_ = 0.;
77      p->blue_cost_ = 0.;
78      memset(p->is_used_, 0, sizeof(p->is_used_));
79    }
80  }
81  VP8LHistogram* VP8LAllocateHistogram(int cache_bits) {
82    VP8LHistogram* histo = NULL;
83    const int total_size = VP8LGetHistogramSize(cache_bits);
84    uint8_t* const memory = (uint8_t*)WebPSafeMalloc(total_size, sizeof(*memory));
85    if (memory == NULL) return NULL;
86    histo = (VP8LHistogram*)memory;
87    histo->literal_ = (uint32_t*)(memory + sizeof(VP8LHistogram));
88    VP8LHistogramInit(histo, cache_bits, &bsol;*init_arrays=*/ 0);
89    return histo;
90  }
91  static void HistogramSetResetPointers(VP8LHistogramSet* const set,
92                                        int cache_bits) {
93    int i;
94    const int histo_size = VP8LGetHistogramSize(cache_bits);
95    uint8_t* memory = (uint8_t*) (set->histograms);
96    memory += set->max_size * sizeof(*set->histograms);
97    for (i = 0; i < set->max_size; ++i) {
98      memory = (uint8_t*) WEBP_ALIGN(memory);
99      set->histograms[i] = (VP8LHistogram*) memory;
100      set->histograms[i]->literal_ = (uint32_t*)(memory + sizeof(VP8LHistogram));
101      memory += histo_size;
102    }
103  }
104  static size_t HistogramSetTotalSize(int size, int cache_bits) {
105    const int histo_size = VP8LGetHistogramSize(cache_bits);
106    return (sizeof(VP8LHistogramSet) + size * (sizeof(VP8LHistogram*) +
107            histo_size + WEBP_ALIGN_CST));
108  }
109  VP8LHistogramSet* VP8LAllocateHistogramSet(int size, int cache_bits) {
110    int i;
111    VP8LHistogramSet* set;
112    const size_t total_size = HistogramSetTotalSize(size, cache_bits);
113    uint8_t* memory = (uint8_t*)WebPSafeMalloc(total_size, sizeof(*memory));
114    if (memory == NULL) return NULL;
115    set = (VP8LHistogramSet*)memory;
116    memory += sizeof(*set);
117    set->histograms = (VP8LHistogram**)memory;
118    set->max_size = size;
119    set->size = size;
120    HistogramSetResetPointers(set, cache_bits);
121    for (i = 0; i < size; ++i) {
122      VP8LHistogramInit(set->histograms[i], cache_bits, &bsol;*init_arrays=*/ 0);
123    }
124    return set;
125  }
126  void VP8LHistogramSetClear(VP8LHistogramSet* const set) {
127    int i;
128    const int cache_bits = set->histograms[0]->palette_code_bits_;
129    const int size = set->max_size;
130    const size_t total_size = HistogramSetTotalSize(size, cache_bits);
131    uint8_t* memory = (uint8_t*)set;
132    memset(memory, 0, total_size);
133    memory += sizeof(*set);
134    set->histograms = (VP8LHistogram**)memory;
135    set->max_size = size;
136    set->size = size;
137    HistogramSetResetPointers(set, cache_bits);
138    for (i = 0; i < size; ++i) {
139      set->histograms[i]->palette_code_bits_ = cache_bits;
140    }
141  }
142  static void HistogramSetRemoveHistogram(VP8LHistogramSet* const set, int i,
143                                          int* const num_used) {
144    assert(set->histograms[i] != NULL);
145    set->histograms[i] = NULL;
146    --*num_used;
147    if (i == set->size - 1) {
148      while (set->size >= 1 && set->histograms[set->size - 1] == NULL) {
149        --set->size;
150      }
151    }
152  }
153  void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram* const histo,
154                                       const PixOrCopy* const v,
155                                       int (*const distance_modifier)(int, int),
156                                       int distance_modifier_arg0) {
157    if (PixOrCopyIsLiteral(v)) {
158      ++histo->alpha_[PixOrCopyLiteral(v, 3)];
159      ++histo->red_[PixOrCopyLiteral(v, 2)];
160      ++histo->literal_[PixOrCopyLiteral(v, 1)];
161      ++histo->blue_[PixOrCopyLiteral(v, 0)];
162    } else if (PixOrCopyIsCacheIdx(v)) {
163      const int literal_ix =
164          NUM_LITERAL_CODES + NUM_LENGTH_CODES + PixOrCopyCacheIdx(v);
165      ++histo->literal_[literal_ix];
166    } else {
167      int code, extra_bits;
168      VP8LPrefixEncodeBits(PixOrCopyLength(v), &code, &extra_bits);
169      ++histo->literal_[NUM_LITERAL_CODES + code];
170      if (distance_modifier == NULL) {
171        VP8LPrefixEncodeBits(PixOrCopyDistance(v), &code, &extra_bits);
172      } else {
173        VP8LPrefixEncodeBits(
174            distance_modifier(distance_modifier_arg0, PixOrCopyDistance(v)),
175            &code, &extra_bits);
176      }
177      ++histo->distance_[code];
178    }
179  }
180  static WEBP_INLINE double BitsEntropyRefine(const VP8LBitEntropy* entropy) {
181    double mix;
182    if (entropy->nonzeros < 5) {
183      if (entropy->nonzeros <= 1) {
184        return 0;
185      }
186      if (entropy->nonzeros == 2) {
187        return 0.99 * entropy->sum + 0.01 * entropy->entropy;
188      }
189      if (entropy->nonzeros == 3) {
190        mix = 0.95;
191      } else {
192        mix = 0.7;  
193      }
194    } else {
195      mix = 0.627;
196    }
197    {
198      double min_limit = 2 * entropy->sum - entropy->max_val;
199      min_limit = mix * min_limit + (1.0 - mix) * entropy->entropy;
200      return (entropy->entropy < min_limit) ? min_limit : entropy->entropy;
201    }
202  }
203  double VP8LBitsEntropy(const uint32_t* const array, int n) {
204    VP8LBitEntropy entropy;
205    VP8LBitsEntropyUnrefined(array, n, &entropy);
206    return BitsEntropyRefine(&entropy);
207  }
208  static double InitialHuffmanCost(void) {
209    static const int kHuffmanCodeOfHuffmanCodeSize = CODE_LENGTH_CODES * 3;
210    static const double kSmallBias = 9.1;
211    return kHuffmanCodeOfHuffmanCodeSize - kSmallBias;
212  }
213  static double FinalHuffmanCost(const VP8LStreaks* const stats) {
214    double retval = InitialHuffmanCost();
215    retval += stats->counts[0] * 1.5625 + 0.234375 * stats->streaks[0][1];
216    retval += stats->counts[1] * 2.578125 + 0.703125 * stats->streaks[1][1];
217    retval += 1.796875 * stats->streaks[0][0];
218    retval += 3.28125 * stats->streaks[1][0];
219    return retval;
220  }
221  static double PopulationCost(const uint32_t* const population, int length,
222                               uint32_t* const trivial_sym,
223                               uint8_t* const is_used) {
224    VP8LBitEntropy bit_entropy;
225    VP8LStreaks stats;
226    VP8LGetEntropyUnrefined(population, length, &bit_entropy, &stats);
227    if (trivial_sym != NULL) {
228      *trivial_sym = (bit_entropy.nonzeros == 1) ? bit_entropy.nonzero_code
229                                                 : VP8L_NON_TRIVIAL_SYM;
230    }
231    *is_used = (stats.streaks[1][0] != 0 || stats.streaks[1][1] != 0);
232    return BitsEntropyRefine(&bit_entropy) + FinalHuffmanCost(&stats);
233  }
234  static WEBP_INLINE double GetCombinedEntropy(const uint32_t* const X,
235                                               const uint32_t* const Y,
236                                               int length, int is_X_used,
237                                               int is_Y_used,
238                                               int trivial_at_end) {
239    VP8LStreaks stats;
240    if (trivial_at_end) {
241      memset(&stats, 0, sizeof(stats));
242      stats.streaks[1][0] = 1;
243      stats.counts[0] = 1;
244      stats.streaks[0][1] = length - 1;
245      return FinalHuffmanCost(&stats);
246    } else {
247      VP8LBitEntropy bit_entropy;
248      if (is_X_used) {
249        if (is_Y_used) {
250          VP8LGetCombinedEntropyUnrefined(X, Y, length, &bit_entropy, &stats);
251        } else {
252          VP8LGetEntropyUnrefined(X, length, &bit_entropy, &stats);
253        }
254      } else {
255        if (is_Y_used) {
256          VP8LGetEntropyUnrefined(Y, length, &bit_entropy, &stats);
257        } else {
258          memset(&stats, 0, sizeof(stats));
259          stats.counts[0] = 1;
260          stats.streaks[0][length > 3] = length;
261          VP8LBitEntropyInit(&bit_entropy);
262        }
263      }
264      return BitsEntropyRefine(&bit_entropy) + FinalHuffmanCost(&stats);
265    }
266  }
267  double VP8LHistogramEstimateBits(VP8LHistogram* const p) {
268    return
269        PopulationCost(p->literal_, VP8LHistogramNumCodes(p->palette_code_bits_),
270                       NULL, &p->is_used_[0])
271        + PopulationCost(p->red_, NUM_LITERAL_CODES, NULL, &p->is_used_[1])
272        + PopulationCost(p->blue_, NUM_LITERAL_CODES, NULL, &p->is_used_[2])
273        + PopulationCost(p->alpha_, NUM_LITERAL_CODES, NULL, &p->is_used_[3])
274        + PopulationCost(p->distance_, NUM_DISTANCE_CODES, NULL, &p->is_used_[4])
275        + VP8LExtraCost(p->literal_ + NUM_LITERAL_CODES, NUM_LENGTH_CODES)
276        + VP8LExtraCost(p->distance_, NUM_DISTANCE_CODES);
277  }
278  static int GetCombinedHistogramEntropy(const VP8LHistogram* const a,
279                                         const VP8LHistogram* const b,
280                                         double cost_threshold,
281                                         double* cost) {
282    const int palette_code_bits = a->palette_code_bits_;
283    int trivial_at_end = 0;
284    assert(a->palette_code_bits_ == b->palette_code_bits_);
285    *cost += GetCombinedEntropy(a->literal_, b->literal_,
286                                VP8LHistogramNumCodes(palette_code_bits),
287                                a->is_used_[0], b->is_used_[0], 0);
288    *cost += VP8LExtraCostCombined(a->literal_ + NUM_LITERAL_CODES,
289                                   b->literal_ + NUM_LITERAL_CODES,
290                                   NUM_LENGTH_CODES);
291    if (*cost > cost_threshold) return 0;
292    if (a->trivial_symbol_ != VP8L_NON_TRIVIAL_SYM &&
293        a->trivial_symbol_ == b->trivial_symbol_) {
294      const uint32_t color_a = (a->trivial_symbol_ >> 24) & 0xff;
295      const uint32_t color_r = (a->trivial_symbol_ >> 16) & 0xff;
296      const uint32_t color_b = (a->trivial_symbol_ >> 0) & 0xff;
297      if ((color_a == 0 || color_a == 0xff) &&
298          (color_r == 0 || color_r == 0xff) &&
299          (color_b == 0 || color_b == 0xff)) {
300        trivial_at_end = 1;
301      }
302    }
303    *cost +=
304        GetCombinedEntropy(a->red_, b->red_, NUM_LITERAL_CODES, a->is_used_[1],
305                           b->is_used_[1], trivial_at_end);
306    if (*cost > cost_threshold) return 0;
307    *cost +=
308        GetCombinedEntropy(a->blue_, b->blue_, NUM_LITERAL_CODES, a->is_used_[2],
309                           b->is_used_[2], trivial_at_end);
310    if (*cost > cost_threshold) return 0;
311    *cost +=
312        GetCombinedEntropy(a->alpha_, b->alpha_, NUM_LITERAL_CODES,
313                           a->is_used_[3], b->is_used_[3], trivial_at_end);
314    if (*cost > cost_threshold) return 0;
315    *cost +=
316        GetCombinedEntropy(a->distance_, b->distance_, NUM_DISTANCE_CODES,
317                           a->is_used_[4], b->is_used_[4], 0);
318    *cost +=
319        VP8LExtraCostCombined(a->distance_, b->distance_, NUM_DISTANCE_CODES);
320    if (*cost > cost_threshold) return 0;
321    return 1;
322  }
323  static WEBP_INLINE void HistogramAdd(const VP8LHistogram* const a,
324                                       const VP8LHistogram* const b,
325                                       VP8LHistogram* const out) {
326    VP8LHistogramAdd(a, b, out);
327    out->trivial_symbol_ = (a->trivial_symbol_ == b->trivial_symbol_)
328                         ? a->trivial_symbol_
329                         : VP8L_NON_TRIVIAL_SYM;
330  }
331  static double HistogramAddEval(const VP8LHistogram* const a,
332                                 const VP8LHistogram* const b,
333                                 VP8LHistogram* const out,
334                                 double cost_threshold) {
335    double cost = 0;
336    const double sum_cost = a->bit_cost_ + b->bit_cost_;
337    cost_threshold += sum_cost;
338    if (GetCombinedHistogramEntropy(a, b, cost_threshold, &cost)) {
339      HistogramAdd(a, b, out);
340      out->bit_cost_ = cost;
341      out->palette_code_bits_ = a->palette_code_bits_;
342    }
343    return cost - sum_cost;
344  }
345  static double HistogramAddThresh(const VP8LHistogram* const a,
346                                   const VP8LHistogram* const b,
347                                   double cost_threshold) {
348    double cost;
349    assert(a != NULL && b != NULL);
350    cost = -a->bit_cost_;
351    GetCombinedHistogramEntropy(a, b, cost_threshold, &cost);
352    return cost;
353  }
354  typedef struct {
355    double literal_max_;
356    double literal_min_;
357    double red_max_;
358    double red_min_;
359    double blue_max_;
360    double blue_min_;
361  } DominantCostRange;
362  static void DominantCostRangeInit(DominantCostRange* const c) {
363    c->literal_max_ = 0.;
364    c->literal_min_ = MAX_COST;
365    c->red_max_ = 0.;
366    c->red_min_ = MAX_COST;
367    c->blue_max_ = 0.;
368    c->blue_min_ = MAX_COST;
369  }
370  static void UpdateDominantCostRange(
371      const VP8LHistogram* const h, DominantCostRange* const c) {
372    if (c->literal_max_ < h->literal_cost_) c->literal_max_ = h->literal_cost_;
373    if (c->literal_min_ > h->literal_cost_) c->literal_min_ = h->literal_cost_;
374    if (c->red_max_ < h->red_cost_) c->red_max_ = h->red_cost_;
375    if (c->red_min_ > h->red_cost_) c->red_min_ = h->red_cost_;
376    if (c->blue_max_ < h->blue_cost_) c->blue_max_ = h->blue_cost_;
377    if (c->blue_min_ > h->blue_cost_) c->blue_min_ = h->blue_cost_;
378  }
379  static void UpdateHistogramCost(VP8LHistogram* const h) {
380    uint32_t alpha_sym, red_sym, blue_sym;
381    const double alpha_cost =
382        PopulationCost(h->alpha_, NUM_LITERAL_CODES, &alpha_sym,
383                       &h->is_used_[3]);
384    const double distance_cost =
385        PopulationCost(h->distance_, NUM_DISTANCE_CODES, NULL, &h->is_used_[4]) +
386        VP8LExtraCost(h->distance_, NUM_DISTANCE_CODES);
387    const int num_codes = VP8LHistogramNumCodes(h->palette_code_bits_);
388    h->literal_cost_ =
389        PopulationCost(h->literal_, num_codes, NULL, &h->is_used_[0]) +
390            VP8LExtraCost(h->literal_ + NUM_LITERAL_CODES, NUM_LENGTH_CODES);
391    h->red_cost_ =
392        PopulationCost(h->red_, NUM_LITERAL_CODES, &red_sym, &h->is_used_[1]);
393    h->blue_cost_ =
394        PopulationCost(h->blue_, NUM_LITERAL_CODES, &blue_sym, &h->is_used_[2]);
395    h->bit_cost_ = h->literal_cost_ + h->red_cost_ + h->blue_cost_ +
396                   alpha_cost + distance_cost;
397    if ((alpha_sym | red_sym | blue_sym) == VP8L_NON_TRIVIAL_SYM) {
398      h->trivial_symbol_ = VP8L_NON_TRIVIAL_SYM;
399    } else {
400      h->trivial_symbol_ =
401          ((uint32_t)alpha_sym << 24) | (red_sym << 16) | (blue_sym << 0);
402    }
403  }
<span onclick='openModal()' class='match'>404  static int GetBinIdForEntropy(double min, double max, double val) {
405    const double range = max - min;
406    if (range > 0.) {
407      const double delta = val - min;
</span>408      return (int)((NUM_PARTITIONS - 1e-6) * delta / range);
409    } else {
410      return 0;
411    }
412  }
413  static int GetHistoBinIndex(const VP8LHistogram* const h,
414                              const DominantCostRange* const c, int low_effort) {
415    int bin_id = GetBinIdForEntropy(c->literal_min_, c->literal_max_,
416                                    h->literal_cost_);
417    assert(bin_id < NUM_PARTITIONS);
418    if (!low_effort) {
419      bin_id = bin_id * NUM_PARTITIONS
420             + GetBinIdForEntropy(c->red_min_, c->red_max_, h->red_cost_);
421      bin_id = bin_id * NUM_PARTITIONS
422             + GetBinIdForEntropy(c->blue_min_, c->blue_max_, h->blue_cost_);
423      assert(bin_id < BIN_SIZE);
424    }
425    return bin_id;
426  }
427  static void HistogramBuild(
428      int xsize, int histo_bits, const VP8LBackwardRefs* const backward_refs,
429      VP8LHistogramSet* const image_histo) {
430    int x = 0, y = 0;
431    const int histo_xsize = VP8LSubSampleSize(xsize, histo_bits);
432    VP8LHistogram** const histograms = image_histo->histograms;
433    VP8LRefsCursor c = VP8LRefsCursorInit(backward_refs);
434    assert(histo_bits > 0);
435    VP8LHistogramSetClear(image_histo);
436    while (VP8LRefsCursorOk(&c)) {
437      const PixOrCopy* const v = c.cur_pos;
438      const int ix = (y >> histo_bits) * histo_xsize + (x >> histo_bits);
439      VP8LHistogramAddSinglePixOrCopy(histograms[ix], v, NULL, 0);
440      x += PixOrCopyLength(v);
441      while (x >= xsize) {
442        x -= xsize;
443        ++y;
444      }
445      VP8LRefsCursorNext(&c);
446    }
447  }
448  static const uint16_t kInvalidHistogramSymbol = (uint16_t)(-1);
449  static void HistogramCopyAndAnalyze(VP8LHistogramSet* const orig_histo,
450                                      VP8LHistogramSet* const image_histo,
451                                      int* const num_used,
452                                      uint16_t* const histogram_symbols) {
453    int i, cluster_id;
454    int num_used_orig = *num_used;
455    VP8LHistogram** const orig_histograms = orig_histo->histograms;
456    VP8LHistogram** const histograms = image_histo->histograms;
457    assert(image_histo->max_size == orig_histo->max_size);
458    for (cluster_id = 0, i = 0; i < orig_histo->max_size; ++i) {
459      VP8LHistogram* const histo = orig_histograms[i];
460      UpdateHistogramCost(histo);
461      if (!histo->is_used_[0] && !histo->is_used_[1] && !histo->is_used_[2]
462          && !histo->is_used_[3] && !histo->is_used_[4]) {
463        assert(i > 0);
464        HistogramSetRemoveHistogram(image_histo, i, num_used);
465        HistogramSetRemoveHistogram(orig_histo, i, &num_used_orig);
466        histogram_symbols[i] = kInvalidHistogramSymbol;
467      } else {
468        HistogramCopy(histo, histograms[i]);
469        histogram_symbols[i] = cluster_id++;
470        assert(cluster_id <= image_histo->max_size);
471      }
472    }
473  }
474  static void HistogramAnalyzeEntropyBin(VP8LHistogramSet* const image_histo,
475                                         uint16_t* const bin_map,
476                                         int low_effort) {
477    int i;
478    VP8LHistogram** const histograms = image_histo->histograms;
479    const int histo_size = image_histo->size;
480    DominantCostRange cost_range;
481    DominantCostRangeInit(&cost_range);
482    for (i = 0; i < histo_size; ++i) {
483      if (histograms[i] == NULL) continue;
484      UpdateDominantCostRange(histograms[i], &cost_range);
485    }
486    for (i = 0; i < histo_size; ++i) {
487      if (histograms[i] == NULL) continue;
488      bin_map[i] = GetHistoBinIndex(histograms[i], &cost_range, low_effort);
489    }
490  }
491  static void HistogramCombineEntropyBin(VP8LHistogramSet* const image_histo,
492                                         int* num_used,
493                                         const uint16_t* const clusters,
494                                         uint16_t* const cluster_mappings,
495                                         VP8LHistogram* cur_combo,
496                                         const uint16_t* const bin_map,
497                                         int num_bins,
498                                         double combine_cost_factor,
499                                         int low_effort) {
500    VP8LHistogram** const histograms = image_histo->histograms;
501    int idx;
502    struct {
503      int16_t first;    
504      uint16_t num_combine_failures;   
505    } bin_info[BIN_SIZE];
506    assert(num_bins <= BIN_SIZE);
507    for (idx = 0; idx < num_bins; ++idx) {
508      bin_info[idx].first = -1;
509      bin_info[idx].num_combine_failures = 0;
510    }
511    for (idx = 0; idx < *num_used; ++idx) cluster_mappings[idx] = idx;
512    for (idx = 0; idx < image_histo->size; ++idx) {
513      int bin_id, first;
514      if (histograms[idx] == NULL) continue;
515      bin_id = bin_map[idx];
516      first = bin_info[bin_id].first;
517      if (first == -1) {
518        bin_info[bin_id].first = idx;
519      } else if (low_effort) {
520        HistogramAdd(histograms[idx], histograms[first], histograms[first]);
521        HistogramSetRemoveHistogram(image_histo, idx, num_used);
522        cluster_mappings[clusters[idx]] = clusters[first];
523      } else {
524        const double bit_cost = histograms[idx]->bit_cost_;
525        const double bit_cost_thresh = -bit_cost * combine_cost_factor;
526        const double curr_cost_diff =
527            HistogramAddEval(histograms[first], histograms[idx],
528                             cur_combo, bit_cost_thresh);
529        if (curr_cost_diff < bit_cost_thresh) {
530          const int try_combine =
531              (cur_combo->trivial_symbol_ != VP8L_NON_TRIVIAL_SYM) ||
532              ((histograms[idx]->trivial_symbol_ == VP8L_NON_TRIVIAL_SYM) &&
533               (histograms[first]->trivial_symbol_ == VP8L_NON_TRIVIAL_SYM));
534          const int max_combine_failures = 32;
535          if (try_combine ||
536              bin_info[bin_id].num_combine_failures >= max_combine_failures) {
537            HistogramSwap(&cur_combo, &histograms[first]);
538            HistogramSetRemoveHistogram(image_histo, idx, num_used);
539            cluster_mappings[clusters[idx]] = clusters[first];
540          } else {
541            ++bin_info[bin_id].num_combine_failures;
542          }
543        }
544      }
545    }
546    if (low_effort) {
547      for (idx = 0; idx < image_histo->size; ++idx) {
548        if (histograms[idx] == NULL) continue;
549        UpdateHistogramCost(histograms[idx]);
550      }
551    }
552  }
553  static uint32_t MyRand(uint32_t* const seed) {
554    *seed = (uint32_t)(((uint64_t)(*seed) * 48271u) % 2147483647u);
555    assert(*seed > 0);
556    return *seed;
557  }
558  typedef struct {
559    int idx1;
560    int idx2;
561    double cost_diff;
562    double cost_combo;
563  } HistogramPair;
564  typedef struct {
565    HistogramPair* queue;
566    int size;
567    int max_size;
568  } HistoQueue;
569  static int HistoQueueInit(HistoQueue* const histo_queue, const int max_size) {
570    histo_queue->size = 0;
571    histo_queue->max_size = max_size;
572    histo_queue->queue = (HistogramPair*)WebPSafeMalloc(
573        histo_queue->max_size + 1, sizeof(*histo_queue->queue));
574    return histo_queue->queue != NULL;
575  }
576  static void HistoQueueClear(HistoQueue* const histo_queue) {
577    assert(histo_queue != NULL);
578    WebPSafeFree(histo_queue->queue);
579    histo_queue->size = 0;
580    histo_queue->max_size = 0;
581  }
582  static void HistoQueuePopPair(HistoQueue* const histo_queue,
583                                HistogramPair* const pair) {
584    assert(pair >= histo_queue->queue &&
585           pair < (histo_queue->queue + histo_queue->size));
586    assert(histo_queue->size > 0);
587    *pair = histo_queue->queue[histo_queue->size - 1];
588    --histo_queue->size;
589  }
590  static void HistoQueueUpdateHead(HistoQueue* const histo_queue,
591                                   HistogramPair* const pair) {
592    assert(pair->cost_diff < 0.);
593    assert(pair >= histo_queue->queue &&
594           pair < (histo_queue->queue + histo_queue->size));
595    assert(histo_queue->size > 0);
596    if (pair->cost_diff < histo_queue->queue[0].cost_diff) {
597      const HistogramPair tmp = histo_queue->queue[0];
598      histo_queue->queue[0] = *pair;
599      *pair = tmp;
600    }
601  }
602  static void HistoQueueUpdatePair(const VP8LHistogram* const h1,
603                                   const VP8LHistogram* const h2,
604                                   double threshold,
605                                   HistogramPair* const pair) {
606    const double sum_cost = h1->bit_cost_ + h2->bit_cost_;
607    pair->cost_combo = 0.;
608    GetCombinedHistogramEntropy(h1, h2, sum_cost + threshold, &pair->cost_combo);
609    pair->cost_diff = pair->cost_combo - sum_cost;
610  }
611  static double HistoQueuePush(HistoQueue* const histo_queue,
612                               VP8LHistogram** const histograms, int idx1,
613                               int idx2, double threshold) {
614    const VP8LHistogram* h1;
615    const VP8LHistogram* h2;
616    HistogramPair pair;
617    if (histo_queue->size == histo_queue->max_size) return 0.;
618    assert(threshold <= 0.);
619    if (idx1 > idx2) {
620      const int tmp = idx2;
621      idx2 = idx1;
622      idx1 = tmp;
623    }
624    pair.idx1 = idx1;
625    pair.idx2 = idx2;
626    h1 = histograms[idx1];
627    h2 = histograms[idx2];
628    HistoQueueUpdatePair(h1, h2, threshold, &pair);
629    if (pair.cost_diff >= threshold) return 0.;
630    histo_queue->queue[histo_queue->size++] = pair;
631    HistoQueueUpdateHead(histo_queue, &histo_queue->queue[histo_queue->size - 1]);
632    return pair.cost_diff;
633  }
634  static int HistogramCombineGreedy(VP8LHistogramSet* const image_histo,
635                                    int* const num_used) {
636    int ok = 0;
637    const int image_histo_size = image_histo->size;
638    int i, j;
639    VP8LHistogram** const histograms = image_histo->histograms;
640    HistoQueue histo_queue;
641    if (!HistoQueueInit(&histo_queue, image_histo_size * image_histo_size)) {
642      goto End;
643    }
644    for (i = 0; i < image_histo_size; ++i) {
645      if (image_histo->histograms[i] == NULL) continue;
646      for (j = i + 1; j < image_histo_size; ++j) {
647        if (image_histo->histograms[j] == NULL) continue;
648        HistoQueuePush(&histo_queue, histograms, i, j, 0.);
649      }
650    }
651    while (histo_queue.size > 0) {
652      const int idx1 = histo_queue.queue[0].idx1;
653      const int idx2 = histo_queue.queue[0].idx2;
654      HistogramAdd(histograms[idx2], histograms[idx1], histograms[idx1]);
655      histograms[idx1]->bit_cost_ = histo_queue.queue[0].cost_combo;
656      HistogramSetRemoveHistogram(image_histo, idx2, num_used);
657      for (i = 0; i < histo_queue.size;) {
658        HistogramPair* const p = histo_queue.queue + i;
659        if (p->idx1 == idx1 || p->idx2 == idx1 ||
660            p->idx1 == idx2 || p->idx2 == idx2) {
661          HistoQueuePopPair(&histo_queue, p);
662        } else {
663          HistoQueueUpdateHead(&histo_queue, p);
664          ++i;
665        }
666      }
667      for (i = 0; i < image_histo->size; ++i) {
668        if (i == idx1 || image_histo->histograms[i] == NULL) continue;
669        HistoQueuePush(&histo_queue, image_histo->histograms, idx1, i, 0.);
670      }
671    }
672    ok = 1;
673   End:
674    HistoQueueClear(&histo_queue);
675    return ok;
676  }
677  static int PairComparison(const void* idx1, const void* idx2) {
678    return (*(int*) idx1 - *(int*) idx2);
679  }
680  static int HistogramCombineStochastic(VP8LHistogramSet* const image_histo,
681                                        int* const num_used, int min_cluster_size,
682                                        int* const do_greedy) {
683    int j, iter;
684    uint32_t seed = 1;
685    int tries_with_no_success = 0;
686    const int outer_iters = *num_used;
687    const int num_tries_no_success = outer_iters / 2;
688    VP8LHistogram** const histograms = image_histo->histograms;
689    HistoQueue histo_queue;
690    const int kHistoQueueSize = 9;
691    int ok = 0;
692    int* mappings;
693    if (*num_used < min_cluster_size) {
694      *do_greedy = 1;
695      return 1;
696    }
697    mappings = (int*) WebPSafeMalloc(*num_used, sizeof(*mappings));
698    if (mappings == NULL) return 0;
699    if (!HistoQueueInit(&histo_queue, kHistoQueueSize)) goto End;
700    for (j = 0, iter = 0; iter < image_histo->size; ++iter) {
701      if (histograms[iter] == NULL) continue;
702      mappings[j++] = iter;
703    }
704    assert(j == *num_used);
705    for (iter = 0;
706         iter < outer_iters && *num_used >= min_cluster_size &&
707             ++tries_with_no_success < num_tries_no_success;
708         ++iter) {
709      int* mapping_index;
710      double best_cost =
711          (histo_queue.size == 0) ? 0. : histo_queue.queue[0].cost_diff;
712      int best_idx1 = -1, best_idx2 = 1;
713      const uint32_t rand_range = (*num_used - 1) * (*num_used);
714      const int num_tries = (*num_used) / 2;
715      for (j = 0; *num_used >= 2 && j < num_tries; ++j) {
716        double curr_cost;
717        const uint32_t tmp = MyRand(&seed) % rand_range;
718        uint32_t idx1 = tmp / (*num_used - 1);
719        uint32_t idx2 = tmp % (*num_used - 1);
720        if (idx2 >= idx1) ++idx2;
721        idx1 = mappings[idx1];
722        idx2 = mappings[idx2];
723        curr_cost =
724            HistoQueuePush(&histo_queue, histograms, idx1, idx2, best_cost);
725        if (curr_cost < 0) {  
726          best_cost = curr_cost;
727          if (histo_queue.size == histo_queue.max_size) break;
728        }
729      }
730      if (histo_queue.size == 0) continue;
731      best_idx1 = histo_queue.queue[0].idx1;
732      best_idx2 = histo_queue.queue[0].idx2;
733      assert(best_idx1 < best_idx2);
734      mapping_index = (int*) bsearch(&best_idx2, mappings, *num_used,
735                                     sizeof(best_idx2), &PairComparison);
736      assert(mapping_index != NULL);
737      memmove(mapping_index, mapping_index + 1, sizeof(*mapping_index) *
738          ((*num_used) - (mapping_index - mappings) - 1));
739      HistogramAdd(histograms[best_idx2], histograms[best_idx1],
740                   histograms[best_idx1]);
741      histograms[best_idx1]->bit_cost_ = histo_queue.queue[0].cost_combo;
742      HistogramSetRemoveHistogram(image_histo, best_idx2, num_used);
743      for (j = 0; j < histo_queue.size;) {
744        HistogramPair* const p = histo_queue.queue + j;
745        const int is_idx1_best = p->idx1 == best_idx1 || p->idx1 == best_idx2;
746        const int is_idx2_best = p->idx2 == best_idx1 || p->idx2 == best_idx2;
747        int do_eval = 0;
748        if (is_idx1_best && is_idx2_best) {
749          HistoQueuePopPair(&histo_queue, p);
750          continue;
751        }
752        if (is_idx1_best) {
753          p->idx1 = best_idx1;
754          do_eval = 1;
755        } else if (is_idx2_best) {
756          p->idx2 = best_idx1;
757          do_eval = 1;
758        }
759        if (p->idx1 > p->idx2) {
760          const int tmp = p->idx2;
761          p->idx2 = p->idx1;
762          p->idx1 = tmp;
763        }
764        if (do_eval) {
765          HistoQueueUpdatePair(histograms[p->idx1], histograms[p->idx2], 0., p);
766          if (p->cost_diff >= 0.) {
767            HistoQueuePopPair(&histo_queue, p);
768            continue;
769          }
770        }
771        HistoQueueUpdateHead(&histo_queue, p);
772        ++j;
773      }
774      tries_with_no_success = 0;
775    }
776    *do_greedy = (*num_used <= min_cluster_size);
777    ok = 1;
778  End:
779    HistoQueueClear(&histo_queue);
780    WebPSafeFree(mappings);
781    return ok;
782  }
783  static void HistogramRemap(const VP8LHistogramSet* const in,
784                             VP8LHistogramSet* const out,
785                             uint16_t* const symbols) {
786    int i;
787    VP8LHistogram** const in_histo = in->histograms;
788    VP8LHistogram** const out_histo = out->histograms;
789    const int in_size = out->max_size;
790    const int out_size = out->size;
791    if (out_size > 1) {
792      for (i = 0; i < in_size; ++i) {
793        int best_out = 0;
794        double best_bits = MAX_COST;
795        int k;
796        if (in_histo[i] == NULL) {
797          symbols[i] = symbols[i - 1];
798          continue;
799        }
800        for (k = 0; k < out_size; ++k) {
801          double cur_bits;
802          cur_bits = HistogramAddThresh(out_histo[k], in_histo[i], best_bits);
803          if (k == 0 || cur_bits < best_bits) {
804            best_bits = cur_bits;
805            best_out = k;
806          }
807        }
808        symbols[i] = best_out;
809      }
810    } else {
811      assert(out_size == 1);
812      for (i = 0; i < in_size; ++i) {
813        symbols[i] = 0;
814      }
815    }
816    VP8LHistogramSetClear(out);
817    out->size = out_size;
818    for (i = 0; i < in_size; ++i) {
819      int idx;
820      if (in_histo[i] == NULL) continue;
821      idx = symbols[i];
822      HistogramAdd(in_histo[i], out_histo[idx], out_histo[idx]);
823    }
824  }
825  static double GetCombineCostFactor(int histo_size, int quality) {
826    double combine_cost_factor = 0.16;
827    if (quality < 90) {
828      if (histo_size > 256) combine_cost_factor /= 2.;
829      if (histo_size > 512) combine_cost_factor /= 2.;
830      if (histo_size > 1024) combine_cost_factor /= 2.;
831      if (quality <= 50) combine_cost_factor /= 2.;
832    }
833    return combine_cost_factor;
834  }
835  static void OptimizeHistogramSymbols(const VP8LHistogramSet* const set,
836                                       uint16_t* const cluster_mappings,
837                                       int num_clusters,
838                                       uint16_t* const cluster_mappings_tmp,
839                                       uint16_t* const symbols) {
840    int i, cluster_max;
841    int do_continue = 1;
842    while (do_continue) {
843      do_continue = 0;
844      for (i = 0; i < num_clusters; ++i) {
845        int k;
846        k = cluster_mappings[i];
847        while (k != cluster_mappings[k]) {
848          cluster_mappings[k] = cluster_mappings[cluster_mappings[k]];
849          k = cluster_mappings[k];
850        }
851        if (k != cluster_mappings[i]) {
852          do_continue = 1;
853          cluster_mappings[i] = k;
854        }
855      }
856    }
857    cluster_max = 0;
858    memset(cluster_mappings_tmp, 0,
859           set->max_size * sizeof(*cluster_mappings_tmp));
860    assert(cluster_mappings[0] == 0);
861    for (i = 0; i < set->max_size; ++i) {
862      int cluster;
863      if (symbols[i] == kInvalidHistogramSymbol) continue;
864      cluster = cluster_mappings[symbols[i]];
865      assert(symbols[i] < num_clusters);
866      if (cluster > 0 && cluster_mappings_tmp[cluster] == 0) {
867        ++cluster_max;
868        cluster_mappings_tmp[cluster] = cluster_max;
869      }
870      symbols[i] = cluster_mappings_tmp[cluster];
871    }
872    cluster_max = 0;
873    for (i = 0; i < set->max_size; ++i) {
874      if (symbols[i] == kInvalidHistogramSymbol) continue;
875      if (symbols[i] <= cluster_max) continue;
876      ++cluster_max;
877      assert(symbols[i] == cluster_max);
878    }
879  }
880  static void RemoveEmptyHistograms(VP8LHistogramSet* const image_histo) {
881    uint32_t size;
882    int i;
883    for (i = 0, size = 0; i < image_histo->size; ++i) {
884      if (image_histo->histograms[i] == NULL) continue;
885      image_histo->histograms[size++] = image_histo->histograms[i];
886    }
887    image_histo->size = size;
888  }
889  int VP8LGetHistoImageSymbols(int xsize, int ysize,
890                               const VP8LBackwardRefs* const refs,
891                               int quality, int low_effort,
892                               int histo_bits, int cache_bits,
893                               VP8LHistogramSet* const image_histo,
894                               VP8LHistogram* const tmp_histo,
895                               uint16_t* const histogram_symbols) {
896    int ok = 0;
897    const int histo_xsize = histo_bits ? VP8LSubSampleSize(xsize, histo_bits) : 1;
898    const int histo_ysize = histo_bits ? VP8LSubSampleSize(ysize, histo_bits) : 1;
899    const int image_histo_raw_size = histo_xsize * histo_ysize;
900    VP8LHistogramSet* const orig_histo =
901        VP8LAllocateHistogramSet(image_histo_raw_size, cache_bits);
902    const int entropy_combine_num_bins = low_effort ? NUM_PARTITIONS : BIN_SIZE;
903    int entropy_combine;
904    uint16_t* const map_tmp =
905        WebPSafeMalloc(2 * image_histo_raw_size, sizeof(map_tmp));
906    uint16_t* const cluster_mappings = map_tmp + image_histo_raw_size;
907    int num_used = image_histo_raw_size;
908    if (orig_histo == NULL || map_tmp == NULL) goto Error;
909    HistogramBuild(xsize, histo_bits, refs, orig_histo);
910    HistogramCopyAndAnalyze(orig_histo, image_histo, &num_used,
911                            histogram_symbols);
912    entropy_combine =
913        (num_used > entropy_combine_num_bins * 2) && (quality < 100);
914    if (entropy_combine) {
915      uint16_t* const bin_map = map_tmp;
916      const double combine_cost_factor =
917          GetCombineCostFactor(image_histo_raw_size, quality);
918      const uint32_t num_clusters = num_used;
919      HistogramAnalyzeEntropyBin(image_histo, bin_map, low_effort);
920      HistogramCombineEntropyBin(image_histo, &num_used, histogram_symbols,
921                                 cluster_mappings, tmp_histo, bin_map,
922                                 entropy_combine_num_bins, combine_cost_factor,
923                                 low_effort);
924      OptimizeHistogramSymbols(image_histo, cluster_mappings, num_clusters,
925                               map_tmp, histogram_symbols);
926    }
927    if (!low_effort || !entropy_combine) {
928      const float x = quality / 100.f;
929      const int threshold_size = (int)(1 + (x * x * x) * (MAX_HISTO_GREEDY - 1));
930      int do_greedy;
931      if (!HistogramCombineStochastic(image_histo, &num_used, threshold_size,
932                                      &do_greedy)) {
933        goto Error;
934      }
935      if (do_greedy) {
936        RemoveEmptyHistograms(image_histo);
937        if (!HistogramCombineGreedy(image_histo, &num_used)) {
938          goto Error;
939        }
940      }
941    }
942    RemoveEmptyHistograms(image_histo);
943    HistogramRemap(orig_histo, image_histo, histogram_symbols);
944    ok = 1;
945   Error:
946    VP8LFreeHistogramSet(orig_histo);
947    WebPSafeFree(map_tmp);
948    return ok;
949  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-syntax_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-histogram_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>152                              const VP8EncFilterHeader* const hdr) {
153    const int use_lf_delta = (hdr->i4x4_lf_delta_ != 0);
154    VP8PutBitUniform(bw, hdr->simple_);
155    VP8PutBits(bw, hdr->level_, 6);
156    VP8PutBits(bw, hdr->sharpness_, 3);
157    if (VP8PutBitUniform(bw, use_lf_delta)) {
158      const int need_update = (hdr->i4x4_lf_delta_ != 0);
</pre></code></div>
                <div class="column column_space"><pre><code>404  static int GetBinIdForEntropy(double min, double max, double val) {
405    const double range = max - min;
406    if (range > 0.) {
407      const double delta = val - min;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    