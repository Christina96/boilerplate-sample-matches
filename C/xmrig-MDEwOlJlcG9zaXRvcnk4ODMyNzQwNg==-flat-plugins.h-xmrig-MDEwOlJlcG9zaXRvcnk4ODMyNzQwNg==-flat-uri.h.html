
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.28898426323319%, Tokens: 8</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-plugins.h</h3>
            <pre><code>1  #ifndef HWLOC_PLUGINS_H
2  #define HWLOC_PLUGINS_H
3  struct hwloc_backend;
4  #include "hwloc.h"
5  #ifdef HWLOC_INSIDE_PLUGIN
6  #ifdef HWLOC_HAVE_LTDL
7  #include <ltdl.h>
8  #else
9  #include <dlfcn.h>
10  #endif
11  #endif
12  struct hwloc_disc_component {
13    const char *name;
14    unsigned phases;
15    unsigned excluded_phases;
16    struct hwloc_backend * (*instantiate)(struct hwloc_topology *topology, struct hwloc_disc_component *component, unsigned excluded_phases, const void *data1, const void *data2, const void *data3);
17    unsigned priority;
18    unsigned enabled_by_default;
19    struct hwloc_disc_component * next;
20  };
21  typedef enum hwloc_disc_phase_e {
<span onclick='openModal()' class='match'>22    HWLOC_DISC_PHASE_GLOBAL = (1U<<0),
23    HWLOC_DISC_PHASE_CPU = (1U<<1),
24    HWLOC_DISC_PHASE_MEMORY = (1U<<2),
25    HWLOC_DISC_PHASE_PCI = (1U<<3),
26    HWLOC_DISC_PHASE_IO = (1U<<4),
27    HWLOC_DISC_PHASE_MISC = (1U<<5),
28    HWLOC_DISC_PHASE_ANNOTATE = (1U<<6),
29    HWLOC_DISC_PHASE_TWEAK = (1U<<7)
</span>30  } hwloc_disc_phase_t;
31  enum hwloc_disc_status_flag_e {
32    HWLOC_DISC_STATUS_FLAG_GOT_ALLOWED_RESOURCES = (1UL<<1)
33  };
34  struct hwloc_disc_status {
35    hwloc_disc_phase_t phase;
36    unsigned excluded_phases;
37    unsigned long flags;
38  };
39  struct hwloc_backend {
40    struct hwloc_disc_component * component;
41    struct hwloc_topology * topology;
42    int envvar_forced;
43    struct hwloc_backend * next;
44    unsigned phases;
45    unsigned long flags;
46    int is_thissystem;
47    void * private_data;
48    void (*disable)(struct hwloc_backend *backend);
49    int (*discover)(struct hwloc_backend *backend, struct hwloc_disc_status *status);
50    int (*get_pci_busid_cpuset)(struct hwloc_backend *backend, struct hwloc_pcidev_attr_s *busid, hwloc_bitmap_t cpuset);
51  };
52  HWLOC_DECLSPEC struct hwloc_backend * hwloc_backend_alloc(struct hwloc_topology *topology, struct hwloc_disc_component *component);
53  HWLOC_DECLSPEC int hwloc_backend_enable(struct hwloc_backend *backend);
54  typedef enum hwloc_component_type_e {
55    HWLOC_COMPONENT_TYPE_DISC,
56    HWLOC_COMPONENT_TYPE_XML
57  } hwloc_component_type_t;
58  struct hwloc_component {
59    unsigned abi;
60    int (*init)(unsigned long flags);
61    void (*finalize)(unsigned long flags);
62    hwloc_component_type_t type;
63    unsigned long flags;
64    void * data;
65  };
66  HWLOC_DECLSPEC int hwloc_hide_errors(void);
67  #define HWLOC_SHOW_CRITICAL_ERRORS() (hwloc_hide_errors() < 2)
68  #define HWLOC_SHOW_ALL_ERRORS() (hwloc_hide_errors() == 0)
69  HWLOC_DECLSPEC hwloc_obj_t
70  hwloc__insert_object_by_cpuset(struct hwloc_topology *topology, hwloc_obj_t root,
71                                 hwloc_obj_t obj, const char *reason);
72  HWLOC_DECLSPEC void hwloc_insert_object_by_parent(struct hwloc_topology *topology, hwloc_obj_t parent, hwloc_obj_t obj);
73  HWLOC_DECLSPEC hwloc_obj_t hwloc_alloc_setup_object(hwloc_topology_t topology, hwloc_obj_type_t type, unsigned os_index);
74  HWLOC_DECLSPEC int hwloc_obj_add_children_sets(hwloc_obj_t obj);
75  HWLOC_DECLSPEC int hwloc_topology_reconnect(hwloc_topology_t topology, unsigned long flags __hwloc_attribute_unused);
76  static __hwloc_inline int
77  hwloc_plugin_check_namespace(const char *pluginname __hwloc_attribute_unused, const char *symbol __hwloc_attribute_unused)
78  {
79  #ifdef HWLOC_INSIDE_PLUGIN
80    void *sym;
81  #ifdef HWLOC_HAVE_LTDL
82    lt_dlhandle handle = lt_dlopen(NULL);
83  #else
84    void *handle = dlopen(NULL, RTLD_NOW|RTLD_LOCAL);
85  #endif
86    if (!handle)
87      return 0;
88  #ifdef HWLOC_HAVE_LTDL
89    sym = lt_dlsym(handle, symbol);
90    lt_dlclose(handle);
91  #else
92    sym = dlsym(handle, symbol);
93    dlclose(handle);
94  #endif
95    if (!sym) {
96      static int verboseenv_checked = 0;
97      static int verboseenv_value = 0;
98      if (!verboseenv_checked) {
99        const char *verboseenv = getenv("HWLOC_PLUGINS_VERBOSE");
100        verboseenv_value = verboseenv ? atoi(verboseenv) : 0;
101        verboseenv_checked = 1;
102      }
103      if (verboseenv_value)
104        fprintf(stderr, "Plugin `%s' disabling itself because it cannot find the `%s' core symbol.\n",
105  	      pluginname, symbol);
106      return -1;
107    }
108  #endif &bsol;* HWLOC_INSIDE_PLUGIN */
109    return 0;
110  }
111  static __hwloc_inline int
112  hwloc_filter_check_pcidev_subtype_important(unsigned classid)
113  {
114    unsigned baseclass = classid >> 8;
115    return (baseclass == 0x03 &bsol;* PCI_BASE_CLASS_DISPLAY */
116  	  || baseclass == 0x02 &bsol;* PCI_BASE_CLASS_NETWORK */
117  	  || baseclass == 0x01 &bsol;* PCI_BASE_CLASS_STORAGE */
118  	  || baseclass == 0x00 &bsol;* Unclassified, for Atos/Bull BXI */
119  	  || baseclass == 0x0b &bsol;* PCI_BASE_CLASS_PROCESSOR */
120  	  || classid == 0x0c04 &bsol;* PCI_CLASS_SERIAL_FIBER */
121  	  || classid == 0x0c06 &bsol;* PCI_CLASS_SERIAL_INFINIBAND */
122            || classid == 0x0502 &bsol;* PCI_CLASS_MEMORY_CXL */
123            || baseclass == 0x06 &bsol;* PCI_BASE_CLASS_BRIDGE with non-PCI downstream. the core will drop the useless ones later */
124  	  || baseclass == 0x12 &bsol;* Processing Accelerators */);
125  }
126  static __hwloc_inline int
127  hwloc_filter_check_osdev_subtype_important(hwloc_obj_osdev_type_t subtype)
128  {
129    return (subtype != HWLOC_OBJ_OSDEV_DMA);
130  }
131  static __hwloc_inline int
132  hwloc_filter_check_keep_object_type(hwloc_topology_t topology, hwloc_obj_type_t type)
133  {
134    enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;
135    hwloc_topology_get_type_filter(topology, type, &filter);
136    assert(filter != HWLOC_TYPE_FILTER_KEEP_IMPORTANT); &bsol;* IMPORTANT only used for I/O */
137    return filter == HWLOC_TYPE_FILTER_KEEP_NONE ? 0 : 1;
138  }
139  static __hwloc_inline int
140  hwloc_filter_check_keep_object(hwloc_topology_t topology, hwloc_obj_t obj)
141  {
142    hwloc_obj_type_t type = obj->type;
143    enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;
144    hwloc_topology_get_type_filter(topology, type, &filter);
145    if (filter == HWLOC_TYPE_FILTER_KEEP_NONE)
146      return 0;
147    if (filter == HWLOC_TYPE_FILTER_KEEP_IMPORTANT) {
148      if (type == HWLOC_OBJ_PCI_DEVICE)
149        return hwloc_filter_check_pcidev_subtype_important(obj->attr->pcidev.class_id);
150      if (type == HWLOC_OBJ_OS_DEVICE)
151        return hwloc_filter_check_osdev_subtype_important(obj->attr->osdev.type);
152    }
153    return 1;
154  }
155  HWLOC_DECLSPEC unsigned hwloc_pcidisc_find_cap(const unsigned char *config, unsigned cap);
156  HWLOC_DECLSPEC int hwloc_pcidisc_find_linkspeed(const unsigned char *config, unsigned offset, float *linkspeed);
157  HWLOC_DECLSPEC hwloc_obj_type_t hwloc_pcidisc_check_bridge_type(unsigned device_class, const unsigned char *config);
158  HWLOC_DECLSPEC int hwloc_pcidisc_find_bridge_buses(unsigned domain, unsigned bus, unsigned dev, unsigned func,
159  						   unsigned *secondary_busp, unsigned *subordinate_busp,
160  						   const unsigned char *config);
161  HWLOC_DECLSPEC void hwloc_pcidisc_tree_insert_by_busid(struct hwloc_obj **treep, struct hwloc_obj *obj);
162  HWLOC_DECLSPEC int hwloc_pcidisc_tree_attach(struct hwloc_topology *topology, struct hwloc_obj *tree);
163  HWLOC_DECLSPEC struct hwloc_obj * hwloc_pci_find_parent_by_busid(struct hwloc_topology *topology, unsigned domain, unsigned bus, unsigned dev, unsigned func);
164  HWLOC_DECLSPEC struct hwloc_obj * hwloc_pci_find_by_busid(struct hwloc_topology *topology, unsigned domain, unsigned bus, unsigned dev, unsigned func);
165  typedef void * hwloc_backend_distances_add_handle_t;
166  HWLOC_DECLSPEC hwloc_backend_distances_add_handle_t
167  hwloc_backend_distances_add_create(hwloc_topology_t topology,
168                                     const char *name, unsigned long kind,
169                                     unsigned long flags);
170  HWLOC_DECLSPEC int
171  hwloc_backend_distances_add_values(hwloc_topology_t topology,
172                                     hwloc_backend_distances_add_handle_t handle,
173                                     unsigned nbobjs, hwloc_obj_t *objs,
174                                     hwloc_uint64_t *values,
175                                     unsigned long flags);
176  HWLOC_DECLSPEC int
177  hwloc_backend_distances_add_commit(hwloc_topology_t topology,
178                                     hwloc_backend_distances_add_handle_t handle,
179                                     unsigned long flags);
180  #endif &bsol;* HWLOC_PLUGINS_H */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-uri.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_URI_H_
2  #define RAPIDJSON_URI_H_
3  #include "internal/strfunc.h"
4  #if defined(__clang__)
5  RAPIDJSON_DIAG_PUSH
6  RAPIDJSON_DIAG_OFF(c++98-compat)
7  #elif defined(_MSC_VER)
8  RAPIDJSON_DIAG_OFF(4512) 
9  #endif
10  RAPIDJSON_NAMESPACE_BEGIN
11  template <typename ValueType, typename Allocator=CrtAllocator>
12  class GenericUri {
13  public:
14      typedef typename ValueType::Ch Ch;
15  #if RAPIDJSON_HAS_STDSTRING
16      typedef std::basic_string<Ch> String;
17  #endif
18      GenericUri(Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
19      }
20      GenericUri(const Ch* uri, SizeType len, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
21          Parse(uri, len);
22      }
23      GenericUri(const Ch* uri, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
24          Parse(uri, internal::StrLen<Ch>(uri));
25      }
26      template<typename T> GenericUri(const T& uri, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
27          const Ch* u = uri.template Get<const Ch*>(); 
28          Parse(u, internal::StrLen<Ch>(u));
29      }
30  #if RAPIDJSON_HAS_STDSTRING
31      GenericUri(const String& uri, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
32          Parse(uri.c_str(), internal::StrLen<Ch>(uri.c_str()));
33      }
34  #endif
35      GenericUri(const GenericUri& rhs) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(), ownAllocator_() {
36          *this = rhs;
37      }
38      GenericUri(const GenericUri& rhs, Allocator* allocator) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
39          *this = rhs;
40      }
41      ~GenericUri() {
42          Free();
43          RAPIDJSON_DELETE(ownAllocator_);
44      }
45      GenericUri& operator=(const GenericUri& rhs) {
46          if (this != &rhs) {
47              Free();
48              Allocate(rhs.GetStringLength());
49              auth_ = CopyPart(scheme_, rhs.scheme_, rhs.GetSchemeStringLength());
50              path_ = CopyPart(auth_, rhs.auth_, rhs.GetAuthStringLength());
51              query_ = CopyPart(path_, rhs.path_, rhs.GetPathStringLength());
52              frag_ = CopyPart(query_, rhs.query_, rhs.GetQueryStringLength());
53              base_ = CopyPart(frag_, rhs.frag_, rhs.GetFragStringLength());
54              uri_ = CopyPart(base_, rhs.base_, rhs.GetBaseStringLength());
55              CopyPart(uri_, rhs.uri_, rhs.GetStringLength());
56          }
57          return *this;
58      }
59      template<typename T> void Get(T& uri, Allocator& allocator) {
60          uri.template Set<const Ch*>(this->GetString(), allocator); 
61      }
62      const Ch* GetString() const { return uri_; }
63      SizeType GetStringLength() const { return uri_ == 0 ? 0 : internal::StrLen<Ch>(uri_); }
64      const Ch* GetBaseString() const { return base_; }
65      SizeType GetBaseStringLength() const { return base_ == 0 ? 0 : internal::StrLen<Ch>(base_); }
66      const Ch* GetSchemeString() const { return scheme_; }
67      SizeType GetSchemeStringLength() const { return scheme_ == 0 ? 0 : internal::StrLen<Ch>(scheme_); }
68      const Ch* GetAuthString() const { return auth_; }
69      SizeType GetAuthStringLength() const { return auth_ == 0 ? 0 : internal::StrLen<Ch>(auth_); }
70      const Ch* GetPathString() const { return path_; }
71      SizeType GetPathStringLength() const { return path_ == 0 ? 0 : internal::StrLen<Ch>(path_); }
72      const Ch* GetQueryString() const { return query_; }
73      SizeType GetQueryStringLength() const { return query_ == 0 ? 0 : internal::StrLen<Ch>(query_); }
74      const Ch* GetFragString() const { return frag_; }
75      SizeType GetFragStringLength() const { return frag_ == 0 ? 0 : internal::StrLen<Ch>(frag_); }
76  #if RAPIDJSON_HAS_STDSTRING
77      static String Get(const GenericUri& uri) { return String(uri.GetString(), uri.GetStringLength()); }
78      static String GetBase(const GenericUri& uri) { return String(uri.GetBaseString(), uri.GetBaseStringLength()); }
79      static String GetScheme(const GenericUri& uri) { return String(uri.GetSchemeString(), uri.GetSchemeStringLength()); }
80      static String GetAuth(const GenericUri& uri) { return String(uri.GetAuthString(), uri.GetAuthStringLength()); }
81      static String GetPath(const GenericUri& uri) { return String(uri.GetPathString(), uri.GetPathStringLength()); }
82      static String GetQuery(const GenericUri& uri) { return String(uri.GetQueryString(), uri.GetQueryStringLength()); }
83      static String GetFrag(const GenericUri& uri) { return String(uri.GetFragString(), uri.GetFragStringLength()); }
84  #endif
85      bool operator==(const GenericUri& rhs) const {
86          return Match(rhs, true);
87      }
88      bool operator!=(const GenericUri& rhs) const {
89          return !Match(rhs, true);
90      }
91      bool Match(const GenericUri& uri, bool full = true) const {
92          Ch* s1;
93          Ch* s2;
94          if (full) {
95              s1 = uri_;
96              s2 = uri.uri_;
97          } else {
98              s1 = base_;
99              s2 = uri.base_;
100          }
101          if (s1 == s2) return true;
102          if (s1 == 0 || s2 == 0) return false;
103          return internal::StrCmp<Ch>(s1, s2) == 0;
104      }
105      GenericUri Resolve(const GenericUri& baseuri, Allocator* allocator = 0) {
106          GenericUri resuri;
107          resuri.allocator_ = allocator;
108          resuri.Allocate(GetStringLength() + baseuri.GetStringLength() + 1); 
109          if (!(GetSchemeStringLength() == 0)) {
110              resuri.auth_ = CopyPart(resuri.scheme_, scheme_, GetSchemeStringLength());
111              resuri.path_ = CopyPart(resuri.auth_, auth_, GetAuthStringLength());
112              resuri.query_ = CopyPart(resuri.path_, path_, GetPathStringLength());
113              resuri.frag_ = CopyPart(resuri.query_, query_, GetQueryStringLength());
114              resuri.RemoveDotSegments();
115          } else {
116              resuri.auth_ = CopyPart(resuri.scheme_, baseuri.scheme_, baseuri.GetSchemeStringLength());
117              if (!(GetAuthStringLength() == 0)) {
118                  resuri.path_ = CopyPart(resuri.auth_, auth_, GetAuthStringLength());
119                  resuri.query_ = CopyPart(resuri.path_, path_, GetPathStringLength());
120                  resuri.frag_ = CopyPart(resuri.query_, query_, GetQueryStringLength());
121                  resuri.RemoveDotSegments();
122              } else {
123                  resuri.path_ = CopyPart(resuri.auth_, baseuri.auth_, baseuri.GetAuthStringLength());
124                  if (GetPathStringLength() == 0) {
125                      resuri.query_ = CopyPart(resuri.path_, baseuri.path_, baseuri.GetPathStringLength());
126                      if (GetQueryStringLength() == 0) {
127                          resuri.frag_ = CopyPart(resuri.query_, baseuri.query_, baseuri.GetQueryStringLength());
128                      } else {
129                          resuri.frag_ = CopyPart(resuri.query_, query_, GetQueryStringLength());
130                      }
131                  } else {
132                      if (path_[0] == '/') {
133                          resuri.query_ = CopyPart(resuri.path_, path_, GetPathStringLength());
134                          resuri.RemoveDotSegments();
135                      } else {
136                          size_t pos = 0;
137                          if (!(baseuri.GetAuthStringLength() == 0) && baseuri.GetPathStringLength() == 0) {
138                              resuri.path_[pos] = '/';
139                              pos++;
140                          }
141                          size_t lastslashpos = baseuri.GetPathStringLength();
142                          while (lastslashpos > 0) {
143                              if (baseuri.path_[lastslashpos - 1] == '/') break;
144                              lastslashpos--;
145                          }
146                          std::memcpy(&resuri.path_[pos], baseuri.path_, lastslashpos * sizeof(Ch));
147                          pos += lastslashpos;
148                          resuri.query_ = CopyPart(&resuri.path_[pos], path_, GetPathStringLength());
149                          resuri.RemoveDotSegments();
150                      }
151                      resuri.frag_ = CopyPart(resuri.query_, query_, GetQueryStringLength());
152                  }
153              }
154          }
155          resuri.base_ = CopyPart(resuri.frag_, frag_, GetFragStringLength());
156          resuri.SetBase();
157          resuri.uri_ = resuri.base_ + resuri.GetBaseStringLength() + 1;
158          resuri.SetUri();
159          return resuri;
160      }
161      Allocator& GetAllocator() { return *allocator_; }
162  private:
163      std::size_t Allocate(std::size_t len) {
164          if (!allocator_)
165              ownAllocator_ =  allocator_ = RAPIDJSON_NEW(Allocator)();
166          size_t total = (3 * len + 7) * sizeof(Ch);
<span onclick='openModal()' class='match'>167          scheme_ = static_cast<Ch*>(allocator_->Malloc(total));
168          *scheme_ = '\0';
169          auth_ = scheme_ + 1;
170          *auth_ = '\0';
171          path_ = auth_ + 1;
172          *path_ = '\0';
173          query_ = path_ + 1;
174          *query_ = '\0';
</span>175          frag_ = query_ + 1;
176          *frag_ = '\0';
177          base_ = frag_ + 1;
178          *base_ = '\0';
179          uri_ = base_ + 1;
180          *uri_ = '\0';
181          return total;
182      }
183      void Free() {
184          if (scheme_) {
185              Allocator::Free(scheme_);
186              scheme_ = 0;
187          }
188      }
189      void Parse(const Ch* uri, std::size_t len) {
190          std::size_t start = 0, pos1 = 0, pos2 = 0;
191          Allocate(len);
192          if (start < len) {
193              while (pos1 < len) {
194                  if (uri[pos1] == ':') break;
195                  pos1++;
196              }
197              if (pos1 != len) {
198                  while (pos2 < len) {
199                      if (uri[pos2] == '/') break;
200                      if (uri[pos2] == '?') break;
201                      if (uri[pos2] == '#') break;
202                      pos2++;
203                  }
204                  if (pos1 < pos2) {
205                      pos1++;
206                      std::memcpy(scheme_, &uri[start], pos1 * sizeof(Ch));
207                      scheme_[pos1] = '\0';
208                      start = pos1;
209                  }
210              }
211          }
212          auth_ = scheme_ + GetSchemeStringLength() + 1;
213          *auth_ = '\0';
214          if (start < len - 1 && uri[start] == '/' && uri[start + 1] == '/') {
215              pos2 = start + 2;
216              while (pos2 < len) {
217                  if (uri[pos2] == '/') break;
218                  if (uri[pos2] == '?') break;
219                  if (uri[pos2] == '#') break;
220                  pos2++;
221              }
222              std::memcpy(auth_, &uri[start], (pos2 - start) * sizeof(Ch));
223              auth_[pos2 - start] = '\0';
224              start = pos2;
225          }
226          path_ = auth_ + GetAuthStringLength() + 1;
227          *path_ = '\0';
228          if (start < len) {
229              pos2 = start;
230              while (pos2 < len) {
231                  if (uri[pos2] == '?') break;
232                  if (uri[pos2] == '#') break;
233                  pos2++;
234              }
235              if (start != pos2) {
236                  std::memcpy(path_, &uri[start], (pos2 - start) * sizeof(Ch));
237                  path_[pos2 - start] = '\0';
238                  if (path_[0] == '/')
239                      RemoveDotSegments();   
240                  start = pos2;
241              }
242          }
243          query_ = path_ + GetPathStringLength() + 1;
244          *query_ = '\0';
245          if (start < len && uri[start] == '?') {
246              pos2 = start + 1;
247              while (pos2 < len) {
248                  if (uri[pos2] == '#') break;
249                  pos2++;
250              }
251              if (start != pos2) {
252                  std::memcpy(query_, &uri[start], (pos2 - start) * sizeof(Ch));
253                  query_[pos2 - start] = '\0';
254                  start = pos2;
255              }
256          }
257          frag_ = query_ + GetQueryStringLength() + 1;
258          *frag_ = '\0';
259          if (start < len && uri[start] == '#') {
260              std::memcpy(frag_, &uri[start], (len - start) * sizeof(Ch));
261              frag_[len - start] = '\0';
262          }
263          base_ = frag_ + GetFragStringLength() + 1;
264          SetBase();
265          uri_ = base_ + GetBaseStringLength() + 1;
266          SetUri();
267      }
268      void SetBase() {
269          Ch* next = base_;
270          std::memcpy(next, scheme_, GetSchemeStringLength() * sizeof(Ch));
271          next+= GetSchemeStringLength();
272          std::memcpy(next, auth_, GetAuthStringLength() * sizeof(Ch));
273          next+= GetAuthStringLength();
274          std::memcpy(next, path_, GetPathStringLength() * sizeof(Ch));
275          next+= GetPathStringLength();
276          std::memcpy(next, query_, GetQueryStringLength() * sizeof(Ch));
277          next+= GetQueryStringLength();
278          *next = '\0';
279      }
280      void SetUri() {
281          Ch* next = uri_;
282          std::memcpy(next, base_, GetBaseStringLength() * sizeof(Ch));
283          next+= GetBaseStringLength();
284          std::memcpy(next, frag_, GetFragStringLength() * sizeof(Ch));
285          next+= GetFragStringLength();
286          *next = '\0';
287      }
288      Ch* CopyPart(Ch* to, Ch* from, std::size_t len) {
289          RAPIDJSON_ASSERT(to != 0);
290          RAPIDJSON_ASSERT(from != 0);
291          std::memcpy(to, from, len * sizeof(Ch));
292          to[len] = '\0';
293          Ch* next = to + len + 1;
294          return next;
295      }
296      void RemoveDotSegments() {
297          std::size_t pathlen = GetPathStringLength();
298          std::size_t pathpos = 0;  
299          std::size_t newpos = 0;   
300          while (pathpos < pathlen) {
301              size_t slashpos = 0;
302              while ((pathpos + slashpos) < pathlen) {
303                  if (path_[pathpos + slashpos] == '/') break;
304                  slashpos++;
305              }
306              if (slashpos == 2 && path_[pathpos] == '.' && path_[pathpos + 1] == '.') {
307                  RAPIDJSON_ASSERT(newpos == 0 || path_[newpos - 1] == '/');
308                  size_t lastslashpos = newpos;
309                  if (lastslashpos > 1) {
310                      lastslashpos--;
311                      while (lastslashpos > 0) {
312                          if (path_[lastslashpos - 1] == '/') break;
313                          lastslashpos--;
314                      }
315                      newpos = lastslashpos;
316                  }
317              } else if (slashpos == 1 && path_[pathpos] == '.') {
318              } else {
319                  RAPIDJSON_ASSERT(newpos <= pathpos);
320                  std::memmove(&path_[newpos], &path_[pathpos], slashpos * sizeof(Ch));
321                  newpos += slashpos;
322                  if ((pathpos + slashpos) < pathlen) {
323                      path_[newpos] = '/';
324                      newpos++;
325                  }
326              }
327              pathpos += slashpos + 1;
328          }
329          path_[newpos] = '\0';
330      }
331      Ch* uri_;    
332      Ch* base_;   
333      Ch* scheme_; 
334      Ch* auth_;   
335      Ch* path_;   
336      Ch* query_;  
337      Ch* frag_;   
338      Allocator* allocator_;      
339      Allocator* ownAllocator_;   
340  };
341  typedef GenericUri<Value> Uri;
342  RAPIDJSON_NAMESPACE_END
343  #if defined(__clang__)
344  RAPIDJSON_DIAG_POP
345  #endif
346  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-plugins.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-uri.h</div>
                <div class="column column_space"><pre><code>22    HWLOC_DISC_PHASE_GLOBAL = (1U<<0),
23    HWLOC_DISC_PHASE_CPU = (1U<<1),
24    HWLOC_DISC_PHASE_MEMORY = (1U<<2),
25    HWLOC_DISC_PHASE_PCI = (1U<<3),
26    HWLOC_DISC_PHASE_IO = (1U<<4),
27    HWLOC_DISC_PHASE_MISC = (1U<<5),
28    HWLOC_DISC_PHASE_ANNOTATE = (1U<<6),
29    HWLOC_DISC_PHASE_TWEAK = (1U<<7)
</pre></code></div>
                <div class="column column_space"><pre><code>167          scheme_ = static_cast<Ch*>(allocator_->Malloc(total));
168          *scheme_ = '\0';
169          auth_ = scheme_ + 1;
170          *auth_ = '\0';
171          path_ = auth_ + 1;
172          *path_ = '\0';
173          query_ = path_ + 1;
174          *query_ = '\0';
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    