
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 110, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-quicklist.c</h3>
            <pre><code>1  #include &lt;string.h&gt; &amp;bsol;* for memcpy */
2  #include &quot;quicklist.h&quot;
3  #include &quot;zmalloc.h&quot;
4  #include &quot;ziplist.h&quot;
5  #include &quot;util.h&quot; &amp;bsol;* for ll2string */
6  #include &quot;lzf.h&quot;
7  #if defined(REDIS_TEST) || defined(REDIS_TEST_VERBOSE)
8  #include &lt;stdio.h&gt; &amp;bsol;* for printf (debug printing), snprintf (genstr) */
9  #endif
10  #ifndef REDIS_STATIC
11  #define REDIS_STATIC static
12  #endif
13  static const size_t optimization_level[] = {4096, 8192, 16384, 32768, 65536};
14  #define SIZE_SAFETY_LIMIT 8192
15  #define MIN_COMPRESS_BYTES 48
16  #define MIN_COMPRESS_IMPROVE 8
17  #ifndef REDIS_TEST_VERBOSE
18  #define D(...)
19  #else
20  #define D(...)                                                                 \
21      do {                                                                       \
22          printf(&quot;%s:%s:%d:\t&quot;, __FILE__, __FUNCTION__, __LINE__);               \
23          printf(__VA_ARGS__);                                                   \
24          printf(&quot;\n&quot;);                                                          \
25      } while (0);
26  #endif
27  #define initEntry(e)                                                           \
28      do {                                                                       \
29          (e)-&gt;zi = (e)-&gt;value = NULL;                                           \
30          (e)-&gt;longval = -123456789;                                             \
31          (e)-&gt;quicklist = NULL;                                                 \
32          (e)-&gt;node = NULL;                                                      \
33          (e)-&gt;offset = 123456789;                                               \
34          (e)-&gt;sz = 0;                                                           \
35      } while (0)
36  #if __GNUC__ &gt;= 3
37  #define likely(x) __builtin_expect(!!(x), 1)
38  #define unlikely(x) __builtin_expect(!!(x), 0)
39  #else
40  #define likely(x) (x)
41  #define unlikely(x) (x)
42  #endif
43  quicklist *quicklistCreate(void) {
44      struct quicklist *quicklist;
45      quicklist = zmalloc(sizeof(*quicklist));
46      quicklist-&gt;head = quicklist-&gt;tail = NULL;
47      quicklist-&gt;len = 0;
48      quicklist-&gt;count = 0;
49      quicklist-&gt;compress = 0;
50      quicklist-&gt;fill = -2;
51      return quicklist;
52  }
53  #define COMPRESS_MAX (1 &lt;&lt; 16)
54  void quicklistSetCompressDepth(quicklist *quicklist, int compress) {
55      if (compress &gt; COMPRESS_MAX) {
56          compress = COMPRESS_MAX;
57      } else if (compress &lt; 0) {
58          compress = 0;
59      }
60      quicklist-&gt;compress = compress;
61  }
62  #define FILL_MAX (1 &lt;&lt; 15)
63  void quicklistSetFill(quicklist *quicklist, int fill) {
64      if (fill &gt; FILL_MAX) {
65          fill = FILL_MAX;
66      } else if (fill &lt; -5) {
67          fill = -5;
68      }
69      quicklist-&gt;fill = fill;
70  }
71  void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {
72      quicklistSetFill(quicklist, fill);
73      quicklistSetCompressDepth(quicklist, depth);
74  }
75  quicklist *quicklistNew(int fill, int compress) {
76      quicklist *quicklist = quicklistCreate();
77      quicklistSetOptions(quicklist, fill, compress);
78      return quicklist;
79  }
80  REDIS_STATIC quicklistNode *quicklistCreateNode(void) {
81      quicklistNode *node;
82      node = zmalloc(sizeof(*node));
83      node-&gt;zl = NULL;
84      node-&gt;count = 0;
85      node-&gt;sz = 0;
86      node-&gt;next = node-&gt;prev = NULL;
87      node-&gt;encoding = QUICKLIST_NODE_ENCODING_RAW;
88      node-&gt;container = QUICKLIST_NODE_CONTAINER_ZIPLIST;
89      node-&gt;recompress = 0;
90      return node;
91  }
92  PORT_ULONG quicklistCount(const quicklist *ql) { return (PORT_ULONG)(ql-&gt;count); } WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
93  void quicklistRelease(quicklist *quicklist) {
94      PORT_ULONG len;
95      quicklistNode *current, *next;
96      current = quicklist-&gt;head;
97      len = quicklist-&gt;len;
98      while (len--) {
99          next = current-&gt;next;
100          zfree(current-&gt;zl);
101          quicklist-&gt;count -= current-&gt;count;
102          zfree(current);
103          quicklist-&gt;len--;
104          current = next;
105      }
106      zfree(quicklist);
107  }
108  REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
109  #ifdef REDIS_TEST
110      node-&gt;attempted_compress = 1;
111  #endif
112      if (node-&gt;sz &lt; MIN_COMPRESS_BYTES)
113          return 0;
114      quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node-&gt;sz);
115      if (((lzf-&gt;sz = lzf_compress(node-&gt;zl, node-&gt;sz, lzf-&gt;compressed,
116                                   node-&gt;sz)) == 0) ||
117          lzf-&gt;sz + MIN_COMPRESS_IMPROVE &gt;= node-&gt;sz) {
118          zfree(lzf);
119          return 0;
120      }
121      lzf = zrealloc(lzf, sizeof(*lzf) + lzf-&gt;sz);
122      zfree(node-&gt;zl);
123      node-&gt;zl = (unsigned char *)lzf;
124      node-&gt;encoding = QUICKLIST_NODE_ENCODING_LZF;
125      node-&gt;recompress = 0;
126      return 1;
127  }
128  #define quicklistCompressNode(_node)                                           \
129      do {                                                                       \
130          if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_RAW) {     \
131              __quicklistCompressNode((_node));                                  \
132          }                                                                      \
133      } while (0)
134  REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
135  #ifdef REDIS_TEST
136      node-&gt;attempted_compress = 0;
137  #endif
138      void *decompressed = zmalloc(node-&gt;sz);
139      quicklistLZF *lzf = (quicklistLZF *)node-&gt;zl;
140      if (lzf_decompress(lzf-&gt;compressed, lzf-&gt;sz, decompressed, node-&gt;sz) == 0) {
141          zfree(decompressed);
142          return 0;
143      }
144      zfree(lzf);
145      node-&gt;zl = decompressed;
146      node-&gt;encoding = QUICKLIST_NODE_ENCODING_RAW;
147      return 1;
148  }
149  #define quicklistDecompressNode(_node)                                         \
150      do {                                                                       \
151          if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) {     \
152              __quicklistDecompressNode((_node));                                \
153          }                                                                      \
154      } while (0)
155  #define quicklistDecompressNodeForUse(_node)                                   \
156      do {                                                                       \
157          if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) {     \
158              __quicklistDecompressNode((_node));                                \
159              (_node)-&gt;recompress = 1;                                           \
160          }                                                                      \
161      } while (0)
162  size_t quicklistGetLzf(const quicklistNode *node, void **data) {
163      quicklistLZF *lzf = (quicklistLZF *)node-&gt;zl;
164      *data = lzf-&gt;compressed;
165      return lzf-&gt;sz;
166  }
167  #define quicklistAllowsCompression(_ql) ((_ql)-&gt;compress != 0)
168  REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,
169                                        quicklistNode *node) {
170      if (!quicklistAllowsCompression(quicklist) ||
171          quicklist-&gt;len &lt; (unsigned int)(quicklist-&gt;compress * 2))
172          return;
173  #if 0
174      if (quicklist-&gt;compress == 1) {
175          quicklistNode *h = quicklist-&gt;head, *t = quicklist-&gt;tail;
176          quicklistDecompressNode(h);
177          quicklistDecompressNode(t);
178          if (h != node &amp;&amp; t != node)
179              quicklistCompressNode(node);
180          return;
181      } else if (quicklist-&gt;compress == 2) {
182          quicklistNode *h = quicklist-&gt;head, *hn = h-&gt;next, *hnn = hn-&gt;next;
183          quicklistNode *t = quicklist-&gt;tail, *tp = t-&gt;prev, *tpp = tp-&gt;prev;
184          quicklistDecompressNode(h);
185          quicklistDecompressNode(hn);
186          quicklistDecompressNode(t);
187          quicklistDecompressNode(tp);
188          if (h != node &amp;&amp; hn != node &amp;&amp; t != node &amp;&amp; tp != node) {
189              quicklistCompressNode(node);
190          }
191          if (hnn != t) {
192              quicklistCompressNode(hnn);
193          }
194          if (tpp != h) {
195              quicklistCompressNode(tpp);
196          }
197          return;
198      }
199  #endif
200      quicklistNode *forward = quicklist-&gt;head;
201      quicklistNode *reverse = quicklist-&gt;tail;
202      int depth = 0;
203      int in_depth = 0;
204      while (depth++ &lt; quicklist-&gt;compress) {
205          quicklistDecompressNode(forward);
206          quicklistDecompressNode(reverse);
207          if (forward == node || reverse == node)
208              in_depth = 1;
209          if (forward == reverse)
210              return;
211          forward = forward-&gt;next;
212          reverse = reverse-&gt;prev;
213      }
214      if (!in_depth)
215          quicklistCompressNode(node);
216      if (depth &gt; 2) {
217          quicklistCompressNode(forward);
218          quicklistCompressNode(reverse);
219      }
220  }
221  #define quicklistCompress(_ql, _node)                                          \
222      do {                                                                       \
223          if ((_node)-&gt;recompress)                                               \
224              quicklistCompressNode((_node));                                    \
225          else                                                                   \
226              __quicklistCompress((_ql), (_node));                               \
227      } while (0)
228  #define quicklistRecompressOnly(_ql, _node)                                    \
229      do {                                                                       \
230          if ((_node)-&gt;recompress)                                               \
231              quicklistCompressNode((_node));                                    \
232      } while (0)
233  REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
234                                          quicklistNode *old_node,
235                                          quicklistNode *new_node, int after) {
236      if (after) {
237          new_node-&gt;prev = old_node;
238          if (old_node) {
239              new_node-&gt;next = old_node-&gt;next;
240              if (old_node-&gt;next)
241                  old_node-&gt;next-&gt;prev = new_node;
242              old_node-&gt;next = new_node;
243          }
244          if (quicklist-&gt;tail == old_node)
245              quicklist-&gt;tail = new_node;
246      } else {
247          new_node-&gt;next = old_node;
248          if (old_node) {
249              new_node-&gt;prev = old_node-&gt;prev;
250              if (old_node-&gt;prev)
251                  old_node-&gt;prev-&gt;next = new_node;
252              old_node-&gt;prev = new_node;
253          }
254          if (quicklist-&gt;head == old_node)
255              quicklist-&gt;head = new_node;
256      }
257      if (quicklist-&gt;len == 0) {
258          quicklist-&gt;head = quicklist-&gt;tail = new_node;
259      }
260      if (old_node)
261          quicklistCompress(quicklist, old_node);
262      quicklist-&gt;len++;
263  }
264  REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
265                                               quicklistNode *old_node,
266                                               quicklistNode *new_node) {
267      __quicklistInsertNode(quicklist, old_node, new_node, 0);
268  }
269  REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
270                                              quicklistNode *old_node,
271                                              quicklistNode *new_node) {
272      __quicklistInsertNode(quicklist, old_node, new_node, 1);
273  }
274  REDIS_STATIC int
275  _quicklistNodeSizeMeetsOptimizationRequirement(const size_t sz,
276                                                 const int fill) {
277      if (fill &gt;= 0)
278          return 0;
279      size_t offset = (-fill) - 1;
280      if (offset &lt; (sizeof(optimization_level) / sizeof(*optimization_level))) {
281          if (sz &lt;= optimization_level[offset]) {
282              return 1;
283          } else {
284              return 0;
285          }
286      } else {
287          return 0;
288      }
289  }
290  #define sizeMeetsSafetyLimit(sz) ((sz) &lt;= SIZE_SAFETY_LIMIT)
291  REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,
292                                             const int fill, const size_t sz) {
293      if (unlikely(!node))
294          return 0;
295      int ziplist_overhead;
296      if (sz &lt; 254)
297          ziplist_overhead = 1;
298      else
299          ziplist_overhead = 5;
300      if (sz &lt; 64)
301          ziplist_overhead += 1;
302      else if (likely(sz &lt; 16384))
303          ziplist_overhead += 2;
304      else
305          ziplist_overhead += 5;
306      unsigned int new_sz = (unsigned int)(node-&gt;sz + sz + ziplist_overhead);     WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
307      if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))
308          return 1;
309      else if (!sizeMeetsSafetyLimit(new_sz))
310          return 0;
311      else if ((int)node-&gt;count &lt; fill)
312          return 1;
313      else
314          return 0;
315  }
316  REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,
317                                            const quicklistNode *b,
318                                            const int fill) {
319      if (!a || !b)
320          return 0;
321      unsigned int merge_sz = a-&gt;sz + b-&gt;sz - 11;
322      if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz, fill)))
323          return 1;
324      else if (!sizeMeetsSafetyLimit(merge_sz))
325          return 0;
326      else if ((int)(a-&gt;count + b-&gt;count) &lt;= fill)
327          return 1;
328      else
329          return 0;
330  }
331  #define quicklistNodeUpdateSz(node)                                            \
332      do {                                                                       \
333          (node)-&gt;sz = ziplistBlobLen((node)-&gt;zl);                               \
334      } while (0)
335  int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
336      quicklistNode *orig_head = quicklist-&gt;head;
337      if (likely(
<span onclick='openModal()' class='match'>338              _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) {
339          quicklist-&gt;head-&gt;zl =
340              ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);
341          quicklistNodeUpdateSz(quicklist-&gt;head);
342      } else {
343          quicklistNode *node = quicklistCreateNode();
344          node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
345          quicklistNodeUpdateSz(node);
346          _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);
347      }
348      quicklist-&gt;count++;
349      quicklist-&gt;head-&gt;count++;
350      return (orig_head != quicklist-&gt;head);
351  }
352  int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
</span>353      quicklistNode *orig_tail = quicklist-&gt;tail;
354      if (likely(
355              _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) {
356          quicklist-&gt;tail-&gt;zl =
357              ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);
358          quicklistNodeUpdateSz(quicklist-&gt;tail);
359      } else {
360          quicklistNode *node = quicklistCreateNode();
361          node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);
362          quicklistNodeUpdateSz(node);
363          _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);
364      }
365      quicklist-&gt;count++;
366      quicklist-&gt;tail-&gt;count++;
367      return (orig_tail != quicklist-&gt;tail);
368  }
369  void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {
370      quicklistNode *node = quicklistCreateNode();
371      node-&gt;zl = zl;
372      node-&gt;count = ziplistLen(node-&gt;zl);
373      node-&gt;sz = ziplistBlobLen(zl);
374      _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);
375      quicklist-&gt;count += node-&gt;count;
376  }
377  quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,
378                                              unsigned char *zl) {
379      unsigned char *value;
380      unsigned int sz;
381      PORT_LONGLONG longval;
382      char longstr[32] = {0};
383      unsigned char *p = ziplistIndex(zl, 0);
384      while (ziplistGet(p, &amp;value, &amp;sz, &amp;longval)) {
385          if (!value) {
386              sz = ll2string(longstr, sizeof(longstr), longval);
387              value = (unsigned char *)longstr;
388          }
389          quicklistPushTail(quicklist, value, sz);
390          p = ziplistNext(zl, p);
391      }
392      zfree(zl);
393      return quicklist;
394  }
395  quicklist *quicklistCreateFromZiplist(int fill, int compress,
396                                        unsigned char *zl) {
397      return quicklistAppendValuesFromZiplist(quicklistNew(fill, compress), zl);
398  }
399  #define quicklistDeleteIfEmpty(ql, n)                                          \
400      do {                                                                       \
401          if ((n)-&gt;count == 0) {                                                 \
402              __quicklistDelNode((ql), (n));                                     \
403              (n) = NULL;                                                        \
404          }                                                                      \
405      } while (0)
406  REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,
407                                       quicklistNode *node) {
408      if (node-&gt;next)
409          node-&gt;next-&gt;prev = node-&gt;prev;
410      if (node-&gt;prev)
411          node-&gt;prev-&gt;next = node-&gt;next;
412      if (node == quicklist-&gt;tail) {
413          quicklist-&gt;tail = node-&gt;prev;
414      }
415      if (node == quicklist-&gt;head) {
416          quicklist-&gt;head = node-&gt;next;
417      }
418      __quicklistCompress(quicklist, NULL);
419      quicklist-&gt;count -= node-&gt;count;
420      zfree(node-&gt;zl);
421      zfree(node);
422      quicklist-&gt;len--;
423  }
424  REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
425                                     unsigned char **p) {
426      int gone = 0;
427      node-&gt;zl = ziplistDelete(node-&gt;zl, p);
428      node-&gt;count--;
429      if (node-&gt;count == 0) {
430          gone = 1;
431          __quicklistDelNode(quicklist, node);
432      } else {
433          quicklistNodeUpdateSz(node);
434      }
435      quicklist-&gt;count--;
436      return gone ? 1 : 0;
437  }
438  void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
439      quicklistNode *prev = entry-&gt;node-&gt;prev;
440      quicklistNode *next = entry-&gt;node-&gt;next;
441      int deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,
442                                           entry-&gt;node, &amp;entry-&gt;zi);
443      iter-&gt;zi = NULL;
444      if (deleted_node) {
445          if (iter-&gt;direction == AL_START_HEAD) {
446              iter-&gt;current = next;
447              iter-&gt;offset = 0;
448          } else if (iter-&gt;direction == AL_START_TAIL) {
449              iter-&gt;current = prev;
450              iter-&gt;offset = -1;
451          }
452      }
453  }
454  int quicklistReplaceAtIndex(quicklist *quicklist, PORT_LONG index, void *data,
455                              int sz) {
456      quicklistEntry entry;
457      if (likely(quicklistIndex(quicklist, index, &amp;entry))) {
458          entry.node-&gt;zl = ziplistDelete(entry.node-&gt;zl, &amp;entry.zi);
459          entry.node-&gt;zl = ziplistInsert(entry.node-&gt;zl, entry.zi, data, sz);
460          quicklistNodeUpdateSz(entry.node);
461          quicklistCompress(quicklist, entry.node);
462          return 1;
463      } else {
464          return 0;
465      }
466  }
467  REDIS_STATIC quicklistNode *_quicklistZiplistMerge(quicklist *quicklist,
468                                                     quicklistNode *a,
469                                                     quicklistNode *b) {
470      D(&quot;Requested merge (a,b) (%u, %u)&quot;, a-&gt;count, b-&gt;count);
471      quicklistDecompressNode(a);
472      quicklistDecompressNode(b);
473      if ((ziplistMerge(&amp;a-&gt;zl, &amp;b-&gt;zl))) {
474          quicklistNode *keep = NULL, *nokeep = NULL;
475          if (!a-&gt;zl) {
476              nokeep = a;
477              keep = b;
478          } else if (!b-&gt;zl) {
479              nokeep = b;
480              keep = a;
481          }
482          keep-&gt;count = ziplistLen(keep-&gt;zl);
483          quicklistNodeUpdateSz(keep);
484          nokeep-&gt;count = 0;
485          __quicklistDelNode(quicklist, nokeep);
486          quicklistCompress(quicklist, keep);
487          return keep;
488      } else {
489          return NULL;
490      }
491  }
492  REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,
493                                         quicklistNode *center) {
494      int fill = quicklist-&gt;fill;
495      quicklistNode *prev, *prev_prev, *next, *next_next, *target;
496      prev = prev_prev = next = next_next = target = NULL;
497      if (center-&gt;prev) {
498          prev = center-&gt;prev;
499          if (center-&gt;prev-&gt;prev)
500              prev_prev = center-&gt;prev-&gt;prev;
501      }
502      if (center-&gt;next) {
503          next = center-&gt;next;
504          if (center-&gt;next-&gt;next)
505              next_next = center-&gt;next-&gt;next;
506      }
507      if (_quicklistNodeAllowMerge(prev, prev_prev, fill)) {
508          _quicklistZiplistMerge(quicklist, prev_prev, prev);
509          prev_prev = prev = NULL; &amp;bsol;* they could have moved, invalidate them. */
510      }
511      if (_quicklistNodeAllowMerge(next, next_next, fill)) {
512          _quicklistZiplistMerge(quicklist, next, next_next);
513          next = next_next = NULL; &amp;bsol;* they could have moved, invalidate them. */
514      }
515      if (_quicklistNodeAllowMerge(center, center-&gt;prev, fill)) {
516          target = _quicklistZiplistMerge(quicklist, center-&gt;prev, center);
517          center = NULL; &amp;bsol;* center could have been deleted, invalidate it. */
518      } else {
519          target = center;
520      }
521      if (_quicklistNodeAllowMerge(target, target-&gt;next, fill)) {
522          _quicklistZiplistMerge(quicklist, target, target-&gt;next);
523      }
524  }
525  REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,
526                                                  int after) {
527      size_t zl_sz = node-&gt;sz;
528      quicklistNode *new_node = quicklistCreateNode();
529      new_node-&gt;zl = zmalloc(zl_sz);
530      memcpy(new_node-&gt;zl, node-&gt;zl, zl_sz);
531      int orig_start = after ? offset + 1 : 0;
532      int orig_extent = after ? -1 : offset;
533      int new_start = after ? 0 : offset;
534      int new_extent = after ? offset + 1 : -1;
535      D(&quot;After %d (%d); ranges: [%d, %d], [%d, %d]&quot;, after, offset, orig_start,
536        orig_extent, new_start, new_extent);
537      node-&gt;zl = ziplistDeleteRange(node-&gt;zl, orig_start, orig_extent);
538      node-&gt;count = ziplistLen(node-&gt;zl);
539      quicklistNodeUpdateSz(node);
540      new_node-&gt;zl = ziplistDeleteRange(new_node-&gt;zl, new_start, new_extent);
541      new_node-&gt;count = ziplistLen(new_node-&gt;zl);
542      quicklistNodeUpdateSz(new_node);
543      D(&quot;After split lengths: orig (%d), new (%d)&quot;, node-&gt;count, new_node-&gt;count);
544      return new_node;
545  }
546  REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,
547                                     void *value, const size_t sz, int after) {
548      int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;
549      int fill = quicklist-&gt;fill;
550      quicklistNode *node = entry-&gt;node;
551      quicklistNode *new_node = NULL;
552      if (!node) {
553          D(&quot;No node given!&quot;);
554          new_node = quicklistCreateNode();
555          new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
556          __quicklistInsertNode(quicklist, NULL, new_node, after);
557          new_node-&gt;count++;
558          quicklist-&gt;count++;
559          return;
560      }
561      if (!_quicklistNodeAllowInsert(node, fill, sz)) {
562          D(&quot;Current node is full with count %d with requested fill %Iu&quot;,                    WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
563            node-&gt;count, fill);
564          full = 1;
565      }
566      if (after &amp;&amp; (entry-&gt;offset == node-&gt;count)) {
567          D(&quot;At Tail of current ziplist&quot;);
568          at_tail = 1;
569          if (!_quicklistNodeAllowInsert(node-&gt;next, fill, sz)) {
570              D(&quot;Next node is full too.&quot;);
571              full_next = 1;
572          }
573      }
574      if (!after &amp;&amp; (entry-&gt;offset == 0)) {
575          D(&quot;At Head&quot;);
576          at_head = 1;
577          if (!_quicklistNodeAllowInsert(node-&gt;prev, fill, sz)) {
578              D(&quot;Prev node is full too.&quot;);
579              full_prev = 1;
580          }
581      }
582      if (!full &amp;&amp; after) {
583          D(&quot;Not full, inserting after current position.&quot;);
584          quicklistDecompressNodeForUse(node);
585          unsigned char *next = ziplistNext(node-&gt;zl, entry-&gt;zi);
586          if (next == NULL) {
587              node-&gt;zl = ziplistPush(node-&gt;zl, value, sz, ZIPLIST_TAIL);
588          } else {
589              node-&gt;zl = ziplistInsert(node-&gt;zl, next, value, sz);
590          }
591          node-&gt;count++;
592          quicklistNodeUpdateSz(node);
593          quicklistRecompressOnly(quicklist, node);
594      } else if (!full &amp;&amp; !after) {
595          D(&quot;Not full, inserting before current position.&quot;);
596          quicklistDecompressNodeForUse(node);
597          node-&gt;zl = ziplistInsert(node-&gt;zl, entry-&gt;zi, value, sz);
598          node-&gt;count++;
599          quicklistNodeUpdateSz(node);
600          quicklistRecompressOnly(quicklist, node);
601      } else if (full &amp;&amp; at_tail &amp;&amp; node-&gt;next &amp;&amp; !full_next &amp;&amp; after) {
602          D(&quot;Full and tail, but next isn&#x27;t full; inserting next node head&quot;);
603          new_node = node-&gt;next;
604          quicklistDecompressNodeForUse(new_node);
605          new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_HEAD);
606          new_node-&gt;count++;
607          quicklistNodeUpdateSz(new_node);
608          quicklistRecompressOnly(quicklist, new_node);
609      } else if (full &amp;&amp; at_head &amp;&amp; node-&gt;prev &amp;&amp; !full_prev &amp;&amp; !after) {
610          D(&quot;Full and head, but prev isn&#x27;t full, inserting prev node tail&quot;);
611          new_node = node-&gt;prev;
612          quicklistDecompressNodeForUse(new_node);
613          new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_TAIL);
614          new_node-&gt;count++;
615          quicklistNodeUpdateSz(new_node);
616          quicklistRecompressOnly(quicklist, new_node);
617      } else if (full &amp;&amp; ((at_tail &amp;&amp; node-&gt;next &amp;&amp; full_next &amp;&amp; after) ||
618                          (at_head &amp;&amp; node-&gt;prev &amp;&amp; full_prev &amp;&amp; !after))) {
619          D(&quot;\tprovisioning new node...&quot;);
620          new_node = quicklistCreateNode();
621          new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
622          new_node-&gt;count++;
623          quicklistNodeUpdateSz(new_node);
624          __quicklistInsertNode(quicklist, node, new_node, after);
625      } else if (full) {
626          D(&quot;\tsplitting node...&quot;);
627          quicklistDecompressNodeForUse(node);
628          new_node = _quicklistSplitNode(node, entry-&gt;offset, after);
629          new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz,
630                                     after ? ZIPLIST_HEAD : ZIPLIST_TAIL);
631          new_node-&gt;count++;
632          quicklistNodeUpdateSz(new_node);
633          __quicklistInsertNode(quicklist, node, new_node, after);
634          _quicklistMergeNodes(quicklist, node);
635      }
636      quicklist-&gt;count++;
637  }
638  void quicklistInsertBefore(quicklist *quicklist, quicklistEntry *entry,
639                             void *value, const size_t sz) {
640      _quicklistInsert(quicklist, entry, value, sz, 0);
641  }
642  void quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,
643                            void *value, const size_t sz) {
644      _quicklistInsert(quicklist, entry, value, sz, 1);
645  }
646  int quicklistDelRange(quicklist *quicklist, const PORT_LONG start,
647                        const PORT_LONG count) {
648      if (count &lt;= 0)
649          return 0;
650      PORT_ULONG extent = count; &amp;bsol;* range is inclusive of start position */
651      if (start &gt;= 0 &amp;&amp; extent &gt; (quicklist-&gt;count - start)) {
652          extent = quicklist-&gt;count - start;
653      } else if (start &lt; 0 &amp;&amp; extent &gt; (PORT_ULONG)(-start)) {
654          extent = -start; &amp;bsol;* c.f. LREM -29 29; just delete until end. */
655      }
656      quicklistEntry entry;
657      if (!quicklistIndex(quicklist, start, &amp;entry))
658          return 0;
659      D(&quot;Quicklist delete request for start %Id, count %Id, extent: %Id&quot;, start,                 WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
660        count, extent);
661      quicklistNode *node = entry.node;
662      while (extent) {
663          quicklistNode *next = node-&gt;next;
664          PORT_ULONG del;
665          int delete_entire_node = 0;
666          if (entry.offset == 0 &amp;&amp; extent &gt;= node-&gt;count) {
667              delete_entire_node = 1;
668              del = node-&gt;count;
669          } else if (entry.offset &gt;= 0 &amp;&amp; extent &gt;= node-&gt;count) {
670              del = node-&gt;count - entry.offset;
671          } else if (entry.offset &lt; 0) {
672              del = -entry.offset;
673              if (del &gt; extent)
674                  del = extent;
675          } else {
676              del = extent;
677          }
678          D(&quot;[%Id]: asking to del: %Id because offset: %d; (ENTIRE NODE: %d), &quot;                             WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
679            &quot;node count: %u&quot;,
680            extent, del, entry.offset, delete_entire_node, node-&gt;count);
681          if (delete_entire_node) {
682              __quicklistDelNode(quicklist, node);
683          } else {
684              quicklistDecompressNodeForUse(node);
685              node-&gt;zl = ziplistDeleteRange(node-&gt;zl, entry.offset, del);
686              quicklistNodeUpdateSz(node);
687              node-&gt;count -= del;
688              quicklist-&gt;count -= del;
689              quicklistDeleteIfEmpty(quicklist, node);
690              if (node)
691                  quicklistRecompressOnly(quicklist, node);
692          }
693          extent -= del;
694          node = next;
695          entry.offset = 0;
696      }
697      return 1;
698  }
699  int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len) {
700      return ziplistCompare(p1, p2, p2_len);
701  }
702  quicklistIter *quicklistGetIterator(const quicklist *quicklist, int direction) {
703      quicklistIter *iter;
704      iter = zmalloc(sizeof(*iter));
705      if (direction == AL_START_HEAD) {
706          iter-&gt;current = quicklist-&gt;head;
707          iter-&gt;offset = 0;
708      } else if (direction == AL_START_TAIL) {
709          iter-&gt;current = quicklist-&gt;tail;
710          iter-&gt;offset = -1;
711      }
712      iter-&gt;direction = direction;
713      iter-&gt;quicklist = quicklist;
714      iter-&gt;zi = NULL;
715      return iter;
716  }
717  quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist,
718                                           const int direction,
719                                           const PORT_LONGLONG idx) {
720      quicklistEntry entry;
721      if (quicklistIndex(quicklist, idx, &amp;entry)) {
722          quicklistIter *base = quicklistGetIterator(quicklist, direction);
723          base-&gt;zi = NULL;
724          base-&gt;current = entry.node;
725          base-&gt;offset = entry.offset;
726          return base;
727      } else {
728          return NULL;
729      }
730  }
731  void quicklistReleaseIterator(quicklistIter *iter) {
732      if (iter-&gt;current)
733          quicklistCompress(iter-&gt;quicklist, iter-&gt;current);
734      zfree(iter);
735  }
736  int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {
737      initEntry(entry);
738      if (!iter) {
739          D(&quot;Returning because no iter!&quot;);
740          return 0;
741      }
742      entry-&gt;quicklist = iter-&gt;quicklist;
743      entry-&gt;node = iter-&gt;current;
744      if (!iter-&gt;current) {
745          D(&quot;Returning because current node is NULL&quot;)
746          return 0;
747      }
748      unsigned char *(*nextFn)(unsigned char *, unsigned char *) = NULL;
749      int offset_update = 0;
750      if (!iter-&gt;zi) {
751          quicklistDecompressNodeForUse(iter-&gt;current);
752          iter-&gt;zi = ziplistIndex(iter-&gt;current-&gt;zl, iter-&gt;offset);
753      } else {
754          if (iter-&gt;direction == AL_START_HEAD) {
755              nextFn = ziplistNext;
756              offset_update = 1;
757          } else if (iter-&gt;direction == AL_START_TAIL) {
758              nextFn = ziplistPrev;
759              offset_update = -1;
760          }
761          iter-&gt;zi = nextFn(iter-&gt;current-&gt;zl, iter-&gt;zi);
762          iter-&gt;offset += offset_update;
763      }
764      entry-&gt;zi = iter-&gt;zi;
765      entry-&gt;offset = iter-&gt;offset;
766      if (iter-&gt;zi) {
767          ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval);
768          return 1;
769      } else {
770          quicklistCompress(iter-&gt;quicklist, iter-&gt;current);
771          if (iter-&gt;direction == AL_START_HEAD) {
772              D(&quot;Jumping to start of next node&quot;);
773              iter-&gt;current = iter-&gt;current-&gt;next;
774              iter-&gt;offset = 0;
775          } else if (iter-&gt;direction == AL_START_TAIL) {
776              D(&quot;Jumping to end of previous node&quot;);
777              iter-&gt;current = iter-&gt;current-&gt;prev;
778              iter-&gt;offset = -1;
779          }
780          iter-&gt;zi = NULL;
781          return quicklistNext(iter, entry);
782      }
783  }
784  quicklist *quicklistDup(quicklist *orig) {
785      quicklist *copy;
786      copy = quicklistNew(orig-&gt;fill, orig-&gt;compress);
787      for (quicklistNode *current = orig-&gt;head; current;
788           current = current-&gt;next) {
789          quicklistNode *node = quicklistCreateNode();
790          if (current-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) {
791              quicklistLZF *lzf = (quicklistLZF *)current-&gt;zl;
792              size_t lzf_sz = sizeof(*lzf) + lzf-&gt;sz;
793              node-&gt;zl = zmalloc(lzf_sz);
794              memcpy(node-&gt;zl, current-&gt;zl, lzf_sz);
795          } else if (current-&gt;encoding == QUICKLIST_NODE_ENCODING_RAW) {
796              node-&gt;zl = zmalloc(current-&gt;sz);
797              memcpy(node-&gt;zl, current-&gt;zl, current-&gt;sz);
798          }
799          node-&gt;count = current-&gt;count;
800          copy-&gt;count += node-&gt;count;
801          node-&gt;sz = current-&gt;sz;
802          node-&gt;encoding = current-&gt;encoding;
803          _quicklistInsertNodeAfter(copy, copy-&gt;tail, node);
804      }
805      return copy;
806  }
807  int quicklistIndex(const quicklist *quicklist, const PORT_LONGLONG idx,
808                     quicklistEntry *entry) {
809      quicklistNode *n;
810      PORT_ULONGLONG accum = 0;
811      PORT_ULONGLONG index;
812      int forward = idx &lt; 0 ? 0 : 1; &amp;bsol;* &lt; 0 -&gt; reverse, 0+ -&gt; forward */
813      initEntry(entry);
814      entry-&gt;quicklist = quicklist;
815      if (!forward) {
816          index = (-idx) - 1;
817          n = quicklist-&gt;tail;
818      } else {
819          index = idx;
820          n = quicklist-&gt;head;
821      }
822      if (index &gt;= quicklist-&gt;count)
823          return 0;
824      while (likely(n)) {
825          if ((accum + n-&gt;count) &gt; index) {
826              break;
827          } else {
828              D(&quot;Skipping over (%p) %u at accum %lld&quot;, (void *)n, n-&gt;count,
829                accum);
830              accum += n-&gt;count;
831              n = forward ? n-&gt;next : n-&gt;prev;
832          }
833      }
834      if (!n)
835          return 0;
836      D(&quot;Found node: %p at accum %llu, idx %llu, sub+ %llu, sub- %llu&quot;, (void *)n,
837        accum, index, index - accum, (-index) - 1 + accum);
838      entry-&gt;node = n;
839      if (forward) {
840          entry-&gt;offset = index - accum;
841      } else {
842          entry-&gt;offset = (-index) - 1 + accum;
843      }
844      quicklistDecompressNodeForUse(entry-&gt;node);
845      entry-&gt;zi = ziplistIndex(entry-&gt;node-&gt;zl, entry-&gt;offset);
846      ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval);
847      return 1;
848  }
849  void quicklistRotate(quicklist *quicklist) {
850      if (quicklist-&gt;count &lt;= 1)
851          return;
852      unsigned char *p = ziplistIndex(quicklist-&gt;tail-&gt;zl, -1);
853      unsigned char *value;
854      PORT_LONGLONG longval;
855      unsigned int sz;
856      char longstr[32] = {0};
857      ziplistGet(p, &amp;value, &amp;sz, &amp;longval);
858      if (!value) {
859          sz = ll2string(longstr, sizeof(longstr), longval);
860          value = (unsigned char *)longstr;
861      }
862      quicklistPushHead(quicklist, value, sz);
863      if (quicklist-&gt;len == 1) {
864          p = ziplistIndex(quicklist-&gt;tail-&gt;zl, -1);
865      }
866      quicklistDelIndex(quicklist, quicklist-&gt;tail, &amp;p);
867  }
868  int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,
869                         unsigned int *sz, PORT_LONGLONG *sval,
870                         void *(*saver)(unsigned char *data, unsigned int sz)) {
871      unsigned char *p;
872      unsigned char *vstr;
873      unsigned int vlen;
874      PORT_LONGLONG vlong;
875      int pos = (where == QUICKLIST_HEAD) ? 0 : -1;
876      if (quicklist-&gt;count == 0)
877          return 0;
878      if (data)
879          *data = NULL;
880      if (sz)
881          *sz = 0;
882      if (sval)
883          *sval = -123456789;
884      quicklistNode *node;
885      if (where == QUICKLIST_HEAD &amp;&amp; quicklist-&gt;head) {
886          node = quicklist-&gt;head;
887      } else if (where == QUICKLIST_TAIL &amp;&amp; quicklist-&gt;tail) {
888          node = quicklist-&gt;tail;
889      } else {
890          return 0;
891      }
892      p = ziplistIndex(node-&gt;zl, pos);
893      if (ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vlong)) {
894          if (vstr) {
895              if (data)
896                  *data = saver(vstr, vlen);
897              if (sz)
898                  *sz = vlen;
899          } else {
900              if (data)
901                  *data = NULL;
902              if (sval)
903                  *sval = vlong;
904          }
905          quicklistDelIndex(quicklist, node, &amp;p);
906          return 1;
907      }
908      return 0;
909  }
910  REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) {
911      unsigned char *vstr;
912      if (data) {
913          vstr = zmalloc(sz);
914          memcpy(vstr, data, sz);
915          return vstr;
916      }
917      return NULL;
918  }
919  int quicklistPop(quicklist *quicklist, int where, unsigned char **data,
920                   unsigned int *sz, PORT_LONGLONG *slong) {
921      unsigned char *vstr;
922      unsigned int vlen;
923      PORT_LONGLONG vlong;
924      if (quicklist-&gt;count == 0)
925          return 0;
926      int ret = quicklistPopCustom(quicklist, where, &amp;vstr, &amp;vlen, &amp;vlong,
927                                   _quicklistSaver);
928      if (data)
929          *data = vstr;
930      if (slong)
931          *slong = vlong;
932      if (sz)
933          *sz = vlen;
934      return ret;
935  }
936  void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
937                     int where) {
938      if (where == QUICKLIST_HEAD) {
939          quicklistPushHead(quicklist, value, sz);
940      } else if (where == QUICKLIST_TAIL) {
941          quicklistPushTail(quicklist, value, sz);
942      }
943  }
944  #ifdef REDIS_TEST
945  #include &lt;stdint.h&gt;
946  #include &lt;sys/time.h&gt;
947  #define assert(_e)                                                             \
948      do {                                                                       \
949          if (!(_e)) {                                                           \
950              printf(&quot;\n\n=== ASSERTION FAILED ===\n&quot;);                          \
951              printf(&quot;==&gt; %s:%d &#x27;%s&#x27; is not true\n&quot;, __FILE__, __LINE__, #_e);   \
952              err++;                                                             \
953          }                                                                      \
954      } while (0)
955  #define yell(str, ...) printf(&quot;ERROR! &quot; str &quot;\n\n&quot;, __VA_ARGS__)
956  #define OK printf(&quot;\tOK\n&quot;)
957  #define ERROR                                                                  \
958      do {                                                                       \
959          printf(&quot;\tERROR!\n&quot;);                                                  \
960          err++;                                                                 \
961      } while (0)
962  #define ERR(x, ...)                                                            \
963      do {                                                                       \
964          printf(&quot;%s:%s:%d:\t&quot;, __FILE__, __FUNCTION__, __LINE__);               \
965          printf(&quot;ERROR! &quot; x &quot;\n&quot;, __VA_ARGS__);                                 \
966          err++;                                                                 \
967      } while (0)
968  #define TEST(name) printf(&quot;test — %s\n&quot;, name);
969  #define TEST_DESC(name, ...) printf(&quot;test — &quot; name &quot;\n&quot;, __VA_ARGS__);
970  #define QL_TEST_VERBOSE 0
971  #define UNUSED(x) (void)(x)
972  static void ql_info(quicklist *ql) {
973  #if QL_TEST_VERBOSE
974      printf(&quot;Container length: %lu\n&quot;, ql-&gt;len);
975      printf(&quot;Container size: %lu\n&quot;, ql-&gt;count);
976      if (ql-&gt;head)
977          printf(&quot;\t(zsize head: %d)\n&quot;, ziplistLen(ql-&gt;head-&gt;zl));
978      if (ql-&gt;tail)
979          printf(&quot;\t(zsize tail: %d)\n&quot;, ziplistLen(ql-&gt;tail-&gt;zl));
980      printf(&quot;\n&quot;);
981  #else
982      UNUSED(ql);
983  #endif
984  }
985  static PORT_LONGLONG ustime(void) {
986      struct timeval tv;
987      PORT_LONGLONG ust;
988      gettimeofday(&amp;tv, NULL);
989      ust = ((PORT_LONGLONG)tv.tv_sec) * 1000000;
990      ust += tv.tv_usec;
991      return ust;
992  }
993  static PORT_LONGLONG mstime(void) { return ustime() / 1000; }
994  static int _itrprintr(quicklist *ql, int print, int forward) {
995      quicklistIter *iter =
996          quicklistGetIterator(ql, forward ? AL_START_HEAD : AL_START_TAIL);
997      quicklistEntry entry;
998      int i = 0;
999      int p = 0;
1000      quicklistNode *prev = NULL;
1001      while (quicklistNext(iter, &amp;entry)) {
1002          if (entry.node != prev) {
1003              p++;
1004              prev = entry.node;
1005          }
1006          if (print) {
1007              printf(&quot;[%3d (%2d)]: [%.*s] (%lld)\n&quot;, i, p, entry.sz,
1008                     (char *)entry.value, entry.longval);
1009          }
1010          i++;
1011      }
1012      quicklistReleaseIterator(iter);
1013      return i;
1014  }
1015  static int itrprintr(quicklist *ql, int print) {
1016      return _itrprintr(ql, print, 1);
1017  }
1018  static int itrprintr_rev(quicklist *ql, int print) {
1019      return _itrprintr(ql, print, 0);
1020  }
1021  #define ql_verify(a, b, c, d, e)                                               \
1022      do {                                                                       \
1023          err += _ql_verify((a), (b), (c), (d), (e));                            \
1024      } while (0)
1025  static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,
1026                        uint32_t head_count, uint32_t tail_count) {
1027      int errors = 0;
1028      ql_info(ql);
1029      if (len != ql-&gt;len) {
1030          yell(&quot;quicklist length wrong: expected %d, got %u&quot;, len, ql-&gt;len);
1031          errors++;
1032      }
1033      if (count != ql-&gt;count) {
1034          yell(&quot;quicklist count wrong: expected %d, got %lu&quot;, count, ql-&gt;count);
1035          errors++;
1036      }
1037      int loopr = itrprintr(ql, 0);
1038      if (loopr != (int)ql-&gt;count) {
1039          yell(&quot;quicklist cached count not match actual count: expected %lu, got &quot;
1040               &quot;%d&quot;,
1041               ql-&gt;count, loopr);
1042          errors++;
1043      }
1044      int rloopr = itrprintr_rev(ql, 0);
1045      if (loopr != rloopr) {
1046          yell(&quot;quicklist has different forward count than reverse count!  &quot;
1047               &quot;Forward count is %d, reverse count is %d.&quot;,
1048               loopr, rloopr);
1049          errors++;
1050      }
1051      if (ql-&gt;len == 0 &amp;&amp; !errors) {
1052          OK;
1053          return errors;
1054      }
1055      if (ql-&gt;head &amp;&amp; head_count != ql-&gt;head-&gt;count &amp;&amp;
1056          head_count != ziplistLen(ql-&gt;head-&gt;zl)) {
1057          yell(&quot;quicklist head count wrong: expected %d, &quot;
1058               &quot;got cached %d vs. actual %d&quot;,
1059               head_count, ql-&gt;head-&gt;count, ziplistLen(ql-&gt;head-&gt;zl));
1060          errors++;
1061      }
1062      if (ql-&gt;tail &amp;&amp; tail_count != ql-&gt;tail-&gt;count &amp;&amp;
1063          tail_count != ziplistLen(ql-&gt;tail-&gt;zl)) {
1064          yell(&quot;quicklist tail count wrong: expected %d, &quot;
1065               &quot;got cached %u vs. actual %d&quot;,
1066               tail_count, ql-&gt;tail-&gt;count, ziplistLen(ql-&gt;tail-&gt;zl));
1067          errors++;
1068      }
1069      if (quicklistAllowsCompression(ql)) {
1070          quicklistNode *node = ql-&gt;head;
1071          unsigned int low_raw = ql-&gt;compress;
1072          unsigned int high_raw = ql-&gt;len - ql-&gt;compress;
1073          for (unsigned int at = 0; at &lt; ql-&gt;len; at++, node = node-&gt;next) {
1074              if (node &amp;&amp; (at &lt; low_raw || at &gt;= high_raw)) {
1075                  if (node-&gt;encoding != QUICKLIST_NODE_ENCODING_RAW) {
1076                      yell(&quot;Incorrect compression: node %d is &quot;
1077                           &quot;compressed at depth %d ((%u, %u); total &quot;
1078                           &quot;nodes: %u; size: %u; recompress: %d)&quot;,
1079                           at, ql-&gt;compress, low_raw, high_raw, ql-&gt;len, node-&gt;sz,
1080                           node-&gt;recompress);
1081                      errors++;
1082                  }
1083              } else {
1084                  if (node-&gt;encoding != QUICKLIST_NODE_ENCODING_LZF &amp;&amp;
1085                      !node-&gt;attempted_compress) {
1086                      yell(&quot;Incorrect non-compression: node %d is NOT &quot;
1087                           &quot;compressed at depth %d ((%u, %u); total &quot;
1088                           &quot;nodes: %u; size: %u; recompress: %d; attempted: %d)&quot;,
1089                           at, ql-&gt;compress, low_raw, high_raw, ql-&gt;len, node-&gt;sz,
1090                           node-&gt;recompress, node-&gt;attempted_compress);
1091                      errors++;
1092                  }
1093              }
1094          }
1095      }
1096      if (!errors)
1097          OK;
1098      return errors;
1099  }
1100  static char *genstr(char *prefix, int i) {
1101      static char result[64] = {0};
1102      snprintf(result, sizeof(result), &quot;%s%d&quot;, prefix, i);
1103      return result;
1104  }
1105  int quicklistTest(int argc, char *argv[]) {
1106      UNUSED(argc);
1107      UNUSED(argv);
1108      unsigned int err = 0;
1109      int optimize_start =
1110          -(int)(sizeof(optimization_level) / sizeof(*optimization_level));
1111      printf(&quot;Starting optimization offset at: %d\n&quot;, optimize_start);
1112      int options[] = {0, 1, 2, 3, 4, 5, 6, 10};
1113      size_t option_count = sizeof(options) / sizeof(*options);
1114      PORT_LONGLONG runtime[option_count];
1115      for (int _i = 0; _i &lt; (int)option_count; _i++) {
1116          printf(&quot;Testing Option %d\n&quot;, options[_i]);
1117          PORT_LONGLONG start = mstime();
1118          TEST(&quot;create list&quot;) {
1119              quicklist *ql = quicklistNew(-2, options[_i]);
1120              ql_verify(ql, 0, 0, 0, 0);
1121              quicklistRelease(ql);
1122          }
1123          TEST(&quot;add to tail of empty list&quot;) {
1124              quicklist *ql = quicklistNew(-2, options[_i]);
1125              quicklistPushTail(ql, &quot;hello&quot;, 6);
1126              ql_verify(ql, 1, 1, 1, 1);
1127              quicklistRelease(ql);
1128          }
1129          TEST(&quot;add to head of empty list&quot;) {
1130              quicklist *ql = quicklistNew(-2, options[_i]);
1131              quicklistPushHead(ql, &quot;hello&quot;, 6);
1132              ql_verify(ql, 1, 1, 1, 1);
1133              quicklistRelease(ql);
1134          }
1135          for (int f = optimize_start; f &lt; 32; f++) {
1136              TEST_DESC(&quot;add to tail 5x at fill %d at compress %d&quot;, f,
1137                        options[_i]) {
1138                  quicklist *ql = quicklistNew(f, options[_i]);
1139                  for (int i = 0; i &lt; 5; i++)
1140                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i), 32);
1141                  if (ql-&gt;count != 5)
1142                      ERROR;
1143                  if (f == 32)
1144                      ql_verify(ql, 1, 5, 5, 5);
1145                  quicklistRelease(ql);
1146              }
1147          }
1148          for (int f = optimize_start; f &lt; 32; f++) {
1149              TEST_DESC(&quot;add to head 5x at fill %d at compress %d&quot;, f,
1150                        options[_i]) {
1151                  quicklist *ql = quicklistNew(f, options[_i]);
1152                  for (int i = 0; i &lt; 5; i++)
1153                      quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1154                  if (ql-&gt;count != 5)
1155                      ERROR;
1156                  if (f == 32)
1157                      ql_verify(ql, 1, 5, 5, 5);
1158                  quicklistRelease(ql);
1159              }
1160          }
1161          for (int f = optimize_start; f &lt; 512; f++) {
1162              TEST_DESC(&quot;add to tail 500x at fill %d at compress %d&quot;, f,
1163                        options[_i]) {
1164                  quicklist *ql = quicklistNew(f, options[_i]);
1165                  for (int i = 0; i &lt; 500; i++)
1166                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i), 64);
1167                  if (ql-&gt;count != 500)
1168                      ERROR;
1169                  if (f == 32)
1170                      ql_verify(ql, 16, 500, 32, 20);
1171                  quicklistRelease(ql);
1172              }
1173          }
1174          for (int f = optimize_start; f &lt; 512; f++) {
1175              TEST_DESC(&quot;add to head 500x at fill %d at compress %d&quot;, f,
1176                        options[_i]) {
1177                  quicklist *ql = quicklistNew(f, options[_i]);
1178                  for (int i = 0; i &lt; 500; i++)
1179                      quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1180                  if (ql-&gt;count != 500)
1181                      ERROR;
1182                  if (f == 32)
1183                      ql_verify(ql, 16, 500, 20, 32);
1184                  quicklistRelease(ql);
1185              }
1186          }
1187          TEST(&quot;rotate empty&quot;) {
1188              quicklist *ql = quicklistNew(-2, options[_i]);
1189              quicklistRotate(ql);
1190              ql_verify(ql, 0, 0, 0, 0);
1191              quicklistRelease(ql);
1192          }
1193          for (int f = optimize_start; f &lt; 32; f++) {
1194              TEST(&quot;rotate one val once&quot;) {
1195                  quicklist *ql = quicklistNew(f, options[_i]);
1196                  quicklistPushHead(ql, &quot;hello&quot;, 6);
1197                  quicklistRotate(ql);
1198                  ql_verify(ql, 1, 1, 1, 1);
1199                  quicklistRelease(ql);
1200              }
1201          }
1202          for (int f = optimize_start; f &lt; 3; f++) {
1203              TEST_DESC(&quot;rotate 500 val 5000 times at fill %d at compress %d&quot;, f,
1204                        options[_i]) {
1205                  quicklist *ql = quicklistNew(f, options[_i]);
1206                  quicklistPushHead(ql, &quot;900&quot;, 3);
1207                  quicklistPushHead(ql, &quot;7000&quot;, 4);
1208                  quicklistPushHead(ql, &quot;-1200&quot;, 5);
1209                  quicklistPushHead(ql, &quot;42&quot;, 2);
1210                  for (int i = 0; i &lt; 500; i++)
1211                      quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 64);
1212                  ql_info(ql);
1213                  for (int i = 0; i &lt; 5000; i++) {
1214                      ql_info(ql);
1215                      quicklistRotate(ql);
1216                  }
1217                  if (f == 1)
1218                      ql_verify(ql, 504, 504, 1, 1);
1219                  else if (f == 2)
1220                      ql_verify(ql, 252, 504, 2, 2);
1221                  else if (f == 32)
1222                      ql_verify(ql, 16, 504, 32, 24);
1223                  quicklistRelease(ql);
1224              }
1225          }
1226          TEST(&quot;pop empty&quot;) {
1227              quicklist *ql = quicklistNew(-2, options[_i]);
1228              quicklistPop(ql, QUICKLIST_HEAD, NULL, NULL, NULL);
1229              ql_verify(ql, 0, 0, 0, 0);
1230              quicklistRelease(ql);
1231          }
1232          TEST(&quot;pop 1 string from 1&quot;) {
1233              quicklist *ql = quicklistNew(-2, options[_i]);
1234              char *populate = genstr(&quot;hello&quot;, 331);
1235              quicklistPushHead(ql, populate, 32);
1236              unsigned char *data;
1237              unsigned int sz;
1238              PORT_LONGLONG lv;
1239              ql_info(ql);
1240              quicklistPop(ql, QUICKLIST_HEAD, &amp;data, &amp;sz, &amp;lv);
1241              assert(data != NULL);
1242              assert(sz == 32);
1243              if (strcmp(populate, (char *)data))
1244                  ERR(&quot;Pop&#x27;d value (%.*s) didn&#x27;t equal original value (%s)&quot;, sz,
1245                      data, populate);
1246              zfree(data);
1247              ql_verify(ql, 0, 0, 0, 0);
1248              quicklistRelease(ql);
1249          }
1250          TEST(&quot;pop head 1 number from 1&quot;) {
1251              quicklist *ql = quicklistNew(-2, options[_i]);
1252              quicklistPushHead(ql, &quot;55513&quot;, 5);
1253              unsigned char *data;
1254              unsigned int sz;
1255              PORT_LONGLONG lv;
1256              ql_info(ql);
1257              quicklistPop(ql, QUICKLIST_HEAD, &amp;data, &amp;sz, &amp;lv);
1258              assert(data == NULL);
1259              assert(lv == 55513);
1260              ql_verify(ql, 0, 0, 0, 0);
1261              quicklistRelease(ql);
1262          }
1263          TEST(&quot;pop head 500 from 500&quot;) {
1264              quicklist *ql = quicklistNew(-2, options[_i]);
1265              for (int i = 0; i &lt; 500; i++)
1266                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1267              ql_info(ql);
1268              for (int i = 0; i &lt; 500; i++) {
1269                  unsigned char *data;
1270                  unsigned int sz;
1271                  PORT_LONGLONG lv;
1272                  int ret = quicklistPop(ql, QUICKLIST_HEAD, &amp;data, &amp;sz, &amp;lv);
1273                  assert(ret == 1);
1274                  assert(data != NULL);
1275                  assert(sz == 32);
1276                  if (strcmp(genstr(&quot;hello&quot;, 499 - i), (char *)data))
1277                      ERR(&quot;Pop&#x27;d value (%.*s) didn&#x27;t equal original value (%s)&quot;,
1278                          sz, data, genstr(&quot;hello&quot;, 499 - i));
1279                  zfree(data);
1280              }
1281              ql_verify(ql, 0, 0, 0, 0);
1282              quicklistRelease(ql);
1283          }
1284          TEST(&quot;pop head 5000 from 500&quot;) {
1285              quicklist *ql = quicklistNew(-2, options[_i]);
1286              for (int i = 0; i &lt; 500; i++)
1287                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1288              for (int i = 0; i &lt; 5000; i++) {
1289                  unsigned char *data;
1290                  unsigned int sz;
1291                  PORT_LONGLONG lv;
1292                  int ret = quicklistPop(ql, QUICKLIST_HEAD, &amp;data, &amp;sz, &amp;lv);
1293                  if (i &lt; 500) {
1294                      assert(ret == 1);
1295                      assert(data != NULL);
1296                      assert(sz == 32);
1297                      if (strcmp(genstr(&quot;hello&quot;, 499 - i), (char *)data))
1298                          ERR(&quot;Pop&#x27;d value (%.*s) didn&#x27;t equal original value &quot;
1299                              &quot;(%s)&quot;,
1300                              sz, data, genstr(&quot;hello&quot;, 499 - i));
1301                      zfree(data);
1302                  } else {
1303                      assert(ret == 0);
1304                  }
1305              }
1306              ql_verify(ql, 0, 0, 0, 0);
1307              quicklistRelease(ql);
1308          }
1309          TEST(&quot;iterate forward over 500 list&quot;) {
1310              quicklist *ql = quicklistNew(-2, options[_i]);
1311              quicklistSetFill(ql, 32);
1312              for (int i = 0; i &lt; 500; i++)
1313                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1314              quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);
1315              quicklistEntry entry;
1316              int i = 499, count = 0;
1317              while (quicklistNext(iter, &amp;entry)) {
1318                  char *h = genstr(&quot;hello&quot;, i);
1319                  if (strcmp((char *)entry.value, h))
1320                      ERR(&quot;value [%s] didn&#x27;t match [%s] at position %d&quot;,
1321                          entry.value, h, i);
1322                  i--;
1323                  count++;
1324              }
1325              if (count != 500)
1326                  ERR(&quot;Didn&#x27;t iterate over exactly 500 elements (%d)&quot;, i);
1327              ql_verify(ql, 16, 500, 20, 32);
1328              quicklistReleaseIterator(iter);
1329              quicklistRelease(ql);
1330          }
1331          TEST(&quot;iterate reverse over 500 list&quot;) {
1332              quicklist *ql = quicklistNew(-2, options[_i]);
1333              quicklistSetFill(ql, 32);
1334              for (int i = 0; i &lt; 500; i++)
1335                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1336              quicklistIter *iter = quicklistGetIterator(ql, AL_START_TAIL);
1337              quicklistEntry entry;
1338              int i = 0;
1339              while (quicklistNext(iter, &amp;entry)) {
1340                  char *h = genstr(&quot;hello&quot;, i);
1341                  if (strcmp((char *)entry.value, h))
1342                      ERR(&quot;value [%s] didn&#x27;t match [%s] at position %d&quot;,
1343                          entry.value, h, i);
1344                  i++;
1345              }
1346              if (i != 500)
1347                  ERR(&quot;Didn&#x27;t iterate over exactly 500 elements (%d)&quot;, i);
1348              ql_verify(ql, 16, 500, 20, 32);
1349              quicklistReleaseIterator(iter);
1350              quicklistRelease(ql);
1351          }
1352          TEST(&quot;insert before with 0 elements&quot;) {
1353              quicklist *ql = quicklistNew(-2, options[_i]);
1354              quicklistEntry entry;
1355              quicklistIndex(ql, 0, &amp;entry);
1356              quicklistInsertBefore(ql, &amp;entry, &quot;abc&quot;, 4);
1357              ql_verify(ql, 1, 1, 1, 1);
1358              quicklistRelease(ql);
1359          }
1360          TEST(&quot;insert after with 0 elements&quot;) {
1361              quicklist *ql = quicklistNew(-2, options[_i]);
1362              quicklistEntry entry;
1363              quicklistIndex(ql, 0, &amp;entry);
1364              quicklistInsertAfter(ql, &amp;entry, &quot;abc&quot;, 4);
1365              ql_verify(ql, 1, 1, 1, 1);
1366              quicklistRelease(ql);
1367          }
1368          TEST(&quot;insert after 1 element&quot;) {
1369              quicklist *ql = quicklistNew(-2, options[_i]);
1370              quicklistPushHead(ql, &quot;hello&quot;, 6);
1371              quicklistEntry entry;
1372              quicklistIndex(ql, 0, &amp;entry);
1373              quicklistInsertAfter(ql, &amp;entry, &quot;abc&quot;, 4);
1374              ql_verify(ql, 1, 2, 2, 2);
1375              quicklistRelease(ql);
1376          }
1377          TEST(&quot;insert before 1 element&quot;) {
1378              quicklist *ql = quicklistNew(-2, options[_i]);
1379              quicklistPushHead(ql, &quot;hello&quot;, 6);
1380              quicklistEntry entry;
1381              quicklistIndex(ql, 0, &amp;entry);
1382              quicklistInsertAfter(ql, &amp;entry, &quot;abc&quot;, 4);
1383              ql_verify(ql, 1, 2, 2, 2);
1384              quicklistRelease(ql);
1385          }
1386          for (int f = optimize_start; f &lt; 12; f++) {
1387              TEST_DESC(&quot;insert once in elements while iterating at fill %d at &quot;
1388                        &quot;compress %d\n&quot;,
1389                        f, options[_i]) {
1390                  quicklist *ql = quicklistNew(f, options[_i]);
1391                  quicklistPushTail(ql, &quot;abc&quot;, 3);
1392                  quicklistSetFill(ql, 1);
1393                  quicklistPushTail(ql, &quot;def&quot;, 3); &amp;bsol;* force to unique node */
1394                  quicklistSetFill(ql, f);
1395                  quicklistPushTail(ql, &quot;bob&quot;, 3); &amp;bsol;* force to reset for +3 */
1396                  quicklistPushTail(ql, &quot;foo&quot;, 3);
1397                  quicklistPushTail(ql, &quot;zoo&quot;, 3);
1398                  itrprintr(ql, 0);
1399                  quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);
1400                  quicklistEntry entry;
1401                  while (quicklistNext(iter, &amp;entry)) {
1402                      if (!strncmp((char *)entry.value, &quot;bob&quot;, 3)) {
1403                          quicklistInsertBefore(ql, &amp;entry, &quot;bar&quot;, 3);
1404                          break; &amp;bsol;* didn&#x27;t we fix insert-while-iterating? */
1405                      }
1406                  }
1407                  itrprintr(ql, 0);
1408                  quicklistIndex(ql, 0, &amp;entry);
1409                  if (strncmp((char *)entry.value, &quot;abc&quot;, 3))
1410                      ERR(&quot;Value 0 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1411                          entry.value);
1412                  quicklistIndex(ql, 1, &amp;entry);
1413                  if (strncmp((char *)entry.value, &quot;def&quot;, 3))
1414                      ERR(&quot;Value 1 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1415                          entry.value);
1416                  quicklistIndex(ql, 2, &amp;entry);
1417                  if (strncmp((char *)entry.value, &quot;bar&quot;, 3))
1418                      ERR(&quot;Value 2 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1419                          entry.value);
1420                  quicklistIndex(ql, 3, &amp;entry);
1421                  if (strncmp((char *)entry.value, &quot;bob&quot;, 3))
1422                      ERR(&quot;Value 3 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1423                          entry.value);
1424                  quicklistIndex(ql, 4, &amp;entry);
1425                  if (strncmp((char *)entry.value, &quot;foo&quot;, 3))
1426                      ERR(&quot;Value 4 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1427                          entry.value);
1428                  quicklistIndex(ql, 5, &amp;entry);
1429                  if (strncmp((char *)entry.value, &quot;zoo&quot;, 3))
1430                      ERR(&quot;Value 5 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1431                          entry.value);
1432                  quicklistReleaseIterator(iter);
1433                  quicklistRelease(ql);
1434              }
1435          }
1436          for (int f = optimize_start; f &lt; 1024; f++) {
1437              TEST_DESC(
1438                  &quot;insert [before] 250 new in middle of 500 elements at fill&quot;
1439                  &quot; %d at compress %d&quot;,
1440                  f, options[_i]) {
1441                  quicklist *ql = quicklistNew(f, options[_i]);
1442                  for (int i = 0; i &lt; 500; i++)
1443                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i), 32);
1444                  for (int i = 0; i &lt; 250; i++) {
1445                      quicklistEntry entry;
1446                      quicklistIndex(ql, 250, &amp;entry);
1447                      quicklistInsertBefore(ql, &amp;entry, genstr(&quot;abc&quot;, i), 32);
1448                  }
1449                  if (f == 32)
1450                      ql_verify(ql, 25, 750, 32, 20);
1451                  quicklistRelease(ql);
1452              }
1453          }
1454          for (int f = optimize_start; f &lt; 1024; f++) {
1455              TEST_DESC(&quot;insert [after] 250 new in middle of 500 elements at &quot;
1456                        &quot;fill %d at compress %d&quot;,
1457                        f, options[_i]) {
1458                  quicklist *ql = quicklistNew(f, options[_i]);
1459                  for (int i = 0; i &lt; 500; i++)
1460                      quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1461                  for (int i = 0; i &lt; 250; i++) {
1462                      quicklistEntry entry;
1463                      quicklistIndex(ql, 250, &amp;entry);
1464                      quicklistInsertAfter(ql, &amp;entry, genstr(&quot;abc&quot;, i), 32);
1465                  }
1466                  if (ql-&gt;count != 750)
1467                      ERR(&quot;List size not 750, but rather %ld&quot;, ql-&gt;count);
1468                  if (f == 32)
1469                      ql_verify(ql, 26, 750, 20, 32);
1470                  quicklistRelease(ql);
1471              }
1472          }
1473          TEST(&quot;duplicate empty list&quot;) {
1474              quicklist *ql = quicklistNew(-2, options[_i]);
1475              ql_verify(ql, 0, 0, 0, 0);
1476              quicklist *copy = quicklistDup(ql);
1477              ql_verify(copy, 0, 0, 0, 0);
1478              quicklistRelease(ql);
1479              quicklistRelease(copy);
1480          }
1481          TEST(&quot;duplicate list of 1 element&quot;) {
1482              quicklist *ql = quicklistNew(-2, options[_i]);
1483              quicklistPushHead(ql, genstr(&quot;hello&quot;, 3), 32);
1484              ql_verify(ql, 1, 1, 1, 1);
1485              quicklist *copy = quicklistDup(ql);
1486              ql_verify(copy, 1, 1, 1, 1);
1487              quicklistRelease(ql);
1488              quicklistRelease(copy);
1489          }
1490          TEST(&quot;duplicate list of 500&quot;) {
1491              quicklist *ql = quicklistNew(-2, options[_i]);
1492              quicklistSetFill(ql, 32);
1493              for (int i = 0; i &lt; 500; i++)
1494                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1495              ql_verify(ql, 16, 500, 20, 32);
1496              quicklist *copy = quicklistDup(ql);
1497              ql_verify(copy, 16, 500, 20, 32);
1498              quicklistRelease(ql);
1499              quicklistRelease(copy);
1500          }
1501          for (int f = optimize_start; f &lt; 512; f++) {
1502              TEST_DESC(&quot;index 1,200 from 500 list at fill %d at compress %d&quot;, f,
1503                        options[_i]) {
1504                  quicklist *ql = quicklistNew(f, options[_i]);
1505                  for (int i = 0; i &lt; 500; i++)
1506                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1507                  quicklistEntry entry;
1508                  quicklistIndex(ql, 1, &amp;entry);
1509                  if (!strcmp((char *)entry.value, &quot;hello2&quot;))
1510                      OK;
1511                  else
1512                      ERR(&quot;Value: %s&quot;, entry.value);
1513                  quicklistIndex(ql, 200, &amp;entry);
1514                  if (!strcmp((char *)entry.value, &quot;hello201&quot;))
1515                      OK;
1516                  else
1517                      ERR(&quot;Value: %s&quot;, entry.value);
1518                  quicklistRelease(ql);
1519              }
1520              TEST_DESC(&quot;index -1,-2 from 500 list at fill %d at compress %d&quot;, f,
1521                        options[_i]) {
1522                  quicklist *ql = quicklistNew(f, options[_i]);
1523                  for (int i = 0; i &lt; 500; i++)
1524                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1525                  quicklistEntry entry;
1526                  quicklistIndex(ql, -1, &amp;entry);
1527                  if (!strcmp((char *)entry.value, &quot;hello500&quot;))
1528                      OK;
1529                  else
1530                      ERR(&quot;Value: %s&quot;, entry.value);
1531                  quicklistIndex(ql, -2, &amp;entry);
1532                  if (!strcmp((char *)entry.value, &quot;hello499&quot;))
1533                      OK;
1534                  else
1535                      ERR(&quot;Value: %s&quot;, entry.value);
1536                  quicklistRelease(ql);
1537              }
1538              TEST_DESC(&quot;index -100 from 500 list at fill %d at compress %d&quot;, f,
1539                        options[_i]) {
1540                  quicklist *ql = quicklistNew(f, options[_i]);
1541                  for (int i = 0; i &lt; 500; i++)
1542                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1543                  quicklistEntry entry;
1544                  quicklistIndex(ql, -100, &amp;entry);
1545                  if (!strcmp((char *)entry.value, &quot;hello401&quot;))
1546                      OK;
1547                  else
1548                      ERR(&quot;Value: %s&quot;, entry.value);
1549                  quicklistRelease(ql);
1550              }
1551              TEST_DESC(&quot;index too big +1 from 50 list at fill %d at compress %d&quot;,
1552                        f, options[_i]) {
1553                  quicklist *ql = quicklistNew(f, options[_i]);
1554                  for (int i = 0; i &lt; 50; i++)
1555                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1556                  quicklistEntry entry;
1557                  if (quicklistIndex(ql, 50, &amp;entry))
1558                      ERR(&quot;Index found at 50 with 50 list: %.*s&quot;, entry.sz,
1559                          entry.value);
1560                  else
1561                      OK;
1562                  quicklistRelease(ql);
1563              }
1564          }
1565          TEST(&quot;delete range empty list&quot;) {
1566              quicklist *ql = quicklistNew(-2, options[_i]);
1567              quicklistDelRange(ql, 5, 20);
1568              ql_verify(ql, 0, 0, 0, 0);
1569              quicklistRelease(ql);
1570          }
1571          TEST(&quot;delete range of entire node in list of one node&quot;) {
1572              quicklist *ql = quicklistNew(-2, options[_i]);
1573              for (int i = 0; i &lt; 32; i++)
1574                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1575              ql_verify(ql, 1, 32, 32, 32);
1576              quicklistDelRange(ql, 0, 32);
1577              ql_verify(ql, 0, 0, 0, 0);
1578              quicklistRelease(ql);
1579          }
1580          TEST(&quot;delete range of entire node with overflow counts&quot;) {
1581              quicklist *ql = quicklistNew(-2, options[_i]);
1582              for (int i = 0; i &lt; 32; i++)
1583                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1584              ql_verify(ql, 1, 32, 32, 32);
1585              quicklistDelRange(ql, 0, 128);
1586              ql_verify(ql, 0, 0, 0, 0);
1587              quicklistRelease(ql);
1588          }
1589          TEST(&quot;delete middle 100 of 500 list&quot;) {
1590              quicklist *ql = quicklistNew(-2, options[_i]);
1591              quicklistSetFill(ql, 32);
1592              for (int i = 0; i &lt; 500; i++)
1593                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1594              ql_verify(ql, 16, 500, 32, 20);
1595              quicklistDelRange(ql, 200, 100);
1596              ql_verify(ql, 14, 400, 32, 20);
1597              quicklistRelease(ql);
1598          }
1599          TEST(&quot;delete negative 1 from 500 list&quot;) {
1600              quicklist *ql = quicklistNew(-2, options[_i]);
1601              quicklistSetFill(ql, 32);
1602              for (int i = 0; i &lt; 500; i++)
1603                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1604              ql_verify(ql, 16, 500, 32, 20);
1605              quicklistDelRange(ql, -1, 1);
1606              ql_verify(ql, 16, 499, 32, 19);
1607              quicklistRelease(ql);
1608          }
1609          TEST(&quot;delete negative 1 from 500 list with overflow counts&quot;) {
1610              quicklist *ql = quicklistNew(-2, options[_i]);
1611              quicklistSetFill(ql, 32);
1612              for (int i = 0; i &lt; 500; i++)
1613                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1614              ql_verify(ql, 16, 500, 32, 20);
1615              quicklistDelRange(ql, -1, 128);
1616              ql_verify(ql, 16, 499, 32, 19);
1617              quicklistRelease(ql);
1618          }
1619          TEST(&quot;delete negative 100 from 500 list&quot;) {
1620              quicklist *ql = quicklistNew(-2, options[_i]);
1621              quicklistSetFill(ql, 32);
1622              for (int i = 0; i &lt; 500; i++)
1623                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1624              quicklistDelRange(ql, -100, 100);
1625              ql_verify(ql, 13, 400, 32, 16);
1626              quicklistRelease(ql);
1627          }
1628          TEST(&quot;delete -10 count 5 from 50 list&quot;) {
1629              quicklist *ql = quicklistNew(-2, options[_i]);
1630              quicklistSetFill(ql, 32);
1631              for (int i = 0; i &lt; 50; i++)
1632                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1633              ql_verify(ql, 2, 50, 32, 18);
1634              quicklistDelRange(ql, -10, 5);
1635              ql_verify(ql, 2, 45, 32, 13);
1636              quicklistRelease(ql);
1637          }
1638          TEST(&quot;numbers only list read&quot;) {
1639              quicklist *ql = quicklistNew(-2, options[_i]);
1640              quicklistPushTail(ql, &quot;1111&quot;, 4);
1641              quicklistPushTail(ql, &quot;2222&quot;, 4);
1642              quicklistPushTail(ql, &quot;3333&quot;, 4);
1643              quicklistPushTail(ql, &quot;4444&quot;, 4);
1644              ql_verify(ql, 1, 4, 4, 4);
1645              quicklistEntry entry;
1646              quicklistIndex(ql, 0, &amp;entry);
1647              if (entry.longval != 1111)
1648                  ERR(&quot;Not 1111, %lld&quot;, entry.longval);
1649              quicklistIndex(ql, 1, &amp;entry);
1650              if (entry.longval != 2222)
1651                  ERR(&quot;Not 2222, %lld&quot;, entry.longval);
1652              quicklistIndex(ql, 2, &amp;entry);
1653              if (entry.longval != 3333)
1654                  ERR(&quot;Not 3333, %lld&quot;, entry.longval);
1655              quicklistIndex(ql, 3, &amp;entry);
1656              if (entry.longval != 4444)
1657                  ERR(&quot;Not 4444, %lld&quot;, entry.longval);
1658              if (quicklistIndex(ql, 4, &amp;entry))
1659                  ERR(&quot;Index past elements: %lld&quot;, entry.longval);
1660              quicklistIndex(ql, -1, &amp;entry);
1661              if (entry.longval != 4444)
1662                  ERR(&quot;Not 4444 (reverse), %lld&quot;, entry.longval);
1663              quicklistIndex(ql, -2, &amp;entry);
1664              if (entry.longval != 3333)
1665                  ERR(&quot;Not 3333 (reverse), %lld&quot;, entry.longval);
1666              quicklistIndex(ql, -3, &amp;entry);
1667              if (entry.longval != 2222)
1668                  ERR(&quot;Not 2222 (reverse), %lld&quot;, entry.longval);
1669              quicklistIndex(ql, -4, &amp;entry);
1670              if (entry.longval != 1111)
1671                  ERR(&quot;Not 1111 (reverse), %lld&quot;, entry.longval);
1672              if (quicklistIndex(ql, -5, &amp;entry))
1673                  ERR(&quot;Index past elements (reverse), %lld&quot;, entry.longval);
1674              quicklistRelease(ql);
1675          }
1676          TEST(&quot;numbers larger list read&quot;) {
1677              quicklist *ql = quicklistNew(-2, options[_i]);
1678              quicklistSetFill(ql, 32);
1679              char num[32];
1680              PORT_LONGLONG nums[5000];
1681              for (int i = 0; i &lt; 5000; i++) {
1682                  nums[i] = -5157318210846258176 + i;
1683                  int sz = ll2string(num, sizeof(num), nums[i]);
1684                  quicklistPushTail(ql, num, sz);
1685              }
1686              quicklistPushTail(ql, &quot;xxxxxxxxxxxxxxxxxxxx&quot;, 20);
1687              quicklistEntry entry;
1688              for (int i = 0; i &lt; 5000; i++) {
1689                  quicklistIndex(ql, i, &amp;entry);
1690                  if (entry.longval != nums[i])
1691                      ERR(&quot;[%d] Not longval %lld but rather %lld&quot;, i, nums[i],
1692                          entry.longval);
1693                  entry.longval = 0xdeadbeef;
1694              }
1695              quicklistIndex(ql, 5000, &amp;entry);
1696              if (strncmp((char *)entry.value, &quot;xxxxxxxxxxxxxxxxxxxx&quot;, 20))
1697                  ERR(&quot;String val not match: %s&quot;, entry.value);
1698              ql_verify(ql, 157, 5001, 32, 9);
1699              quicklistRelease(ql);
1700          }
1701          TEST(&quot;numbers larger list read B&quot;) {
1702              quicklist *ql = quicklistNew(-2, options[_i]);
1703              quicklistPushTail(ql, &quot;99&quot;, 2);
1704              quicklistPushTail(ql, &quot;98&quot;, 2);
1705              quicklistPushTail(ql, &quot;xxxxxxxxxxxxxxxxxxxx&quot;, 20);
1706              quicklistPushTail(ql, &quot;96&quot;, 2);
1707              quicklistPushTail(ql, &quot;95&quot;, 2);
1708              quicklistReplaceAtIndex(ql, 1, &quot;foo&quot;, 3);
1709              quicklistReplaceAtIndex(ql, -1, &quot;bar&quot;, 3);
1710              quicklistRelease(ql);
1711              OK;
1712          }
1713          for (int f = optimize_start; f &lt; 16; f++) {
1714              TEST_DESC(&quot;lrem test at fill %d at compress %d&quot;, f, options[_i]) {
1715                  quicklist *ql = quicklistNew(f, options[_i]);
1716                  char *words[] = {&quot;abc&quot;, &quot;foo&quot;, &quot;bar&quot;,  &quot;foobar&quot;, &quot;foobared&quot;,
1717                                   &quot;zap&quot;, &quot;bar&quot;, &quot;test&quot;, &quot;foo&quot;};
1718                  char *result[] = {&quot;abc&quot;, &quot;foo&quot;,  &quot;foobar&quot;, &quot;foobared&quot;,
1719                                    &quot;zap&quot;, &quot;test&quot;, &quot;foo&quot;};
1720                  char *resultB[] = {&quot;abc&quot;,      &quot;foo&quot;, &quot;foobar&quot;,
1721                                     &quot;foobared&quot;, &quot;zap&quot;, &quot;test&quot;};
1722                  for (int i = 0; i &lt; 9; i++)
1723                      quicklistPushTail(ql, words[i], strlen(words[i]));
1724                  quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);
1725                  quicklistEntry entry;
1726                  int i = 0;
1727                  while (quicklistNext(iter, &amp;entry)) {
1728                      if (quicklistCompare(entry.zi, (unsigned char *)&quot;bar&quot;, 3)) {
1729                          quicklistDelEntry(iter, &amp;entry);
1730                      }
1731                      i++;
1732                  }
1733                  quicklistReleaseIterator(iter);
1734                  iter = quicklistGetIterator(ql, AL_START_HEAD);
1735                  i = 0;
1736                  int ok = 1;
1737                  while (quicklistNext(iter, &amp;entry)) {
1738                      if (strncmp((char *)entry.value, result[i], entry.sz)) {
1739                          ERR(&quot;No match at position %d, got %.*s instead of %s&quot;,
1740                              i, entry.sz, entry.value, result[i]);
1741                          ok = 0;
1742                      }
1743                      i++;
1744                  }
1745                  quicklistReleaseIterator(iter);
1746                  quicklistPushTail(ql, &quot;foo&quot;, 3);
1747                  iter = quicklistGetIterator(ql, AL_START_TAIL);
1748                  i = 0;
1749                  int del = 2;
1750                  while (quicklistNext(iter, &amp;entry)) {
1751                      if (quicklistCompare(entry.zi, (unsigned char *)&quot;foo&quot;, 3)) {
1752                          quicklistDelEntry(iter, &amp;entry);
1753                          del--;
1754                      }
1755                      if (!del)
1756                          break;
1757                      i++;
1758                  }
1759                  quicklistReleaseIterator(iter);
1760                  iter = quicklistGetIterator(ql, AL_START_TAIL);
1761                  i = 0;
1762                  size_t resB = sizeof(resultB) / sizeof(*resultB);
1763                  while (quicklistNext(iter, &amp;entry)) {
1764                      if (strncmp((char *)entry.value, resultB[resB - 1 - i],
1765                                  entry.sz)) {
1766                          ERR(&quot;No match at position %d, got %.*s instead of %s&quot;,
1767                              i, entry.sz, entry.value, resultB[resB - 1 - i]);
1768                          ok = 0;
1769                      }
1770                      i++;
1771                  }
1772                  quicklistReleaseIterator(iter);
1773                  if (ok)
1774                      OK;
1775                  quicklistRelease(ql);
1776              }
1777          }
1778          for (int f = optimize_start; f &lt; 16; f++) {
1779              TEST_DESC(&quot;iterate reverse + delete at fill %d at compress %d&quot;, f,
1780                        options[_i]) {
1781                  quicklist *ql = quicklistNew(f, options[_i]);
1782                  quicklistPushTail(ql, &quot;abc&quot;, 3);
1783                  quicklistPushTail(ql, &quot;def&quot;, 3);
1784                  quicklistPushTail(ql, &quot;hij&quot;, 3);
1785                  quicklistPushTail(ql, &quot;jkl&quot;, 3);
1786                  quicklistPushTail(ql, &quot;oop&quot;, 3);
1787                  quicklistEntry entry;
1788                  quicklistIter *iter = quicklistGetIterator(ql, AL_START_TAIL);
1789                  int i = 0;
1790                  while (quicklistNext(iter, &amp;entry)) {
1791                      if (quicklistCompare(entry.zi, (unsigned char *)&quot;hij&quot;, 3)) {
1792                          quicklistDelEntry(iter, &amp;entry);
1793                      }
1794                      i++;
1795                  }
1796                  quicklistReleaseIterator(iter);
1797                  if (i != 5)
1798                      ERR(&quot;Didn&#x27;t iterate 5 times, iterated %d times.&quot;, i);
1799                  iter = quicklistGetIterator(ql, AL_START_HEAD);
1800                  i = 0;
1801                  char *vals[] = {&quot;abc&quot;, &quot;def&quot;, &quot;jkl&quot;, &quot;oop&quot;};
1802                  while (quicklistNext(iter, &amp;entry)) {
1803                      if (!quicklistCompare(entry.zi, (unsigned char *)vals[i],
1804                                            3)) {
1805                          ERR(&quot;Value at %d didn&#x27;t match %s\n&quot;, i, vals[i]);
1806                      }
1807                      i++;
1808                  }
1809                  quicklistReleaseIterator(iter);
1810                  quicklistRelease(ql);
1811              }
1812          }
1813          for (int f = optimize_start; f &lt; 800; f++) {
1814              TEST_DESC(&quot;iterator at index test at fill %d at compress %d&quot;, f,
1815                        options[_i]) {
1816                  quicklist *ql = quicklistNew(f, options[_i]);
1817                  char num[32];
1818                  PORT_LONGLONG nums[5000];
1819                  for (int i = 0; i &lt; 760; i++) {
1820                      nums[i] = -5157318210846258176 + i;
1821                      int sz = ll2string(num, sizeof(num), nums[i]);
1822                      quicklistPushTail(ql, num, sz);
1823                  }
1824                  quicklistEntry entry;
1825                  quicklistIter *iter =
1826                      quicklistGetIteratorAtIdx(ql, AL_START_HEAD, 437);
1827                  int i = 437;
1828                  while (quicklistNext(iter, &amp;entry)) {
1829                      if (entry.longval != nums[i])
1830                          ERR(&quot;Expected %lld, but got %lld&quot;, entry.longval,
1831                              nums[i]);
1832                      i++;
1833                  }
1834                  quicklistReleaseIterator(iter);
1835                  quicklistRelease(ql);
1836              }
1837          }
1838          for (int f = optimize_start; f &lt; 40; f++) {
1839              TEST_DESC(&quot;ltrim test A at fill %d at compress %d&quot;, f,
1840                        options[_i]) {
1841                  quicklist *ql = quicklistNew(f, options[_i]);
1842                  char num[32];
1843                  PORT_LONGLONG nums[5000];
1844                  for (int i = 0; i &lt; 32; i++) {
1845                      nums[i] = -5157318210846258176 + i;
1846                      int sz = ll2string(num, sizeof(num), nums[i]);
1847                      quicklistPushTail(ql, num, sz);
1848                  }
1849                  if (f == 32)
1850                      ql_verify(ql, 1, 32, 32, 32);
1851                  quicklistDelRange(ql, 0, 25);
1852                  quicklistDelRange(ql, 0, 0);
1853                  quicklistEntry entry;
1854                  for (int i = 0; i &lt; 7; i++) {
1855                      quicklistIndex(ql, i, &amp;entry);
1856                      if (entry.longval != nums[25 + i])
1857                          ERR(&quot;Deleted invalid range!  Expected %lld but got &quot;
1858                              &quot;%lld&quot;,
1859                              entry.longval, nums[25 + i]);
1860                  }
1861                  if (f == 32)
1862                      ql_verify(ql, 1, 7, 7, 7);
1863                  quicklistRelease(ql);
1864              }
1865          }
1866          for (int f = optimize_start; f &lt; 40; f++) {
1867              TEST_DESC(&quot;ltrim test B at fill %d at compress %d&quot;, f,
1868                        options[_i]) {
1869                  quicklist *ql = quicklistNew(f, QUICKLIST_NOCOMPRESS);
1870                  char num[32];
1871                  PORT_LONGLONG nums[5000];
1872                  for (int i = 0; i &lt; 33; i++) {
1873                      nums[i] = i;
1874                      int sz = ll2string(num, sizeof(num), nums[i]);
1875                      quicklistPushTail(ql, num, sz);
1876                  }
1877                  if (f == 32)
1878                      ql_verify(ql, 2, 33, 32, 1);
1879                  quicklistDelRange(ql, 0, 5);
1880                  quicklistDelRange(ql, -16, 16);
1881                  if (f == 32)
1882                      ql_verify(ql, 1, 12, 12, 12);
1883                  quicklistEntry entry;
1884                  quicklistIndex(ql, 0, &amp;entry);
1885                  if (entry.longval != 5)
1886                      ERR(&quot;A: longval not 5, but %lld&quot;, entry.longval);
1887                  else
1888                      OK;
1889                  quicklistIndex(ql, -1, &amp;entry);
1890                  if (entry.longval != 16)
1891                      ERR(&quot;B! got instead: %lld&quot;, entry.longval);
1892                  else
1893                      OK;
1894                  quicklistPushTail(ql, &quot;bobobob&quot;, 7);
1895                  quicklistIndex(ql, -1, &amp;entry);
1896                  if (strncmp((char *)entry.value, &quot;bobobob&quot;, 7))
1897                      ERR(&quot;Tail doesn&#x27;t match bobobob, it&#x27;s %.*s instead&quot;,
1898                          entry.sz, entry.value);
1899                  for (int i = 0; i &lt; 12; i++) {
1900                      quicklistIndex(ql, i, &amp;entry);
1901                      if (entry.longval != nums[5 + i])
1902                          ERR(&quot;Deleted invalid range!  Expected %lld but got &quot;
1903                              &quot;%lld&quot;,
1904                              entry.longval, nums[5 + i]);
1905                  }
1906                  quicklistRelease(ql);
1907              }
1908          }
1909          for (int f = optimize_start; f &lt; 40; f++) {
1910              TEST_DESC(&quot;ltrim test C at fill %d at compress %d&quot;, f,
1911                        options[_i]) {
1912                  quicklist *ql = quicklistNew(f, options[_i]);
1913                  char num[32];
1914                  PORT_LONGLONG nums[5000];
1915                  for (int i = 0; i &lt; 33; i++) {
1916                      nums[i] = -5157318210846258176 + i;
1917                      int sz = ll2string(num, sizeof(num), nums[i]);
1918                      quicklistPushTail(ql, num, sz);
1919                  }
1920                  if (f == 32)
1921                      ql_verify(ql, 2, 33, 32, 1);
1922                  quicklistDelRange(ql, 0, 3);
1923                  quicklistDelRange(ql, -29,
1924                                    4000); &amp;bsol;* make sure not loop forever */
1925                  if (f == 32)
1926                      ql_verify(ql, 1, 1, 1, 1);
1927                  quicklistEntry entry;
1928                  quicklistIndex(ql, 0, &amp;entry);
1929                  if (entry.longval != -5157318210846258173)
1930                      ERROR;
1931                  else
1932                      OK;
1933                  quicklistRelease(ql);
1934              }
1935          }
1936          for (int f = optimize_start; f &lt; 40; f++) {
1937              TEST_DESC(&quot;ltrim test D at fill %d at compress %d&quot;, f,
1938                        options[_i]) {
1939                  quicklist *ql = quicklistNew(f, options[_i]);
1940                  char num[32];
1941                  PORT_LONGLONG nums[5000];
1942                  for (int i = 0; i &lt; 33; i++) {
1943                      nums[i] = -5157318210846258176 + i;
1944                      int sz = ll2string(num, sizeof(num), nums[i]);
1945                      quicklistPushTail(ql, num, sz);
1946                  }
1947                  if (f == 32)
1948                      ql_verify(ql, 2, 33, 32, 1);
1949                  quicklistDelRange(ql, -12, 3);
1950                  if (ql-&gt;count != 30)
1951                      ERR(&quot;Didn&#x27;t delete exactly three elements!  Count is: %lu&quot;,
1952                          ql-&gt;count);
1953                  quicklistRelease(ql);
1954              }
1955          }
1956          for (int f = optimize_start; f &lt; 72; f++) {
1957              TEST_DESC(&quot;create quicklist from ziplist at fill %d at compress %d&quot;,
1958                        f, options[_i]) {
1959                  unsigned char *zl = ziplistNew();
1960                  PORT_LONGLONG nums[64];
1961                  char num[64];
1962                  for (int i = 0; i &lt; 33; i++) {
1963                      nums[i] = -5157318210846258176 + i;
1964                      int sz = ll2string(num, sizeof(num), nums[i]);
1965                      zl =
1966                          ziplistPush(zl, (unsigned char *)num, sz, ZIPLIST_TAIL);
1967                  }
1968                  for (int i = 0; i &lt; 33; i++) {
1969                      zl = ziplistPush(zl, (unsigned char *)genstr(&quot;hello&quot;, i),
1970                                       32, ZIPLIST_TAIL);
1971                  }
1972                  quicklist *ql = quicklistCreateFromZiplist(f, options[_i], zl);
1973                  if (f == 1)
1974                      ql_verify(ql, 66, 66, 1, 1);
1975                  else if (f == 32)
1976                      ql_verify(ql, 3, 66, 32, 2);
1977                  else if (f == 66)
1978                      ql_verify(ql, 1, 66, 66, 66);
1979                  quicklistRelease(ql);
1980              }
1981          }
1982          PORT_LONGLONG stop = mstime();
1983          runtime[_i] = stop - start;
1984      }
1985      int list_sizes[] = {250, 251, 500, 999, 1000};
1986      PORT_LONGLONG start = mstime();
1987      for (int list = 0; list &lt; (int)(sizeof(list_sizes) / sizeof(*list_sizes));
1988           list++) {
1989          for (int f = optimize_start; f &lt; 128; f++) {
1990              for (int depth = 1; depth &lt; 40; depth++) {
1991                  TEST_DESC(&quot;verify specific compression of interior nodes with &quot;
1992                            &quot;%d list &quot;
1993                            &quot;at fill %d at compress %d&quot;,
1994                            list_sizes[list], f, depth) {
1995                      quicklist *ql = quicklistNew(f, depth);
1996                      for (int i = 0; i &lt; list_sizes[list]; i++) {
1997                          quicklistPushTail(ql, genstr(&quot;hello TAIL&quot;, i + 1), 64);
1998                          quicklistPushHead(ql, genstr(&quot;hello HEAD&quot;, i + 1), 64);
1999                      }
2000                      quicklistNode *node = ql-&gt;head;
2001                      unsigned int low_raw = ql-&gt;compress;
2002                      unsigned int high_raw = ql-&gt;len - ql-&gt;compress;
2003                      for (unsigned int at = 0; at &lt; ql-&gt;len;
2004                           at++, node = node-&gt;next) {
2005                          if (at &lt; low_raw || at &gt;= high_raw) {
2006                              if (node-&gt;encoding != QUICKLIST_NODE_ENCODING_RAW) {
2007                                  ERR(&quot;Incorrect compression: node %d is &quot;
2008                                      &quot;compressed at depth %d ((%u, %u); total &quot;
2009                                      &quot;nodes: %u; size: %u)&quot;,
2010                                      at, depth, low_raw, high_raw, ql-&gt;len,
2011                                      node-&gt;sz);
2012                              }
2013                          } else {
2014                              if (node-&gt;encoding != QUICKLIST_NODE_ENCODING_LZF) {
2015                                  ERR(&quot;Incorrect non-compression: node %d is NOT &quot;
2016                                      &quot;compressed at depth %d ((%u, %u); total &quot;
2017                                      &quot;nodes: %u; size: %u; attempted: %d)&quot;,
2018                                      at, depth, low_raw, high_raw, ql-&gt;len,
2019                                      node-&gt;sz, node-&gt;attempted_compress);
2020                              }
2021                          }
2022                      }
2023                      quicklistRelease(ql);
2024                  }
2025              }
2026          }
2027      }
2028      PORT_LONGLONG stop = mstime();
2029      printf(&quot;\n&quot;);
2030      for (size_t i = 0; i &lt; option_count; i++)
2031          printf(&quot;Test Loop %02d: %0.2f seconds.\n&quot;, options[i],
2032                 (float)runtime[i] / 1000);
2033      printf(&quot;Compressions: %0.2f seconds.\n&quot;, (float)(stop - start) / 1000);
2034      printf(&quot;\n&quot;);
2035      if (!err)
2036          printf(&quot;ALL TESTS PASSED!\n&quot;);
2037      else
2038          ERR(&quot;Sorry, not all tests passed!  In fact, %d tests failed.&quot;, err);
2039      return err;
2040  }
2041  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-quicklist.c</h3>
            <pre><code>1  #include &lt;string.h&gt; &amp;bsol;* for memcpy */
2  #include &quot;quicklist.h&quot;
3  #include &quot;zmalloc.h&quot;
4  #include &quot;ziplist.h&quot;
5  #include &quot;util.h&quot; &amp;bsol;* for ll2string */
6  #include &quot;lzf.h&quot;
7  #if defined(REDIS_TEST) || defined(REDIS_TEST_VERBOSE)
8  #include &lt;stdio.h&gt; &amp;bsol;* for printf (debug printing), snprintf (genstr) */
9  #endif
10  #ifndef REDIS_STATIC
11  #define REDIS_STATIC static
12  #endif
13  static const size_t optimization_level[] = {4096, 8192, 16384, 32768, 65536};
14  #define SIZE_SAFETY_LIMIT 8192
15  #define MIN_COMPRESS_BYTES 48
16  #define MIN_COMPRESS_IMPROVE 8
17  #ifndef REDIS_TEST_VERBOSE
18  #define D(...)
19  #else
20  #define D(...)                                                                 \
21      do {                                                                       \
22          printf(&quot;%s:%s:%d:\t&quot;, __FILE__, __FUNCTION__, __LINE__);               \
23          printf(__VA_ARGS__);                                                   \
24          printf(&quot;\n&quot;);                                                          \
25      } while (0);
26  #endif
27  #define initEntry(e)                                                           \
28      do {                                                                       \
29          (e)-&gt;zi = (e)-&gt;value = NULL;                                           \
30          (e)-&gt;longval = -123456789;                                             \
31          (e)-&gt;quicklist = NULL;                                                 \
32          (e)-&gt;node = NULL;                                                      \
33          (e)-&gt;offset = 123456789;                                               \
34          (e)-&gt;sz = 0;                                                           \
35      } while (0)
36  #if __GNUC__ &gt;= 3
37  #define likely(x) __builtin_expect(!!(x), 1)
38  #define unlikely(x) __builtin_expect(!!(x), 0)
39  #else
40  #define likely(x) (x)
41  #define unlikely(x) (x)
42  #endif
43  quicklist *quicklistCreate(void) {
44      struct quicklist *quicklist;
45      quicklist = zmalloc(sizeof(*quicklist));
46      quicklist-&gt;head = quicklist-&gt;tail = NULL;
47      quicklist-&gt;len = 0;
48      quicklist-&gt;count = 0;
49      quicklist-&gt;compress = 0;
50      quicklist-&gt;fill = -2;
51      return quicklist;
52  }
53  #define COMPRESS_MAX (1 &lt;&lt; 16)
54  void quicklistSetCompressDepth(quicklist *quicklist, int compress) {
55      if (compress &gt; COMPRESS_MAX) {
56          compress = COMPRESS_MAX;
57      } else if (compress &lt; 0) {
58          compress = 0;
59      }
60      quicklist-&gt;compress = compress;
61  }
62  #define FILL_MAX (1 &lt;&lt; 15)
63  void quicklistSetFill(quicklist *quicklist, int fill) {
64      if (fill &gt; FILL_MAX) {
65          fill = FILL_MAX;
66      } else if (fill &lt; -5) {
67          fill = -5;
68      }
69      quicklist-&gt;fill = fill;
70  }
71  void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {
72      quicklistSetFill(quicklist, fill);
73      quicklistSetCompressDepth(quicklist, depth);
74  }
75  quicklist *quicklistNew(int fill, int compress) {
76      quicklist *quicklist = quicklistCreate();
77      quicklistSetOptions(quicklist, fill, compress);
78      return quicklist;
79  }
80  REDIS_STATIC quicklistNode *quicklistCreateNode(void) {
81      quicklistNode *node;
82      node = zmalloc(sizeof(*node));
83      node-&gt;zl = NULL;
84      node-&gt;count = 0;
85      node-&gt;sz = 0;
86      node-&gt;next = node-&gt;prev = NULL;
87      node-&gt;encoding = QUICKLIST_NODE_ENCODING_RAW;
88      node-&gt;container = QUICKLIST_NODE_CONTAINER_ZIPLIST;
89      node-&gt;recompress = 0;
90      return node;
91  }
92  PORT_ULONG quicklistCount(const quicklist *ql) { return (PORT_ULONG)(ql-&gt;count); } WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
93  void quicklistRelease(quicklist *quicklist) {
94      PORT_ULONG len;
95      quicklistNode *current, *next;
96      current = quicklist-&gt;head;
97      len = quicklist-&gt;len;
98      while (len--) {
99          next = current-&gt;next;
100          zfree(current-&gt;zl);
101          quicklist-&gt;count -= current-&gt;count;
102          zfree(current);
103          quicklist-&gt;len--;
104          current = next;
105      }
106      zfree(quicklist);
107  }
108  REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
109  #ifdef REDIS_TEST
110      node-&gt;attempted_compress = 1;
111  #endif
112      if (node-&gt;sz &lt; MIN_COMPRESS_BYTES)
113          return 0;
114      quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node-&gt;sz);
115      if (((lzf-&gt;sz = lzf_compress(node-&gt;zl, node-&gt;sz, lzf-&gt;compressed,
116                                   node-&gt;sz)) == 0) ||
117          lzf-&gt;sz + MIN_COMPRESS_IMPROVE &gt;= node-&gt;sz) {
118          zfree(lzf);
119          return 0;
120      }
121      lzf = zrealloc(lzf, sizeof(*lzf) + lzf-&gt;sz);
122      zfree(node-&gt;zl);
123      node-&gt;zl = (unsigned char *)lzf;
124      node-&gt;encoding = QUICKLIST_NODE_ENCODING_LZF;
125      node-&gt;recompress = 0;
126      return 1;
127  }
128  #define quicklistCompressNode(_node)                                           \
129      do {                                                                       \
130          if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_RAW) {     \
131              __quicklistCompressNode((_node));                                  \
132          }                                                                      \
133      } while (0)
134  REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
135  #ifdef REDIS_TEST
136      node-&gt;attempted_compress = 0;
137  #endif
138      void *decompressed = zmalloc(node-&gt;sz);
139      quicklistLZF *lzf = (quicklistLZF *)node-&gt;zl;
140      if (lzf_decompress(lzf-&gt;compressed, lzf-&gt;sz, decompressed, node-&gt;sz) == 0) {
141          zfree(decompressed);
142          return 0;
143      }
144      zfree(lzf);
145      node-&gt;zl = decompressed;
146      node-&gt;encoding = QUICKLIST_NODE_ENCODING_RAW;
147      return 1;
148  }
149  #define quicklistDecompressNode(_node)                                         \
150      do {                                                                       \
151          if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) {     \
152              __quicklistDecompressNode((_node));                                \
153          }                                                                      \
154      } while (0)
155  #define quicklistDecompressNodeForUse(_node)                                   \
156      do {                                                                       \
157          if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) {     \
158              __quicklistDecompressNode((_node));                                \
159              (_node)-&gt;recompress = 1;                                           \
160          }                                                                      \
161      } while (0)
162  size_t quicklistGetLzf(const quicklistNode *node, void **data) {
163      quicklistLZF *lzf = (quicklistLZF *)node-&gt;zl;
164      *data = lzf-&gt;compressed;
165      return lzf-&gt;sz;
166  }
167  #define quicklistAllowsCompression(_ql) ((_ql)-&gt;compress != 0)
168  REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,
169                                        quicklistNode *node) {
170      if (!quicklistAllowsCompression(quicklist) ||
171          quicklist-&gt;len &lt; (unsigned int)(quicklist-&gt;compress * 2))
172          return;
173  #if 0
174      if (quicklist-&gt;compress == 1) {
175          quicklistNode *h = quicklist-&gt;head, *t = quicklist-&gt;tail;
176          quicklistDecompressNode(h);
177          quicklistDecompressNode(t);
178          if (h != node &amp;&amp; t != node)
179              quicklistCompressNode(node);
180          return;
181      } else if (quicklist-&gt;compress == 2) {
182          quicklistNode *h = quicklist-&gt;head, *hn = h-&gt;next, *hnn = hn-&gt;next;
183          quicklistNode *t = quicklist-&gt;tail, *tp = t-&gt;prev, *tpp = tp-&gt;prev;
184          quicklistDecompressNode(h);
185          quicklistDecompressNode(hn);
186          quicklistDecompressNode(t);
187          quicklistDecompressNode(tp);
188          if (h != node &amp;&amp; hn != node &amp;&amp; t != node &amp;&amp; tp != node) {
189              quicklistCompressNode(node);
190          }
191          if (hnn != t) {
192              quicklistCompressNode(hnn);
193          }
194          if (tpp != h) {
195              quicklistCompressNode(tpp);
196          }
197          return;
198      }
199  #endif
200      quicklistNode *forward = quicklist-&gt;head;
201      quicklistNode *reverse = quicklist-&gt;tail;
202      int depth = 0;
203      int in_depth = 0;
204      while (depth++ &lt; quicklist-&gt;compress) {
205          quicklistDecompressNode(forward);
206          quicklistDecompressNode(reverse);
207          if (forward == node || reverse == node)
208              in_depth = 1;
209          if (forward == reverse)
210              return;
211          forward = forward-&gt;next;
212          reverse = reverse-&gt;prev;
213      }
214      if (!in_depth)
215          quicklistCompressNode(node);
216      if (depth &gt; 2) {
217          quicklistCompressNode(forward);
218          quicklistCompressNode(reverse);
219      }
220  }
221  #define quicklistCompress(_ql, _node)                                          \
222      do {                                                                       \
223          if ((_node)-&gt;recompress)                                               \
224              quicklistCompressNode((_node));                                    \
225          else                                                                   \
226              __quicklistCompress((_ql), (_node));                               \
227      } while (0)
228  #define quicklistRecompressOnly(_ql, _node)                                    \
229      do {                                                                       \
230          if ((_node)-&gt;recompress)                                               \
231              quicklistCompressNode((_node));                                    \
232      } while (0)
233  REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
234                                          quicklistNode *old_node,
235                                          quicklistNode *new_node, int after) {
236      if (after) {
237          new_node-&gt;prev = old_node;
238          if (old_node) {
239              new_node-&gt;next = old_node-&gt;next;
240              if (old_node-&gt;next)
241                  old_node-&gt;next-&gt;prev = new_node;
242              old_node-&gt;next = new_node;
243          }
244          if (quicklist-&gt;tail == old_node)
245              quicklist-&gt;tail = new_node;
246      } else {
247          new_node-&gt;next = old_node;
248          if (old_node) {
249              new_node-&gt;prev = old_node-&gt;prev;
250              if (old_node-&gt;prev)
251                  old_node-&gt;prev-&gt;next = new_node;
252              old_node-&gt;prev = new_node;
253          }
254          if (quicklist-&gt;head == old_node)
255              quicklist-&gt;head = new_node;
256      }
257      if (quicklist-&gt;len == 0) {
258          quicklist-&gt;head = quicklist-&gt;tail = new_node;
259      }
260      if (old_node)
261          quicklistCompress(quicklist, old_node);
262      quicklist-&gt;len++;
263  }
264  REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
265                                               quicklistNode *old_node,
266                                               quicklistNode *new_node) {
267      __quicklistInsertNode(quicklist, old_node, new_node, 0);
268  }
269  REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
270                                              quicklistNode *old_node,
271                                              quicklistNode *new_node) {
272      __quicklistInsertNode(quicklist, old_node, new_node, 1);
273  }
274  REDIS_STATIC int
275  _quicklistNodeSizeMeetsOptimizationRequirement(const size_t sz,
276                                                 const int fill) {
277      if (fill &gt;= 0)
278          return 0;
279      size_t offset = (-fill) - 1;
280      if (offset &lt; (sizeof(optimization_level) / sizeof(*optimization_level))) {
281          if (sz &lt;= optimization_level[offset]) {
282              return 1;
283          } else {
284              return 0;
285          }
286      } else {
287          return 0;
288      }
289  }
290  #define sizeMeetsSafetyLimit(sz) ((sz) &lt;= SIZE_SAFETY_LIMIT)
291  REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,
292                                             const int fill, const size_t sz) {
293      if (unlikely(!node))
294          return 0;
295      int ziplist_overhead;
296      if (sz &lt; 254)
297          ziplist_overhead = 1;
298      else
299          ziplist_overhead = 5;
300      if (sz &lt; 64)
301          ziplist_overhead += 1;
302      else if (likely(sz &lt; 16384))
303          ziplist_overhead += 2;
304      else
305          ziplist_overhead += 5;
306      unsigned int new_sz = (unsigned int)(node-&gt;sz + sz + ziplist_overhead);     WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
307      if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))
308          return 1;
309      else if (!sizeMeetsSafetyLimit(new_sz))
310          return 0;
311      else if ((int)node-&gt;count &lt; fill)
312          return 1;
313      else
314          return 0;
315  }
316  REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,
317                                            const quicklistNode *b,
318                                            const int fill) {
319      if (!a || !b)
320          return 0;
321      unsigned int merge_sz = a-&gt;sz + b-&gt;sz - 11;
322      if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz, fill)))
323          return 1;
324      else if (!sizeMeetsSafetyLimit(merge_sz))
325          return 0;
326      else if ((int)(a-&gt;count + b-&gt;count) &lt;= fill)
327          return 1;
328      else
329          return 0;
330  }
331  #define quicklistNodeUpdateSz(node)                                            \
332      do {                                                                       \
333          (node)-&gt;sz = ziplistBlobLen((node)-&gt;zl);                               \
334      } while (0)
335  int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
336      quicklistNode *orig_head = quicklist-&gt;head;
337      if (likely(
338              _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) {
339          quicklist-&gt;head-&gt;zl =
340              ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);
341          quicklistNodeUpdateSz(quicklist-&gt;head);
342      } else {
343          quicklistNode *node = quicklistCreateNode();
344          node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
345          quicklistNodeUpdateSz(node);
346          _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);
347      }
348      quicklist-&gt;count++;
349      quicklist-&gt;head-&gt;count++;
350      return (orig_head != quicklist-&gt;head);
351  }
352  int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
353      quicklistNode *orig_tail = quicklist-&gt;tail;
354      if (likely(
<span onclick='openModal()' class='match'>355              _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) {
356          quicklist-&gt;tail-&gt;zl =
357              ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);
358          quicklistNodeUpdateSz(quicklist-&gt;tail);
359      } else {
360          quicklistNode *node = quicklistCreateNode();
361          node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);
362          quicklistNodeUpdateSz(node);
363          _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);
364      }
365      quicklist-&gt;count++;
366      quicklist-&gt;tail-&gt;count++;
367      return (orig_tail != quicklist-&gt;tail);
368  }
369  void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {
</span>370      quicklistNode *node = quicklistCreateNode();
371      node-&gt;zl = zl;
372      node-&gt;count = ziplistLen(node-&gt;zl);
373      node-&gt;sz = ziplistBlobLen(zl);
374      _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);
375      quicklist-&gt;count += node-&gt;count;
376  }
377  quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,
378                                              unsigned char *zl) {
379      unsigned char *value;
380      unsigned int sz;
381      PORT_LONGLONG longval;
382      char longstr[32] = {0};
383      unsigned char *p = ziplistIndex(zl, 0);
384      while (ziplistGet(p, &amp;value, &amp;sz, &amp;longval)) {
385          if (!value) {
386              sz = ll2string(longstr, sizeof(longstr), longval);
387              value = (unsigned char *)longstr;
388          }
389          quicklistPushTail(quicklist, value, sz);
390          p = ziplistNext(zl, p);
391      }
392      zfree(zl);
393      return quicklist;
394  }
395  quicklist *quicklistCreateFromZiplist(int fill, int compress,
396                                        unsigned char *zl) {
397      return quicklistAppendValuesFromZiplist(quicklistNew(fill, compress), zl);
398  }
399  #define quicklistDeleteIfEmpty(ql, n)                                          \
400      do {                                                                       \
401          if ((n)-&gt;count == 0) {                                                 \
402              __quicklistDelNode((ql), (n));                                     \
403              (n) = NULL;                                                        \
404          }                                                                      \
405      } while (0)
406  REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,
407                                       quicklistNode *node) {
408      if (node-&gt;next)
409          node-&gt;next-&gt;prev = node-&gt;prev;
410      if (node-&gt;prev)
411          node-&gt;prev-&gt;next = node-&gt;next;
412      if (node == quicklist-&gt;tail) {
413          quicklist-&gt;tail = node-&gt;prev;
414      }
415      if (node == quicklist-&gt;head) {
416          quicklist-&gt;head = node-&gt;next;
417      }
418      __quicklistCompress(quicklist, NULL);
419      quicklist-&gt;count -= node-&gt;count;
420      zfree(node-&gt;zl);
421      zfree(node);
422      quicklist-&gt;len--;
423  }
424  REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
425                                     unsigned char **p) {
426      int gone = 0;
427      node-&gt;zl = ziplistDelete(node-&gt;zl, p);
428      node-&gt;count--;
429      if (node-&gt;count == 0) {
430          gone = 1;
431          __quicklistDelNode(quicklist, node);
432      } else {
433          quicklistNodeUpdateSz(node);
434      }
435      quicklist-&gt;count--;
436      return gone ? 1 : 0;
437  }
438  void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
439      quicklistNode *prev = entry-&gt;node-&gt;prev;
440      quicklistNode *next = entry-&gt;node-&gt;next;
441      int deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,
442                                           entry-&gt;node, &amp;entry-&gt;zi);
443      iter-&gt;zi = NULL;
444      if (deleted_node) {
445          if (iter-&gt;direction == AL_START_HEAD) {
446              iter-&gt;current = next;
447              iter-&gt;offset = 0;
448          } else if (iter-&gt;direction == AL_START_TAIL) {
449              iter-&gt;current = prev;
450              iter-&gt;offset = -1;
451          }
452      }
453  }
454  int quicklistReplaceAtIndex(quicklist *quicklist, PORT_LONG index, void *data,
455                              int sz) {
456      quicklistEntry entry;
457      if (likely(quicklistIndex(quicklist, index, &amp;entry))) {
458          entry.node-&gt;zl = ziplistDelete(entry.node-&gt;zl, &amp;entry.zi);
459          entry.node-&gt;zl = ziplistInsert(entry.node-&gt;zl, entry.zi, data, sz);
460          quicklistNodeUpdateSz(entry.node);
461          quicklistCompress(quicklist, entry.node);
462          return 1;
463      } else {
464          return 0;
465      }
466  }
467  REDIS_STATIC quicklistNode *_quicklistZiplistMerge(quicklist *quicklist,
468                                                     quicklistNode *a,
469                                                     quicklistNode *b) {
470      D(&quot;Requested merge (a,b) (%u, %u)&quot;, a-&gt;count, b-&gt;count);
471      quicklistDecompressNode(a);
472      quicklistDecompressNode(b);
473      if ((ziplistMerge(&amp;a-&gt;zl, &amp;b-&gt;zl))) {
474          quicklistNode *keep = NULL, *nokeep = NULL;
475          if (!a-&gt;zl) {
476              nokeep = a;
477              keep = b;
478          } else if (!b-&gt;zl) {
479              nokeep = b;
480              keep = a;
481          }
482          keep-&gt;count = ziplistLen(keep-&gt;zl);
483          quicklistNodeUpdateSz(keep);
484          nokeep-&gt;count = 0;
485          __quicklistDelNode(quicklist, nokeep);
486          quicklistCompress(quicklist, keep);
487          return keep;
488      } else {
489          return NULL;
490      }
491  }
492  REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,
493                                         quicklistNode *center) {
494      int fill = quicklist-&gt;fill;
495      quicklistNode *prev, *prev_prev, *next, *next_next, *target;
496      prev = prev_prev = next = next_next = target = NULL;
497      if (center-&gt;prev) {
498          prev = center-&gt;prev;
499          if (center-&gt;prev-&gt;prev)
500              prev_prev = center-&gt;prev-&gt;prev;
501      }
502      if (center-&gt;next) {
503          next = center-&gt;next;
504          if (center-&gt;next-&gt;next)
505              next_next = center-&gt;next-&gt;next;
506      }
507      if (_quicklistNodeAllowMerge(prev, prev_prev, fill)) {
508          _quicklistZiplistMerge(quicklist, prev_prev, prev);
509          prev_prev = prev = NULL; &amp;bsol;* they could have moved, invalidate them. */
510      }
511      if (_quicklistNodeAllowMerge(next, next_next, fill)) {
512          _quicklistZiplistMerge(quicklist, next, next_next);
513          next = next_next = NULL; &amp;bsol;* they could have moved, invalidate them. */
514      }
515      if (_quicklistNodeAllowMerge(center, center-&gt;prev, fill)) {
516          target = _quicklistZiplistMerge(quicklist, center-&gt;prev, center);
517          center = NULL; &amp;bsol;* center could have been deleted, invalidate it. */
518      } else {
519          target = center;
520      }
521      if (_quicklistNodeAllowMerge(target, target-&gt;next, fill)) {
522          _quicklistZiplistMerge(quicklist, target, target-&gt;next);
523      }
524  }
525  REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,
526                                                  int after) {
527      size_t zl_sz = node-&gt;sz;
528      quicklistNode *new_node = quicklistCreateNode();
529      new_node-&gt;zl = zmalloc(zl_sz);
530      memcpy(new_node-&gt;zl, node-&gt;zl, zl_sz);
531      int orig_start = after ? offset + 1 : 0;
532      int orig_extent = after ? -1 : offset;
533      int new_start = after ? 0 : offset;
534      int new_extent = after ? offset + 1 : -1;
535      D(&quot;After %d (%d); ranges: [%d, %d], [%d, %d]&quot;, after, offset, orig_start,
536        orig_extent, new_start, new_extent);
537      node-&gt;zl = ziplistDeleteRange(node-&gt;zl, orig_start, orig_extent);
538      node-&gt;count = ziplistLen(node-&gt;zl);
539      quicklistNodeUpdateSz(node);
540      new_node-&gt;zl = ziplistDeleteRange(new_node-&gt;zl, new_start, new_extent);
541      new_node-&gt;count = ziplistLen(new_node-&gt;zl);
542      quicklistNodeUpdateSz(new_node);
543      D(&quot;After split lengths: orig (%d), new (%d)&quot;, node-&gt;count, new_node-&gt;count);
544      return new_node;
545  }
546  REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,
547                                     void *value, const size_t sz, int after) {
548      int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;
549      int fill = quicklist-&gt;fill;
550      quicklistNode *node = entry-&gt;node;
551      quicklistNode *new_node = NULL;
552      if (!node) {
553          D(&quot;No node given!&quot;);
554          new_node = quicklistCreateNode();
555          new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
556          __quicklistInsertNode(quicklist, NULL, new_node, after);
557          new_node-&gt;count++;
558          quicklist-&gt;count++;
559          return;
560      }
561      if (!_quicklistNodeAllowInsert(node, fill, sz)) {
562          D(&quot;Current node is full with count %d with requested fill %Iu&quot;,                    WIN_PORT_FIX &amp;bsol;* %lu -&gt; %Iu */
563            node-&gt;count, fill);
564          full = 1;
565      }
566      if (after &amp;&amp; (entry-&gt;offset == node-&gt;count)) {
567          D(&quot;At Tail of current ziplist&quot;);
568          at_tail = 1;
569          if (!_quicklistNodeAllowInsert(node-&gt;next, fill, sz)) {
570              D(&quot;Next node is full too.&quot;);
571              full_next = 1;
572          }
573      }
574      if (!after &amp;&amp; (entry-&gt;offset == 0)) {
575          D(&quot;At Head&quot;);
576          at_head = 1;
577          if (!_quicklistNodeAllowInsert(node-&gt;prev, fill, sz)) {
578              D(&quot;Prev node is full too.&quot;);
579              full_prev = 1;
580          }
581      }
582      if (!full &amp;&amp; after) {
583          D(&quot;Not full, inserting after current position.&quot;);
584          quicklistDecompressNodeForUse(node);
585          unsigned char *next = ziplistNext(node-&gt;zl, entry-&gt;zi);
586          if (next == NULL) {
587              node-&gt;zl = ziplistPush(node-&gt;zl, value, sz, ZIPLIST_TAIL);
588          } else {
589              node-&gt;zl = ziplistInsert(node-&gt;zl, next, value, sz);
590          }
591          node-&gt;count++;
592          quicklistNodeUpdateSz(node);
593          quicklistRecompressOnly(quicklist, node);
594      } else if (!full &amp;&amp; !after) {
595          D(&quot;Not full, inserting before current position.&quot;);
596          quicklistDecompressNodeForUse(node);
597          node-&gt;zl = ziplistInsert(node-&gt;zl, entry-&gt;zi, value, sz);
598          node-&gt;count++;
599          quicklistNodeUpdateSz(node);
600          quicklistRecompressOnly(quicklist, node);
601      } else if (full &amp;&amp; at_tail &amp;&amp; node-&gt;next &amp;&amp; !full_next &amp;&amp; after) {
602          D(&quot;Full and tail, but next isn&#x27;t full; inserting next node head&quot;);
603          new_node = node-&gt;next;
604          quicklistDecompressNodeForUse(new_node);
605          new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_HEAD);
606          new_node-&gt;count++;
607          quicklistNodeUpdateSz(new_node);
608          quicklistRecompressOnly(quicklist, new_node);
609      } else if (full &amp;&amp; at_head &amp;&amp; node-&gt;prev &amp;&amp; !full_prev &amp;&amp; !after) {
610          D(&quot;Full and head, but prev isn&#x27;t full, inserting prev node tail&quot;);
611          new_node = node-&gt;prev;
612          quicklistDecompressNodeForUse(new_node);
613          new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_TAIL);
614          new_node-&gt;count++;
615          quicklistNodeUpdateSz(new_node);
616          quicklistRecompressOnly(quicklist, new_node);
617      } else if (full &amp;&amp; ((at_tail &amp;&amp; node-&gt;next &amp;&amp; full_next &amp;&amp; after) ||
618                          (at_head &amp;&amp; node-&gt;prev &amp;&amp; full_prev &amp;&amp; !after))) {
619          D(&quot;\tprovisioning new node...&quot;);
620          new_node = quicklistCreateNode();
621          new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
622          new_node-&gt;count++;
623          quicklistNodeUpdateSz(new_node);
624          __quicklistInsertNode(quicklist, node, new_node, after);
625      } else if (full) {
626          D(&quot;\tsplitting node...&quot;);
627          quicklistDecompressNodeForUse(node);
628          new_node = _quicklistSplitNode(node, entry-&gt;offset, after);
629          new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz,
630                                     after ? ZIPLIST_HEAD : ZIPLIST_TAIL);
631          new_node-&gt;count++;
632          quicklistNodeUpdateSz(new_node);
633          __quicklistInsertNode(quicklist, node, new_node, after);
634          _quicklistMergeNodes(quicklist, node);
635      }
636      quicklist-&gt;count++;
637  }
638  void quicklistInsertBefore(quicklist *quicklist, quicklistEntry *entry,
639                             void *value, const size_t sz) {
640      _quicklistInsert(quicklist, entry, value, sz, 0);
641  }
642  void quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,
643                            void *value, const size_t sz) {
644      _quicklistInsert(quicklist, entry, value, sz, 1);
645  }
646  int quicklistDelRange(quicklist *quicklist, const PORT_LONG start,
647                        const PORT_LONG count) {
648      if (count &lt;= 0)
649          return 0;
650      PORT_ULONG extent = count; &amp;bsol;* range is inclusive of start position */
651      if (start &gt;= 0 &amp;&amp; extent &gt; (quicklist-&gt;count - start)) {
652          extent = quicklist-&gt;count - start;
653      } else if (start &lt; 0 &amp;&amp; extent &gt; (PORT_ULONG)(-start)) {
654          extent = -start; &amp;bsol;* c.f. LREM -29 29; just delete until end. */
655      }
656      quicklistEntry entry;
657      if (!quicklistIndex(quicklist, start, &amp;entry))
658          return 0;
659      D(&quot;Quicklist delete request for start %Id, count %Id, extent: %Id&quot;, start,                 WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
660        count, extent);
661      quicklistNode *node = entry.node;
662      while (extent) {
663          quicklistNode *next = node-&gt;next;
664          PORT_ULONG del;
665          int delete_entire_node = 0;
666          if (entry.offset == 0 &amp;&amp; extent &gt;= node-&gt;count) {
667              delete_entire_node = 1;
668              del = node-&gt;count;
669          } else if (entry.offset &gt;= 0 &amp;&amp; extent &gt;= node-&gt;count) {
670              del = node-&gt;count - entry.offset;
671          } else if (entry.offset &lt; 0) {
672              del = -entry.offset;
673              if (del &gt; extent)
674                  del = extent;
675          } else {
676              del = extent;
677          }
678          D(&quot;[%Id]: asking to del: %Id because offset: %d; (ENTIRE NODE: %d), &quot;                             WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
679            &quot;node count: %u&quot;,
680            extent, del, entry.offset, delete_entire_node, node-&gt;count);
681          if (delete_entire_node) {
682              __quicklistDelNode(quicklist, node);
683          } else {
684              quicklistDecompressNodeForUse(node);
685              node-&gt;zl = ziplistDeleteRange(node-&gt;zl, entry.offset, del);
686              quicklistNodeUpdateSz(node);
687              node-&gt;count -= del;
688              quicklist-&gt;count -= del;
689              quicklistDeleteIfEmpty(quicklist, node);
690              if (node)
691                  quicklistRecompressOnly(quicklist, node);
692          }
693          extent -= del;
694          node = next;
695          entry.offset = 0;
696      }
697      return 1;
698  }
699  int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len) {
700      return ziplistCompare(p1, p2, p2_len);
701  }
702  quicklistIter *quicklistGetIterator(const quicklist *quicklist, int direction) {
703      quicklistIter *iter;
704      iter = zmalloc(sizeof(*iter));
705      if (direction == AL_START_HEAD) {
706          iter-&gt;current = quicklist-&gt;head;
707          iter-&gt;offset = 0;
708      } else if (direction == AL_START_TAIL) {
709          iter-&gt;current = quicklist-&gt;tail;
710          iter-&gt;offset = -1;
711      }
712      iter-&gt;direction = direction;
713      iter-&gt;quicklist = quicklist;
714      iter-&gt;zi = NULL;
715      return iter;
716  }
717  quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist,
718                                           const int direction,
719                                           const PORT_LONGLONG idx) {
720      quicklistEntry entry;
721      if (quicklistIndex(quicklist, idx, &amp;entry)) {
722          quicklistIter *base = quicklistGetIterator(quicklist, direction);
723          base-&gt;zi = NULL;
724          base-&gt;current = entry.node;
725          base-&gt;offset = entry.offset;
726          return base;
727      } else {
728          return NULL;
729      }
730  }
731  void quicklistReleaseIterator(quicklistIter *iter) {
732      if (iter-&gt;current)
733          quicklistCompress(iter-&gt;quicklist, iter-&gt;current);
734      zfree(iter);
735  }
736  int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {
737      initEntry(entry);
738      if (!iter) {
739          D(&quot;Returning because no iter!&quot;);
740          return 0;
741      }
742      entry-&gt;quicklist = iter-&gt;quicklist;
743      entry-&gt;node = iter-&gt;current;
744      if (!iter-&gt;current) {
745          D(&quot;Returning because current node is NULL&quot;)
746          return 0;
747      }
748      unsigned char *(*nextFn)(unsigned char *, unsigned char *) = NULL;
749      int offset_update = 0;
750      if (!iter-&gt;zi) {
751          quicklistDecompressNodeForUse(iter-&gt;current);
752          iter-&gt;zi = ziplistIndex(iter-&gt;current-&gt;zl, iter-&gt;offset);
753      } else {
754          if (iter-&gt;direction == AL_START_HEAD) {
755              nextFn = ziplistNext;
756              offset_update = 1;
757          } else if (iter-&gt;direction == AL_START_TAIL) {
758              nextFn = ziplistPrev;
759              offset_update = -1;
760          }
761          iter-&gt;zi = nextFn(iter-&gt;current-&gt;zl, iter-&gt;zi);
762          iter-&gt;offset += offset_update;
763      }
764      entry-&gt;zi = iter-&gt;zi;
765      entry-&gt;offset = iter-&gt;offset;
766      if (iter-&gt;zi) {
767          ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval);
768          return 1;
769      } else {
770          quicklistCompress(iter-&gt;quicklist, iter-&gt;current);
771          if (iter-&gt;direction == AL_START_HEAD) {
772              D(&quot;Jumping to start of next node&quot;);
773              iter-&gt;current = iter-&gt;current-&gt;next;
774              iter-&gt;offset = 0;
775          } else if (iter-&gt;direction == AL_START_TAIL) {
776              D(&quot;Jumping to end of previous node&quot;);
777              iter-&gt;current = iter-&gt;current-&gt;prev;
778              iter-&gt;offset = -1;
779          }
780          iter-&gt;zi = NULL;
781          return quicklistNext(iter, entry);
782      }
783  }
784  quicklist *quicklistDup(quicklist *orig) {
785      quicklist *copy;
786      copy = quicklistNew(orig-&gt;fill, orig-&gt;compress);
787      for (quicklistNode *current = orig-&gt;head; current;
788           current = current-&gt;next) {
789          quicklistNode *node = quicklistCreateNode();
790          if (current-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) {
791              quicklistLZF *lzf = (quicklistLZF *)current-&gt;zl;
792              size_t lzf_sz = sizeof(*lzf) + lzf-&gt;sz;
793              node-&gt;zl = zmalloc(lzf_sz);
794              memcpy(node-&gt;zl, current-&gt;zl, lzf_sz);
795          } else if (current-&gt;encoding == QUICKLIST_NODE_ENCODING_RAW) {
796              node-&gt;zl = zmalloc(current-&gt;sz);
797              memcpy(node-&gt;zl, current-&gt;zl, current-&gt;sz);
798          }
799          node-&gt;count = current-&gt;count;
800          copy-&gt;count += node-&gt;count;
801          node-&gt;sz = current-&gt;sz;
802          node-&gt;encoding = current-&gt;encoding;
803          _quicklistInsertNodeAfter(copy, copy-&gt;tail, node);
804      }
805      return copy;
806  }
807  int quicklistIndex(const quicklist *quicklist, const PORT_LONGLONG idx,
808                     quicklistEntry *entry) {
809      quicklistNode *n;
810      PORT_ULONGLONG accum = 0;
811      PORT_ULONGLONG index;
812      int forward = idx &lt; 0 ? 0 : 1; &amp;bsol;* &lt; 0 -&gt; reverse, 0+ -&gt; forward */
813      initEntry(entry);
814      entry-&gt;quicklist = quicklist;
815      if (!forward) {
816          index = (-idx) - 1;
817          n = quicklist-&gt;tail;
818      } else {
819          index = idx;
820          n = quicklist-&gt;head;
821      }
822      if (index &gt;= quicklist-&gt;count)
823          return 0;
824      while (likely(n)) {
825          if ((accum + n-&gt;count) &gt; index) {
826              break;
827          } else {
828              D(&quot;Skipping over (%p) %u at accum %lld&quot;, (void *)n, n-&gt;count,
829                accum);
830              accum += n-&gt;count;
831              n = forward ? n-&gt;next : n-&gt;prev;
832          }
833      }
834      if (!n)
835          return 0;
836      D(&quot;Found node: %p at accum %llu, idx %llu, sub+ %llu, sub- %llu&quot;, (void *)n,
837        accum, index, index - accum, (-index) - 1 + accum);
838      entry-&gt;node = n;
839      if (forward) {
840          entry-&gt;offset = index - accum;
841      } else {
842          entry-&gt;offset = (-index) - 1 + accum;
843      }
844      quicklistDecompressNodeForUse(entry-&gt;node);
845      entry-&gt;zi = ziplistIndex(entry-&gt;node-&gt;zl, entry-&gt;offset);
846      ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval);
847      return 1;
848  }
849  void quicklistRotate(quicklist *quicklist) {
850      if (quicklist-&gt;count &lt;= 1)
851          return;
852      unsigned char *p = ziplistIndex(quicklist-&gt;tail-&gt;zl, -1);
853      unsigned char *value;
854      PORT_LONGLONG longval;
855      unsigned int sz;
856      char longstr[32] = {0};
857      ziplistGet(p, &amp;value, &amp;sz, &amp;longval);
858      if (!value) {
859          sz = ll2string(longstr, sizeof(longstr), longval);
860          value = (unsigned char *)longstr;
861      }
862      quicklistPushHead(quicklist, value, sz);
863      if (quicklist-&gt;len == 1) {
864          p = ziplistIndex(quicklist-&gt;tail-&gt;zl, -1);
865      }
866      quicklistDelIndex(quicklist, quicklist-&gt;tail, &amp;p);
867  }
868  int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,
869                         unsigned int *sz, PORT_LONGLONG *sval,
870                         void *(*saver)(unsigned char *data, unsigned int sz)) {
871      unsigned char *p;
872      unsigned char *vstr;
873      unsigned int vlen;
874      PORT_LONGLONG vlong;
875      int pos = (where == QUICKLIST_HEAD) ? 0 : -1;
876      if (quicklist-&gt;count == 0)
877          return 0;
878      if (data)
879          *data = NULL;
880      if (sz)
881          *sz = 0;
882      if (sval)
883          *sval = -123456789;
884      quicklistNode *node;
885      if (where == QUICKLIST_HEAD &amp;&amp; quicklist-&gt;head) {
886          node = quicklist-&gt;head;
887      } else if (where == QUICKLIST_TAIL &amp;&amp; quicklist-&gt;tail) {
888          node = quicklist-&gt;tail;
889      } else {
890          return 0;
891      }
892      p = ziplistIndex(node-&gt;zl, pos);
893      if (ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vlong)) {
894          if (vstr) {
895              if (data)
896                  *data = saver(vstr, vlen);
897              if (sz)
898                  *sz = vlen;
899          } else {
900              if (data)
901                  *data = NULL;
902              if (sval)
903                  *sval = vlong;
904          }
905          quicklistDelIndex(quicklist, node, &amp;p);
906          return 1;
907      }
908      return 0;
909  }
910  REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) {
911      unsigned char *vstr;
912      if (data) {
913          vstr = zmalloc(sz);
914          memcpy(vstr, data, sz);
915          return vstr;
916      }
917      return NULL;
918  }
919  int quicklistPop(quicklist *quicklist, int where, unsigned char **data,
920                   unsigned int *sz, PORT_LONGLONG *slong) {
921      unsigned char *vstr;
922      unsigned int vlen;
923      PORT_LONGLONG vlong;
924      if (quicklist-&gt;count == 0)
925          return 0;
926      int ret = quicklistPopCustom(quicklist, where, &amp;vstr, &amp;vlen, &amp;vlong,
927                                   _quicklistSaver);
928      if (data)
929          *data = vstr;
930      if (slong)
931          *slong = vlong;
932      if (sz)
933          *sz = vlen;
934      return ret;
935  }
936  void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
937                     int where) {
938      if (where == QUICKLIST_HEAD) {
939          quicklistPushHead(quicklist, value, sz);
940      } else if (where == QUICKLIST_TAIL) {
941          quicklistPushTail(quicklist, value, sz);
942      }
943  }
944  #ifdef REDIS_TEST
945  #include &lt;stdint.h&gt;
946  #include &lt;sys/time.h&gt;
947  #define assert(_e)                                                             \
948      do {                                                                       \
949          if (!(_e)) {                                                           \
950              printf(&quot;\n\n=== ASSERTION FAILED ===\n&quot;);                          \
951              printf(&quot;==&gt; %s:%d &#x27;%s&#x27; is not true\n&quot;, __FILE__, __LINE__, #_e);   \
952              err++;                                                             \
953          }                                                                      \
954      } while (0)
955  #define yell(str, ...) printf(&quot;ERROR! &quot; str &quot;\n\n&quot;, __VA_ARGS__)
956  #define OK printf(&quot;\tOK\n&quot;)
957  #define ERROR                                                                  \
958      do {                                                                       \
959          printf(&quot;\tERROR!\n&quot;);                                                  \
960          err++;                                                                 \
961      } while (0)
962  #define ERR(x, ...)                                                            \
963      do {                                                                       \
964          printf(&quot;%s:%s:%d:\t&quot;, __FILE__, __FUNCTION__, __LINE__);               \
965          printf(&quot;ERROR! &quot; x &quot;\n&quot;, __VA_ARGS__);                                 \
966          err++;                                                                 \
967      } while (0)
968  #define TEST(name) printf(&quot;test — %s\n&quot;, name);
969  #define TEST_DESC(name, ...) printf(&quot;test — &quot; name &quot;\n&quot;, __VA_ARGS__);
970  #define QL_TEST_VERBOSE 0
971  #define UNUSED(x) (void)(x)
972  static void ql_info(quicklist *ql) {
973  #if QL_TEST_VERBOSE
974      printf(&quot;Container length: %lu\n&quot;, ql-&gt;len);
975      printf(&quot;Container size: %lu\n&quot;, ql-&gt;count);
976      if (ql-&gt;head)
977          printf(&quot;\t(zsize head: %d)\n&quot;, ziplistLen(ql-&gt;head-&gt;zl));
978      if (ql-&gt;tail)
979          printf(&quot;\t(zsize tail: %d)\n&quot;, ziplistLen(ql-&gt;tail-&gt;zl));
980      printf(&quot;\n&quot;);
981  #else
982      UNUSED(ql);
983  #endif
984  }
985  static PORT_LONGLONG ustime(void) {
986      struct timeval tv;
987      PORT_LONGLONG ust;
988      gettimeofday(&amp;tv, NULL);
989      ust = ((PORT_LONGLONG)tv.tv_sec) * 1000000;
990      ust += tv.tv_usec;
991      return ust;
992  }
993  static PORT_LONGLONG mstime(void) { return ustime() / 1000; }
994  static int _itrprintr(quicklist *ql, int print, int forward) {
995      quicklistIter *iter =
996          quicklistGetIterator(ql, forward ? AL_START_HEAD : AL_START_TAIL);
997      quicklistEntry entry;
998      int i = 0;
999      int p = 0;
1000      quicklistNode *prev = NULL;
1001      while (quicklistNext(iter, &amp;entry)) {
1002          if (entry.node != prev) {
1003              p++;
1004              prev = entry.node;
1005          }
1006          if (print) {
1007              printf(&quot;[%3d (%2d)]: [%.*s] (%lld)\n&quot;, i, p, entry.sz,
1008                     (char *)entry.value, entry.longval);
1009          }
1010          i++;
1011      }
1012      quicklistReleaseIterator(iter);
1013      return i;
1014  }
1015  static int itrprintr(quicklist *ql, int print) {
1016      return _itrprintr(ql, print, 1);
1017  }
1018  static int itrprintr_rev(quicklist *ql, int print) {
1019      return _itrprintr(ql, print, 0);
1020  }
1021  #define ql_verify(a, b, c, d, e)                                               \
1022      do {                                                                       \
1023          err += _ql_verify((a), (b), (c), (d), (e));                            \
1024      } while (0)
1025  static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,
1026                        uint32_t head_count, uint32_t tail_count) {
1027      int errors = 0;
1028      ql_info(ql);
1029      if (len != ql-&gt;len) {
1030          yell(&quot;quicklist length wrong: expected %d, got %u&quot;, len, ql-&gt;len);
1031          errors++;
1032      }
1033      if (count != ql-&gt;count) {
1034          yell(&quot;quicklist count wrong: expected %d, got %lu&quot;, count, ql-&gt;count);
1035          errors++;
1036      }
1037      int loopr = itrprintr(ql, 0);
1038      if (loopr != (int)ql-&gt;count) {
1039          yell(&quot;quicklist cached count not match actual count: expected %lu, got &quot;
1040               &quot;%d&quot;,
1041               ql-&gt;count, loopr);
1042          errors++;
1043      }
1044      int rloopr = itrprintr_rev(ql, 0);
1045      if (loopr != rloopr) {
1046          yell(&quot;quicklist has different forward count than reverse count!  &quot;
1047               &quot;Forward count is %d, reverse count is %d.&quot;,
1048               loopr, rloopr);
1049          errors++;
1050      }
1051      if (ql-&gt;len == 0 &amp;&amp; !errors) {
1052          OK;
1053          return errors;
1054      }
1055      if (ql-&gt;head &amp;&amp; head_count != ql-&gt;head-&gt;count &amp;&amp;
1056          head_count != ziplistLen(ql-&gt;head-&gt;zl)) {
1057          yell(&quot;quicklist head count wrong: expected %d, &quot;
1058               &quot;got cached %d vs. actual %d&quot;,
1059               head_count, ql-&gt;head-&gt;count, ziplistLen(ql-&gt;head-&gt;zl));
1060          errors++;
1061      }
1062      if (ql-&gt;tail &amp;&amp; tail_count != ql-&gt;tail-&gt;count &amp;&amp;
1063          tail_count != ziplistLen(ql-&gt;tail-&gt;zl)) {
1064          yell(&quot;quicklist tail count wrong: expected %d, &quot;
1065               &quot;got cached %u vs. actual %d&quot;,
1066               tail_count, ql-&gt;tail-&gt;count, ziplistLen(ql-&gt;tail-&gt;zl));
1067          errors++;
1068      }
1069      if (quicklistAllowsCompression(ql)) {
1070          quicklistNode *node = ql-&gt;head;
1071          unsigned int low_raw = ql-&gt;compress;
1072          unsigned int high_raw = ql-&gt;len - ql-&gt;compress;
1073          for (unsigned int at = 0; at &lt; ql-&gt;len; at++, node = node-&gt;next) {
1074              if (node &amp;&amp; (at &lt; low_raw || at &gt;= high_raw)) {
1075                  if (node-&gt;encoding != QUICKLIST_NODE_ENCODING_RAW) {
1076                      yell(&quot;Incorrect compression: node %d is &quot;
1077                           &quot;compressed at depth %d ((%u, %u); total &quot;
1078                           &quot;nodes: %u; size: %u; recompress: %d)&quot;,
1079                           at, ql-&gt;compress, low_raw, high_raw, ql-&gt;len, node-&gt;sz,
1080                           node-&gt;recompress);
1081                      errors++;
1082                  }
1083              } else {
1084                  if (node-&gt;encoding != QUICKLIST_NODE_ENCODING_LZF &amp;&amp;
1085                      !node-&gt;attempted_compress) {
1086                      yell(&quot;Incorrect non-compression: node %d is NOT &quot;
1087                           &quot;compressed at depth %d ((%u, %u); total &quot;
1088                           &quot;nodes: %u; size: %u; recompress: %d; attempted: %d)&quot;,
1089                           at, ql-&gt;compress, low_raw, high_raw, ql-&gt;len, node-&gt;sz,
1090                           node-&gt;recompress, node-&gt;attempted_compress);
1091                      errors++;
1092                  }
1093              }
1094          }
1095      }
1096      if (!errors)
1097          OK;
1098      return errors;
1099  }
1100  static char *genstr(char *prefix, int i) {
1101      static char result[64] = {0};
1102      snprintf(result, sizeof(result), &quot;%s%d&quot;, prefix, i);
1103      return result;
1104  }
1105  int quicklistTest(int argc, char *argv[]) {
1106      UNUSED(argc);
1107      UNUSED(argv);
1108      unsigned int err = 0;
1109      int optimize_start =
1110          -(int)(sizeof(optimization_level) / sizeof(*optimization_level));
1111      printf(&quot;Starting optimization offset at: %d\n&quot;, optimize_start);
1112      int options[] = {0, 1, 2, 3, 4, 5, 6, 10};
1113      size_t option_count = sizeof(options) / sizeof(*options);
1114      PORT_LONGLONG runtime[option_count];
1115      for (int _i = 0; _i &lt; (int)option_count; _i++) {
1116          printf(&quot;Testing Option %d\n&quot;, options[_i]);
1117          PORT_LONGLONG start = mstime();
1118          TEST(&quot;create list&quot;) {
1119              quicklist *ql = quicklistNew(-2, options[_i]);
1120              ql_verify(ql, 0, 0, 0, 0);
1121              quicklistRelease(ql);
1122          }
1123          TEST(&quot;add to tail of empty list&quot;) {
1124              quicklist *ql = quicklistNew(-2, options[_i]);
1125              quicklistPushTail(ql, &quot;hello&quot;, 6);
1126              ql_verify(ql, 1, 1, 1, 1);
1127              quicklistRelease(ql);
1128          }
1129          TEST(&quot;add to head of empty list&quot;) {
1130              quicklist *ql = quicklistNew(-2, options[_i]);
1131              quicklistPushHead(ql, &quot;hello&quot;, 6);
1132              ql_verify(ql, 1, 1, 1, 1);
1133              quicklistRelease(ql);
1134          }
1135          for (int f = optimize_start; f &lt; 32; f++) {
1136              TEST_DESC(&quot;add to tail 5x at fill %d at compress %d&quot;, f,
1137                        options[_i]) {
1138                  quicklist *ql = quicklistNew(f, options[_i]);
1139                  for (int i = 0; i &lt; 5; i++)
1140                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i), 32);
1141                  if (ql-&gt;count != 5)
1142                      ERROR;
1143                  if (f == 32)
1144                      ql_verify(ql, 1, 5, 5, 5);
1145                  quicklistRelease(ql);
1146              }
1147          }
1148          for (int f = optimize_start; f &lt; 32; f++) {
1149              TEST_DESC(&quot;add to head 5x at fill %d at compress %d&quot;, f,
1150                        options[_i]) {
1151                  quicklist *ql = quicklistNew(f, options[_i]);
1152                  for (int i = 0; i &lt; 5; i++)
1153                      quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1154                  if (ql-&gt;count != 5)
1155                      ERROR;
1156                  if (f == 32)
1157                      ql_verify(ql, 1, 5, 5, 5);
1158                  quicklistRelease(ql);
1159              }
1160          }
1161          for (int f = optimize_start; f &lt; 512; f++) {
1162              TEST_DESC(&quot;add to tail 500x at fill %d at compress %d&quot;, f,
1163                        options[_i]) {
1164                  quicklist *ql = quicklistNew(f, options[_i]);
1165                  for (int i = 0; i &lt; 500; i++)
1166                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i), 64);
1167                  if (ql-&gt;count != 500)
1168                      ERROR;
1169                  if (f == 32)
1170                      ql_verify(ql, 16, 500, 32, 20);
1171                  quicklistRelease(ql);
1172              }
1173          }
1174          for (int f = optimize_start; f &lt; 512; f++) {
1175              TEST_DESC(&quot;add to head 500x at fill %d at compress %d&quot;, f,
1176                        options[_i]) {
1177                  quicklist *ql = quicklistNew(f, options[_i]);
1178                  for (int i = 0; i &lt; 500; i++)
1179                      quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1180                  if (ql-&gt;count != 500)
1181                      ERROR;
1182                  if (f == 32)
1183                      ql_verify(ql, 16, 500, 20, 32);
1184                  quicklistRelease(ql);
1185              }
1186          }
1187          TEST(&quot;rotate empty&quot;) {
1188              quicklist *ql = quicklistNew(-2, options[_i]);
1189              quicklistRotate(ql);
1190              ql_verify(ql, 0, 0, 0, 0);
1191              quicklistRelease(ql);
1192          }
1193          for (int f = optimize_start; f &lt; 32; f++) {
1194              TEST(&quot;rotate one val once&quot;) {
1195                  quicklist *ql = quicklistNew(f, options[_i]);
1196                  quicklistPushHead(ql, &quot;hello&quot;, 6);
1197                  quicklistRotate(ql);
1198                  ql_verify(ql, 1, 1, 1, 1);
1199                  quicklistRelease(ql);
1200              }
1201          }
1202          for (int f = optimize_start; f &lt; 3; f++) {
1203              TEST_DESC(&quot;rotate 500 val 5000 times at fill %d at compress %d&quot;, f,
1204                        options[_i]) {
1205                  quicklist *ql = quicklistNew(f, options[_i]);
1206                  quicklistPushHead(ql, &quot;900&quot;, 3);
1207                  quicklistPushHead(ql, &quot;7000&quot;, 4);
1208                  quicklistPushHead(ql, &quot;-1200&quot;, 5);
1209                  quicklistPushHead(ql, &quot;42&quot;, 2);
1210                  for (int i = 0; i &lt; 500; i++)
1211                      quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 64);
1212                  ql_info(ql);
1213                  for (int i = 0; i &lt; 5000; i++) {
1214                      ql_info(ql);
1215                      quicklistRotate(ql);
1216                  }
1217                  if (f == 1)
1218                      ql_verify(ql, 504, 504, 1, 1);
1219                  else if (f == 2)
1220                      ql_verify(ql, 252, 504, 2, 2);
1221                  else if (f == 32)
1222                      ql_verify(ql, 16, 504, 32, 24);
1223                  quicklistRelease(ql);
1224              }
1225          }
1226          TEST(&quot;pop empty&quot;) {
1227              quicklist *ql = quicklistNew(-2, options[_i]);
1228              quicklistPop(ql, QUICKLIST_HEAD, NULL, NULL, NULL);
1229              ql_verify(ql, 0, 0, 0, 0);
1230              quicklistRelease(ql);
1231          }
1232          TEST(&quot;pop 1 string from 1&quot;) {
1233              quicklist *ql = quicklistNew(-2, options[_i]);
1234              char *populate = genstr(&quot;hello&quot;, 331);
1235              quicklistPushHead(ql, populate, 32);
1236              unsigned char *data;
1237              unsigned int sz;
1238              PORT_LONGLONG lv;
1239              ql_info(ql);
1240              quicklistPop(ql, QUICKLIST_HEAD, &amp;data, &amp;sz, &amp;lv);
1241              assert(data != NULL);
1242              assert(sz == 32);
1243              if (strcmp(populate, (char *)data))
1244                  ERR(&quot;Pop&#x27;d value (%.*s) didn&#x27;t equal original value (%s)&quot;, sz,
1245                      data, populate);
1246              zfree(data);
1247              ql_verify(ql, 0, 0, 0, 0);
1248              quicklistRelease(ql);
1249          }
1250          TEST(&quot;pop head 1 number from 1&quot;) {
1251              quicklist *ql = quicklistNew(-2, options[_i]);
1252              quicklistPushHead(ql, &quot;55513&quot;, 5);
1253              unsigned char *data;
1254              unsigned int sz;
1255              PORT_LONGLONG lv;
1256              ql_info(ql);
1257              quicklistPop(ql, QUICKLIST_HEAD, &amp;data, &amp;sz, &amp;lv);
1258              assert(data == NULL);
1259              assert(lv == 55513);
1260              ql_verify(ql, 0, 0, 0, 0);
1261              quicklistRelease(ql);
1262          }
1263          TEST(&quot;pop head 500 from 500&quot;) {
1264              quicklist *ql = quicklistNew(-2, options[_i]);
1265              for (int i = 0; i &lt; 500; i++)
1266                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1267              ql_info(ql);
1268              for (int i = 0; i &lt; 500; i++) {
1269                  unsigned char *data;
1270                  unsigned int sz;
1271                  PORT_LONGLONG lv;
1272                  int ret = quicklistPop(ql, QUICKLIST_HEAD, &amp;data, &amp;sz, &amp;lv);
1273                  assert(ret == 1);
1274                  assert(data != NULL);
1275                  assert(sz == 32);
1276                  if (strcmp(genstr(&quot;hello&quot;, 499 - i), (char *)data))
1277                      ERR(&quot;Pop&#x27;d value (%.*s) didn&#x27;t equal original value (%s)&quot;,
1278                          sz, data, genstr(&quot;hello&quot;, 499 - i));
1279                  zfree(data);
1280              }
1281              ql_verify(ql, 0, 0, 0, 0);
1282              quicklistRelease(ql);
1283          }
1284          TEST(&quot;pop head 5000 from 500&quot;) {
1285              quicklist *ql = quicklistNew(-2, options[_i]);
1286              for (int i = 0; i &lt; 500; i++)
1287                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1288              for (int i = 0; i &lt; 5000; i++) {
1289                  unsigned char *data;
1290                  unsigned int sz;
1291                  PORT_LONGLONG lv;
1292                  int ret = quicklistPop(ql, QUICKLIST_HEAD, &amp;data, &amp;sz, &amp;lv);
1293                  if (i &lt; 500) {
1294                      assert(ret == 1);
1295                      assert(data != NULL);
1296                      assert(sz == 32);
1297                      if (strcmp(genstr(&quot;hello&quot;, 499 - i), (char *)data))
1298                          ERR(&quot;Pop&#x27;d value (%.*s) didn&#x27;t equal original value &quot;
1299                              &quot;(%s)&quot;,
1300                              sz, data, genstr(&quot;hello&quot;, 499 - i));
1301                      zfree(data);
1302                  } else {
1303                      assert(ret == 0);
1304                  }
1305              }
1306              ql_verify(ql, 0, 0, 0, 0);
1307              quicklistRelease(ql);
1308          }
1309          TEST(&quot;iterate forward over 500 list&quot;) {
1310              quicklist *ql = quicklistNew(-2, options[_i]);
1311              quicklistSetFill(ql, 32);
1312              for (int i = 0; i &lt; 500; i++)
1313                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1314              quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);
1315              quicklistEntry entry;
1316              int i = 499, count = 0;
1317              while (quicklistNext(iter, &amp;entry)) {
1318                  char *h = genstr(&quot;hello&quot;, i);
1319                  if (strcmp((char *)entry.value, h))
1320                      ERR(&quot;value [%s] didn&#x27;t match [%s] at position %d&quot;,
1321                          entry.value, h, i);
1322                  i--;
1323                  count++;
1324              }
1325              if (count != 500)
1326                  ERR(&quot;Didn&#x27;t iterate over exactly 500 elements (%d)&quot;, i);
1327              ql_verify(ql, 16, 500, 20, 32);
1328              quicklistReleaseIterator(iter);
1329              quicklistRelease(ql);
1330          }
1331          TEST(&quot;iterate reverse over 500 list&quot;) {
1332              quicklist *ql = quicklistNew(-2, options[_i]);
1333              quicklistSetFill(ql, 32);
1334              for (int i = 0; i &lt; 500; i++)
1335                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1336              quicklistIter *iter = quicklistGetIterator(ql, AL_START_TAIL);
1337              quicklistEntry entry;
1338              int i = 0;
1339              while (quicklistNext(iter, &amp;entry)) {
1340                  char *h = genstr(&quot;hello&quot;, i);
1341                  if (strcmp((char *)entry.value, h))
1342                      ERR(&quot;value [%s] didn&#x27;t match [%s] at position %d&quot;,
1343                          entry.value, h, i);
1344                  i++;
1345              }
1346              if (i != 500)
1347                  ERR(&quot;Didn&#x27;t iterate over exactly 500 elements (%d)&quot;, i);
1348              ql_verify(ql, 16, 500, 20, 32);
1349              quicklistReleaseIterator(iter);
1350              quicklistRelease(ql);
1351          }
1352          TEST(&quot;insert before with 0 elements&quot;) {
1353              quicklist *ql = quicklistNew(-2, options[_i]);
1354              quicklistEntry entry;
1355              quicklistIndex(ql, 0, &amp;entry);
1356              quicklistInsertBefore(ql, &amp;entry, &quot;abc&quot;, 4);
1357              ql_verify(ql, 1, 1, 1, 1);
1358              quicklistRelease(ql);
1359          }
1360          TEST(&quot;insert after with 0 elements&quot;) {
1361              quicklist *ql = quicklistNew(-2, options[_i]);
1362              quicklistEntry entry;
1363              quicklistIndex(ql, 0, &amp;entry);
1364              quicklistInsertAfter(ql, &amp;entry, &quot;abc&quot;, 4);
1365              ql_verify(ql, 1, 1, 1, 1);
1366              quicklistRelease(ql);
1367          }
1368          TEST(&quot;insert after 1 element&quot;) {
1369              quicklist *ql = quicklistNew(-2, options[_i]);
1370              quicklistPushHead(ql, &quot;hello&quot;, 6);
1371              quicklistEntry entry;
1372              quicklistIndex(ql, 0, &amp;entry);
1373              quicklistInsertAfter(ql, &amp;entry, &quot;abc&quot;, 4);
1374              ql_verify(ql, 1, 2, 2, 2);
1375              quicklistRelease(ql);
1376          }
1377          TEST(&quot;insert before 1 element&quot;) {
1378              quicklist *ql = quicklistNew(-2, options[_i]);
1379              quicklistPushHead(ql, &quot;hello&quot;, 6);
1380              quicklistEntry entry;
1381              quicklistIndex(ql, 0, &amp;entry);
1382              quicklistInsertAfter(ql, &amp;entry, &quot;abc&quot;, 4);
1383              ql_verify(ql, 1, 2, 2, 2);
1384              quicklistRelease(ql);
1385          }
1386          for (int f = optimize_start; f &lt; 12; f++) {
1387              TEST_DESC(&quot;insert once in elements while iterating at fill %d at &quot;
1388                        &quot;compress %d\n&quot;,
1389                        f, options[_i]) {
1390                  quicklist *ql = quicklistNew(f, options[_i]);
1391                  quicklistPushTail(ql, &quot;abc&quot;, 3);
1392                  quicklistSetFill(ql, 1);
1393                  quicklistPushTail(ql, &quot;def&quot;, 3); &amp;bsol;* force to unique node */
1394                  quicklistSetFill(ql, f);
1395                  quicklistPushTail(ql, &quot;bob&quot;, 3); &amp;bsol;* force to reset for +3 */
1396                  quicklistPushTail(ql, &quot;foo&quot;, 3);
1397                  quicklistPushTail(ql, &quot;zoo&quot;, 3);
1398                  itrprintr(ql, 0);
1399                  quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);
1400                  quicklistEntry entry;
1401                  while (quicklistNext(iter, &amp;entry)) {
1402                      if (!strncmp((char *)entry.value, &quot;bob&quot;, 3)) {
1403                          quicklistInsertBefore(ql, &amp;entry, &quot;bar&quot;, 3);
1404                          break; &amp;bsol;* didn&#x27;t we fix insert-while-iterating? */
1405                      }
1406                  }
1407                  itrprintr(ql, 0);
1408                  quicklistIndex(ql, 0, &amp;entry);
1409                  if (strncmp((char *)entry.value, &quot;abc&quot;, 3))
1410                      ERR(&quot;Value 0 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1411                          entry.value);
1412                  quicklistIndex(ql, 1, &amp;entry);
1413                  if (strncmp((char *)entry.value, &quot;def&quot;, 3))
1414                      ERR(&quot;Value 1 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1415                          entry.value);
1416                  quicklistIndex(ql, 2, &amp;entry);
1417                  if (strncmp((char *)entry.value, &quot;bar&quot;, 3))
1418                      ERR(&quot;Value 2 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1419                          entry.value);
1420                  quicklistIndex(ql, 3, &amp;entry);
1421                  if (strncmp((char *)entry.value, &quot;bob&quot;, 3))
1422                      ERR(&quot;Value 3 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1423                          entry.value);
1424                  quicklistIndex(ql, 4, &amp;entry);
1425                  if (strncmp((char *)entry.value, &quot;foo&quot;, 3))
1426                      ERR(&quot;Value 4 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1427                          entry.value);
1428                  quicklistIndex(ql, 5, &amp;entry);
1429                  if (strncmp((char *)entry.value, &quot;zoo&quot;, 3))
1430                      ERR(&quot;Value 5 didn&#x27;t match, instead got: %.*s&quot;, entry.sz,
1431                          entry.value);
1432                  quicklistReleaseIterator(iter);
1433                  quicklistRelease(ql);
1434              }
1435          }
1436          for (int f = optimize_start; f &lt; 1024; f++) {
1437              TEST_DESC(
1438                  &quot;insert [before] 250 new in middle of 500 elements at fill&quot;
1439                  &quot; %d at compress %d&quot;,
1440                  f, options[_i]) {
1441                  quicklist *ql = quicklistNew(f, options[_i]);
1442                  for (int i = 0; i &lt; 500; i++)
1443                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i), 32);
1444                  for (int i = 0; i &lt; 250; i++) {
1445                      quicklistEntry entry;
1446                      quicklistIndex(ql, 250, &amp;entry);
1447                      quicklistInsertBefore(ql, &amp;entry, genstr(&quot;abc&quot;, i), 32);
1448                  }
1449                  if (f == 32)
1450                      ql_verify(ql, 25, 750, 32, 20);
1451                  quicklistRelease(ql);
1452              }
1453          }
1454          for (int f = optimize_start; f &lt; 1024; f++) {
1455              TEST_DESC(&quot;insert [after] 250 new in middle of 500 elements at &quot;
1456                        &quot;fill %d at compress %d&quot;,
1457                        f, options[_i]) {
1458                  quicklist *ql = quicklistNew(f, options[_i]);
1459                  for (int i = 0; i &lt; 500; i++)
1460                      quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1461                  for (int i = 0; i &lt; 250; i++) {
1462                      quicklistEntry entry;
1463                      quicklistIndex(ql, 250, &amp;entry);
1464                      quicklistInsertAfter(ql, &amp;entry, genstr(&quot;abc&quot;, i), 32);
1465                  }
1466                  if (ql-&gt;count != 750)
1467                      ERR(&quot;List size not 750, but rather %ld&quot;, ql-&gt;count);
1468                  if (f == 32)
1469                      ql_verify(ql, 26, 750, 20, 32);
1470                  quicklistRelease(ql);
1471              }
1472          }
1473          TEST(&quot;duplicate empty list&quot;) {
1474              quicklist *ql = quicklistNew(-2, options[_i]);
1475              ql_verify(ql, 0, 0, 0, 0);
1476              quicklist *copy = quicklistDup(ql);
1477              ql_verify(copy, 0, 0, 0, 0);
1478              quicklistRelease(ql);
1479              quicklistRelease(copy);
1480          }
1481          TEST(&quot;duplicate list of 1 element&quot;) {
1482              quicklist *ql = quicklistNew(-2, options[_i]);
1483              quicklistPushHead(ql, genstr(&quot;hello&quot;, 3), 32);
1484              ql_verify(ql, 1, 1, 1, 1);
1485              quicklist *copy = quicklistDup(ql);
1486              ql_verify(copy, 1, 1, 1, 1);
1487              quicklistRelease(ql);
1488              quicklistRelease(copy);
1489          }
1490          TEST(&quot;duplicate list of 500&quot;) {
1491              quicklist *ql = quicklistNew(-2, options[_i]);
1492              quicklistSetFill(ql, 32);
1493              for (int i = 0; i &lt; 500; i++)
1494                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1495              ql_verify(ql, 16, 500, 20, 32);
1496              quicklist *copy = quicklistDup(ql);
1497              ql_verify(copy, 16, 500, 20, 32);
1498              quicklistRelease(ql);
1499              quicklistRelease(copy);
1500          }
1501          for (int f = optimize_start; f &lt; 512; f++) {
1502              TEST_DESC(&quot;index 1,200 from 500 list at fill %d at compress %d&quot;, f,
1503                        options[_i]) {
1504                  quicklist *ql = quicklistNew(f, options[_i]);
1505                  for (int i = 0; i &lt; 500; i++)
1506                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1507                  quicklistEntry entry;
1508                  quicklistIndex(ql, 1, &amp;entry);
1509                  if (!strcmp((char *)entry.value, &quot;hello2&quot;))
1510                      OK;
1511                  else
1512                      ERR(&quot;Value: %s&quot;, entry.value);
1513                  quicklistIndex(ql, 200, &amp;entry);
1514                  if (!strcmp((char *)entry.value, &quot;hello201&quot;))
1515                      OK;
1516                  else
1517                      ERR(&quot;Value: %s&quot;, entry.value);
1518                  quicklistRelease(ql);
1519              }
1520              TEST_DESC(&quot;index -1,-2 from 500 list at fill %d at compress %d&quot;, f,
1521                        options[_i]) {
1522                  quicklist *ql = quicklistNew(f, options[_i]);
1523                  for (int i = 0; i &lt; 500; i++)
1524                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1525                  quicklistEntry entry;
1526                  quicklistIndex(ql, -1, &amp;entry);
1527                  if (!strcmp((char *)entry.value, &quot;hello500&quot;))
1528                      OK;
1529                  else
1530                      ERR(&quot;Value: %s&quot;, entry.value);
1531                  quicklistIndex(ql, -2, &amp;entry);
1532                  if (!strcmp((char *)entry.value, &quot;hello499&quot;))
1533                      OK;
1534                  else
1535                      ERR(&quot;Value: %s&quot;, entry.value);
1536                  quicklistRelease(ql);
1537              }
1538              TEST_DESC(&quot;index -100 from 500 list at fill %d at compress %d&quot;, f,
1539                        options[_i]) {
1540                  quicklist *ql = quicklistNew(f, options[_i]);
1541                  for (int i = 0; i &lt; 500; i++)
1542                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1543                  quicklistEntry entry;
1544                  quicklistIndex(ql, -100, &amp;entry);
1545                  if (!strcmp((char *)entry.value, &quot;hello401&quot;))
1546                      OK;
1547                  else
1548                      ERR(&quot;Value: %s&quot;, entry.value);
1549                  quicklistRelease(ql);
1550              }
1551              TEST_DESC(&quot;index too big +1 from 50 list at fill %d at compress %d&quot;,
1552                        f, options[_i]) {
1553                  quicklist *ql = quicklistNew(f, options[_i]);
1554                  for (int i = 0; i &lt; 50; i++)
1555                      quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1556                  quicklistEntry entry;
1557                  if (quicklistIndex(ql, 50, &amp;entry))
1558                      ERR(&quot;Index found at 50 with 50 list: %.*s&quot;, entry.sz,
1559                          entry.value);
1560                  else
1561                      OK;
1562                  quicklistRelease(ql);
1563              }
1564          }
1565          TEST(&quot;delete range empty list&quot;) {
1566              quicklist *ql = quicklistNew(-2, options[_i]);
1567              quicklistDelRange(ql, 5, 20);
1568              ql_verify(ql, 0, 0, 0, 0);
1569              quicklistRelease(ql);
1570          }
1571          TEST(&quot;delete range of entire node in list of one node&quot;) {
1572              quicklist *ql = quicklistNew(-2, options[_i]);
1573              for (int i = 0; i &lt; 32; i++)
1574                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1575              ql_verify(ql, 1, 32, 32, 32);
1576              quicklistDelRange(ql, 0, 32);
1577              ql_verify(ql, 0, 0, 0, 0);
1578              quicklistRelease(ql);
1579          }
1580          TEST(&quot;delete range of entire node with overflow counts&quot;) {
1581              quicklist *ql = quicklistNew(-2, options[_i]);
1582              for (int i = 0; i &lt; 32; i++)
1583                  quicklistPushHead(ql, genstr(&quot;hello&quot;, i), 32);
1584              ql_verify(ql, 1, 32, 32, 32);
1585              quicklistDelRange(ql, 0, 128);
1586              ql_verify(ql, 0, 0, 0, 0);
1587              quicklistRelease(ql);
1588          }
1589          TEST(&quot;delete middle 100 of 500 list&quot;) {
1590              quicklist *ql = quicklistNew(-2, options[_i]);
1591              quicklistSetFill(ql, 32);
1592              for (int i = 0; i &lt; 500; i++)
1593                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1594              ql_verify(ql, 16, 500, 32, 20);
1595              quicklistDelRange(ql, 200, 100);
1596              ql_verify(ql, 14, 400, 32, 20);
1597              quicklistRelease(ql);
1598          }
1599          TEST(&quot;delete negative 1 from 500 list&quot;) {
1600              quicklist *ql = quicklistNew(-2, options[_i]);
1601              quicklistSetFill(ql, 32);
1602              for (int i = 0; i &lt; 500; i++)
1603                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1604              ql_verify(ql, 16, 500, 32, 20);
1605              quicklistDelRange(ql, -1, 1);
1606              ql_verify(ql, 16, 499, 32, 19);
1607              quicklistRelease(ql);
1608          }
1609          TEST(&quot;delete negative 1 from 500 list with overflow counts&quot;) {
1610              quicklist *ql = quicklistNew(-2, options[_i]);
1611              quicklistSetFill(ql, 32);
1612              for (int i = 0; i &lt; 500; i++)
1613                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1614              ql_verify(ql, 16, 500, 32, 20);
1615              quicklistDelRange(ql, -1, 128);
1616              ql_verify(ql, 16, 499, 32, 19);
1617              quicklistRelease(ql);
1618          }
1619          TEST(&quot;delete negative 100 from 500 list&quot;) {
1620              quicklist *ql = quicklistNew(-2, options[_i]);
1621              quicklistSetFill(ql, 32);
1622              for (int i = 0; i &lt; 500; i++)
1623                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1624              quicklistDelRange(ql, -100, 100);
1625              ql_verify(ql, 13, 400, 32, 16);
1626              quicklistRelease(ql);
1627          }
1628          TEST(&quot;delete -10 count 5 from 50 list&quot;) {
1629              quicklist *ql = quicklistNew(-2, options[_i]);
1630              quicklistSetFill(ql, 32);
1631              for (int i = 0; i &lt; 50; i++)
1632                  quicklistPushTail(ql, genstr(&quot;hello&quot;, i + 1), 32);
1633              ql_verify(ql, 2, 50, 32, 18);
1634              quicklistDelRange(ql, -10, 5);
1635              ql_verify(ql, 2, 45, 32, 13);
1636              quicklistRelease(ql);
1637          }
1638          TEST(&quot;numbers only list read&quot;) {
1639              quicklist *ql = quicklistNew(-2, options[_i]);
1640              quicklistPushTail(ql, &quot;1111&quot;, 4);
1641              quicklistPushTail(ql, &quot;2222&quot;, 4);
1642              quicklistPushTail(ql, &quot;3333&quot;, 4);
1643              quicklistPushTail(ql, &quot;4444&quot;, 4);
1644              ql_verify(ql, 1, 4, 4, 4);
1645              quicklistEntry entry;
1646              quicklistIndex(ql, 0, &amp;entry);
1647              if (entry.longval != 1111)
1648                  ERR(&quot;Not 1111, %lld&quot;, entry.longval);
1649              quicklistIndex(ql, 1, &amp;entry);
1650              if (entry.longval != 2222)
1651                  ERR(&quot;Not 2222, %lld&quot;, entry.longval);
1652              quicklistIndex(ql, 2, &amp;entry);
1653              if (entry.longval != 3333)
1654                  ERR(&quot;Not 3333, %lld&quot;, entry.longval);
1655              quicklistIndex(ql, 3, &amp;entry);
1656              if (entry.longval != 4444)
1657                  ERR(&quot;Not 4444, %lld&quot;, entry.longval);
1658              if (quicklistIndex(ql, 4, &amp;entry))
1659                  ERR(&quot;Index past elements: %lld&quot;, entry.longval);
1660              quicklistIndex(ql, -1, &amp;entry);
1661              if (entry.longval != 4444)
1662                  ERR(&quot;Not 4444 (reverse), %lld&quot;, entry.longval);
1663              quicklistIndex(ql, -2, &amp;entry);
1664              if (entry.longval != 3333)
1665                  ERR(&quot;Not 3333 (reverse), %lld&quot;, entry.longval);
1666              quicklistIndex(ql, -3, &amp;entry);
1667              if (entry.longval != 2222)
1668                  ERR(&quot;Not 2222 (reverse), %lld&quot;, entry.longval);
1669              quicklistIndex(ql, -4, &amp;entry);
1670              if (entry.longval != 1111)
1671                  ERR(&quot;Not 1111 (reverse), %lld&quot;, entry.longval);
1672              if (quicklistIndex(ql, -5, &amp;entry))
1673                  ERR(&quot;Index past elements (reverse), %lld&quot;, entry.longval);
1674              quicklistRelease(ql);
1675          }
1676          TEST(&quot;numbers larger list read&quot;) {
1677              quicklist *ql = quicklistNew(-2, options[_i]);
1678              quicklistSetFill(ql, 32);
1679              char num[32];
1680              PORT_LONGLONG nums[5000];
1681              for (int i = 0; i &lt; 5000; i++) {
1682                  nums[i] = -5157318210846258176 + i;
1683                  int sz = ll2string(num, sizeof(num), nums[i]);
1684                  quicklistPushTail(ql, num, sz);
1685              }
1686              quicklistPushTail(ql, &quot;xxxxxxxxxxxxxxxxxxxx&quot;, 20);
1687              quicklistEntry entry;
1688              for (int i = 0; i &lt; 5000; i++) {
1689                  quicklistIndex(ql, i, &amp;entry);
1690                  if (entry.longval != nums[i])
1691                      ERR(&quot;[%d] Not longval %lld but rather %lld&quot;, i, nums[i],
1692                          entry.longval);
1693                  entry.longval = 0xdeadbeef;
1694              }
1695              quicklistIndex(ql, 5000, &amp;entry);
1696              if (strncmp((char *)entry.value, &quot;xxxxxxxxxxxxxxxxxxxx&quot;, 20))
1697                  ERR(&quot;String val not match: %s&quot;, entry.value);
1698              ql_verify(ql, 157, 5001, 32, 9);
1699              quicklistRelease(ql);
1700          }
1701          TEST(&quot;numbers larger list read B&quot;) {
1702              quicklist *ql = quicklistNew(-2, options[_i]);
1703              quicklistPushTail(ql, &quot;99&quot;, 2);
1704              quicklistPushTail(ql, &quot;98&quot;, 2);
1705              quicklistPushTail(ql, &quot;xxxxxxxxxxxxxxxxxxxx&quot;, 20);
1706              quicklistPushTail(ql, &quot;96&quot;, 2);
1707              quicklistPushTail(ql, &quot;95&quot;, 2);
1708              quicklistReplaceAtIndex(ql, 1, &quot;foo&quot;, 3);
1709              quicklistReplaceAtIndex(ql, -1, &quot;bar&quot;, 3);
1710              quicklistRelease(ql);
1711              OK;
1712          }
1713          for (int f = optimize_start; f &lt; 16; f++) {
1714              TEST_DESC(&quot;lrem test at fill %d at compress %d&quot;, f, options[_i]) {
1715                  quicklist *ql = quicklistNew(f, options[_i]);
1716                  char *words[] = {&quot;abc&quot;, &quot;foo&quot;, &quot;bar&quot;,  &quot;foobar&quot;, &quot;foobared&quot;,
1717                                   &quot;zap&quot;, &quot;bar&quot;, &quot;test&quot;, &quot;foo&quot;};
1718                  char *result[] = {&quot;abc&quot;, &quot;foo&quot;,  &quot;foobar&quot;, &quot;foobared&quot;,
1719                                    &quot;zap&quot;, &quot;test&quot;, &quot;foo&quot;};
1720                  char *resultB[] = {&quot;abc&quot;,      &quot;foo&quot;, &quot;foobar&quot;,
1721                                     &quot;foobared&quot;, &quot;zap&quot;, &quot;test&quot;};
1722                  for (int i = 0; i &lt; 9; i++)
1723                      quicklistPushTail(ql, words[i], strlen(words[i]));
1724                  quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);
1725                  quicklistEntry entry;
1726                  int i = 0;
1727                  while (quicklistNext(iter, &amp;entry)) {
1728                      if (quicklistCompare(entry.zi, (unsigned char *)&quot;bar&quot;, 3)) {
1729                          quicklistDelEntry(iter, &amp;entry);
1730                      }
1731                      i++;
1732                  }
1733                  quicklistReleaseIterator(iter);
1734                  iter = quicklistGetIterator(ql, AL_START_HEAD);
1735                  i = 0;
1736                  int ok = 1;
1737                  while (quicklistNext(iter, &amp;entry)) {
1738                      if (strncmp((char *)entry.value, result[i], entry.sz)) {
1739                          ERR(&quot;No match at position %d, got %.*s instead of %s&quot;,
1740                              i, entry.sz, entry.value, result[i]);
1741                          ok = 0;
1742                      }
1743                      i++;
1744                  }
1745                  quicklistReleaseIterator(iter);
1746                  quicklistPushTail(ql, &quot;foo&quot;, 3);
1747                  iter = quicklistGetIterator(ql, AL_START_TAIL);
1748                  i = 0;
1749                  int del = 2;
1750                  while (quicklistNext(iter, &amp;entry)) {
1751                      if (quicklistCompare(entry.zi, (unsigned char *)&quot;foo&quot;, 3)) {
1752                          quicklistDelEntry(iter, &amp;entry);
1753                          del--;
1754                      }
1755                      if (!del)
1756                          break;
1757                      i++;
1758                  }
1759                  quicklistReleaseIterator(iter);
1760                  iter = quicklistGetIterator(ql, AL_START_TAIL);
1761                  i = 0;
1762                  size_t resB = sizeof(resultB) / sizeof(*resultB);
1763                  while (quicklistNext(iter, &amp;entry)) {
1764                      if (strncmp((char *)entry.value, resultB[resB - 1 - i],
1765                                  entry.sz)) {
1766                          ERR(&quot;No match at position %d, got %.*s instead of %s&quot;,
1767                              i, entry.sz, entry.value, resultB[resB - 1 - i]);
1768                          ok = 0;
1769                      }
1770                      i++;
1771                  }
1772                  quicklistReleaseIterator(iter);
1773                  if (ok)
1774                      OK;
1775                  quicklistRelease(ql);
1776              }
1777          }
1778          for (int f = optimize_start; f &lt; 16; f++) {
1779              TEST_DESC(&quot;iterate reverse + delete at fill %d at compress %d&quot;, f,
1780                        options[_i]) {
1781                  quicklist *ql = quicklistNew(f, options[_i]);
1782                  quicklistPushTail(ql, &quot;abc&quot;, 3);
1783                  quicklistPushTail(ql, &quot;def&quot;, 3);
1784                  quicklistPushTail(ql, &quot;hij&quot;, 3);
1785                  quicklistPushTail(ql, &quot;jkl&quot;, 3);
1786                  quicklistPushTail(ql, &quot;oop&quot;, 3);
1787                  quicklistEntry entry;
1788                  quicklistIter *iter = quicklistGetIterator(ql, AL_START_TAIL);
1789                  int i = 0;
1790                  while (quicklistNext(iter, &amp;entry)) {
1791                      if (quicklistCompare(entry.zi, (unsigned char *)&quot;hij&quot;, 3)) {
1792                          quicklistDelEntry(iter, &amp;entry);
1793                      }
1794                      i++;
1795                  }
1796                  quicklistReleaseIterator(iter);
1797                  if (i != 5)
1798                      ERR(&quot;Didn&#x27;t iterate 5 times, iterated %d times.&quot;, i);
1799                  iter = quicklistGetIterator(ql, AL_START_HEAD);
1800                  i = 0;
1801                  char *vals[] = {&quot;abc&quot;, &quot;def&quot;, &quot;jkl&quot;, &quot;oop&quot;};
1802                  while (quicklistNext(iter, &amp;entry)) {
1803                      if (!quicklistCompare(entry.zi, (unsigned char *)vals[i],
1804                                            3)) {
1805                          ERR(&quot;Value at %d didn&#x27;t match %s\n&quot;, i, vals[i]);
1806                      }
1807                      i++;
1808                  }
1809                  quicklistReleaseIterator(iter);
1810                  quicklistRelease(ql);
1811              }
1812          }
1813          for (int f = optimize_start; f &lt; 800; f++) {
1814              TEST_DESC(&quot;iterator at index test at fill %d at compress %d&quot;, f,
1815                        options[_i]) {
1816                  quicklist *ql = quicklistNew(f, options[_i]);
1817                  char num[32];
1818                  PORT_LONGLONG nums[5000];
1819                  for (int i = 0; i &lt; 760; i++) {
1820                      nums[i] = -5157318210846258176 + i;
1821                      int sz = ll2string(num, sizeof(num), nums[i]);
1822                      quicklistPushTail(ql, num, sz);
1823                  }
1824                  quicklistEntry entry;
1825                  quicklistIter *iter =
1826                      quicklistGetIteratorAtIdx(ql, AL_START_HEAD, 437);
1827                  int i = 437;
1828                  while (quicklistNext(iter, &amp;entry)) {
1829                      if (entry.longval != nums[i])
1830                          ERR(&quot;Expected %lld, but got %lld&quot;, entry.longval,
1831                              nums[i]);
1832                      i++;
1833                  }
1834                  quicklistReleaseIterator(iter);
1835                  quicklistRelease(ql);
1836              }
1837          }
1838          for (int f = optimize_start; f &lt; 40; f++) {
1839              TEST_DESC(&quot;ltrim test A at fill %d at compress %d&quot;, f,
1840                        options[_i]) {
1841                  quicklist *ql = quicklistNew(f, options[_i]);
1842                  char num[32];
1843                  PORT_LONGLONG nums[5000];
1844                  for (int i = 0; i &lt; 32; i++) {
1845                      nums[i] = -5157318210846258176 + i;
1846                      int sz = ll2string(num, sizeof(num), nums[i]);
1847                      quicklistPushTail(ql, num, sz);
1848                  }
1849                  if (f == 32)
1850                      ql_verify(ql, 1, 32, 32, 32);
1851                  quicklistDelRange(ql, 0, 25);
1852                  quicklistDelRange(ql, 0, 0);
1853                  quicklistEntry entry;
1854                  for (int i = 0; i &lt; 7; i++) {
1855                      quicklistIndex(ql, i, &amp;entry);
1856                      if (entry.longval != nums[25 + i])
1857                          ERR(&quot;Deleted invalid range!  Expected %lld but got &quot;
1858                              &quot;%lld&quot;,
1859                              entry.longval, nums[25 + i]);
1860                  }
1861                  if (f == 32)
1862                      ql_verify(ql, 1, 7, 7, 7);
1863                  quicklistRelease(ql);
1864              }
1865          }
1866          for (int f = optimize_start; f &lt; 40; f++) {
1867              TEST_DESC(&quot;ltrim test B at fill %d at compress %d&quot;, f,
1868                        options[_i]) {
1869                  quicklist *ql = quicklistNew(f, QUICKLIST_NOCOMPRESS);
1870                  char num[32];
1871                  PORT_LONGLONG nums[5000];
1872                  for (int i = 0; i &lt; 33; i++) {
1873                      nums[i] = i;
1874                      int sz = ll2string(num, sizeof(num), nums[i]);
1875                      quicklistPushTail(ql, num, sz);
1876                  }
1877                  if (f == 32)
1878                      ql_verify(ql, 2, 33, 32, 1);
1879                  quicklistDelRange(ql, 0, 5);
1880                  quicklistDelRange(ql, -16, 16);
1881                  if (f == 32)
1882                      ql_verify(ql, 1, 12, 12, 12);
1883                  quicklistEntry entry;
1884                  quicklistIndex(ql, 0, &amp;entry);
1885                  if (entry.longval != 5)
1886                      ERR(&quot;A: longval not 5, but %lld&quot;, entry.longval);
1887                  else
1888                      OK;
1889                  quicklistIndex(ql, -1, &amp;entry);
1890                  if (entry.longval != 16)
1891                      ERR(&quot;B! got instead: %lld&quot;, entry.longval);
1892                  else
1893                      OK;
1894                  quicklistPushTail(ql, &quot;bobobob&quot;, 7);
1895                  quicklistIndex(ql, -1, &amp;entry);
1896                  if (strncmp((char *)entry.value, &quot;bobobob&quot;, 7))
1897                      ERR(&quot;Tail doesn&#x27;t match bobobob, it&#x27;s %.*s instead&quot;,
1898                          entry.sz, entry.value);
1899                  for (int i = 0; i &lt; 12; i++) {
1900                      quicklistIndex(ql, i, &amp;entry);
1901                      if (entry.longval != nums[5 + i])
1902                          ERR(&quot;Deleted invalid range!  Expected %lld but got &quot;
1903                              &quot;%lld&quot;,
1904                              entry.longval, nums[5 + i]);
1905                  }
1906                  quicklistRelease(ql);
1907              }
1908          }
1909          for (int f = optimize_start; f &lt; 40; f++) {
1910              TEST_DESC(&quot;ltrim test C at fill %d at compress %d&quot;, f,
1911                        options[_i]) {
1912                  quicklist *ql = quicklistNew(f, options[_i]);
1913                  char num[32];
1914                  PORT_LONGLONG nums[5000];
1915                  for (int i = 0; i &lt; 33; i++) {
1916                      nums[i] = -5157318210846258176 + i;
1917                      int sz = ll2string(num, sizeof(num), nums[i]);
1918                      quicklistPushTail(ql, num, sz);
1919                  }
1920                  if (f == 32)
1921                      ql_verify(ql, 2, 33, 32, 1);
1922                  quicklistDelRange(ql, 0, 3);
1923                  quicklistDelRange(ql, -29,
1924                                    4000); &amp;bsol;* make sure not loop forever */
1925                  if (f == 32)
1926                      ql_verify(ql, 1, 1, 1, 1);
1927                  quicklistEntry entry;
1928                  quicklistIndex(ql, 0, &amp;entry);
1929                  if (entry.longval != -5157318210846258173)
1930                      ERROR;
1931                  else
1932                      OK;
1933                  quicklistRelease(ql);
1934              }
1935          }
1936          for (int f = optimize_start; f &lt; 40; f++) {
1937              TEST_DESC(&quot;ltrim test D at fill %d at compress %d&quot;, f,
1938                        options[_i]) {
1939                  quicklist *ql = quicklistNew(f, options[_i]);
1940                  char num[32];
1941                  PORT_LONGLONG nums[5000];
1942                  for (int i = 0; i &lt; 33; i++) {
1943                      nums[i] = -5157318210846258176 + i;
1944                      int sz = ll2string(num, sizeof(num), nums[i]);
1945                      quicklistPushTail(ql, num, sz);
1946                  }
1947                  if (f == 32)
1948                      ql_verify(ql, 2, 33, 32, 1);
1949                  quicklistDelRange(ql, -12, 3);
1950                  if (ql-&gt;count != 30)
1951                      ERR(&quot;Didn&#x27;t delete exactly three elements!  Count is: %lu&quot;,
1952                          ql-&gt;count);
1953                  quicklistRelease(ql);
1954              }
1955          }
1956          for (int f = optimize_start; f &lt; 72; f++) {
1957              TEST_DESC(&quot;create quicklist from ziplist at fill %d at compress %d&quot;,
1958                        f, options[_i]) {
1959                  unsigned char *zl = ziplistNew();
1960                  PORT_LONGLONG nums[64];
1961                  char num[64];
1962                  for (int i = 0; i &lt; 33; i++) {
1963                      nums[i] = -5157318210846258176 + i;
1964                      int sz = ll2string(num, sizeof(num), nums[i]);
1965                      zl =
1966                          ziplistPush(zl, (unsigned char *)num, sz, ZIPLIST_TAIL);
1967                  }
1968                  for (int i = 0; i &lt; 33; i++) {
1969                      zl = ziplistPush(zl, (unsigned char *)genstr(&quot;hello&quot;, i),
1970                                       32, ZIPLIST_TAIL);
1971                  }
1972                  quicklist *ql = quicklistCreateFromZiplist(f, options[_i], zl);
1973                  if (f == 1)
1974                      ql_verify(ql, 66, 66, 1, 1);
1975                  else if (f == 32)
1976                      ql_verify(ql, 3, 66, 32, 2);
1977                  else if (f == 66)
1978                      ql_verify(ql, 1, 66, 66, 66);
1979                  quicklistRelease(ql);
1980              }
1981          }
1982          PORT_LONGLONG stop = mstime();
1983          runtime[_i] = stop - start;
1984      }
1985      int list_sizes[] = {250, 251, 500, 999, 1000};
1986      PORT_LONGLONG start = mstime();
1987      for (int list = 0; list &lt; (int)(sizeof(list_sizes) / sizeof(*list_sizes));
1988           list++) {
1989          for (int f = optimize_start; f &lt; 128; f++) {
1990              for (int depth = 1; depth &lt; 40; depth++) {
1991                  TEST_DESC(&quot;verify specific compression of interior nodes with &quot;
1992                            &quot;%d list &quot;
1993                            &quot;at fill %d at compress %d&quot;,
1994                            list_sizes[list], f, depth) {
1995                      quicklist *ql = quicklistNew(f, depth);
1996                      for (int i = 0; i &lt; list_sizes[list]; i++) {
1997                          quicklistPushTail(ql, genstr(&quot;hello TAIL&quot;, i + 1), 64);
1998                          quicklistPushHead(ql, genstr(&quot;hello HEAD&quot;, i + 1), 64);
1999                      }
2000                      quicklistNode *node = ql-&gt;head;
2001                      unsigned int low_raw = ql-&gt;compress;
2002                      unsigned int high_raw = ql-&gt;len - ql-&gt;compress;
2003                      for (unsigned int at = 0; at &lt; ql-&gt;len;
2004                           at++, node = node-&gt;next) {
2005                          if (at &lt; low_raw || at &gt;= high_raw) {
2006                              if (node-&gt;encoding != QUICKLIST_NODE_ENCODING_RAW) {
2007                                  ERR(&quot;Incorrect compression: node %d is &quot;
2008                                      &quot;compressed at depth %d ((%u, %u); total &quot;
2009                                      &quot;nodes: %u; size: %u)&quot;,
2010                                      at, depth, low_raw, high_raw, ql-&gt;len,
2011                                      node-&gt;sz);
2012                              }
2013                          } else {
2014                              if (node-&gt;encoding != QUICKLIST_NODE_ENCODING_LZF) {
2015                                  ERR(&quot;Incorrect non-compression: node %d is NOT &quot;
2016                                      &quot;compressed at depth %d ((%u, %u); total &quot;
2017                                      &quot;nodes: %u; size: %u; attempted: %d)&quot;,
2018                                      at, depth, low_raw, high_raw, ql-&gt;len,
2019                                      node-&gt;sz, node-&gt;attempted_compress);
2020                              }
2021                          }
2022                      }
2023                      quicklistRelease(ql);
2024                  }
2025              }
2026          }
2027      }
2028      PORT_LONGLONG stop = mstime();
2029      printf(&quot;\n&quot;);
2030      for (size_t i = 0; i &lt; option_count; i++)
2031          printf(&quot;Test Loop %02d: %0.2f seconds.\n&quot;, options[i],
2032                 (float)runtime[i] / 1000);
2033      printf(&quot;Compressions: %0.2f seconds.\n&quot;, (float)(stop - start) / 1000);
2034      printf(&quot;\n&quot;);
2035      if (!err)
2036          printf(&quot;ALL TESTS PASSED!\n&quot;);
2037      else
2038          ERR(&quot;Sorry, not all tests passed!  In fact, %d tests failed.&quot;, err);
2039      return err;
2040  }
2041  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-quicklist.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-quicklist.c</div>
                </div>
                <div class="column column_space"><pre><code>338              _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) {
339          quicklist-&gt;head-&gt;zl =
340              ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);
341          quicklistNodeUpdateSz(quicklist-&gt;head);
342      } else {
343          quicklistNode *node = quicklistCreateNode();
344          node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
345          quicklistNodeUpdateSz(node);
346          _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);
347      }
348      quicklist-&gt;count++;
349      quicklist-&gt;head-&gt;count++;
350      return (orig_head != quicklist-&gt;head);
351  }
352  int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
</pre></code></div>
                <div class="column column_space"><pre><code>355              _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) {
356          quicklist-&gt;tail-&gt;zl =
357              ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);
358          quicklistNodeUpdateSz(quicklist-&gt;tail);
359      } else {
360          quicklistNode *node = quicklistCreateNode();
361          node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);
362          quicklistNodeUpdateSz(node);
363          _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);
364      }
365      quicklist-&gt;count++;
366      quicklist-&gt;tail-&gt;count++;
367      return (orig_tail != quicklist-&gt;tail);
368  }
369  void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    