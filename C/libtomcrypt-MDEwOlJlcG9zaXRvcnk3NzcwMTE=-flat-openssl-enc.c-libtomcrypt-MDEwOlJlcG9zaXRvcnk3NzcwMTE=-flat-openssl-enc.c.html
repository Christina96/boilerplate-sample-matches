
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-openssl-enc.c</h3>
            <pre><code>1  #include <tomcrypt.h>
2  #ifndef LTC_RIJNDAEL
3  #error Cannot compile this demo; Rijndael (AES) required
4  #endif
5  #ifndef LTC_CBC_MODE
6  #error Cannot compile this demo; CBC mode required
7  #endif
8  #ifndef LTC_PKCS_5
9  #error Cannot compile this demo; PKCS5 required
10  #endif
11  #ifndef LTC_RNG_GET_BYTES
12  #error Cannot compile this demo; random generator required
13  #endif
14  #ifndef LTC_MD5
15  #error Cannot compile this demo; MD5 required
16  #endif
17  #define OPENSSL_ITERATIONS 1
18  #define KEY_LENGTH (256>>3)
19  #define IV_LENGTH (128>>3)
20  #define SALT_LENGTH 8
21  static char salt_header[] = { 'S', 'a', 'l', 't', 'e', 'd', '_', '_' };
22  #include <errno.h>
23  #include <stdio.h>
24  #include <string.h>
25  union paddable {
26     unsigned char unpad[1024];
27     unsigned char pad[1024+MAXBLOCKSIZE];
28  };
29  void barf(const char *pname, const char *err)
30  {
31     printf("Usage: %s <enc|dec> infile outfile passphrase [salt]\n", pname);
32     printf("\n");
33     printf("       # encrypts infile->outfile, random salt\n");
34     printf("       %s enc infile outfile \"passphrase\"\n", pname);
35     printf("\n");
36     printf("       # encrypts infile->outfile, salt from cmdline\n");
37     printf("       %s enc infile outfile pass 0123456789abcdef\n", pname);
38     printf("\n");
39     printf("       # decrypts infile->outfile, pulls salt from infile\n");
40     printf("       %s dec infile outfile pass\n", pname);
41     printf("\n");
42     printf("       # decrypts infile->outfile, salt specified\n");
43     printf("       # (don't try to read the salt from infile)\n");
44     printf("       %s dec infile outfile pass 0123456789abcdef"
45            "\n", pname);
46     printf("\n");
47     printf("Application Error: %s\n", err);
48     if(errno)
49        perror("     System Error");
50     exit(-1);
51  }
52  int parse_hex_salt(unsigned char *in, unsigned char *out)
53  {
54     int idx;
55     for(idx=0; idx<SALT_LENGTH; idx++)
56        if(sscanf((char*)in+idx*2, "%02hhx", out+idx) != 1)
57           return CRYPT_ERROR;
58     return CRYPT_OK;
59  }
60  int parse_openssl_header(FILE *in, unsigned char *out)
61  {
62     unsigned char tmp[SALT_LENGTH];
63     if(fread(tmp, 1, sizeof(tmp), in) != sizeof(tmp))
64        return CRYPT_ERROR;
65     if(memcmp(tmp, salt_header, sizeof(tmp)))
66        return CRYPT_ERROR;
67     if(fread(tmp, 1, sizeof(tmp), in) != sizeof(tmp))
68        return CRYPT_ERROR;
69     memcpy(out, tmp, sizeof(tmp));
70     return CRYPT_OK;
71  }
72  void dump_bytes(unsigned char *in, unsigned long len)
73  {
74     unsigned long idx;
75     for(idx=0; idx<len; idx++)
76        printf("%02hhX", *(in+idx));
77  }
78  static size_t s_pkcs7_pad(union paddable *buf, size_t nb, int block_length,
79                   int is_padding)
80  {
81     unsigned long length;
82     if(is_padding) {
83        length = sizeof(buf->pad);
84        if (padding_pad(buf->pad, nb, &length, block_length) != CRYPT_OK)
85           return 0;
86        return length;
87     } else {
88        length = nb;
89        if (padding_depad(buf->pad, &length, 0) != CRYPT_OK)
90           return 0;
91        return length;
92     }
93  }
94  int do_crypt(FILE *infd, FILE *outfd, unsigned char *key, unsigned char *iv,
95               int encrypt)
96  {
97     union paddable inbuf, outbuf;
98     int cipher, ret;
99     symmetric_CBC cbc;
100     size_t nb;
<span onclick='openModal()' class='match'>101     cipher = register_cipher(&aes_desc);
102     if(cipher == -1)
103        return CRYPT_INVALID_CIPHER;
</span>104     ret = cbc_start(cipher, iv, key, KEY_LENGTH, 0, &cbc);
105     if( ret != CRYPT_OK )
106        return -1;
107     do {
108        nb = fread(inbuf.unpad, 1, sizeof(inbuf.unpad), infd);
109        if(!nb)
110           return encrypt ? CRYPT_OK : CRYPT_ERROR;
111        if(ferror(infd))
112           return CRYPT_ERROR;
113        if(encrypt) {
114           if(feof(infd))
115              nb = s_pkcs7_pad(&inbuf, nb,
116                             aes_desc.block_length, 1);
117           ret = cbc_encrypt(inbuf.pad, outbuf.pad, nb, &cbc);
118           if(ret != CRYPT_OK)
119              return ret;
120        } else {
121           ret = cbc_decrypt(inbuf.unpad, outbuf.unpad, nb, &cbc);
122           if( ret != CRYPT_OK )
123              return ret;
124           if(feof(infd))
125              nb = s_pkcs7_pad(&outbuf, nb,
126                             aes_desc.block_length, 0);
127           if(nb == 0)
128              return CRYPT_ERROR;
129        }
130        if(fwrite(outbuf.unpad, 1, nb, outfd) != nb)
131           return CRYPT_ERROR;
132     } while(!feof(infd));
133     cbc_done(&cbc);
134     return CRYPT_OK;
135  }
136  #define BARF(a) { \
137     if(infd) fclose(infd); \
138     if(outfd) { fclose(outfd); remove(argv[3]); } \
139     barf(argv[0], a); \
140  }
141  int main(int argc, char *argv[]) {
142     unsigned char salt[SALT_LENGTH];
143     FILE *infd = NULL, *outfd = NULL;
144     int encrypt = -1;
145     int hash = -1;
146     int ret;
147     unsigned char keyiv[KEY_LENGTH + IV_LENGTH];
148     unsigned long keyivlen = (KEY_LENGTH + IV_LENGTH);
149     unsigned char *key, *iv;
150     if(argc < 5 || argc > 6)
151        BARF("Invalid number of arguments");
152     if     (!strncmp(argv[1], "enc", 3))
153        encrypt = 1;
154     else if(!strncmp(argv[1], "dec", 3))
155        encrypt = 0;
156     else
157        BARF("Bad command name");
158     infd = fopen(argv[2], "rb");
159     if(infd == NULL)
160        BARF("Could not open infile");
161     outfd = fopen(argv[3], "wb");
162     if(outfd == NULL)
163        BARF("Could not open outfile");
164     if(argc == 6) {
165        if(parse_hex_salt((unsigned char*) argv[5], salt) != CRYPT_OK)
166           BARF("Bad user-specified salt");
167     } else if(!strncmp(argv[1], "enc", 3)) {
168        if(rng_get_bytes(salt, sizeof(salt), NULL) != sizeof(salt))
169           BARF("Not enough random data");
170     } else {
171        if(parse_openssl_header(infd, salt) != CRYPT_OK)
172           BARF("Invalid OpenSSL header in infile");
173     }
174     hash = register_hash(&md5_desc);
175     if(hash == -1)
176        BARF("Could not register MD5 hash");
177     zeromem(keyiv, sizeof(keyiv));
178     key = keyiv + 0;      &bsol;* key comes first */
179     iv = keyiv + KEY_LENGTH;   &bsol;* iv comes next */
180     ret = pkcs_5_alg1_openssl((unsigned char*)argv[4], XSTRLEN(argv[4]), salt,
181                               OPENSSL_ITERATIONS, hash, keyiv, &keyivlen );
182     if(ret != CRYPT_OK)
183        BARF("Could not derive key/iv from passphrase");
184     printf("salt="); dump_bytes(salt, sizeof(salt)); printf("\n");
185     printf("key=");  dump_bytes(key, KEY_LENGTH);    printf("\n");
186     printf("iv =");  dump_bytes(iv,  IV_LENGTH );    printf("\n");
187     if(!strncmp(argv[1], "enc", 3)) {
188        if(fwrite(salt_header, 1, sizeof(salt_header), outfd) !=
189           sizeof(salt_header) )
190           BARF("Error writing salt header to outfile");
191        if(fwrite(salt, 1, sizeof(salt), outfd) != sizeof(salt))
192           BARF("Error writing salt to outfile");
193     }
194     if(do_crypt(infd, outfd, key, iv, encrypt) != CRYPT_OK)
195        BARF("Error during crypt operation");
196     fclose(infd); fclose(outfd);
197     return 0;
198  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-openssl-enc.c</h3>
            <pre><code>1  #include <tomcrypt.h>
2  #ifndef LTC_RIJNDAEL
3  #error Cannot compile this demo; Rijndael (AES) required
4  #endif
5  #ifndef LTC_CBC_MODE
6  #error Cannot compile this demo; CBC mode required
7  #endif
8  #ifndef LTC_PKCS_5
9  #error Cannot compile this demo; PKCS5 required
10  #endif
11  #ifndef LTC_RNG_GET_BYTES
12  #error Cannot compile this demo; random generator required
13  #endif
14  #ifndef LTC_MD5
15  #error Cannot compile this demo; MD5 required
16  #endif
17  #define OPENSSL_ITERATIONS 1
18  #define KEY_LENGTH (256>>3)
19  #define IV_LENGTH (128>>3)
20  #define SALT_LENGTH 8
21  static char salt_header[] = { 'S', 'a', 'l', 't', 'e', 'd', '_', '_' };
22  #include <errno.h>
23  #include <stdio.h>
24  #include <string.h>
25  union paddable {
26     unsigned char unpad[1024];
27     unsigned char pad[1024+MAXBLOCKSIZE];
28  };
29  void barf(const char *pname, const char *err)
30  {
31     printf("Usage: %s <enc|dec> infile outfile passphrase [salt]\n", pname);
32     printf("\n");
33     printf("       # encrypts infile->outfile, random salt\n");
34     printf("       %s enc infile outfile \"passphrase\"\n", pname);
35     printf("\n");
36     printf("       # encrypts infile->outfile, salt from cmdline\n");
37     printf("       %s enc infile outfile pass 0123456789abcdef\n", pname);
38     printf("\n");
39     printf("       # decrypts infile->outfile, pulls salt from infile\n");
40     printf("       %s dec infile outfile pass\n", pname);
41     printf("\n");
42     printf("       # decrypts infile->outfile, salt specified\n");
43     printf("       # (don't try to read the salt from infile)\n");
44     printf("       %s dec infile outfile pass 0123456789abcdef"
45            "\n", pname);
46     printf("\n");
47     printf("Application Error: %s\n", err);
48     if(errno)
49        perror("     System Error");
50     exit(-1);
51  }
52  int parse_hex_salt(unsigned char *in, unsigned char *out)
53  {
54     int idx;
55     for(idx=0; idx<SALT_LENGTH; idx++)
56        if(sscanf((char*)in+idx*2, "%02hhx", out+idx) != 1)
57           return CRYPT_ERROR;
58     return CRYPT_OK;
59  }
60  int parse_openssl_header(FILE *in, unsigned char *out)
61  {
62     unsigned char tmp[SALT_LENGTH];
63     if(fread(tmp, 1, sizeof(tmp), in) != sizeof(tmp))
64        return CRYPT_ERROR;
65     if(memcmp(tmp, salt_header, sizeof(tmp)))
66        return CRYPT_ERROR;
67     if(fread(tmp, 1, sizeof(tmp), in) != sizeof(tmp))
68        return CRYPT_ERROR;
69     memcpy(out, tmp, sizeof(tmp));
70     return CRYPT_OK;
71  }
72  void dump_bytes(unsigned char *in, unsigned long len)
73  {
74     unsigned long idx;
75     for(idx=0; idx<len; idx++)
76        printf("%02hhX", *(in+idx));
77  }
78  static size_t s_pkcs7_pad(union paddable *buf, size_t nb, int block_length,
79                   int is_padding)
80  {
81     unsigned long length;
82     if(is_padding) {
83        length = sizeof(buf->pad);
84        if (padding_pad(buf->pad, nb, &length, block_length) != CRYPT_OK)
85           return 0;
86        return length;
87     } else {
88        length = nb;
89        if (padding_depad(buf->pad, &length, 0) != CRYPT_OK)
90           return 0;
91        return length;
92     }
93  }
94  int do_crypt(FILE *infd, FILE *outfd, unsigned char *key, unsigned char *iv,
95               int encrypt)
96  {
97     union paddable inbuf, outbuf;
98     int cipher, ret;
99     symmetric_CBC cbc;
100     size_t nb;
<span onclick='openModal()' class='match'>101     cipher = register_cipher(&aes_desc);
102     if(cipher == -1)
103        return CRYPT_INVALID_CIPHER;
</span>104     ret = cbc_start(cipher, iv, key, KEY_LENGTH, 0, &cbc);
105     if( ret != CRYPT_OK )
106        return -1;
107     do {
108        nb = fread(inbuf.unpad, 1, sizeof(inbuf.unpad), infd);
109        if(!nb)
110           return encrypt ? CRYPT_OK : CRYPT_ERROR;
111        if(ferror(infd))
112           return CRYPT_ERROR;
113        if(encrypt) {
114           if(feof(infd))
115              nb = s_pkcs7_pad(&inbuf, nb,
116                             aes_desc.block_length, 1);
117           ret = cbc_encrypt(inbuf.pad, outbuf.pad, nb, &cbc);
118           if(ret != CRYPT_OK)
119              return ret;
120        } else {
121           ret = cbc_decrypt(inbuf.unpad, outbuf.unpad, nb, &cbc);
122           if( ret != CRYPT_OK )
123              return ret;
124           if(feof(infd))
125              nb = s_pkcs7_pad(&outbuf, nb,
126                             aes_desc.block_length, 0);
127           if(nb == 0)
128              return CRYPT_ERROR;
129        }
130        if(fwrite(outbuf.unpad, 1, nb, outfd) != nb)
131           return CRYPT_ERROR;
132     } while(!feof(infd));
133     cbc_done(&cbc);
134     return CRYPT_OK;
135  }
136  #define BARF(a) { \
137     if(infd) fclose(infd); \
138     if(outfd) { fclose(outfd); remove(argv[3]); } \
139     barf(argv[0], a); \
140  }
141  int main(int argc, char *argv[]) {
142     unsigned char salt[SALT_LENGTH];
143     FILE *infd = NULL, *outfd = NULL;
144     int encrypt = -1;
145     int hash = -1;
146     int ret;
147     unsigned char keyiv[KEY_LENGTH + IV_LENGTH];
148     unsigned long keyivlen = (KEY_LENGTH + IV_LENGTH);
149     unsigned char *key, *iv;
150     if(argc < 5 || argc > 6)
151        BARF("Invalid number of arguments");
152     if     (!strncmp(argv[1], "enc", 3))
153        encrypt = 1;
154     else if(!strncmp(argv[1], "dec", 3))
155        encrypt = 0;
156     else
157        BARF("Bad command name");
158     infd = fopen(argv[2], "rb");
159     if(infd == NULL)
160        BARF("Could not open infile");
161     outfd = fopen(argv[3], "wb");
162     if(outfd == NULL)
163        BARF("Could not open outfile");
164     if(argc == 6) {
165        if(parse_hex_salt((unsigned char*) argv[5], salt) != CRYPT_OK)
166           BARF("Bad user-specified salt");
167     } else if(!strncmp(argv[1], "enc", 3)) {
168        if(rng_get_bytes(salt, sizeof(salt), NULL) != sizeof(salt))
169           BARF("Not enough random data");
170     } else {
171        if(parse_openssl_header(infd, salt) != CRYPT_OK)
172           BARF("Invalid OpenSSL header in infile");
173     }
174     hash = register_hash(&md5_desc);
175     if(hash == -1)
176        BARF("Could not register MD5 hash");
177     zeromem(keyiv, sizeof(keyiv));
178     key = keyiv + 0;      &bsol;* key comes first */
179     iv = keyiv + KEY_LENGTH;   &bsol;* iv comes next */
180     ret = pkcs_5_alg1_openssl((unsigned char*)argv[4], XSTRLEN(argv[4]), salt,
181                               OPENSSL_ITERATIONS, hash, keyiv, &keyivlen );
182     if(ret != CRYPT_OK)
183        BARF("Could not derive key/iv from passphrase");
184     printf("salt="); dump_bytes(salt, sizeof(salt)); printf("\n");
185     printf("key=");  dump_bytes(key, KEY_LENGTH);    printf("\n");
186     printf("iv =");  dump_bytes(iv,  IV_LENGTH );    printf("\n");
187     if(!strncmp(argv[1], "enc", 3)) {
188        if(fwrite(salt_header, 1, sizeof(salt_header), outfd) !=
189           sizeof(salt_header) )
190           BARF("Error writing salt header to outfile");
191        if(fwrite(salt, 1, sizeof(salt), outfd) != sizeof(salt))
192           BARF("Error writing salt to outfile");
193     }
194     if(do_crypt(infd, outfd, key, iv, encrypt) != CRYPT_OK)
195        BARF("Error during crypt operation");
196     fclose(infd); fclose(outfd);
197     return 0;
198  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-openssl-enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-openssl-enc.c</div>
                </div>
                <div class="column column_space"><pre><code>101     cipher = register_cipher(&aes_desc);
102     if(cipher == -1)
103        return CRYPT_INVALID_CIPHER;
</pre></code></div>
                <div class="column column_space"><pre><code>101     cipher = register_cipher(&aes_desc);
102     if(cipher == -1)
103        return CRYPT_INVALID_CIPHER;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    