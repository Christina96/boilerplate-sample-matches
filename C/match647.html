<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for pmdb2diag.c &amp; imrelp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pmdb2diag.c &amp; imrelp.c
      </h3>
<h1 align="center">
        11.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pmdb2diag.c (28.350515%)<th>imrelp.c (7.4024224%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(254-260)<td><a href="#" name="0">(582-588)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(240-253)<td><a href="#" name="1">(518-533)</a><td align="center"><font color="#e50000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(59-68)<td><a href="#" name="2">(166-175)</a><td align="center"><font color="#d80000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pmdb2diag.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;stdio.h&gt;
4 #include &lt;time.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;ctype.h&gt;
8 #ifdef HAVE_SYS_TIME_H
9 #	include &lt;sys/time.h&gt;
10 #endif
11 #include "rsyslog.h"
12 #include "conf.h"
13 #include "syslogd-types.h"
14 #include "template.h"
15 #include "msg.h"
16 #include "module-template.h"
17 #include "glbl.h"
18 #include "errmsg.h"
19 #include "parser.h"
20 #include "datetime.h"
21 #include "unicode-helper.h"
22 MODULE_TYPE_PARSER
23 MODULE_TYPE_NOKEEP
24 PARSER_NAME("db2.diag")
25 MODULE_CNFNAME("pmdb2diag")
26 DEF_PMOD_STATIC_DATA
27 DEFobjCurrIf(glbl)
28 DEFobjCurrIf(datetime)
29 <a name="2"></a>
30 static struct cnfparamdescr parserpdescr[] = {
31 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "levelpos", eCmdHdlrInt, 0 },
32 	{ "timepos", eCmdHdlrInt, 0 },
33 	{ "timeformat", eCmdHdlrString, 0 },
34 	{ "pidstarttoprogstartshift", eCmdHdlrInt, 0 },
35 };
36 static struct cnfparamblk parserpblk =
37 	{ CNFPARAMBLK_VERSION,
38 	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
39 	  parserpdescr
40 	};</b></font>
41 struct instanceConf_s {
42 	int levelpos; 	int timepos;  	int pidstarttoprogstartshift; 	char *timeformat; 	char sepSec; };
43 BEGINisCompatibleWithFeature
44 CODESTARTisCompatibleWithFeature
45 	if(eFeat == sFEATUREAutomaticPRIParsing)
46 		iRet = RS_RET_OK;
47 ENDisCompatibleWithFeature
48 BEGINparse2
49 	struct tm tm;
50 	char *ms, *timepos, *pid, *prog, *eprog, *backslash, *end, *lvl;
51 	int lprog, lpid, lvl_len;
52 	char buffer[128];
53 CODESTARTparse2
54 	assert(pMsg != NULL);
55 	assert(pMsg-&gt;pszRawMsg != NULL);
56 	DBGPRINTF("Message will now be parsed by \"db2diag\" parser.\n");
57 	if(pMsg-&gt;iLenRawMsg - (int)pMsg-&gt;offAfterPRI &lt; pInst-&gt;levelpos+4)
58 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
59 	lvl = (char*)(pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI + pInst-&gt;levelpos);
60 	switch (*lvl) {
61 	case 'C': 		pMsg-&gt;iSeverity = LOG_EMERG;
62 		lvl_len = 8;
63 		break;
64 	case 'A': 		pMsg-&gt;iSeverity = LOG_ALERT;
65 		lvl_len = 5;
66 		break;
67 	case 'S': 		pMsg-&gt;iSeverity = LOG_CRIT;
68 		lvl_len = 6;
69 		break;
70 	case 'E': 		pMsg-&gt;iSeverity = (lvl[1] == 'r') ? LOG_ERR : LOG_NOTICE;
71 		lvl_len = 5;
72 		break;
73 	case 'W': 		pMsg-&gt;iSeverity = LOG_WARNING;
74 		lvl_len = 7;
75 		break;
76 	case 'I': 		pMsg-&gt;iSeverity = LOG_INFO;
77 		lvl_len = 4;
78 		break;
79 	case 'D': 		pMsg-&gt;iSeverity = LOG_DEBUG;
80 		lvl_len = 5;
81 		break;
82 	default:
83 		ABORT_FINALIZE(0);
84 	}
85 	if(pMsg-&gt;iLenRawMsg - (int)pMsg-&gt;offAfterPRI &lt; pInst-&gt;levelpos+lvl_len)
86 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
87 	DBGPRINTF("db2parse Level %d\n", pMsg-&gt;iSeverity);
88 	end = (char*)pMsg-&gt;pszRawMsg + pMsg-&gt;iLenRawMsg ;
89 	timepos = (char*)pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI + pInst-&gt;timepos;
90 	DBGPRINTF("db2parse Time %.30s\n", timepos);
91 	ms = strptime(timepos, pInst-&gt;timeformat, &amp;tm);
92 	if (ms &gt; timepos &amp;&amp;  *(ms-1) == pInst-&gt;sepSec)
93 	{
94 		int secfrac = 0, tzoff = 0;
95 		char *tzpos = strchr(ms, '+');
96 		if (!tzpos) tzpos = strchr(ms, '-');
97 		if (!tzpos) tzpos = (char*)"+";
98 		sscanf(ms, (*tzpos == '+') ? "%d+%d " : "%d-%d ", &amp;secfrac, &amp;tzoff);
99 		pMsg-&gt;tTIMESTAMP.year = tm.tm_year+1900;
100 		pMsg-&gt;tTIMESTAMP.month = tm.tm_mon + 1;
101 		pMsg-&gt;tTIMESTAMP.day = tm.tm_mday;
102 		pMsg-&gt;tTIMESTAMP.hour = tm.tm_hour;
103 		pMsg-&gt;tTIMESTAMP.minute = tm.tm_min;
104 		pMsg-&gt;tTIMESTAMP.second = tm.tm_sec;
105 		pMsg-&gt;tTIMESTAMP.secfrac = secfrac;
106 		pMsg-&gt;tTIMESTAMP.secfracPrecision = tzpos-ms;
107 		pMsg-&gt;tTIMESTAMP.OffsetMode = *tzpos;
108 		pMsg-&gt;tTIMESTAMP.OffsetHour = tzoff / 60;
109 		pMsg-&gt;tTIMESTAMP.OffsetMinute = tzoff % 60;
110 	}
111 	pid = strchr((char*)pMsg-&gt;pszRawMsg + pInst-&gt;levelpos + lvl_len, ':');
112 	if (!pid || pid&gt;=end) ABORT_FINALIZE(0);
113 	pid += 2;
114 	lpid = strchr(pid, ' ') - pid;
115 	DBGPRINTF("db2parse pid %.*s\n", lpid, pid);
116 	snprintf(buffer, 128, "%.*s", lpid, pid);
117 	MsgSetPROCID(pMsg, buffer);
118 	prog = pid + pInst-&gt;pidstarttoprogstartshift; 	if (prog&gt;=end) ABORT_FINALIZE(0);
119 	eprog = strchr(prog, ' '); 	if (eprog &amp;&amp; eprog&gt;=end) ABORT_FINALIZE(0);
120 	backslash = strchr(prog, '\\'); 	if (!backslash || backslash&gt;=end) backslash = end;
121 	lprog = (eprog &amp;&amp; eprog&lt;backslash) ? eprog-prog : backslash-prog;
122 	DBGPRINTF("db2parse prog %.*s     lprog %d\n", lprog, prog, lprog);
123 	snprintf(buffer, 128, "%.*s", lprog, prog);
124 	MsgSetAPPNAME(pMsg, buffer);
125 finalize_it:
126 ENDparse2
127 BEGINfreeParserInst
128 CODESTARTfreeParserInst
129 	free(pInst-&gt;timeformat);
130 ENDfreeParserInst
131 static rsRetVal
132 createInstance(instanceConf_t **ppInst)
133 {
134 	instanceConf_t *pInst;
135 	DEFiRet;
136 	CHKmalloc(pInst = (instanceConf_t *)malloc(sizeof(instanceConf_t)));
137 	pInst-&gt;timeformat = NULL;
138 	pInst-&gt;levelpos = 59;
139 	pInst-&gt;timepos = 0;
140 	pInst-&gt;pidstarttoprogstartshift = 49;
141 	*ppInst = pInst;
142 finalize_it:
143 	RETiRet;
144 }
145 BEGINnewParserInst
146 	struct cnfparamvals *pvals = NULL;
147 	int i;
148 CODESTARTnewParserInst
149 	inst = NULL;
150 	DBGPRINTF("newParserInst (pmdb2diag)\n");
151 	CHKiRet(createInstance(&amp;inst));
152 <a name="1"></a>
153 	if (lst)
154 	{
155 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		if((pvals = nvlstGetParams(lst, &amp;parserpblk, NULL)) == NULL) {
156 			ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
157 		}
158 		if(Debug) {
159 			DBGPRINTF("parser param blk in pmdb2diag:\n");
160 			cnfparamsPrint(&amp;parserpblk, pvals);
161 		}
162 		for(i = 0 ; i &lt; parserpblk.nParams ; ++i) {
163 			if(!pvals[i].bUsed)
164 <a name="0"></a>				continue;
165 			if(!strcmp(parserpblk.descr[i].name, "timeformat")) {
166 				inst-&gt;timeformat = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
167 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			} else if(!strcmp(parserpblk.descr[i].name, "timepos")) {
168 				inst-&gt;timepos = (int)pvals[i].val.d.n;
169 			} else if(!strcmp(parserpblk.descr[i].name, "levelpos")) {
170 				inst-&gt;levelpos = (int) pvals[i].val.d.n;
171 			} else if(!strcmp(parserpblk.descr[i].name, "pidstarttoprogstartshift")) {
172 				inst-&gt;pidstarttoprogstartshift = (int) pvals[i].val.d.n;
173 			} else {</b></font>
174 				DBGPRINTF("pmdb2diag: program error, non-handled "
175 				  "param '%s'\n", parserpblk.descr[i].name);
176 			}
177 		}
178 	}
179 	if (inst-&gt;timeformat == NULL)
180 	{
181 		inst-&gt;timeformat = strdup("%Y-%m-%d-%H.%M.%S.");
182 		inst-&gt;sepSec = '.';
183 	}else
184 		inst-&gt;sepSec = inst-&gt;timeformat[strlen(inst-&gt;timeformat)-1];
185 	DBGPRINTF("pmdb2diag: parsing date/time with '%s' at position %d and level at position %d.\n",
186 			inst-&gt;timeformat, inst-&gt;timepos, inst-&gt;levelpos);
187 finalize_it:
188 CODE_STD_FINALIZERnewParserInst
189 	if(lst != NULL)
190 		cnfparamvalsDestruct(pvals, &amp;parserpblk);
191 ENDnewParserInst
192 BEGINmodExit
193 CODESTARTmodExit
194 	objRelease(glbl, CORE_COMPONENT);
195 	objRelease(datetime, CORE_COMPONENT);
196 ENDmodExit
197 BEGINqueryEtryPt
198 CODESTARTqueryEtryPt
199 CODEqueryEtryPt_STD_PMOD2_QUERIES
200 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
201 ENDqueryEtryPt
202 BEGINmodInit()
203 CODESTARTmodInit
204 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
205 	CHKiRet(objUse(glbl, CORE_COMPONENT));
206 	CHKiRet(objUse(datetime, CORE_COMPONENT));
207 	DBGPRINTF("pmdb2diag parser init called, compiled with version %s\n", VERSION);
208 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imrelp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;assert.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;errno.h&gt;
6 #include &lt;unistd.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;netinet/in.h&gt;
10 #include &lt;netdb.h&gt;
11 #include &lt;sys/types.h&gt;
12 #include &lt;sys/socket.h&gt;
13 #include &lt;signal.h&gt;
14 #include &lt;librelp.h&gt;
15 #include "rsyslog.h"
16 #include "dirty.h"
17 #include "errmsg.h"
18 #include "cfsysline.h"
19 #include "module-template.h"
20 #include "net.h"
21 #include "msg.h"
22 #include "unicode-helper.h"
23 #include "prop.h"
24 #include "ruleset.h"
25 #include "glbl.h"
26 #include "statsobj.h"
27 #include "srUtils.h"
28 #include "parserif.h"
29 MODULE_TYPE_INPUT
30 MODULE_TYPE_NOKEEP
31 MODULE_CNFNAME("imrelp")
32 DEF_IMOD_STATIC_DATA
33 DEFobjCurrIf(net)
34 DEFobjCurrIf(prop)
35 DEFobjCurrIf(ruleset)
36 DEFobjCurrIf(glbl)
37 DEFobjCurrIf(statsobj)
38 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
39 static relpEngine_t *pRelpEngine;	
40 typedef struct configSettings_s {
41 	uchar *pszBindRuleset;		} configSettings_t;
42 static configSettings_t cs;
43 struct instanceConf_s {
44 	uchar *pszBindPort;			uchar *pszBindAddr;			uchar *pszBindRuleset;			uchar *pszInputName;			prop_t *pInputName;			ruleset_t *pBindRuleset;		sbool bKeepAlive;			sbool bEnableTLS;
45 	sbool bEnableTLSZip;
46 	sbool bEnableLstn;			int dhBits;
47 	size_t maxDataSize;
48 	int oversizeMode;
49 	uchar *pristring;			uchar *authmode;			uchar *caCertFile;
50 	uchar *myCertFile;
51 	uchar *myPrivKeyFile;
52 #if defined(HAVE_RELPENGINESETTLSCFGCMD)
53 	uchar *tlscfgcmd;
54 #endif
55 	int iKeepAliveIntvl;
56 	int iKeepAliveProbes;
57 	int iKeepAliveTime;
58 	flowControl_t flowCtlType;
59 	struct {
60 		int nmemb;
61 		uchar **name;
62 	} permittedPeers;
63 	struct instanceConf_s *next;
64 	struct {
65 		statsobj_t *stats;			STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
66 	} data;
67 };
68 struct modConfData_s {
69 	rsconf_t *pConf;			instanceConf_t *root, *tail;
70 	const char *tlslib;
71 	uchar *pszBindRuleset;		};
72 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
73 static struct cnfparamdescr modpdescr[] = {
74 	{ "ruleset", eCmdHdlrGetWord, 0 },
75 	{ "tls.tlslib", eCmdHdlrString, 0 }
76 };
77 static struct cnfparamblk modpblk =
78 	{ CNFPARAMBLK_VERSION,
79 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
80 	  modpdescr
81 	};
82 static struct cnfparamdescr inppdescr[] = {
83 	{ "port", eCmdHdlrString, CNFPARAM_REQUIRED },
84 	{ "address", eCmdHdlrString, 0 },
85 	{ "name", eCmdHdlrString, 0 },
86 	{ "ruleset", eCmdHdlrString, 0 },
87 	{ "keepalive", eCmdHdlrBinary, 0 },
88 	{ "keepalive.probes", eCmdHdlrInt, 0 },
89 	{ "keepalive.time", eCmdHdlrInt, 0 },
90 	{ "keepalive.interval", eCmdHdlrInt, 0 },
91 	{ "maxdatasize", eCmdHdlrSize, 0 },
92 	{ "oversizemode", eCmdHdlrString, 0 },
93 	{ "flowcontrol", eCmdHdlrGetWord, 0 },
94 	{ "tls", eCmdHdlrBinary, 0 },
95 	{ "tls.permittedpeer", eCmdHdlrArray, 0 },
96 	{ "tls.authmode", eCmdHdlrString, 0 },
97 <a name="2"></a>	{ "tls.dhbits", eCmdHdlrInt, 0 },
98 	{ "tls.prioritystring", eCmdHdlrString, 0 },
99 	{ "tls.cacert", eCmdHdlrString, 0 },
100 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "tls.mycert", eCmdHdlrString, 0 },
101 	{ "tls.myprivkey", eCmdHdlrString, 0 },
102 	{ "tls.tlscfgcmd", eCmdHdlrString, 0 },
103 	{ "tls.compression", eCmdHdlrBinary, 0 }
104 };
105 static struct cnfparamblk inppblk =
106 	{ CNFPARAMBLK_VERSION,
107 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
108 	  inppdescr
109 	};</b></font>
110 #include "im-helper.h" static int bLegacyCnfModGlobalsPermitted;
111 PRAGMA_DIAGNOSTIC_PUSH
112 PRAGMA_IGNORE_Wformat_nonliteral
113 static void __attribute__((format(printf, 1, 2)))
114 imrelp_dbgprintf(const char *fmt, ...)
115 {
116 	va_list ap;
117 	char pszWriteBuf[32*1024+1]; //this function has to be able to
118 	if(!(Debug &amp;&amp; debugging_on)) {
119 		return;
120 	}
121 	va_start(ap, fmt);
122 	vsnprintf(pszWriteBuf, sizeof(pszWriteBuf), fmt, ap);
123 	va_end(ap);
124 	r_dbgprintf("imrelp.c", "%s", pszWriteBuf);
125 }
126 PRAGMA_DIAGNOSTIC_POP
127 static void
128 onErr(void *pUsr, char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
129 {
130 	instanceConf_t *inst = (instanceConf_t*) pUsr;
131 	LogError(0, RS_RET_RELP_AUTH_FAIL, "imrelp[%s]: error '%s', object "
132 			" '%s' - input may not work as intended",
133 			inst-&gt;pszBindPort, errmesg, objinfo);
134 }
135 static void
136 onGenericErr(char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
137 {
138 	LogError(0, RS_RET_RELP_ERR, "imrelp: librelp error '%s', object "
139 			" '%s' - input may not work as intended", errmesg, objinfo);
140 }
141 static void
142 onAuthErr(void *pUsr, char *authinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
143 {
144 	instanceConf_t *inst = (instanceConf_t*) pUsr;
145 	LogError(0, RS_RET_RELP_AUTH_FAIL, "imrelp[%s]: authentication error '%s', peer "
146 			"is '%s'", inst-&gt;pszBindPort, errmesg, authinfo);
147 }
148 static relpRetVal
149 onSyslogRcv(void *pUsr, uchar *pHostname, uchar *pIP, uchar *msg, size_t lenMsg)
150 {
151 	prop_t *pProp = NULL;
152 	smsg_t *pMsg;
153 	instanceConf_t *inst = (instanceConf_t*) pUsr;
154 	DEFiRet;
155 	CHKiRet(msgConstruct(&amp;pMsg));
156 	MsgSetInputName(pMsg, inst-&gt;pInputName);
157 	MsgSetRawMsg(pMsg, (char*)msg, lenMsg);
158 	MsgSetFlowControlType(pMsg, inst-&gt;flowCtlType);
159 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
160 	pMsg-&gt;msgFlags  = PARSE_HOSTNAME | NEEDS_PARSING;
161 	MsgSetRcvFromStr(pMsg, pHostname, ustrlen(pHostname), &amp;pProp);
162 	CHKiRet(prop.Destruct(&amp;pProp));
163 	CHKiRet(MsgSetRcvFromIPStr(pMsg, pIP, ustrlen(pIP), &amp;pProp));
164 	CHKiRet(prop.Destruct(&amp;pProp));
165 	CHKiRet(submitMsg2(pMsg));
166 	STATSCOUNTER_INC(inst-&gt;data.ctrSubmit, inst-&gt;data.mutCtrSubmit);
167 finalize_it:
168 	RETiRet;
169 }
170 static rsRetVal
171 createInstance(instanceConf_t **pinst)
172 {
173 	instanceConf_t *inst;
174 	DEFiRet;
175 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
176 	inst-&gt;next = NULL;
177 	inst-&gt;pszBindPort = NULL;
178 	inst-&gt;pszBindAddr = NULL;
179 	inst-&gt;pszBindRuleset = NULL;
180 	inst-&gt;pszInputName = NULL;
181 	inst-&gt;pBindRuleset = NULL;
182 	inst-&gt;bKeepAlive = 0;
183 	inst-&gt;iKeepAliveIntvl = 0;
184 	inst-&gt;iKeepAliveProbes = 0;
185 	inst-&gt;iKeepAliveTime = 0;
186 	inst-&gt;bEnableTLS = 0;
187 	inst-&gt;bEnableTLSZip = 0;
188 	inst-&gt;bEnableLstn = 0;
189 	inst-&gt;dhBits = 0;
190 	inst-&gt;pristring = NULL;
191 	inst-&gt;authmode = NULL;
192 	inst-&gt;permittedPeers.nmemb = 0;
193 	inst-&gt;caCertFile = NULL;
194 	inst-&gt;myCertFile = NULL;
195 	inst-&gt;myPrivKeyFile = NULL;
196 #if defined(HAVE_RELPENGINESETTLSCFGCMD)
197 	inst-&gt;tlscfgcmd = NULL;
198 #endif
199 	inst-&gt;maxDataSize = 0;
200 	inst-&gt;flowCtlType = eFLOWCTL_LIGHT_DELAY;
201 #ifdef HAVE_RELPSRVSETOVERSIZEMODE
202 	inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
203 #endif
204 	if(loadModConf-&gt;tail == NULL) {
205 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
206 	} else {
207 		loadModConf-&gt;tail-&gt;next = inst;
208 		loadModConf-&gt;tail = inst;
209 	}
210 	*pinst = inst;
211 finalize_it:
212 	RETiRet;
213 }
214 static inline void
215 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
216 {
217 	LogError(0, NO_ERRCODE, "imrelp[%s]: ruleset '%s' not found - "
218 			"using default ruleset instead",
219 			inst-&gt;pszBindPort, inst-&gt;pszBindRuleset);
220 }
221 static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
222 {
223 	instanceConf_t *inst;
224 	DEFiRet;
225 	CHKiRet(createInstance(&amp;inst));
226 	if(pNewVal == NULL || *pNewVal == '\0') {
227 		LogError(0, NO_ERRCODE, "imrelp: port number must be specified, listener ignored");
228 	}
229 	if((pNewVal == NULL) || (*pNewVal == '\0')) {
230 		inst-&gt;pszBindPort = NULL;
231 	} else {
232 		CHKmalloc(inst-&gt;pszBindPort = ustrdup(pNewVal));
233 	}
234 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
235 		inst-&gt;pszBindRuleset = NULL;
236 	} else {
237 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
238 	}
239 	inst-&gt;pBindRuleset = NULL;
240 	inst-&gt;bEnableLstn = -1; finalize_it:
241 	free(pNewVal);
242 	RETiRet;
243 }
244 static rsRetVal
245 addListner(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
246 {
247 	relpSrv_t *pSrv;
248 	int relpRet;
249 	uchar statname[64];
250 	int i;
251 	DEFiRet;
252 	if(!inst-&gt;bEnableLstn) {
253 		DBGPRINTF("listener not started because it is disabled by config error\n");
254 		FINALIZE;
255 	}
256 	if(pRelpEngine == NULL) {
257 		CHKiRet(relpEngineConstruct(&amp;pRelpEngine));
258 		CHKiRet(relpEngineSetDbgprint(pRelpEngine, (void (*)(char *, ...))imrelp_dbgprintf));
259 		CHKiRet(relpEngineSetFamily(pRelpEngine, glbl.GetDefPFFamily(runModConf-&gt;pConf)));
260 		CHKiRet(relpEngineSetEnableCmd(pRelpEngine, (uchar*) "syslog", eRelpCmdState_Required));
261 		CHKiRet(relpEngineSetSyslogRcv2(pRelpEngine, onSyslogRcv));
262 		CHKiRet(relpEngineSetOnErr(pRelpEngine, onErr));
263 		CHKiRet(relpEngineSetOnGenericErr(pRelpEngine, onGenericErr));
264 		CHKiRet(relpEngineSetOnAuthErr(pRelpEngine, onAuthErr));
265 		if (!glbl.GetDisableDNS(runModConf-&gt;pConf)) {
266 			CHKiRet(relpEngineSetDnsLookupMode(pRelpEngine, 1));
267 		}
268 		#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
269 			if(modConf-&gt;tlslib != NULL) {
270 				if(relpEngineSetTLSLibByName(pRelpEngine, modConf-&gt;tlslib) != RELP_RET_OK) {
271 					LogMsg(0, RS_RET_CONF_PARAM_INVLD, LOG_WARNING,
272 						"imrelp: tlslib '%s' not accepted as valid by librelp - using default",
273 						modConf-&gt;tlslib);
274 				}
275 			}
276 		#endif
277 	}
278 	CHKiRet(relpEngineListnerConstruct(pRelpEngine, &amp;pSrv));
279 	CHKiRet(relpSrvSetMaxDataSize(pSrv, inst-&gt;maxDataSize));
280 	CHKiRet(relpSrvSetLstnPort(pSrv, inst-&gt;pszBindPort));
281 	#if defined(HAVE_RELPSRVSETLSTNADDR)
282 		CHKiRet(relpSrvSetLstnAddr(pSrv, inst-&gt;pszBindAddr));
283 	#endif
284 #ifdef HAVE_RELPSRVSETOVERSIZEMODE
285 	CHKiRet(relpSrvSetOversizeMode(pSrv, inst-&gt;oversizeMode));
286 #endif
287 	inst-&gt;pszInputName = ustrdup((inst-&gt;pszInputName == NULL) ?  UCHAR_CONSTANT("imrelp") : inst-&gt;pszInputName);
288 	CHKiRet(prop.Construct(&amp;inst-&gt;pInputName));
289 	CHKiRet(prop.SetString(inst-&gt;pInputName, inst-&gt;pszInputName, ustrlen(inst-&gt;pszInputName)));
290 	CHKiRet(prop.ConstructFinalize(inst-&gt;pInputName));
291 	CHKiRet(statsobj.Construct(&amp;(inst-&gt;data.stats)));
292 	snprintf((char*)statname, sizeof(statname), "%s(%s)",
293 		 inst-&gt;pszInputName, inst-&gt;pszBindPort);
294 	statname[sizeof(statname)-1] = '\0'; 	CHKiRet(statsobj.SetName(inst-&gt;data.stats, statname));
295 	CHKiRet(statsobj.SetOrigin(inst-&gt;data.stats, (uchar*)"imrelp"));
296 	STATSCOUNTER_INIT(inst-&gt;data.ctrSubmit, inst-&gt;data.mutCtrSubmit);
297 	CHKiRet(statsobj.AddCounter(inst-&gt;data.stats, UCHAR_CONSTANT("submitted"),
298 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(inst-&gt;data.ctrSubmit)));
299 	CHKiRet(statsobj.ConstructFinalize(inst-&gt;data.stats));
300 	relpSrvSetUsrPtr(pSrv, inst);
301 	relpSrvSetKeepAlive(pSrv, inst-&gt;bKeepAlive, inst-&gt;iKeepAliveIntvl,
302 			    inst-&gt;iKeepAliveProbes, inst-&gt;iKeepAliveTime);
303 	if(inst-&gt;bEnableTLS) {
304 		relpRet = relpSrvEnableTLS2(pSrv);
305 		if(relpRet == RELP_RET_ERR_NO_TLS) {
306 			LogError(0, RS_RET_RELP_NO_TLS,
307 					"imrelp: could not activate relp TLS, librelp "
308 					"does not support it (most probably GnuTLS lib "
309 					"is too old)!");
310 			ABORT_FINALIZE(RS_RET_RELP_NO_TLS);
311 		} else if(relpRet == RELP_RET_ERR_NO_TLS_AUTH) {
312 			LogError(0, RS_RET_RELP_NO_TLS_AUTH,
313 					"imrelp: could not activate relp TLS with "
314 					"authentication, librelp does not support it "
315 					"(most probably GnuTLS lib is too old)! "
316 					"Note: anonymous TLS is probably supported.");
317 			ABORT_FINALIZE(RS_RET_RELP_NO_TLS_AUTH);
318 		} else if(relpRet != RELP_RET_OK) {
319 			LogError(0, RS_RET_RELP_ERR,
320 					"imrelp: could not activate relp TLS, code %d", relpRet);
321 			ABORT_FINALIZE(RS_RET_RELP_ERR);
322 		}
323 		if(inst-&gt;bEnableTLSZip) {
324 			relpSrvEnableTLSZip2(pSrv);
325 		}
326 		if(inst-&gt;dhBits) {
327 			relpSrvSetDHBits(pSrv, inst-&gt;dhBits);
328 		}
329 		relpSrvSetGnuTLSPriString(pSrv, (char*)inst-&gt;pristring);
330 		if(relpSrvSetAuthMode(pSrv, (char*)inst-&gt;authmode) != RELP_RET_OK) {
331 			LogError(0, RS_RET_RELP_ERR,
332 					"imrelp: invalid auth mode '%s'", inst-&gt;authmode);
333 			ABORT_FINALIZE(RS_RET_RELP_ERR);
334 		}
335 		if(relpSrvSetCACert(pSrv, (char*) inst-&gt;caCertFile) != RELP_RET_OK)
336 			ABORT_FINALIZE(RS_RET_RELP_ERR);
337 		if(relpSrvSetOwnCert(pSrv, (char*) inst-&gt;myCertFile) != RELP_RET_OK)
338 			ABORT_FINALIZE(RS_RET_RELP_ERR);
339 		if(relpSrvSetPrivKey(pSrv, (char*) inst-&gt;myPrivKeyFile) != RELP_RET_OK)
340 			ABORT_FINALIZE(RS_RET_RELP_ERR);
341 #if defined(HAVE_RELPENGINESETTLSCFGCMD)
342 		if (inst-&gt;tlscfgcmd != NULL) {
343 			if(relpSrvSetTlsConfigCmd(pSrv, (char*) inst-&gt;tlscfgcmd) != RELP_RET_OK)
344 				ABORT_FINALIZE(RS_RET_RELP_ERR);
345 		}
346 #endif
347 		for(i = 0 ; i &lt;  inst-&gt;permittedPeers.nmemb ; ++i) {
348 			relpSrvAddPermittedPeer(pSrv, (char*)inst-&gt;permittedPeers.name[i]);
349 		}
350 	}
351 	relpRet = relpEngineListnerConstructFinalize(pRelpEngine, pSrv);
352 	if(relpRet == RELP_RET_ERR_NO_TLS) {
353 		LogError(0, RS_RET_RELP_NO_TLS,
354 				"imrelp: could not activate relp TLS listener, librelp "
355 				"does not support it (most probably GnuTLS lib "
356 				"is too old)!");
357 		ABORT_FINALIZE(RS_RET_RELP_NO_TLS);
358 	} else if(relpRet == RELP_RET_ERR_NO_TLS_AUTH) {
359 		LogError(0, RS_RET_RELP_NO_TLS_AUTH,
360 				"imrelp: could not activate relp TLS listener with "
361 				"authentication, librelp does not support it "
362 				"(most probably GnuTLS lib is too old)! "
363 				"Note: anonymous TLS is probably supported.");
364 		ABORT_FINALIZE(RS_RET_RELP_NO_TLS_AUTH);
365 	} else if(relpRet != RELP_RET_OK) {
366 		LogError(0, RS_RET_RELP_ERR,
367 				"imrelp: could not activate relp listener, code %d", relpRet);
368 		ABORT_FINALIZE(RS_RET_RELP_ERR);
369 	}
370 	DBGPRINTF("imrelp: max data size %zd\n", inst-&gt;maxDataSize);
371 	resetConfigVariables(NULL,NULL);
372 finalize_it:
373 	RETiRet;
374 }
375 BEGINnewInpInst
376 	struct cnfparamvals *pvals;
377 	instanceConf_t *inst = NULL;
378 	int i,j;
379 	FILE *fp;
380 <a name="1"></a>CODESTARTnewInpInst
381 	DBGPRINTF("newInpInst (imrelp)\n");
382 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
383 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
384 	}
385 	if(Debug) {
386 		dbgprintf("input param blk in imrelp:\n");
387 		cnfparamsPrint(&amp;inppblk, pvals);
388 	}
389 	CHKiRet(createInstance(&amp;inst));
390 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
391 		if(!pvals[i].bUsed)
392 			continue;
393 		if(!strcmp(inppblk.descr[i].name, "port")) {
394 			inst-&gt;pszBindPort = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
395 		} else if(!strcmp(inppblk.descr[i].name, "address")) {
396 			#if defined(HAVE_RELPSRVSETLSTNADDR)
397 				inst-&gt;pszBindAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
398 			#else
399 				parser_errmsg("imrelp: librelp does not support input parameter 'address'; "
400 					"it probably is too old (1.2.16 should be fine); ignoring setting now, "
401 					"listening on all interfaces");
402 			#endif
403 		} else if(!strcmp(inppblk.descr[i].name, "name")) {
404 			inst-&gt;pszInputName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
405 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
406 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
407 		} else if(!strcmp(inppblk.descr[i].name, "maxdatasize")) {
408 			inst-&gt;maxDataSize = (size_t) pvals[i].val.d.n;
409 		} else if(!strcmp(inppblk.descr[i].name, "flowcontrol")) {
410 			if(!es_strconstcmp(pvals[i].val.d.estr, "none")) {
411 				inst-&gt;flowCtlType = eFLOWCTL_NO_DELAY;
412 			} else if(!es_strconstcmp(pvals[i].val.d.estr, "light")) {
413 				inst-&gt;flowCtlType = eFLOWCTL_LIGHT_DELAY;
414 			} else if(!es_strconstcmp(pvals[i].val.d.estr, "full")) {
415 				inst-&gt;flowCtlType = eFLOWCTL_FULL_DELAY;
416 			} else {
417 				const char *const mode = es_str2cstr(pvals[i].val.d.estr, NULL);
418 				parser_errmsg("imrelp: wrong flowcontrol parameter "
419 					"value '%s', using default: 'light'; possible "
420 					"values: 'no', 'light', 'full'\n", mode);
421 				free((void*)mode);
422 			}
423 		} else if(!strcmp(inppblk.descr[i].name, "oversizemode")) {
424 #ifdef HAVE_RELPSRVSETOVERSIZEMODE
425 			char *mode = es_str2cstr(pvals[i].val.d.estr, NULL);
426 			if(!strcmp(mode, "abort")) {
427 				inst-&gt;oversizeMode = RELP_OVERSIZE_ABORT;
428 			} else if(!strcmp(mode, "truncate")) {
429 				inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
430 			} else if(!strcmp(mode, "accept")) {
431 				inst-&gt;oversizeMode = RELP_OVERSIZE_ACCEPT;
432 			} else {
433 				parser_errmsg("imrelp: wrong oversizeMode parameter "
434 					"value %s, using default: truncate\n", mode);
435 				inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
436 			}
437 #else
438 			parser_errmsg("imrelp: parameter oversizeMode is not available in "
439 				"this relp version and is therefore disabled.");
440 <a name="0"></a>#endif
441 		} else if(!strcmp(inppblk.descr[i].name, "keepalive")) {
442 			inst-&gt;bKeepAlive = (sbool) pvals[i].val.d.n;
443 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "keepalive.probes")) {
444 			inst-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
445 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.time")) {
446 			inst-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
447 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.interval")) {
448 			inst-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
449 		} else if(!strcmp(inppblk.descr[i].name, "tls")) {</b></font>
450 			inst-&gt;bEnableTLS = (unsigned) pvals[i].val.d.n;
451 		} else if(!strcmp(inppblk.descr[i].name, "tls.dhbits")) {
452 			inst-&gt;dhBits = (unsigned) pvals[i].val.d.n;
453 		} else if(!strcmp(inppblk.descr[i].name, "tls.prioritystring")) {
454 			inst-&gt;pristring = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
455 		} else if(!strcmp(inppblk.descr[i].name, "tls.authmode")) {
456 			inst-&gt;authmode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
457 		} else if(!strcmp(inppblk.descr[i].name, "tls.compression")) {
458 			inst-&gt;bEnableTLSZip = (unsigned) pvals[i].val.d.n;
459 		} else if(!strcmp(inppblk.descr[i].name, "tls.cacert")) {
460 			inst-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
461 			fp = fopen((const char*)inst-&gt;caCertFile, "r");
462 			if(fp == NULL) {
463 				char errStr[1024];
464 				rs_strerror_r(errno, errStr, sizeof(errStr));
465 				LogError(0, RS_RET_NO_FILE_ACCESS,
466 				"error: certificate file %s couldn't be accessed: %s\n",
467 				inst-&gt;caCertFile, errStr);
468 			} else {
469 				fclose(fp);
470 			}
471 		} else if(!strcmp(inppblk.descr[i].name, "tls.mycert")) {
472 			inst-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
473 			fp = fopen((const char*)inst-&gt;myCertFile, "r");
474 			if(fp == NULL) {
475 				char errStr[1024];
476 				rs_strerror_r(errno, errStr, sizeof(errStr));
477 				LogError(0, RS_RET_NO_FILE_ACCESS,
478 				"error: certificate file %s couldn't be accessed: %s\n",
479 				inst-&gt;myCertFile, errStr);
480 			} else {
481 				fclose(fp);
482 			}
483 		} else if(!strcmp(inppblk.descr[i].name, "tls.myprivkey")) {
484 			inst-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
485 			fp = fopen((const char*)inst-&gt;myPrivKeyFile, "r");
486 			if(fp == NULL) {
487 				char errStr[1024];
488 				rs_strerror_r(errno, errStr, sizeof(errStr));
489 				LogError(0, RS_RET_NO_FILE_ACCESS,
490 				"error: certificate file %s couldn't be accessed: %s\n",
491 				inst-&gt;myPrivKeyFile, errStr);
492 			} else {
493 				fclose(fp);
494 			}
495 		} else if(!strcmp(inppblk.descr[i].name, "tls.tlscfgcmd")) {
496 #if defined(HAVE_RELPENGINESETTLSCFGCMD)
497 			inst-&gt;tlscfgcmd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
498 #else
499 			parser_errmsg("imrelp: librelp does not support input parameter 'tls.tlscfgcmd'; "
500 				"it probably is too old (1.5.0 or higher should be fine); ignoring setting now.");
501 #endif
502 		} else if(!strcmp(inppblk.descr[i].name, "tls.permittedpeer")) {
503 			inst-&gt;permittedPeers.nmemb = pvals[i].val.d.ar-&gt;nmemb;
504 			CHKmalloc(inst-&gt;permittedPeers.name =
505 				malloc(sizeof(uchar*) * inst-&gt;permittedPeers.nmemb));
506 			for(j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
507 				inst-&gt;permittedPeers.name[j] = (uchar*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
508 			}
509 		} else {
510 			dbgprintf("imrelp: program error, non-handled "
511 			  "param '%s'\n", inppblk.descr[i].name);
512 		}
513 	}
514 	if(inst-&gt;myCertFile  != NULL &amp;&amp; inst-&gt;myPrivKeyFile == NULL) {
515 		LogError(0, RS_RET_ERR, "imrelp: certificate file given but no corresponding "
516 			"private key file - this is invalid, listener cannot be started");
517 		ABORT_FINALIZE(RS_RET_ERR);
518 	}
519 	if(inst-&gt;myCertFile  == NULL &amp;&amp; inst-&gt;myPrivKeyFile != NULL) {
520 		LogError(0, RS_RET_ERR, "imrelp: private key file given but no corresponding "
521 			"certificate file - this is invalid, listener cannot be started");
522 		ABORT_FINALIZE(RS_RET_ERR);
523 	}
524 	inst-&gt;bEnableLstn = -1; 
525 finalize_it:
526 CODE_STD_FINALIZERnewInpInst
527 	cnfparamvalsDestruct(pvals, &amp;inppblk);
528 	if(iRet != RS_RET_OK) {
529 		if(inst != NULL) {
530 			free(inst-&gt;myCertFile);
531 			inst-&gt;myCertFile = NULL;
532 			free(inst-&gt;myPrivKeyFile);
533 			inst-&gt;myPrivKeyFile = NULL;
534 		}
535 	}
536 ENDnewInpInst
537 BEGINbeginCnfLoad
538 CODESTARTbeginCnfLoad
539 	loadModConf = pModConf;
540 	pModConf-&gt;pConf = pConf;
541 	pModConf-&gt;pszBindRuleset = NULL;
542 	pModConf-&gt;tlslib = NULL;
543 	cs.pszBindRuleset = NULL;
544 	bLegacyCnfModGlobalsPermitted = 1;
545 ENDbeginCnfLoad
546 BEGINsetModCnf
547 	struct cnfparamvals *pvals = NULL;
548 	int i;
549 CODESTARTsetModCnf
550 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
551 	if(pvals == NULL) {
552 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
553 				"config parameters [module(...)]");
554 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
555 	}
556 	if(Debug) {
557 		dbgprintf("module (global) param blk for imrelp:\n");
558 		cnfparamsPrint(&amp;modpblk, pvals);
559 	}
560 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
561 		if(!pvals[i].bUsed)
562 			continue;
563 		if(!strcmp(modpblk.descr[i].name, "ruleset")) {
564 			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
565 		} else if(!strcmp(modpblk.descr[i].name, "tls.tlslib")) {
566 			#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
567 				loadModConf-&gt;tlslib = es_str2cstr(pvals[i].val.d.estr, NULL);
568 			#else
569 				LogError(0, RS_RET_NOT_IMPLEMENTED,
570 					"imrelp warning: parameter tls.tlslib ignored - librelp does not support "
571 					"this API call. Using whatever librelp was compiled with.");
572 			#endif
573 		} else {
574 			dbgprintf("imrelp: program error, non-handled "
575 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
576 		}
577 	}
578 	bLegacyCnfModGlobalsPermitted = 0;
579 finalize_it:
580 	if(pvals != NULL)
581 		cnfparamvalsDestruct(pvals, &amp;modpblk);
582 ENDsetModCnf
583 BEGINendCnfLoad
584 CODESTARTendCnfLoad
585 	if(loadModConf-&gt;pszBindRuleset == NULL) {
586 		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
587 			loadModConf-&gt;pszBindRuleset = NULL;
588 		} else {
589 			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
590 		}
591 	} else {
592 		if((cs.pszBindRuleset != NULL) &amp;&amp; (cs.pszBindRuleset[0] != '\0')) {
593 			LogError(0, RS_RET_DUP_PARAM, "imrelp: ruleset "
594 					"set via legacy directive ignored");
595 		}
596 	}
597 finalize_it:
598 	free(cs.pszBindRuleset);
599 	cs.pszBindRuleset = NULL;
600 	loadModConf = NULL; ENDendCnfLoad
601 BEGINcheckCnf
602 	instanceConf_t *inst;
603 	size_t maxMessageSize;
604 CODESTARTcheckCnf
605 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
606 		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
607 			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
608 		}
609 		std_checkRuleset(pModConf, inst);
610 		if(inst-&gt;maxDataSize == 0) {
611 			inst-&gt;maxDataSize = glbl.GetMaxLine(loadConf);
612 		}
613 		maxMessageSize = (size_t)glbl.GetMaxLine(loadConf);
614 		if(inst-&gt;maxDataSize &lt; maxMessageSize) {
615 			LogError(0, RS_RET_INVALID_PARAMS, "error: "
616 					"maxDataSize (%zu) is smaller than global parameter "
617 					"maxMessageSize (%zu) - global parameter will be used.",
618 					inst-&gt;maxDataSize, maxMessageSize);
619 			inst-&gt;maxDataSize = maxMessageSize;
620 		}
621 	}
622 finalize_it:
623 ENDcheckCnf
624 BEGINactivateCnfPrePrivDrop
625 	instanceConf_t *inst;
626 CODESTARTactivateCnfPrePrivDrop
627 	runModConf = pModConf;
628 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
629 		addListner(pModConf, inst);
630 	}
631 	if(pRelpEngine == NULL) {
632 		LogError(0, RS_RET_NO_LSTN_DEFINED, "imrelp: no RELP listener defined, module can not run.");
633 		ABORT_FINALIZE(RS_RET_NO_RUN);
634 	}
635 finalize_it:
636 ENDactivateCnfPrePrivDrop
637 BEGINactivateCnf
638 CODESTARTactivateCnf
639 ENDactivateCnf
640 BEGINfreeCnf
641 	instanceConf_t *inst, *del;
642 	int i;
643 CODESTARTfreeCnf
644 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
645 		free(inst-&gt;pszBindPort);
646 		if (inst-&gt;pszBindAddr != NULL) {
647 			free(inst-&gt;pszBindAddr);
648 		}
649 		free(inst-&gt;pszBindRuleset);
650 		free(inst-&gt;pszInputName);
651 		free(inst-&gt;pristring);
652 		free(inst-&gt;authmode);
653 		for(i = 0 ; i &lt;  inst-&gt;permittedPeers.nmemb ; ++i) {
654 			free(inst-&gt;permittedPeers.name[i]);
655 		}
656 		if(inst-&gt;bEnableLstn) {
657 			prop.Destruct(&amp;inst-&gt;pInputName);
658 			statsobj.Destruct(&amp;(inst-&gt;data.stats));
659 		}
660 		del = inst;
661 		inst = inst-&gt;next;
662 		free(del);
663 	}
664 	free(pModConf-&gt;pszBindRuleset);
665 ENDfreeCnf
666 static void
667 doSIGTTIN(int __attribute__((unused)) sig)
668 {
669 	const int bTerminate = ATOMIC_FETCH_32BIT(&amp;bTerminateInputs, &amp;mutTerminateInputs);
670 	if(bTerminate) {
671 		relpEngineSetStop(pRelpEngine);
672 	}
673 }
674 BEGINrunInput
675 	sigset_t sigSet;
676 	struct sigaction sigAct;
677 CODESTARTrunInput
678 	sigfillset(&amp;sigSet);
679 	pthread_sigmask(SIG_BLOCK, &amp;sigSet, NULL);
680 	sigemptyset(&amp;sigSet);
681 	sigaddset(&amp;sigSet, SIGTTIN);
682 	pthread_sigmask(SIG_UNBLOCK, &amp;sigSet, NULL);
683 	memset(&amp;sigAct, 0, sizeof (sigAct));
684 	sigemptyset(&amp;sigAct.sa_mask);
685 	sigAct.sa_handler = doSIGTTIN;
686 	sigaction(SIGTTIN, &amp;sigAct, NULL);
687 	iRet = relpEngineRun(pRelpEngine);
688 ENDrunInput
689 BEGINwillRun
690 CODESTARTwillRun
691 ENDwillRun
692 BEGINafterRun
693 CODESTARTafterRun
694 ENDafterRun
695 BEGINmodExit
696 CODESTARTmodExit
697 	if(pRelpEngine != NULL)
698 		iRet = relpEngineDestruct(&amp;pRelpEngine);
699 	objRelease(statsobj, CORE_COMPONENT);
700 	objRelease(ruleset, CORE_COMPONENT);
701 	objRelease(glbl, CORE_COMPONENT);
702 	objRelease(prop, CORE_COMPONENT);
703 	objRelease(net, LM_NET_FILENAME);
704 ENDmodExit
705 static rsRetVal
706 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
707 {
708 	free(cs.pszBindRuleset);
709 	cs.pszBindRuleset = NULL;
710 	return RS_RET_OK;
711 }
712 BEGINisCompatibleWithFeature
713 CODESTARTisCompatibleWithFeature
714 	if(eFeat == sFEATURENonCancelInputTermination)
715 		iRet = RS_RET_OK;
716 ENDisCompatibleWithFeature
717 BEGINqueryEtryPt
718 CODESTARTqueryEtryPt
719 CODEqueryEtryPt_STD_IMOD_QUERIES
720 CODEqueryEtryPt_STD_CONF2_QUERIES
721 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
722 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
723 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
724 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
725 ENDqueryEtryPt
726 BEGINmodInit()
727 CODESTARTmodInit
728 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
729 	pRelpEngine = NULL;
730 	CHKiRet(objUse(glbl, CORE_COMPONENT));
731 	CHKiRet(objUse(prop, CORE_COMPONENT));
732 	CHKiRet(objUse(net, LM_NET_FILENAME));
733 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
734 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
735 	#ifndef HAVE_RELPSRVSETOVERSIZEMODE
736 		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imrelp: librelp too old, oversizemode "
737 			"defaults to \"abort\"");
738 	#endif
739 	CHKiRet(regCfSysLineHdlr2((uchar*)"inputrelpserverbindruleset", 0, eCmdHdlrGetWord,
740 				   NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
741 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputrelpserverrun", 0, eCmdHdlrGetWord,
742 				   addInstance, NULL, STD_LOADABLE_MODULE_ID));
743 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
744 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
745 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
