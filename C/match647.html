<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for pmdb2diag.c &amp; imrelp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pmdb2diag.c &amp; imrelp.c
      </h3>
<h1 align="center">
        11.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pmdb2diag.c (28.350515%)<th>imrelp.c (7.4024224%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(254-260)<td><a href="#" name="0">(582-588)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(240-253)<td><a href="#" name="1">(518-533)</a><td align="center"><font color="#e50000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(59-68)<td><a href="#" name="2">(166-175)</a><td align="center"><font color="#d80000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pmdb2diag.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* pmdb2diag.c
 *
 * This is a parser module specifically for DB2diag log file.
 * It extracted program, pid and severity from the log.
 *
 * Copyright 2015 Philippe Duveau @ Pari Mutuel Urbain.
 *
 * This file is contribution of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#ifdef HAVE_SYS_TIME_H
#	include &lt;sys/time.h&gt;
#endif
#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "template.h"
#include "msg.h"
#include "module-template.h"
#include "glbl.h"
#include "errmsg.h"
#include "parser.h"
#include "datetime.h"
#include "unicode-helper.h"

MODULE_TYPE_PARSER
MODULE_TYPE_NOKEEP
PARSER_NAME("db2.diag")
MODULE_CNFNAME("pmdb2diag")

/* internal structures
 */
DEF_PMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(datetime)
<a name="2"></a>
/* input instance parameters */
static struct cnfparamdescr parserpdescr[] = {
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "levelpos", eCmdHdlrInt, 0 },
	{ "timepos", eCmdHdlrInt, 0 },
	{ "timeformat", eCmdHdlrString, 0 },
	{ "pidstarttoprogstartshift", eCmdHdlrInt, 0 },
};
static struct cnfparamblk parserpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
	  parserpdescr
	};</b></font>

struct instanceConf_s {
	int levelpos; /* expected severity position in read message */
	int timepos;  /* expected time position in read message */
	int pidstarttoprogstartshift; /* position of prog related to pid */
	char *timeformat; /* format of timestamp in read message */
	char sepSec; /* decimal separator between second and milliseconds */
};

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATUREAutomaticPRIParsing)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINparse2
	struct tm tm;
	char *ms, *timepos, *pid, *prog, *eprog, *backslash, *end, *lvl;
	int lprog, lpid, lvl_len;
	char buffer[128];
CODESTARTparse2
	assert(pMsg != NULL);
	assert(pMsg-&gt;pszRawMsg != NULL);

	DBGPRINTF("Message will now be parsed by \"db2diag\" parser.\n");
	if(pMsg-&gt;iLenRawMsg - (int)pMsg-&gt;offAfterPRI &lt; pInst-&gt;levelpos+4)
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);

	/* Instead of comparing strings which a waste of cpu cycles we take interpret the 4 first chars of
	 * level read it as int32 and compare it to same interpretation of our constant "levels"
	 * So this test is not sensitive to ENDIANESS. This is not a clean way but very efficient.
	 */
	lvl = (char*)(pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI + pInst-&gt;levelpos);

	switch (*lvl) {
	case 'C': /* Critical */
		pMsg-&gt;iSeverity = LOG_EMERG;
		lvl_len = 8;
		break;
	case 'A': /* Alert */
		pMsg-&gt;iSeverity = LOG_ALERT;
		lvl_len = 5;
		break;
	case 'S': /* Severe */
		pMsg-&gt;iSeverity = LOG_CRIT;
		lvl_len = 6;
		break;
	case 'E': /* Error / Event */
		pMsg-&gt;iSeverity = (lvl[1] == 'r') ? LOG_ERR : LOG_NOTICE;
		lvl_len = 5;
		break;
	case 'W': /* Warning */
		pMsg-&gt;iSeverity = LOG_WARNING;
		lvl_len = 7;
		break;
	case 'I': /* Info */
		pMsg-&gt;iSeverity = LOG_INFO;
		lvl_len = 4;
		break;
	case 'D': /* Debug */
		pMsg-&gt;iSeverity = LOG_DEBUG;
		lvl_len = 5;
		break;
	default:
		/* perhaps the message does not contain a proper level if so don't parse the log */
		ABORT_FINALIZE(0);
	}

	/* let recheck with the real level len */
	if(pMsg-&gt;iLenRawMsg - (int)pMsg-&gt;offAfterPRI &lt; pInst-&gt;levelpos+lvl_len)
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);

	DBGPRINTF("db2parse Level %d\n", pMsg-&gt;iSeverity);

	end = (char*)pMsg-&gt;pszRawMsg + pMsg-&gt;iLenRawMsg ;

	timepos = (char*)pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI + pInst-&gt;timepos;

	DBGPRINTF("db2parse Time %.30s\n", timepos);
	ms = strptime(timepos, pInst-&gt;timeformat, &amp;tm);

	if (ms &gt; timepos &amp;&amp;  *(ms-1) == pInst-&gt;sepSec)
	{
		/* the timestamp could be properly interpreted by strptime &amp; our format then set proper timestamp  */
		int secfrac = 0, tzoff = 0;

		char *tzpos = strchr(ms, '+');
		if (!tzpos) tzpos = strchr(ms, '-');
		if (!tzpos) tzpos = (char*)"+";

		sscanf(ms, (*tzpos == '+') ? "%d+%d " : "%d-%d ", &amp;secfrac, &amp;tzoff);

		pMsg-&gt;tTIMESTAMP.year = tm.tm_year+1900;
		pMsg-&gt;tTIMESTAMP.month = tm.tm_mon + 1;
		pMsg-&gt;tTIMESTAMP.day = tm.tm_mday;
		pMsg-&gt;tTIMESTAMP.hour = tm.tm_hour;
		pMsg-&gt;tTIMESTAMP.minute = tm.tm_min;
		pMsg-&gt;tTIMESTAMP.second = tm.tm_sec;
		pMsg-&gt;tTIMESTAMP.secfrac = secfrac;
		pMsg-&gt;tTIMESTAMP.secfracPrecision = tzpos-ms;
		pMsg-&gt;tTIMESTAMP.OffsetMode = *tzpos;
		pMsg-&gt;tTIMESTAMP.OffsetHour = tzoff / 60;
		pMsg-&gt;tTIMESTAMP.OffsetMinute = tzoff % 60;
	}

	pid = strchr((char*)pMsg-&gt;pszRawMsg + pInst-&gt;levelpos + lvl_len, ':');
	if (!pid || pid&gt;=end) ABORT_FINALIZE(0);
	pid += 2;
	lpid = strchr(pid, ' ') - pid;

	DBGPRINTF("db2parse pid %.*s\n", lpid, pid);

	/* set the pid */
	snprintf(buffer, 128, "%.*s", lpid, pid);
	MsgSetPROCID(pMsg, buffer);

	prog = pid + pInst-&gt;pidstarttoprogstartshift; /* this offset between start of pid to start of prog */
	if (prog&gt;=end) ABORT_FINALIZE(0);

	eprog = strchr(prog, ' '); /* let find the end of the program */
	if (eprog &amp;&amp; eprog&gt;=end) ABORT_FINALIZE(0);

	backslash = strchr(prog, '\\'); /* perhaps program contain an backslash */
	if (!backslash || backslash&gt;=end) backslash = end;

	/* Determine the final length of prog */
	lprog = (eprog &amp;&amp; eprog&lt;backslash) ? eprog-prog : backslash-prog;

	DBGPRINTF("db2parse prog %.*s     lprog %d\n", lprog, prog, lprog);

/* set the appname */
	snprintf(buffer, 128, "%.*s", lprog, prog);
	MsgSetAPPNAME(pMsg, buffer);

	/* the original raw msg if not altered by the parser */
finalize_it:
ENDparse2


BEGINfreeParserInst
CODESTARTfreeParserInst
	free(pInst-&gt;timeformat);
ENDfreeParserInst

static rsRetVal
createInstance(instanceConf_t **ppInst)
{
	instanceConf_t *pInst;
	DEFiRet;
	CHKmalloc(pInst = (instanceConf_t *)malloc(sizeof(instanceConf_t)));
	pInst-&gt;timeformat = NULL;
	pInst-&gt;levelpos = 59;
	pInst-&gt;timepos = 0;
	pInst-&gt;pidstarttoprogstartshift = 49;

	*ppInst = pInst;
finalize_it:
	RETiRet;
}

BEGINnewParserInst
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTnewParserInst
	inst = NULL;

	DBGPRINTF("newParserInst (pmdb2diag)\n");
	CHKiRet(createInstance(&amp;inst));
<a name="1"></a>
	if (lst)
	{
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		if((pvals = nvlstGetParams(lst, &amp;parserpblk, NULL)) == NULL) {
			ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
		}

		if(Debug) {
			DBGPRINTF("parser param blk in pmdb2diag:\n");
			cnfparamsPrint(&amp;parserpblk, pvals);
		}

		for(i = 0 ; i &lt; parserpblk.nParams ; ++i) {
			if(!pvals[i].bUsed)
<a name="0"></a>				continue;
			if(!strcmp(parserpblk.descr[i].name, "timeformat")) {
				inst-&gt;timeformat = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			} else if(!strcmp(parserpblk.descr[i].name, "timepos")) {
				inst-&gt;timepos = (int)pvals[i].val.d.n;
			} else if(!strcmp(parserpblk.descr[i].name, "levelpos")) {
				inst-&gt;levelpos = (int) pvals[i].val.d.n;
			} else if(!strcmp(parserpblk.descr[i].name, "pidstarttoprogstartshift")) {
				inst-&gt;pidstarttoprogstartshift = (int) pvals[i].val.d.n;
			} else {</b></font>
				DBGPRINTF("pmdb2diag: program error, non-handled "
				  "param '%s'\n", parserpblk.descr[i].name);
			}
		}
	}

	if (inst-&gt;timeformat == NULL)
	{
		inst-&gt;timeformat = strdup("%Y-%m-%d-%H.%M.%S.");
		inst-&gt;sepSec = '.';
	}else
		inst-&gt;sepSec = inst-&gt;timeformat[strlen(inst-&gt;timeformat)-1];

	DBGPRINTF("pmdb2diag: parsing date/time with '%s' at position %d and level at position %d.\n",
			inst-&gt;timeformat, inst-&gt;timepos, inst-&gt;levelpos);

finalize_it:
CODE_STD_FINALIZERnewParserInst
	if(lst != NULL)
		cnfparamvalsDestruct(pvals, &amp;parserpblk);
ENDnewParserInst

BEGINmodExit
CODESTARTmodExit
	/* release what we no longer need */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit

BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_PMOD2_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt



BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	DBGPRINTF("pmdb2diag parser init called, compiled with version %s\n", VERSION);
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imrelp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* imrelp.c
 *
 * This is the implementation of the RELP input module.
 *
 * File begun on 2008-03-13 by RGerhards
 *
 * Copyright 2008-2019 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;signal.h&gt;
#include &lt;librelp.h&gt;
#include "rsyslog.h"
#include "dirty.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "module-template.h"
#include "net.h"
#include "msg.h"
#include "unicode-helper.h"
#include "prop.h"
#include "ruleset.h"
#include "glbl.h"
#include "statsobj.h"
#include "srUtils.h"
#include "parserif.h"

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imrelp")

/* static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(net)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)

/* forward definitions */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);


/* Module static data */
/* config vars for legacy config system */
static relpEngine_t *pRelpEngine;	/* our relp engine */

/* config settings */
typedef struct configSettings_s {
	uchar *pszBindRuleset;		/* name of Ruleset to bind to */
} configSettings_t;
static configSettings_t cs;

struct instanceConf_s {
	uchar *pszBindPort;		/* port to bind to */
	uchar *pszBindAddr;		/* address to bind to */
	uchar *pszBindRuleset;		/* name of ruleset to bind to */
	uchar *pszInputName;		/* value for inputname property */
	prop_t *pInputName;		/* InputName in property format for fast access */
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to */
	sbool bKeepAlive;		/* support keep-alive packets */
	sbool bEnableTLS;
	sbool bEnableTLSZip;
	sbool bEnableLstn;		/* flag to permit disabling of listener in error case */
	int dhBits;
	size_t maxDataSize;
	int oversizeMode;
	uchar *pristring;		/* GnuTLS priority string (NULL if not to be provided) */
	uchar *authmode;		/* TLS auth mode */
	uchar *caCertFile;
	uchar *myCertFile;
	uchar *myPrivKeyFile;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	uchar *tlscfgcmd;
#endif
	int iKeepAliveIntvl;
	int iKeepAliveProbes;
	int iKeepAliveTime;
	flowControl_t flowCtlType;
	struct {
		int nmemb;
		uchar **name;
	} permittedPeers;

	struct instanceConf_s *next;
	/* with librelp, this module does not have any own specific session
	 * or listener active data item. As a "work-around", we keep some
	 * data items inside the configuration object. To keep things
	 * decently clean, we put them all into their dedicated struct. So
	 * it is easy to judge what is actual configuration and what is
	 * dynamic runtime data. -- rgerhards, 2013-06-18
	 */
	struct {
		statsobj_t *stats;	/* listener stats */
		STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
	} data;
};


struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
	const char *tlslib;
	uchar *pszBindRuleset;		/* default name of Ruleset to bind to */
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ "ruleset", eCmdHdlrGetWord, 0 },
	{ "tls.tlslib", eCmdHdlrString, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ "port", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "address", eCmdHdlrString, 0 },
	{ "name", eCmdHdlrString, 0 },
	{ "ruleset", eCmdHdlrString, 0 },
	{ "keepalive", eCmdHdlrBinary, 0 },
	{ "keepalive.probes", eCmdHdlrInt, 0 },
	{ "keepalive.time", eCmdHdlrInt, 0 },
	{ "keepalive.interval", eCmdHdlrInt, 0 },
	{ "maxdatasize", eCmdHdlrSize, 0 },
	{ "oversizemode", eCmdHdlrString, 0 },
	{ "flowcontrol", eCmdHdlrGetWord, 0 },
	{ "tls", eCmdHdlrBinary, 0 },
	{ "tls.permittedpeer", eCmdHdlrArray, 0 },
	{ "tls.authmode", eCmdHdlrString, 0 },
<a name="2"></a>	{ "tls.dhbits", eCmdHdlrInt, 0 },
	{ "tls.prioritystring", eCmdHdlrString, 0 },
	{ "tls.cacert", eCmdHdlrString, 0 },
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "tls.mycert", eCmdHdlrString, 0 },
	{ "tls.myprivkey", eCmdHdlrString, 0 },
	{ "tls.tlscfgcmd", eCmdHdlrString, 0 },
	{ "tls.compression", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};</b></font>

#include "im-helper.h" /* must be included AFTER the type definitions! */
static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */

/* ------------------------------ callbacks ------------------------------ */

PRAGMA_DIAGNOSTIC_PUSH
PRAGMA_IGNORE_Wformat_nonliteral
static void __attribute__((format(printf, 1, 2)))
imrelp_dbgprintf(const char *fmt, ...)
{
	va_list ap;
	char pszWriteBuf[32*1024+1]; //this function has to be able to
					/*generate a buffer longer than that of r_dbgprintf, so
					r_dbgprintf can properly truncate*/

	if(!(Debug &amp;&amp; debugging_on)) {
		return;
	}

	va_start(ap, fmt);
	vsnprintf(pszWriteBuf, sizeof(pszWriteBuf), fmt, ap);
	va_end(ap);
	r_dbgprintf("imrelp.c", "%s", pszWriteBuf);
}
PRAGMA_DIAGNOSTIC_POP

static void
onErr(void *pUsr, char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	instanceConf_t *inst = (instanceConf_t*) pUsr;
	LogError(0, RS_RET_RELP_AUTH_FAIL, "imrelp[%s]: error '%s', object "
			" '%s' - input may not work as intended",
			inst-&gt;pszBindPort, errmesg, objinfo);
}

static void
onGenericErr(char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	LogError(0, RS_RET_RELP_ERR, "imrelp: librelp error '%s', object "
			" '%s' - input may not work as intended", errmesg, objinfo);
}

static void
onAuthErr(void *pUsr, char *authinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	instanceConf_t *inst = (instanceConf_t*) pUsr;
	LogError(0, RS_RET_RELP_AUTH_FAIL, "imrelp[%s]: authentication error '%s', peer "
			"is '%s'", inst-&gt;pszBindPort, errmesg, authinfo);
}

/* callback for receiving syslog messages. This function is invoked from the
 * RELP engine when a syslog message arrived. It must return a relpRetVal,
 * with anything else but RELP_RET_OK terminating the relp session. Please note
 * that RELP_RET_OK is equal to RS_RET_OK and the other libRELP error codes
 * are different from our rsRetVal. So we can simply use our own iRet system
 * to fulfill the requirement.
 * rgerhards, 2008-03-21
 * Note: librelp 1.0.0 is required in order to receive the IP address, otherwise
 * we will only see the hostname (twice). -- rgerhards, 2009-10-14
 */
static relpRetVal
onSyslogRcv(void *pUsr, uchar *pHostname, uchar *pIP, uchar *msg, size_t lenMsg)
{
	prop_t *pProp = NULL;
	smsg_t *pMsg;
	instanceConf_t *inst = (instanceConf_t*) pUsr;
	DEFiRet;

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetInputName(pMsg, inst-&gt;pInputName);
	MsgSetRawMsg(pMsg, (char*)msg, lenMsg);
	MsgSetFlowControlType(pMsg, inst-&gt;flowCtlType);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	pMsg-&gt;msgFlags  = PARSE_HOSTNAME | NEEDS_PARSING;

	/* TODO: optimize this, we can store it inside the session */
	MsgSetRcvFromStr(pMsg, pHostname, ustrlen(pHostname), &amp;pProp);
	CHKiRet(prop.Destruct(&amp;pProp));
	CHKiRet(MsgSetRcvFromIPStr(pMsg, pIP, ustrlen(pIP), &amp;pProp));
	CHKiRet(prop.Destruct(&amp;pProp));
	CHKiRet(submitMsg2(pMsg));
	STATSCOUNTER_INC(inst-&gt;data.ctrSubmit, inst-&gt;data.mutCtrSubmit);

finalize_it:

	RETiRet;
}


/* ------------------------------ end callbacks ------------------------------ */

/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;

	inst-&gt;pszBindPort = NULL;
	inst-&gt;pszBindAddr = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pszInputName = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;bKeepAlive = 0;
	inst-&gt;iKeepAliveIntvl = 0;
	inst-&gt;iKeepAliveProbes = 0;
	inst-&gt;iKeepAliveTime = 0;
	inst-&gt;bEnableTLS = 0;
	inst-&gt;bEnableTLSZip = 0;
	inst-&gt;bEnableLstn = 0;
	inst-&gt;dhBits = 0;
	inst-&gt;pristring = NULL;
	inst-&gt;authmode = NULL;
	inst-&gt;permittedPeers.nmemb = 0;
	inst-&gt;caCertFile = NULL;
	inst-&gt;myCertFile = NULL;
	inst-&gt;myPrivKeyFile = NULL;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	inst-&gt;tlscfgcmd = NULL;
#endif
	inst-&gt;maxDataSize = 0;
	inst-&gt;flowCtlType = eFLOWCTL_LIGHT_DELAY;
#ifdef HAVE_RELPSRVSETOVERSIZEMODE
	inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
#endif

	/* node created, let's add to config */
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}


/* function to generate an error message if the ruleset cannot be found */
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imrelp[%s]: ruleset '%s' not found - "
			"using default ruleset instead",
			inst-&gt;pszBindPort, inst-&gt;pszBindRuleset);
}


/* This function is called when a new listener instance shall be added to
 * the current config object via the legacy config system. It just shuffles
 * all parameters to the listener in-memory instance.
 * rgerhards, 2011-05-04
 */
static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	instanceConf_t *inst;
	DEFiRet;

	CHKiRet(createInstance(&amp;inst));

	if(pNewVal == NULL || *pNewVal == '\0') {
		LogError(0, NO_ERRCODE, "imrelp: port number must be specified, listener ignored");
	}
	if((pNewVal == NULL) || (*pNewVal == '\0')) {
		inst-&gt;pszBindPort = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindPort = ustrdup(pNewVal));
	}
	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
		inst-&gt;pszBindRuleset = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
	}
	inst-&gt;pBindRuleset = NULL;

	inst-&gt;bEnableLstn = -1; /* all ok, ready to start up */
finalize_it:
	free(pNewVal);
	RETiRet;
}


static rsRetVal
addListner(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
{
	relpSrv_t *pSrv;
	int relpRet;
	uchar statname[64];
	int i;
	DEFiRet;

	if(!inst-&gt;bEnableLstn) {
		DBGPRINTF("listener not started because it is disabled by config error\n");
		FINALIZE;
	}

	if(pRelpEngine == NULL) {
		CHKiRet(relpEngineConstruct(&amp;pRelpEngine));
		CHKiRet(relpEngineSetDbgprint(pRelpEngine, (void (*)(char *, ...))imrelp_dbgprintf));
		CHKiRet(relpEngineSetFamily(pRelpEngine, glbl.GetDefPFFamily(runModConf-&gt;pConf)));
		CHKiRet(relpEngineSetEnableCmd(pRelpEngine, (uchar*) "syslog", eRelpCmdState_Required));
		CHKiRet(relpEngineSetSyslogRcv2(pRelpEngine, onSyslogRcv));
		CHKiRet(relpEngineSetOnErr(pRelpEngine, onErr));
		CHKiRet(relpEngineSetOnGenericErr(pRelpEngine, onGenericErr));
		CHKiRet(relpEngineSetOnAuthErr(pRelpEngine, onAuthErr));
		if (!glbl.GetDisableDNS(runModConf-&gt;pConf)) {
			CHKiRet(relpEngineSetDnsLookupMode(pRelpEngine, 1));
		}
		#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
			if(modConf-&gt;tlslib != NULL) {
				if(relpEngineSetTLSLibByName(pRelpEngine, modConf-&gt;tlslib) != RELP_RET_OK) {
					LogMsg(0, RS_RET_CONF_PARAM_INVLD, LOG_WARNING,
						"imrelp: tlslib '%s' not accepted as valid by librelp - using default",
						modConf-&gt;tlslib);
				}
			}
		#endif
	}

	CHKiRet(relpEngineListnerConstruct(pRelpEngine, &amp;pSrv));
	CHKiRet(relpSrvSetMaxDataSize(pSrv, inst-&gt;maxDataSize));
	CHKiRet(relpSrvSetLstnPort(pSrv, inst-&gt;pszBindPort));
	#if defined(HAVE_RELPSRVSETLSTNADDR)
		CHKiRet(relpSrvSetLstnAddr(pSrv, inst-&gt;pszBindAddr));
	#endif

#ifdef HAVE_RELPSRVSETOVERSIZEMODE
	CHKiRet(relpSrvSetOversizeMode(pSrv, inst-&gt;oversizeMode));
#endif
	inst-&gt;pszInputName = ustrdup((inst-&gt;pszInputName == NULL) ?  UCHAR_CONSTANT("imrelp") : inst-&gt;pszInputName);
	CHKiRet(prop.Construct(&amp;inst-&gt;pInputName));
	CHKiRet(prop.SetString(inst-&gt;pInputName, inst-&gt;pszInputName, ustrlen(inst-&gt;pszInputName)));
	CHKiRet(prop.ConstructFinalize(inst-&gt;pInputName));
	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&amp;(inst-&gt;data.stats)));
	snprintf((char*)statname, sizeof(statname), "%s(%s)",
		 inst-&gt;pszInputName, inst-&gt;pszBindPort);
	statname[sizeof(statname)-1] = '\0'; /* just to be on the save side... */
	CHKiRet(statsobj.SetName(inst-&gt;data.stats, statname));
	CHKiRet(statsobj.SetOrigin(inst-&gt;data.stats, (uchar*)"imrelp"));
	STATSCOUNTER_INIT(inst-&gt;data.ctrSubmit, inst-&gt;data.mutCtrSubmit);
	CHKiRet(statsobj.AddCounter(inst-&gt;data.stats, UCHAR_CONSTANT("submitted"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(inst-&gt;data.ctrSubmit)));
	CHKiRet(statsobj.ConstructFinalize(inst-&gt;data.stats));
	/* end stats counters */
	relpSrvSetUsrPtr(pSrv, inst);
	relpSrvSetKeepAlive(pSrv, inst-&gt;bKeepAlive, inst-&gt;iKeepAliveIntvl,
			    inst-&gt;iKeepAliveProbes, inst-&gt;iKeepAliveTime);
	if(inst-&gt;bEnableTLS) {
		relpRet = relpSrvEnableTLS2(pSrv);
		if(relpRet == RELP_RET_ERR_NO_TLS) {
			LogError(0, RS_RET_RELP_NO_TLS,
					"imrelp: could not activate relp TLS, librelp "
					"does not support it (most probably GnuTLS lib "
					"is too old)!");
			ABORT_FINALIZE(RS_RET_RELP_NO_TLS);
		} else if(relpRet == RELP_RET_ERR_NO_TLS_AUTH) {
			LogError(0, RS_RET_RELP_NO_TLS_AUTH,
					"imrelp: could not activate relp TLS with "
					"authentication, librelp does not support it "
					"(most probably GnuTLS lib is too old)! "
					"Note: anonymous TLS is probably supported.");
			ABORT_FINALIZE(RS_RET_RELP_NO_TLS_AUTH);
		} else if(relpRet != RELP_RET_OK) {
			LogError(0, RS_RET_RELP_ERR,
					"imrelp: could not activate relp TLS, code %d", relpRet);
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
		if(inst-&gt;bEnableTLSZip) {
			relpSrvEnableTLSZip2(pSrv);
		}
		if(inst-&gt;dhBits) {
			relpSrvSetDHBits(pSrv, inst-&gt;dhBits);
		}
		relpSrvSetGnuTLSPriString(pSrv, (char*)inst-&gt;pristring);
		if(relpSrvSetAuthMode(pSrv, (char*)inst-&gt;authmode) != RELP_RET_OK) {
			LogError(0, RS_RET_RELP_ERR,
					"imrelp: invalid auth mode '%s'", inst-&gt;authmode);
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
		if(relpSrvSetCACert(pSrv, (char*) inst-&gt;caCertFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(relpSrvSetOwnCert(pSrv, (char*) inst-&gt;myCertFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(relpSrvSetPrivKey(pSrv, (char*) inst-&gt;myPrivKeyFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
		if (inst-&gt;tlscfgcmd != NULL) {
			if(relpSrvSetTlsConfigCmd(pSrv, (char*) inst-&gt;tlscfgcmd) != RELP_RET_OK)
				ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
#endif
		for(i = 0 ; i &lt;  inst-&gt;permittedPeers.nmemb ; ++i) {
			relpSrvAddPermittedPeer(pSrv, (char*)inst-&gt;permittedPeers.name[i]);
		}
	}
	relpRet = relpEngineListnerConstructFinalize(pRelpEngine, pSrv);
	/* re-check error TLS error codes. librelp seems to emit them only
	 * after finalize in some cases...
	 */
	if(relpRet == RELP_RET_ERR_NO_TLS) {
		LogError(0, RS_RET_RELP_NO_TLS,
				"imrelp: could not activate relp TLS listener, librelp "
				"does not support it (most probably GnuTLS lib "
				"is too old)!");
		ABORT_FINALIZE(RS_RET_RELP_NO_TLS);
	} else if(relpRet == RELP_RET_ERR_NO_TLS_AUTH) {
		LogError(0, RS_RET_RELP_NO_TLS_AUTH,
				"imrelp: could not activate relp TLS listener with "
				"authentication, librelp does not support it "
				"(most probably GnuTLS lib is too old)! "
				"Note: anonymous TLS is probably supported.");
		ABORT_FINALIZE(RS_RET_RELP_NO_TLS_AUTH);
	} else if(relpRet != RELP_RET_OK) {
		LogError(0, RS_RET_RELP_ERR,
				"imrelp: could not activate relp listener, code %d", relpRet);
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	}

	DBGPRINTF("imrelp: max data size %zd\n", inst-&gt;maxDataSize);
	resetConfigVariables(NULL,NULL);

finalize_it:
	RETiRet;
}


BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst = NULL;
	int i,j;
	FILE *fp;
<a name="1"></a>CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imrelp)\n");

<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("input param blk in imrelp:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));

	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "port")) {
			inst-&gt;pszBindPort = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "address")) {
			#if defined(HAVE_RELPSRVSETLSTNADDR)
				inst-&gt;pszBindAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			#else
				parser_errmsg("imrelp: librelp does not support input parameter 'address'; "
					"it probably is too old (1.2.16 should be fine); ignoring setting now, "
					"listening on all interfaces");
			#endif
		} else if(!strcmp(inppblk.descr[i].name, "name")) {
			inst-&gt;pszInputName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "maxdatasize")) {
			inst-&gt;maxDataSize = (size_t) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "flowcontrol")) {
			if(!es_strconstcmp(pvals[i].val.d.estr, "none")) {
				inst-&gt;flowCtlType = eFLOWCTL_NO_DELAY;
			} else if(!es_strconstcmp(pvals[i].val.d.estr, "light")) {
				inst-&gt;flowCtlType = eFLOWCTL_LIGHT_DELAY;
			} else if(!es_strconstcmp(pvals[i].val.d.estr, "full")) {
				inst-&gt;flowCtlType = eFLOWCTL_FULL_DELAY;
			} else {
				const char *const mode = es_str2cstr(pvals[i].val.d.estr, NULL);
				parser_errmsg("imrelp: wrong flowcontrol parameter "
					"value '%s', using default: 'light'; possible "
					"values: 'no', 'light', 'full'\n", mode);
				free((void*)mode);
			}
		} else if(!strcmp(inppblk.descr[i].name, "oversizemode")) {
#ifdef HAVE_RELPSRVSETOVERSIZEMODE
			char *mode = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(!strcmp(mode, "abort")) {
				inst-&gt;oversizeMode = RELP_OVERSIZE_ABORT;
			} else if(!strcmp(mode, "truncate")) {
				inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
			} else if(!strcmp(mode, "accept")) {
				inst-&gt;oversizeMode = RELP_OVERSIZE_ACCEPT;
			} else {
				parser_errmsg("imrelp: wrong oversizeMode parameter "
					"value %s, using default: truncate\n", mode);
				inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
			}
#else
			parser_errmsg("imrelp: parameter oversizeMode is not available in "
				"this relp version and is therefore disabled.");
<a name="0"></a>#endif
		} else if(!strcmp(inppblk.descr[i].name, "keepalive")) {
			inst-&gt;bKeepAlive = (sbool) pvals[i].val.d.n;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "keepalive.probes")) {
			inst-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "keepalive.time")) {
			inst-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "keepalive.interval")) {
			inst-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "tls")) {</b></font>
			inst-&gt;bEnableTLS = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "tls.dhbits")) {
			inst-&gt;dhBits = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "tls.prioritystring")) {
			inst-&gt;pristring = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "tls.authmode")) {
			inst-&gt;authmode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "tls.compression")) {
			inst-&gt;bEnableTLSZip = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "tls.cacert")) {
			inst-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)inst-&gt;caCertFile, "r");
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				"error: certificate file %s couldn't be accessed: %s\n",
				inst-&gt;caCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(inppblk.descr[i].name, "tls.mycert")) {
			inst-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)inst-&gt;myCertFile, "r");
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				"error: certificate file %s couldn't be accessed: %s\n",
				inst-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(inppblk.descr[i].name, "tls.myprivkey")) {
			inst-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)inst-&gt;myPrivKeyFile, "r");
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				"error: certificate file %s couldn't be accessed: %s\n",
				inst-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(inppblk.descr[i].name, "tls.tlscfgcmd")) {
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
			inst-&gt;tlscfgcmd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
#else
			parser_errmsg("imrelp: librelp does not support input parameter 'tls.tlscfgcmd'; "
				"it probably is too old (1.5.0 or higher should be fine); ignoring setting now.");
#endif
		} else if(!strcmp(inppblk.descr[i].name, "tls.permittedpeer")) {
			inst-&gt;permittedPeers.nmemb = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(inst-&gt;permittedPeers.name =
				malloc(sizeof(uchar*) * inst-&gt;permittedPeers.nmemb));
			for(j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				inst-&gt;permittedPeers.name[j] = (uchar*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
			}
		} else {
			dbgprintf("imrelp: program error, non-handled "
			  "param '%s'\n", inppblk.descr[i].name);
		}
	}

	if(inst-&gt;myCertFile  != NULL &amp;&amp; inst-&gt;myPrivKeyFile == NULL) {
		LogError(0, RS_RET_ERR, "imrelp: certificate file given but no corresponding "
			"private key file - this is invalid, listener cannot be started");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(inst-&gt;myCertFile  == NULL &amp;&amp; inst-&gt;myPrivKeyFile != NULL) {
		LogError(0, RS_RET_ERR, "imrelp: private key file given but no corresponding "
			"certificate file - this is invalid, listener cannot be started");
		ABORT_FINALIZE(RS_RET_ERR);
	}

	inst-&gt;bEnableLstn = -1; /* all ok, ready to start up */

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
	if(iRet != RS_RET_OK) {
		if(inst != NULL) {
			free(inst-&gt;myCertFile);
			inst-&gt;myCertFile = NULL;
			free(inst-&gt;myPrivKeyFile);
			inst-&gt;myPrivKeyFile = NULL;
		}
	}
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;pszBindRuleset = NULL;
	pModConf-&gt;tlslib = NULL;
	/* init legacy config variables */
	cs.pszBindRuleset = NULL;
	bLegacyCnfModGlobalsPermitted = 1;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for imrelp:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "ruleset")) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "tls.tlslib")) {
			#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
				loadModConf-&gt;tlslib = es_str2cstr(pvals[i].val.d.estr, NULL);
			#else
				LogError(0, RS_RET_NOT_IMPLEMENTED,
					"imrelp warning: parameter tls.tlslib ignored - librelp does not support "
					"this API call. Using whatever librelp was compiled with.");
			#endif
		} else {
			dbgprintf("imrelp: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
	/* remove all of our legacy module handlers, as they can not used in addition
	 * the the new-style config method.
	 */
	bLegacyCnfModGlobalsPermitted = 0;
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	if(loadModConf-&gt;pszBindRuleset == NULL) {
		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
			loadModConf-&gt;pszBindRuleset = NULL;
		} else {
			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
		}
	} else {
		if((cs.pszBindRuleset != NULL) &amp;&amp; (cs.pszBindRuleset[0] != '\0')) {
			LogError(0, RS_RET_DUP_PARAM, "imrelp: ruleset "
					"set via legacy directive ignored");
		}
	}
finalize_it:
	free(cs.pszBindRuleset);
	cs.pszBindRuleset = NULL;
	loadModConf = NULL; /* done loading */
ENDendCnfLoad

BEGINcheckCnf
	instanceConf_t *inst;
	size_t maxMessageSize;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
		}
		std_checkRuleset(pModConf, inst);


		if(inst-&gt;maxDataSize == 0) {
			/* We set default value for maxDataSize here because
			 * otherwise the maxMessageSize isn't set.
			 */
			inst-&gt;maxDataSize = glbl.GetMaxLine(loadConf);
		}
		maxMessageSize = (size_t)glbl.GetMaxLine(loadConf);
		if(inst-&gt;maxDataSize &lt; maxMessageSize) {
			LogError(0, RS_RET_INVALID_PARAMS, "error: "
					"maxDataSize (%zu) is smaller than global parameter "
					"maxMessageSize (%zu) - global parameter will be used.",
					inst-&gt;maxDataSize, maxMessageSize);
			inst-&gt;maxDataSize = maxMessageSize;
		}
	}

finalize_it:
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
	instanceConf_t *inst;
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		addListner(pModConf, inst);
	}
	if(pRelpEngine == NULL) {
		LogError(0, RS_RET_NO_LSTN_DEFINED, "imrelp: no RELP listener defined, module can not run.");
		ABORT_FINALIZE(RS_RET_NO_RUN);
	}
finalize_it:
ENDactivateCnfPrePrivDrop

BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
	int i;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;pszBindPort);
		if (inst-&gt;pszBindAddr != NULL) {
			free(inst-&gt;pszBindAddr);
		}
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;pszInputName);
		free(inst-&gt;pristring);
		free(inst-&gt;authmode);
		for(i = 0 ; i &lt;  inst-&gt;permittedPeers.nmemb ; ++i) {
			free(inst-&gt;permittedPeers.name[i]);
		}
		if(inst-&gt;bEnableLstn) {
			prop.Destruct(&amp;inst-&gt;pInputName);
			statsobj.Destruct(&amp;(inst-&gt;data.stats));
		}
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
	free(pModConf-&gt;pszBindRuleset);
ENDfreeCnf

/* This is used to terminate the plugin. Note that the signal handler blocks
 * other activity on the thread. As such, it is safe to request the stop. When
 * we terminate, relpEngine is called, and it's select() loop interrupted. But
 * only *after this function is done*. So we do not have a race!
 */
static void
doSIGTTIN(int __attribute__((unused)) sig)
{
	const int bTerminate = ATOMIC_FETCH_32BIT(&amp;bTerminateInputs, &amp;mutTerminateInputs);
	if(bTerminate) {
		relpEngineSetStop(pRelpEngine);
	}
}


/* This function is called to gather input.
 */
BEGINrunInput
	sigset_t sigSet;
	struct sigaction sigAct;
CODESTARTrunInput
	/* we want to support non-cancel input termination. To do so, we must signal librelp
	 * when to stop. As we run on the same thread, we need to register as SIGTTIN handler,
	 * which will be used to put the terminating condition into librelp.
	 */
	sigfillset(&amp;sigSet);
	pthread_sigmask(SIG_BLOCK, &amp;sigSet, NULL);
	sigemptyset(&amp;sigSet);
	sigaddset(&amp;sigSet, SIGTTIN);
	pthread_sigmask(SIG_UNBLOCK, &amp;sigSet, NULL);
	memset(&amp;sigAct, 0, sizeof (sigAct));
	sigemptyset(&amp;sigAct.sa_mask);
	sigAct.sa_handler = doSIGTTIN;
	sigaction(SIGTTIN, &amp;sigAct, NULL);

	iRet = relpEngineRun(pRelpEngine);
ENDrunInput


BEGINwillRun
CODESTARTwillRun
ENDwillRun


BEGINafterRun
CODESTARTafterRun
	/* do cleanup here */
ENDafterRun


BEGINmodExit
CODESTARTmodExit
	if(pRelpEngine != NULL)
		iRet = relpEngineDestruct(&amp;pRelpEngine);

	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(net, LM_NET_FILENAME);
ENDmodExit


static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	free(cs.pszBindRuleset);
	cs.pszBindRuleset = NULL;
	return RS_RET_OK;
}


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	pRelpEngine = NULL;
	/* request objects we use */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(net, LM_NET_FILENAME));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	#ifndef HAVE_RELPSRVSETOVERSIZEMODE
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imrelp: librelp too old, oversizemode "
			"defaults to \"abort\"");
	#endif

	/* register config file handlers */
	CHKiRet(regCfSysLineHdlr2((uchar*)"inputrelpserverbindruleset", 0, eCmdHdlrGetWord,
				   NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputrelpserverrun", 0, eCmdHdlrGetWord,
				   addInstance, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
