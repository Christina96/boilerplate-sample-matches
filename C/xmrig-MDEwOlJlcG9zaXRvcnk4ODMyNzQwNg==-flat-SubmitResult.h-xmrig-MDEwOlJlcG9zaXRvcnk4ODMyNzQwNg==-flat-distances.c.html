
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.2491325468424705%, Tokens: 9</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-SubmitResult.h</h3>
            <pre><code>1  #ifndef XMRIG_SUBMITRESULT_H
2  #define XMRIG_SUBMITRESULT_H
3  #include "base/tools/Chrono.h"
4  namespace xmrig {
5  class SubmitResult
6  {
7  public:
8      SubmitResult() = default;
9      inline SubmitResult(int64_t seq, uint64_t diff, uint64_t actualDiff, int64_t reqId, uint32_t backend) :
10          reqId(reqId),
11          seq(seq),
12          backend(backend),
13          actualDiff(actualDiff),
14          diff(diff),
15          m_start(Chrono::steadyMSecs())
16      {}
<span onclick='openModal()' class='match'>17      inline void done() { elapsed = Chrono::steadyMSecs() - m_start; }
18      int64_t reqId           = 0;
19      int64_t seq             = 0;
20      uint32_t backend        = 0;
21      uint64_t actualDiff     = 0;
22      uint64_t diff           = 0;
23      uint64_t elapsed        = 0;
24  private:
25      uint64_t m_start        = 0;
</span>26  };
27  } &bsol;* namespace xmrig */
28  #endif &bsol;* XMRIG_SUBMITRESULT_H */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-distances.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "private/debug.h"
5  #include "private/misc.h"
6  #include <float.h>
7  #include <math.h>
8  static struct hwloc_internal_distances_s *
9  hwloc__internal_distances_from_public(hwloc_topology_t topology, struct hwloc_distances_s *distances);
10  static void
11  hwloc__groups_by_distances(struct hwloc_topology *topology, unsigned nbobjs, struct hwloc_obj **objs, uint64_t *values, unsigned long kind, unsigned nbaccuracies, float *accuracies, int needcheck);
12  static void
13  hwloc_internal_distances_restrict(hwloc_obj_t *objs,
14  				  uint64_t *indexes,
15  				  hwloc_obj_type_t *different_types,
16  				  uint64_t *values,
17  				  unsigned nbobjs, unsigned disappeared);
18  static void
19  hwloc_internal_distances_print_matrix(struct hwloc_internal_distances_s *dist)
20  {
21    unsigned nbobjs = dist->nbobjs;
22    hwloc_obj_t *objs = dist->objs;
23    hwloc_uint64_t *values = dist->values;
24    int gp = !HWLOC_DIST_TYPE_USE_OS_INDEX(dist->unique_type);
25    unsigned i, j;
26    fprintf(stderr, "%s", gp ? "gp_index" : "os_index");
27    for(j=0; j<nbobjs; j++)
28      fprintf(stderr, " % 5d", (int)(gp ? objs[j]->gp_index : objs[j]->os_index));
29    fprintf(stderr, "\n");
30    for(i=0; i<nbobjs; i++) {
31      fprintf(stderr, "  % 5d", (int)(gp ? objs[i]->gp_index : objs[i]->os_index));
32      for(j=0; j<nbobjs; j++)
33        fprintf(stderr, " % 5lld", (long long) values[i*nbobjs + j]);
34      fprintf(stderr, "\n");
35    }
36  }
37  void hwloc_internal_distances_init(struct hwloc_topology *topology)
38  {
39    topology->first_dist = topology->last_dist = NULL;
40    topology->next_dist_id = 0;
41  }
42  void hwloc_internal_distances_prepare(struct hwloc_topology *topology)
43  {
44    char *env;
45    hwloc_localeswitch_declare;
46    topology->grouping = 1;
47    if (topology->type_filter[HWLOC_OBJ_GROUP] == HWLOC_TYPE_FILTER_KEEP_NONE)
48      topology->grouping = 0;
49    env = getenv("HWLOC_GROUPING");
50    if (env && !atoi(env))
51      topology->grouping = 0;
52    if (topology->grouping) {
53      topology->grouping_next_subkind = 0;
54      HWLOC_BUILD_ASSERT(sizeof(topology->grouping_accuracies)/sizeof(*topology->grouping_accuracies) == 5);
55      topology->grouping_accuracies[0] = 0.0f;
56      topology->grouping_accuracies[1] = 0.01f;
57      topology->grouping_accuracies[2] = 0.02f;
58      topology->grouping_accuracies[3] = 0.05f;
59      topology->grouping_accuracies[4] = 0.1f;
60      topology->grouping_nbaccuracies = 5;
61      hwloc_localeswitch_init();
62      env = getenv("HWLOC_GROUPING_ACCURACY");
63      if (!env) {
64        topology->grouping_nbaccuracies = 1;
65      } else if (strcmp(env, "try")) {
66        topology->grouping_nbaccuracies = 1;
67        topology->grouping_accuracies[0] = (float) atof(env);
68      } &bsol;* otherwise try all values */
69      hwloc_localeswitch_fini();
70      topology->grouping_verbose = 0;
71      env = getenv("HWLOC_GROUPING_VERBOSE");
72      if (env)
73        topology->grouping_verbose = atoi(env);
74    }
75  }
76  static void hwloc_internal_distances_free(struct hwloc_internal_distances_s *dist)
77  {
78    free(dist->name);
79    free(dist->different_types);
80    free(dist->indexes);
81    free(dist->objs);
82    free(dist->values);
83    free(dist);
84  }
85  void hwloc_internal_distances_destroy(struct hwloc_topology * topology)
86  {
87    struct hwloc_internal_distances_s *dist, *next = topology->first_dist;
88    while ((dist = next) != NULL) {
89      next = dist->next;
90      hwloc_internal_distances_free(dist);
91    }
92    topology->first_dist = topology->last_dist = NULL;
93  }
94  static int hwloc_internal_distances_dup_one(struct hwloc_topology *new, struct hwloc_internal_distances_s *olddist)
95  {
96    struct hwloc_tma *tma = new->tma;
97    struct hwloc_internal_distances_s *newdist;
98    unsigned nbobjs = olddist->nbobjs;
99    newdist = hwloc_tma_malloc(tma, sizeof(*newdist));
100    if (!newdist)
101      return -1;
102    if (olddist->name) {
103      newdist->name = hwloc_tma_strdup(tma, olddist->name);
104      if (!newdist->name) {
105        assert(!tma || !tma->dontfree); &bsol;* this tma cannot fail to allocate */
106        hwloc_internal_distances_free(newdist);
107        return -1;
108      }
109    } else {
110      newdist->name = NULL;
111    }
112    if (olddist->different_types) {
113      newdist->different_types = hwloc_tma_malloc(tma, nbobjs * sizeof(*newdist->different_types));
114      if (!newdist->different_types) {
115        assert(!tma || !tma->dontfree); &bsol;* this tma cannot fail to allocate */
116        hwloc_internal_distances_free(newdist);
117        return -1;
118      }
119      memcpy(newdist->different_types, olddist->different_types, nbobjs * sizeof(*newdist->different_types));
120    } else
121      newdist->different_types = NULL;
122    newdist->unique_type = olddist->unique_type;
123    newdist->nbobjs = nbobjs;
124    newdist->kind = olddist->kind;
125    newdist->id = olddist->id;
126    newdist->indexes = hwloc_tma_malloc(tma, nbobjs * sizeof(*newdist->indexes));
127    newdist->objs = hwloc_tma_calloc(tma, nbobjs * sizeof(*newdist->objs));
128    newdist->iflags = olddist->iflags & ~HWLOC_INTERNAL_DIST_FLAG_OBJS_VALID; &bsol;* must be revalidated after dup() */
129    newdist->values = hwloc_tma_malloc(tma, nbobjs*nbobjs * sizeof(*newdist->values));
130    if (!newdist->indexes || !newdist->objs || !newdist->values) {
131      assert(!tma || !tma->dontfree); &bsol;* this tma cannot fail to allocate */
132      hwloc_internal_distances_free(newdist);
133      return -1;
134    }
135    memcpy(newdist->indexes, olddist->indexes, nbobjs * sizeof(*newdist->indexes));
136    memcpy(newdist->values, olddist->values, nbobjs*nbobjs * sizeof(*newdist->values));
137    newdist->next = NULL;
138    newdist->prev = new->last_dist;
139    if (new->last_dist)
140      new->last_dist->next = newdist;
141    else
142      new->first_dist = newdist;
143    new->last_dist = newdist;
144    return 0;
145  }
146  int hwloc_internal_distances_dup(struct hwloc_topology *new, struct hwloc_topology *old)
147  {
148    struct hwloc_internal_distances_s *olddist;
149    int err;
150    new->next_dist_id = old->next_dist_id;
151    for(olddist = old->first_dist; olddist; olddist = olddist->next) {
152      err = hwloc_internal_distances_dup_one(new, olddist);
153      if (err < 0)
154        return err;
155    }
156    return 0;
157  }
158  int hwloc_distances_remove(hwloc_topology_t topology)
159  {
160    if (!topology->is_loaded) {
161      errno = EINVAL;
162      return -1;
163    }
164    if (topology->adopted_shmem_addr) {
165      errno = EPERM;
166      return -1;
167    }
168    hwloc_internal_distances_destroy(topology);
169    return 0;
170  }
171  int hwloc_distances_remove_by_depth(hwloc_topology_t topology, int depth)
172  {
173    struct hwloc_internal_distances_s *dist, *next;
174    hwloc_obj_type_t type;
175    if (!topology->is_loaded) {
176      errno = EINVAL;
177      return -1;
178    }
179    if (topology->adopted_shmem_addr) {
180      errno = EPERM;
181      return -1;
182    }
183    type = hwloc_get_depth_type(topology, depth);
184    if (type == (hwloc_obj_type_t)-1) {
185      errno = EINVAL;
186      return -1;
187    }
188    next = topology->first_dist;
189    while ((dist = next) != NULL) {
190      next = dist->next;
191      if (dist->unique_type == type) {
192        if (next)
193  	next->prev = dist->prev;
194        else
195  	topology->last_dist = dist->prev;
196        if (dist->prev)
197  	dist->prev->next = dist->next;
198        else
199  	topology->first_dist = dist->next;
200        hwloc_internal_distances_free(dist);
201      }
202    }
203    return 0;
204  }
205  int hwloc_distances_release_remove(hwloc_topology_t topology,
206  				   struct hwloc_distances_s *distances)
207  {
208    struct hwloc_internal_distances_s *dist = hwloc__internal_distances_from_public(topology, distances);
209    if (!dist) {
210      errno = EINVAL;
211      return -1;
212    }
213    if (dist->prev)
214      dist->prev->next = dist->next;
215    else
216      topology->first_dist = dist->next;
217    if (dist->next)
218      dist->next->prev = dist->prev;
219    else
220      topology->last_dist = dist->prev;
221    hwloc_internal_distances_free(dist);
222    hwloc_distances_release(topology, distances);
223    return 0;
224  }
225  static void
226  hwloc_backend_distances_add__cancel(struct hwloc_internal_distances_s *dist)
227  {
228    free(dist->name);
229    free(dist->indexes);
230    free(dist->objs);
231    free(dist->different_types);
232    free(dist->values);
233    free(dist);
234  }
235  hwloc_backend_distances_add_handle_t
236  hwloc_backend_distances_add_create(hwloc_topology_t topology,
237                                     const char *name, unsigned long kind, unsigned long flags)
238  {
239    struct hwloc_internal_distances_s *dist;
240    if (flags) {
241      errno = EINVAL;
242      goto err;
243    }
244    dist = calloc(1, sizeof(*dist));
245    if (!dist)
246      goto err;
247    if (name) {
248      dist->name = strdup(name); &bsol;* ignore failure */
249      if (!dist->name)
250        goto err_with_dist;
251    }
252    dist->kind = kind;
253    dist->iflags = HWLOC_INTERNAL_DIST_FLAG_NOT_COMMITTED;
254    dist->unique_type = HWLOC_OBJ_TYPE_NONE;
255    dist->different_types = NULL;
256    dist->nbobjs = 0;
257    dist->indexes = NULL;
258    dist->objs = NULL;
259    dist->values = NULL;
260    dist->id = topology->next_dist_id++;
261    return dist;
262   err_with_dist:
263    hwloc_backend_distances_add__cancel(dist);
264   err:
265    return NULL;
266  }
267  int
268  hwloc_backend_distances_add_values(hwloc_topology_t topology __hwloc_attribute_unused,
269                                     hwloc_backend_distances_add_handle_t handle,
270                                     unsigned nbobjs, hwloc_obj_t *objs,
271                                     hwloc_uint64_t *values,
272                                     unsigned long flags)
273  {
274    struct hwloc_internal_distances_s *dist = handle;
275    hwloc_obj_type_t unique_type, *different_types = NULL;
276    hwloc_uint64_t *indexes = NULL;
277    unsigned i, disappeared = 0;
278    if (dist->nbobjs || !(dist->iflags & HWLOC_INTERNAL_DIST_FLAG_NOT_COMMITTED)) {
279      errno = EINVAL;
280      goto err;
281    }
282    if (flags || nbobjs < 2 || !objs || !values) {
283      errno = EINVAL;
284      goto err;
285    }
286    for(i=0; i<nbobjs; i++)
287      if (!objs[i])
288        disappeared++;
289    if (disappeared) {
290      if (disappeared == nbobjs) {
291        errno = ENOENT;
292        goto err;
293      }
294      hwloc_internal_distances_restrict(objs, NULL, NULL, values, nbobjs, disappeared);
295      nbobjs -= disappeared;
296    }
297    indexes = malloc(nbobjs * sizeof(*indexes));
298    if (!indexes)
299      goto err;
300    unique_type = objs[0]->type;
301    for(i=1; i<nbobjs; i++)
302      if (objs[i]->type != unique_type) {
303        unique_type = HWLOC_OBJ_TYPE_NONE;
304        break;
305      }
306    if (unique_type == HWLOC_OBJ_TYPE_NONE) {
307      different_types = malloc(nbobjs * sizeof(*different_types));
308      if (!different_types)
309        goto err_with_indexes;
310      for(i=0; i<nbobjs; i++)
<span onclick='openModal()' class='match'>311        different_types[i] = objs[i]->type;
312    }
313    dist->nbobjs = nbobjs;
314    dist->objs = objs;
315    dist->iflags |= HWLOC_INTERNAL_DIST_FLAG_OBJS_VALID;
316    dist->indexes = indexes;
317    dist->unique_type = unique_type;
318    dist->different_types = different_types;
319    dist->values = values;
</span>320    if (different_types)
321      dist->kind |= HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES;
322    if (HWLOC_DIST_TYPE_USE_OS_INDEX(dist->unique_type)) {
323        for(i=0; i<nbobjs; i++)
324  	dist->indexes[i] = objs[i]->os_index;
325      } else {
326        for(i=0; i<nbobjs; i++)
327  	dist->indexes[i] = objs[i]->gp_index;
328      }
329    return 0;
330   err_with_indexes:
331    free(indexes);
332   err:
333    hwloc_backend_distances_add__cancel(dist);
334    return -1;
335  }
336  static int
337  hwloc_backend_distances_add_values_by_index(hwloc_topology_t topology __hwloc_attribute_unused,
338                                              hwloc_backend_distances_add_handle_t handle,
339                                              unsigned nbobjs, hwloc_obj_type_t unique_type, hwloc_obj_type_t *different_types, hwloc_uint64_t *indexes,
340                                              hwloc_uint64_t *values)
341  {
342    struct hwloc_internal_distances_s *dist = handle;
343    hwloc_obj_t *objs;
344    if (dist->nbobjs || !(dist->iflags & HWLOC_INTERNAL_DIST_FLAG_NOT_COMMITTED)) {
345      errno = EINVAL;
346      goto err;
347    }
348    if (nbobjs < 2 || !indexes || !values || (unique_type == HWLOC_OBJ_TYPE_NONE && !different_types)) {
349      errno = EINVAL;
350      goto err;
351    }
352    objs = malloc(nbobjs * sizeof(*objs));
353    if (!objs)
354      goto err;
355    dist->nbobjs = nbobjs;
356    dist->objs = objs;
357    dist->indexes = indexes;
358    dist->unique_type = unique_type;
359    dist->different_types = different_types;
360    dist->values = values;
361    if (different_types)
362      dist->kind |= HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES;
363    return 0;
364   err:
365    hwloc_backend_distances_add__cancel(dist);
366    return -1;
367  }
368  int
369  hwloc_backend_distances_add_commit(hwloc_topology_t topology,
370                                     hwloc_backend_distances_add_handle_t handle,
371                                     unsigned long flags)
372  {
373    struct hwloc_internal_distances_s *dist = handle;
374    if (!dist->nbobjs || !(dist->iflags & HWLOC_INTERNAL_DIST_FLAG_NOT_COMMITTED)) {
375      errno = EINVAL;
376      goto err;
377    }
378    if ((flags & HWLOC_DISTANCES_ADD_FLAG_GROUP) && !dist->objs) {
379      errno = EINVAL;
380      goto err;
381    }
382    if (topology->grouping && (flags & HWLOC_DISTANCES_ADD_FLAG_GROUP) && !dist->different_types) {
383      float full_accuracy = 0.f;
384      float *accuracies;
385      unsigned nbaccuracies;
386      if (flags & HWLOC_DISTANCES_ADD_FLAG_GROUP_INACCURATE) {
387        accuracies = topology->grouping_accuracies;
388        nbaccuracies = topology->grouping_nbaccuracies;
389      } else {
390        accuracies = &full_accuracy;
391        nbaccuracies = 1;
392      }
393      if (topology->grouping_verbose) {
394        fprintf(stderr, "Trying to group objects using distance matrix:\n");
395        hwloc_internal_distances_print_matrix(dist);
396      }
397      hwloc__groups_by_distances(topology, dist->nbobjs, dist->objs, dist->values,
398  			       dist->kind, nbaccuracies, accuracies, 1 &bsol;* check the first matrix */);
399    }
400    if (topology->last_dist)
401      topology->last_dist->next = dist;
402    else
403      topology->first_dist = dist;
404    dist->prev = topology->last_dist;
405    dist->next = NULL;
406    topology->last_dist = dist;
407    dist->iflags &= ~HWLOC_INTERNAL_DIST_FLAG_NOT_COMMITTED;
408    return 0;
409   err:
410    hwloc_backend_distances_add__cancel(dist);
411    return -1;
412  }
413  int hwloc_internal_distances_add_by_index(hwloc_topology_t topology, const char *name,
414                                            hwloc_obj_type_t unique_type, hwloc_obj_type_t *different_types, unsigned nbobjs, uint64_t *indexes, uint64_t *values,
415                                            unsigned long kind, unsigned long flags)
416  {
417    hwloc_backend_distances_add_handle_t handle;
418    int err;
419    handle = hwloc_backend_distances_add_create(topology, name, kind, 0);
420    if (!handle)
421      goto err;
422    err = hwloc_backend_distances_add_values_by_index(topology, handle,
423                                                      nbobjs, unique_type, different_types, indexes,
424                                                      values);
425    if (err < 0)
426      goto err;
427    indexes = NULL;
428    different_types = NULL;
429    values = NULL;
430    err = hwloc_backend_distances_add_commit(topology, handle, flags);
431    if (err < 0)
432      goto err;
433    return 0;
434   err:
435    free(indexes);
436    free(different_types);
437    free(values);
438    return -1;
439  }
440  int hwloc_internal_distances_add(hwloc_topology_t topology, const char *name,
441                                   unsigned nbobjs, hwloc_obj_t *objs, uint64_t *values,
442                                   unsigned long kind, unsigned long flags)
443  {
444    hwloc_backend_distances_add_handle_t handle;
445    int err;
446    handle = hwloc_backend_distances_add_create(topology, name, kind, 0);
447    if (!handle)
448      goto err;
449    err = hwloc_backend_distances_add_values(topology, handle,
450                                             nbobjs, objs,
451                                             values,
452                                             0);
453    if (err < 0)
454      goto err;
455    objs = NULL;
456    values = NULL;
457    err = hwloc_backend_distances_add_commit(topology, handle, flags);
458    if (err < 0)
459      goto err;
460    return 0;
461   err:
462    free(objs);
463    free(values);
464    return -1;
465  }
466  #define HWLOC_DISTANCES_KIND_FROM_ALL (HWLOC_DISTANCES_KIND_FROM_OS|HWLOC_DISTANCES_KIND_FROM_USER)
467  #define HWLOC_DISTANCES_KIND_MEANS_ALL (HWLOC_DISTANCES_KIND_MEANS_LATENCY|HWLOC_DISTANCES_KIND_MEANS_BANDWIDTH)
468  #define HWLOC_DISTANCES_KIND_ALL (HWLOC_DISTANCES_KIND_FROM_ALL|HWLOC_DISTANCES_KIND_MEANS_ALL|HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES)
469  #define HWLOC_DISTANCES_ADD_FLAG_ALL (HWLOC_DISTANCES_ADD_FLAG_GROUP|HWLOC_DISTANCES_ADD_FLAG_GROUP_INACCURATE)
470  void * hwloc_distances_add_create(hwloc_topology_t topology,
471                                    const char *name, unsigned long kind,
472                                    unsigned long flags)
473  {
474    if (!topology->is_loaded) {
475      errno = EINVAL;
476      return NULL;
477    }
478    if (topology->adopted_shmem_addr) {
479      errno = EPERM;
480      return NULL;
481    }
482    if ((kind & ~HWLOC_DISTANCES_KIND_ALL)
483        || hwloc_weight_long(kind & HWLOC_DISTANCES_KIND_FROM_ALL) != 1
484        || hwloc_weight_long(kind & HWLOC_DISTANCES_KIND_MEANS_ALL) != 1) {
485      errno = EINVAL;
486      return NULL;
487    }
488    return hwloc_backend_distances_add_create(topology, name, kind, flags);
489  }
490  int hwloc_distances_add_values(hwloc_topology_t topology,
491                                 void *handle,
492                                 unsigned nbobjs, hwloc_obj_t *objs,
493                                 hwloc_uint64_t *values,
494                                 unsigned long flags)
495  {
496    unsigned i;
497    uint64_t *_values;
498    hwloc_obj_t *_objs;
499    int err;
500    for(i=1; i<nbobjs; i++)
501      if (!objs[i]) {
502        errno = EINVAL;
503        goto out;
504      }
505    _objs = malloc(nbobjs*sizeof(hwloc_obj_t));
506    _values = malloc(nbobjs*nbobjs*sizeof(*_values));
507    if (!_objs || !_values)
508      goto out_with_arrays;
509    memcpy(_objs, objs, nbobjs*sizeof(hwloc_obj_t));
510    memcpy(_values, values, nbobjs*nbobjs*sizeof(*_values));
511    err = hwloc_backend_distances_add_values(topology, handle, nbobjs, _objs, _values, flags);
512    if (err < 0) {
513      handle = NULL;
514      goto out_with_arrays;
515    }
516    return 0;
517   out_with_arrays:
518    free(_objs);
519    free(_values);
520   out:
521    if (handle)
522      hwloc_backend_distances_add__cancel(handle);
523    return -1;
524  }
525  int
526  hwloc_distances_add_commit(hwloc_topology_t topology,
527                             void *handle,
528                             unsigned long flags)
529  {
530    int err;
531    if (flags & ~HWLOC_DISTANCES_ADD_FLAG_ALL) {
532      errno = EINVAL;
533      goto out;
534    }
535    err = hwloc_backend_distances_add_commit(topology, handle, flags);
536    if (err < 0) {
537      handle = NULL;
538      goto out;
539    }
540    hwloc_topology_reconnect(topology, 0);
541    return 0;
542   out:
543    if (handle)
544      hwloc_backend_distances_add__cancel(handle);
545    return -1;
546  }
547  int hwloc_distances_add(hwloc_topology_t topology,
548  			unsigned nbobjs, hwloc_obj_t *objs, hwloc_uint64_t *values,
549  			unsigned long kind, unsigned long flags)
550  {
551    void *handle;
552    int err;
553    handle = hwloc_distances_add_create(topology, NULL, kind, 0);
554    if (!handle)
555      return -1;
556    err = hwloc_distances_add_values(topology, handle, nbobjs, objs, values, 0);
557    if (err < 0)
558      return -1;
559    err = hwloc_distances_add_commit(topology, handle, flags);
560    if (err < 0)
561      return -1;
562    return 0;
563  }
564  static void
565  hwloc_internal_distances_restrict(hwloc_obj_t *objs,
566  				  uint64_t *indexes,
567                                    hwloc_obj_type_t *different_types,
568  				  uint64_t *values,
569  				  unsigned nbobjs, unsigned disappeared)
570  {
571    unsigned i, newi;
572    unsigned j, newj;
573    for(i=0, newi=0; i<nbobjs; i++)
574      if (objs[i]) {
575        for(j=0, newj=0; j<nbobjs; j++)
576  	if (objs[j]) {
577  	  values[newi*(nbobjs-disappeared)+newj] = values[i*nbobjs+j];
578  	  newj++;
579  	}
580        newi++;
581      }
582    for(i=0, newi=0; i<nbobjs; i++)
583      if (objs[i]) {
584        objs[newi] = objs[i];
585        if (indexes)
586  	indexes[newi] = indexes[i];
587        if (different_types)
588          different_types[newi] = different_types[i];
589        newi++;
590      }
591  }
592  static int
593  hwloc_internal_distances_refresh_one(hwloc_topology_t topology,
594  				     struct hwloc_internal_distances_s *dist)
595  {
596    hwloc_obj_type_t unique_type = dist->unique_type;
597    hwloc_obj_type_t *different_types = dist->different_types;
598    unsigned nbobjs = dist->nbobjs;
599    hwloc_obj_t *objs = dist->objs;
600    uint64_t *indexes = dist->indexes;
601    unsigned disappeared = 0;
602    unsigned i;
603    if (dist->iflags & HWLOC_INTERNAL_DIST_FLAG_OBJS_VALID)
604      return 0;
605    for(i=0; i<nbobjs; i++) {
606      hwloc_obj_t obj;
607      if (HWLOC_DIST_TYPE_USE_OS_INDEX(unique_type)) {
608        if (unique_type == HWLOC_OBJ_PU)
609  	obj = hwloc_get_pu_obj_by_os_index(topology, (unsigned) indexes[i]);
610        else if (unique_type == HWLOC_OBJ_NUMANODE)
611  	obj = hwloc_get_numanode_obj_by_os_index(topology, (unsigned) indexes[i]);
612        else
613  	abort();
614      } else {
615        obj = hwloc_get_obj_by_type_and_gp_index(topology, different_types ? different_types[i] : unique_type, indexes[i]);
616      }
617      objs[i] = obj;
618      if (!obj)
619        disappeared++;
620    }
621    if (nbobjs-disappeared < 2)
622      return -1;
623    if (disappeared) {
624      hwloc_internal_distances_restrict(objs, dist->indexes, dist->different_types, dist->values, nbobjs, disappeared);
625      dist->nbobjs -= disappeared;
626    }
627    dist->iflags |= HWLOC_INTERNAL_DIST_FLAG_OBJS_VALID;
628    return 0;
629  }
630  void
631  hwloc_internal_distances_refresh(hwloc_topology_t topology)
632  {
633    struct hwloc_internal_distances_s *dist, *next;
634    for(dist = topology->first_dist; dist; dist = next) {
635      next = dist->next;
636      if (hwloc_internal_distances_refresh_one(topology, dist) < 0) {
637        assert(!topology->tma || !topology->tma->dontfree); &bsol;* this tma cannot fail to allocate */
638        if (dist->prev)
639  	dist->prev->next = next;
640        else
641  	topology->first_dist = next;
642        if (next)
643  	next->prev = dist->prev;
644        else
645  	topology->last_dist = dist->prev;
646        hwloc_internal_distances_free(dist);
647        continue;
648      }
649    }
650  }
651  void
652  hwloc_internal_distances_invalidate_cached_objs(hwloc_topology_t topology)
653  {
654    struct hwloc_internal_distances_s *dist;
655    for(dist = topology->first_dist; dist; dist = dist->next)
656      dist->iflags &= ~HWLOC_INTERNAL_DIST_FLAG_OBJS_VALID;
657  }
658  struct hwloc_distances_container_s {
659    unsigned id;
660    struct hwloc_distances_s distances;
661  };
662  #define HWLOC_DISTANCES_CONTAINER_OFFSET ((uintptr_t)(&((struct hwloc_distances_container_s*)NULL)->distances) - (uintptr_t)NULL)
663  #define HWLOC_DISTANCES_CONTAINER(_d) (struct hwloc_distances_container_s *) ( ((char*)_d) - HWLOC_DISTANCES_CONTAINER_OFFSET )
664  static struct hwloc_internal_distances_s *
665  hwloc__internal_distances_from_public(hwloc_topology_t topology, struct hwloc_distances_s *distances)
666  {
667    struct hwloc_distances_container_s *cont = HWLOC_DISTANCES_CONTAINER(distances);
668    struct hwloc_internal_distances_s *dist;
669    for(dist = topology->first_dist; dist; dist = dist->next)
670      if (dist->id == cont->id)
671        return dist;
672    return NULL;
673  }
674  void
675  hwloc_distances_release(hwloc_topology_t topology __hwloc_attribute_unused,
676  			struct hwloc_distances_s *distances)
677  {
678    struct hwloc_distances_container_s *cont = HWLOC_DISTANCES_CONTAINER(distances);
679    free(distances->values);
680    free(distances->objs);
681    free(cont);
682  }
683  const char *
684  hwloc_distances_get_name(hwloc_topology_t topology, struct hwloc_distances_s *distances)
685  {
686    struct hwloc_internal_distances_s *dist = hwloc__internal_distances_from_public(topology, distances);
687    return dist ? dist->name : NULL;
688  }
689  static struct hwloc_distances_s *
690  hwloc_distances_get_one(hwloc_topology_t topology __hwloc_attribute_unused,
691  			struct hwloc_internal_distances_s *dist)
692  {
693    struct hwloc_distances_container_s *cont;
694    struct hwloc_distances_s *distances;
695    unsigned nbobjs;
696    cont = malloc(sizeof(*cont));
697    if (!cont)
698      return NULL;
699    distances = &cont->distances;
700    nbobjs = distances->nbobjs = dist->nbobjs;
701    distances->objs = malloc(nbobjs * sizeof(hwloc_obj_t));
702    if (!distances->objs)
703      goto out;
704    memcpy(distances->objs, dist->objs, nbobjs * sizeof(hwloc_obj_t));
705    distances->values = malloc(nbobjs * nbobjs * sizeof(*distances->values));
706    if (!distances->values)
707      goto out_with_objs;
708    memcpy(distances->values, dist->values, nbobjs*nbobjs*sizeof(*distances->values));
709    distances->kind = dist->kind;
710    cont->id = dist->id;
711    return distances;
712   out_with_objs:
713    free(distances->objs);
714   out:
715    free(cont);
716    return NULL;
717  }
718  static int
719  hwloc__distances_get(hwloc_topology_t topology,
720  		     const char *name, hwloc_obj_type_t type,
721  		     unsigned *nrp, struct hwloc_distances_s **distancesp,
722  		     unsigned long kind, unsigned long flags __hwloc_attribute_unused)
723  {
724    struct hwloc_internal_distances_s *dist;
725    unsigned nr = 0, i;
726    if (flags) {
727      errno = EINVAL;
728      return -1;
729    }
730    hwloc_internal_distances_refresh(topology);
731    for(dist = topology->first_dist; dist; dist = dist->next) {
732      unsigned long kind_from = kind & HWLOC_DISTANCES_KIND_FROM_ALL;
733      unsigned long kind_means = kind & HWLOC_DISTANCES_KIND_MEANS_ALL;
734      if (name && (!dist->name || strcmp(name, dist->name)))
735        continue;
736      if (type != HWLOC_OBJ_TYPE_NONE && type != dist->unique_type)
737        continue;
738      if (kind_from && !(kind_from & dist->kind))
739        continue;
740      if (kind_means && !(kind_means & dist->kind))
741        continue;
742      if (nr < *nrp) {
743        struct hwloc_distances_s *distances = hwloc_distances_get_one(topology, dist);
744        if (!distances)
745  	goto error;
746        distancesp[nr] = distances;
747      }
748      nr++;
749    }
750    for(i=nr; i<*nrp; i++)
751      distancesp[i] = NULL;
752    *nrp = nr;
753    return 0;
754   error:
755    for(i=0; i<nr; i++)
756      hwloc_distances_release(topology, distancesp[i]);
757    return -1;
758  }
759  int
760  hwloc_distances_get(hwloc_topology_t topology,
761  		    unsigned *nrp, struct hwloc_distances_s **distancesp,
762  		    unsigned long kind, unsigned long flags)
763  {
764    if (flags || !topology->is_loaded) {
765      errno = EINVAL;
766      return -1;
767    }
768    return hwloc__distances_get(topology, NULL, HWLOC_OBJ_TYPE_NONE, nrp, distancesp, kind, flags);
769  }
770  int
771  hwloc_distances_get_by_depth(hwloc_topology_t topology, int depth,
772  			     unsigned *nrp, struct hwloc_distances_s **distancesp,
773  			     unsigned long kind, unsigned long flags)
774  {
775    hwloc_obj_type_t type;
776    if (flags || !topology->is_loaded) {
777      errno = EINVAL;
778      return -1;
779    }
780    type = hwloc_get_depth_type(topology, depth);
781    if (type == (hwloc_obj_type_t)-1) {
782      errno = EINVAL;
783      return -1;
784    }
785    return hwloc__distances_get(topology, NULL, type, nrp, distancesp, kind, flags);
786  }
787  int
788  hwloc_distances_get_by_name(hwloc_topology_t topology, const char *name,
789  			    unsigned *nrp, struct hwloc_distances_s **distancesp,
790  			    unsigned long flags)
791  {
792    if (flags || !topology->is_loaded) {
793      errno = EINVAL;
794      return -1;
795    }
796    return hwloc__distances_get(topology, name, HWLOC_OBJ_TYPE_NONE, nrp, distancesp, HWLOC_DISTANCES_KIND_ALL, flags);
797  }
798  int
799  hwloc_distances_get_by_type(hwloc_topology_t topology, hwloc_obj_type_t type,
800  			    unsigned *nrp, struct hwloc_distances_s **distancesp,
801  			    unsigned long kind, unsigned long flags)
802  {
803    if (flags || !topology->is_loaded) {
804      errno = EINVAL;
805      return -1;
806    }
807    return hwloc__distances_get(topology, NULL, type, nrp, distancesp, kind, flags);
808  }
809  static int hwloc_compare_values(uint64_t a, uint64_t b, float accuracy)
810  {
811    if (accuracy != 0.0f && fabsf((float)a-(float)b) < (float)a * accuracy)
812      return 0;
813    return a < b ? -1 : a == b ? 0 : 1;
814  }
815  static unsigned
816  hwloc__find_groups_by_min_distance(unsigned nbobjs,
817  				   uint64_t *_values,
818  				   float accuracy,
819  				   unsigned *groupids,
820  				   int verbose)
821  {
822    uint64_t min_distance = UINT64_MAX;
823    unsigned groupid = 1;
824    unsigned i,j,k;
825    unsigned skipped = 0;
826  #define VALUE(i, j) _values[(i) * nbobjs + (j)]
827    memset(groupids, 0, nbobjs*sizeof(*groupids));
828    for(i=0; i<nbobjs; i++)
829      for(j=0; j<nbobjs; j++) &bsol;* check the entire matrix, it may not be perfectly symmetric depending on the accuracy */
830        if (i != j && VALUE(i, j) < min_distance) &bsol;* no accuracy here, we want the real minimal */
831          min_distance = VALUE(i, j);
832    hwloc_debug("  found minimal distance %llu between objects\n", (unsigned long long) min_distance);
833    if (min_distance == UINT64_MAX)
834      return 0;
835    for(i=0; i<nbobjs; i++) {
836      unsigned size;
837      unsigned firstfound;
838      if (groupids[i])
839        continue;
840      groupids[i] = groupid;
841      size = 1;
842      firstfound = i;
843      while (firstfound != (unsigned)-1) {
844        unsigned newfirstfound = (unsigned)-1;
845        for(j=firstfound; j<nbobjs; j++)
846  	if (groupids[j] == groupid)
847  	  for(k=0; k<nbobjs; k++)
848                if (!groupids[k] && !hwloc_compare_values(VALUE(j, k), min_distance, accuracy)) {
849  	      groupids[k] = groupid;
850  	      size++;
851  	      if (newfirstfound == (unsigned)-1)
852  		newfirstfound = k;
853  	      if (i == j)
854  		hwloc_debug("  object %u is minimally connected to %u\n", k, i);
855  	      else
856  	        hwloc_debug("  object %u is minimally connected to %u through %u\n", k, i, j);
857  	    }
858        firstfound = newfirstfound;
859      }
860      if (size == 1) {
861        groupids[i] = 0;
862        skipped++;
863        continue;
864      }
865      groupid++;
866      if (verbose)
867        fprintf(stderr, " Found transitive graph with %u objects with minimal distance %llu accuracy %f\n",
868  	      size, (unsigned long long) min_distance, accuracy);
869    }
870    if (groupid == 2 && !skipped)
871      return 0;
872    return groupid-1;
873  }
874  static int
875  hwloc__check_grouping_matrix(unsigned nbobjs, uint64_t *_values, float accuracy, int verbose)
876  {
877    unsigned i,j;
878    for(i=0; i<nbobjs; i++) {
879      for(j=i+1; j<nbobjs; j++) {
880        if (hwloc_compare_values(VALUE(i, j), VALUE(j, i), accuracy)) {
881  	if (verbose)
882  	  fprintf(stderr, " Distance matrix asymmetric ([%u,%u]=%llu != [%u,%u]=%llu), aborting\n",
883  		  i, j, (unsigned long long) VALUE(i, j), j, i, (unsigned long long) VALUE(j, i));
884  	return -1;
885        }
886        if (hwloc_compare_values(VALUE(i, j), VALUE(i, i), accuracy) <= 0) {
887  	if (verbose)
888  	  fprintf(stderr, " Distance to self not strictly minimal ([%u,%u]=%llu <= [%u,%u]=%llu), aborting\n",
889  		  i, j, (unsigned long long) VALUE(i, j), i, i, (unsigned long long) VALUE(i, i));
890  	return -1;
891        }
892      }
893    }
894    return 0;
895  }
896  static void
897  hwloc__groups_by_distances(struct hwloc_topology *topology,
898  			   unsigned nbobjs,
899  			   struct hwloc_obj **objs,
900  			   uint64_t *_values,
901  			   unsigned long kind,
902  			   unsigned nbaccuracies,
903  			   float *accuracies,
904  			   int needcheck)
905  {
906    unsigned *groupids;
907    unsigned nbgroups = 0;
908    unsigned i,j;
909    int verbose = topology->grouping_verbose;
910    hwloc_obj_t *groupobjs;
911    unsigned * groupsizes;
912    uint64_t *groupvalues;
913    unsigned failed = 0;
914    if (nbobjs <= 2)
915        return;
916    if (!(kind & HWLOC_DISTANCES_KIND_MEANS_LATENCY))
917      return;
918    groupids = malloc(nbobjs * sizeof(*groupids));
919    if (!groupids)
920      return;
921    for(i=0; i<nbaccuracies; i++) {
922      if (verbose)
923        fprintf(stderr, "Trying to group %u %s objects according to physical distances with accuracy %f\n",
924  	      nbobjs, hwloc_obj_type_string(objs[0]->type), accuracies[i]);
925      if (needcheck && hwloc__check_grouping_matrix(nbobjs, _values, accuracies[i], verbose) < 0)
926        continue;
927      nbgroups = hwloc__find_groups_by_min_distance(nbobjs, _values, accuracies[i], groupids, verbose);
928      if (nbgroups)
929        break;
930    }
931    if (!nbgroups)
932      goto out_with_groupids;
933    groupobjs = malloc(nbgroups * sizeof(*groupobjs));
934    groupsizes = malloc(nbgroups * sizeof(*groupsizes));
935    groupvalues = malloc(nbgroups * nbgroups * sizeof(*groupvalues));
936    if (!groupobjs || !groupsizes || !groupvalues)
937      goto out_with_groups;
938        memset(&(groupsizes[0]), 0, sizeof(groupsizes[0]) * nbgroups);
939        for(i=0; i<nbgroups; i++) {
940            hwloc_obj_t group_obj, res_obj;
941            group_obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
942            group_obj->cpuset = hwloc_bitmap_alloc();
943            group_obj->attr->group.kind = HWLOC_GROUP_KIND_DISTANCE;
944            group_obj->attr->group.subkind = topology->grouping_next_subkind;
945            for (j=0; j<nbobjs; j++)
946  	    if (groupids[j] == i+1) {
947  	      hwloc_obj_add_other_obj_sets(group_obj, objs[j]);
948                groupsizes[i]++;
949              }
950            hwloc_debug_1arg_bitmap("adding Group object with %u objects and cpuset %s\n",
951                                    groupsizes[i], group_obj->cpuset);
952            res_obj = hwloc__insert_object_by_cpuset(topology, NULL, group_obj,
953                                                     (kind & HWLOC_DISTANCES_KIND_FROM_USER) ? "distances:fromuser:group" : "distances:group");
954  	  if (!res_obj)
955  	    failed++;
956            groupobjs[i] = res_obj;
957        }
958        topology->grouping_next_subkind++;
959        if (failed)
960  	goto out_with_groups;
961        memset(&(groupvalues[0]), 0, sizeof(groupvalues[0]) * nbgroups * nbgroups);
962  #undef VALUE
963  #define VALUE(i, j) _values[(i) * nbobjs + (j)]
964  #define GROUP_VALUE(i, j) groupvalues[(i) * nbgroups + (j)]
965        for(i=0; i<nbobjs; i++)
966  	if (groupids[i])
967  	  for(j=0; j<nbobjs; j++)
968  	    if (groupids[j])
969                  GROUP_VALUE(groupids[i]-1, groupids[j]-1) += VALUE(i, j);
970        for(i=0; i<nbgroups; i++)
971            for(j=0; j<nbgroups; j++) {
972                unsigned groupsize = groupsizes[i]*groupsizes[j];
973                GROUP_VALUE(i, j) /= groupsize;
974            }
975  #ifdef HWLOC_DEBUG
976        hwloc_debug("%s", "generated new distance matrix between groups:\n");
977        hwloc_debug("%s", "  index");
978        for(j=0; j<nbgroups; j++)
979  	hwloc_debug(" % 5d", (int) j); &bsol;* print index because os_index is -1 for Groups */
980        hwloc_debug("%s", "\n");
981        for(i=0; i<nbgroups; i++) {
982  	hwloc_debug("  % 5d", (int) i);
983  	for(j=0; j<nbgroups; j++)
984  	  hwloc_debug(" %llu", (unsigned long long) GROUP_VALUE(i, j));
985  	hwloc_debug("%s", "\n");
986        }
987  #endif
988        hwloc__groups_by_distances(topology, nbgroups, groupobjs, groupvalues, kind, nbaccuracies, accuracies, 0 &bsol;* no need to check generated matrix */);
989   out_with_groups:
990    free(groupobjs);
991    free(groupsizes);
992    free(groupvalues);
993   out_with_groupids:
994    free(groupids);
995  }
996  static int
997  hwloc__distances_transform_remove_null(struct hwloc_distances_s *distances)
998  {
999    hwloc_uint64_t *values = distances->values;
1000    hwloc_obj_t *objs = distances->objs;
1001    unsigned i, nb, nbobjs = distances->nbobjs;
1002    hwloc_obj_type_t unique_type;
1003    for(i=0, nb=0; i<nbobjs; i++)
1004      if (objs[i])
1005        nb++;
1006    if (nb < 2) {
1007      errno = EINVAL;
1008      return -1;
1009    }
1010    if (nb == nbobjs)
1011      return 0;
1012    hwloc_internal_distances_restrict(objs, NULL, NULL, values, nbobjs, nbobjs-nb);
1013    distances->nbobjs = nb;
1014    unique_type = objs[0]->type;
1015    for(i=1; i<nb; i++)
1016      if (objs[i]->type != unique_type) {
1017        unique_type = HWLOC_OBJ_TYPE_NONE;
1018        break;
1019      }
1020    if (unique_type == HWLOC_OBJ_TYPE_NONE)
1021      distances->kind |= HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES;
1022    else
1023      distances->kind &= ~HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES;
1024    return 0;
1025  }
1026  static int
1027  hwloc__distances_transform_links(struct hwloc_distances_s *distances)
1028  {
1029    hwloc_uint64_t divider, *values = distances->values;
1030    unsigned i, nbobjs = distances->nbobjs;
1031    if (!(distances->kind & HWLOC_DISTANCES_KIND_MEANS_BANDWIDTH)) {
1032      errno = EINVAL;
1033      return -1;
1034    }
1035    for(i=0; i<nbobjs; i++)
1036      values[i*nbobjs+i] = 0;
1037    divider = 0;
1038    for(i=0; i<nbobjs*nbobjs; i++)
1039      if (values[i] && (!divider || values[i] < divider))
1040        divider = values[i];
1041    if (!divider)
1042      return 0;
1043    for(i=0; i<nbobjs*nbobjs; i++)
1044      if (values[i]%divider) {
1045        errno = ENOENT;
1046        return -1;
1047      }
1048    for(i=0; i<nbobjs*nbobjs; i++)
1049      values[i] /= divider;
1050    return 0;
1051  }
1052  static __hwloc_inline int is_nvswitch(hwloc_obj_t obj)
1053  {
1054    return obj && obj->subtype && !strcmp(obj->subtype, "NVSwitch");
1055  }
1056  static int
1057  hwloc__distances_transform_merge_switch_ports(hwloc_topology_t topology,
1058                                                struct hwloc_distances_s *distances)
1059  {
1060    struct hwloc_internal_distances_s *dist = hwloc__internal_distances_from_public(topology, distances);
1061    hwloc_obj_t *objs = distances->objs;
1062    hwloc_uint64_t *values = distances->values;
1063    unsigned first, i, j, nbobjs = distances->nbobjs;
1064    if (strcmp(dist->name, "NVLinkBandwidth")) {
1065      errno = EINVAL;
1066      return -1;
1067    }
1068    first = (unsigned) -1;
1069    for(i=0; i<nbobjs; i++)
1070      if (is_nvswitch(objs[i])) {
1071        first = i;
1072        break;
1073      }
1074    if (first == (unsigned)-1) {
1075      errno = ENOENT;
1076      return -1;
1077    }
1078    for(j=i+1; j<nbobjs; j++) {
1079      if (is_nvswitch(objs[j])) {
1080        unsigned k;
1081        for(k=0; k<nbobjs; k++) {
1082          if (k==i || k==j)
1083            continue;
1084          values[k*nbobjs+i] += values[k*nbobjs+j];
1085          values[k*nbobjs+j] = 0;
1086          values[i*nbobjs+k] += values[j*nbobjs+k];
1087          values[j*nbobjs+k] = 0;
1088        }
1089        values[i*nbobjs+i] += values[j*nbobjs+j];
1090        values[j*nbobjs+j] = 0;
1091      }
1092      objs[j] = NULL;
1093    }
1094    return 0;
1095  }
1096  static int
1097  hwloc__distances_transform_transitive_closure(hwloc_topology_t topology,
1098                                                struct hwloc_distances_s *distances)
1099  {
1100    struct hwloc_internal_distances_s *dist = hwloc__internal_distances_from_public(topology, distances);
1101    hwloc_obj_t *objs = distances->objs;
1102    hwloc_uint64_t *values = distances->values;
1103    unsigned nbobjs = distances->nbobjs;
1104    unsigned i, j, k;
1105    if (strcmp(dist->name, "NVLinkBandwidth")) {
1106      errno = EINVAL;
1107      return -1;
1108    }
1109    for(i=0; i<nbobjs; i++) {
1110      hwloc_uint64_t bw_i2sw = 0;
1111      if (is_nvswitch(objs[i]))
1112        continue;
1113      for(k=0; k<nbobjs; k++)
1114        if (is_nvswitch(objs[k]))
1115          bw_i2sw += values[i*nbobjs+k];
1116      for(j=0; j<nbobjs; j++) {
1117        hwloc_uint64_t bw_sw2j = 0;
1118        if (i == j || is_nvswitch(objs[j]))
1119          continue;
1120        for(k=0; k<nbobjs; k++)
1121          if (is_nvswitch(objs[k]))
1122            bw_sw2j += values[k*nbobjs+j];
1123        values[i*nbobjs+j] = bw_i2sw > bw_sw2j ? bw_sw2j : bw_i2sw;
1124      }
1125    }
1126    return 0;
1127  }
1128  int
1129  hwloc_distances_transform(hwloc_topology_t topology,
1130                            struct hwloc_distances_s *distances,
1131                            enum hwloc_distances_transform_e transform,
1132                            void *transform_attr,
1133                            unsigned long flags)
1134  {
1135    if (flags || transform_attr) {
1136      errno = EINVAL;
1137      return -1;
1138    }
1139    switch (transform) {
1140    case HWLOC_DISTANCES_TRANSFORM_REMOVE_NULL:
1141      return hwloc__distances_transform_remove_null(distances);
1142    case HWLOC_DISTANCES_TRANSFORM_LINKS:
1143      return hwloc__distances_transform_links(distances);
1144    case HWLOC_DISTANCES_TRANSFORM_MERGE_SWITCH_PORTS:
1145    {
1146      int err;
1147      err = hwloc__distances_transform_merge_switch_ports(topology, distances);
1148      if (!err)
1149        err = hwloc__distances_transform_remove_null(distances);
1150      return err;
1151    }
1152    case HWLOC_DISTANCES_TRANSFORM_TRANSITIVE_CLOSURE:
1153      return hwloc__distances_transform_transitive_closure(topology, distances);
1154    default:
1155      errno = EINVAL;
1156      return -1;
1157    }
1158  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-SubmitResult.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-distances.c</div>
                <div class="column column_space"><pre><code>17      inline void done() { elapsed = Chrono::steadyMSecs() - m_start; }
18      int64_t reqId           = 0;
19      int64_t seq             = 0;
20      uint32_t backend        = 0;
21      uint64_t actualDiff     = 0;
22      uint64_t diff           = 0;
23      uint64_t elapsed        = 0;
24  private:
25      uint64_t m_start        = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>311        different_types[i] = objs[i]->type;
312    }
313    dist->nbobjs = nbobjs;
314    dist->objs = objs;
315    dist->iflags |= HWLOC_INTERNAL_DIST_FLAG_OBJS_VALID;
316    dist->indexes = indexes;
317    dist->unique_type = unique_type;
318    dist->different_types = different_types;
319    dist->values = values;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    