
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.949182501104729%, Tokens: 8</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-delta_palettization_enc.c</h3>
            <pre><code>1  #include "./delta_palettization_enc.h"
2  #ifdef WEBP_EXPERIMENTAL_FEATURES
3  #include "../webp/types.h"
4  #include "../dsp/lossless.h"
5  #define MK_COL(r, g, b) (((r) << 16) + ((g) << 8) + (b))
6  #define DELTA_PALETTE_SIZE 226
7  static const uint32_t kDeltaPalette[DELTA_PALETTE_SIZE] = {
8    MK_COL(0u, 0u, 0u),
9    MK_COL(255u, 255u, 255u),
10    MK_COL(1u, 1u, 1u),
11    MK_COL(254u, 254u, 254u),
12    MK_COL(2u, 2u, 2u),
13    MK_COL(4u, 4u, 4u),
14    MK_COL(252u, 252u, 252u),
15    MK_COL(250u, 0u, 0u),
16    MK_COL(0u, 250u, 0u),
17    MK_COL(0u, 0u, 250u),
18    MK_COL(6u, 0u, 0u),
19    MK_COL(0u, 6u, 0u),
20    MK_COL(0u, 0u, 6u),
21    MK_COL(0u, 0u, 248u),
22    MK_COL(0u, 0u, 8u),
23    MK_COL(0u, 248u, 0u),
24    MK_COL(0u, 248u, 248u),
25    MK_COL(0u, 248u, 8u),
26    MK_COL(0u, 8u, 0u),
27    MK_COL(0u, 8u, 248u),
28    MK_COL(0u, 8u, 8u),
29    MK_COL(8u, 8u, 8u),
30    MK_COL(248u, 0u, 0u),
31    MK_COL(248u, 0u, 248u),
32    MK_COL(248u, 0u, 8u),
33    MK_COL(248u, 248u, 0u),
34    MK_COL(248u, 8u, 0u),
35    MK_COL(8u, 0u, 0u),
36    MK_COL(8u, 0u, 248u),
37    MK_COL(8u, 0u, 8u),
38    MK_COL(8u, 248u, 0u),
39    MK_COL(8u, 8u, 0u),
40    MK_COL(23u, 23u, 23u),
41    MK_COL(13u, 13u, 13u),
42    MK_COL(232u, 232u, 232u),
43    MK_COL(244u, 244u, 244u),
44    MK_COL(245u, 245u, 250u),
45    MK_COL(50u, 50u, 50u),
46    MK_COL(204u, 204u, 204u),
47    MK_COL(236u, 236u, 236u),
48    MK_COL(16u, 16u, 16u),
49    MK_COL(240u, 16u, 16u),
50    MK_COL(16u, 240u, 16u),
51    MK_COL(240u, 240u, 16u),
52    MK_COL(16u, 16u, 240u),
53    MK_COL(240u, 16u, 240u),
54    MK_COL(16u, 240u, 240u),
55    MK_COL(240u, 240u, 240u),
56    MK_COL(0u, 0u, 232u),
57    MK_COL(0u, 232u, 0u),
58    MK_COL(232u, 0u, 0u),
59    MK_COL(0u, 0u, 24u),
60    MK_COL(0u, 24u, 0u),
61    MK_COL(24u, 0u, 0u),
62    MK_COL(32u, 32u, 32u),
63    MK_COL(224u, 32u, 32u),
64    MK_COL(32u, 224u, 32u),
65    MK_COL(224u, 224u, 32u),
66    MK_COL(32u, 32u, 224u),
67    MK_COL(224u, 32u, 224u),
68    MK_COL(32u, 224u, 224u),
69    MK_COL(224u, 224u, 224u),
70    MK_COL(0u, 0u, 176u),
71    MK_COL(0u, 0u, 80u),
72    MK_COL(0u, 176u, 0u),
73    MK_COL(0u, 176u, 176u),
74    MK_COL(0u, 176u, 80u),
75    MK_COL(0u, 80u, 0u),
76    MK_COL(0u, 80u, 176u),
77    MK_COL(0u, 80u, 80u),
78    MK_COL(176u, 0u, 0u),
79    MK_COL(176u, 0u, 176u),
80    MK_COL(176u, 0u, 80u),
81    MK_COL(176u, 176u, 0u),
82    MK_COL(176u, 80u, 0u),
83    MK_COL(80u, 0u, 0u),
84    MK_COL(80u, 0u, 176u),
85    MK_COL(80u, 0u, 80u),
86    MK_COL(80u, 176u, 0u),
87    MK_COL(80u, 80u, 0u),
88    MK_COL(0u, 0u, 152u),
89    MK_COL(0u, 0u, 104u),
90    MK_COL(0u, 152u, 0u),
91    MK_COL(0u, 152u, 152u),
92    MK_COL(0u, 152u, 104u),
93    MK_COL(0u, 104u, 0u),
94    MK_COL(0u, 104u, 152u),
95    MK_COL(0u, 104u, 104u),
96    MK_COL(152u, 0u, 0u),
97    MK_COL(152u, 0u, 152u),
98    MK_COL(152u, 0u, 104u),
99    MK_COL(152u, 152u, 0u),
100    MK_COL(152u, 104u, 0u),
101    MK_COL(104u, 0u, 0u),
102    MK_COL(104u, 0u, 152u),
103    MK_COL(104u, 0u, 104u),
104    MK_COL(104u, 152u, 0u),
105    MK_COL(104u, 104u, 0u),
106    MK_COL(216u, 216u, 216u),
107    MK_COL(216u, 216u, 40u),
108    MK_COL(216u, 216u, 176u),
109    MK_COL(216u, 216u, 80u),
110    MK_COL(216u, 40u, 216u),
111    MK_COL(216u, 40u, 40u),
112    MK_COL(216u, 40u, 176u),
113    MK_COL(216u, 40u, 80u),
114    MK_COL(216u, 176u, 216u),
115    MK_COL(216u, 176u, 40u),
116    MK_COL(216u, 176u, 176u),
117    MK_COL(216u, 176u, 80u),
118    MK_COL(216u, 80u, 216u),
119    MK_COL(216u, 80u, 40u),
120    MK_COL(216u, 80u, 176u),
121    MK_COL(216u, 80u, 80u),
122    MK_COL(40u, 216u, 216u),
123    MK_COL(40u, 216u, 40u),
124    MK_COL(40u, 216u, 176u),
125    MK_COL(40u, 216u, 80u),
126    MK_COL(40u, 40u, 216u),
127    MK_COL(40u, 40u, 40u),
128    MK_COL(40u, 40u, 176u),
129    MK_COL(40u, 40u, 80u),
130    MK_COL(40u, 176u, 216u),
131    MK_COL(40u, 176u, 40u),
132    MK_COL(40u, 176u, 176u),
133    MK_COL(40u, 176u, 80u),
134    MK_COL(40u, 80u, 216u),
135    MK_COL(40u, 80u, 40u),
136    MK_COL(40u, 80u, 176u),
137    MK_COL(40u, 80u, 80u),
138    MK_COL(80u, 216u, 216u),
139    MK_COL(80u, 216u, 40u),
140    MK_COL(80u, 216u, 176u),
141    MK_COL(80u, 216u, 80u),
142    MK_COL(80u, 40u, 216u),
143    MK_COL(80u, 40u, 40u),
144    MK_COL(80u, 40u, 176u),
145    MK_COL(80u, 40u, 80u),
146    MK_COL(80u, 176u, 216u),
147    MK_COL(80u, 176u, 40u),
148    MK_COL(80u, 176u, 176u),
149    MK_COL(80u, 176u, 80u),
150    MK_COL(80u, 80u, 216u),
151    MK_COL(80u, 80u, 40u),
152    MK_COL(80u, 80u, 176u),
153    MK_COL(80u, 80u, 80u),
154    MK_COL(0u, 0u, 192u),
155    MK_COL(0u, 0u, 64u),
156    MK_COL(0u, 0u, 128u),
157    MK_COL(0u, 192u, 0u),
158    MK_COL(0u, 192u, 192u),
159    MK_COL(0u, 192u, 64u),
160    MK_COL(0u, 192u, 128u),
161    MK_COL(0u, 64u, 0u),
162    MK_COL(0u, 64u, 192u),
163    MK_COL(0u, 64u, 64u),
164    MK_COL(0u, 64u, 128u),
165    MK_COL(0u, 128u, 0u),
166    MK_COL(0u, 128u, 192u),
167    MK_COL(0u, 128u, 64u),
168    MK_COL(0u, 128u, 128u),
169    MK_COL(176u, 216u, 216u),
170    MK_COL(176u, 216u, 40u),
171    MK_COL(176u, 216u, 176u),
172    MK_COL(176u, 216u, 80u),
173    MK_COL(176u, 40u, 216u),
174    MK_COL(176u, 40u, 40u),
175    MK_COL(176u, 40u, 176u),
176    MK_COL(176u, 40u, 80u),
177    MK_COL(176u, 176u, 216u),
178    MK_COL(176u, 176u, 40u),
179    MK_COL(176u, 176u, 176u),
180    MK_COL(176u, 176u, 80u),
181    MK_COL(176u, 80u, 216u),
182    MK_COL(176u, 80u, 40u),
183    MK_COL(176u, 80u, 176u),
184    MK_COL(176u, 80u, 80u),
185    MK_COL(192u, 0u, 0u),
186    MK_COL(192u, 0u, 192u),
187    MK_COL(192u, 0u, 64u),
188    MK_COL(192u, 0u, 128u),
189    MK_COL(192u, 192u, 0u),
190    MK_COL(192u, 192u, 192u),
191    MK_COL(192u, 192u, 64u),
192    MK_COL(192u, 192u, 128u),
193    MK_COL(192u, 64u, 0u),
194    MK_COL(192u, 64u, 192u),
195    MK_COL(192u, 64u, 64u),
196    MK_COL(192u, 64u, 128u),
197    MK_COL(192u, 128u, 0u),
198    MK_COL(192u, 128u, 192u),
199    MK_COL(192u, 128u, 64u),
200    MK_COL(192u, 128u, 128u),
201    MK_COL(64u, 0u, 0u),
202    MK_COL(64u, 0u, 192u),
203    MK_COL(64u, 0u, 64u),
204    MK_COL(64u, 0u, 128u),
205    MK_COL(64u, 192u, 0u),
206    MK_COL(64u, 192u, 192u),
207    MK_COL(64u, 192u, 64u),
208    MK_COL(64u, 192u, 128u),
209    MK_COL(64u, 64u, 0u),
210    MK_COL(64u, 64u, 192u),
211    MK_COL(64u, 64u, 64u),
212    MK_COL(64u, 64u, 128u),
213    MK_COL(64u, 128u, 0u),
214    MK_COL(64u, 128u, 192u),
215    MK_COL(64u, 128u, 64u),
216    MK_COL(64u, 128u, 128u),
217    MK_COL(128u, 0u, 0u),
218    MK_COL(128u, 0u, 192u),
219    MK_COL(128u, 0u, 64u),
220    MK_COL(128u, 0u, 128u),
221    MK_COL(128u, 192u, 0u),
222    MK_COL(128u, 192u, 192u),
223    MK_COL(128u, 192u, 64u),
224    MK_COL(128u, 192u, 128u),
225    MK_COL(128u, 64u, 0u),
226    MK_COL(128u, 64u, 192u),
227    MK_COL(128u, 64u, 64u),
228    MK_COL(128u, 64u, 128u),
229    MK_COL(128u, 128u, 0u),
230    MK_COL(128u, 128u, 192u),
231    MK_COL(128u, 128u, 64u),
232    MK_COL(128u, 128u, 128u),
233  };
234  #undef MK_COL
235  static WEBP_INLINE void AddPixelsEq(uint32_t* a, uint32_t b) {
236    const uint32_t alpha_and_green = (*a & 0xff00ff00u) + (b & 0xff00ff00u);
237    const uint32_t red_and_blue = (*a & 0x00ff00ffu) + (b & 0x00ff00ffu);
238    *a = (alpha_and_green & 0xff00ff00u) | (red_and_blue & 0x00ff00ffu);
239  }
240  static WEBP_INLINE uint32_t Clip255(uint32_t a) {
241    if (a < 256) {
242      return a;
243    }
244    return ~a >> 24;
245  }
246  static WEBP_INLINE int Square(int x) {
247    return x * x;
248  }
249  static WEBP_INLINE uint32_t Intensity(uint32_t a) {
250    return
251        30 * ((a >> 16) & 0xff) +
252        59 * ((a >>  8) & 0xff) +
253        11 * ((a >>  0) & 0xff);
254  }
255  static uint32_t CalcDist(uint32_t predicted_value, uint32_t actual_value,
256                           uint32_t palette_entry) {
257    int i;
258    uint32_t distance = 0;
259    AddPixelsEq(&predicted_value, palette_entry);
260    for (i = 0; i < 32; i += 8) {
261      const int32_t av = (actual_value >> i) & 0xff;
262      const int32_t pv = (predicted_value >> i) & 0xff;
263      distance += Square(pv - av);
<span onclick='openModal()' class='match'>264    }
265    distance *= 1000u;
266    distance += Square(Intensity(predicted_value)
267                       - Intensity(actual_value));
268    return distance;
269  }
270  static uint32_t Predict(int x, int y, uint32_t* image) {
</span>271    const uint32_t t = (y == 0) ? ARGB_BLACK : image[x];
272    const uint32_t l = (x == 0) ? ARGB_BLACK : image[x - 1];
273    const uint32_t p =
274        (((((t >> 24) & 0xff) + ((l >> 24) & 0xff)) / 2) << 24) +
275        (((((t >> 16) & 0xff) + ((l >> 16) & 0xff)) / 2) << 16) +
276        (((((t >>  8) & 0xff) + ((l >>  8) & 0xff)) / 2) <<  8) +
277        (((((t >>  0) & 0xff) + ((l >>  0) & 0xff)) / 2) <<  0);
278    if (x == 0 && y == 0) return ARGB_BLACK;
279    if (x == 0) return t;
280    if (y == 0) return l;
281    return p;
282  }
283  static WEBP_INLINE int AddSubtractComponentFullWithCoefficient(
284      int a, int b, int c) {
285    return Clip255(a + ((b - c) >> 2));
286  }
287  static WEBP_INLINE uint32_t ClampedAddSubtractFullWithCoefficient(
288      uint32_t c0, uint32_t c1, uint32_t c2) {
289    const int a = AddSubtractComponentFullWithCoefficient(
290        c0 >> 24, c1 >> 24, c2 >> 24);
291    const int r = AddSubtractComponentFullWithCoefficient((c0 >> 16) & 0xff,
292                                                         (c1 >> 16) & 0xff,
293                                                         (c2 >> 16) & 0xff);
294    const int g = AddSubtractComponentFullWithCoefficient((c0 >> 8) & 0xff,
295                                                         (c1 >> 8) & 0xff,
296                                                         (c2 >> 8) & 0xff);
297    const int b = AddSubtractComponentFullWithCoefficient(
298        c0 & 0xff, c1 & 0xff, c2 & 0xff);
299    return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
300  }
301  static int FindBestPaletteEntry(uint32_t src, uint32_t predicted_value,
302                                  const uint32_t palette[], int palette_size) {
303    int i;
304    int idx = 0;
305    uint32_t best_distance = CalcDist(predicted_value, src, palette[0]);
306    for (i = 1; i < palette_size; ++i) {
307      const uint32_t distance = CalcDist(predicted_value, src, palette[i]);
308      if (distance < best_distance) {
309        best_distance = distance;
310        idx = i;
311      }
312    }
313    return idx;
314  }
315  static void ApplyBestPaletteEntry(int x, int y,
316                                    uint32_t new_value, uint32_t palette_value,
317                                    uint32_t* src, int src_stride,
318                                    uint32_t* new_image) {
319    AddPixelsEq(&new_value, palette_value);
320    if (x > 0) {
321      src[x - 1] = ClampedAddSubtractFullWithCoefficient(src[x - 1],
322                                                         new_value, src[x]);
323    }
324    if (y > 0) {
325      src[x - src_stride] =
326          ClampedAddSubtractFullWithCoefficient(src[x - src_stride],
327                                                new_value, src[x]);
328    }
329    new_image[x] = new_value;
330  }
331  static WebPEncodingError ApplyDeltaPalette(uint32_t* src, uint32_t* dst,
332                                             uint32_t src_stride,
333                                             uint32_t dst_stride,
334                                             const uint32_t* palette,
335                                             int palette_size,
336                                             int width, int height,
337                                             int num_passes) {
338    int x, y;
339    WebPEncodingError err = VP8_ENC_OK;
340    uint32_t* new_image = (uint32_t*)WebPSafeMalloc(width, sizeof(*new_image));
341    uint8_t* const tmp_row = (uint8_t*)WebPSafeMalloc(width, sizeof(*tmp_row));
342    if (new_image == NULL || tmp_row == NULL) {
343      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
344      goto Error;
345    }
346    while (num_passes--) {
347      uint32_t* cur_src = src;
348      uint32_t* cur_dst = dst;
349      for (y = 0; y < height; ++y) {
350        for (x = 0; x < width; ++x) {
351          const uint32_t predicted_value = Predict(x, y, new_image);
352          tmp_row[x] = FindBestPaletteEntry(cur_src[x], predicted_value,
353                                            palette, palette_size);
354          ApplyBestPaletteEntry(x, y, predicted_value, palette[tmp_row[x]],
355                                cur_src, src_stride, new_image);
356        }
357        for (x = 0; x < width; ++x) {
358          cur_dst[x] = palette[tmp_row[x]];
359        }
360        cur_src += src_stride;
361        cur_dst += dst_stride;
362      }
363    }
364   Error:
365    WebPSafeFree(new_image);
366    WebPSafeFree(tmp_row);
367    return err;
368  }
369  WebPEncodingError WebPSearchOptimalDeltaPalette(VP8LEncoder* const enc) {
370    const WebPPicture* const pic = enc->pic_;
371    uint32_t* src = pic->argb;
372    uint32_t* dst = enc->argb_;
373    const int width = pic->width;
374    const int height = pic->height;
375    WebPEncodingError err = VP8_ENC_OK;
376    memcpy(enc->palette_, kDeltaPalette, sizeof(kDeltaPalette));
377    enc->palette_[DELTA_PALETTE_SIZE - 1] = src[0] - 0xff000000u;
378    enc->palette_size_ = DELTA_PALETTE_SIZE;
379    err = ApplyDeltaPalette(src, dst, pic->argb_stride, enc->current_width_,
380                            enc->palette_, enc->palette_size_,
381                            width, height, 2);
382    if (err != VP8_ENC_OK) goto Error;
383   Error:
384    return err;
385  }
386  #else  
387  WebPEncodingError WebPSearchOptimalDeltaPalette(VP8LEncoder* const enc) {
388    (void)enc;
389    return VP8_ENC_ERROR_INVALID_CONFIGURATION;
390  }
391  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_dec.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include "src/dec/alphai_dec.h"
3  #include "src/dec/vp8li_dec.h"
4  #include "src/dsp/dsp.h"
5  #include "src/dsp/lossless.h"
6  #include "src/dsp/lossless_common.h"
7  #include "src/dsp/yuv.h"
8  #include "src/utils/endian_inl_utils.h"
9  #include "src/utils/huffman_utils.h"
10  #include "src/utils/utils.h"
11  #define NUM_ARGB_CACHE_ROWS          16
12  static const int kCodeLengthLiterals = 16;
13  static const int kCodeLengthRepeatCode = 16;
14  static const uint8_t kCodeLengthExtraBits[3] = { 2, 3, 7 };
15  static const uint8_t kCodeLengthRepeatOffsets[3] = { 3, 3, 11 };
16  typedef enum {
17    GREEN = 0,
18    RED   = 1,
19    BLUE  = 2,
20    ALPHA = 3,
21    DIST  = 4
22  } HuffIndex;
23  static const uint16_t kAlphabetSize[HUFFMAN_CODES_PER_META_CODE] = {
24    NUM_LITERAL_CODES + NUM_LENGTH_CODES,
25    NUM_LITERAL_CODES, NUM_LITERAL_CODES, NUM_LITERAL_CODES,
26    NUM_DISTANCE_CODES
27  };
28  static const uint8_t kLiteralMap[HUFFMAN_CODES_PER_META_CODE] = {
29    0, 1, 1, 1, 0
30  };
31  #define NUM_CODE_LENGTH_CODES       19
32  static const uint8_t kCodeLengthCodeOrder[NUM_CODE_LENGTH_CODES] = {
33    17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
34  };
35  #define CODE_TO_PLANE_CODES        120
36  static const uint8_t kCodeToPlane[CODE_TO_PLANE_CODES] = {
37    0x18, 0x07, 0x17, 0x19, 0x28, 0x06, 0x27, 0x29, 0x16, 0x1a,
38    0x26, 0x2a, 0x38, 0x05, 0x37, 0x39, 0x15, 0x1b, 0x36, 0x3a,
39    0x25, 0x2b, 0x48, 0x04, 0x47, 0x49, 0x14, 0x1c, 0x35, 0x3b,
40    0x46, 0x4a, 0x24, 0x2c, 0x58, 0x45, 0x4b, 0x34, 0x3c, 0x03,
41    0x57, 0x59, 0x13, 0x1d, 0x56, 0x5a, 0x23, 0x2d, 0x44, 0x4c,
42    0x55, 0x5b, 0x33, 0x3d, 0x68, 0x02, 0x67, 0x69, 0x12, 0x1e,
43    0x66, 0x6a, 0x22, 0x2e, 0x54, 0x5c, 0x43, 0x4d, 0x65, 0x6b,
44    0x32, 0x3e, 0x78, 0x01, 0x77, 0x79, 0x53, 0x5d, 0x11, 0x1f,
45    0x64, 0x6c, 0x42, 0x4e, 0x76, 0x7a, 0x21, 0x2f, 0x75, 0x7b,
46    0x31, 0x3f, 0x63, 0x6d, 0x52, 0x5e, 0x00, 0x74, 0x7c, 0x41,
47    0x4f, 0x10, 0x20, 0x62, 0x6e, 0x30, 0x73, 0x7d, 0x51, 0x5f,
48    0x40, 0x72, 0x7e, 0x61, 0x6f, 0x50, 0x71, 0x7f, 0x60, 0x70
49  };
50  #define FIXED_TABLE_SIZE (630 * 3 + 410)
51  static const uint16_t kTableSize[12] = {
52    FIXED_TABLE_SIZE + 654,
53    FIXED_TABLE_SIZE + 656,
54    FIXED_TABLE_SIZE + 658,
55    FIXED_TABLE_SIZE + 662,
56    FIXED_TABLE_SIZE + 670,
57    FIXED_TABLE_SIZE + 686,
58    FIXED_TABLE_SIZE + 718,
59    FIXED_TABLE_SIZE + 782,
60    FIXED_TABLE_SIZE + 912,
61    FIXED_TABLE_SIZE + 1168,
62    FIXED_TABLE_SIZE + 1680,
63    FIXED_TABLE_SIZE + 2704
64  };
65  static int DecodeImageStream(int xsize, int ysize,
66                               int is_level0,
67                               VP8LDecoder* const dec,
68                               uint32_t** const decoded_data);
69  int VP8LCheckSignature(const uint8_t* const data, size_t size) {
70    return (size >= VP8L_FRAME_HEADER_SIZE &&
71            data[0] == VP8L_MAGIC_BYTE &&
72            (data[4] >> 5) == 0);  
73  }
74  static int ReadImageInfo(VP8LBitReader* const br,
75                           int* const width, int* const height,
76                           int* const has_alpha) {
77    if (VP8LReadBits(br, 8) != VP8L_MAGIC_BYTE) return 0;
78    *width = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;
79    *height = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;
80    *has_alpha = VP8LReadBits(br, 1);
81    if (VP8LReadBits(br, VP8L_VERSION_BITS) != 0) return 0;
82    return !br->eos_;
83  }
84  int VP8LGetInfo(const uint8_t* data, size_t data_size,
85                  int* const width, int* const height, int* const has_alpha) {
86    if (data == NULL || data_size < VP8L_FRAME_HEADER_SIZE) {
87      return 0;         
88    } else if (!VP8LCheckSignature(data, data_size)) {
89      return 0;         
90    } else {
91      int w, h, a;
92      VP8LBitReader br;
93      VP8LInitBitReader(&br, data, data_size);
94      if (!ReadImageInfo(&br, &w, &h, &a)) {
95        return 0;
96      }
97      if (width != NULL) *width = w;
98      if (height != NULL) *height = h;
99      if (has_alpha != NULL) *has_alpha = a;
100      return 1;
101    }
102  }
103  static WEBP_INLINE int GetCopyDistance(int distance_symbol,
104                                         VP8LBitReader* const br) {
105    int extra_bits, offset;
106    if (distance_symbol < 4) {
107      return distance_symbol + 1;
<span onclick='openModal()' class='match'>108    }
109    extra_bits = (distance_symbol - 2) >> 1;
110    offset = (2 + (distance_symbol & 1)) << extra_bits;
111    return offset + VP8LReadBits(br, extra_bits) + 1;
112  }
113  static WEBP_INLINE int GetCopyLength(int length_symbol,
</span>114                                       VP8LBitReader* const br) {
115    return GetCopyDistance(length_symbol, br);
116  }
117  static WEBP_INLINE int PlaneCodeToDistance(int xsize, int plane_code) {
118    if (plane_code > CODE_TO_PLANE_CODES) {
119      return plane_code - CODE_TO_PLANE_CODES;
120    } else {
121      const int dist_code = kCodeToPlane[plane_code - 1];
122      const int yoffset = dist_code >> 4;
123      const int xoffset = 8 - (dist_code & 0xf);
124      const int dist = yoffset * xsize + xoffset;
125      return (dist >= 1) ? dist : 1;  
126    }
127  }
128  static WEBP_INLINE int ReadSymbol(const HuffmanCode* table,
129                                    VP8LBitReader* const br) {
130    int nbits;
131    uint32_t val = VP8LPrefetchBits(br);
132    table += val & HUFFMAN_TABLE_MASK;
133    nbits = table->bits - HUFFMAN_TABLE_BITS;
134    if (nbits > 0) {
135      VP8LSetBitPos(br, br->bit_pos_ + HUFFMAN_TABLE_BITS);
136      val = VP8LPrefetchBits(br);
137      table += table->value;
138      table += val & ((1 << nbits) - 1);
139    }
140    VP8LSetBitPos(br, br->bit_pos_ + table->bits);
141    return table->value;
142  }
143  #define BITS_SPECIAL_MARKER 0x100  
144  #define PACKED_NON_LITERAL_CODE 0  
145  static WEBP_INLINE int ReadPackedSymbols(const HTreeGroup* group,
146                                           VP8LBitReader* const br,
147                                           uint32_t* const dst) {
148    const uint32_t val = VP8LPrefetchBits(br) & (HUFFMAN_PACKED_TABLE_SIZE - 1);
149    const HuffmanCode32 code = group->packed_table[val];
150    assert(group->use_packed_table);
151    if (code.bits < BITS_SPECIAL_MARKER) {
152      VP8LSetBitPos(br, br->bit_pos_ + code.bits);
153      *dst = code.value;
154      return PACKED_NON_LITERAL_CODE;
155    } else {
156      VP8LSetBitPos(br, br->bit_pos_ + code.bits - BITS_SPECIAL_MARKER);
157      assert(code.value >= NUM_LITERAL_CODES);
158      return code.value;
159    }
160  }
161  static int AccumulateHCode(HuffmanCode hcode, int shift,
162                             HuffmanCode32* const huff) {
163    huff->bits += hcode.bits;
164    huff->value |= (uint32_t)hcode.value << shift;
165    assert(huff->bits <= HUFFMAN_TABLE_BITS);
166    return hcode.bits;
167  }
168  static void BuildPackedTable(HTreeGroup* const htree_group) {
169    uint32_t code;
170    for (code = 0; code < HUFFMAN_PACKED_TABLE_SIZE; ++code) {
171      uint32_t bits = code;
172      HuffmanCode32* const huff = &htree_group->packed_table[bits];
173      HuffmanCode hcode = htree_group->htrees[GREEN][bits];
174      if (hcode.value >= NUM_LITERAL_CODES) {
175        huff->bits = hcode.bits + BITS_SPECIAL_MARKER;
176        huff->value = hcode.value;
177      } else {
178        huff->bits = 0;
179        huff->value = 0;
180        bits >>= AccumulateHCode(hcode, 8, huff);
181        bits >>= AccumulateHCode(htree_group->htrees[RED][bits], 16, huff);
182        bits >>= AccumulateHCode(htree_group->htrees[BLUE][bits], 0, huff);
183        bits >>= AccumulateHCode(htree_group->htrees[ALPHA][bits], 24, huff);
184        (void)bits;
185      }
186    }
187  }
188  static int ReadHuffmanCodeLengths(
189      VP8LDecoder* const dec, const int* const code_length_code_lengths,
190      int num_symbols, int* const code_lengths) {
191    int ok = 0;
192    VP8LBitReader* const br = &dec->br_;
193    int symbol;
194    int max_symbol;
195    int prev_code_len = DEFAULT_CODE_LENGTH;
196    HuffmanCode table[1 << LENGTHS_TABLE_BITS];
197    if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,
198                               code_length_code_lengths,
199                               NUM_CODE_LENGTH_CODES)) {
200      goto End;
201    }
202    if (VP8LReadBits(br, 1)) {    
203      const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);
204      max_symbol = 2 + VP8LReadBits(br, length_nbits);
205      if (max_symbol > num_symbols) {
206        goto End;
207      }
208    } else {
209      max_symbol = num_symbols;
210    }
211    symbol = 0;
212    while (symbol < num_symbols) {
213      const HuffmanCode* p;
214      int code_len;
215      if (max_symbol-- == 0) break;
216      VP8LFillBitWindow(br);
217      p = &table[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];
218      VP8LSetBitPos(br, br->bit_pos_ + p->bits);
219      code_len = p->value;
220      if (code_len < kCodeLengthLiterals) {
221        code_lengths[symbol++] = code_len;
222        if (code_len != 0) prev_code_len = code_len;
223      } else {
224        const int use_prev = (code_len == kCodeLengthRepeatCode);
225        const int slot = code_len - kCodeLengthLiterals;
226        const int extra_bits = kCodeLengthExtraBits[slot];
227        const int repeat_offset = kCodeLengthRepeatOffsets[slot];
228        int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;
229        if (symbol + repeat > num_symbols) {
230          goto End;
231        } else {
232          const int length = use_prev ? prev_code_len : 0;
233          while (repeat-- > 0) code_lengths[symbol++] = length;
234        }
235      }
236    }
237    ok = 1;
238   End:
239    if (!ok) dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
240    return ok;
241  }
242  static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,
243                             int* const code_lengths, HuffmanCode* const table) {
244    int ok = 0;
245    int size = 0;
246    VP8LBitReader* const br = &dec->br_;
247    const int simple_code = VP8LReadBits(br, 1);
248    memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));
249    if (simple_code) {  
250      const int num_symbols = VP8LReadBits(br, 1) + 1;
251      const int first_symbol_len_code = VP8LReadBits(br, 1);
252      int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);
253      code_lengths[symbol] = 1;
254      if (num_symbols == 2) {
255        symbol = VP8LReadBits(br, 8);
256        code_lengths[symbol] = 1;
257      }
258      ok = 1;
259    } else {  
260      int i;
261      int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };
262      const int num_codes = VP8LReadBits(br, 4) + 4;
263      if (num_codes > NUM_CODE_LENGTH_CODES) {
264        dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
265        return 0;
266      }
267      for (i = 0; i < num_codes; ++i) {
268        code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);
269      }
270      ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,
271                                  code_lengths);
272    }
273    ok = ok && !br->eos_;
274    if (ok) {
275      size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,
276                                   code_lengths, alphabet_size);
277    }
278    if (!ok || size == 0) {
279      dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
280      return 0;
281    }
282    return size;
283  }
284  static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,
285                              int color_cache_bits, int allow_recursion) {
286    int i, j;
287    VP8LBitReader* const br = &dec->br_;
288    VP8LMetadata* const hdr = &dec->hdr_;
289    uint32_t* huffman_image = NULL;
290    HTreeGroup* htree_groups = NULL;
291    HuffmanCode* huffman_tables = NULL;
292    HuffmanCode* huffman_table = NULL;
293    int num_htree_groups = 1;
294    int num_htree_groups_max = 1;
295    int max_alphabet_size = 0;
296    int* code_lengths = NULL;
297    const int table_size = kTableSize[color_cache_bits];
298    int* mapping = NULL;
299    int ok = 0;
300    if (allow_recursion && VP8LReadBits(br, 1)) {
301      const int huffman_precision = VP8LReadBits(br, 3) + 2;
302      const int huffman_xsize = VP8LSubSampleSize(xsize, huffman_precision);
303      const int huffman_ysize = VP8LSubSampleSize(ysize, huffman_precision);
304      const int huffman_pixs = huffman_xsize * huffman_ysize;
305      if (!DecodeImageStream(huffman_xsize, huffman_ysize, 0, dec,
306                             &huffman_image)) {
307        goto Error;
308      }
309      hdr->huffman_subsample_bits_ = huffman_precision;
310      for (i = 0; i < huffman_pixs; ++i) {
311        const int group = (huffman_image[i] >> 8) & 0xffff;
312        huffman_image[i] = group;
313        if (group >= num_htree_groups_max) {
314          num_htree_groups_max = group + 1;
315        }
316      }
317      if (num_htree_groups_max > 1000 || num_htree_groups_max > xsize * ysize) {
318        mapping = (int*)WebPSafeMalloc(num_htree_groups_max, sizeof(*mapping));
319        if (mapping == NULL) {
320          dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
321          goto Error;
322        }
323        memset(mapping, 0xff, num_htree_groups_max * sizeof(*mapping));
324        for (num_htree_groups = 0, i = 0; i < huffman_pixs; ++i) {
325          int* const mapped_group = &mapping[huffman_image[i]];
326          if (*mapped_group == -1) *mapped_group = num_htree_groups++;
327          huffman_image[i] = *mapped_group;
328        }
329      } else {
330        num_htree_groups = num_htree_groups_max;
331      }
332    }
333    if (br->eos_) goto Error;
334    for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {
335      int alphabet_size = kAlphabetSize[j];
336      if (j == 0 && color_cache_bits > 0) {
337        alphabet_size += 1 << color_cache_bits;
338      }
339      if (max_alphabet_size < alphabet_size) {
340        max_alphabet_size = alphabet_size;
341      }
342    }
343    code_lengths = (int*)WebPSafeCalloc((uint64_t)max_alphabet_size,
344                                        sizeof(*code_lengths));
345    huffman_tables = (HuffmanCode*)WebPSafeMalloc(num_htree_groups * table_size,
346                                                  sizeof(*huffman_tables));
347    htree_groups = VP8LHtreeGroupsNew(num_htree_groups);
348    if (htree_groups == NULL || code_lengths == NULL || huffman_tables == NULL) {
349      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
350      goto Error;
351    }
352    huffman_table = huffman_tables;
353    for (i = 0; i < num_htree_groups_max; ++i) {
354      if (mapping != NULL && mapping[i] == -1) {
355        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {
356          int alphabet_size = kAlphabetSize[j];
357          if (j == 0 && color_cache_bits > 0) {
358            alphabet_size += (1 << color_cache_bits);
359          }
360          if (!ReadHuffmanCode(alphabet_size, dec, code_lengths, NULL)) {
361            goto Error;
362          }
363        }
364      } else {
365        HTreeGroup* const htree_group =
366            &htree_groups[(mapping == NULL) ? i : mapping[i]];
367        HuffmanCode** const htrees = htree_group->htrees;
368        int size;
369        int total_size = 0;
370        int is_trivial_literal = 1;
371        int max_bits = 0;
372        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {
373          int alphabet_size = kAlphabetSize[j];
374          htrees[j] = huffman_table;
375          if (j == 0 && color_cache_bits > 0) {
376            alphabet_size += (1 << color_cache_bits);
377          }
378          size = ReadHuffmanCode(alphabet_size, dec, code_lengths, huffman_table);
379          if (size == 0) {
380            goto Error;
381          }
382          if (is_trivial_literal && kLiteralMap[j] == 1) {
383            is_trivial_literal = (huffman_table->bits == 0);
384          }
385          total_size += huffman_table->bits;
386          huffman_table += size;
387          if (j <= ALPHA) {
388            int local_max_bits = code_lengths[0];
389            int k;
390            for (k = 1; k < alphabet_size; ++k) {
391              if (code_lengths[k] > local_max_bits) {
392                local_max_bits = code_lengths[k];
393              }
394            }
395            max_bits += local_max_bits;
396          }
397        }
398        htree_group->is_trivial_literal = is_trivial_literal;
399        htree_group->is_trivial_code = 0;
400        if (is_trivial_literal) {
401          const int red = htrees[RED][0].value;
402          const int blue = htrees[BLUE][0].value;
403          const int alpha = htrees[ALPHA][0].value;
404          htree_group->literal_arb = ((uint32_t)alpha << 24) | (red << 16) | blue;
405          if (total_size == 0 && htrees[GREEN][0].value < NUM_LITERAL_CODES) {
406            htree_group->is_trivial_code = 1;
407            htree_group->literal_arb |= htrees[GREEN][0].value << 8;
408          }
409        }
410        htree_group->use_packed_table =
411            !htree_group->is_trivial_code && (max_bits < HUFFMAN_PACKED_BITS);
412        if (htree_group->use_packed_table) BuildPackedTable(htree_group);
413      }
414    }
415    ok = 1;
416    hdr->huffman_image_ = huffman_image;
417    hdr->num_htree_groups_ = num_htree_groups;
418    hdr->htree_groups_ = htree_groups;
419    hdr->huffman_tables_ = huffman_tables;
420   Error:
421    WebPSafeFree(code_lengths);
422    WebPSafeFree(mapping);
423    if (!ok) {
424      WebPSafeFree(huffman_image);
425      WebPSafeFree(huffman_tables);
426      VP8LHtreeGroupsFree(htree_groups);
427    }
428    return ok;
429  }
430  #if !defined(WEBP_REDUCE_SIZE)
431  static int AllocateAndInitRescaler(VP8LDecoder* const dec, VP8Io* const io) {
432    const int num_channels = 4;
433    const int in_width = io->mb_w;
434    const int out_width = io->scaled_width;
435    const int in_height = io->mb_h;
436    const int out_height = io->scaled_height;
437    const uint64_t work_size = 2 * num_channels * (uint64_t)out_width;
438    rescaler_t* work;        
439    const uint64_t scaled_data_size = (uint64_t)out_width;
440    uint32_t* scaled_data;  
441    const uint64_t memory_size = sizeof(*dec->rescaler) +
442                                 work_size * sizeof(*work) +
443                                 scaled_data_size * sizeof(*scaled_data);
444    uint8_t* memory = (uint8_t*)WebPSafeMalloc(memory_size, sizeof(*memory));
445    if (memory == NULL) {
446      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
447      return 0;
448    }
449    assert(dec->rescaler_memory == NULL);
450    dec->rescaler_memory = memory;
451    dec->rescaler = (WebPRescaler*)memory;
452    memory += sizeof(*dec->rescaler);
453    work = (rescaler_t*)memory;
454    memory += work_size * sizeof(*work);
455    scaled_data = (uint32_t*)memory;
456    WebPRescalerInit(dec->rescaler, in_width, in_height, (uint8_t*)scaled_data,
457                     out_width, out_height, 0, num_channels, work);
458    return 1;
459  }
460  #endif   
461  #if !defined(WEBP_REDUCE_SIZE)
462  static int Export(WebPRescaler* const rescaler, WEBP_CSP_MODE colorspace,
463                    int rgba_stride, uint8_t* const rgba) {
464    uint32_t* const src = (uint32_t*)rescaler->dst;
465    const int dst_width = rescaler->dst_width;
466    int num_lines_out = 0;
467    while (WebPRescalerHasPendingOutput(rescaler)) {
468      uint8_t* const dst = rgba + num_lines_out * rgba_stride;
469      WebPRescalerExportRow(rescaler);
470      WebPMultARGBRow(src, dst_width, 1);
471      VP8LConvertFromBGRA(src, dst_width, colorspace, dst);
472      ++num_lines_out;
473    }
474    return num_lines_out;
475  }
476  static int EmitRescaledRowsRGBA(const VP8LDecoder* const dec,
477                                  uint8_t* in, int in_stride, int mb_h,
478                                  uint8_t* const out, int out_stride) {
479    const WEBP_CSP_MODE colorspace = dec->output_->colorspace;
480    int num_lines_in = 0;
481    int num_lines_out = 0;
482    while (num_lines_in < mb_h) {
483      uint8_t* const row_in = in + num_lines_in * in_stride;
484      uint8_t* const row_out = out + num_lines_out * out_stride;
485      const int lines_left = mb_h - num_lines_in;
486      const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);
487      int lines_imported;
488      assert(needed_lines > 0 && needed_lines <= lines_left);
489      WebPMultARGBRows(row_in, in_stride,
490                       dec->rescaler->src_width, needed_lines, 0);
491      lines_imported =
492          WebPRescalerImport(dec->rescaler, lines_left, row_in, in_stride);
493      assert(lines_imported == needed_lines);
494      num_lines_in += lines_imported;
495      num_lines_out += Export(dec->rescaler, colorspace, out_stride, row_out);
496    }
497    return num_lines_out;
498  }
499  #endif   
500  static int EmitRows(WEBP_CSP_MODE colorspace,
501                      const uint8_t* row_in, int in_stride,
502                      int mb_w, int mb_h,
503                      uint8_t* const out, int out_stride) {
504    int lines = mb_h;
505    uint8_t* row_out = out;
506    while (lines-- > 0) {
507      VP8LConvertFromBGRA((const uint32_t*)row_in, mb_w, colorspace, row_out);
508      row_in += in_stride;
509      row_out += out_stride;
510    }
511    return mb_h;  
512  }
513  static void ConvertToYUVA(const uint32_t* const src, int width, int y_pos,
514                            const WebPDecBuffer* const output) {
515    const WebPYUVABuffer* const buf = &output->u.YUVA;
516    WebPConvertARGBToY(src, buf->y + y_pos * buf->y_stride, width);
517    {
518      uint8_t* const u = buf->u + (y_pos >> 1) * buf->u_stride;
519      uint8_t* const v = buf->v + (y_pos >> 1) * buf->v_stride;
520      WebPConvertARGBToUV(src, u, v, width, !(y_pos & 1));
521    }
522    if (buf->a != NULL) {
523      uint8_t* const a = buf->a + y_pos * buf->a_stride;
524  #if defined(WORDS_BIGENDIAN)
525      WebPExtractAlpha((uint8_t*)src + 0, 0, width, 1, a, 0);
526  #else
527      WebPExtractAlpha((uint8_t*)src + 3, 0, width, 1, a, 0);
528  #endif
529    }
530  }
531  static int ExportYUVA(const VP8LDecoder* const dec, int y_pos) {
532    WebPRescaler* const rescaler = dec->rescaler;
533    uint32_t* const src = (uint32_t*)rescaler->dst;
534    const int dst_width = rescaler->dst_width;
535    int num_lines_out = 0;
536    while (WebPRescalerHasPendingOutput(rescaler)) {
537      WebPRescalerExportRow(rescaler);
538      WebPMultARGBRow(src, dst_width, 1);
539      ConvertToYUVA(src, dst_width, y_pos, dec->output_);
540      ++y_pos;
541      ++num_lines_out;
542    }
543    return num_lines_out;
544  }
545  static int EmitRescaledRowsYUVA(const VP8LDecoder* const dec,
546                                  uint8_t* in, int in_stride, int mb_h) {
547    int num_lines_in = 0;
548    int y_pos = dec->last_out_row_;
549    while (num_lines_in < mb_h) {
550      const int lines_left = mb_h - num_lines_in;
551      const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);
552      int lines_imported;
553      WebPMultARGBRows(in, in_stride, dec->rescaler->src_width, needed_lines, 0);
554      lines_imported =
555          WebPRescalerImport(dec->rescaler, lines_left, in, in_stride);
556      assert(lines_imported == needed_lines);
557      num_lines_in += lines_imported;
558      in += needed_lines * in_stride;
559      y_pos += ExportYUVA(dec, y_pos);
560    }
561    return y_pos;
562  }
563  static int EmitRowsYUVA(const VP8LDecoder* const dec,
564                          const uint8_t* in, int in_stride,
565                          int mb_w, int num_rows) {
566    int y_pos = dec->last_out_row_;
567    while (num_rows-- > 0) {
568      ConvertToYUVA((const uint32_t*)in, mb_w, y_pos, dec->output_);
569      in += in_stride;
570      ++y_pos;
571    }
572    return y_pos;
573  }
574  static int SetCropWindow(VP8Io* const io, int y_start, int y_end,
575                           uint8_t** const in_data, int pixel_stride) {
576    assert(y_start < y_end);
577    assert(io->crop_left < io->crop_right);
578    if (y_end > io->crop_bottom) {
579      y_end = io->crop_bottom;  
580    }
581    if (y_start < io->crop_top) {
582      const int delta = io->crop_top - y_start;
583      y_start = io->crop_top;
584      *in_data += delta * pixel_stride;
585    }
586    if (y_start >= y_end) return 0;  
587    *in_data += io->crop_left * sizeof(uint32_t);
588    io->mb_y = y_start - io->crop_top;
589    io->mb_w = io->crop_right - io->crop_left;
590    io->mb_h = y_end - y_start;
591    return 1;  
592  }
593  static WEBP_INLINE int GetMetaIndex(
594      const uint32_t* const image, int xsize, int bits, int x, int y) {
595    if (bits == 0) return 0;
596    return image[xsize * (y >> bits) + (x >> bits)];
597  }
598  static WEBP_INLINE HTreeGroup* GetHtreeGroupForPos(VP8LMetadata* const hdr,
599                                                     int x, int y) {
600    const int meta_index = GetMetaIndex(hdr->huffman_image_, hdr->huffman_xsize_,
601                                        hdr->huffman_subsample_bits_, x, y);
602    assert(meta_index < hdr->num_htree_groups_);
603    return hdr->htree_groups_ + meta_index;
604  }
605  typedef void (*ProcessRowsFunc)(VP8LDecoder* const dec, int row);
606  static void ApplyInverseTransforms(VP8LDecoder* const dec,
607                                     int start_row, int num_rows,
608                                     const uint32_t* const rows) {
609    int n = dec->next_transform_;
610    const int cache_pixs = dec->width_ * num_rows;
611    const int end_row = start_row + num_rows;
612    const uint32_t* rows_in = rows;
613    uint32_t* const rows_out = dec->argb_cache_;
614    while (n-- > 0) {
615      VP8LTransform* const transform = &dec->transforms_[n];
616      VP8LInverseTransform(transform, start_row, end_row, rows_in, rows_out);
617      rows_in = rows_out;
618    }
619    if (rows_in != rows_out) {
620      memcpy(rows_out, rows_in, cache_pixs * sizeof(*rows_out));
621    }
622  }
623  static void ProcessRows(VP8LDecoder* const dec, int row) {
624    const uint32_t* const rows = dec->pixels_ + dec->width_ * dec->last_row_;
625    const int num_rows = row - dec->last_row_;
626    assert(row <= dec->io_->crop_bottom);
627    assert(num_rows <= NUM_ARGB_CACHE_ROWS);
628    if (num_rows > 0) {    
629      VP8Io* const io = dec->io_;
630      uint8_t* rows_data = (uint8_t*)dec->argb_cache_;
631      const int in_stride = io->width * sizeof(uint32_t);  
632      ApplyInverseTransforms(dec, dec->last_row_, num_rows, rows);
633      if (!SetCropWindow(io, dec->last_row_, row, &rows_data, in_stride)) {
634      } else {
635        const WebPDecBuffer* const output = dec->output_;
636        if (WebPIsRGBMode(output->colorspace)) {  
637          const WebPRGBABuffer* const buf = &output->u.RGBA;
638          uint8_t* const rgba = buf->rgba + dec->last_out_row_ * buf->stride;
639          const int num_rows_out =
640  #if !defined(WEBP_REDUCE_SIZE)
641           io->use_scaling ?
642              EmitRescaledRowsRGBA(dec, rows_data, in_stride, io->mb_h,
643                                   rgba, buf->stride) :
644  #endif  
645              EmitRows(output->colorspace, rows_data, in_stride,
646                       io->mb_w, io->mb_h, rgba, buf->stride);
647          dec->last_out_row_ += num_rows_out;
648        } else {                              
649          dec->last_out_row_ = io->use_scaling ?
650              EmitRescaledRowsYUVA(dec, rows_data, in_stride, io->mb_h) :
651              EmitRowsYUVA(dec, rows_data, in_stride, io->mb_w, io->mb_h);
652        }
653        assert(dec->last_out_row_ <= output->height);
654      }
655    }
656    dec->last_row_ = row;
657    assert(dec->last_row_ <= dec->height_);
658  }
659  static int Is8bOptimizable(const VP8LMetadata* const hdr) {
660    int i;
661    if (hdr->color_cache_size_ > 0) return 0;
662    for (i = 0; i < hdr->num_htree_groups_; ++i) {
663      HuffmanCode** const htrees = hdr->htree_groups_[i].htrees;
664      if (htrees[RED][0].bits > 0) return 0;
665      if (htrees[BLUE][0].bits > 0) return 0;
666      if (htrees[ALPHA][0].bits > 0) return 0;
667    }
668    return 1;
669  }
670  static void AlphaApplyFilter(ALPHDecoder* const alph_dec,
671                               int first_row, int last_row,
672                               uint8_t* out, int stride) {
673    if (alph_dec->filter_ != WEBP_FILTER_NONE) {
674      int y;
675      const uint8_t* prev_line = alph_dec->prev_line_;
676      assert(WebPUnfilters[alph_dec->filter_] != NULL);
677      for (y = first_row; y < last_row; ++y) {
678        WebPUnfilters[alph_dec->filter_](prev_line, out, out, stride);
679        prev_line = out;
680        out += stride;
681      }
682      alph_dec->prev_line_ = prev_line;
683    }
684  }
685  static void ExtractPalettedAlphaRows(VP8LDecoder* const dec, int last_row) {
686    ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;
687    const int top_row =
688        (alph_dec->filter_ == WEBP_FILTER_NONE ||
689         alph_dec->filter_ == WEBP_FILTER_HORIZONTAL) ? dec->io_->crop_top
690                                                      : dec->last_row_;
691    const int first_row = (dec->last_row_ < top_row) ? top_row : dec->last_row_;
692    assert(last_row <= dec->io_->crop_bottom);
693    if (last_row > first_row) {
694      const int width = dec->io_->width;
695      uint8_t* out = alph_dec->output_ + width * first_row;
696      const uint8_t* const in =
697        (uint8_t*)dec->pixels_ + dec->width_ * first_row;
698      VP8LTransform* const transform = &dec->transforms_[0];
699      assert(dec->next_transform_ == 1);
700      assert(transform->type_ == COLOR_INDEXING_TRANSFORM);
701      VP8LColorIndexInverseTransformAlpha(transform, first_row, last_row,
702                                          in, out);
703      AlphaApplyFilter(alph_dec, first_row, last_row, out, width);
704    }
705    dec->last_row_ = dec->last_out_row_ = last_row;
706  }
707  static WEBP_INLINE uint32_t Rotate8b(uint32_t V) {
708  #if defined(WORDS_BIGENDIAN)
709    return ((V & 0xff000000u) >> 24) | (V << 8);
710  #else
711    return ((V & 0xffu) << 24) | (V >> 8);
712  #endif
713  }
714  static WEBP_INLINE void CopySmallPattern8b(const uint8_t* src, uint8_t* dst,
715                                             int length, uint32_t pattern) {
716    int i;
717    while ((uintptr_t)dst & 3) {
718      *dst++ = *src++;
719      pattern = Rotate8b(pattern);
720      --length;
721    }
722    for (i = 0; i < (length >> 2); ++i) {
723      ((uint32_t*)dst)[i] = pattern;
724    }
725    for (i <<= 2; i < length; ++i) {
726      dst[i] = src[i];
727    }
728  }
729  static WEBP_INLINE void CopyBlock8b(uint8_t* const dst, int dist, int length) {
730    const uint8_t* src = dst - dist;
731    if (length >= 8) {
732      uint32_t pattern = 0;
733      switch (dist) {
734        case 1:
735          pattern = src[0];
736  #if defined(__arm__) || defined(_M_ARM)   
737          pattern |= pattern << 8;
738          pattern |= pattern << 16;
739  #elif defined(WEBP_USE_MIPS_DSP_R2)
740          __asm__ volatile ("replv.qb %0, %0" : "+r"(pattern));
741  #else
742          pattern = 0x01010101u * pattern;
743  #endif
744          break;
745        case 2:
746  #if !defined(WORDS_BIGENDIAN)
747          memcpy(&pattern, src, sizeof(uint16_t));
748  #else
749          pattern = ((uint32_t)src[0] << 8) | src[1];
750  #endif
751  #if defined(__arm__) || defined(_M_ARM)
752          pattern |= pattern << 16;
753  #elif defined(WEBP_USE_MIPS_DSP_R2)
754          __asm__ volatile ("replv.ph %0, %0" : "+r"(pattern));
755  #else
756          pattern = 0x00010001u * pattern;
757  #endif
758          break;
759        case 4:
760          memcpy(&pattern, src, sizeof(uint32_t));
761          break;
762        default:
763          goto Copy;
764          break;
765      }
766      CopySmallPattern8b(src, dst, length, pattern);
767      return;
768    }
769   Copy:
770    if (dist >= length) {  
771      memcpy(dst, src, length * sizeof(*dst));
772    } else {
773      int i;
774      for (i = 0; i < length; ++i) dst[i] = src[i];
775    }
776  }
777  static WEBP_INLINE void CopySmallPattern32b(const uint32_t* src,
778                                              uint32_t* dst,
779                                              int length, uint64_t pattern) {
780    int i;
781    if ((uintptr_t)dst & 4) {           
782      *dst++ = *src++;
783      pattern = (pattern >> 32) | (pattern << 32);
784      --length;
785    }
786    assert(0 == ((uintptr_t)dst & 7));
787    for (i = 0; i < (length >> 1); ++i) {
788      ((uint64_t*)dst)[i] = pattern;    
789    }
790    if (length & 1) {                   
791      dst[i << 1] = src[i << 1];
792    }
793  }
794  static WEBP_INLINE void CopyBlock32b(uint32_t* const dst,
795                                       int dist, int length) {
796    const uint32_t* const src = dst - dist;
797    if (dist <= 2 && length >= 4 && ((uintptr_t)dst & 3) == 0) {
798      uint64_t pattern;
799      if (dist == 1) {
800        pattern = (uint64_t)src[0];
801        pattern |= pattern << 32;
802      } else {
803        memcpy(&pattern, src, sizeof(pattern));
804      }
805      CopySmallPattern32b(src, dst, length, pattern);
806    } else if (dist >= length) {  
807      memcpy(dst, src, length * sizeof(*dst));
808    } else {
809      int i;
810      for (i = 0; i < length; ++i) dst[i] = src[i];
811    }
812  }
813  static int DecodeAlphaData(VP8LDecoder* const dec, uint8_t* const data,
814                             int width, int height, int last_row) {
815    int ok = 1;
816    int row = dec->last_pixel_ / width;
817    int col = dec->last_pixel_ % width;
818    VP8LBitReader* const br = &dec->br_;
819    VP8LMetadata* const hdr = &dec->hdr_;
820    int pos = dec->last_pixel_;         
821    const int end = width * height;     
822    const int last = width * last_row;  
823    const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;
824    const int mask = hdr->huffman_mask_;
825    const HTreeGroup* htree_group =
826        (pos < last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;
827    assert(pos <= end);
828    assert(last_row <= height);
829    assert(Is8bOptimizable(hdr));
830    while (!br->eos_ && pos < last) {
831      int code;
832      if ((col & mask) == 0) {
833        htree_group = GetHtreeGroupForPos(hdr, col, row);
834      }
835      assert(htree_group != NULL);
836      VP8LFillBitWindow(br);
837      code = ReadSymbol(htree_group->htrees[GREEN], br);
838      if (code < NUM_LITERAL_CODES) {  
839        data[pos] = code;
840        ++pos;
841        ++col;
842        if (col >= width) {
843          col = 0;
844          ++row;
845          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
846            ExtractPalettedAlphaRows(dec, row);
847          }
848        }
849      } else if (code < len_code_limit) {  
850        int dist_code, dist;
851        const int length_sym = code - NUM_LITERAL_CODES;
852        const int length = GetCopyLength(length_sym, br);
853        const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);
854        VP8LFillBitWindow(br);
855        dist_code = GetCopyDistance(dist_symbol, br);
856        dist = PlaneCodeToDistance(width, dist_code);
857        if (pos >= dist && end - pos >= length) {
858          CopyBlock8b(data + pos, dist, length);
859        } else {
860          ok = 0;
861          goto End;
862        }
863        pos += length;
864        col += length;
865        while (col >= width) {
866          col -= width;
867          ++row;
868          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
869            ExtractPalettedAlphaRows(dec, row);
870          }
871        }
872        if (pos < last && (col & mask)) {
873          htree_group = GetHtreeGroupForPos(hdr, col, row);
874        }
875      } else {  
876        ok = 0;
877        goto End;
878      }
879      br->eos_ = VP8LIsEndOfStream(br);
880    }
881    ExtractPalettedAlphaRows(dec, row > last_row ? last_row : row);
882   End:
883    br->eos_ = VP8LIsEndOfStream(br);
884    if (!ok || (br->eos_ && pos < end)) {
885      ok = 0;
886      dec->status_ = br->eos_ ? VP8_STATUS_SUSPENDED
887                              : VP8_STATUS_BITSTREAM_ERROR;
888    } else {
889      dec->last_pixel_ = pos;
890    }
891    return ok;
892  }
893  static void SaveState(VP8LDecoder* const dec, int last_pixel) {
894    assert(dec->incremental_);
895    dec->saved_br_ = dec->br_;
896    dec->saved_last_pixel_ = last_pixel;
897    if (dec->hdr_.color_cache_size_ > 0) {
898      VP8LColorCacheCopy(&dec->hdr_.color_cache_, &dec->hdr_.saved_color_cache_);
899    }
900  }
901  static void RestoreState(VP8LDecoder* const dec) {
902    assert(dec->br_.eos_);
903    dec->status_ = VP8_STATUS_SUSPENDED;
904    dec->br_ = dec->saved_br_;
905    dec->last_pixel_ = dec->saved_last_pixel_;
906    if (dec->hdr_.color_cache_size_ > 0) {
907      VP8LColorCacheCopy(&dec->hdr_.saved_color_cache_, &dec->hdr_.color_cache_);
908    }
909  }
910  #define SYNC_EVERY_N_ROWS 8  
911  static int DecodeImageData(VP8LDecoder* const dec, uint32_t* const data,
912                             int width, int height, int last_row,
913                             ProcessRowsFunc process_func) {
914    int row = dec->last_pixel_ / width;
915    int col = dec->last_pixel_ % width;
916    VP8LBitReader* const br = &dec->br_;
917    VP8LMetadata* const hdr = &dec->hdr_;
918    uint32_t* src = data + dec->last_pixel_;
919    uint32_t* last_cached = src;
920    uint32_t* const src_end = data + width * height;     
921    uint32_t* const src_last = data + width * last_row;  
922    const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;
923    const int color_cache_limit = len_code_limit + hdr->color_cache_size_;
924    int next_sync_row = dec->incremental_ ? row : 1 << 24;
925    VP8LColorCache* const color_cache =
926        (hdr->color_cache_size_ > 0) ? &hdr->color_cache_ : NULL;
927    const int mask = hdr->huffman_mask_;
928    const HTreeGroup* htree_group =
929        (src < src_last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;
930    assert(dec->last_row_ < last_row);
931    assert(src_last <= src_end);
932    while (src < src_last) {
933      int code;
934      if (row >= next_sync_row) {
935        SaveState(dec, (int)(src - data));
936        next_sync_row = row + SYNC_EVERY_N_ROWS;
937      }
938      if ((col & mask) == 0) {
939        htree_group = GetHtreeGroupForPos(hdr, col, row);
940      }
941      assert(htree_group != NULL);
942      if (htree_group->is_trivial_code) {
943        *src = htree_group->literal_arb;
944        goto AdvanceByOne;
945      }
946      VP8LFillBitWindow(br);
947      if (htree_group->use_packed_table) {
948        code = ReadPackedSymbols(htree_group, br, src);
949        if (VP8LIsEndOfStream(br)) break;
950        if (code == PACKED_NON_LITERAL_CODE) goto AdvanceByOne;
951      } else {
952        code = ReadSymbol(htree_group->htrees[GREEN], br);
953      }
954      if (VP8LIsEndOfStream(br)) break;
955      if (code < NUM_LITERAL_CODES) {  
956        if (htree_group->is_trivial_literal) {
957          *src = htree_group->literal_arb | (code << 8);
958        } else {
959          int red, blue, alpha;
960          red = ReadSymbol(htree_group->htrees[RED], br);
961          VP8LFillBitWindow(br);
962          blue = ReadSymbol(htree_group->htrees[BLUE], br);
963          alpha = ReadSymbol(htree_group->htrees[ALPHA], br);
964          if (VP8LIsEndOfStream(br)) break;
965          *src = ((uint32_t)alpha << 24) | (red << 16) | (code << 8) | blue;
966        }
967      AdvanceByOne:
968        ++src;
969        ++col;
970        if (col >= width) {
971          col = 0;
972          ++row;
973          if (process_func != NULL) {
974            if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
975              process_func(dec, row);
976            }
977          }
978          if (color_cache != NULL) {
979            while (last_cached < src) {
980              VP8LColorCacheInsert(color_cache, *last_cached++);
981            }
982          }
983        }
984      } else if (code < len_code_limit) {  
985        int dist_code, dist;
986        const int length_sym = code - NUM_LITERAL_CODES;
987        const int length = GetCopyLength(length_sym, br);
988        const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);
989        VP8LFillBitWindow(br);
990        dist_code = GetCopyDistance(dist_symbol, br);
991        dist = PlaneCodeToDistance(width, dist_code);
992        if (VP8LIsEndOfStream(br)) break;
993        if (src - data < (ptrdiff_t)dist || src_end - src < (ptrdiff_t)length) {
994          goto Error;
995        } else {
996          CopyBlock32b(src, dist, length);
997        }
998        src += length;
999        col += length;
1000        while (col >= width) {
1001          col -= width;
1002          ++row;
1003          if (process_func != NULL) {
1004            if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
1005              process_func(dec, row);
1006            }
1007          }
1008        }
1009        assert(src <= src_end);
1010        if (col & mask) htree_group = GetHtreeGroupForPos(hdr, col, row);
1011        if (color_cache != NULL) {
1012          while (last_cached < src) {
1013            VP8LColorCacheInsert(color_cache, *last_cached++);
1014          }
1015        }
1016      } else if (code < color_cache_limit) {  
1017        const int key = code - len_code_limit;
1018        assert(color_cache != NULL);
1019        while (last_cached < src) {
1020          VP8LColorCacheInsert(color_cache, *last_cached++);
1021        }
1022        *src = VP8LColorCacheLookup(color_cache, key);
1023        goto AdvanceByOne;
1024      } else {  
1025        goto Error;
1026      }
1027    }
1028    br->eos_ = VP8LIsEndOfStream(br);
1029    if (dec->incremental_ && br->eos_ && src < src_end) {
1030      RestoreState(dec);
1031    } else if (!br->eos_) {
1032      if (process_func != NULL) {
1033        process_func(dec, row > last_row ? last_row : row);
1034      }
1035      dec->status_ = VP8_STATUS_OK;
1036      dec->last_pixel_ = (int)(src - data);  
1037    } else {
1038      goto Error;
1039    }
1040    return 1;
1041   Error:
1042    dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1043    return 0;
1044  }
1045  static void ClearTransform(VP8LTransform* const transform) {
1046    WebPSafeFree(transform->data_);
1047    transform->data_ = NULL;
1048  }
1049  static int ExpandColorMap(int num_colors, VP8LTransform* const transform) {
1050    int i;
1051    const int final_num_colors = 1 << (8 >> transform->bits_);
1052    uint32_t* const new_color_map =
1053        (uint32_t*)WebPSafeMalloc((uint64_t)final_num_colors,
1054                                  sizeof(*new_color_map));
1055    if (new_color_map == NULL) {
1056      return 0;
1057    } else {
1058      uint8_t* const data = (uint8_t*)transform->data_;
1059      uint8_t* const new_data = (uint8_t*)new_color_map;
1060      new_color_map[0] = transform->data_[0];
1061      for (i = 4; i < 4 * num_colors; ++i) {
1062        new_data[i] = (data[i] + new_data[i - 4]) & 0xff;
1063      }
1064      for (; i < 4 * final_num_colors; ++i) {
1065        new_data[i] = 0;  
1066      }
1067      WebPSafeFree(transform->data_);
1068      transform->data_ = new_color_map;
1069    }
1070    return 1;
1071  }
1072  static int ReadTransform(int* const xsize, int const* ysize,
1073                           VP8LDecoder* const dec) {
1074    int ok = 1;
1075    VP8LBitReader* const br = &dec->br_;
1076    VP8LTransform* transform = &dec->transforms_[dec->next_transform_];
1077    const VP8LImageTransformType type =
1078        (VP8LImageTransformType)VP8LReadBits(br, 2);
1079    if (dec->transforms_seen_ & (1U << type)) {
1080      return 0;  
1081    }
1082    dec->transforms_seen_ |= (1U << type);
1083    transform->type_ = type;
1084    transform->xsize_ = *xsize;
1085    transform->ysize_ = *ysize;
1086    transform->data_ = NULL;
1087    ++dec->next_transform_;
1088    assert(dec->next_transform_ <= NUM_TRANSFORMS);
1089    switch (type) {
1090      case PREDICTOR_TRANSFORM:
1091      case CROSS_COLOR_TRANSFORM:
1092        transform->bits_ = VP8LReadBits(br, 3) + 2;
1093        ok = DecodeImageStream(VP8LSubSampleSize(transform->xsize_,
1094                                                 transform->bits_),
1095                               VP8LSubSampleSize(transform->ysize_,
1096                                                 transform->bits_),
1097                               0, dec, &transform->data_);
1098        break;
1099      case COLOR_INDEXING_TRANSFORM: {
1100         const int num_colors = VP8LReadBits(br, 8) + 1;
1101         const int bits = (num_colors > 16) ? 0
1102                        : (num_colors > 4) ? 1
1103                        : (num_colors > 2) ? 2
1104                        : 3;
1105         *xsize = VP8LSubSampleSize(transform->xsize_, bits);
1106         transform->bits_ = bits;
1107         ok = DecodeImageStream(num_colors, 1, 0, dec, &transform->data_);
1108         ok = ok && ExpandColorMap(num_colors, transform);
1109        break;
1110      }
1111      case SUBTRACT_GREEN:
1112        break;
1113      default:
1114        assert(0);    
1115        break;
1116    }
1117    return ok;
1118  }
1119  static void InitMetadata(VP8LMetadata* const hdr) {
1120    assert(hdr != NULL);
1121    memset(hdr, 0, sizeof(*hdr));
1122  }
1123  static void ClearMetadata(VP8LMetadata* const hdr) {
1124    assert(hdr != NULL);
1125    WebPSafeFree(hdr->huffman_image_);
1126    WebPSafeFree(hdr->huffman_tables_);
1127    VP8LHtreeGroupsFree(hdr->htree_groups_);
1128    VP8LColorCacheClear(&hdr->color_cache_);
1129    VP8LColorCacheClear(&hdr->saved_color_cache_);
1130    InitMetadata(hdr);
1131  }
1132  VP8LDecoder* VP8LNew(void) {
1133    VP8LDecoder* const dec = (VP8LDecoder*)WebPSafeCalloc(1ULL, sizeof(*dec));
1134    if (dec == NULL) return NULL;
1135    dec->status_ = VP8_STATUS_OK;
1136    dec->state_ = READ_DIM;
1137    VP8LDspInit();  
1138    return dec;
1139  }
1140  void VP8LClear(VP8LDecoder* const dec) {
1141    int i;
1142    if (dec == NULL) return;
1143    ClearMetadata(&dec->hdr_);
1144    WebPSafeFree(dec->pixels_);
1145    dec->pixels_ = NULL;
1146    for (i = 0; i < dec->next_transform_; ++i) {
1147      ClearTransform(&dec->transforms_[i]);
1148    }
1149    dec->next_transform_ = 0;
1150    dec->transforms_seen_ = 0;
1151    WebPSafeFree(dec->rescaler_memory);
1152    dec->rescaler_memory = NULL;
1153    dec->output_ = NULL;   
1154  }
1155  void VP8LDelete(VP8LDecoder* const dec) {
1156    if (dec != NULL) {
1157      VP8LClear(dec);
1158      WebPSafeFree(dec);
1159    }
1160  }
1161  static void UpdateDecoder(VP8LDecoder* const dec, int width, int height) {
1162    VP8LMetadata* const hdr = &dec->hdr_;
1163    const int num_bits = hdr->huffman_subsample_bits_;
1164    dec->width_ = width;
1165    dec->height_ = height;
1166    hdr->huffman_xsize_ = VP8LSubSampleSize(width, num_bits);
1167    hdr->huffman_mask_ = (num_bits == 0) ? ~0 : (1 << num_bits) - 1;
1168  }
1169  static int DecodeImageStream(int xsize, int ysize,
1170                               int is_level0,
1171                               VP8LDecoder* const dec,
1172                               uint32_t** const decoded_data) {
1173    int ok = 1;
1174    int transform_xsize = xsize;
1175    int transform_ysize = ysize;
1176    VP8LBitReader* const br = &dec->br_;
1177    VP8LMetadata* const hdr = &dec->hdr_;
1178    uint32_t* data = NULL;
1179    int color_cache_bits = 0;
1180    if (is_level0) {
1181      while (ok && VP8LReadBits(br, 1)) {
1182        ok = ReadTransform(&transform_xsize, &transform_ysize, dec);
1183      }
1184    }
1185    if (ok && VP8LReadBits(br, 1)) {
1186      color_cache_bits = VP8LReadBits(br, 4);
1187      ok = (color_cache_bits >= 1 && color_cache_bits <= MAX_CACHE_BITS);
1188      if (!ok) {
1189        dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1190        goto End;
1191      }
1192    }
1193    ok = ok && ReadHuffmanCodes(dec, transform_xsize, transform_ysize,
1194                                color_cache_bits, is_level0);
1195    if (!ok) {
1196      dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1197      goto End;
1198    }
1199    if (color_cache_bits > 0) {
1200      hdr->color_cache_size_ = 1 << color_cache_bits;
1201      if (!VP8LColorCacheInit(&hdr->color_cache_, color_cache_bits)) {
1202        dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1203        ok = 0;
1204        goto End;
1205      }
1206    } else {
1207      hdr->color_cache_size_ = 0;
1208    }
1209    UpdateDecoder(dec, transform_xsize, transform_ysize);
1210    if (is_level0) {   
1211      dec->state_ = READ_HDR;
1212      goto End;
1213    }
1214    {
1215      const uint64_t total_size = (uint64_t)transform_xsize * transform_ysize;
1216      data = (uint32_t*)WebPSafeMalloc(total_size, sizeof(*data));
1217      if (data == NULL) {
1218        dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1219        ok = 0;
1220        goto End;
1221      }
1222    }
1223    ok = DecodeImageData(dec, data, transform_xsize, transform_ysize,
1224                         transform_ysize, NULL);
1225    ok = ok && !br->eos_;
1226   End:
1227    if (!ok) {
1228      WebPSafeFree(data);
1229      ClearMetadata(hdr);
1230    } else {
1231      if (decoded_data != NULL) {
1232        *decoded_data = data;
1233      } else {
1234        assert(data == NULL);
1235        assert(is_level0);
1236      }
1237      dec->last_pixel_ = 0;  
1238      if (!is_level0) ClearMetadata(hdr);  
1239    }
1240    return ok;
1241  }
1242  static int AllocateInternalBuffers32b(VP8LDecoder* const dec, int final_width) {
1243    const uint64_t num_pixels = (uint64_t)dec->width_ * dec->height_;
1244    const uint64_t cache_top_pixels = (uint16_t)final_width;
1245    const uint64_t cache_pixels = (uint64_t)final_width * NUM_ARGB_CACHE_ROWS;
1246    const uint64_t total_num_pixels =
1247        num_pixels + cache_top_pixels + cache_pixels;
1248    assert(dec->width_ <= final_width);
1249    dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint32_t));
1250    if (dec->pixels_ == NULL) {
1251      dec->argb_cache_ = NULL;    
1252      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1253      return 0;
1254    }
1255    dec->argb_cache_ = dec->pixels_ + num_pixels + cache_top_pixels;
1256    return 1;
1257  }
1258  static int AllocateInternalBuffers8b(VP8LDecoder* const dec) {
1259    const uint64_t total_num_pixels = (uint64_t)dec->width_ * dec->height_;
1260    dec->argb_cache_ = NULL;    
1261    dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint8_t));
1262    if (dec->pixels_ == NULL) {
1263      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1264      return 0;
1265    }
1266    return 1;
1267  }
1268  static void ExtractAlphaRows(VP8LDecoder* const dec, int last_row) {
1269    int cur_row = dec->last_row_;
1270    int num_rows = last_row - cur_row;
1271    const uint32_t* in = dec->pixels_ + dec->width_ * cur_row;
1272    assert(last_row <= dec->io_->crop_bottom);
1273    while (num_rows > 0) {
1274      const int num_rows_to_process =
1275          (num_rows > NUM_ARGB_CACHE_ROWS) ? NUM_ARGB_CACHE_ROWS : num_rows;
1276      ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;
1277      uint8_t* const output = alph_dec->output_;
1278      const int width = dec->io_->width;      
1279      const int cache_pixs = width * num_rows_to_process;
1280      uint8_t* const dst = output + width * cur_row;
1281      const uint32_t* const src = dec->argb_cache_;
1282      ApplyInverseTransforms(dec, cur_row, num_rows_to_process, in);
1283      WebPExtractGreen(src, dst, cache_pixs);
1284      AlphaApplyFilter(alph_dec,
1285                       cur_row, cur_row + num_rows_to_process, dst, width);
1286      num_rows -= num_rows_to_process;
1287      in += num_rows_to_process * dec->width_;
1288      cur_row += num_rows_to_process;
1289    }
1290    assert(cur_row == last_row);
1291    dec->last_row_ = dec->last_out_row_ = last_row;
1292  }
1293  int VP8LDecodeAlphaHeader(ALPHDecoder* const alph_dec,
1294                            const uint8_t* const data, size_t data_size) {
1295    int ok = 0;
1296    VP8LDecoder* dec = VP8LNew();
1297    if (dec == NULL) return 0;
1298    assert(alph_dec != NULL);
1299    dec->width_ = alph_dec->width_;
1300    dec->height_ = alph_dec->height_;
1301    dec->io_ = &alph_dec->io_;
1302    dec->io_->opaque = alph_dec;
1303    dec->io_->width = alph_dec->width_;
1304    dec->io_->height = alph_dec->height_;
1305    dec->status_ = VP8_STATUS_OK;
1306    VP8LInitBitReader(&dec->br_, data, data_size);
1307    if (!DecodeImageStream(alph_dec->width_, alph_dec->height_, 1, dec, NULL)) {
1308      goto Err;
1309    }
1310    if (dec->next_transform_ == 1 &&
1311        dec->transforms_[0].type_ == COLOR_INDEXING_TRANSFORM &&
1312        Is8bOptimizable(&dec->hdr_)) {
1313      alph_dec->use_8b_decode_ = 1;
1314      ok = AllocateInternalBuffers8b(dec);
1315    } else {
1316      alph_dec->use_8b_decode_ = 0;
1317      ok = AllocateInternalBuffers32b(dec, alph_dec->width_);
1318    }
1319    if (!ok) goto Err;
1320    alph_dec->vp8l_dec_ = dec;
1321    return 1;
1322   Err:
1323    VP8LDelete(dec);
1324    return 0;
1325  }
1326  int VP8LDecodeAlphaImageStream(ALPHDecoder* const alph_dec, int last_row) {
1327    VP8LDecoder* const dec = alph_dec->vp8l_dec_;
1328    assert(dec != NULL);
1329    assert(last_row <= dec->height_);
1330    if (dec->last_row_ >= last_row) {
1331      return 1;  
1332    }
1333    if (!alph_dec->use_8b_decode_) WebPInitAlphaProcessing();
1334    return alph_dec->use_8b_decode_ ?
1335        DecodeAlphaData(dec, (uint8_t*)dec->pixels_, dec->width_, dec->height_,
1336                        last_row) :
1337        DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,
1338                        last_row, ExtractAlphaRows);
1339  }
1340  int VP8LDecodeHeader(VP8LDecoder* const dec, VP8Io* const io) {
1341    int width, height, has_alpha;
1342    if (dec == NULL) return 0;
1343    if (io == NULL) {
1344      dec->status_ = VP8_STATUS_INVALID_PARAM;
1345      return 0;
1346    }
1347    dec->io_ = io;
1348    dec->status_ = VP8_STATUS_OK;
1349    VP8LInitBitReader(&dec->br_, io->data, io->data_size);
1350    if (!ReadImageInfo(&dec->br_, &width, &height, &has_alpha)) {
1351      dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1352      goto Error;
1353    }
1354    dec->state_ = READ_DIM;
1355    io->width = width;
1356    io->height = height;
1357    if (!DecodeImageStream(width, height, 1, dec, NULL)) goto Error;
1358    return 1;
1359   Error:
1360    VP8LClear(dec);
1361    assert(dec->status_ != VP8_STATUS_OK);
1362    return 0;
1363  }
1364  int VP8LDecodeImage(VP8LDecoder* const dec) {
1365    VP8Io* io = NULL;
1366    WebPDecParams* params = NULL;
1367    if (dec == NULL) return 0;
1368    assert(dec->hdr_.huffman_tables_ != NULL);
1369    assert(dec->hdr_.htree_groups_ != NULL);
1370    assert(dec->hdr_.num_htree_groups_ > 0);
1371    io = dec->io_;
1372    assert(io != NULL);
1373    params = (WebPDecParams*)io->opaque;
1374    assert(params != NULL);
1375    if (dec->state_ != READ_DATA) {
1376      dec->output_ = params->output;
1377      assert(dec->output_ != NULL);
1378      if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {
1379        dec->status_ = VP8_STATUS_INVALID_PARAM;
1380        goto Err;
1381      }
1382      if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;
1383  #if !defined(WEBP_REDUCE_SIZE)
1384      if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;
1385  #else
1386      if (io->use_scaling) {
1387        dec->status_ = VP8_STATUS_INVALID_PARAM;
1388        goto Err;
1389      }
1390  #endif
1391      if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {
1392        WebPInitAlphaProcessing();
1393      }
1394      if (!WebPIsRGBMode(dec->output_->colorspace)) {
1395        WebPInitConvertARGBToYUV();
1396        if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();
1397      }
1398      if (dec->incremental_) {
1399        if (dec->hdr_.color_cache_size_ > 0 &&
1400            dec->hdr_.saved_color_cache_.colors_ == NULL) {
1401          if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,
1402                                  dec->hdr_.color_cache_.hash_bits_)) {
1403            dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1404            goto Err;
1405          }
1406        }
1407      }
1408      dec->state_ = READ_DATA;
1409    }
1410    if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,
1411                         io->crop_bottom, ProcessRows)) {
1412      goto Err;
1413    }
1414    params->last_y = dec->last_out_row_;
1415    return 1;
1416   Err:
1417    VP8LClear(dec);
1418    assert(dec->status_ != VP8_STATUS_OK);
1419    return 0;
1420  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-delta_palettization_enc.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_dec.c</div>
                <div class="column column_space"><pre><code>264    }
265    distance *= 1000u;
266    distance += Square(Intensity(predicted_value)
267                       - Intensity(actual_value));
268    return distance;
269  }
270  static uint32_t Predict(int x, int y, uint32_t* image) {
</pre></code></div>
                <div class="column column_space"><pre><code>108    }
109    extra_bits = (distance_symbol - 2) >> 1;
110    offset = (2 + (distance_symbol & 1)) << extra_bits;
111    return offset + VP8LReadBits(br, extra_bits) + 1;
112  }
113  static WEBP_INLINE int GetCopyLength(int length_symbol,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    