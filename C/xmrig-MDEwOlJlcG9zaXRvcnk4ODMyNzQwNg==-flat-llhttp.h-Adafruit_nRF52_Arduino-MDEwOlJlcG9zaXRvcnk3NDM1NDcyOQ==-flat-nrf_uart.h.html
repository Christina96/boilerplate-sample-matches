
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.365535248041773%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-llhttp.h</h3>
            <pre><code>1  #ifndef INCLUDE_LLHTTP_H_
2  #define INCLUDE_LLHTTP_H_
3  #define LLHTTP_VERSION_MAJOR 5
4  #define LLHTTP_VERSION_MINOR 1
5  #define LLHTTP_VERSION_PATCH 0
6  #ifndef LLHTTP_STRICT_MODE
7  # define LLHTTP_STRICT_MODE 0
8  #endif
9  #ifndef INCLUDE_LLHTTP_ITSELF_H_
10  #define INCLUDE_LLHTTP_ITSELF_H_
11  #ifdef __cplusplus
12  extern "C" {
13  #endif
14  #include <stdint.h>
15  typedef struct llhttp__internal_s llhttp__internal_t;
16  struct llhttp__internal_s {
17    int32_t _index;
18    void* _span_pos0;
19    void* _span_cb0;
20    int32_t error;
21    const char* reason;
22    const char* error_pos;
23    void* data;
24    void* _current;
25    uint64_t content_length;
26    uint8_t type;
27    uint8_t method;
28    uint8_t http_major;
29    uint8_t http_minor;
30    uint8_t header_state;
31    uint8_t lenient_flags;
32    uint8_t upgrade;
33    uint8_t finish;
34    uint16_t flags;
35    uint16_t status_code;
36    void* settings;
37  };
38  int llhttp__internal_init(llhttp__internal_t* s);
39  int llhttp__internal_execute(llhttp__internal_t* s, const char* p, const char* endp);
40  #ifdef __cplusplus
41  }  &bsol;* extern "C" */
42  #endif
43  #endif  &bsol;* INCLUDE_LLHTTP_ITSELF_H_ */
44  #ifndef LLLLHTTP_C_HEADERS_
45  #define LLLLHTTP_C_HEADERS_
46  #ifdef __cplusplus
47  extern "C" {
48  #endif
49  enum llhttp_errno {
50    HPE_OK = 0,
51    HPE_INTERNAL = 1,
52    HPE_STRICT = 2,
53    HPE_LF_EXPECTED = 3,
54    HPE_UNEXPECTED_CONTENT_LENGTH = 4,
55    HPE_CLOSED_CONNECTION = 5,
56    HPE_INVALID_METHOD = 6,
57    HPE_INVALID_URL = 7,
58    HPE_INVALID_CONSTANT = 8,
59    HPE_INVALID_VERSION = 9,
60    HPE_INVALID_HEADER_TOKEN = 10,
61    HPE_INVALID_CONTENT_LENGTH = 11,
62    HPE_INVALID_CHUNK_SIZE = 12,
63    HPE_INVALID_STATUS = 13,
64    HPE_INVALID_EOF_STATE = 14,
65    HPE_INVALID_TRANSFER_ENCODING = 15,
66    HPE_CB_MESSAGE_BEGIN = 16,
67    HPE_CB_HEADERS_COMPLETE = 17,
68    HPE_CB_MESSAGE_COMPLETE = 18,
69    HPE_CB_CHUNK_HEADER = 19,
70    HPE_CB_CHUNK_COMPLETE = 20,
71    HPE_PAUSED = 21,
72    HPE_PAUSED_UPGRADE = 22,
73    HPE_PAUSED_H2_UPGRADE = 23,
74    HPE_USER = 24
75  };
76  typedef enum llhttp_errno llhttp_errno_t;
77  enum llhttp_flags {
78    F_CONNECTION_KEEP_ALIVE = 0x1,
79    F_CONNECTION_CLOSE = 0x2,
80    F_CONNECTION_UPGRADE = 0x4,
<span onclick='openModal()' class='match'>81    F_CHUNKED = 0x8,
82    F_UPGRADE = 0x10,
83    F_CONTENT_LENGTH = 0x20,
84    F_SKIPBODY = 0x40,
85    F_TRAILING = 0x80,
86    F_TRANSFER_ENCODING = 0x200
87  };
88  typedef enum llhttp_flags llhttp_flags_t;
</span>89  enum llhttp_lenient_flags {
90    LENIENT_HEADERS = 0x1,
91    LENIENT_CHUNKED_LENGTH = 0x2,
92    LENIENT_KEEP_ALIVE = 0x4
93  };
94  typedef enum llhttp_lenient_flags llhttp_lenient_flags_t;
95  enum llhttp_type {
96    HTTP_BOTH = 0,
97    HTTP_REQUEST = 1,
98    HTTP_RESPONSE = 2
99  };
100  typedef enum llhttp_type llhttp_type_t;
101  enum llhttp_finish {
102    HTTP_FINISH_SAFE = 0,
103    HTTP_FINISH_SAFE_WITH_CB = 1,
104    HTTP_FINISH_UNSAFE = 2
105  };
106  typedef enum llhttp_finish llhttp_finish_t;
107  enum llhttp_method {
108    HTTP_DELETE = 0,
109    HTTP_GET = 1,
110    HTTP_HEAD = 2,
111    HTTP_POST = 3,
112    HTTP_PUT = 4,
113    HTTP_CONNECT = 5,
114    HTTP_OPTIONS = 6,
115    HTTP_TRACE = 7,
116    HTTP_COPY = 8,
117    HTTP_LOCK = 9,
118    HTTP_MKCOL = 10,
119    HTTP_MOVE = 11,
120    HTTP_PROPFIND = 12,
121    HTTP_PROPPATCH = 13,
122    HTTP_SEARCH = 14,
123    HTTP_UNLOCK = 15,
124    HTTP_BIND = 16,
125    HTTP_REBIND = 17,
126    HTTP_UNBIND = 18,
127    HTTP_ACL = 19,
128    HTTP_REPORT = 20,
129    HTTP_MKACTIVITY = 21,
130    HTTP_CHECKOUT = 22,
131    HTTP_MERGE = 23,
132    HTTP_MSEARCH = 24,
133    HTTP_NOTIFY = 25,
134    HTTP_SUBSCRIBE = 26,
135    HTTP_UNSUBSCRIBE = 27,
136    HTTP_PATCH = 28,
137    HTTP_PURGE = 29,
138    HTTP_MKCALENDAR = 30,
139    HTTP_LINK = 31,
140    HTTP_UNLINK = 32,
141    HTTP_SOURCE = 33,
142    HTTP_PRI = 34,
143    HTTP_DESCRIBE = 35,
144    HTTP_ANNOUNCE = 36,
145    HTTP_SETUP = 37,
146    HTTP_PLAY = 38,
147    HTTP_PAUSE = 39,
148    HTTP_TEARDOWN = 40,
149    HTTP_GET_PARAMETER = 41,
150    HTTP_SET_PARAMETER = 42,
151    HTTP_REDIRECT = 43,
152    HTTP_RECORD = 44,
153    HTTP_FLUSH = 45
154  };
155  typedef enum llhttp_method llhttp_method_t;
156  #define HTTP_ERRNO_MAP(XX) \
157    XX(0, OK, OK) \
158    XX(1, INTERNAL, INTERNAL) \
159    XX(2, STRICT, STRICT) \
160    XX(3, LF_EXPECTED, LF_EXPECTED) \
161    XX(4, UNEXPECTED_CONTENT_LENGTH, UNEXPECTED_CONTENT_LENGTH) \
162    XX(5, CLOSED_CONNECTION, CLOSED_CONNECTION) \
163    XX(6, INVALID_METHOD, INVALID_METHOD) \
164    XX(7, INVALID_URL, INVALID_URL) \
165    XX(8, INVALID_CONSTANT, INVALID_CONSTANT) \
166    XX(9, INVALID_VERSION, INVALID_VERSION) \
167    XX(10, INVALID_HEADER_TOKEN, INVALID_HEADER_TOKEN) \
168    XX(11, INVALID_CONTENT_LENGTH, INVALID_CONTENT_LENGTH) \
169    XX(12, INVALID_CHUNK_SIZE, INVALID_CHUNK_SIZE) \
170    XX(13, INVALID_STATUS, INVALID_STATUS) \
171    XX(14, INVALID_EOF_STATE, INVALID_EOF_STATE) \
172    XX(15, INVALID_TRANSFER_ENCODING, INVALID_TRANSFER_ENCODING) \
173    XX(16, CB_MESSAGE_BEGIN, CB_MESSAGE_BEGIN) \
174    XX(17, CB_HEADERS_COMPLETE, CB_HEADERS_COMPLETE) \
175    XX(18, CB_MESSAGE_COMPLETE, CB_MESSAGE_COMPLETE) \
176    XX(19, CB_CHUNK_HEADER, CB_CHUNK_HEADER) \
177    XX(20, CB_CHUNK_COMPLETE, CB_CHUNK_COMPLETE) \
178    XX(21, PAUSED, PAUSED) \
179    XX(22, PAUSED_UPGRADE, PAUSED_UPGRADE) \
180    XX(23, PAUSED_H2_UPGRADE, PAUSED_H2_UPGRADE) \
181    XX(24, USER, USER) \
182  
183  #define HTTP_METHOD_MAP(XX) \
184    XX(0, DELETE, DELETE) \
185    XX(1, GET, GET) \
186    XX(2, HEAD, HEAD) \
187    XX(3, POST, POST) \
188    XX(4, PUT, PUT) \
189    XX(5, CONNECT, CONNECT) \
190    XX(6, OPTIONS, OPTIONS) \
191    XX(7, TRACE, TRACE) \
192    XX(8, COPY, COPY) \
193    XX(9, LOCK, LOCK) \
194    XX(10, MKCOL, MKCOL) \
195    XX(11, MOVE, MOVE) \
196    XX(12, PROPFIND, PROPFIND) \
197    XX(13, PROPPATCH, PROPPATCH) \
198    XX(14, SEARCH, SEARCH) \
199    XX(15, UNLOCK, UNLOCK) \
200    XX(16, BIND, BIND) \
201    XX(17, REBIND, REBIND) \
202    XX(18, UNBIND, UNBIND) \
203    XX(19, ACL, ACL) \
204    XX(20, REPORT, REPORT) \
205    XX(21, MKACTIVITY, MKACTIVITY) \
206    XX(22, CHECKOUT, CHECKOUT) \
207    XX(23, MERGE, MERGE) \
208    XX(24, MSEARCH, M-SEARCH) \
209    XX(25, NOTIFY, NOTIFY) \
210    XX(26, SUBSCRIBE, SUBSCRIBE) \
211    XX(27, UNSUBSCRIBE, UNSUBSCRIBE) \
212    XX(28, PATCH, PATCH) \
213    XX(29, PURGE, PURGE) \
214    XX(30, MKCALENDAR, MKCALENDAR) \
215    XX(31, LINK, LINK) \
216    XX(32, UNLINK, UNLINK) \
217    XX(33, SOURCE, SOURCE) \
218    XX(34, PRI, PRI) \
219    XX(35, DESCRIBE, DESCRIBE) \
220    XX(36, ANNOUNCE, ANNOUNCE) \
221    XX(37, SETUP, SETUP) \
222    XX(38, PLAY, PLAY) \
223    XX(39, PAUSE, PAUSE) \
224    XX(40, TEARDOWN, TEARDOWN) \
225    XX(41, GET_PARAMETER, GET_PARAMETER) \
226    XX(42, SET_PARAMETER, SET_PARAMETER) \
227    XX(43, REDIRECT, REDIRECT) \
228    XX(44, RECORD, RECORD) \
229    XX(45, FLUSH, FLUSH) \
230  
231  #ifdef __cplusplus
232  }  &bsol;* extern "C" */
233  #endif
234  #endif  &bsol;* LLLLHTTP_C_HEADERS_ */
235  #ifndef INCLUDE_LLHTTP_API_H_
236  #define INCLUDE_LLHTTP_API_H_
237  #ifdef __cplusplus
238  extern "C" {
239  #endif
240  #include <stddef.h>
241  #if defined(__wasm__)
242  #define LLHTTP_EXPORT __attribute__((visibility("default")))
243  #else
244  #define LLHTTP_EXPORT
245  #endif
246  typedef llhttp__internal_t llhttp_t;
247  typedef struct llhttp_settings_s llhttp_settings_t;
248  typedef int (*llhttp_data_cb)(llhttp_t*, const char *at, size_t length);
249  typedef int (*llhttp_cb)(llhttp_t*);
250  struct llhttp_settings_s {
251    llhttp_cb      on_message_begin;
252    llhttp_data_cb on_url;
253    llhttp_data_cb on_status;
254    llhttp_data_cb on_header_field;
255    llhttp_data_cb on_header_value;
256    llhttp_cb      on_headers_complete;
257    llhttp_data_cb on_body;
258    llhttp_cb      on_message_complete;
259    llhttp_cb      on_chunk_header;
260    llhttp_cb      on_chunk_complete;
261    llhttp_cb      on_url_complete;
262    llhttp_cb      on_status_complete;
263    llhttp_cb      on_header_field_complete;
264    llhttp_cb      on_header_value_complete;
265  };
266  LLHTTP_EXPORT
267  void llhttp_init(llhttp_t* parser, llhttp_type_t type,
268                   const llhttp_settings_t* settings);
269  #if defined(__wasm__)
270  LLHTTP_EXPORT
271  llhttp_t* llhttp_alloc(llhttp_type_t type);
272  LLHTTP_EXPORT
273  void llhttp_free(llhttp_t* parser);
274  LLHTTP_EXPORT
275  uint8_t llhttp_get_type(llhttp_t* parser);
276  LLHTTP_EXPORT
277  uint8_t llhttp_get_http_major(llhttp_t* parser);
278  LLHTTP_EXPORT
279  uint8_t llhttp_get_http_minor(llhttp_t* parser);
280  LLHTTP_EXPORT
281  uint8_t llhttp_get_method(llhttp_t* parser);
282  LLHTTP_EXPORT
283  int llhttp_get_status_code(llhttp_t* parser);
284  LLHTTP_EXPORT
285  uint8_t llhttp_get_upgrade(llhttp_t* parser);
286  #endif  
287  LLHTTP_EXPORT
288  void llhttp_reset(llhttp_t* parser);
289  LLHTTP_EXPORT
290  void llhttp_settings_init(llhttp_settings_t* settings);
291  LLHTTP_EXPORT
292  llhttp_errno_t llhttp_execute(llhttp_t* parser, const char* data, size_t len);
293  LLHTTP_EXPORT
294  llhttp_errno_t llhttp_finish(llhttp_t* parser);
295  LLHTTP_EXPORT
296  int llhttp_message_needs_eof(const llhttp_t* parser);
297  LLHTTP_EXPORT
298  int llhttp_should_keep_alive(const llhttp_t* parser);
299  LLHTTP_EXPORT
300  void llhttp_pause(llhttp_t* parser);
301  LLHTTP_EXPORT
302  void llhttp_resume(llhttp_t* parser);
303  LLHTTP_EXPORT
304  void llhttp_resume_after_upgrade(llhttp_t* parser);
305  LLHTTP_EXPORT
306  llhttp_errno_t llhttp_get_errno(const llhttp_t* parser);
307  LLHTTP_EXPORT
308  const char* llhttp_get_error_reason(const llhttp_t* parser);
309  LLHTTP_EXPORT
310  void llhttp_set_error_reason(llhttp_t* parser, const char* reason);
311  LLHTTP_EXPORT
312  const char* llhttp_get_error_pos(const llhttp_t* parser);
313  LLHTTP_EXPORT
314  const char* llhttp_errno_name(llhttp_errno_t err);
315  LLHTTP_EXPORT
316  const char* llhttp_method_name(llhttp_method_t method);
317  LLHTTP_EXPORT
318  void llhttp_set_lenient_headers(llhttp_t* parser, int enabled);
319  LLHTTP_EXPORT
320  void llhttp_set_lenient_chunked_length(llhttp_t* parser, int enabled);
321  void llhttp_set_lenient_keep_alive(llhttp_t* parser, int enabled);
322  #ifdef __cplusplus
323  }  &bsol;* extern "C" */
324  #endif
325  #endif  &bsol;* INCLUDE_LLHTTP_API_H_ */
326  #endif  &bsol;* INCLUDE_LLHTTP_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_uart.h</h3>
            <pre><code>1  #ifndef NRF_UART_H__
2  #define NRF_UART_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_UART_PSEL_DISCONNECTED 0xFFFFFFFF
8  typedef enum
9  {
10      NRF_UART_TASK_STARTRX = offsetof(NRF_UART_Type, TASKS_STARTRX), &bsol;**< Task for starting reception. */
11      NRF_UART_TASK_STOPRX  = offsetof(NRF_UART_Type, TASKS_STOPRX),  &bsol;**< Task for stopping reception. */
12      NRF_UART_TASK_STARTTX = offsetof(NRF_UART_Type, TASKS_STARTTX), &bsol;**< Task for starting transmission. */
13      NRF_UART_TASK_STOPTX  = offsetof(NRF_UART_Type, TASKS_STOPTX),  &bsol;**< Task for stopping transmission. */
14      NRF_UART_TASK_SUSPEND = offsetof(NRF_UART_Type, TASKS_SUSPEND), &bsol;**< Task for suspending UART. */
15  } nrf_uart_task_t;
16  typedef enum
17  {
<span onclick='openModal()' class='match'>18      NRF_UART_EVENT_CTS    = offsetof(NRF_UART_Type, EVENTS_CTS),   &bsol;**< Event from CTS line activation. */
19      NRF_UART_EVENT_NCTS   = offsetof(NRF_UART_Type, EVENTS_NCTS),  &bsol;**< Event from CTS line deactivation. */
20      NRF_UART_EVENT_RXDRDY = offsetof(NRF_UART_Type, EVENTS_RXDRDY),&bsol;**< Event from data ready in RXD. */
21      NRF_UART_EVENT_TXDRDY = offsetof(NRF_UART_Type, EVENTS_TXDRDY),&bsol;**< Event from data sent from TXD. */
22      NRF_UART_EVENT_ERROR  = offsetof(NRF_UART_Type, EVENTS_ERROR), &bsol;**< Event from error detection. */
23      NRF_UART_EVENT_RXTO   = offsetof(NRF_UART_Type, EVENTS_RXTO)   &bsol;**< Event from receiver timeout. */
24  } nrf_uart_event_t;
25  typedef enum
</span>26  {
27      NRF_UART_INT_MASK_CTS    = UART_INTENCLR_CTS_Msk,    &bsol;**< CTS line activation interrupt. */
28      NRF_UART_INT_MASK_NCTS   = UART_INTENCLR_NCTS_Msk,   &bsol;**< CTS line deactivation interrupt. */
29      NRF_UART_INT_MASK_RXDRDY = UART_INTENCLR_RXDRDY_Msk, &bsol;**< Data ready in RXD interrupt. */
30      NRF_UART_INT_MASK_TXDRDY = UART_INTENCLR_TXDRDY_Msk, &bsol;**< Data sent from TXD interrupt. */
31      NRF_UART_INT_MASK_ERROR  = UART_INTENCLR_ERROR_Msk,  &bsol;**< Error detection interrupt. */
32      NRF_UART_INT_MASK_RXTO   = UART_INTENCLR_RXTO_Msk    &bsol;**< Receiver timeout interrupt. */
33  } nrf_uart_int_mask_t;
34  typedef enum
35  {
36      NRF_UART_BAUDRATE_1200    = UART_BAUDRATE_BAUDRATE_Baud1200,   &bsol;**< 1200 baud. */
37      NRF_UART_BAUDRATE_2400    = UART_BAUDRATE_BAUDRATE_Baud2400,   &bsol;**< 2400 baud. */
38      NRF_UART_BAUDRATE_4800    = UART_BAUDRATE_BAUDRATE_Baud4800,   &bsol;**< 4800 baud. */
39      NRF_UART_BAUDRATE_9600    = UART_BAUDRATE_BAUDRATE_Baud9600,   &bsol;**< 9600 baud. */
40      NRF_UART_BAUDRATE_14400   = UART_BAUDRATE_BAUDRATE_Baud14400,  &bsol;**< 14400 baud. */
41      NRF_UART_BAUDRATE_19200   = UART_BAUDRATE_BAUDRATE_Baud19200,  &bsol;**< 19200 baud. */
42      NRF_UART_BAUDRATE_28800   = UART_BAUDRATE_BAUDRATE_Baud28800,  &bsol;**< 28800 baud. */
43      NRF_UART_BAUDRATE_31250   = UART_BAUDRATE_BAUDRATE_Baud31250,  &bsol;**< 31250 baud. */
44      NRF_UART_BAUDRATE_38400   = UART_BAUDRATE_BAUDRATE_Baud38400,  &bsol;**< 38400 baud. */
45      NRF_UART_BAUDRATE_56000   = UART_BAUDRATE_BAUDRATE_Baud56000,  &bsol;**< 56000 baud. */
46      NRF_UART_BAUDRATE_57600   = UART_BAUDRATE_BAUDRATE_Baud57600,  &bsol;**< 57600 baud. */
47      NRF_UART_BAUDRATE_76800   = UART_BAUDRATE_BAUDRATE_Baud76800,  &bsol;**< 76800 baud. */
48      NRF_UART_BAUDRATE_115200  = UART_BAUDRATE_BAUDRATE_Baud115200, &bsol;**< 115200 baud. */
49      NRF_UART_BAUDRATE_230400  = UART_BAUDRATE_BAUDRATE_Baud230400, &bsol;**< 230400 baud. */
50      NRF_UART_BAUDRATE_250000  = UART_BAUDRATE_BAUDRATE_Baud250000, &bsol;**< 250000 baud. */
51      NRF_UART_BAUDRATE_460800  = UART_BAUDRATE_BAUDRATE_Baud460800, &bsol;**< 460800 baud. */
52      NRF_UART_BAUDRATE_921600  = UART_BAUDRATE_BAUDRATE_Baud921600, &bsol;**< 921600 baud. */
53      NRF_UART_BAUDRATE_1000000 = UART_BAUDRATE_BAUDRATE_Baud1M,     &bsol;**< 1000000 baud. */
54  } nrf_uart_baudrate_t;
55  typedef enum
56  {
57      NRF_UART_ERROR_OVERRUN_MASK = UART_ERRORSRC_OVERRUN_Msk,   &bsol;**< Overrun error. */
58      NRF_UART_ERROR_PARITY_MASK  = UART_ERRORSRC_PARITY_Msk,    &bsol;**< Parity error. */
59      NRF_UART_ERROR_FRAMING_MASK = UART_ERRORSRC_FRAMING_Msk,   &bsol;**< Framing error. */
60      NRF_UART_ERROR_BREAK_MASK   = UART_ERRORSRC_BREAK_Msk,     &bsol;**< Break error. */
61  } nrf_uart_error_mask_t;
62  typedef enum
63  {
64      NRF_UART_PARITY_EXCLUDED = UART_CONFIG_PARITY_Excluded << UART_CONFIG_PARITY_Pos, &bsol;**< Parity excluded. */
65      NRF_UART_PARITY_INCLUDED = UART_CONFIG_PARITY_Included << UART_CONFIG_PARITY_Pos, &bsol;**< Parity included. */
66  } nrf_uart_parity_t;
67  typedef enum
68  {
69      NRF_UART_HWFC_DISABLED = UART_CONFIG_HWFC_Disabled, &bsol;**< Hardware flow control disabled. */
70      NRF_UART_HWFC_ENABLED  = UART_CONFIG_HWFC_Enabled,  &bsol;**< Hardware flow control enabled. */
71  } nrf_uart_hwfc_t;
72  #if defined(UART_CONFIG_STOP_Msk) || defined(__NRFX_DOXYGEN__)
73  typedef enum
74  {
75      NRF_UART_STOP_ONE = UART_CONFIG_STOP_One << UART_CONFIG_STOP_Pos, 
76      NRF_UART_STOP_TWO = UART_CONFIG_STOP_Two << UART_CONFIG_STOP_Pos  
77  } nrf_uart_stop_t;
78  #endif
79  #if defined(UART_CONFIG_PARITYTYPE_Msk) || defined(__NRFX_DOXYGEN__)
80  typedef enum
81  {
82      NRF_UART_PARITYTYPE_EVEN = UART_CONFIG_PARITYTYPE_Even << UART_CONFIG_PARITYTYPE_Pos, &bsol;**< Parity even. */
83      NRF_UART_PARITYTYPE_ODD  = UART_CONFIG_PARITYTYPE_Odd << UART_CONFIG_PARITYTYPE_Pos,  &bsol;**< Parity odd. */
84  } nrf_uart_paritytype_t;
85  #endif
86  typedef struct
87  {
88      nrf_uart_hwfc_t       hwfc;       
89      nrf_uart_parity_t     parity;     
90  #if defined(UART_CONFIG_STOP_Msk) || defined(__NRFX_DOXYGEN__)
91      nrf_uart_stop_t       stop;       
92  #endif
93  #if defined(UART_CONFIG_PARITYTYPE_Msk) || defined(__NRFX_DOXYGEN__)
94      nrf_uart_paritytype_t paritytype; 
95  #endif
96  } nrf_uart_config_t;
97  NRF_STATIC_INLINE void nrf_uart_event_clear(NRF_UART_Type * p_reg, nrf_uart_event_t event);
98  NRF_STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type const * p_reg, nrf_uart_event_t event);
99  NRF_STATIC_INLINE uint32_t nrf_uart_event_address_get(NRF_UART_Type const * p_reg,
100                                                        nrf_uart_event_t      event);
101  NRF_STATIC_INLINE void nrf_uart_int_enable(NRF_UART_Type * p_reg, uint32_t mask);
102  NRF_STATIC_INLINE uint32_t nrf_uart_int_enable_check(NRF_UART_Type const * p_reg, uint32_t mask);
103  NRF_STATIC_INLINE void nrf_uart_int_disable(NRF_UART_Type * p_reg, uint32_t mask);
104  NRF_STATIC_INLINE uint32_t nrf_uart_errorsrc_get_and_clear(NRF_UART_Type * p_reg);
105  NRF_STATIC_INLINE void nrf_uart_enable(NRF_UART_Type * p_reg);
106  NRF_STATIC_INLINE void nrf_uart_disable(NRF_UART_Type * p_reg);
107  NRF_STATIC_INLINE void nrf_uart_txrx_pins_set(NRF_UART_Type * p_reg,
108                                                uint32_t        pseltxd,
109                                                uint32_t        pselrxd);
110  NRF_STATIC_INLINE void nrf_uart_txrx_pins_disconnect(NRF_UART_Type * p_reg);
111  NRF_STATIC_INLINE uint32_t nrf_uart_tx_pin_get(NRF_UART_Type const * p_reg);
112  NRF_STATIC_INLINE uint32_t nrf_uart_rx_pin_get(NRF_UART_Type const * p_reg);
113  NRF_STATIC_INLINE uint32_t nrf_uart_rts_pin_get(NRF_UART_Type const * p_reg);
114  NRF_STATIC_INLINE uint32_t nrf_uart_cts_pin_get(NRF_UART_Type const * p_reg);
115  NRF_STATIC_INLINE void nrf_uart_hwfc_pins_set(NRF_UART_Type * p_reg,
116                                                uint32_t        pselrts,
117                                                uint32_t        pselcts);
118  NRF_STATIC_INLINE void nrf_uart_hwfc_pins_disconnect(NRF_UART_Type * p_reg);
119  NRF_STATIC_INLINE uint8_t nrf_uart_rxd_get(NRF_UART_Type const * p_reg);
120  NRF_STATIC_INLINE void nrf_uart_txd_set(NRF_UART_Type * p_reg, uint8_t txd);
121  NRF_STATIC_INLINE void nrf_uart_task_trigger(NRF_UART_Type * p_reg, nrf_uart_task_t task);
122  NRF_STATIC_INLINE uint32_t nrf_uart_task_address_get(NRF_UART_Type const * p_reg,
123                                                       nrf_uart_task_t       task);
124  NRF_STATIC_INLINE void nrf_uart_configure(NRF_UART_Type           * p_reg,
125                                            nrf_uart_config_t const * p_cfg);
126  NRF_STATIC_INLINE void nrf_uart_baudrate_set(NRF_UART_Type * p_reg, nrf_uart_baudrate_t baudrate);
127  #ifndef NRF_DECLARE_ONLY
128  NRF_STATIC_INLINE void nrf_uart_event_clear(NRF_UART_Type * p_reg, nrf_uart_event_t event)
129  {
130      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
131  #if __CORTEX_M == 0x04
132      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
133      (void)dummy;
134  #endif
135  }
136  NRF_STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type const * p_reg, nrf_uart_event_t event)
137  {
138      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
139  }
140  NRF_STATIC_INLINE uint32_t nrf_uart_event_address_get(NRF_UART_Type const * p_reg,
141                                                        nrf_uart_event_t      event)
142  {
143      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
144  }
145  NRF_STATIC_INLINE void nrf_uart_int_enable(NRF_UART_Type * p_reg, uint32_t mask)
146  {
147      p_reg->INTENSET = mask;
148  }
149  NRF_STATIC_INLINE uint32_t nrf_uart_int_enable_check(NRF_UART_Type const * p_reg, uint32_t mask)
150  {
151      return p_reg->INTENSET & mask;
152  }
153  NRF_STATIC_INLINE void nrf_uart_int_disable(NRF_UART_Type * p_reg, uint32_t mask)
154  {
155      p_reg->INTENCLR = mask;
156  }
157  NRF_STATIC_INLINE uint32_t nrf_uart_errorsrc_get_and_clear(NRF_UART_Type * p_reg)
158  {
159      uint32_t errsrc_mask = p_reg->ERRORSRC;
160      p_reg->ERRORSRC = errsrc_mask;
161      return errsrc_mask;
162  }
163  NRF_STATIC_INLINE void nrf_uart_enable(NRF_UART_Type * p_reg)
164  {
165      p_reg->ENABLE = UART_ENABLE_ENABLE_Enabled;
166  }
167  NRF_STATIC_INLINE void nrf_uart_disable(NRF_UART_Type * p_reg)
168  {
169      p_reg->ENABLE = UART_ENABLE_ENABLE_Disabled;
170  }
171  NRF_STATIC_INLINE void nrf_uart_txrx_pins_set(NRF_UART_Type * p_reg,
172                                                uint32_t        pseltxd,
173                                                uint32_t        pselrxd)
174  {
175  #if defined(UART_PSEL_RXD_CONNECT_Pos)
176      p_reg->PSEL.RXD = pselrxd;
177  #else
178      p_reg->PSELRXD = pselrxd;
179  #endif
180  #if defined(UART_PSEL_TXD_CONNECT_Pos)
181      p_reg->PSEL.TXD = pseltxd;
182  #else
183      p_reg->PSELTXD = pseltxd;
184  #endif
185  }
186  NRF_STATIC_INLINE void nrf_uart_txrx_pins_disconnect(NRF_UART_Type * p_reg)
187  {
188      nrf_uart_txrx_pins_set(p_reg, NRF_UART_PSEL_DISCONNECTED, NRF_UART_PSEL_DISCONNECTED);
189  }
190  NRF_STATIC_INLINE uint32_t nrf_uart_tx_pin_get(NRF_UART_Type const * p_reg)
191  {
192  #if defined(UART_PSEL_TXD_CONNECT_Pos)
193      return p_reg->PSEL.TXD;
194  #else
195      return p_reg->PSELTXD;
196  #endif
197  }
198  NRF_STATIC_INLINE uint32_t nrf_uart_rx_pin_get(NRF_UART_Type const * p_reg)
199  {
200  #if defined(UART_PSEL_RXD_CONNECT_Pos)
201      return p_reg->PSEL.RXD;
202  #else
203      return p_reg->PSELRXD;
204  #endif
205  }
206  NRF_STATIC_INLINE uint32_t nrf_uart_rts_pin_get(NRF_UART_Type const * p_reg)
207  {
208  #if defined(UART_PSEL_RTS_CONNECT_Pos)
209      return p_reg->PSEL.RTS;
210  #else
211      return p_reg->PSELRTS;
212  #endif
213  }
214  NRF_STATIC_INLINE uint32_t nrf_uart_cts_pin_get(NRF_UART_Type const * p_reg)
215  {
216  #if defined(UART_PSEL_RTS_CONNECT_Pos)
217      return p_reg->PSEL.CTS;
218  #else
219      return p_reg->PSELCTS;
220  #endif
221  }
222  NRF_STATIC_INLINE void nrf_uart_hwfc_pins_set(NRF_UART_Type * p_reg,
223                                                uint32_t        pselrts,
224                                                uint32_t        pselcts)
225  {
226  #if defined(UART_PSEL_RTS_CONNECT_Pos)
227      p_reg->PSEL.RTS = pselrts;
228  #else
229      p_reg->PSELRTS = pselrts;
230  #endif
231  #if defined(UART_PSEL_RTS_CONNECT_Pos)
232      p_reg->PSEL.CTS = pselcts;
233  #else
234      p_reg->PSELCTS = pselcts;
235  #endif
236  }
237  NRF_STATIC_INLINE void nrf_uart_hwfc_pins_disconnect(NRF_UART_Type * p_reg)
238  {
239      nrf_uart_hwfc_pins_set(p_reg, NRF_UART_PSEL_DISCONNECTED, NRF_UART_PSEL_DISCONNECTED);
240  }
241  NRF_STATIC_INLINE uint8_t nrf_uart_rxd_get(NRF_UART_Type const * p_reg)
242  {
243      return p_reg->RXD;
244  }
245  NRF_STATIC_INLINE void nrf_uart_txd_set(NRF_UART_Type * p_reg, uint8_t txd)
246  {
247      p_reg->TXD = txd;
248  }
249  NRF_STATIC_INLINE void nrf_uart_task_trigger(NRF_UART_Type * p_reg, nrf_uart_task_t task)
250  {
251      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
252  }
253  NRF_STATIC_INLINE uint32_t nrf_uart_task_address_get(NRF_UART_Type const * p_reg,
254                                                       nrf_uart_task_t       task)
255  {
256      return (uint32_t)p_reg + (uint32_t)task;
257  }
258  NRF_STATIC_INLINE void nrf_uart_configure(NRF_UART_Type           * p_reg,
259                                            nrf_uart_config_t const * p_cfg)
260  {
261      p_reg->CONFIG = (uint32_t)p_cfg->parity
262  #if defined(UART_CONFIG_STOP_Msk)
263                      | (uint32_t)p_cfg->stop
264  #endif
265  #if defined(UART_CONFIG_PARITYTYPE_Msk)
266                      | (uint32_t)p_cfg->paritytype
267  #endif
268                      | (uint32_t)p_cfg->hwfc;
269  }
270  NRF_STATIC_INLINE void nrf_uart_baudrate_set(NRF_UART_Type * p_reg, nrf_uart_baudrate_t baudrate)
271  {
272      p_reg->BAUDRATE = baudrate;
273  }
274  #endif 
275  #ifdef __cplusplus
276  }
277  #endif
278  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-llhttp.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_uart.h</div>
                </div>
                <div class="column column_space"><pre><code>81    F_CHUNKED = 0x8,
82    F_UPGRADE = 0x10,
83    F_CONTENT_LENGTH = 0x20,
84    F_SKIPBODY = 0x40,
85    F_TRAILING = 0x80,
86    F_TRANSFER_ENCODING = 0x200
87  };
88  typedef enum llhttp_flags llhttp_flags_t;
</pre></code></div>
                <div class="column column_space"><pre><code>18      NRF_UART_EVENT_CTS    = offsetof(NRF_UART_Type, EVENTS_CTS),   &bsol;**< Event from CTS line activation. */
19      NRF_UART_EVENT_NCTS   = offsetof(NRF_UART_Type, EVENTS_NCTS),  &bsol;**< Event from CTS line deactivation. */
20      NRF_UART_EVENT_RXDRDY = offsetof(NRF_UART_Type, EVENTS_RXDRDY),&bsol;**< Event from data ready in RXD. */
21      NRF_UART_EVENT_TXDRDY = offsetof(NRF_UART_Type, EVENTS_TXDRDY),&bsol;**< Event from data sent from TXD. */
22      NRF_UART_EVENT_ERROR  = offsetof(NRF_UART_Type, EVENTS_ERROR), &bsol;**< Event from error detection. */
23      NRF_UART_EVENT_RXTO   = offsetof(NRF_UART_Type, EVENTS_RXTO)   &bsol;**< Event from receiver timeout. */
24  } nrf_uart_event_t;
25  typedef enum
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    