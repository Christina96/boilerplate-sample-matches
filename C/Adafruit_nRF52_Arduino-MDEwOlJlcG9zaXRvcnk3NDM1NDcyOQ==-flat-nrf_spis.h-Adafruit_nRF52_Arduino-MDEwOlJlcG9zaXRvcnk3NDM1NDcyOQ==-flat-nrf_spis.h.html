
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spis.h</h3>
            <pre><code>1  #ifndef NRF_SPIS_H__
2  #define NRF_SPIS_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_SPIS_PIN_NOT_CONNECTED  0xFFFFFFFF
8  typedef enum
9  {
10      NRF_SPIS_TASK_ACQUIRE = offsetof(NRF_SPIS_Type, TASKS_ACQUIRE), 
11      NRF_SPIS_TASK_RELEASE = offsetof(NRF_SPIS_Type, TASKS_RELEASE), 
12  } nrf_spis_task_t;
13  typedef enum
14  {
15      NRF_SPIS_EVENT_END      = offsetof(NRF_SPIS_Type, EVENTS_END),     
16      NRF_SPIS_EVENT_ACQUIRED = offsetof(NRF_SPIS_Type, EVENTS_ACQUIRED) 
17  } nrf_spis_event_t;
18  typedef enum
19  {
20      NRF_SPIS_SHORT_END_ACQUIRE = SPIS_SHORTS_END_ACQUIRE_Msk 
21  } nrf_spis_short_mask_t;
22  typedef enum
23  {
24      NRF_SPIS_INT_END_MASK      = SPIS_INTENSET_END_Msk,     
25      NRF_SPIS_INT_ACQUIRED_MASK = SPIS_INTENSET_ACQUIRED_Msk 
26  } nrf_spis_int_mask_t;
27  typedef enum
28  {
29      NRF_SPIS_MODE_0, 
30      NRF_SPIS_MODE_1, 
31      NRF_SPIS_MODE_2, 
32      NRF_SPIS_MODE_3  
33  } nrf_spis_mode_t;
34  typedef enum
35  {
36      NRF_SPIS_BIT_ORDER_MSB_FIRST = SPIS_CONFIG_ORDER_MsbFirst, 
37      NRF_SPIS_BIT_ORDER_LSB_FIRST = SPIS_CONFIG_ORDER_LsbFirst  
38  } nrf_spis_bit_order_t;
39  typedef enum
40  {
41      NRF_SPIS_SEMSTAT_FREE       = 0, 
42      NRF_SPIS_SEMSTAT_CPU        = 1, 
43      NRF_SPIS_SEMSTAT_SPIS       = 2, 
44      NRF_SPIS_SEMSTAT_CPUPENDING = 3  
45  } nrf_spis_semstat_t;
46  typedef enum
47  {
48      NRF_SPIS_STATUS_OVERREAD = SPIS_STATUS_OVERREAD_Msk, 
49      NRF_SPIS_STATUS_OVERFLOW = SPIS_STATUS_OVERFLOW_Msk  
50  } nrf_spis_status_mask_t;
51  NRF_STATIC_INLINE void nrf_spis_task_trigger(NRF_SPIS_Type * p_reg,
52                                               nrf_spis_task_t task);
53  NRF_STATIC_INLINE uint32_t nrf_spis_task_address_get(NRF_SPIS_Type const * p_reg,
54                                                       nrf_spis_task_t       task);
55  NRF_STATIC_INLINE void nrf_spis_event_clear(NRF_SPIS_Type *  p_reg,
56                                              nrf_spis_event_t event);
57  NRF_STATIC_INLINE bool nrf_spis_event_check(NRF_SPIS_Type const * p_reg,
58                                              nrf_spis_event_t      event);
59  NRF_STATIC_INLINE uint32_t nrf_spis_event_address_get(NRF_SPIS_Type const * p_reg,
60                                                        nrf_spis_event_t      event);
61  NRF_STATIC_INLINE void nrf_spis_shorts_enable(NRF_SPIS_Type * p_reg,
62                                                uint32_t        mask);
63  NRF_STATIC_INLINE void nrf_spis_shorts_disable(NRF_SPIS_Type * p_reg,
64                                                 uint32_t        mask);
65  NRF_STATIC_INLINE void nrf_spis_int_enable(NRF_SPIS_Type * p_reg,
66                                             uint32_t        mask);
67  NRF_STATIC_INLINE void nrf_spis_int_disable(NRF_SPIS_Type * p_reg,
68                                              uint32_t        mask);
69  NRF_STATIC_INLINE uint32_t nrf_spis_int_enable_check(NRF_SPIS_Type const * p_reg, uint32_t mask);
70  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
71  NRF_STATIC_INLINE void nrf_spis_subscribe_set(NRF_SPIS_Type * p_reg,
72                                                nrf_spis_task_t task,
73                                                uint8_t         channel);
74  NRF_STATIC_INLINE void nrf_spis_subscribe_clear(NRF_SPIS_Type * p_reg,
75                                                  nrf_spis_task_t task);
76  NRF_STATIC_INLINE void nrf_spis_publish_set(NRF_SPIS_Type *  p_reg,
77                                              nrf_spis_event_t event,
78                                              uint8_t          channel);
79  NRF_STATIC_INLINE void nrf_spis_publish_clear(NRF_SPIS_Type *  p_reg,
80                                                nrf_spis_event_t event);
81  #endif 
82  NRF_STATIC_INLINE void nrf_spis_enable(NRF_SPIS_Type * p_reg);
83  NRF_STATIC_INLINE void nrf_spis_disable(NRF_SPIS_Type * p_reg);
84  NRF_STATIC_INLINE nrf_spis_semstat_t nrf_spis_semaphore_status_get(NRF_SPIS_Type const * p_reg);
85  NRF_STATIC_INLINE nrf_spis_status_mask_t nrf_spis_status_get(NRF_SPIS_Type const * p_reg);
86  NRF_STATIC_INLINE void nrf_spis_pins_set(NRF_SPIS_Type * p_reg,
87                                           uint32_t        sck_pin,
88                                           uint32_t        mosi_pin,
89                                           uint32_t        miso_pin,
90                                           uint32_t        csn_pin);
91  NRF_STATIC_INLINE void nrf_spis_tx_buffer_set(NRF_SPIS_Type * p_reg,
92                                                uint8_t const * p_buffer,
93                                                size_t          length);
94  NRF_STATIC_INLINE void nrf_spis_rx_buffer_set(NRF_SPIS_Type * p_reg,
95                                                uint8_t *       p_buffer,
96                                                size_t          length);
97  NRF_STATIC_INLINE size_t nrf_spis_tx_amount_get(NRF_SPIS_Type const * p_reg);
98  NRF_STATIC_INLINE size_t nrf_spis_rx_amount_get(NRF_SPIS_Type const * p_reg);
99  NRF_STATIC_INLINE void nrf_spis_configure(NRF_SPIS_Type *      p_reg,
100                                            nrf_spis_mode_t      spi_mode,
101                                            nrf_spis_bit_order_t spi_bit_order);
102  NRF_STATIC_INLINE void nrf_spis_def_set(NRF_SPIS_Type * p_reg,
103                                          uint8_t         def);
104  NRF_STATIC_INLINE void nrf_spis_orc_set(NRF_SPIS_Type * p_reg,
105                                          uint8_t         orc);
106  #if defined(SPIS_TXD_LIST_LIST_Msk) || defined(__NRFX_DOXYGEN__)
107  NRF_STATIC_INLINE void nrf_spis_tx_list_enable(NRF_SPIS_Type * p_reg);
108  NRF_STATIC_INLINE void nrf_spis_tx_list_disable(NRF_SPIS_Type * p_reg);
109  #endif 
110  #if defined(SPIS_RXD_LIST_LIST_Msk) || defined(__NRFX_DOXYGEN__)
111  NRF_STATIC_INLINE void nrf_spis_rx_list_enable(NRF_SPIS_Type * p_reg);
112  NRF_STATIC_INLINE void nrf_spis_rx_list_disable(NRF_SPIS_Type * p_reg);
113  #endif 
114  #ifndef NRF_DECLARE_ONLY
115  NRF_STATIC_INLINE void nrf_spis_task_trigger(NRF_SPIS_Type * p_reg,
116                                               nrf_spis_task_t task)
117  {
118      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
119  }
120  NRF_STATIC_INLINE uint32_t nrf_spis_task_address_get(NRF_SPIS_Type const * p_reg,
121                                                       nrf_spis_task_t       task)
122  {
123      return (uint32_t)p_reg + (uint32_t)task;
124  }
125  NRF_STATIC_INLINE void nrf_spis_event_clear(NRF_SPIS_Type *  p_reg,
126                                              nrf_spis_event_t event)
127  {
128      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
129  #if __CORTEX_M == 0x04
130      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
131      (void)dummy;
132  #endif
133  }
134  NRF_STATIC_INLINE bool nrf_spis_event_check(NRF_SPIS_Type const * p_reg,
135                                              nrf_spis_event_t      event)
136  {
137      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
138  }
139  NRF_STATIC_INLINE uint32_t nrf_spis_event_address_get(NRF_SPIS_Type const * p_reg,
140                                                        nrf_spis_event_t      event)
141  {
142      return (uint32_t)p_reg + (uint32_t)event;
143  }
144  NRF_STATIC_INLINE void nrf_spis_shorts_enable(NRF_SPIS_Type * p_reg,
145                                                uint32_t        mask)
146  {
147      p_reg->SHORTS |= mask;
148  }
149  NRF_STATIC_INLINE void nrf_spis_shorts_disable(NRF_SPIS_Type * p_reg,
150                                                 uint32_t        mask)
151  {
152      p_reg->SHORTS &= ~(mask);
153  }
154  NRF_STATIC_INLINE void nrf_spis_int_enable(NRF_SPIS_Type * p_reg,
155                                             uint32_t        mask)
156  {
157      p_reg->INTENSET = mask;
158  }
159  NRF_STATIC_INLINE void nrf_spis_int_disable(NRF_SPIS_Type * p_reg,
160                                              uint32_t mask)
161  {
162      p_reg->INTENCLR = mask;
163  }
164  NRF_STATIC_INLINE uint32_t nrf_spis_int_enable_check(NRF_SPIS_Type const * p_reg, uint32_t mask)
165  {
166      return p_reg->INTENSET & mask;
167  }
168  #if defined(DPPI_PRESENT)
169  NRF_STATIC_INLINE void nrf_spis_subscribe_set(NRF_SPIS_Type * p_reg,
170                                                nrf_spis_task_t task,
171                                                uint8_t         channel)
172  {
173      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
174              ((uint32_t)channel | SPIS_SUBSCRIBE_ACQUIRE_EN_Msk);
175  }
176  NRF_STATIC_INLINE void nrf_spis_subscribe_clear(NRF_SPIS_Type * p_reg,
177                                                  nrf_spis_task_t task)
178  {
179      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
180  }
181  NRF_STATIC_INLINE void nrf_spis_publish_set(NRF_SPIS_Type *  p_reg,
182                                              nrf_spis_event_t event,
183                                              uint8_t          channel)
184  {
185      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
186              ((uint32_t)channel | SPIS_PUBLISH_END_EN_Msk);
187  }
188  NRF_STATIC_INLINE void nrf_spis_publish_clear(NRF_SPIS_Type *  p_reg,
189                                                nrf_spis_event_t event)
190  {
191      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
192  }
193  #endif 
194  NRF_STATIC_INLINE void nrf_spis_enable(NRF_SPIS_Type * p_reg)
195  {
196      p_reg->ENABLE = (SPIS_ENABLE_ENABLE_Enabled << SPIS_ENABLE_ENABLE_Pos);
197  }
198  NRF_STATIC_INLINE void nrf_spis_disable(NRF_SPIS_Type * p_reg)
199  {
200      p_reg->ENABLE = (SPIS_ENABLE_ENABLE_Disabled << SPIS_ENABLE_ENABLE_Pos);
201  }
202  NRF_STATIC_INLINE nrf_spis_semstat_t nrf_spis_semaphore_status_get(NRF_SPIS_Type const * p_reg)
203  {
204      return (nrf_spis_semstat_t) ((p_reg->SEMSTAT & SPIS_SEMSTAT_SEMSTAT_Msk)
205                                   >> SPIS_SEMSTAT_SEMSTAT_Pos);
206  }
207  NRF_STATIC_INLINE nrf_spis_status_mask_t nrf_spis_status_get(NRF_SPIS_Type const * p_reg)
208  {
209      return (nrf_spis_status_mask_t) p_reg->STATUS;
210  }
211  NRF_STATIC_INLINE void nrf_spis_pins_set(NRF_SPIS_Type * p_reg,
212                                           uint32_t        sck_pin,
213                                           uint32_t        mosi_pin,
214                                           uint32_t        miso_pin,
215                                           uint32_t        csn_pin)
216  {
217  #if defined (NRF51)
218      p_reg->PSELSCK  = sck_pin;
219      p_reg->PSELMOSI = mosi_pin;
220      p_reg->PSELMISO = miso_pin;
221      p_reg->PSELCSN  = csn_pin;
222  #else
223      p_reg->PSEL.SCK  = sck_pin;
224      p_reg->PSEL.MOSI = mosi_pin;
225      p_reg->PSEL.MISO = miso_pin;
226      p_reg->PSEL.CSN  = csn_pin;
227  #endif
228  }
229  NRF_STATIC_INLINE void nrf_spis_tx_buffer_set(NRF_SPIS_Type * p_reg,
230                                                uint8_t const * p_buffer,
231                                                size_t          length)
232  {
233  #if defined (NRF51)
<span onclick='openModal()' class='match'>234      p_reg->TXDPTR = (uint32_t)p_buffer;
235      p_reg->MAXTX  = length;
236  #else
</span>237      p_reg->TXD.PTR    = (uint32_t)p_buffer;
238      p_reg->TXD.MAXCNT = length;
239  #endif
240  }
241  NRF_STATIC_INLINE void nrf_spis_rx_buffer_set(NRF_SPIS_Type * p_reg,
242                                                uint8_t *       p_buffer,
243                                                size_t          length)
244  {
245  #if defined (NRF51)
246      p_reg->RXDPTR = (uint32_t)p_buffer;
247      p_reg->MAXRX  = length;
248  #else
249      p_reg->RXD.PTR    = (uint32_t)p_buffer;
250      p_reg->RXD.MAXCNT = length;
251  #endif
252  }
253  NRF_STATIC_INLINE size_t nrf_spis_tx_amount_get(NRF_SPIS_Type const * p_reg)
254  {
255  #if defined (NRF51)
256      return p_reg->AMOUNTTX;
257  #else
258      return p_reg->TXD.AMOUNT;
259  #endif
260  }
261  NRF_STATIC_INLINE size_t nrf_spis_rx_amount_get(NRF_SPIS_Type const * p_reg)
262  {
263  #if defined (NRF51)
264      return p_reg->AMOUNTRX;
265  #else
266      return p_reg->RXD.AMOUNT;
267  #endif
268  }
269  NRF_STATIC_INLINE void nrf_spis_configure(NRF_SPIS_Type *      p_reg,
270                                            nrf_spis_mode_t      spi_mode,
271                                            nrf_spis_bit_order_t spi_bit_order)
272  {
273      uint32_t config = (spi_bit_order == NRF_SPIS_BIT_ORDER_MSB_FIRST ?
274          SPIS_CONFIG_ORDER_MsbFirst : SPIS_CONFIG_ORDER_LsbFirst);
275      switch (spi_mode)
276      {
277      default:
278      case NRF_SPIS_MODE_0:
279          config |= (SPIS_CONFIG_CPOL_ActiveHigh << SPIS_CONFIG_CPOL_Pos) |
280                    (SPIS_CONFIG_CPHA_Leading    << SPIS_CONFIG_CPHA_Pos);
281          break;
282      case NRF_SPIS_MODE_1:
283          config |= (SPIS_CONFIG_CPOL_ActiveHigh << SPIS_CONFIG_CPOL_Pos) |
284                    (SPIS_CONFIG_CPHA_Trailing   << SPIS_CONFIG_CPHA_Pos);
285          break;
286      case NRF_SPIS_MODE_2:
287          config |= (SPIS_CONFIG_CPOL_ActiveLow  << SPIS_CONFIG_CPOL_Pos) |
288                    (SPIS_CONFIG_CPHA_Leading    << SPIS_CONFIG_CPHA_Pos);
289          break;
290      case NRF_SPIS_MODE_3:
291          config |= (SPIS_CONFIG_CPOL_ActiveLow  << SPIS_CONFIG_CPOL_Pos) |
292                    (SPIS_CONFIG_CPHA_Trailing   << SPIS_CONFIG_CPHA_Pos);
293          break;
294      }
295      p_reg->CONFIG = config;
296  }
297  NRF_STATIC_INLINE void nrf_spis_orc_set(NRF_SPIS_Type * p_reg,
298                                          uint8_t         orc)
299  {
300      p_reg->ORC = orc;
301  }
302  NRF_STATIC_INLINE void nrf_spis_def_set(NRF_SPIS_Type * p_reg,
303                                          uint8_t         def)
304  {
305      p_reg->DEF = def;
306  }
307  #if defined(SPIS_TXD_LIST_LIST_Msk)
308  NRF_STATIC_INLINE void nrf_spis_tx_list_enable(NRF_SPIS_Type * p_reg)
309  {
310      p_reg->TXD.LIST = SPIS_TXD_LIST_LIST_ArrayList << SPIS_TXD_LIST_LIST_Pos;
311  }
312  NRF_STATIC_INLINE void nrf_spis_tx_list_disable(NRF_SPIS_Type * p_reg)
313  {
314      p_reg->TXD.LIST = SPIS_TXD_LIST_LIST_Disabled << SPIS_TXD_LIST_LIST_Pos;
315  }
316  #endif 
317  #if defined(SPIS_RXD_LIST_LIST_Msk)
318  NRF_STATIC_INLINE void nrf_spis_rx_list_enable(NRF_SPIS_Type * p_reg)
319  {
320      p_reg->RXD.LIST = SPIS_RXD_LIST_LIST_ArrayList << SPIS_RXD_LIST_LIST_Pos;
321  }
322  NRF_STATIC_INLINE void nrf_spis_rx_list_disable(NRF_SPIS_Type * p_reg)
323  {
324      p_reg->RXD.LIST = SPIS_RXD_LIST_LIST_Disabled << SPIS_RXD_LIST_LIST_Pos;
325  }
326  #endif 
327  #endif 
328  #ifdef __cplusplus
329  }
330  #endif
331  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spis.h</h3>
            <pre><code>1  #ifndef NRF_SPIS_H__
2  #define NRF_SPIS_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_SPIS_PIN_NOT_CONNECTED  0xFFFFFFFF
8  typedef enum
9  {
10      NRF_SPIS_TASK_ACQUIRE = offsetof(NRF_SPIS_Type, TASKS_ACQUIRE), 
11      NRF_SPIS_TASK_RELEASE = offsetof(NRF_SPIS_Type, TASKS_RELEASE), 
12  } nrf_spis_task_t;
13  typedef enum
14  {
15      NRF_SPIS_EVENT_END      = offsetof(NRF_SPIS_Type, EVENTS_END),     
16      NRF_SPIS_EVENT_ACQUIRED = offsetof(NRF_SPIS_Type, EVENTS_ACQUIRED) 
17  } nrf_spis_event_t;
18  typedef enum
19  {
20      NRF_SPIS_SHORT_END_ACQUIRE = SPIS_SHORTS_END_ACQUIRE_Msk 
21  } nrf_spis_short_mask_t;
22  typedef enum
23  {
24      NRF_SPIS_INT_END_MASK      = SPIS_INTENSET_END_Msk,     
25      NRF_SPIS_INT_ACQUIRED_MASK = SPIS_INTENSET_ACQUIRED_Msk 
26  } nrf_spis_int_mask_t;
27  typedef enum
28  {
29      NRF_SPIS_MODE_0, 
30      NRF_SPIS_MODE_1, 
31      NRF_SPIS_MODE_2, 
32      NRF_SPIS_MODE_3  
33  } nrf_spis_mode_t;
34  typedef enum
35  {
36      NRF_SPIS_BIT_ORDER_MSB_FIRST = SPIS_CONFIG_ORDER_MsbFirst, 
37      NRF_SPIS_BIT_ORDER_LSB_FIRST = SPIS_CONFIG_ORDER_LsbFirst  
38  } nrf_spis_bit_order_t;
39  typedef enum
40  {
41      NRF_SPIS_SEMSTAT_FREE       = 0, 
42      NRF_SPIS_SEMSTAT_CPU        = 1, 
43      NRF_SPIS_SEMSTAT_SPIS       = 2, 
44      NRF_SPIS_SEMSTAT_CPUPENDING = 3  
45  } nrf_spis_semstat_t;
46  typedef enum
47  {
48      NRF_SPIS_STATUS_OVERREAD = SPIS_STATUS_OVERREAD_Msk, 
49      NRF_SPIS_STATUS_OVERFLOW = SPIS_STATUS_OVERFLOW_Msk  
50  } nrf_spis_status_mask_t;
51  NRF_STATIC_INLINE void nrf_spis_task_trigger(NRF_SPIS_Type * p_reg,
52                                               nrf_spis_task_t task);
53  NRF_STATIC_INLINE uint32_t nrf_spis_task_address_get(NRF_SPIS_Type const * p_reg,
54                                                       nrf_spis_task_t       task);
55  NRF_STATIC_INLINE void nrf_spis_event_clear(NRF_SPIS_Type *  p_reg,
56                                              nrf_spis_event_t event);
57  NRF_STATIC_INLINE bool nrf_spis_event_check(NRF_SPIS_Type const * p_reg,
58                                              nrf_spis_event_t      event);
59  NRF_STATIC_INLINE uint32_t nrf_spis_event_address_get(NRF_SPIS_Type const * p_reg,
60                                                        nrf_spis_event_t      event);
61  NRF_STATIC_INLINE void nrf_spis_shorts_enable(NRF_SPIS_Type * p_reg,
62                                                uint32_t        mask);
63  NRF_STATIC_INLINE void nrf_spis_shorts_disable(NRF_SPIS_Type * p_reg,
64                                                 uint32_t        mask);
65  NRF_STATIC_INLINE void nrf_spis_int_enable(NRF_SPIS_Type * p_reg,
66                                             uint32_t        mask);
67  NRF_STATIC_INLINE void nrf_spis_int_disable(NRF_SPIS_Type * p_reg,
68                                              uint32_t        mask);
69  NRF_STATIC_INLINE uint32_t nrf_spis_int_enable_check(NRF_SPIS_Type const * p_reg, uint32_t mask);
70  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
71  NRF_STATIC_INLINE void nrf_spis_subscribe_set(NRF_SPIS_Type * p_reg,
72                                                nrf_spis_task_t task,
73                                                uint8_t         channel);
74  NRF_STATIC_INLINE void nrf_spis_subscribe_clear(NRF_SPIS_Type * p_reg,
75                                                  nrf_spis_task_t task);
76  NRF_STATIC_INLINE void nrf_spis_publish_set(NRF_SPIS_Type *  p_reg,
77                                              nrf_spis_event_t event,
78                                              uint8_t          channel);
79  NRF_STATIC_INLINE void nrf_spis_publish_clear(NRF_SPIS_Type *  p_reg,
80                                                nrf_spis_event_t event);
81  #endif 
82  NRF_STATIC_INLINE void nrf_spis_enable(NRF_SPIS_Type * p_reg);
83  NRF_STATIC_INLINE void nrf_spis_disable(NRF_SPIS_Type * p_reg);
84  NRF_STATIC_INLINE nrf_spis_semstat_t nrf_spis_semaphore_status_get(NRF_SPIS_Type const * p_reg);
85  NRF_STATIC_INLINE nrf_spis_status_mask_t nrf_spis_status_get(NRF_SPIS_Type const * p_reg);
86  NRF_STATIC_INLINE void nrf_spis_pins_set(NRF_SPIS_Type * p_reg,
87                                           uint32_t        sck_pin,
88                                           uint32_t        mosi_pin,
89                                           uint32_t        miso_pin,
90                                           uint32_t        csn_pin);
91  NRF_STATIC_INLINE void nrf_spis_tx_buffer_set(NRF_SPIS_Type * p_reg,
92                                                uint8_t const * p_buffer,
93                                                size_t          length);
94  NRF_STATIC_INLINE void nrf_spis_rx_buffer_set(NRF_SPIS_Type * p_reg,
95                                                uint8_t *       p_buffer,
96                                                size_t          length);
97  NRF_STATIC_INLINE size_t nrf_spis_tx_amount_get(NRF_SPIS_Type const * p_reg);
98  NRF_STATIC_INLINE size_t nrf_spis_rx_amount_get(NRF_SPIS_Type const * p_reg);
99  NRF_STATIC_INLINE void nrf_spis_configure(NRF_SPIS_Type *      p_reg,
100                                            nrf_spis_mode_t      spi_mode,
101                                            nrf_spis_bit_order_t spi_bit_order);
102  NRF_STATIC_INLINE void nrf_spis_def_set(NRF_SPIS_Type * p_reg,
103                                          uint8_t         def);
104  NRF_STATIC_INLINE void nrf_spis_orc_set(NRF_SPIS_Type * p_reg,
105                                          uint8_t         orc);
106  #if defined(SPIS_TXD_LIST_LIST_Msk) || defined(__NRFX_DOXYGEN__)
107  NRF_STATIC_INLINE void nrf_spis_tx_list_enable(NRF_SPIS_Type * p_reg);
108  NRF_STATIC_INLINE void nrf_spis_tx_list_disable(NRF_SPIS_Type * p_reg);
109  #endif 
110  #if defined(SPIS_RXD_LIST_LIST_Msk) || defined(__NRFX_DOXYGEN__)
111  NRF_STATIC_INLINE void nrf_spis_rx_list_enable(NRF_SPIS_Type * p_reg);
112  NRF_STATIC_INLINE void nrf_spis_rx_list_disable(NRF_SPIS_Type * p_reg);
113  #endif 
114  #ifndef NRF_DECLARE_ONLY
115  NRF_STATIC_INLINE void nrf_spis_task_trigger(NRF_SPIS_Type * p_reg,
116                                               nrf_spis_task_t task)
117  {
118      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
119  }
120  NRF_STATIC_INLINE uint32_t nrf_spis_task_address_get(NRF_SPIS_Type const * p_reg,
121                                                       nrf_spis_task_t       task)
122  {
123      return (uint32_t)p_reg + (uint32_t)task;
124  }
125  NRF_STATIC_INLINE void nrf_spis_event_clear(NRF_SPIS_Type *  p_reg,
126                                              nrf_spis_event_t event)
127  {
128      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
129  #if __CORTEX_M == 0x04
130      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
131      (void)dummy;
132  #endif
133  }
134  NRF_STATIC_INLINE bool nrf_spis_event_check(NRF_SPIS_Type const * p_reg,
135                                              nrf_spis_event_t      event)
136  {
137      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
138  }
139  NRF_STATIC_INLINE uint32_t nrf_spis_event_address_get(NRF_SPIS_Type const * p_reg,
140                                                        nrf_spis_event_t      event)
141  {
142      return (uint32_t)p_reg + (uint32_t)event;
143  }
144  NRF_STATIC_INLINE void nrf_spis_shorts_enable(NRF_SPIS_Type * p_reg,
145                                                uint32_t        mask)
146  {
147      p_reg->SHORTS |= mask;
148  }
149  NRF_STATIC_INLINE void nrf_spis_shorts_disable(NRF_SPIS_Type * p_reg,
150                                                 uint32_t        mask)
151  {
152      p_reg->SHORTS &= ~(mask);
153  }
154  NRF_STATIC_INLINE void nrf_spis_int_enable(NRF_SPIS_Type * p_reg,
155                                             uint32_t        mask)
156  {
157      p_reg->INTENSET = mask;
158  }
159  NRF_STATIC_INLINE void nrf_spis_int_disable(NRF_SPIS_Type * p_reg,
160                                              uint32_t mask)
161  {
162      p_reg->INTENCLR = mask;
163  }
164  NRF_STATIC_INLINE uint32_t nrf_spis_int_enable_check(NRF_SPIS_Type const * p_reg, uint32_t mask)
165  {
166      return p_reg->INTENSET & mask;
167  }
168  #if defined(DPPI_PRESENT)
169  NRF_STATIC_INLINE void nrf_spis_subscribe_set(NRF_SPIS_Type * p_reg,
170                                                nrf_spis_task_t task,
171                                                uint8_t         channel)
172  {
173      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
174              ((uint32_t)channel | SPIS_SUBSCRIBE_ACQUIRE_EN_Msk);
175  }
176  NRF_STATIC_INLINE void nrf_spis_subscribe_clear(NRF_SPIS_Type * p_reg,
177                                                  nrf_spis_task_t task)
178  {
179      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
180  }
181  NRF_STATIC_INLINE void nrf_spis_publish_set(NRF_SPIS_Type *  p_reg,
182                                              nrf_spis_event_t event,
183                                              uint8_t          channel)
184  {
185      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
186              ((uint32_t)channel | SPIS_PUBLISH_END_EN_Msk);
187  }
188  NRF_STATIC_INLINE void nrf_spis_publish_clear(NRF_SPIS_Type *  p_reg,
189                                                nrf_spis_event_t event)
190  {
191      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
192  }
193  #endif 
194  NRF_STATIC_INLINE void nrf_spis_enable(NRF_SPIS_Type * p_reg)
195  {
196      p_reg->ENABLE = (SPIS_ENABLE_ENABLE_Enabled << SPIS_ENABLE_ENABLE_Pos);
197  }
198  NRF_STATIC_INLINE void nrf_spis_disable(NRF_SPIS_Type * p_reg)
199  {
200      p_reg->ENABLE = (SPIS_ENABLE_ENABLE_Disabled << SPIS_ENABLE_ENABLE_Pos);
201  }
202  NRF_STATIC_INLINE nrf_spis_semstat_t nrf_spis_semaphore_status_get(NRF_SPIS_Type const * p_reg)
203  {
204      return (nrf_spis_semstat_t) ((p_reg->SEMSTAT & SPIS_SEMSTAT_SEMSTAT_Msk)
205                                   >> SPIS_SEMSTAT_SEMSTAT_Pos);
206  }
207  NRF_STATIC_INLINE nrf_spis_status_mask_t nrf_spis_status_get(NRF_SPIS_Type const * p_reg)
208  {
209      return (nrf_spis_status_mask_t) p_reg->STATUS;
210  }
211  NRF_STATIC_INLINE void nrf_spis_pins_set(NRF_SPIS_Type * p_reg,
212                                           uint32_t        sck_pin,
213                                           uint32_t        mosi_pin,
214                                           uint32_t        miso_pin,
215                                           uint32_t        csn_pin)
216  {
217  #if defined (NRF51)
218      p_reg->PSELSCK  = sck_pin;
219      p_reg->PSELMOSI = mosi_pin;
220      p_reg->PSELMISO = miso_pin;
221      p_reg->PSELCSN  = csn_pin;
222  #else
223      p_reg->PSEL.SCK  = sck_pin;
224      p_reg->PSEL.MOSI = mosi_pin;
225      p_reg->PSEL.MISO = miso_pin;
226      p_reg->PSEL.CSN  = csn_pin;
227  #endif
228  }
229  NRF_STATIC_INLINE void nrf_spis_tx_buffer_set(NRF_SPIS_Type * p_reg,
230                                                uint8_t const * p_buffer,
231                                                size_t          length)
232  {
233  #if defined (NRF51)
<span onclick='openModal()' class='match'>234      p_reg->TXDPTR = (uint32_t)p_buffer;
235      p_reg->MAXTX  = length;
236  #else
</span>237      p_reg->TXD.PTR    = (uint32_t)p_buffer;
238      p_reg->TXD.MAXCNT = length;
239  #endif
240  }
241  NRF_STATIC_INLINE void nrf_spis_rx_buffer_set(NRF_SPIS_Type * p_reg,
242                                                uint8_t *       p_buffer,
243                                                size_t          length)
244  {
245  #if defined (NRF51)
246      p_reg->RXDPTR = (uint32_t)p_buffer;
247      p_reg->MAXRX  = length;
248  #else
249      p_reg->RXD.PTR    = (uint32_t)p_buffer;
250      p_reg->RXD.MAXCNT = length;
251  #endif
252  }
253  NRF_STATIC_INLINE size_t nrf_spis_tx_amount_get(NRF_SPIS_Type const * p_reg)
254  {
255  #if defined (NRF51)
256      return p_reg->AMOUNTTX;
257  #else
258      return p_reg->TXD.AMOUNT;
259  #endif
260  }
261  NRF_STATIC_INLINE size_t nrf_spis_rx_amount_get(NRF_SPIS_Type const * p_reg)
262  {
263  #if defined (NRF51)
264      return p_reg->AMOUNTRX;
265  #else
266      return p_reg->RXD.AMOUNT;
267  #endif
268  }
269  NRF_STATIC_INLINE void nrf_spis_configure(NRF_SPIS_Type *      p_reg,
270                                            nrf_spis_mode_t      spi_mode,
271                                            nrf_spis_bit_order_t spi_bit_order)
272  {
273      uint32_t config = (spi_bit_order == NRF_SPIS_BIT_ORDER_MSB_FIRST ?
274          SPIS_CONFIG_ORDER_MsbFirst : SPIS_CONFIG_ORDER_LsbFirst);
275      switch (spi_mode)
276      {
277      default:
278      case NRF_SPIS_MODE_0:
279          config |= (SPIS_CONFIG_CPOL_ActiveHigh << SPIS_CONFIG_CPOL_Pos) |
280                    (SPIS_CONFIG_CPHA_Leading    << SPIS_CONFIG_CPHA_Pos);
281          break;
282      case NRF_SPIS_MODE_1:
283          config |= (SPIS_CONFIG_CPOL_ActiveHigh << SPIS_CONFIG_CPOL_Pos) |
284                    (SPIS_CONFIG_CPHA_Trailing   << SPIS_CONFIG_CPHA_Pos);
285          break;
286      case NRF_SPIS_MODE_2:
287          config |= (SPIS_CONFIG_CPOL_ActiveLow  << SPIS_CONFIG_CPOL_Pos) |
288                    (SPIS_CONFIG_CPHA_Leading    << SPIS_CONFIG_CPHA_Pos);
289          break;
290      case NRF_SPIS_MODE_3:
291          config |= (SPIS_CONFIG_CPOL_ActiveLow  << SPIS_CONFIG_CPOL_Pos) |
292                    (SPIS_CONFIG_CPHA_Trailing   << SPIS_CONFIG_CPHA_Pos);
293          break;
294      }
295      p_reg->CONFIG = config;
296  }
297  NRF_STATIC_INLINE void nrf_spis_orc_set(NRF_SPIS_Type * p_reg,
298                                          uint8_t         orc)
299  {
300      p_reg->ORC = orc;
301  }
302  NRF_STATIC_INLINE void nrf_spis_def_set(NRF_SPIS_Type * p_reg,
303                                          uint8_t         def)
304  {
305      p_reg->DEF = def;
306  }
307  #if defined(SPIS_TXD_LIST_LIST_Msk)
308  NRF_STATIC_INLINE void nrf_spis_tx_list_enable(NRF_SPIS_Type * p_reg)
309  {
310      p_reg->TXD.LIST = SPIS_TXD_LIST_LIST_ArrayList << SPIS_TXD_LIST_LIST_Pos;
311  }
312  NRF_STATIC_INLINE void nrf_spis_tx_list_disable(NRF_SPIS_Type * p_reg)
313  {
314      p_reg->TXD.LIST = SPIS_TXD_LIST_LIST_Disabled << SPIS_TXD_LIST_LIST_Pos;
315  }
316  #endif 
317  #if defined(SPIS_RXD_LIST_LIST_Msk)
318  NRF_STATIC_INLINE void nrf_spis_rx_list_enable(NRF_SPIS_Type * p_reg)
319  {
320      p_reg->RXD.LIST = SPIS_RXD_LIST_LIST_ArrayList << SPIS_RXD_LIST_LIST_Pos;
321  }
322  NRF_STATIC_INLINE void nrf_spis_rx_list_disable(NRF_SPIS_Type * p_reg)
323  {
324      p_reg->RXD.LIST = SPIS_RXD_LIST_LIST_Disabled << SPIS_RXD_LIST_LIST_Pos;
325  }
326  #endif 
327  #endif 
328  #ifdef __cplusplus
329  }
330  #endif
331  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spis.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spis.h</div>
                </div>
                <div class="column column_space"><pre><code>234      p_reg->TXDPTR = (uint32_t)p_buffer;
235      p_reg->MAXTX  = length;
236  #else
</pre></code></div>
                <div class="column column_space"><pre><code>234      p_reg->TXDPTR = (uint32_t)p_buffer;
235      p_reg->MAXTX  = length;
236  #else
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    