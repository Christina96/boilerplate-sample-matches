<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-communication-central-method.c &amp; inf-adopted-algorithm.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-communication-central-method.c &amp; inf-adopted-algorithm.c
      </h3>
<h1 align="center">
        8.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-communication-central-method.c (16.044777%)<th>inf-adopted-algorithm.c (5.5771723%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(561-586)<td><a href="#" name="0">(1235-1260)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(606-645)<td><a href="#" name="1">(1301-1318)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(157-191)<td><a href="#" name="2">(1261-1284)</a><td align="center"><font color="#ee0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-communication-central-method.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/communication/inf-communication-central-method.h&gt;
2 #include &lt;libinfinity/communication/inf-communication-hosted-group.h&gt;
3 #include &lt;libinfinity/communication/inf-communication-registry.h&gt;
4 #include &lt;libinfinity/inf-signals.h&gt;
5 typedef struct _InfCommunicationCentralMethodPrivate
6   InfCommunicationCentralMethodPrivate;
7 struct _InfCommunicationCentralMethodPrivate {
8   InfCommunicationRegistry* registry;
9   InfCommunicationGroup* group;
10   gboolean is_publisher; 
11   GSList* connections;
12 };
13 enum {
14   PROP_0,
15   PROP_REGISTRY,
16   PROP_GROUP
17 };
18 #define INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_COMMUNICATION_TYPE_CENTRAL_METHOD, InfCommunicationCentralMethodPrivate))
19 static void inf_communication_central_method_method_iface_init(InfCommunicationMethodInterface* iface);
20 G_DEFINE_TYPE_WITH_CODE(InfCommunicationCentralMethod, inf_communication_central_method, G_TYPE_OBJECT,
21   G_ADD_PRIVATE(InfCommunicationCentralMethod)
22   G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_METHOD, inf_communication_central_method_method_iface_init))
23 static void
24 inf_communication_central_method_broadcast(InfCommunicationMethod* method,
25                                            xmlNodePtr xml,
26                                            InfXmlConnection* except)
27 {
28   InfCommunicationCentralMethodPrivate* priv;
29   InfCommunicationRegistry* registry;
30   InfCommunicationGroup* group;
31   GSList* connections;
32   GSList* item;
33   InfXmlConnection* connection;
34   gboolean is_registered;
35   InfXmlConnectionStatus status;
36   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
37   g_object_ref(method);
38   registry = g_object_ref(priv-&gt;registry);
39   group = g_object_ref(priv-&gt;group);
40   connections = g_slist_copy(priv-&gt;connections);
41   for(item = connections; item != NULL; item = item-&gt;next)
42     g_object_ref(item-&gt;data);
43   while(connections)
44   {
45     connection = INF_XML_CONNECTION(connections-&gt;data);
46     is_registered = inf_communication_registry_is_registered(
47       registry,
48       group,
49       connection
50     );
51     g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
52     if(is_registered &amp;&amp;
53        status == INF_XML_CONNECTION_OPEN &amp;&amp;
54        connection != except)
55     {
56       if(connections-&gt;next != NULL)
57       {
58         inf_communication_registry_send(
59           registry,
60           group,
61           connection,
62           xmlCopyNode(xml, 1)
63         );
64       }
65       else
66       {
67         inf_communication_registry_send(registry, group, connection, xml);
68         xml = NULL;
69       }
70     }
71     g_object_unref(connection);
72     connections = g_slist_delete_link(connections, connections);
73   }
74   g_object_unref(method);
75   g_object_unref(registry);
76   g_object_unref(group);
77   if(xml != NULL)
78     xmlFreeNode(xml);
79 }
80 static void
81 inf_communication_central_method_notify_status_cb(GObject* object,
82                                                   GParamSpec* pspec,
83                                                   gpointer user_data)
84 {
85   InfCommunicationCentralMethod* method;
86   InfCommunicationCentralMethodPrivate* priv;
87   InfXmlConnectionStatus status;
88   method = INF_COMMUNICATION_CENTRAL_METHOD(user_data);
89   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
90   g_object_get(object, "status", &amp;status, NULL);
91 <a name="2"></a>  switch(status)
92   {
93   case INF_XML_CONNECTION_CLOSED:
94 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case INF_XML_CONNECTION_CLOSING:
95     g_object_ref(priv-&gt;group);
96     inf_communication_method_remove_member(
97       INF_COMMUNICATION_METHOD(method),
98       INF_XML_CONNECTION(object)
99     );
100     g_object_unref(priv-&gt;group);
101     break;
102   case INF_XML_CONNECTION_OPENING:
103     break;
104   case INF_XML_CONNECTION_OPEN:
105     inf_communication_registry_register(
106       priv-&gt;registry,
107       priv-&gt;group,
108       INF_COMMUNICATION_METHOD(method),
109       INF_XML_CONNECTION(object)
110     );
111     break;
112   default:
113     g_assert_not_reached();
114     break;
115   }
116 }
117 static void
118 inf_communication_central_method_add_member(InfCommunicationMethod* method,
119                                             InfXmlConnection* connection)
120 {
121   InfCommunicationCentralMethodPrivate* priv;
122   InfXmlConnectionStatus status;
123   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);</b></font>
124   g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
125   g_assert(status != INF_XML_CONNECTION_CLOSING &amp;&amp; 
126            status != INF_XML_CONNECTION_CLOSED);
127   priv-&gt;connections = g_slist_prepend(priv-&gt;connections, connection);
128   g_signal_connect(
129     connection,
130     "notify::status",
131     G_CALLBACK(inf_communication_central_method_notify_status_cb),
132     method
133   );
134   if(status == INF_XML_CONNECTION_OPEN)
135   {
136     inf_communication_registry_register(
137       priv-&gt;registry,
138       priv-&gt;group,
139       method,
140       connection
141     );
142   }
143 }
144 static void
145 inf_communication_central_method_remove_member(InfCommunicationMethod* method,
146                                                InfXmlConnection* connection)
147 {
148   InfCommunicationCentralMethodPrivate* priv;
149   InfXmlConnectionStatus status;
150   gboolean is_registered;
151   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
152   g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
153   is_registered = inf_communication_registry_is_registered(
154     priv-&gt;registry,
155     priv-&gt;group,
156     connection
157   );
158   if(is_registered)
159   {
160     inf_communication_registry_unregister(
161       priv-&gt;registry,
162       priv-&gt;group,
163       connection
164     );
165   }
166   inf_signal_handlers_disconnect_by_func(
167     connection,
168     G_CALLBACK(inf_communication_central_method_notify_status_cb),
169     method
170   );
171   priv-&gt;connections = g_slist_remove(priv-&gt;connections, connection);
172 }
173 static gboolean
174 inf_communication_central_method_is_member(InfCommunicationMethod* method,
175                                            InfXmlConnection* connection)
176 {
177   InfCommunicationCentralMethodPrivate* priv;
178   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
179   if(g_slist_find(priv-&gt;connections, connection) == NULL)
180     return FALSE;
181   return TRUE;
182 }
183 static void
184 inf_communication_central_method_send_single(InfCommunicationMethod* method,
185                                              InfXmlConnection* connection,
186                                              xmlNodePtr xml)
187 {
188   InfCommunicationCentralMethodPrivate* priv;
189   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
190   inf_communication_registry_send(
191     priv-&gt;registry,
192     priv-&gt;group,
193     connection,
194     xml
195   );
196 }
197 static void
198 inf_communication_central_method_send_all(InfCommunicationMethod* method,
199                                           xmlNodePtr xml)
200 {
201   inf_communication_central_method_broadcast(method, xml, NULL);
202 }
203 static void
204 inf_communication_central_method_cancel_messages(InfCommunicationMethod* meth,
205                                                  InfXmlConnection* connection)
206 {
207   InfCommunicationCentralMethodPrivate* priv;
208   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(meth);
209   inf_communication_registry_cancel_messages(
210     priv-&gt;registry,
211     priv-&gt;group,
212     connection
213   );
214 }
215 static InfCommunicationScope
216 inf_communication_central_method_received(InfCommunicationMethod* method,
217                                           InfXmlConnection* connection,
218                                           xmlNodePtr xml)
219 {
220   InfCommunicationCentralMethodPrivate* priv;
221   InfCommunicationObject* target;
222   InfCommunicationGroup* group;
223   InfCommunicationScope scope;
224   gchar* remote_id;
225   gchar* publisher_id;
226   GSList* item;
227   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
228   target = inf_communication_group_get_target(priv-&gt;group);
229   group = priv-&gt;group;
230   if(target != NULL)
231   {
232     g_object_ref(target);
233     g_object_ref(group);
234     g_object_ref(method);
235     scope = inf_communication_object_received(
236       target,
237       connection,
238       xml
239     );
240     if(priv-&gt;is_publisher &amp;&amp; scope == INF_COMMUNICATION_SCOPE_GROUP)
241     {
242       inf_communication_central_method_broadcast(
243         method,
244         xmlCopyNode(xml, 1),
245         connection
246       );
247     }
248     g_object_unref(method);
249     g_object_unref(group);
250     g_object_unref(target);
251     return scope;
252   }
253   else
254   {
255     return INF_COMMUNICATION_SCOPE_PTP;
256   }
257 }
258 static void
259 inf_communication_central_method_enqueued(InfCommunicationMethod* method,
260                                           InfXmlConnection* connection,
261                                           xmlNodePtr xml)
262 {
263   InfCommunicationCentralMethodPrivate* priv;
264   InfCommunicationObject* target;
265   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
266   target = inf_communication_group_get_target(priv-&gt;group);
267   if(target != NULL)
268     inf_communication_object_enqueued(target, connection, xml);
269 }
270 static void
271 inf_communication_central_method_sent(InfCommunicationMethod* method,
272                                       InfXmlConnection* connection,
273                                       xmlNodePtr xml)
274 {
275   InfCommunicationCentralMethodPrivate* priv;
276   InfCommunicationObject* target;
277   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
278   target = inf_communication_group_get_target(priv-&gt;group);
279   if(target != NULL)
280     inf_communication_object_sent(target, connection, xml);
281 }
282 static void
283 inf_communication_central_method_registry_unrefed(gpointer data,
284                                                   GObject* object)
285 {
286   InfCommunicationCentralMethod* method;
287   InfCommunicationCentralMethodPrivate* priv;
288   method = INF_COMMUNICATION_CENTRAL_METHOD(data);
289   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
290   g_warning("A method's registry was unrefed before the method was unrefed");
291   priv-&gt;registry = NULL;
292 }
293 static void
294 inf_communication_central_method_group_unrefed(gpointer data,
295                                                GObject* where_the_object_was)
296 {
297   InfCommunicationCentralMethod* method;
298   InfCommunicationCentralMethodPrivate* priv;
299   method = INF_COMMUNICATION_CENTRAL_METHOD(data);
300   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
301   g_warning("A method's group was unrefed before the method was unrefed");
302   priv-&gt;group = NULL;
303 }
304 static void
305 inf_communication_central_method_set_registry(InfCommunicationCentralMethod* m,
306                                               InfCommunicationRegistry* reg)
307 {
308   InfCommunicationCentralMethodPrivate* priv;
309   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(m);
310   if(priv-&gt;registry != NULL)
311   {
312     g_object_weak_unref(
313       G_OBJECT(priv-&gt;registry),
314       inf_communication_central_method_registry_unrefed,
315       m
316     );
317   }
318   priv-&gt;registry = reg;
319   if(reg != NULL)
320   {
321     g_object_weak_ref(
322       G_OBJECT(reg),
323       inf_communication_central_method_registry_unrefed,
324       m
325     );
326   }
327   g_object_notify(G_OBJECT(m), "registry");
328 }
329 static void
330 inf_communication_central_method_set_group(InfCommunicationCentralMethod* m,
331                                            InfCommunicationGroup* group)
332 {
333   InfCommunicationCentralMethodPrivate* priv;
334   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(m);
335   if(priv-&gt;group != NULL)
336   {
337     g_object_weak_unref(
338       G_OBJECT(priv-&gt;group),
339       inf_communication_central_method_group_unrefed,
340       m
341     );
342     priv-&gt;is_publisher = FALSE;
343   }
344   priv-&gt;group = group;
345   if(group != NULL)
346   {
347     g_object_weak_ref(
348       G_OBJECT(group),
349       inf_communication_central_method_group_unrefed,
350       m
351     );
352     if(INF_COMMUNICATION_IS_HOSTED_GROUP(group))
353       priv-&gt;is_publisher = TRUE;
354     else
355       priv-&gt;is_publisher = FALSE;
356   }
357   g_object_notify(G_OBJECT(m), "group");
358 }
359 static void
360 inf_communication_central_method_init(InfCommunicationCentralMethod* method)
361 {
362   InfCommunicationCentralMethodPrivate* priv;
363   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
364   priv-&gt;group = NULL;
365   priv-&gt;registry = NULL;
366   priv-&gt;is_publisher = FALSE;
367   priv-&gt;connections = NULL;
368 }
369 static void
370 inf_communication_central_method_dispose(GObject* object)
371 {
372   InfCommunicationCentralMethod* method;
373   InfCommunicationCentralMethodPrivate* priv;
374   method = INF_COMMUNICATION_CENTRAL_METHOD(object);
375   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
376   while(priv-&gt;connections != NULL)
377   {
378     inf_communication_method_remove_member(
379       INF_COMMUNICATION_METHOD(method),
380       INF_XML_CONNECTION(priv-&gt;connections-&gt;data)
381     );
382   }
383   inf_communication_central_method_set_group(method, NULL);
384   inf_communication_central_method_set_registry(method, NULL);
385   G_OBJECT_CLASS(inf_communication_central_method_parent_class)-&gt;dispose(object);
386 }
387 static void
388 inf_communication_central_method_set_property(GObject* object,
389                                               guint prop_id,
390                                               const GValue* value,
391                                               GParamSpec* pspec)
392 {
393   InfCommunicationCentralMethod* method;
394   InfCommunicationCentralMethodPrivate* priv;
395   method = INF_COMMUNICATION_CENTRAL_METHOD(object);
396   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
397   switch(prop_id)
398   {
399   case PROP_REGISTRY:
400     g_assert(priv-&gt;registry == NULL); 
401     inf_communication_central_method_set_registry(
402       method,
403       INF_COMMUNICATION_REGISTRY(g_value_get_object(value))
404     );
405     break;
406   case PROP_GROUP:
407     g_assert(priv-&gt;group == NULL); 
408     inf_communication_central_method_set_group(
409       method,
410       INF_COMMUNICATION_GROUP(g_value_get_object(value))
411 <a name="0"></a>    );
412     break;
413 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
414     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
415     break;
416   }
417 }
418 static void
419 inf_communication_central_method_get_property(GObject* object,
420                                               guint prop_id,
421                                               GValue* value,
422                                               GParamSpec* pspec)
423 {
424   InfCommunicationCentralMethod* method;
425   InfCommunicationCentralMethodPrivate* priv;
426   method = INF_COMMUNICATION_CENTRAL_METHOD(object);
427   priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
428   switch(prop_id)
429   {
430   case PROP_REGISTRY:
431     g_value_set_object(value, priv-&gt;registry);
432     break;
433   case PROP_GROUP:
434     g_value_set_object(value, priv-&gt;group);
435     break;</b></font>
436   default:
437     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
438     break;
439   }
440 }
441 static void
442 inf_communication_central_method_class_init(
443   InfCommunicationCentralMethodClass* method_class)
444 {
445   GObjectClass* object_class;
446   object_class = G_OBJECT_CLASS(method_class);
447 <a name="1"></a>
448   object_class-&gt;dispose = inf_communication_central_method_dispose;
449   object_class-&gt;set_property = inf_communication_central_method_set_property;
450 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  object_class-&gt;get_property = inf_communication_central_method_get_property;
451   g_object_class_install_property(
452     object_class,
453     PROP_REGISTRY,
454     g_param_spec_object(
455       "registry",
456       "Registry",
457       "The communication registry to register connections with",
458       INF_COMMUNICATION_TYPE_REGISTRY,
459       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
460     )
461   );
462   g_object_class_install_property(
463     object_class,
464     PROP_GROUP,
465     g_param_spec_object(
466       "group",
467       "Group",
468       "The communication group for which to handle messages",
469       INF_COMMUNICATION_TYPE_GROUP,
470       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
471     )
472   );
473 }
474 static void
475 inf_communication_central_method_method_iface_init(
476   InfCommunicationMethodInterface* iface)
477 {
478   iface-&gt;add_member = inf_communication_central_method_add_member;
479   iface-&gt;remove_member = inf_communication_central_method_remove_member;
480   iface-&gt;is_member = inf_communication_central_method_is_member;
481   iface-&gt;send_single = inf_communication_central_method_send_single;
482   iface-&gt;send_all = inf_communication_central_method_send_all;
483   iface-&gt;cancel_messages = inf_communication_central_method_cancel_messages;
484   iface-&gt;received = inf_communication_central_method_received;
485   iface-&gt;enqueued = inf_communication_central_method_enqueued;
486   iface-&gt;sent = inf_communication_central_method_sent;</b></font>
487 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-algorithm.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/adopted/inf-adopted-algorithm.h&gt;
2 #include &lt;libinfinity/inf-signals.h&gt;
3 #include &lt;libinfinity/inf-i18n.h&gt;
4 typedef struct _InfAdoptedAlgorithmLocalUser InfAdoptedAlgorithmLocalUser;
5 struct _InfAdoptedAlgorithmLocalUser {
6   InfAdoptedUser* user;
7   gboolean can_undo;
8   gboolean can_redo;
9 };
10 typedef struct _InfAdoptedAlgorithmPrivate InfAdoptedAlgorithmPrivate;
11 struct _InfAdoptedAlgorithmPrivate {
12   guint max_total_log_size;
13   InfAdoptedStateVector* current;
14   InfAdoptedStateVector* buffer_modified_time;
15   InfAdoptedRequest* execute_request;
16   InfUserTable* user_table;
17   InfBuffer* buffer;
18   InfAdoptedUser** users_begin;
19   InfAdoptedUser** users_end;
20   GSList* local_users;
21 };
22 enum {
23   PROP_0,
24   PROP_USER_TABLE,
25   PROP_BUFFER,
26   PROP_MAX_TOTAL_LOG_SIZE,
27   PROP_CURRENT_STATE,
28   PROP_BUFFER_MODIFIED_STATE
29 };
30 enum {
31   CAN_UNDO_CHANGED,
32   CAN_REDO_CHANGED,
33   BEGIN_EXECUTE_REQUEST,
34   END_EXECUTE_REQUEST,
35   LAST_SIGNAL
36 };
37 #define INF_ADOPTED_ALGORITHM_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_ALGORITHM, InfAdoptedAlgorithmPrivate))
38 #define INF_ADOPTED_ALGORITHM_PRIVATE(obj)     ((InfAdoptedAlgorithmPrivate*)(obj)-&gt;priv)
39 static guint algorithm_signals[LAST_SIGNAL];
40 G_DEFINE_TYPE_WITH_CODE(InfAdoptedAlgorithm, inf_adopted_algorithm, G_TYPE_OBJECT,
41   G_ADD_PRIVATE(InfAdoptedAlgorithm))
42 static InfAdoptedStateVector*
43 inf_adopted_algorithm_least_common_successor(InfAdoptedAlgorithm* algorithm,
44                                              InfAdoptedStateVector* first,
45                                              InfAdoptedStateVector* second)
46 {
47   InfAdoptedAlgorithmPrivate* priv;
48   InfAdoptedUser** user;
49   InfAdoptedStateVector* result;
50   guint id;
51   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
52   result = inf_adopted_state_vector_new();
53   for(user = priv-&gt;users_begin; user != priv-&gt;users_end; ++ user)
54   {
55     id = inf_user_get_id(INF_USER(*user));
56     inf_adopted_state_vector_set(
57       result,
58       id,
59       MAX(
60         inf_adopted_state_vector_get(first, id),
61         inf_adopted_state_vector_get(second, id)
62       )
63     );
64   }
65   g_assert(inf_adopted_state_vector_causally_before(first, result));
66   g_assert(inf_adopted_state_vector_causally_before(second, result));
67   return result;
68 }
69 static InfAdoptedStateVector*
70 inf_adopted_algorithm_least_common_predecessor(InfAdoptedAlgorithm* algorithm,
71                                                InfAdoptedStateVector* first,
72                                                InfAdoptedStateVector* second)
73 {
74   InfAdoptedAlgorithmPrivate* priv;
75   InfAdoptedUser** user;
76   InfAdoptedStateVector* result;
77   guint id;
78   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
79   result = inf_adopted_state_vector_new();
80   for(user = priv-&gt;users_begin; user != priv-&gt;users_end; ++ user)
81   {
82     id = inf_user_get_id(INF_USER(*user));
83     inf_adopted_state_vector_set(
84       result,
85       id,
86       MIN(
87         inf_adopted_state_vector_get(first, id),
88         inf_adopted_state_vector_get(second, id)
89       )
90     );
91   }
92   return result;
93 }
94 static gboolean
95 inf_adopted_algorithm_can_undo_redo(InfAdoptedAlgorithm* algorithm,
96                                     InfAdoptedUser* user,
97                                     InfAdoptedRequest* request)
98 {
99   InfAdoptedAlgorithmPrivate* priv;
100   InfAdoptedRequestLog* log;
101   guint diff;
102   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
103   if(request != NULL)
104   {
105     if(priv-&gt;max_total_log_size != G_MAXUINT)
106     {
107       log = inf_adopted_user_get_request_log(user);
108       request = inf_adopted_request_log_original_request(log, request);
109       diff = inf_adopted_state_vector_vdiff(
110         inf_adopted_request_get_vector(request),
111         inf_adopted_user_get_vector(user)
112       );
113       if(diff &gt;= priv-&gt;max_total_log_size)
114         return FALSE;
115       else
116         return TRUE;
117     }
118     else
119     {
120       return TRUE;
121     }
122   }
123   else
124   {
125     return FALSE;
126   }
127 }
128 static void
129 inf_adopted_algorithm_update_undo_redo(InfAdoptedAlgorithm* algorithm)
130 {
131   InfAdoptedAlgorithmPrivate* priv;
132   InfAdoptedAlgorithmLocalUser* local;
133   InfAdoptedRequestLog* log;
134   GSList* item;
135   gboolean can_undo;
136   gboolean can_redo;
137   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
138   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
139   {
140     local = item-&gt;data;
141     log = inf_adopted_user_get_request_log(local-&gt;user);
142     can_undo = inf_adopted_algorithm_can_undo_redo(
143       algorithm,
144       local-&gt;user,
145       inf_adopted_request_log_next_undo(log)
146     );
147     can_redo = inf_adopted_algorithm_can_undo_redo(
148       algorithm,
149       local-&gt;user,
150       inf_adopted_request_log_next_redo(log)
151     );
152     if(local-&gt;can_undo != can_undo)
153     {
154       g_signal_emit(
155         G_OBJECT(algorithm),
156         algorithm_signals[CAN_UNDO_CHANGED],
157         0,
158         local-&gt;user,
159         can_undo
160       );
161     }
162     if(local-&gt;can_redo != can_redo)
163     {
164       g_signal_emit(
165         G_OBJECT(algorithm),
166         algorithm_signals[CAN_REDO_CHANGED],
167         0,
168         local-&gt;user,
169         can_redo
170       );
171     }
172   }
173 }
174 static InfAdoptedAlgorithmLocalUser*
175 inf_adopted_algorithm_find_local_user(InfAdoptedAlgorithm* algorithm,
176                                       InfAdoptedUser* user)
177 {
178   InfAdoptedAlgorithmPrivate* priv;
179   GSList* item;
180   InfAdoptedAlgorithmLocalUser* local;
181   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
182   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
183   {
184     local = (InfAdoptedAlgorithmLocalUser*)item-&gt;data;
185     if(local-&gt;user == user)
186       return local;
187   }
188   return NULL;
189 }
190 static void
191 inf_adopted_algorithm_local_user_free(InfAdoptedAlgorithm* algorithm,
192                                       InfAdoptedAlgorithmLocalUser* local)
193 {
194   InfAdoptedAlgorithmPrivate* priv;
195   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
196   priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
197   g_slice_free(InfAdoptedAlgorithmLocalUser, local);
198 }
199 static void
200 inf_adopted_algorithm_add_user(InfAdoptedAlgorithm* algorithm,
201                                InfAdoptedUser* user)
202 {
203   InfAdoptedAlgorithmPrivate* priv;
204   InfAdoptedRequestLog* log;
205   InfAdoptedStateVector* time;
206   guint user_count;
207   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
208   log = inf_adopted_user_get_request_log(user);
209   time = inf_adopted_user_get_vector(user);
210   inf_adopted_state_vector_set(
211     priv-&gt;current,
212     inf_user_get_id(INF_USER(user)),
213     inf_adopted_state_vector_get(time, inf_user_get_id(INF_USER(user)))
214   );
215   user_count = (priv-&gt;users_end - priv-&gt;users_begin) + 1;
216   priv-&gt;users_begin =
217     g_realloc(priv-&gt;users_begin, sizeof(InfAdoptedUser*) * user_count);
218   priv-&gt;users_end = priv-&gt;users_begin + user_count;
219   priv-&gt;users_begin[user_count - 1] = user;
220 }
221 static void
222 inf_adopted_algorithm_add_local_user(InfAdoptedAlgorithm* algorithm,
223                                      InfAdoptedUser* user)
224 {
225   InfAdoptedAlgorithmPrivate* priv;
226   InfAdoptedAlgorithmLocalUser* local;
227   InfAdoptedRequestLog* log;
228   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
229   local = g_slice_new(InfAdoptedAlgorithmLocalUser);
230   local-&gt;user = user;
231   log = inf_adopted_user_get_request_log(user);
232   local-&gt;can_undo = inf_adopted_algorithm_can_undo_redo(
233     algorithm,
234     user,
235     inf_adopted_request_log_next_undo(log)
236   );
237   local-&gt;can_redo = inf_adopted_algorithm_can_undo_redo(
238     algorithm,
239     user,
240     inf_adopted_request_log_next_redo(log)
241   );
242   priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
243 }
244 static void
245 inf_adopted_algorithm_add_user_cb(InfUserTable* user_table,
246                                   InfUser* user,
247                                   gpointer user_data)
248 {
249   InfAdoptedAlgorithm* algorithm;
250   algorithm = INF_ADOPTED_ALGORITHM(user_data);
251   g_assert(INF_ADOPTED_IS_USER(user));
252   inf_adopted_algorithm_add_user(algorithm, INF_ADOPTED_USER(user));
253 }
254 static void
255 inf_adopted_algorithm_add_local_user_cb(InfUserTable* user_table,
256                                         InfUser* user,
257                                         gpointer user_data)
258 {
259   InfAdoptedAlgorithm* algorithm;
260   algorithm = INF_ADOPTED_ALGORITHM(user_data);
261   g_assert(INF_ADOPTED_IS_USER(user));
262   inf_adopted_algorithm_add_local_user(algorithm, INF_ADOPTED_USER(user));
263 }
264 static void
265 inf_adopted_algorithm_remove_local_user_cb(InfUserTable* user_table,
266                                            InfUser* user,
267                                            gpointer user_data)
268 {
269   InfAdoptedAlgorithm* algorithm;
270   InfAdoptedAlgorithmPrivate* priv;
271   InfAdoptedAlgorithmLocalUser* local;
272   algorithm = INF_ADOPTED_ALGORITHM(user_data);
273   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
274   local =
275     inf_adopted_algorithm_find_local_user(algorithm, INF_ADOPTED_USER(user));
276   g_assert(local != NULL);
277   inf_adopted_algorithm_local_user_free(algorithm, local);
278 }
279 static gboolean
280 inf_adopted_algorithm_buffer_states_equivalent(InfAdoptedAlgorithm* algorithm,
281                                                InfAdoptedStateVector* first,
282                                                InfAdoptedStateVector* second)
283 {
284   InfAdoptedAlgorithmPrivate* priv;
285   InfAdoptedUser** user_it;
286   InfAdoptedUser* user;
287   InfAdoptedRequest* request;
288   InfAdoptedRequestLog* log;
289   guint user_id;
290   guint first_n;
291   guint second_n;
292   g_assert(inf_adopted_state_vector_causally_before(first, second));
293   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
294   for(user_it = priv-&gt;users_begin; user_it != priv-&gt;users_end; ++ user_it)
295   {
296     user = *user_it;
297     user_id = inf_user_get_id(INF_USER(user));
298     log = inf_adopted_user_get_request_log(user);
299     first_n = inf_adopted_state_vector_get(first, user_id);
300     second_n = inf_adopted_state_vector_get(second, user_id);
301     while(second_n &gt; first_n)
302     {
303       if(second_n &lt;= inf_adopted_request_log_get_begin(log))
304         return FALSE;
305       request = inf_adopted_request_log_get_request(log, second_n - 1);
306       if(inf_adopted_request_get_request_type(request) ==
307          INF_ADOPTED_REQUEST_DO)
308       {
309         return FALSE;
310       }
311       else
312       {
313         request = inf_adopted_request_log_prev_associated(log, request);
314         second_n = inf_adopted_state_vector_get(
315           inf_adopted_request_get_vector(request),
316           user_id
317         );
318       }
319     }
320     if(second_n &lt; first_n)
321       return FALSE;
322   }
323   return TRUE;
324 }
325 static void
326 inf_adopted_algorithm_buffer_notify_modified_cb(GObject* object,
327                                                 GParamSpec* pspec,
328                                                 gpointer user_data)
329 {
330   InfAdoptedAlgorithm* algorithm;
331   InfAdoptedAlgorithmPrivate* priv;
332   gboolean equivalent;
333   algorithm = INF_ADOPTED_ALGORITHM(user_data);
334   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
335   if(inf_buffer_get_modified(INF_BUFFER(object)))
336   {
337     if(priv-&gt;buffer_modified_time != NULL)
338     {
339       equivalent = inf_adopted_algorithm_buffer_states_equivalent(
340         algorithm,
341         priv-&gt;buffer_modified_time,
342         priv-&gt;current
343       );
344       if(equivalent == TRUE)
345       {
346         inf_adopted_state_vector_free(priv-&gt;buffer_modified_time);
347         priv-&gt;buffer_modified_time = NULL;
348       }
349     }
350   }
351   else
352   {
353     if(priv-&gt;buffer_modified_time != NULL)
354       inf_adopted_state_vector_free(priv-&gt;buffer_modified_time);
355     priv-&gt;buffer_modified_time = inf_adopted_state_vector_copy(priv-&gt;current);
356   }
357 }
358 static void
359 inf_adopted_algorithm_update_local_user_times(InfAdoptedAlgorithm* algorithm)
360 {
361   InfAdoptedAlgorithmPrivate* priv;
362   InfAdoptedAlgorithmLocalUser* local;
363   GSList* item;
364   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
365   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
366   {
367     local = item-&gt;data;
368     inf_adopted_user_set_vector(
369       local-&gt;user,
370       inf_adopted_state_vector_copy(priv-&gt;current)
371     );
372   }
373 }
374 static gboolean
375 inf_adopted_algorithm_can_cache(InfAdoptedRequest* request)
376 {
377   InfAdoptedOperation* operation;
378   InfAdoptedOperationFlags flags;
379 #define INF_ADOPTED_OPERATION_CACHABLE \
380   (INF_ADOPTED_OPERATION_AFFECTS_BUFFER | INF_ADOPTED_OPERATION_REVERSIBLE)
381   if(inf_adopted_request_get_request_type(request) != INF_ADOPTED_REQUEST_DO)
382     return TRUE;
383   operation = inf_adopted_request_get_operation(request);
384   flags = inf_adopted_operation_get_flags(operation) &amp;
385     INF_ADOPTED_OPERATION_CACHABLE;
386   return flags == INF_ADOPTED_OPERATION_CACHABLE;
387 }
388 static InfAdoptedRequest*
389 inf_adopted_algorithm_transform_request(InfAdoptedAlgorithm* algorithm,
390                                         InfAdoptedRequest* request,
391                                         InfAdoptedRequest* against,
392                                         InfAdoptedStateVector* at)
393 {
394   InfAdoptedRequest* request_at;
395   InfAdoptedRequest* against_at;
396   InfAdoptedConcurrencyId concurrency_id;
397   InfAdoptedStateVector* lcs;
398   InfAdoptedRequest* lcs_against;
399   InfAdoptedRequest* lcs_request;
400   InfAdoptedRequest* result;
401   g_assert(
402     inf_adopted_state_vector_causally_before(
403       inf_adopted_request_get_vector(request),
404       at
405     )
406   );
407   g_assert(
408     inf_adopted_state_vector_causally_before(
409       inf_adopted_request_get_vector(against),
410       at
411     )
412   );
413   against_at = inf_adopted_algorithm_translate_request(
414     algorithm,
415     against,
416     at
417   );
418   request_at = inf_adopted_algorithm_translate_request(
419     algorithm,
420     request,
421     at
422   );
423   concurrency_id = INF_ADOPTED_CONCURRENCY_NONE;
424   if(inf_adopted_request_need_concurrency_id(request_at, against_at) == TRUE)
425   {
426     lcs = inf_adopted_algorithm_least_common_successor(
427       algorithm,
428       inf_adopted_request_get_vector(request),
429       inf_adopted_request_get_vector(against)
430     );
431     g_assert(inf_adopted_state_vector_causally_before(lcs, at));
432     if(inf_adopted_state_vector_compare(lcs, at) != 0)
433     {
434       lcs_against = inf_adopted_algorithm_translate_request(
435         algorithm,
436         against,
437         lcs
438       );
439       lcs_request = inf_adopted_algorithm_translate_request(
440         algorithm,
441         request,
442         lcs
443       );
444     }
445     else
446     {
447       lcs_against = against_at;
448       lcs_request = request_at;
449       g_object_ref(lcs_against);
450       g_object_ref(lcs_request);
451     }
452     inf_adopted_state_vector_free(lcs);
453   }
454   else
455   {
456     lcs_against = NULL;
457     lcs_request = NULL;
458   }
459   result = inf_adopted_request_transform(
460     request_at,
461     against_at,
462     lcs_request,
463     lcs_against
464   );
465   if(lcs_request != NULL)
466     g_object_unref(lcs_request);
467   if(lcs_against != NULL)
468     g_object_unref(lcs_against);
469   g_object_unref(request_at);
470   g_object_unref(against_at);
471   return result;
472 }
473 static InfAdoptedRequest*
474 inf_adopted_algorithm_translate_request_forward(InfAdoptedAlgorithm* algorithm,
475                                                 InfAdoptedRequest* request,
476                                                 InfAdoptedStateVector* to)
477 {
478   InfAdoptedAlgorithmPrivate* priv;
479   InfAdoptedUser** user_it;
480   InfAdoptedUser* user;
481   InfAdoptedRequestLog* log;
482   guint user_id;
483   InfAdoptedRequest* cur_req;
484   InfAdoptedRequest* next_req;
485   InfAdoptedStateVector* vector;
486   InfAdoptedRequest* index;
487   InfAdoptedRequest* associated;
488   InfAdoptedRequest* translated;
489   InfAdoptedStateVector* associated_vector;
490   guint from_n;
491   guint to_n;
492   guint associated_index;
493   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
494   cur_req = request;
495   vector = inf_adopted_request_get_vector(cur_req);
496   g_object_ref(cur_req);
497   while(inf_adopted_state_vector_compare(vector, to) != 0)
498   {
499     next_req = NULL;
500     g_assert(inf_adopted_state_vector_causally_before(vector, to) == TRUE);
501     for(user_it = priv-&gt;users_begin; user_it != priv-&gt;users_end; ++user_it)
502     {
503       user = *user_it;
504       user_id = inf_user_get_id(INF_USER(user));
505       if(user_id == inf_adopted_request_get_user_id(cur_req)) continue;
506       from_n = inf_adopted_state_vector_get(vector, user_id);
507       to_n = inf_adopted_state_vector_get(to, user_id);
508       g_assert(from_n &lt;= to_n);
509       if(from_n == to_n) continue;
510       log = inf_adopted_user_get_request_log(user);
511       g_assert(from_n &gt;= inf_adopted_request_log_get_begin(log));
512       g_assert(to_n &lt;= inf_adopted_request_log_get_end(log));
513       index = inf_adopted_request_log_get_request(log, from_n);
514       associated = inf_adopted_request_log_next_associated(log, index);
515       if(associated != NULL &amp;&amp;
516          inf_adopted_request_get_index(associated) &lt; to_n)
517       {
518         next_req = inf_adopted_request_fold(
519           cur_req,
520           user_id,
521           inf_adopted_request_get_index(associated) - from_n + 1
522         );
523         break;
524       }
525       else
526       {
527         associated = inf_adopted_request_log_original_request(log, index);
528         associated_vector = inf_adopted_request_get_vector(associated);
529         if(inf_adopted_state_vector_causally_before(associated_vector, vector))
530         {
531           translated = inf_adopted_algorithm_translate_request(
532             algorithm,
533             associated,
534             vector
535           );
536           next_req = inf_adopted_algorithm_transform_request(
537             algorithm,
538             cur_req,
539             translated,
540             vector
541           );
542           g_object_unref(translated);
543           break;
544         }
545       }
546     }
547     if(next_req == NULL)
548     {
549       user_id = inf_adopted_request_get_user_id(cur_req);
550       user = INF_ADOPTED_USER(
551         inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id)
552       );
553       log = inf_adopted_user_get_request_log(user);
554       from_n = inf_adopted_request_get_index(cur_req);
555       to_n = inf_adopted_state_vector_get(to, user_id);
556       index = inf_adopted_request_log_get_request(log, from_n);
557       associated = inf_adopted_request_log_next_associated(log, index);
558       if(associated == NULL)
559       {
560         if(inf_adopted_request_get_request_type(index) == INF_ADOPTED_REQUEST_UNDO)
561         {
562           if(inf_adopted_request_log_next_redo(log) == index)
563             associated_index = to_n;
564           else
565             associated_index = G_MAXUINT;
566         }
567         else
568         {
569           if(inf_adopted_request_log_next_undo(log) == index)
570             associated_index = to_n;
571           else
572             associated_index = G_MAXUINT;
573         }
574       }
575       else
576       {
577         associated_index = inf_adopted_request_get_index(associated);
578       }
579       if(associated_index != G_MAXUINT &amp;&amp; associated_index &lt;= to_n)
580       {
581         next_req = inf_adopted_request_mirror(
582           cur_req,
583           associated_index - from_n
584         );
585       }
586     }
587     g_assert(next_req != NULL);
588     g_object_unref(cur_req);
589     cur_req = next_req;
590     vector = inf_adopted_request_get_vector(cur_req);
591   }
592   return cur_req;
593 }
594 static void
595 inf_adopted_algorithm_log_request(InfAdoptedAlgorithm* algorithm,
596                                   InfAdoptedUser* user,
597                                   InfAdoptedRequest* request)
598 {
599   InfAdoptedAlgorithmPrivate* priv;
600   InfAdoptedRequestLog* log;
601   guint user_id;
602   gboolean equivalent;
603   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
604   log = inf_adopted_user_get_request_log(user);
605   user_id = inf_user_get_id(INF_USER(user));
606   g_assert(inf_adopted_request_get_user_id(request) == user_id);
607   if(inf_adopted_request_affects_buffer(request))
608   {
609     inf_adopted_request_log_add_request(log, request);
610     inf_adopted_state_vector_add(priv-&gt;current, user_id, 1);
611     inf_adopted_algorithm_update_local_user_times(algorithm);
612     if(priv-&gt;buffer_modified_time != NULL)
613     {
614       equivalent = inf_adopted_algorithm_buffer_states_equivalent(
615         algorithm,
616         priv-&gt;buffer_modified_time,
617         priv-&gt;current
618       );
619       if(equivalent == TRUE)
620       {
621         inf_buffer_set_modified(priv-&gt;buffer, FALSE);
622         inf_adopted_state_vector_free(priv-&gt;buffer_modified_time);
623         priv-&gt;buffer_modified_time =
624           inf_adopted_state_vector_copy(priv-&gt;current);
625       }
626       else
627       {
628       }
629     }
630     else
631     {
632       g_assert(inf_buffer_get_modified(priv-&gt;buffer) == TRUE);
633     }
634   }
635 }
636 static InfAdoptedRequest*
637 inf_adopted_algorithm_apply_request(InfAdoptedAlgorithm* algorithm,
638                                     InfAdoptedUser* user,
639                                     InfAdoptedRequest* request,
640                                     InfAdoptedRequest* translated,
641                                     GError** error)
642 {
643   InfAdoptedAlgorithmPrivate* priv;
644   InfAdoptedOperation* reversible_operation;
645   InfAdoptedRequest* log_request;
646   GError* local_error;
647   gchar* request_str;
648   gchar* translated_str;
649   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
650   local_error = NULL;
651   log_request = NULL;
652   if(inf_adopted_request_get_request_type(request) == INF_ADOPTED_REQUEST_DO)
653   {
654     reversible_operation = inf_adopted_operation_apply_transformed(
655       inf_adopted_request_get_operation(request),
656       inf_adopted_request_get_operation(translated),
657       user,
658       priv-&gt;buffer,
659       &amp;local_error
660     );
661     if(local_error == NULL)
662     {
663       g_assert(reversible_operation != NULL);
664       if(reversible_operation == inf_adopted_request_get_operation(request))
665       {
666         log_request = request;
667         g_object_ref(log_request);
668         g_object_unref(reversible_operation);
669       }
670       else
671       {
672         log_request = inf_adopted_request_new_do(
673           inf_adopted_request_get_vector(request),
674           inf_adopted_request_get_user_id(request),
675           reversible_operation,
676           inf_adopted_request_get_receive_time(request)
677         );
678         inf_adopted_request_set_execute_time(
679           log_request,
680           inf_adopted_request_get_execute_time(request)
681         );
682         g_object_unref(reversible_operation);
683       }
684     }
685   }
686   else
687   {
688     inf_adopted_operation_apply(
689       inf_adopted_request_get_operation(translated),
690       user,
691       priv-&gt;buffer,
692       &amp;local_error
693     );
694     if(local_error == NULL)
695     {
696       log_request = request;
697       g_object_ref(log_request);
698     }
699   }
700   if(local_error != NULL)
701   {
702     g_assert(log_request == NULL);
703     request_str = inf_adopted_state_vector_to_string(
704       inf_adopted_request_get_vector(request)
705     );
706     translated_str = inf_adopted_state_vector_to_string(
707       inf_adopted_request_get_vector(translated)
708     );
709     g_propagate_prefixed_error(
710       error,
711       local_error,
712       _("Failed to apply request \"%s\" from user \"%s\" at state \"%s\": "),
713       request_str,
714       inf_user_get_name(INF_USER(user)),
715       translated_str
716     );
717     g_free(request_str);
718     g_free(translated_str);
719     return NULL;
720   }
721   g_assert(log_request != NULL);
722   return log_request;
723 }
724 static void
725 inf_adopted_algorithm_init(InfAdoptedAlgorithm* algorithm)
726 {
727   InfAdoptedAlgorithmPrivate* priv;
728   algorithm-&gt;priv = INF_ADOPTED_ALGORITHM_GET_PRIVATE(algorithm);
729   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
730   priv-&gt;max_total_log_size = 2048;
731   priv-&gt;execute_request = NULL;
732   priv-&gt;current = inf_adopted_state_vector_new();
733   priv-&gt;buffer_modified_time = NULL;
734   priv-&gt;user_table = NULL;
735   priv-&gt;buffer = NULL;
736   priv-&gt;users_begin = NULL;
737   priv-&gt;users_end = NULL;
738   priv-&gt;local_users = NULL;
739 }
740 static void
741 inf_adopted_algorithm_constructed_foreach_user_func(InfUser* user,
742                                                     gpointer user_data)
743 {
744   InfAdoptedAlgorithm* algorithm;
745   algorithm = INF_ADOPTED_ALGORITHM(user_data);
746   g_assert(INF_ADOPTED_IS_USER(user));
747   inf_adopted_algorithm_add_user(algorithm, INF_ADOPTED_USER(user));
748 }
749 static void
750 inf_adopted_algorithm_constructed_foreach_local_user_func(InfUser* user,
751                                                           gpointer user_data)
752 {
753   InfAdoptedAlgorithm* algorithm;
754   algorithm = INF_ADOPTED_ALGORITHM(user_data);
755   g_assert(INF_ADOPTED_IS_USER(user));
756   inf_adopted_algorithm_add_local_user(algorithm, INF_ADOPTED_USER(user));
757 }
758 static void
759 inf_adopted_algorithm_constructed(GObject* object)
760 {
761   InfAdoptedAlgorithm* algorithm;
762   InfAdoptedAlgorithmPrivate* priv;
763   gboolean modified;
764   G_OBJECT_CLASS(inf_adopted_algorithm_parent_class)-&gt;constructed(object);
765   algorithm = INF_ADOPTED_ALGORITHM(object);
766   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
767   inf_user_table_foreach_user(
768     priv-&gt;user_table,
769     inf_adopted_algorithm_constructed_foreach_user_func,
770     algorithm
771   );
772   inf_user_table_foreach_local_user(
773     priv-&gt;user_table,
774     inf_adopted_algorithm_constructed_foreach_local_user_func,
775     algorithm
776   );
777   g_object_get(G_OBJECT(priv-&gt;buffer), "modified", &amp;modified, NULL);
778   if(modified == FALSE)
779     priv-&gt;buffer_modified_time = inf_adopted_state_vector_copy(priv-&gt;current);
780 }
781 static void
782 inf_adopted_algorithm_dispose(GObject* object)
783 {
784   InfAdoptedAlgorithm* algorithm;
785   InfAdoptedAlgorithmPrivate* priv;
786   GList* item;
787   algorithm = INF_ADOPTED_ALGORITHM(object);
788   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
789   while(priv-&gt;local_users != NULL)
790     inf_adopted_algorithm_local_user_free(algorithm, priv-&gt;local_users-&gt;data);
791   g_free(priv-&gt;users_begin);
792   if(priv-&gt;buffer != NULL)
793   {
794     inf_signal_handlers_disconnect_by_func(
795       G_OBJECT(priv-&gt;buffer),
796       G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
797       algorithm
798     );
799     g_object_unref(priv-&gt;buffer);
800     priv-&gt;buffer = NULL;
801   }
802   if(priv-&gt;buffer_modified_time != NULL)
803     inf_adopted_state_vector_free(priv-&gt;buffer_modified_time);
804   if(priv-&gt;user_table != NULL)
805   {
806     inf_signal_handlers_disconnect_by_func(
807       G_OBJECT(priv-&gt;user_table),
808       G_CALLBACK(inf_adopted_algorithm_add_user_cb),
809       algorithm
810     );
811     inf_signal_handlers_disconnect_by_func(
812       G_OBJECT(priv-&gt;user_table),
813       G_CALLBACK(inf_adopted_algorithm_add_local_user_cb),
814       algorithm
815     );
816     inf_signal_handlers_disconnect_by_func(
817       G_OBJECT(priv-&gt;user_table),
818       G_CALLBACK(inf_adopted_algorithm_remove_local_user_cb),
819       algorithm
820     );
821     g_object_unref(priv-&gt;user_table);
822     priv-&gt;user_table = NULL;
823   }
824   G_OBJECT_CLASS(inf_adopted_algorithm_parent_class)-&gt;dispose(object);
825 }
826 static void
827 inf_adopted_algorithm_finalize(GObject* object)
828 {
829   InfAdoptedAlgorithm* algorithm;
830   InfAdoptedAlgorithmPrivate* priv;
831   algorithm = INF_ADOPTED_ALGORITHM(object);
832   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
833   inf_adopted_state_vector_free(priv-&gt;current);
834   G_OBJECT_CLASS(inf_adopted_algorithm_parent_class)-&gt;finalize(object);
835 }
836 static void
837 inf_adopted_algorithm_set_property(GObject* object,
838                                    guint prop_id,
839                                    const GValue* value,
840                                    GParamSpec* pspec)
841 {
842   InfAdoptedAlgorithm* algorithm;
843   InfAdoptedAlgorithmPrivate* priv;
844   algorithm = INF_ADOPTED_ALGORITHM(object);
845   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
846   switch(prop_id)
847   {
848   case PROP_USER_TABLE:
849     g_assert(priv-&gt;user_table == NULL);     priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
850     g_signal_connect(
851       G_OBJECT(priv-&gt;user_table),
852       "add-user",
853       G_CALLBACK(inf_adopted_algorithm_add_user_cb),
854       algorithm
855     );
856     g_signal_connect(
857       G_OBJECT(priv-&gt;user_table),
858       "add-local-user",
859       G_CALLBACK(inf_adopted_algorithm_add_local_user_cb),
860       algorithm
861     );
862     g_signal_connect(
863       G_OBJECT(priv-&gt;user_table),
864       "remove-local-user",
865       G_CALLBACK(inf_adopted_algorithm_remove_local_user_cb),
866       algorithm
867     );
868     break;
869   case PROP_BUFFER:
870     g_assert(priv-&gt;buffer == NULL);     g_assert(priv-&gt;buffer_modified_time == NULL);
871     priv-&gt;buffer = INF_BUFFER(g_value_dup_object(value));
872     g_signal_connect(
873       G_OBJECT(priv-&gt;buffer),
874       "notify::modified",
875       G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
876       algorithm
877     );
878     break;
879   case PROP_MAX_TOTAL_LOG_SIZE:
880     priv-&gt;max_total_log_size = g_value_get_uint(value);
881     break;
882 <a name="0"></a>  case PROP_CURRENT_STATE:
883   case PROP_BUFFER_MODIFIED_STATE:
884 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
885     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
886     break;
887   }
888 }
889 static void
890 inf_adopted_algorithm_get_property(GObject* object,
891                                    guint prop_id,
892                                    GValue* value,
893                                    GParamSpec* pspec)
894 {
895   InfAdoptedAlgorithm* log;
896   InfAdoptedAlgorithmPrivate* priv;
897   log = INF_ADOPTED_ALGORITHM(object);
898   priv = INF_ADOPTED_ALGORITHM_PRIVATE(log);
899   switch(prop_id)
900   {
901   case PROP_USER_TABLE:
902     g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
903     break;
904 <a name="2"></a>  case PROP_BUFFER:
905     g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
906     break;</b></font>
907 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  case PROP_MAX_TOTAL_LOG_SIZE:
908     g_value_set_uint(value, priv-&gt;max_total_log_size);
909     break;
910   case PROP_CURRENT_STATE:
911     g_value_set_boxed(value, priv-&gt;current);
912     break;
913   case PROP_BUFFER_MODIFIED_STATE:
914     g_value_set_boxed(value, priv-&gt;buffer_modified_time);
915     break;
916   default:
917     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
918     break;
919   }
920 }
921 static void
922 inf_adopted_algorithm_can_undo_changed(InfAdoptedAlgorithm* algorithm,
923                                        InfAdoptedUser* user,
924                                        gboolean can_undo)
925 {
926   InfAdoptedAlgorithmPrivate* priv;
927   GSList* item;
928   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);</b></font>
929   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
930     if( ((InfAdoptedAlgorithmLocalUser*)item-&gt;data)-&gt;user == user)
931       ((InfAdoptedAlgorithmLocalUser*)item-&gt;data)-&gt;can_undo = can_undo;
932 }
933 static void
934 inf_adopted_algorithm_can_redo_changed(InfAdoptedAlgorithm* algorithm,
935                                        InfAdoptedUser* user,
936                                        gboolean can_redo)
937 {
938   InfAdoptedAlgorithmPrivate* priv;
939   GSList* item;
940 <a name="1"></a>  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
941   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
942     if( ((InfAdoptedAlgorithmLocalUser*)item-&gt;data)-&gt;user == user)
943 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      ((InfAdoptedAlgorithmLocalUser*)item-&gt;data)-&gt;can_redo = can_redo;
944 }
945 static void
946 inf_adopted_algorithm_class_init(InfAdoptedAlgorithmClass* algorithm_class)
947 {
948   GObjectClass* object_class;
949   object_class = G_OBJECT_CLASS(algorithm_class);
950   object_class-&gt;constructed = inf_adopted_algorithm_constructed;
951   object_class-&gt;dispose = inf_adopted_algorithm_dispose;
952   object_class-&gt;finalize = inf_adopted_algorithm_finalize;
953   object_class-&gt;set_property = inf_adopted_algorithm_set_property;
954   object_class-&gt;get_property = inf_adopted_algorithm_get_property;
955   algorithm_class-&gt;can_undo_changed = inf_adopted_algorithm_can_undo_changed;
956   algorithm_class-&gt;can_redo_changed = inf_adopted_algorithm_can_redo_changed;
957   algorithm_class-&gt;begin_execute_request = NULL;</b></font>
958   algorithm_class-&gt;end_execute_request = NULL;
959   g_object_class_install_property(
960     object_class,
961     PROP_USER_TABLE,
962     g_param_spec_object(
963       "user-table",
964       "User table",
965       "The user table",
966       INF_TYPE_USER_TABLE,
967       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
968     )
969   );
970   g_object_class_install_property(
971     object_class,
972     PROP_BUFFER,
973     g_param_spec_object(
974       "buffer",
975       "Buffer",
976       "The buffer to apply operations to",
977       INF_TYPE_BUFFER,
978       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
979     )
980   );
981   g_object_class_install_property(
982     object_class,
983     PROP_MAX_TOTAL_LOG_SIZE,
984     g_param_spec_uint(
985       "max-total-log-size",
986       "Maxmimum total log size",
987       "The maximum number of requests to keep in all user's logs",
988       0,
989       G_MAXUINT,
990       2048,
991       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
992     )
993   );
994   g_object_class_install_property(
995     object_class,
996     PROP_CURRENT_STATE,
997     g_param_spec_boxed(
998       "current-state",
999       "Current state",
1000       "The state vector describing the current document state",
1001       INF_ADOPTED_TYPE_STATE_VECTOR,
1002       G_PARAM_READABLE
1003     )
1004   );
1005   g_object_class_install_property(
1006     object_class,
1007     PROP_BUFFER_MODIFIED_STATE,
1008     g_param_spec_boxed(
1009       "buffer-modified-state",
1010       "Buffer modified state",
1011       "The state in which the buffer is considered not being modified",
1012       INF_ADOPTED_TYPE_STATE_VECTOR,
1013       G_PARAM_READABLE
1014     )
1015   );
1016   algorithm_signals[CAN_UNDO_CHANGED] = g_signal_new(
1017     "can-undo-changed",
1018     G_OBJECT_CLASS_TYPE(object_class),
1019     G_SIGNAL_RUN_LAST,
1020     G_STRUCT_OFFSET(InfAdoptedAlgorithmClass, can_undo_changed),
1021     NULL, NULL,
1022     NULL,
1023     G_TYPE_NONE,
1024     2,
1025     INF_ADOPTED_TYPE_USER,
1026     G_TYPE_BOOLEAN
1027   );
1028   algorithm_signals[CAN_REDO_CHANGED] = g_signal_new(
1029     "can-redo-changed",
1030     G_OBJECT_CLASS_TYPE(object_class),
1031     G_SIGNAL_RUN_LAST,
1032     G_STRUCT_OFFSET(InfAdoptedAlgorithmClass, can_redo_changed),
1033     NULL, NULL,
1034     NULL,
1035     G_TYPE_NONE,
1036     2,
1037     INF_ADOPTED_TYPE_USER,
1038     G_TYPE_BOOLEAN
1039   );
1040   algorithm_signals[BEGIN_EXECUTE_REQUEST] = g_signal_new(
1041     "begin-execute-request",
1042     G_OBJECT_CLASS_TYPE(object_class),
1043     G_SIGNAL_RUN_LAST,
1044     G_STRUCT_OFFSET(InfAdoptedAlgorithmClass, begin_execute_request),
1045     NULL, NULL,
1046     NULL,
1047     G_TYPE_NONE,
1048     2,
1049     INF_ADOPTED_TYPE_USER,
1050     INF_ADOPTED_TYPE_REQUEST
1051   );
1052   algorithm_signals[END_EXECUTE_REQUEST] = g_signal_new(
1053     "end-execute-request",
1054     G_OBJECT_CLASS_TYPE(object_class),
1055     G_SIGNAL_RUN_LAST,
1056     G_STRUCT_OFFSET(InfAdoptedAlgorithmClass, end_execute_request),
1057     NULL, NULL,
1058     NULL,
1059     G_TYPE_NONE,
1060     4,
1061     INF_ADOPTED_TYPE_USER,
1062     INF_ADOPTED_TYPE_REQUEST,
1063     INF_ADOPTED_TYPE_REQUEST,
1064     G_TYPE_ERROR
1065   );
1066 }
1067 InfAdoptedAlgorithm*
1068 inf_adopted_algorithm_new(InfUserTable* user_table,
1069                           InfBuffer* buffer)
1070 {
1071   GObject* object;
1072   g_return_val_if_fail(INF_IS_BUFFER(buffer), NULL);
1073   object = g_object_new(
1074     INF_ADOPTED_TYPE_ALGORITHM,
1075     "user-table", user_table,
1076     "buffer", buffer,
1077     NULL
1078   );
1079   return INF_ADOPTED_ALGORITHM(object);
1080 }
1081 InfAdoptedAlgorithm*
1082 inf_adopted_algorithm_new_full(InfUserTable* user_table,
1083                                InfBuffer* buffer,
1084                                guint max_total_log_size)
1085 {
1086   GObject* object;
1087   g_return_val_if_fail(INF_IS_BUFFER(buffer), NULL);
1088   object = g_object_new(
1089     INF_ADOPTED_TYPE_ALGORITHM,
1090     "user-table", user_table,
1091     "buffer", buffer,
1092     "max-total-log-size", max_total_log_size,
1093     NULL
1094   );
1095   return INF_ADOPTED_ALGORITHM(object);
1096 }
1097 InfAdoptedStateVector*
1098 inf_adopted_algorithm_get_current(InfAdoptedAlgorithm* algorithm)
1099 {
1100   g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), NULL);
1101   return INF_ADOPTED_ALGORITHM_PRIVATE(algorithm)-&gt;current;
1102 }
1103 InfAdoptedRequest*
1104 inf_adopted_algorithm_get_execute_request(InfAdoptedAlgorithm* algorithm)
1105 {
1106   g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), NULL);
1107   return INF_ADOPTED_ALGORITHM_PRIVATE(algorithm)-&gt;execute_request;
1108 }
1109 InfAdoptedRequest*
1110 inf_adopted_algorithm_generate_request(InfAdoptedAlgorithm* algorithm,
1111                                        InfAdoptedRequestType type,
1112                                        InfAdoptedUser* user,
1113                                        InfAdoptedOperation* operation)
1114 {
1115   InfAdoptedAlgorithmPrivate* priv;
1116   g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), NULL);
1117   g_return_val_if_fail(INF_ADOPTED_IS_USER(user), NULL);
1118   g_return_val_if_fail(
1119     type != INF_ADOPTED_REQUEST_DO || INF_ADOPTED_IS_OPERATION(operation),
1120     NULL
1121   );
1122   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
1123   switch(type)
1124   {
1125   case INF_ADOPTED_REQUEST_DO:
1126     return inf_adopted_request_new_do(
1127       priv-&gt;current,
1128       inf_user_get_id(INF_USER(user)),
1129       operation,
1130       g_get_real_time()
1131     );
1132   case INF_ADOPTED_REQUEST_UNDO:
1133     return inf_adopted_request_new_undo(
1134       priv-&gt;current,
1135       inf_user_get_id(INF_USER(user)),
1136       g_get_real_time()
1137     );
1138   case INF_ADOPTED_REQUEST_REDO:
1139     return inf_adopted_request_new_redo(
1140       priv-&gt;current,
1141       inf_user_get_id(INF_USER(user)),
1142       g_get_real_time()
1143     );
1144   default:
1145     g_return_val_if_reached(NULL);
1146     return NULL;
1147   }
1148 }
1149 InfAdoptedRequest*
1150 inf_adopted_algorithm_translate_request(InfAdoptedAlgorithm* algorithm,
1151                                         InfAdoptedRequest* request,
1152                                         InfAdoptedStateVector* to)
1153 {
1154   InfAdoptedAlgorithmPrivate* priv;
1155   guint user_id;
1156   InfUser* plain_user;
1157   InfAdoptedUser* user;
1158   InfAdoptedRequestLog* log;
1159   InfAdoptedRequest* result;
1160   g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), NULL);
1161   g_return_val_if_fail(INF_ADOPTED_IS_REQUEST(request), NULL);
1162   g_return_val_if_fail(to != NULL, NULL);
1163   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
1164   user_id = inf_adopted_request_get_user_id(request);
1165   plain_user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id);
1166   g_return_val_if_fail(INF_ADOPTED_IS_USER(plain_user), NULL);
1167   user = INF_ADOPTED_USER(plain_user);
1168   log = inf_adopted_user_get_request_log(user);
1169   g_return_val_if_fail(
1170     inf_adopted_state_vector_causally_before(to, priv-&gt;current),
1171     NULL
1172   );
1173   g_return_val_if_fail(
1174     inf_adopted_state_vector_causally_before(
1175       inf_adopted_request_get_vector(
1176         inf_adopted_request_log_original_request(log, request)
1177       ),
1178       to
1179     ),
1180     NULL
1181   );
1182   if(inf_adopted_request_affects_buffer(request))
1183   {
1184     result = inf_adopted_request_log_lookup_cached_request(log, to);
1185     if(result != NULL)
1186     {
1187       g_object_ref(result);
1188       return result;
1189     }
1190   }
1191   result = inf_adopted_algorithm_translate_request_forward(
1192     algorithm,
1193     request,
1194     to
1195   );
1196   g_assert(
1197     inf_adopted_state_vector_compare(
1198       inf_adopted_request_get_vector(result),
1199       to
1200     ) == 0
1201   );
1202   if(inf_adopted_algorithm_can_cache(result))
1203     inf_adopted_request_log_add_cached_request(log, result);
1204   return result;
1205 }
1206 gboolean
1207 inf_adopted_algorithm_execute_request(InfAdoptedAlgorithm* algorithm,
1208                                       InfAdoptedRequest* request,
1209                                       gboolean apply,
1210                                       GError** error)
1211 {
1212   InfAdoptedAlgorithmPrivate* priv;
1213   InfAdoptedUser* user;
1214   InfAdoptedRequestLog* log;
1215   InfAdoptedRequest* original;
1216   InfAdoptedRequest* translated;
1217   InfAdoptedRequest* log_request;
1218   GError* local_error;
1219   gchar* request_str;
1220   g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), FALSE);
1221   g_return_val_if_fail(INF_ADOPTED_IS_REQUEST(request), FALSE);
1222   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
1223   g_return_val_if_fail(
1224     inf_adopted_state_vector_causally_before(
1225       inf_adopted_request_get_vector(request),
1226       priv-&gt;current
1227     ),
1228     FALSE
1229   );
1230   g_return_val_if_fail(
1231     apply == TRUE || (
1232       inf_adopted_state_vector_compare(
1233         inf_adopted_request_get_vector(request),
1234         priv-&gt;current
1235       ) == 0 &amp;&amp; 
1236       inf_adopted_request_get_request_type(request) == INF_ADOPTED_REQUEST_DO
1237     ),
1238     FALSE
1239   );
1240   user = INF_ADOPTED_USER(
1241     inf_user_table_lookup_user_by_id(
1242       priv-&gt;user_table,
1243       inf_adopted_request_get_user_id(request)
1244     )
1245   );
1246   g_return_val_if_fail(user != NULL, FALSE);
1247   g_return_val_if_fail(priv-&gt;execute_request == NULL, FALSE);
1248   priv-&gt;execute_request = request;
1249   inf_adopted_request_set_execute_time(request, g_get_real_time());
1250   g_signal_emit(
1251     G_OBJECT(algorithm),
1252     algorithm_signals[BEGIN_EXECUTE_REQUEST],
1253     0,
1254     user,
1255     request
1256   );
1257   local_error = NULL;
1258   switch(inf_adopted_request_get_request_type(request))
1259   {
1260   case INF_ADOPTED_REQUEST_DO:
1261     break;
1262   case INF_ADOPTED_REQUEST_UNDO:
1263     if(!inf_adopted_algorithm_can_undo(algorithm, user))
1264     {
1265       request_str = inf_adopted_state_vector_to_string(
1266         inf_adopted_request_get_vector(request)
1267       );
1268       g_set_error(
1269         &amp;local_error,
1270         g_quark_from_static_string("INF_ADOPTED_ALGORITHM_ERROR"),
1271         INF_ADOPTED_ALGORITHM_ERROR_NO_UNDO,
1272         _("The request \"%s\" from user \"%s\" is an UNDO request but there "
1273           "is no request to be undone."),
1274         request_str,
1275         inf_user_get_name(INF_USER(user))
1276       );
1277       g_free(request_str);
1278     }
1279     break;
1280   case INF_ADOPTED_REQUEST_REDO:
1281     if(!inf_adopted_algorithm_can_redo(algorithm, user))
1282     {
1283       request_str = inf_adopted_state_vector_to_string(
1284         inf_adopted_request_get_vector(request)
1285       );
1286       g_set_error(
1287         &amp;local_error,
1288         g_quark_from_static_string("INF_ADOPTED_ALGORITHM_ERROR"),
1289         INF_ADOPTED_ALGORITHM_ERROR_NO_REDO,
1290         _("The request \"%s\" from user \"%s\" is a REDO request but there "
1291           "is no request to be redone."),
1292         request_str,
1293         inf_user_get_name(INF_USER(user))
1294       );
1295       g_free(request_str);
1296     }
1297     break;
1298   default:
1299     g_assert_not_reached();
1300     break;
1301   }
1302   if(local_error != NULL)
1303   {
1304     g_signal_emit(
1305       G_OBJECT(algorithm),
1306       algorithm_signals[END_EXECUTE_REQUEST],
1307       0,
1308       user,
1309       request,
1310       NULL,
1311       local_error
1312     );
1313     priv-&gt;execute_request = NULL;
1314     g_propagate_error(error, local_error);
1315     return FALSE;
1316   }
1317   log = inf_adopted_user_get_request_log(user);
1318   original = inf_adopted_request_log_original_request(log, request);
1319   g_assert(
1320     inf_adopted_request_get_request_type(original) == INF_ADOPTED_REQUEST_DO
1321   );
1322   translated = inf_adopted_algorithm_translate_request(
1323     algorithm,
1324     original,
1325     priv-&gt;current
1326   );
1327   g_assert(
1328     inf_adopted_request_get_request_type(translated) == INF_ADOPTED_REQUEST_DO
1329   );
1330   inf_signal_handlers_block_by_func(
1331     G_OBJECT(priv-&gt;buffer),
1332     G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
1333     algorithm
1334   );
1335   if(apply == TRUE)
1336   {
1337     log_request = inf_adopted_algorithm_apply_request(
1338       algorithm,
1339       user,
1340       request,
1341       translated,
1342       &amp;local_error
1343     );
1344     if(local_error != NULL)
1345     {
1346       inf_signal_handlers_unblock_by_func(
1347         G_OBJECT(priv-&gt;buffer),
1348         G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
1349         algorithm
1350       );
1351       g_signal_emit(
1352         G_OBJECT(algorithm),
1353         algorithm_signals[END_EXECUTE_REQUEST],
1354         0,
1355         user,
1356         request,
1357         translated,
1358         local_error
1359       );
1360       priv-&gt;execute_request = NULL;
1361       g_object_unref(translated);
1362       g_propagate_error(error, local_error);
1363       return FALSE;
1364     }
1365   }
1366   else
1367   {
1368     log_request = request;
1369     g_object_ref(request);
1370   }
1371   inf_adopted_algorithm_log_request(
1372     algorithm,
1373     user,
1374     log_request
1375   );
1376   inf_signal_handlers_unblock_by_func(
1377     G_OBJECT(priv-&gt;buffer),
1378     G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
1379     algorithm
1380   );
1381   inf_adopted_algorithm_update_undo_redo(algorithm);
1382   g_signal_emit(
1383     G_OBJECT(algorithm),
1384     algorithm_signals[END_EXECUTE_REQUEST],
1385     0,
1386     user,
1387     log_request,
1388     translated,
1389     NULL
1390   );
1391   g_object_unref(translated);
1392   g_object_unref(log_request);
1393   priv-&gt;execute_request = NULL;
1394   return TRUE;
1395 }
1396 void
1397 inf_adopted_algorithm_cleanup(InfAdoptedAlgorithm* algorithm)
1398 {
1399   InfAdoptedAlgorithmPrivate* priv;
1400   InfAdoptedStateVector* temp;
1401   InfAdoptedStateVector* lcp;
1402   InfAdoptedUser** user;
1403   InfAdoptedRequestLog* log;
1404   InfAdoptedRequest* req;
1405   InfAdoptedStateVector* req_vec;
1406   InfAdoptedStateVector* low_vec;
1407   gboolean req_before_lcp;
1408   guint n;
1409   guint id;
1410   guint vdiff;
1411   priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
1412   g_assert(priv-&gt;users_begin != priv-&gt;users_end);
1413   if(priv-&gt;max_total_log_size == G_MAXUINT)
1414     return;
1415   lcp = inf_adopted_state_vector_copy(priv-&gt;current);
1416   for(user = priv-&gt;users_begin; user != priv-&gt;users_end; ++ user)
1417   {
1418     if(inf_user_get_status(INF_USER(*user)) != INF_USER_UNAVAILABLE)
1419     {
1420       temp = inf_adopted_algorithm_least_common_predecessor(
1421         algorithm,
1422         lcp,
1423         inf_adopted_user_get_vector(*user)
1424       );
1425       inf_adopted_state_vector_free(lcp);
1426       lcp = temp;
1427     }
1428   }
1429   for(user = priv-&gt;users_begin; user != priv-&gt;users_end; ++ user)
1430   {
1431     id = inf_user_get_id(INF_USER(*user));
1432     log = inf_adopted_user_get_request_log(*user);
1433     n = inf_adopted_request_log_get_begin(log);
1434     while(n &lt; inf_adopted_request_log_get_end(log))
1435     {
1436       req = inf_adopted_request_log_upper_related(log, n);
1437       req_vec = inf_adopted_request_get_vector(req);
1438       req_before_lcp = inf_adopted_state_vector_causally_before_inc(
1439         req_vec,
1440         lcp,
1441         id
1442       );
1443       if(!req_before_lcp)
1444         break;
1445       low_vec = inf_adopted_request_get_vector(
1446         inf_adopted_request_log_get_request(log, n)
1447       );
1448       vdiff = inf_adopted_state_vector_vdiff(low_vec, lcp);
1449       if(vdiff &lt; priv-&gt;max_total_log_size)
1450         break;
1451       n = inf_adopted_state_vector_get(req_vec, id) + 1;
1452     }
1453     inf_adopted_request_log_remove_requests(log, n);
1454   }
1455   inf_adopted_state_vector_free(lcp);
1456 }
1457 gboolean
1458 inf_adopted_algorithm_can_undo(InfAdoptedAlgorithm* algorithm,
1459                                InfAdoptedUser* user)
1460 {
1461   InfAdoptedAlgorithmLocalUser* local;
1462   InfAdoptedRequestLog* log;
1463   g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), FALSE);
1464   g_return_val_if_fail(INF_ADOPTED_IS_USER(user), FALSE);
1465   local = inf_adopted_algorithm_find_local_user(algorithm, user);
1466   if(local != NULL)
1467   {
1468     return local-&gt;can_undo;
1469   }
1470   else
1471   {
1472     log = inf_adopted_user_get_request_log(user);
1473     return inf_adopted_algorithm_can_undo_redo(
1474       algorithm,
1475       user,
1476       inf_adopted_request_log_next_undo(log)
1477     );
1478   }
1479 }
1480 gboolean
1481 inf_adopted_algorithm_can_redo(InfAdoptedAlgorithm* algorithm,
1482                                InfAdoptedUser* user)
1483 {
1484   InfAdoptedAlgorithmLocalUser* local;
1485   InfAdoptedRequestLog* log;
1486   g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), FALSE);
1487   g_return_val_if_fail(INF_ADOPTED_IS_USER(user), FALSE);
1488   local = inf_adopted_algorithm_find_local_user(algorithm, user);
1489   if(local != NULL)
1490   {
1491     return local-&gt;can_redo;
1492   }
1493   else
1494   {
1495     log = inf_adopted_user_get_request_log(user);
1496     return inf_adopted_algorithm_can_undo_redo(
1497       algorithm,
1498       user,
1499       inf_adopted_request_log_next_redo(log)
1500     );
1501   }
1502 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
