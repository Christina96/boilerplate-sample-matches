<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-communication-central-method.c &amp; inf-adopted-algorithm.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-communication-central-method.c &amp; inf-adopted-algorithm.c
      </h3>
<h1 align="center">
        8.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-communication-central-method.c (16.044777%)<th>inf-adopted-algorithm.c (5.5771723%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(561-586)<td><a href="#" name="0">(1235-1260)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(606-645)<td><a href="#" name="1">(1301-1318)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(157-191)<td><a href="#" name="2">(1261-1284)</a><td align="center"><font color="#ee0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-communication-central-method.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/communication/inf-communication-central-method.h&gt;
#include &lt;libinfinity/communication/inf-communication-hosted-group.h&gt;
#include &lt;libinfinity/communication/inf-communication-registry.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
typedef struct _InfCommunicationCentralMethodPrivate
  InfCommunicationCentralMethodPrivate;
struct _InfCommunicationCentralMethodPrivate {
  InfCommunicationRegistry* registry;
  InfCommunicationGroup* group;
  gboolean is_publisher; 
  GSList* connections;
};
enum {
  PROP_0,
  PROP_REGISTRY,
  PROP_GROUP
};
#define INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_COMMUNICATION_TYPE_CENTRAL_METHOD, InfCommunicationCentralMethodPrivate))
static void inf_communication_central_method_method_iface_init(InfCommunicationMethodInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfCommunicationCentralMethod, inf_communication_central_method, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfCommunicationCentralMethod)
  G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_METHOD, inf_communication_central_method_method_iface_init))
static void
inf_communication_central_method_broadcast(InfCommunicationMethod* method,
                                           xmlNodePtr xml,
                                           InfXmlConnection* except)
{
  InfCommunicationCentralMethodPrivate* priv;
  InfCommunicationRegistry* registry;
  InfCommunicationGroup* group;
  GSList* connections;
  GSList* item;
  InfXmlConnection* connection;
  gboolean is_registered;
  InfXmlConnectionStatus status;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  g_object_ref(method);
  registry = g_object_ref(priv-&gt;registry);
  group = g_object_ref(priv-&gt;group);
  connections = g_slist_copy(priv-&gt;connections);
  for(item = connections; item != NULL; item = item-&gt;next)
    g_object_ref(item-&gt;data);
  while(connections)
  {
    connection = INF_XML_CONNECTION(connections-&gt;data);
    is_registered = inf_communication_registry_is_registered(
      registry,
      group,
      connection
    );
    g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
    if(is_registered &amp;&amp;
       status == INF_XML_CONNECTION_OPEN &amp;&amp;
       connection != except)
    {
      if(connections-&gt;next != NULL)
      {
        inf_communication_registry_send(
          registry,
          group,
          connection,
          xmlCopyNode(xml, 1)
        );
      }
      else
      {
        inf_communication_registry_send(registry, group, connection, xml);
        xml = NULL;
      }
    }
    g_object_unref(connection);
    connections = g_slist_delete_link(connections, connections);
  }
  g_object_unref(method);
  g_object_unref(registry);
  g_object_unref(group);
  if(xml != NULL)
    xmlFreeNode(xml);
}
static void
inf_communication_central_method_notify_status_cb(GObject* object,
                                                  GParamSpec* pspec,
                                                  gpointer user_data)
{
  InfCommunicationCentralMethod* method;
  InfCommunicationCentralMethodPrivate* priv;
  InfXmlConnectionStatus status;
  method = INF_COMMUNICATION_CENTRAL_METHOD(user_data);
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  g_object_get(object, "status", &amp;status, NULL);
<a name="2"></a>  switch(status)
  {
  case INF_XML_CONNECTION_CLOSED:
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case INF_XML_CONNECTION_CLOSING:
    g_object_ref(priv-&gt;group);
    inf_communication_method_remove_member(
      INF_COMMUNICATION_METHOD(method),
      INF_XML_CONNECTION(object)
    );
    g_object_unref(priv-&gt;group);
    break;
  case INF_XML_CONNECTION_OPENING:
    break;
  case INF_XML_CONNECTION_OPEN:
    inf_communication_registry_register(
      priv-&gt;registry,
      priv-&gt;group,
      INF_COMMUNICATION_METHOD(method),
      INF_XML_CONNECTION(object)
    );
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_communication_central_method_add_member(InfCommunicationMethod* method,
                                            InfXmlConnection* connection)
{
  InfCommunicationCentralMethodPrivate* priv;
  InfXmlConnectionStatus status;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);</b></font>
  g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
  g_assert(status != INF_XML_CONNECTION_CLOSING &amp;&amp; 
           status != INF_XML_CONNECTION_CLOSED);
  priv-&gt;connections = g_slist_prepend(priv-&gt;connections, connection);
  g_signal_connect(
    connection,
    "notify::status",
    G_CALLBACK(inf_communication_central_method_notify_status_cb),
    method
  );
  if(status == INF_XML_CONNECTION_OPEN)
  {
    inf_communication_registry_register(
      priv-&gt;registry,
      priv-&gt;group,
      method,
      connection
    );
  }
}
static void
inf_communication_central_method_remove_member(InfCommunicationMethod* method,
                                               InfXmlConnection* connection)
{
  InfCommunicationCentralMethodPrivate* priv;
  InfXmlConnectionStatus status;
  gboolean is_registered;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
  is_registered = inf_communication_registry_is_registered(
    priv-&gt;registry,
    priv-&gt;group,
    connection
  );
  if(is_registered)
  {
    inf_communication_registry_unregister(
      priv-&gt;registry,
      priv-&gt;group,
      connection
    );
  }
  inf_signal_handlers_disconnect_by_func(
    connection,
    G_CALLBACK(inf_communication_central_method_notify_status_cb),
    method
  );
  priv-&gt;connections = g_slist_remove(priv-&gt;connections, connection);
}
static gboolean
inf_communication_central_method_is_member(InfCommunicationMethod* method,
                                           InfXmlConnection* connection)
{
  InfCommunicationCentralMethodPrivate* priv;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  if(g_slist_find(priv-&gt;connections, connection) == NULL)
    return FALSE;
  return TRUE;
}
static void
inf_communication_central_method_send_single(InfCommunicationMethod* method,
                                             InfXmlConnection* connection,
                                             xmlNodePtr xml)
{
  InfCommunicationCentralMethodPrivate* priv;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  inf_communication_registry_send(
    priv-&gt;registry,
    priv-&gt;group,
    connection,
    xml
  );
}
static void
inf_communication_central_method_send_all(InfCommunicationMethod* method,
                                          xmlNodePtr xml)
{
  inf_communication_central_method_broadcast(method, xml, NULL);
}
static void
inf_communication_central_method_cancel_messages(InfCommunicationMethod* meth,
                                                 InfXmlConnection* connection)
{
  InfCommunicationCentralMethodPrivate* priv;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(meth);
  inf_communication_registry_cancel_messages(
    priv-&gt;registry,
    priv-&gt;group,
    connection
  );
}
static InfCommunicationScope
inf_communication_central_method_received(InfCommunicationMethod* method,
                                          InfXmlConnection* connection,
                                          xmlNodePtr xml)
{
  InfCommunicationCentralMethodPrivate* priv;
  InfCommunicationObject* target;
  InfCommunicationGroup* group;
  InfCommunicationScope scope;
  gchar* remote_id;
  gchar* publisher_id;
  GSList* item;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  target = inf_communication_group_get_target(priv-&gt;group);
  group = priv-&gt;group;
  if(target != NULL)
  {
    g_object_ref(target);
    g_object_ref(group);
    g_object_ref(method);
    scope = inf_communication_object_received(
      target,
      connection,
      xml
    );
    if(priv-&gt;is_publisher &amp;&amp; scope == INF_COMMUNICATION_SCOPE_GROUP)
    {
      inf_communication_central_method_broadcast(
        method,
        xmlCopyNode(xml, 1),
        connection
      );
    }
    g_object_unref(method);
    g_object_unref(group);
    g_object_unref(target);
    return scope;
  }
  else
  {
    return INF_COMMUNICATION_SCOPE_PTP;
  }
}
static void
inf_communication_central_method_enqueued(InfCommunicationMethod* method,
                                          InfXmlConnection* connection,
                                          xmlNodePtr xml)
{
  InfCommunicationCentralMethodPrivate* priv;
  InfCommunicationObject* target;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  target = inf_communication_group_get_target(priv-&gt;group);
  if(target != NULL)
    inf_communication_object_enqueued(target, connection, xml);
}
static void
inf_communication_central_method_sent(InfCommunicationMethod* method,
                                      InfXmlConnection* connection,
                                      xmlNodePtr xml)
{
  InfCommunicationCentralMethodPrivate* priv;
  InfCommunicationObject* target;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  target = inf_communication_group_get_target(priv-&gt;group);
  if(target != NULL)
    inf_communication_object_sent(target, connection, xml);
}
static void
inf_communication_central_method_registry_unrefed(gpointer data,
                                                  GObject* object)
{
  InfCommunicationCentralMethod* method;
  InfCommunicationCentralMethodPrivate* priv;
  method = INF_COMMUNICATION_CENTRAL_METHOD(data);
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  g_warning("A method's registry was unrefed before the method was unrefed");
  priv-&gt;registry = NULL;
}
static void
inf_communication_central_method_group_unrefed(gpointer data,
                                               GObject* where_the_object_was)
{
  InfCommunicationCentralMethod* method;
  InfCommunicationCentralMethodPrivate* priv;
  method = INF_COMMUNICATION_CENTRAL_METHOD(data);
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  g_warning("A method's group was unrefed before the method was unrefed");
  priv-&gt;group = NULL;
}
static void
inf_communication_central_method_set_registry(InfCommunicationCentralMethod* m,
                                              InfCommunicationRegistry* reg)
{
  InfCommunicationCentralMethodPrivate* priv;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(m);
  if(priv-&gt;registry != NULL)
  {
    g_object_weak_unref(
      G_OBJECT(priv-&gt;registry),
      inf_communication_central_method_registry_unrefed,
      m
    );
  }
  priv-&gt;registry = reg;
  if(reg != NULL)
  {
    g_object_weak_ref(
      G_OBJECT(reg),
      inf_communication_central_method_registry_unrefed,
      m
    );
  }
  g_object_notify(G_OBJECT(m), "registry");
}
static void
inf_communication_central_method_set_group(InfCommunicationCentralMethod* m,
                                           InfCommunicationGroup* group)
{
  InfCommunicationCentralMethodPrivate* priv;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(m);
  if(priv-&gt;group != NULL)
  {
    g_object_weak_unref(
      G_OBJECT(priv-&gt;group),
      inf_communication_central_method_group_unrefed,
      m
    );
    priv-&gt;is_publisher = FALSE;
  }
  priv-&gt;group = group;
  if(group != NULL)
  {
    g_object_weak_ref(
      G_OBJECT(group),
      inf_communication_central_method_group_unrefed,
      m
    );
    if(INF_COMMUNICATION_IS_HOSTED_GROUP(group))
      priv-&gt;is_publisher = TRUE;
    else
      priv-&gt;is_publisher = FALSE;
  }
  g_object_notify(G_OBJECT(m), "group");
}
static void
inf_communication_central_method_init(InfCommunicationCentralMethod* method)
{
  InfCommunicationCentralMethodPrivate* priv;
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  priv-&gt;group = NULL;
  priv-&gt;registry = NULL;
  priv-&gt;is_publisher = FALSE;
  priv-&gt;connections = NULL;
}
static void
inf_communication_central_method_dispose(GObject* object)
{
  InfCommunicationCentralMethod* method;
  InfCommunicationCentralMethodPrivate* priv;
  method = INF_COMMUNICATION_CENTRAL_METHOD(object);
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  while(priv-&gt;connections != NULL)
  {
    inf_communication_method_remove_member(
      INF_COMMUNICATION_METHOD(method),
      INF_XML_CONNECTION(priv-&gt;connections-&gt;data)
    );
  }
  inf_communication_central_method_set_group(method, NULL);
  inf_communication_central_method_set_registry(method, NULL);
  G_OBJECT_CLASS(inf_communication_central_method_parent_class)-&gt;dispose(object);
}
static void
inf_communication_central_method_set_property(GObject* object,
                                              guint prop_id,
                                              const GValue* value,
                                              GParamSpec* pspec)
{
  InfCommunicationCentralMethod* method;
  InfCommunicationCentralMethodPrivate* priv;
  method = INF_COMMUNICATION_CENTRAL_METHOD(object);
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  switch(prop_id)
  {
  case PROP_REGISTRY:
    g_assert(priv-&gt;registry == NULL); 
    inf_communication_central_method_set_registry(
      method,
      INF_COMMUNICATION_REGISTRY(g_value_get_object(value))
    );
    break;
  case PROP_GROUP:
    g_assert(priv-&gt;group == NULL); 
    inf_communication_central_method_set_group(
      method,
      INF_COMMUNICATION_GROUP(g_value_get_object(value))
<a name="0"></a>    );
    break;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_communication_central_method_get_property(GObject* object,
                                              guint prop_id,
                                              GValue* value,
                                              GParamSpec* pspec)
{
  InfCommunicationCentralMethod* method;
  InfCommunicationCentralMethodPrivate* priv;
  method = INF_COMMUNICATION_CENTRAL_METHOD(object);
  priv = INF_COMMUNICATION_CENTRAL_METHOD_PRIVATE(method);
  switch(prop_id)
  {
  case PROP_REGISTRY:
    g_value_set_object(value, priv-&gt;registry);
    break;
  case PROP_GROUP:
    g_value_set_object(value, priv-&gt;group);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_communication_central_method_class_init(
  InfCommunicationCentralMethodClass* method_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(method_class);
<a name="1"></a>
  object_class-&gt;dispose = inf_communication_central_method_dispose;
  object_class-&gt;set_property = inf_communication_central_method_set_property;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  object_class-&gt;get_property = inf_communication_central_method_get_property;
  g_object_class_install_property(
    object_class,
    PROP_REGISTRY,
    g_param_spec_object(
      "registry",
      "Registry",
      "The communication registry to register connections with",
      INF_COMMUNICATION_TYPE_REGISTRY,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_GROUP,
    g_param_spec_object(
      "group",
      "Group",
      "The communication group for which to handle messages",
      INF_COMMUNICATION_TYPE_GROUP,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}
static void
inf_communication_central_method_method_iface_init(
  InfCommunicationMethodInterface* iface)
{
  iface-&gt;add_member = inf_communication_central_method_add_member;
  iface-&gt;remove_member = inf_communication_central_method_remove_member;
  iface-&gt;is_member = inf_communication_central_method_is_member;
  iface-&gt;send_single = inf_communication_central_method_send_single;
  iface-&gt;send_all = inf_communication_central_method_send_all;
  iface-&gt;cancel_messages = inf_communication_central_method_cancel_messages;
  iface-&gt;received = inf_communication_central_method_received;
  iface-&gt;enqueued = inf_communication_central_method_enqueued;
  iface-&gt;sent = inf_communication_central_method_sent;</b></font>
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-algorithm.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/adopted/inf-adopted-algorithm.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
typedef struct _InfAdoptedAlgorithmLocalUser InfAdoptedAlgorithmLocalUser;
struct _InfAdoptedAlgorithmLocalUser {
  InfAdoptedUser* user;
  gboolean can_undo;
  gboolean can_redo;
};
typedef struct _InfAdoptedAlgorithmPrivate InfAdoptedAlgorithmPrivate;
struct _InfAdoptedAlgorithmPrivate {
  guint max_total_log_size;
  InfAdoptedStateVector* current;
  InfAdoptedStateVector* buffer_modified_time;
  InfAdoptedRequest* execute_request;
  InfUserTable* user_table;
  InfBuffer* buffer;
  InfAdoptedUser** users_begin;
  InfAdoptedUser** users_end;
  GSList* local_users;
};
enum {
  PROP_0,
  PROP_USER_TABLE,
  PROP_BUFFER,
  PROP_MAX_TOTAL_LOG_SIZE,
  PROP_CURRENT_STATE,
  PROP_BUFFER_MODIFIED_STATE
};
enum {
  CAN_UNDO_CHANGED,
  CAN_REDO_CHANGED,
  BEGIN_EXECUTE_REQUEST,
  END_EXECUTE_REQUEST,
  LAST_SIGNAL
};
#define INF_ADOPTED_ALGORITHM_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_ALGORITHM, InfAdoptedAlgorithmPrivate))
#define INF_ADOPTED_ALGORITHM_PRIVATE(obj)     ((InfAdoptedAlgorithmPrivate*)(obj)-&gt;priv)
static guint algorithm_signals[LAST_SIGNAL];
G_DEFINE_TYPE_WITH_CODE(InfAdoptedAlgorithm, inf_adopted_algorithm, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfAdoptedAlgorithm))
static InfAdoptedStateVector*
inf_adopted_algorithm_least_common_successor(InfAdoptedAlgorithm* algorithm,
                                             InfAdoptedStateVector* first,
                                             InfAdoptedStateVector* second)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedUser** user;
  InfAdoptedStateVector* result;
  guint id;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  result = inf_adopted_state_vector_new();
  for(user = priv-&gt;users_begin; user != priv-&gt;users_end; ++ user)
  {
    id = inf_user_get_id(INF_USER(*user));
    inf_adopted_state_vector_set(
      result,
      id,
      MAX(
        inf_adopted_state_vector_get(first, id),
        inf_adopted_state_vector_get(second, id)
      )
    );
  }
  g_assert(inf_adopted_state_vector_causally_before(first, result));
  g_assert(inf_adopted_state_vector_causally_before(second, result));
  return result;
}
static InfAdoptedStateVector*
inf_adopted_algorithm_least_common_predecessor(InfAdoptedAlgorithm* algorithm,
                                               InfAdoptedStateVector* first,
                                               InfAdoptedStateVector* second)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedUser** user;
  InfAdoptedStateVector* result;
  guint id;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  result = inf_adopted_state_vector_new();
  for(user = priv-&gt;users_begin; user != priv-&gt;users_end; ++ user)
  {
    id = inf_user_get_id(INF_USER(*user));
    inf_adopted_state_vector_set(
      result,
      id,
      MIN(
        inf_adopted_state_vector_get(first, id),
        inf_adopted_state_vector_get(second, id)
      )
    );
  }
  return result;
}
static gboolean
inf_adopted_algorithm_can_undo_redo(InfAdoptedAlgorithm* algorithm,
                                    InfAdoptedUser* user,
                                    InfAdoptedRequest* request)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedRequestLog* log;
  guint diff;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  if(request != NULL)
  {
    if(priv-&gt;max_total_log_size != G_MAXUINT)
    {
      log = inf_adopted_user_get_request_log(user);
      request = inf_adopted_request_log_original_request(log, request);
      diff = inf_adopted_state_vector_vdiff(
        inf_adopted_request_get_vector(request),
        inf_adopted_user_get_vector(user)
      );
      if(diff &gt;= priv-&gt;max_total_log_size)
        return FALSE;
      else
        return TRUE;
    }
    else
    {
      return TRUE;
    }
  }
  else
  {
    return FALSE;
  }
}
static void
inf_adopted_algorithm_update_undo_redo(InfAdoptedAlgorithm* algorithm)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedAlgorithmLocalUser* local;
  InfAdoptedRequestLog* log;
  GSList* item;
  gboolean can_undo;
  gboolean can_redo;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = item-&gt;data;
    log = inf_adopted_user_get_request_log(local-&gt;user);
    can_undo = inf_adopted_algorithm_can_undo_redo(
      algorithm,
      local-&gt;user,
      inf_adopted_request_log_next_undo(log)
    );
    can_redo = inf_adopted_algorithm_can_undo_redo(
      algorithm,
      local-&gt;user,
      inf_adopted_request_log_next_redo(log)
    );
    if(local-&gt;can_undo != can_undo)
    {
      g_signal_emit(
        G_OBJECT(algorithm),
        algorithm_signals[CAN_UNDO_CHANGED],
        0,
        local-&gt;user,
        can_undo
      );
    }
    if(local-&gt;can_redo != can_redo)
    {
      g_signal_emit(
        G_OBJECT(algorithm),
        algorithm_signals[CAN_REDO_CHANGED],
        0,
        local-&gt;user,
        can_redo
      );
    }
  }
}
static InfAdoptedAlgorithmLocalUser*
inf_adopted_algorithm_find_local_user(InfAdoptedAlgorithm* algorithm,
                                      InfAdoptedUser* user)
{
  InfAdoptedAlgorithmPrivate* priv;
  GSList* item;
  InfAdoptedAlgorithmLocalUser* local;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfAdoptedAlgorithmLocalUser*)item-&gt;data;
    if(local-&gt;user == user)
      return local;
  }
  return NULL;
}
static void
inf_adopted_algorithm_local_user_free(InfAdoptedAlgorithm* algorithm,
                                      InfAdoptedAlgorithmLocalUser* local)
{
  InfAdoptedAlgorithmPrivate* priv;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
  g_slice_free(InfAdoptedAlgorithmLocalUser, local);
}
static void
inf_adopted_algorithm_add_user(InfAdoptedAlgorithm* algorithm,
                               InfAdoptedUser* user)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedRequestLog* log;
  InfAdoptedStateVector* time;
  guint user_count;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  log = inf_adopted_user_get_request_log(user);
  time = inf_adopted_user_get_vector(user);
  inf_adopted_state_vector_set(
    priv-&gt;current,
    inf_user_get_id(INF_USER(user)),
    inf_adopted_state_vector_get(time, inf_user_get_id(INF_USER(user)))
  );
  user_count = (priv-&gt;users_end - priv-&gt;users_begin) + 1;
  priv-&gt;users_begin =
    g_realloc(priv-&gt;users_begin, sizeof(InfAdoptedUser*) * user_count);
  priv-&gt;users_end = priv-&gt;users_begin + user_count;
  priv-&gt;users_begin[user_count - 1] = user;
}
static void
inf_adopted_algorithm_add_local_user(InfAdoptedAlgorithm* algorithm,
                                     InfAdoptedUser* user)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedAlgorithmLocalUser* local;
  InfAdoptedRequestLog* log;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  local = g_slice_new(InfAdoptedAlgorithmLocalUser);
  local-&gt;user = user;
  log = inf_adopted_user_get_request_log(user);
  local-&gt;can_undo = inf_adopted_algorithm_can_undo_redo(
    algorithm,
    user,
    inf_adopted_request_log_next_undo(log)
  );
  local-&gt;can_redo = inf_adopted_algorithm_can_undo_redo(
    algorithm,
    user,
    inf_adopted_request_log_next_redo(log)
  );
  priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
}
static void
inf_adopted_algorithm_add_user_cb(InfUserTable* user_table,
                                  InfUser* user,
                                  gpointer user_data)
{
  InfAdoptedAlgorithm* algorithm;
  algorithm = INF_ADOPTED_ALGORITHM(user_data);
  g_assert(INF_ADOPTED_IS_USER(user));
  inf_adopted_algorithm_add_user(algorithm, INF_ADOPTED_USER(user));
}
static void
inf_adopted_algorithm_add_local_user_cb(InfUserTable* user_table,
                                        InfUser* user,
                                        gpointer user_data)
{
  InfAdoptedAlgorithm* algorithm;
  algorithm = INF_ADOPTED_ALGORITHM(user_data);
  g_assert(INF_ADOPTED_IS_USER(user));
  inf_adopted_algorithm_add_local_user(algorithm, INF_ADOPTED_USER(user));
}
static void
inf_adopted_algorithm_remove_local_user_cb(InfUserTable* user_table,
                                           InfUser* user,
                                           gpointer user_data)
{
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedAlgorithmLocalUser* local;
  algorithm = INF_ADOPTED_ALGORITHM(user_data);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  local =
    inf_adopted_algorithm_find_local_user(algorithm, INF_ADOPTED_USER(user));
  g_assert(local != NULL);
  inf_adopted_algorithm_local_user_free(algorithm, local);
}
static gboolean
inf_adopted_algorithm_buffer_states_equivalent(InfAdoptedAlgorithm* algorithm,
                                               InfAdoptedStateVector* first,
                                               InfAdoptedStateVector* second)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedUser** user_it;
  InfAdoptedUser* user;
  InfAdoptedRequest* request;
  InfAdoptedRequestLog* log;
  guint user_id;
  guint first_n;
  guint second_n;
  g_assert(inf_adopted_state_vector_causally_before(first, second));
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  for(user_it = priv-&gt;users_begin; user_it != priv-&gt;users_end; ++ user_it)
  {
    user = *user_it;
    user_id = inf_user_get_id(INF_USER(user));
    log = inf_adopted_user_get_request_log(user);
    first_n = inf_adopted_state_vector_get(first, user_id);
    second_n = inf_adopted_state_vector_get(second, user_id);
    while(second_n &gt; first_n)
    {
      if(second_n &lt;= inf_adopted_request_log_get_begin(log))
        return FALSE;
      request = inf_adopted_request_log_get_request(log, second_n - 1);
      if(inf_adopted_request_get_request_type(request) ==
         INF_ADOPTED_REQUEST_DO)
      {
        return FALSE;
      }
      else
      {
        request = inf_adopted_request_log_prev_associated(log, request);
        second_n = inf_adopted_state_vector_get(
          inf_adopted_request_get_vector(request),
          user_id
        );
      }
    }
    if(second_n &lt; first_n)
      return FALSE;
  }
  return TRUE;
}
static void
inf_adopted_algorithm_buffer_notify_modified_cb(GObject* object,
                                                GParamSpec* pspec,
                                                gpointer user_data)
{
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedAlgorithmPrivate* priv;
  gboolean equivalent;
  algorithm = INF_ADOPTED_ALGORITHM(user_data);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  if(inf_buffer_get_modified(INF_BUFFER(object)))
  {
    if(priv-&gt;buffer_modified_time != NULL)
    {
      equivalent = inf_adopted_algorithm_buffer_states_equivalent(
        algorithm,
        priv-&gt;buffer_modified_time,
        priv-&gt;current
      );
      if(equivalent == TRUE)
      {
        inf_adopted_state_vector_free(priv-&gt;buffer_modified_time);
        priv-&gt;buffer_modified_time = NULL;
      }
    }
  }
  else
  {
    if(priv-&gt;buffer_modified_time != NULL)
      inf_adopted_state_vector_free(priv-&gt;buffer_modified_time);
    priv-&gt;buffer_modified_time = inf_adopted_state_vector_copy(priv-&gt;current);
  }
}
static void
inf_adopted_algorithm_update_local_user_times(InfAdoptedAlgorithm* algorithm)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedAlgorithmLocalUser* local;
  GSList* item;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = item-&gt;data;
    inf_adopted_user_set_vector(
      local-&gt;user,
      inf_adopted_state_vector_copy(priv-&gt;current)
    );
  }
}
static gboolean
inf_adopted_algorithm_can_cache(InfAdoptedRequest* request)
{
  InfAdoptedOperation* operation;
  InfAdoptedOperationFlags flags;
#define INF_ADOPTED_OPERATION_CACHABLE \
  (INF_ADOPTED_OPERATION_AFFECTS_BUFFER | INF_ADOPTED_OPERATION_REVERSIBLE)
  if(inf_adopted_request_get_request_type(request) != INF_ADOPTED_REQUEST_DO)
    return TRUE;
  operation = inf_adopted_request_get_operation(request);
  flags = inf_adopted_operation_get_flags(operation) &amp;
    INF_ADOPTED_OPERATION_CACHABLE;
  return flags == INF_ADOPTED_OPERATION_CACHABLE;
}
static InfAdoptedRequest*
inf_adopted_algorithm_transform_request(InfAdoptedAlgorithm* algorithm,
                                        InfAdoptedRequest* request,
                                        InfAdoptedRequest* against,
                                        InfAdoptedStateVector* at)
{
  InfAdoptedRequest* request_at;
  InfAdoptedRequest* against_at;
  InfAdoptedConcurrencyId concurrency_id;
  InfAdoptedStateVector* lcs;
  InfAdoptedRequest* lcs_against;
  InfAdoptedRequest* lcs_request;
  InfAdoptedRequest* result;
  g_assert(
    inf_adopted_state_vector_causally_before(
      inf_adopted_request_get_vector(request),
      at
    )
  );
  g_assert(
    inf_adopted_state_vector_causally_before(
      inf_adopted_request_get_vector(against),
      at
    )
  );
  against_at = inf_adopted_algorithm_translate_request(
    algorithm,
    against,
    at
  );
  request_at = inf_adopted_algorithm_translate_request(
    algorithm,
    request,
    at
  );
  concurrency_id = INF_ADOPTED_CONCURRENCY_NONE;
  if(inf_adopted_request_need_concurrency_id(request_at, against_at) == TRUE)
  {
    lcs = inf_adopted_algorithm_least_common_successor(
      algorithm,
      inf_adopted_request_get_vector(request),
      inf_adopted_request_get_vector(against)
    );
    g_assert(inf_adopted_state_vector_causally_before(lcs, at));
    if(inf_adopted_state_vector_compare(lcs, at) != 0)
    {
      lcs_against = inf_adopted_algorithm_translate_request(
        algorithm,
        against,
        lcs
      );
      lcs_request = inf_adopted_algorithm_translate_request(
        algorithm,
        request,
        lcs
      );
    }
    else
    {
      lcs_against = against_at;
      lcs_request = request_at;
      g_object_ref(lcs_against);
      g_object_ref(lcs_request);
    }
    inf_adopted_state_vector_free(lcs);
  }
  else
  {
    lcs_against = NULL;
    lcs_request = NULL;
  }
  result = inf_adopted_request_transform(
    request_at,
    against_at,
    lcs_request,
    lcs_against
  );
  if(lcs_request != NULL)
    g_object_unref(lcs_request);
  if(lcs_against != NULL)
    g_object_unref(lcs_against);
  g_object_unref(request_at);
  g_object_unref(against_at);
  return result;
}
static InfAdoptedRequest*
inf_adopted_algorithm_translate_request_forward(InfAdoptedAlgorithm* algorithm,
                                                InfAdoptedRequest* request,
                                                InfAdoptedStateVector* to)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedUser** user_it;
  InfAdoptedUser* user;
  InfAdoptedRequestLog* log;
  guint user_id;
  InfAdoptedRequest* cur_req;
  InfAdoptedRequest* next_req;
  InfAdoptedStateVector* vector;
  InfAdoptedRequest* index;
  InfAdoptedRequest* associated;
  InfAdoptedRequest* translated;
  InfAdoptedStateVector* associated_vector;
  guint from_n;
  guint to_n;
  guint associated_index;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  cur_req = request;
  vector = inf_adopted_request_get_vector(cur_req);
  g_object_ref(cur_req);
  while(inf_adopted_state_vector_compare(vector, to) != 0)
  {
    next_req = NULL;
    g_assert(inf_adopted_state_vector_causally_before(vector, to) == TRUE);
    for(user_it = priv-&gt;users_begin; user_it != priv-&gt;users_end; ++user_it)
    {
      user = *user_it;
      user_id = inf_user_get_id(INF_USER(user));
      if(user_id == inf_adopted_request_get_user_id(cur_req)) continue;
      from_n = inf_adopted_state_vector_get(vector, user_id);
      to_n = inf_adopted_state_vector_get(to, user_id);
      g_assert(from_n &lt;= to_n);
      if(from_n == to_n) continue;
      log = inf_adopted_user_get_request_log(user);
      g_assert(from_n &gt;= inf_adopted_request_log_get_begin(log));
      g_assert(to_n &lt;= inf_adopted_request_log_get_end(log));
      index = inf_adopted_request_log_get_request(log, from_n);
      associated = inf_adopted_request_log_next_associated(log, index);
      if(associated != NULL &amp;&amp;
         inf_adopted_request_get_index(associated) &lt; to_n)
      {
        next_req = inf_adopted_request_fold(
          cur_req,
          user_id,
          inf_adopted_request_get_index(associated) - from_n + 1
        );
        break;
      }
      else
      {
        associated = inf_adopted_request_log_original_request(log, index);
        associated_vector = inf_adopted_request_get_vector(associated);
        if(inf_adopted_state_vector_causally_before(associated_vector, vector))
        {
          translated = inf_adopted_algorithm_translate_request(
            algorithm,
            associated,
            vector
          );
          next_req = inf_adopted_algorithm_transform_request(
            algorithm,
            cur_req,
            translated,
            vector
          );
          g_object_unref(translated);
          break;
        }
      }
    }
    if(next_req == NULL)
    {
      user_id = inf_adopted_request_get_user_id(cur_req);
      user = INF_ADOPTED_USER(
        inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id)
      );
      log = inf_adopted_user_get_request_log(user);
      from_n = inf_adopted_request_get_index(cur_req);
      to_n = inf_adopted_state_vector_get(to, user_id);
      index = inf_adopted_request_log_get_request(log, from_n);
      associated = inf_adopted_request_log_next_associated(log, index);
      if(associated == NULL)
      {
        if(inf_adopted_request_get_request_type(index) == INF_ADOPTED_REQUEST_UNDO)
        {
          if(inf_adopted_request_log_next_redo(log) == index)
            associated_index = to_n;
          else
            associated_index = G_MAXUINT;
        }
        else
        {
          if(inf_adopted_request_log_next_undo(log) == index)
            associated_index = to_n;
          else
            associated_index = G_MAXUINT;
        }
      }
      else
      {
        associated_index = inf_adopted_request_get_index(associated);
      }
      if(associated_index != G_MAXUINT &amp;&amp; associated_index &lt;= to_n)
      {
        next_req = inf_adopted_request_mirror(
          cur_req,
          associated_index - from_n
        );
      }
    }
    g_assert(next_req != NULL);
    g_object_unref(cur_req);
    cur_req = next_req;
    vector = inf_adopted_request_get_vector(cur_req);
  }
  return cur_req;
}
static void
inf_adopted_algorithm_log_request(InfAdoptedAlgorithm* algorithm,
                                  InfAdoptedUser* user,
                                  InfAdoptedRequest* request)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedRequestLog* log;
  guint user_id;
  gboolean equivalent;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  log = inf_adopted_user_get_request_log(user);
  user_id = inf_user_get_id(INF_USER(user));
  g_assert(inf_adopted_request_get_user_id(request) == user_id);
  if(inf_adopted_request_affects_buffer(request))
  {
    inf_adopted_request_log_add_request(log, request);
    inf_adopted_state_vector_add(priv-&gt;current, user_id, 1);
    inf_adopted_algorithm_update_local_user_times(algorithm);
    if(priv-&gt;buffer_modified_time != NULL)
    {
      equivalent = inf_adopted_algorithm_buffer_states_equivalent(
        algorithm,
        priv-&gt;buffer_modified_time,
        priv-&gt;current
      );
      if(equivalent == TRUE)
      {
        inf_buffer_set_modified(priv-&gt;buffer, FALSE);
        inf_adopted_state_vector_free(priv-&gt;buffer_modified_time);
        priv-&gt;buffer_modified_time =
          inf_adopted_state_vector_copy(priv-&gt;current);
      }
      else
      {
      }
    }
    else
    {
      g_assert(inf_buffer_get_modified(priv-&gt;buffer) == TRUE);
    }
  }
}
static InfAdoptedRequest*
inf_adopted_algorithm_apply_request(InfAdoptedAlgorithm* algorithm,
                                    InfAdoptedUser* user,
                                    InfAdoptedRequest* request,
                                    InfAdoptedRequest* translated,
                                    GError** error)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedOperation* reversible_operation;
  InfAdoptedRequest* log_request;
  GError* local_error;
  gchar* request_str;
  gchar* translated_str;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  local_error = NULL;
  log_request = NULL;
  if(inf_adopted_request_get_request_type(request) == INF_ADOPTED_REQUEST_DO)
  {
    reversible_operation = inf_adopted_operation_apply_transformed(
      inf_adopted_request_get_operation(request),
      inf_adopted_request_get_operation(translated),
      user,
      priv-&gt;buffer,
      &amp;local_error
    );
    if(local_error == NULL)
    {
      g_assert(reversible_operation != NULL);
      if(reversible_operation == inf_adopted_request_get_operation(request))
      {
        log_request = request;
        g_object_ref(log_request);
        g_object_unref(reversible_operation);
      }
      else
      {
        log_request = inf_adopted_request_new_do(
          inf_adopted_request_get_vector(request),
          inf_adopted_request_get_user_id(request),
          reversible_operation,
          inf_adopted_request_get_receive_time(request)
        );
        inf_adopted_request_set_execute_time(
          log_request,
          inf_adopted_request_get_execute_time(request)
        );
        g_object_unref(reversible_operation);
      }
    }
  }
  else
  {
    inf_adopted_operation_apply(
      inf_adopted_request_get_operation(translated),
      user,
      priv-&gt;buffer,
      &amp;local_error
    );
    if(local_error == NULL)
    {
      log_request = request;
      g_object_ref(log_request);
    }
  }
  if(local_error != NULL)
  {
    g_assert(log_request == NULL);
    request_str = inf_adopted_state_vector_to_string(
      inf_adopted_request_get_vector(request)
    );
    translated_str = inf_adopted_state_vector_to_string(
      inf_adopted_request_get_vector(translated)
    );
    g_propagate_prefixed_error(
      error,
      local_error,
      _("Failed to apply request \"%s\" from user \"%s\" at state \"%s\": "),
      request_str,
      inf_user_get_name(INF_USER(user)),
      translated_str
    );
    g_free(request_str);
    g_free(translated_str);
    return NULL;
  }
  g_assert(log_request != NULL);
  return log_request;
}
static void
inf_adopted_algorithm_init(InfAdoptedAlgorithm* algorithm)
{
  InfAdoptedAlgorithmPrivate* priv;
  algorithm-&gt;priv = INF_ADOPTED_ALGORITHM_GET_PRIVATE(algorithm);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  priv-&gt;max_total_log_size = 2048;
  priv-&gt;execute_request = NULL;
  priv-&gt;current = inf_adopted_state_vector_new();
  priv-&gt;buffer_modified_time = NULL;
  priv-&gt;user_table = NULL;
  priv-&gt;buffer = NULL;
  priv-&gt;users_begin = NULL;
  priv-&gt;users_end = NULL;
  priv-&gt;local_users = NULL;
}
static void
inf_adopted_algorithm_constructed_foreach_user_func(InfUser* user,
                                                    gpointer user_data)
{
  InfAdoptedAlgorithm* algorithm;
  algorithm = INF_ADOPTED_ALGORITHM(user_data);
  g_assert(INF_ADOPTED_IS_USER(user));
  inf_adopted_algorithm_add_user(algorithm, INF_ADOPTED_USER(user));
}
static void
inf_adopted_algorithm_constructed_foreach_local_user_func(InfUser* user,
                                                          gpointer user_data)
{
  InfAdoptedAlgorithm* algorithm;
  algorithm = INF_ADOPTED_ALGORITHM(user_data);
  g_assert(INF_ADOPTED_IS_USER(user));
  inf_adopted_algorithm_add_local_user(algorithm, INF_ADOPTED_USER(user));
}
static void
inf_adopted_algorithm_constructed(GObject* object)
{
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedAlgorithmPrivate* priv;
  gboolean modified;
  G_OBJECT_CLASS(inf_adopted_algorithm_parent_class)-&gt;constructed(object);
  algorithm = INF_ADOPTED_ALGORITHM(object);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  inf_user_table_foreach_user(
    priv-&gt;user_table,
    inf_adopted_algorithm_constructed_foreach_user_func,
    algorithm
  );
  inf_user_table_foreach_local_user(
    priv-&gt;user_table,
    inf_adopted_algorithm_constructed_foreach_local_user_func,
    algorithm
  );
  g_object_get(G_OBJECT(priv-&gt;buffer), "modified", &amp;modified, NULL);
  if(modified == FALSE)
    priv-&gt;buffer_modified_time = inf_adopted_state_vector_copy(priv-&gt;current);
}
static void
inf_adopted_algorithm_dispose(GObject* object)
{
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedAlgorithmPrivate* priv;
  GList* item;
  algorithm = INF_ADOPTED_ALGORITHM(object);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  while(priv-&gt;local_users != NULL)
    inf_adopted_algorithm_local_user_free(algorithm, priv-&gt;local_users-&gt;data);
  g_free(priv-&gt;users_begin);
  if(priv-&gt;buffer != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
      algorithm
    );
    g_object_unref(priv-&gt;buffer);
    priv-&gt;buffer = NULL;
  }
  if(priv-&gt;buffer_modified_time != NULL)
    inf_adopted_state_vector_free(priv-&gt;buffer_modified_time);
  if(priv-&gt;user_table != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_adopted_algorithm_add_user_cb),
      algorithm
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_adopted_algorithm_add_local_user_cb),
      algorithm
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_adopted_algorithm_remove_local_user_cb),
      algorithm
    );
    g_object_unref(priv-&gt;user_table);
    priv-&gt;user_table = NULL;
  }
  G_OBJECT_CLASS(inf_adopted_algorithm_parent_class)-&gt;dispose(object);
}
static void
inf_adopted_algorithm_finalize(GObject* object)
{
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedAlgorithmPrivate* priv;
  algorithm = INF_ADOPTED_ALGORITHM(object);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  inf_adopted_state_vector_free(priv-&gt;current);
  G_OBJECT_CLASS(inf_adopted_algorithm_parent_class)-&gt;finalize(object);
}
static void
inf_adopted_algorithm_set_property(GObject* object,
                                   guint prop_id,
                                   const GValue* value,
                                   GParamSpec* pspec)
{
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedAlgorithmPrivate* priv;
  algorithm = INF_ADOPTED_ALGORITHM(object);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  switch(prop_id)
  {
  case PROP_USER_TABLE:
    g_assert(priv-&gt;user_table == NULL);     priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
    g_signal_connect(
      G_OBJECT(priv-&gt;user_table),
      "add-user",
      G_CALLBACK(inf_adopted_algorithm_add_user_cb),
      algorithm
    );
    g_signal_connect(
      G_OBJECT(priv-&gt;user_table),
      "add-local-user",
      G_CALLBACK(inf_adopted_algorithm_add_local_user_cb),
      algorithm
    );
    g_signal_connect(
      G_OBJECT(priv-&gt;user_table),
      "remove-local-user",
      G_CALLBACK(inf_adopted_algorithm_remove_local_user_cb),
      algorithm
    );
    break;
  case PROP_BUFFER:
    g_assert(priv-&gt;buffer == NULL);     g_assert(priv-&gt;buffer_modified_time == NULL);
    priv-&gt;buffer = INF_BUFFER(g_value_dup_object(value));
    g_signal_connect(
      G_OBJECT(priv-&gt;buffer),
      "notify::modified",
      G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
      algorithm
    );
    break;
  case PROP_MAX_TOTAL_LOG_SIZE:
    priv-&gt;max_total_log_size = g_value_get_uint(value);
    break;
<a name="0"></a>  case PROP_CURRENT_STATE:
  case PROP_BUFFER_MODIFIED_STATE:
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_adopted_algorithm_get_property(GObject* object,
                                   guint prop_id,
                                   GValue* value,
                                   GParamSpec* pspec)
{
  InfAdoptedAlgorithm* log;
  InfAdoptedAlgorithmPrivate* priv;
  log = INF_ADOPTED_ALGORITHM(object);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(log);
  switch(prop_id)
  {
  case PROP_USER_TABLE:
    g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
    break;
<a name="2"></a>  case PROP_BUFFER:
    g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
    break;</b></font>
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  case PROP_MAX_TOTAL_LOG_SIZE:
    g_value_set_uint(value, priv-&gt;max_total_log_size);
    break;
  case PROP_CURRENT_STATE:
    g_value_set_boxed(value, priv-&gt;current);
    break;
  case PROP_BUFFER_MODIFIED_STATE:
    g_value_set_boxed(value, priv-&gt;buffer_modified_time);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_adopted_algorithm_can_undo_changed(InfAdoptedAlgorithm* algorithm,
                                       InfAdoptedUser* user,
                                       gboolean can_undo)
{
  InfAdoptedAlgorithmPrivate* priv;
  GSList* item;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);</b></font>
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
    if( ((InfAdoptedAlgorithmLocalUser*)item-&gt;data)-&gt;user == user)
      ((InfAdoptedAlgorithmLocalUser*)item-&gt;data)-&gt;can_undo = can_undo;
}
static void
inf_adopted_algorithm_can_redo_changed(InfAdoptedAlgorithm* algorithm,
                                       InfAdoptedUser* user,
                                       gboolean can_redo)
{
  InfAdoptedAlgorithmPrivate* priv;
  GSList* item;
<a name="1"></a>  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
    if( ((InfAdoptedAlgorithmLocalUser*)item-&gt;data)-&gt;user == user)
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      ((InfAdoptedAlgorithmLocalUser*)item-&gt;data)-&gt;can_redo = can_redo;
}
static void
inf_adopted_algorithm_class_init(InfAdoptedAlgorithmClass* algorithm_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(algorithm_class);
  object_class-&gt;constructed = inf_adopted_algorithm_constructed;
  object_class-&gt;dispose = inf_adopted_algorithm_dispose;
  object_class-&gt;finalize = inf_adopted_algorithm_finalize;
  object_class-&gt;set_property = inf_adopted_algorithm_set_property;
  object_class-&gt;get_property = inf_adopted_algorithm_get_property;
  algorithm_class-&gt;can_undo_changed = inf_adopted_algorithm_can_undo_changed;
  algorithm_class-&gt;can_redo_changed = inf_adopted_algorithm_can_redo_changed;
  algorithm_class-&gt;begin_execute_request = NULL;</b></font>
  algorithm_class-&gt;end_execute_request = NULL;
  g_object_class_install_property(
    object_class,
    PROP_USER_TABLE,
    g_param_spec_object(
      "user-table",
      "User table",
      "The user table",
      INF_TYPE_USER_TABLE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_BUFFER,
    g_param_spec_object(
      "buffer",
      "Buffer",
      "The buffer to apply operations to",
      INF_TYPE_BUFFER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_MAX_TOTAL_LOG_SIZE,
    g_param_spec_uint(
      "max-total-log-size",
      "Maxmimum total log size",
      "The maximum number of requests to keep in all user's logs",
      0,
      G_MAXUINT,
      2048,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CURRENT_STATE,
    g_param_spec_boxed(
      "current-state",
      "Current state",
      "The state vector describing the current document state",
      INF_ADOPTED_TYPE_STATE_VECTOR,
      G_PARAM_READABLE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_BUFFER_MODIFIED_STATE,
    g_param_spec_boxed(
      "buffer-modified-state",
      "Buffer modified state",
      "The state in which the buffer is considered not being modified",
      INF_ADOPTED_TYPE_STATE_VECTOR,
      G_PARAM_READABLE
    )
  );
  algorithm_signals[CAN_UNDO_CHANGED] = g_signal_new(
    "can-undo-changed",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfAdoptedAlgorithmClass, can_undo_changed),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    INF_ADOPTED_TYPE_USER,
    G_TYPE_BOOLEAN
  );
  algorithm_signals[CAN_REDO_CHANGED] = g_signal_new(
    "can-redo-changed",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfAdoptedAlgorithmClass, can_redo_changed),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    INF_ADOPTED_TYPE_USER,
    G_TYPE_BOOLEAN
  );
  algorithm_signals[BEGIN_EXECUTE_REQUEST] = g_signal_new(
    "begin-execute-request",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfAdoptedAlgorithmClass, begin_execute_request),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    INF_ADOPTED_TYPE_USER,
    INF_ADOPTED_TYPE_REQUEST
  );
  algorithm_signals[END_EXECUTE_REQUEST] = g_signal_new(
    "end-execute-request",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfAdoptedAlgorithmClass, end_execute_request),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    4,
    INF_ADOPTED_TYPE_USER,
    INF_ADOPTED_TYPE_REQUEST,
    INF_ADOPTED_TYPE_REQUEST,
    G_TYPE_ERROR
  );
}
InfAdoptedAlgorithm*
inf_adopted_algorithm_new(InfUserTable* user_table,
                          InfBuffer* buffer)
{
  GObject* object;
  g_return_val_if_fail(INF_IS_BUFFER(buffer), NULL);
  object = g_object_new(
    INF_ADOPTED_TYPE_ALGORITHM,
    "user-table", user_table,
    "buffer", buffer,
    NULL
  );
  return INF_ADOPTED_ALGORITHM(object);
}
InfAdoptedAlgorithm*
inf_adopted_algorithm_new_full(InfUserTable* user_table,
                               InfBuffer* buffer,
                               guint max_total_log_size)
{
  GObject* object;
  g_return_val_if_fail(INF_IS_BUFFER(buffer), NULL);
  object = g_object_new(
    INF_ADOPTED_TYPE_ALGORITHM,
    "user-table", user_table,
    "buffer", buffer,
    "max-total-log-size", max_total_log_size,
    NULL
  );
  return INF_ADOPTED_ALGORITHM(object);
}
InfAdoptedStateVector*
inf_adopted_algorithm_get_current(InfAdoptedAlgorithm* algorithm)
{
  g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), NULL);
  return INF_ADOPTED_ALGORITHM_PRIVATE(algorithm)-&gt;current;
}
InfAdoptedRequest*
inf_adopted_algorithm_get_execute_request(InfAdoptedAlgorithm* algorithm)
{
  g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), NULL);
  return INF_ADOPTED_ALGORITHM_PRIVATE(algorithm)-&gt;execute_request;
}
InfAdoptedRequest*
inf_adopted_algorithm_generate_request(InfAdoptedAlgorithm* algorithm,
                                       InfAdoptedRequestType type,
                                       InfAdoptedUser* user,
                                       InfAdoptedOperation* operation)
{
  InfAdoptedAlgorithmPrivate* priv;
  g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), NULL);
  g_return_val_if_fail(INF_ADOPTED_IS_USER(user), NULL);
  g_return_val_if_fail(
    type != INF_ADOPTED_REQUEST_DO || INF_ADOPTED_IS_OPERATION(operation),
    NULL
  );
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  switch(type)
  {
  case INF_ADOPTED_REQUEST_DO:
    return inf_adopted_request_new_do(
      priv-&gt;current,
      inf_user_get_id(INF_USER(user)),
      operation,
      g_get_real_time()
    );
  case INF_ADOPTED_REQUEST_UNDO:
    return inf_adopted_request_new_undo(
      priv-&gt;current,
      inf_user_get_id(INF_USER(user)),
      g_get_real_time()
    );
  case INF_ADOPTED_REQUEST_REDO:
    return inf_adopted_request_new_redo(
      priv-&gt;current,
      inf_user_get_id(INF_USER(user)),
      g_get_real_time()
    );
  default:
    g_return_val_if_reached(NULL);
    return NULL;
  }
}
InfAdoptedRequest*
inf_adopted_algorithm_translate_request(InfAdoptedAlgorithm* algorithm,
                                        InfAdoptedRequest* request,
                                        InfAdoptedStateVector* to)
{
  InfAdoptedAlgorithmPrivate* priv;
  guint user_id;
  InfUser* plain_user;
  InfAdoptedUser* user;
  InfAdoptedRequestLog* log;
  InfAdoptedRequest* result;
  g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), NULL);
  g_return_val_if_fail(INF_ADOPTED_IS_REQUEST(request), NULL);
  g_return_val_if_fail(to != NULL, NULL);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  user_id = inf_adopted_request_get_user_id(request);
  plain_user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id);
  g_return_val_if_fail(INF_ADOPTED_IS_USER(plain_user), NULL);
  user = INF_ADOPTED_USER(plain_user);
  log = inf_adopted_user_get_request_log(user);
  g_return_val_if_fail(
    inf_adopted_state_vector_causally_before(to, priv-&gt;current),
    NULL
  );
  g_return_val_if_fail(
    inf_adopted_state_vector_causally_before(
      inf_adopted_request_get_vector(
        inf_adopted_request_log_original_request(log, request)
      ),
      to
    ),
    NULL
  );
  if(inf_adopted_request_affects_buffer(request))
  {
    result = inf_adopted_request_log_lookup_cached_request(log, to);
    if(result != NULL)
    {
      g_object_ref(result);
      return result;
    }
  }
  result = inf_adopted_algorithm_translate_request_forward(
    algorithm,
    request,
    to
  );
  g_assert(
    inf_adopted_state_vector_compare(
      inf_adopted_request_get_vector(result),
      to
    ) == 0
  );
  if(inf_adopted_algorithm_can_cache(result))
    inf_adopted_request_log_add_cached_request(log, result);
  return result;
}
gboolean
inf_adopted_algorithm_execute_request(InfAdoptedAlgorithm* algorithm,
                                      InfAdoptedRequest* request,
                                      gboolean apply,
                                      GError** error)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedUser* user;
  InfAdoptedRequestLog* log;
  InfAdoptedRequest* original;
  InfAdoptedRequest* translated;
  InfAdoptedRequest* log_request;
  GError* local_error;
  gchar* request_str;
  g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), FALSE);
  g_return_val_if_fail(INF_ADOPTED_IS_REQUEST(request), FALSE);
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  g_return_val_if_fail(
    inf_adopted_state_vector_causally_before(
      inf_adopted_request_get_vector(request),
      priv-&gt;current
    ),
    FALSE
  );
  g_return_val_if_fail(
    apply == TRUE || (
      inf_adopted_state_vector_compare(
        inf_adopted_request_get_vector(request),
        priv-&gt;current
      ) == 0 &amp;&amp; 
      inf_adopted_request_get_request_type(request) == INF_ADOPTED_REQUEST_DO
    ),
    FALSE
  );
  user = INF_ADOPTED_USER(
    inf_user_table_lookup_user_by_id(
      priv-&gt;user_table,
      inf_adopted_request_get_user_id(request)
    )
  );
  g_return_val_if_fail(user != NULL, FALSE);
  g_return_val_if_fail(priv-&gt;execute_request == NULL, FALSE);
  priv-&gt;execute_request = request;
  inf_adopted_request_set_execute_time(request, g_get_real_time());
  g_signal_emit(
    G_OBJECT(algorithm),
    algorithm_signals[BEGIN_EXECUTE_REQUEST],
    0,
    user,
    request
  );
  local_error = NULL;
  switch(inf_adopted_request_get_request_type(request))
  {
  case INF_ADOPTED_REQUEST_DO:
    break;
  case INF_ADOPTED_REQUEST_UNDO:
    if(!inf_adopted_algorithm_can_undo(algorithm, user))
    {
      request_str = inf_adopted_state_vector_to_string(
        inf_adopted_request_get_vector(request)
      );
      g_set_error(
        &amp;local_error,
        g_quark_from_static_string("INF_ADOPTED_ALGORITHM_ERROR"),
        INF_ADOPTED_ALGORITHM_ERROR_NO_UNDO,
        _("The request \"%s\" from user \"%s\" is an UNDO request but there "
          "is no request to be undone."),
        request_str,
        inf_user_get_name(INF_USER(user))
      );
      g_free(request_str);
    }
    break;
  case INF_ADOPTED_REQUEST_REDO:
    if(!inf_adopted_algorithm_can_redo(algorithm, user))
    {
      request_str = inf_adopted_state_vector_to_string(
        inf_adopted_request_get_vector(request)
      );
      g_set_error(
        &amp;local_error,
        g_quark_from_static_string("INF_ADOPTED_ALGORITHM_ERROR"),
        INF_ADOPTED_ALGORITHM_ERROR_NO_REDO,
        _("The request \"%s\" from user \"%s\" is a REDO request but there "
          "is no request to be redone."),
        request_str,
        inf_user_get_name(INF_USER(user))
      );
      g_free(request_str);
    }
    break;
  default:
    g_assert_not_reached();
    break;
  }
  if(local_error != NULL)
  {
    g_signal_emit(
      G_OBJECT(algorithm),
      algorithm_signals[END_EXECUTE_REQUEST],
      0,
      user,
      request,
      NULL,
      local_error
    );
    priv-&gt;execute_request = NULL;
    g_propagate_error(error, local_error);
    return FALSE;
  }
  log = inf_adopted_user_get_request_log(user);
  original = inf_adopted_request_log_original_request(log, request);
  g_assert(
    inf_adopted_request_get_request_type(original) == INF_ADOPTED_REQUEST_DO
  );
  translated = inf_adopted_algorithm_translate_request(
    algorithm,
    original,
    priv-&gt;current
  );
  g_assert(
    inf_adopted_request_get_request_type(translated) == INF_ADOPTED_REQUEST_DO
  );
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
    algorithm
  );
  if(apply == TRUE)
  {
    log_request = inf_adopted_algorithm_apply_request(
      algorithm,
      user,
      request,
      translated,
      &amp;local_error
    );
    if(local_error != NULL)
    {
      inf_signal_handlers_unblock_by_func(
        G_OBJECT(priv-&gt;buffer),
        G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
        algorithm
      );
      g_signal_emit(
        G_OBJECT(algorithm),
        algorithm_signals[END_EXECUTE_REQUEST],
        0,
        user,
        request,
        translated,
        local_error
      );
      priv-&gt;execute_request = NULL;
      g_object_unref(translated);
      g_propagate_error(error, local_error);
      return FALSE;
    }
  }
  else
  {
    log_request = request;
    g_object_ref(request);
  }
  inf_adopted_algorithm_log_request(
    algorithm,
    user,
    log_request
  );
  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_adopted_algorithm_buffer_notify_modified_cb),
    algorithm
  );
  inf_adopted_algorithm_update_undo_redo(algorithm);
  g_signal_emit(
    G_OBJECT(algorithm),
    algorithm_signals[END_EXECUTE_REQUEST],
    0,
    user,
    log_request,
    translated,
    NULL
  );
  g_object_unref(translated);
  g_object_unref(log_request);
  priv-&gt;execute_request = NULL;
  return TRUE;
}
void
inf_adopted_algorithm_cleanup(InfAdoptedAlgorithm* algorithm)
{
  InfAdoptedAlgorithmPrivate* priv;
  InfAdoptedStateVector* temp;
  InfAdoptedStateVector* lcp;
  InfAdoptedUser** user;
  InfAdoptedRequestLog* log;
  InfAdoptedRequest* req;
  InfAdoptedStateVector* req_vec;
  InfAdoptedStateVector* low_vec;
  gboolean req_before_lcp;
  guint n;
  guint id;
  guint vdiff;
  priv = INF_ADOPTED_ALGORITHM_PRIVATE(algorithm);
  g_assert(priv-&gt;users_begin != priv-&gt;users_end);
  if(priv-&gt;max_total_log_size == G_MAXUINT)
    return;
  lcp = inf_adopted_state_vector_copy(priv-&gt;current);
  for(user = priv-&gt;users_begin; user != priv-&gt;users_end; ++ user)
  {
    if(inf_user_get_status(INF_USER(*user)) != INF_USER_UNAVAILABLE)
    {
      temp = inf_adopted_algorithm_least_common_predecessor(
        algorithm,
        lcp,
        inf_adopted_user_get_vector(*user)
      );
      inf_adopted_state_vector_free(lcp);
      lcp = temp;
    }
  }
  for(user = priv-&gt;users_begin; user != priv-&gt;users_end; ++ user)
  {
    id = inf_user_get_id(INF_USER(*user));
    log = inf_adopted_user_get_request_log(*user);
    n = inf_adopted_request_log_get_begin(log);
    while(n &lt; inf_adopted_request_log_get_end(log))
    {
      req = inf_adopted_request_log_upper_related(log, n);
      req_vec = inf_adopted_request_get_vector(req);
      req_before_lcp = inf_adopted_state_vector_causally_before_inc(
        req_vec,
        lcp,
        id
      );
      if(!req_before_lcp)
        break;
      low_vec = inf_adopted_request_get_vector(
        inf_adopted_request_log_get_request(log, n)
      );
      vdiff = inf_adopted_state_vector_vdiff(low_vec, lcp);
      if(vdiff &lt; priv-&gt;max_total_log_size)
        break;
      n = inf_adopted_state_vector_get(req_vec, id) + 1;
    }
    inf_adopted_request_log_remove_requests(log, n);
  }
  inf_adopted_state_vector_free(lcp);
}
gboolean
inf_adopted_algorithm_can_undo(InfAdoptedAlgorithm* algorithm,
                               InfAdoptedUser* user)
{
  InfAdoptedAlgorithmLocalUser* local;
  InfAdoptedRequestLog* log;
  g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), FALSE);
  g_return_val_if_fail(INF_ADOPTED_IS_USER(user), FALSE);
  local = inf_adopted_algorithm_find_local_user(algorithm, user);
  if(local != NULL)
  {
    return local-&gt;can_undo;
  }
  else
  {
    log = inf_adopted_user_get_request_log(user);
    return inf_adopted_algorithm_can_undo_redo(
      algorithm,
      user,
      inf_adopted_request_log_next_undo(log)
    );
  }
}
gboolean
inf_adopted_algorithm_can_redo(InfAdoptedAlgorithm* algorithm,
                               InfAdoptedUser* user)
{
  InfAdoptedAlgorithmLocalUser* local;
  InfAdoptedRequestLog* log;
  g_return_val_if_fail(INF_ADOPTED_IS_ALGORITHM(algorithm), FALSE);
  g_return_val_if_fail(INF_ADOPTED_IS_USER(user), FALSE);
  local = inf_adopted_algorithm_find_local_user(algorithm, user);
  if(local != NULL)
  {
    return local-&gt;can_redo;
  }
  else
  {
    log = inf_adopted_user_get_request_log(user);
    return inf_adopted_algorithm_can_undo_redo(
      algorithm,
      user,
      inf_adopted_request_log_next_redo(log)
    );
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
