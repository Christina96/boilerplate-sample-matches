
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 40, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_types.h</h3>
            <pre><code>1  #ifndef SPH_TYPES_H__
2  #define SPH_TYPES_H__
3  #include &lt;limits.h&gt;
4  #if CHAR_BIT != 8
5  #error This code requires 8-bit bytes
6  #endif
7  #ifdef DOXYGEN_IGNORE
8  typedef __arch_dependant__ sph_u32;
9  typedef __arch_dependant__ sph_s32;
10  typedef __arch_dependant__ sph_u64;
11  typedef __arch_dependant__ sph_s64;
12  #define SPH_C32(x)
13  #define SPH_T32(x)
14  #define SPH_ROTL32(x, n)
15  #define SPH_ROTR32(x, n)
16  #define SPH_64
17  #define SPH_64_TRUE
18  #define SPH_C64(x)
19  #define SPH_T64(x)
20  #define SPH_ROTL64(x, n)
21  #define SPH_ROTR64(x, n)
22  #define SPH_INLINE
23  #define SPH_LITTLE_ENDIAN
24  #define SPH_BIG_ENDIAN
25  #define SPH_LITTLE_FAST
26  #define SPH_BIG_FAST
27  #define SPH_UPTR
28  #define SPH_UNALIGNED
29  static inline sph_u32 sph_bswap32(sph_u32 x);
30  static inline sph_u64 sph_bswap64(sph_u64 x);
31  static inline unsigned sph_dec16le(const void *src);
32  static inline void sph_enc16le(void *dst, unsigned val);
33  static inline unsigned sph_dec16be(const void *src);
34  static inline void sph_enc16be(void *dst, unsigned val);
35  static inline sph_u32 sph_dec32le(const void *src);
36  static inline sph_u32 sph_dec32le_aligned(const void *src);
37  static inline void sph_enc32le(void *dst, sph_u32 val);
38  static inline void sph_enc32le_aligned(void *dst, sph_u32 val);
39  static inline sph_u32 sph_dec32be(const void *src);
40  static inline sph_u32 sph_dec32be_aligned(const void *src);
41  static inline void sph_enc32be(void *dst, sph_u32 val);
42  static inline void sph_enc32be_aligned(void *dst, sph_u32 val);
43  static inline sph_u64 sph_dec64le(const void *src);
44  static inline sph_u64 sph_dec64le_aligned(const void *src);
45  static inline void sph_enc64le(void *dst, sph_u64 val);
46  static inline void sph_enc64le_aligned(void *dst, sph_u64 val);
47  static inline sph_u64 sph_dec64be(const void *src);
48  static inline sph_u64 sph_dec64be_aligned(const void *src);
49  static inline void sph_enc64be(void *dst, sph_u64 val);
50  static inline void sph_enc64be_aligned(void *dst, sph_u64 val);
51  #endif
52  #ifndef DOXYGEN_IGNORE
53  #undef SPH_64
54  #undef SPH_64_TRUE
55  #if defined __STDC__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L
56  #include &lt;stdint.h&gt;
57  #ifdef UINT32_MAX
58  typedef uint32_t sph_u32;
59  typedef int32_t sph_s32;
60  #else
61  typedef uint_fast32_t sph_u32;
62  typedef int_fast32_t sph_s32;
63  #endif
64  #if !SPH_NO_64
65  #ifdef UINT64_MAX
66  typedef uint64_t sph_u64;
67  typedef int64_t sph_s64;
68  #else
69  typedef uint_fast64_t sph_u64;
70  typedef int_fast64_t sph_s64;
71  #endif
72  #endif
73  #define SPH_C32(x)    ((sph_u32)(x))
74  #if !SPH_NO_64
75  #define SPH_C64(x)    ((sph_u64)(x))
76  #define SPH_64  1
77  #endif
78  #else
79  #if ((UINT_MAX &gt;&gt; 11) &gt;&gt; 11) &gt;= 0x3FF
80  typedef unsigned int sph_u32;
81  typedef int sph_s32;
82  #define SPH_C32(x)    ((sph_u32)(x ## U))
83  #else
84  typedef unsigned long sph_u32;
85  typedef long sph_s32;
86  #define SPH_C32(x)    ((sph_u32)(x ## UL))
87  #endif
88  #if !SPH_NO_64
89  #if ((ULONG_MAX &gt;&gt; 31) &gt;&gt; 31) &gt;= 3
90  typedef unsigned long sph_u64;
91  typedef long sph_s64;
92  #define SPH_C64(x)    ((sph_u64)(x ## UL))
93  #define SPH_64  1
94  #elif ((ULLONG_MAX &gt;&gt; 31) &gt;&gt; 31) &gt;= 3 || defined __GNUC__
95  typedef unsigned long long sph_u64;
96  typedef long long sph_s64;
97  #define SPH_C64(x)    ((sph_u64)(x ## ULL))
98  #define SPH_64  1
99  #else
100  #endif
101  #endif
102  #endif
103  #if SPH_64 &amp;&amp; (((ULONG_MAX &gt;&gt; 31) &gt;&gt; 31) &gt;= 3 || defined _M_X64)
104  #define SPH_64_TRUE   1
105  #endif
106  #define SPH_T32(x)    ((x) &amp; SPH_C32(0xFFFFFFFF))
107  #define SPH_ROTL32(x, n)   SPH_T32(((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32 - (n))))
108  #define SPH_ROTR32(x, n)   SPH_ROTL32(x, (32 - (n)))
109  #if SPH_64
110  #define SPH_T64(x)    ((x) &amp; SPH_C64(0xFFFFFFFFFFFFFFFF))
111  #define SPH_ROTL64(x, n)   SPH_T64(((x) &lt;&lt; (n)) | ((x) &gt;&gt; (64 - (n))))
112  #define SPH_ROTR64(x, n)   SPH_ROTL64(x, (64 - (n)))
113  #endif
114  #ifndef DOXYGEN_IGNORE
115  #if (defined __STDC__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L) || defined __GNUC__
116  #define SPH_INLINE inline
117  #elif defined _MSC_VER
118  #define SPH_INLINE __inline
119  #else
120  #define SPH_INLINE
121  #endif
122  #endif
123  #if defined __i386__ || defined _M_IX86
124  #define SPH_DETECT_UNALIGNED         1
125  #define SPH_DETECT_LITTLE_ENDIAN     1
126  #define SPH_DETECT_UPTR              sph_u32
127  #ifdef __GNUC__
128  #define SPH_DETECT_I386_GCC          1
129  #endif
130  #ifdef _MSC_VER
131  #define SPH_DETECT_I386_MSVC         1
132  #endif
133  #elif defined __x86_64 || defined _M_X64
134  #define SPH_DETECT_UNALIGNED         1
135  #define SPH_DETECT_LITTLE_ENDIAN     1
136  #define SPH_DETECT_UPTR              sph_u64
137  #ifdef __GNUC__
138  #define SPH_DETECT_AMD64_GCC         1
139  #endif
140  #ifdef _MSC_VER
141  #define SPH_DETECT_AMD64_MSVC        1
142  #endif
143  #elif ((defined __sparc__ || defined __sparc) &amp;&amp; defined __arch64__) \
144  	|| defined __sparcv9
145  #define SPH_DETECT_BIG_ENDIAN        1
146  #define SPH_DETECT_UPTR              sph_u64
147  #ifdef __GNUC__
148  #define SPH_DETECT_SPARCV9_GCC_64    1
149  #define SPH_DETECT_LITTLE_FAST       1
150  #endif
151  #elif (defined __sparc__ || defined __sparc) \
152  	&amp;&amp; !(defined __sparcv9 || defined __arch64__)
153  #define SPH_DETECT_BIG_ENDIAN        1
154  #define SPH_DETECT_UPTR              sph_u32
155  #if defined __GNUC__ &amp;&amp; defined __sparc_v9__
156  #define SPH_DETECT_SPARCV9_GCC_32    1
157  #define SPH_DETECT_LITTLE_FAST       1
158  #endif
159  #elif defined __arm__ &amp;&amp; __ARMEL__
160  #define SPH_DETECT_LITTLE_ENDIAN     1
161  #elif MIPSEL || _MIPSEL || __MIPSEL || __MIPSEL__
162  #define SPH_DETECT_LITTLE_ENDIAN     1
163  #elif MIPSEB || _MIPSEB || __MIPSEB || __MIPSEB__
164  #define SPH_DETECT_BIG_ENDIAN        1
165  #elif defined __powerpc__ || defined __POWERPC__ || defined __ppc__ \
166  	|| defined _ARCH_PPC
167  #if defined __GNUC__
168  #if SPH_64_TRUE
169  #define SPH_DETECT_PPC64_GCC         1
170  #else
171  #define SPH_DETECT_PPC32_GCC         1
172  #endif
173  #endif
174  #if defined __BIG_ENDIAN__ || defined _BIG_ENDIAN
175  #define SPH_DETECT_BIG_ENDIAN        1
176  #elif defined __LITTLE_ENDIAN__ || defined _LITTLE_ENDIAN
177  #define SPH_DETECT_LITTLE_ENDIAN     1
178  #endif
179  #elif defined __ia64 || defined __ia64__ \
180  	|| defined __itanium__ || defined _M_IA64
181  #if defined __BIG_ENDIAN__ || defined _BIG_ENDIAN
182  #define SPH_DETECT_BIG_ENDIAN        1
183  #else
184  #define SPH_DETECT_LITTLE_ENDIAN     1
185  #endif
186  #if defined __LP64__ || defined _LP64
187  #define SPH_DETECT_UPTR              sph_u64
188  #else
189  #define SPH_DETECT_UPTR              sph_u32
190  #endif
191  #endif
192  #if defined SPH_DETECT_SPARCV9_GCC_32 || defined SPH_DETECT_SPARCV9_GCC_64
193  #define SPH_DETECT_SPARCV9_GCC       1
194  #endif
195  #if defined SPH_DETECT_UNALIGNED &amp;&amp; !defined SPH_UNALIGNED
196  #define SPH_UNALIGNED         SPH_DETECT_UNALIGNED
197  #endif
198  #if defined SPH_DETECT_UPTR &amp;&amp; !defined SPH_UPTR
199  #define SPH_UPTR              SPH_DETECT_UPTR
200  #endif
201  #if defined SPH_DETECT_LITTLE_ENDIAN &amp;&amp; !defined SPH_LITTLE_ENDIAN
202  #define SPH_LITTLE_ENDIAN     SPH_DETECT_LITTLE_ENDIAN
203  #endif
204  #if defined SPH_DETECT_BIG_ENDIAN &amp;&amp; !defined SPH_BIG_ENDIAN
205  #define SPH_BIG_ENDIAN        SPH_DETECT_BIG_ENDIAN
206  #endif
207  #if defined SPH_DETECT_LITTLE_FAST &amp;&amp; !defined SPH_LITTLE_FAST
208  #define SPH_LITTLE_FAST       SPH_DETECT_LITTLE_FAST
209  #endif
210  #if defined SPH_DETECT_BIG_FAST &amp;&amp; !defined SPH_BIG_FAST
211  #define SPH_BIG_FAST    SPH_DETECT_BIG_FAST
212  #endif
213  #if defined SPH_DETECT_SPARCV9_GCC_32 &amp;&amp; !defined SPH_SPARCV9_GCC_32
214  #define SPH_SPARCV9_GCC_32    SPH_DETECT_SPARCV9_GCC_32
215  #endif
216  #if defined SPH_DETECT_SPARCV9_GCC_64 &amp;&amp; !defined SPH_SPARCV9_GCC_64
217  #define SPH_SPARCV9_GCC_64    SPH_DETECT_SPARCV9_GCC_64
218  #endif
219  #if defined SPH_DETECT_SPARCV9_GCC &amp;&amp; !defined SPH_SPARCV9_GCC
220  #define SPH_SPARCV9_GCC       SPH_DETECT_SPARCV9_GCC
221  #endif
222  #if defined SPH_DETECT_I386_GCC &amp;&amp; !defined SPH_I386_GCC
223  #define SPH_I386_GCC          SPH_DETECT_I386_GCC
224  #endif
225  #if defined SPH_DETECT_I386_MSVC &amp;&amp; !defined SPH_I386_MSVC
226  #define SPH_I386_MSVC         SPH_DETECT_I386_MSVC
227  #endif
228  #if defined SPH_DETECT_AMD64_GCC &amp;&amp; !defined SPH_AMD64_GCC
229  #define SPH_AMD64_GCC         SPH_DETECT_AMD64_GCC
230  #endif
231  #if defined SPH_DETECT_AMD64_MSVC &amp;&amp; !defined SPH_AMD64_MSVC
232  #define SPH_AMD64_MSVC        SPH_DETECT_AMD64_MSVC
233  #endif
234  #if defined SPH_DETECT_PPC32_GCC &amp;&amp; !defined SPH_PPC32_GCC
235  #define SPH_PPC32_GCC         SPH_DETECT_PPC32_GCC
236  #endif
237  #if defined SPH_DETECT_PPC64_GCC &amp;&amp; !defined SPH_PPC64_GCC
238  #define SPH_PPC64_GCC         SPH_DETECT_PPC64_GCC
239  #endif
240  #if SPH_LITTLE_ENDIAN &amp;&amp; !defined SPH_LITTLE_FAST
241  #define SPH_LITTLE_FAST              1
242  #endif
243  #if SPH_BIG_ENDIAN &amp;&amp; !defined SPH_BIG_FAST
244  #define SPH_BIG_FAST                 1
245  #endif
246  #if defined SPH_UPTR &amp;&amp; !(SPH_LITTLE_ENDIAN || SPH_BIG_ENDIAN)
247  #error SPH_UPTR defined, but endianness is not known.
248  #endif
249  #if SPH_I386_GCC &amp;&amp; !SPH_NO_ASM
250  static SPH_INLINE sph_u32
251  sph_bswap32(sph_u32 x)
252  {
253  	__asm__ __volatile__ (&quot;bswapl %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
254  	return x;
255  }
256  #if SPH_64
257  static SPH_INLINE sph_u64
258  sph_bswap64(sph_u64 x)
259  {
260  	return ((sph_u64)sph_bswap32((sph_u32)x) &lt;&lt; 32)
261  		| (sph_u64)sph_bswap32((sph_u32)(x &gt;&gt; 32));
262  }
263  #endif
264  #elif SPH_AMD64_GCC &amp;&amp; !SPH_NO_ASM
265  static SPH_INLINE sph_u32
266  sph_bswap32(sph_u32 x)
267  {
268  	__asm__ __volatile__ (&quot;bswapl %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
269  	return x;
270  }
271  #if SPH_64
272  static SPH_INLINE sph_u64
273  sph_bswap64(sph_u64 x)
274  {
275  	__asm__ __volatile__ (&quot;bswapq %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
276  	return x;
277  }
278  #endif
279  #else
280  static SPH_INLINE sph_u32
281  sph_bswap32(sph_u32 x)
282  {
283  	x = SPH_T32((x &lt;&lt; 16) | (x &gt;&gt; 16));
284  	x = ((x &amp; SPH_C32(0xFF00FF00)) &gt;&gt; 8)
285  		| ((x &amp; SPH_C32(0x00FF00FF)) &lt;&lt; 8);
286  	return x;
287  }
288  #if SPH_64
289  static SPH_INLINE sph_u64
290  sph_bswap64(sph_u64 x)
291  {
292  	x = SPH_T64((x &lt;&lt; 32) | (x &gt;&gt; 32));
293  	x = ((x &amp; SPH_C64(0xFFFF0000FFFF0000)) &gt;&gt; 16)
294  		| ((x &amp; SPH_C64(0x0000FFFF0000FFFF)) &lt;&lt; 16);
295  	x = ((x &amp; SPH_C64(0xFF00FF00FF00FF00)) &gt;&gt; 8)
296  		| ((x &amp; SPH_C64(0x00FF00FF00FF00FF)) &lt;&lt; 8);
297  	return x;
298  }
299  #endif
300  #endif
301  #if SPH_SPARCV9_GCC &amp;&amp; !SPH_NO_ASM
302  #define SPH_SPARCV9_SET_ASI   \
303  	sph_u32 sph_sparcv9_asi; \
304  	__asm__ __volatile__ ( \
305  		&quot;rd %%asi,%0\n\twr %%g0,0x88,%%asi&quot; : &quot;=r&quot; (sph_sparcv9_asi));
306  #define SPH_SPARCV9_RESET_ASI  \
307  	__asm__ __volatile__ (&quot;wr %%g0,%0,%%asi&quot; : : &quot;r&quot; (sph_sparcv9_asi));
308  #define SPH_SPARCV9_DEC32LE(base, idx)   ({ \
309  		sph_u32 sph_sparcv9_tmp; \
310  		__asm__ __volatile__ (&quot;lda [%1+&quot; #idx &quot;*4]%%asi,%0&quot; \
311  			: &quot;=r&quot; (sph_sparcv9_tmp) : &quot;r&quot; (base)); \
312  		sph_sparcv9_tmp; \
313  	})
314  #endif
315  static SPH_INLINE void
316  sph_enc16be(void *dst, unsigned val)
317  {
318  	((unsigned char *)dst)[0] = (val &gt;&gt; 8);
319  	((unsigned char *)dst)[1] = val;
320  }
321  static SPH_INLINE unsigned
322  sph_dec16be(const void *src)
323  {
324  	return ((unsigned)(((const unsigned char *)src)[0]) &lt;&lt; 8)
325  		| (unsigned)(((const unsigned char *)src)[1]);
326  }
327  static SPH_INLINE void
328  sph_enc16le(void *dst, unsigned val)
329  {
330  	((unsigned char *)dst)[0] = val;
331  	((unsigned char *)dst)[1] = val &gt;&gt; 8;
332  }
333  static SPH_INLINE unsigned
334  sph_dec16le(const void *src)
335  {
336  	return (unsigned)(((const unsigned char *)src)[0])
337  		| ((unsigned)(((const unsigned char *)src)[1]) &lt;&lt; 8);
338  }
339  static SPH_INLINE void
340  sph_enc32be(void *dst, sph_u32 val)
341  {
342  #if defined SPH_UPTR
343  #if SPH_UNALIGNED
344  #if SPH_LITTLE_ENDIAN
345  	val = sph_bswap32(val);
346  #endif
347  	*(sph_u32 *)dst = val;
348  #else
349  	if (((SPH_UPTR)dst &amp; 3) == 0) {
350  #if SPH_LITTLE_ENDIAN
351  		val = sph_bswap32(val);
352  #endif
353  		*(sph_u32 *)dst = val;
354  	} else {
355  		((unsigned char *)dst)[0] = (val &gt;&gt; 24);
356  		((unsigned char *)dst)[1] = (val &gt;&gt; 16);
357  		((unsigned char *)dst)[2] = (val &gt;&gt; 8);
358  		((unsigned char *)dst)[3] = val;
359  	}
360  #endif
361  #else
362  	((unsigned char *)dst)[0] = (val &gt;&gt; 24);
363  	((unsigned char *)dst)[1] = (val &gt;&gt; 16);
364  	((unsigned char *)dst)[2] = (val &gt;&gt; 8);
365  	((unsigned char *)dst)[3] = val;
366  #endif
367  }
368  static SPH_INLINE void
369  sph_enc32be_aligned(void *dst, sph_u32 val)
370  {
371  #if SPH_LITTLE_ENDIAN
372  	*(sph_u32 *)dst = sph_bswap32(val);
373  #elif SPH_BIG_ENDIAN
374  	*(sph_u32 *)dst = val;
375  #else
376  	((unsigned char *)dst)[0] = (val &gt;&gt; 24);
377  	((unsigned char *)dst)[1] = (val &gt;&gt; 16);
378  	((unsigned char *)dst)[2] = (val &gt;&gt; 8);
379  	((unsigned char *)dst)[3] = val;
380  #endif
381  }
382  static SPH_INLINE sph_u32
383  sph_dec32be(const void *src)
384  {
385  #if defined SPH_UPTR
386  #if SPH_UNALIGNED
387  #if SPH_LITTLE_ENDIAN
388  	return sph_bswap32(*(const sph_u32 *)src);
389  #else
390  	return *(const sph_u32 *)src;
391  #endif
392  #else
393  	if (((SPH_UPTR)src &amp; 3) == 0) {
394  #if SPH_LITTLE_ENDIAN
395  		return sph_bswap32(*(const sph_u32 *)src);
396  #else
397  		return *(const sph_u32 *)src;
398  #endif
399  	} else {
400  		return ((sph_u32)(((const unsigned char *)src)[0]) &lt;&lt; 24)
401  			| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 16)
402  			| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 8)
403  			| (sph_u32)(((const unsigned char *)src)[3]);
404  	}
405  #endif
406  #else
407  	return ((sph_u32)(((const unsigned char *)src)[0]) &lt;&lt; 24)
408  		| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 16)
409  		| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 8)
410  		| (sph_u32)(((const unsigned char *)src)[3]);
411  #endif
412  }
413  static SPH_INLINE sph_u32
414  sph_dec32be_aligned(const void *src)
415  {
416  #if SPH_LITTLE_ENDIAN
417  	return sph_bswap32(*(const sph_u32 *)src);
418  #elif SPH_BIG_ENDIAN
419  	return *(const sph_u32 *)src;
420  #else
421  	return ((sph_u32)(((const unsigned char *)src)[0]) &lt;&lt; 24)
422  		| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 16)
423  		| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 8)
424  		| (sph_u32)(((const unsigned char *)src)[3]);
425  #endif
426  }
427  static SPH_INLINE void
428  sph_enc32le(void *dst, sph_u32 val)
429  {
430  #if defined SPH_UPTR
431  #if SPH_UNALIGNED
432  #if SPH_BIG_ENDIAN
433  	val = sph_bswap32(val);
434  #endif
435  	*(sph_u32 *)dst = val;
436  #else
437  	if (((SPH_UPTR)dst &amp; 3) == 0) {
438  #if SPH_BIG_ENDIAN
439  		val = sph_bswap32(val);
440  #endif
441  		*(sph_u32 *)dst = val;
442  	} else {
443  		((unsigned char *)dst)[0] = val;
444  		((unsigned char *)dst)[1] = (val &gt;&gt; 8);
445  		((unsigned char *)dst)[2] = (val &gt;&gt; 16);
446  		((unsigned char *)dst)[3] = (val &gt;&gt; 24);
447  	}
448  #endif
449  #else
450  	((unsigned char *)dst)[0] = val;
451  	((unsigned char *)dst)[1] = (val &gt;&gt; 8);
452  	((unsigned char *)dst)[2] = (val &gt;&gt; 16);
453  	((unsigned char *)dst)[3] = (val &gt;&gt; 24);
454  #endif
455  }
456  static SPH_INLINE void
457  sph_enc32le_aligned(void *dst, sph_u32 val)
458  {
459  #if SPH_LITTLE_ENDIAN
460  	*(sph_u32 *)dst = val;
461  #elif SPH_BIG_ENDIAN
462  	*(sph_u32 *)dst = sph_bswap32(val);
463  #else
464  	((unsigned char *)dst)[0] = val;
465  	((unsigned char *)dst)[1] = (val &gt;&gt; 8);
466  	((unsigned char *)dst)[2] = (val &gt;&gt; 16);
467  	((unsigned char *)dst)[3] = (val &gt;&gt; 24);
468  #endif
469  }
470  static SPH_INLINE sph_u32
471  sph_dec32le(const void *src)
472  {
473  #if defined SPH_UPTR
474  #if SPH_UNALIGNED
475  #if SPH_BIG_ENDIAN
476  	return sph_bswap32(*(const sph_u32 *)src);
477  #else
478  	return *(const sph_u32 *)src;
479  #endif
480  #else
481  	if (((SPH_UPTR)src &amp; 3) == 0) {
482  #if SPH_BIG_ENDIAN
483  #if SPH_SPARCV9_GCC &amp;&amp; !SPH_NO_ASM
484  		sph_u32 tmp;
485  		__asm__ __volatile__ (
486  			&quot;lda [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
487  		return tmp;
488  #else
489  		return sph_bswap32(*(const sph_u32 *)src);
490  #endif
491  #else
492  		return *(const sph_u32 *)src;
493  #endif
494  	} else {
495  		return (sph_u32)(((const unsigned char *)src)[0])
496  			| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 8)
497  			| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 16)
498  			| ((sph_u32)(((const unsigned char *)src)[3]) &lt;&lt; 24);
499  	}
500  #endif
501  #else
502  	return (sph_u32)(((const unsigned char *)src)[0])
503  		| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 8)
504  		| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 16)
505  		| ((sph_u32)(((const unsigned char *)src)[3]) &lt;&lt; 24);
506  #endif
507  }
508  static SPH_INLINE sph_u32
509  sph_dec32le_aligned(const void *src)
510  {
511  #if SPH_LITTLE_ENDIAN
512  	return *(const sph_u32 *)src;
513  #elif SPH_BIG_ENDIAN
514  #if SPH_SPARCV9_GCC &amp;&amp; !SPH_NO_ASM
515  	sph_u32 tmp;
516  	__asm__ __volatile__ (&quot;lda [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
517  	return tmp;
518  #else
519  	return sph_bswap32(*(const sph_u32 *)src);
520  #endif
521  #else
522  	return (sph_u32)(((const unsigned char *)src)[0])
523  		| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 8)
524  		| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 16)
525  		| ((sph_u32)(((const unsigned char *)src)[3]) &lt;&lt; 24);
526  #endif
527  }
528  #if SPH_64
529  static SPH_INLINE void
530  sph_enc64be(void *dst, sph_u64 val)
531  {
532  #if defined SPH_UPTR
533  #if SPH_UNALIGNED
534  #if SPH_LITTLE_ENDIAN
535  	val = sph_bswap64(val);
536  #endif
537  	*(sph_u64 *)dst = val;
538  #else
539  	if (((SPH_UPTR)dst &amp; 7) == 0) {
540  #if SPH_LITTLE_ENDIAN
541  		val = sph_bswap64(val);
542  #endif
543  		*(sph_u64 *)dst = val;
544  	} else {
545  		((unsigned char *)dst)[0] = (val &gt;&gt; 56);
546  		((unsigned char *)dst)[1] = (val &gt;&gt; 48);
547  		((unsigned char *)dst)[2] = (val &gt;&gt; 40);
548  		((unsigned char *)dst)[3] = (val &gt;&gt; 32);
549  		((unsigned char *)dst)[4] = (val &gt;&gt; 24);
550  		((unsigned char *)dst)[5] = (val &gt;&gt; 16);
551  		((unsigned char *)dst)[6] = (val &gt;&gt; 8);
552  		((unsigned char *)dst)[7] = val;
553  	}
554  #endif
555  #else
556  	((unsigned char *)dst)[0] = (val &gt;&gt; 56);
557  	((unsigned char *)dst)[1] = (val &gt;&gt; 48);
558  	((unsigned char *)dst)[2] = (val &gt;&gt; 40);
559  	((unsigned char *)dst)[3] = (val &gt;&gt; 32);
560  	((unsigned char *)dst)[4] = (val &gt;&gt; 24);
561  	((unsigned char *)dst)[5] = (val &gt;&gt; 16);
562  	((unsigned char *)dst)[6] = (val &gt;&gt; 8);
563  	((unsigned char *)dst)[7] = val;
564  #endif
565  }
566  static SPH_INLINE void
567  sph_enc64be_aligned(void *dst, sph_u64 val)
568  {
569  #if SPH_LITTLE_ENDIAN
570  	*(sph_u64 *)dst = sph_bswap64(val);
571  #elif SPH_BIG_ENDIAN
572  	*(sph_u64 *)dst = val;
573  #else
574  	((unsigned char *)dst)[0] = (val &gt;&gt; 56);
575  	((unsigned char *)dst)[1] = (val &gt;&gt; 48);
576  	((unsigned char *)dst)[2] = (val &gt;&gt; 40);
577  	((unsigned char *)dst)[3] = (val &gt;&gt; 32);
578  	((unsigned char *)dst)[4] = (val &gt;&gt; 24);
579  	((unsigned char *)dst)[5] = (val &gt;&gt; 16);
580  	((unsigned char *)dst)[6] = (val &gt;&gt; 8);
581  	((unsigned char *)dst)[7] = val;
582  #endif
583  }
584  static SPH_INLINE sph_u64
585  sph_dec64be(const void *src)
586  {
587  #if defined SPH_UPTR
588  #if SPH_UNALIGNED
589  #if SPH_LITTLE_ENDIAN
590  	return sph_bswap64(*(const sph_u64 *)src);
591  #else
592  	return *(const sph_u64 *)src;
593  #endif
594  #else
595  	if (((SPH_UPTR)src &amp; 7) == 0) {
596  #if SPH_LITTLE_ENDIAN
597  		return sph_bswap64(*(const sph_u64 *)src);
598  #else
599  		return *(const sph_u64 *)src;
600  #endif
601  	} else {
602  		return ((sph_u64)(((const unsigned char *)src)[0]) &lt;&lt; 56)
603  			| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 48)
604  			| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 40)
605  			| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 32)
606  			| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 24)
607  			| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 16)
608  			| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 8)
609  			| (sph_u64)(((const unsigned char *)src)[7]);
610  	}
611  #endif
612  #else
613  	return ((sph_u64)(((const unsigned char *)src)[0]) &lt;&lt; 56)
614  		| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 48)
615  		| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 40)
616  		| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 32)
617  		| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 24)
618  		| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 16)
619  		| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 8)
620  		| (sph_u64)(((const unsigned char *)src)[7]);
621  #endif
622  }
623  static SPH_INLINE sph_u64
624  sph_dec64be_aligned(const void *src)
625  {
626  #if SPH_LITTLE_ENDIAN
627  	return sph_bswap64(*(const sph_u64 *)src);
628  #elif SPH_BIG_ENDIAN
629  	return *(const sph_u64 *)src;
630  #else
631  	return ((sph_u64)(((const unsigned char *)src)[0]) &lt;&lt; 56)
632  		| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 48)
633  		| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 40)
634  		| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 32)
635  		| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 24)
636  		| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 16)
637  		| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 8)
638  		| (sph_u64)(((const unsigned char *)src)[7]);
639  #endif
640  }
641  static SPH_INLINE void
642  sph_enc64le(void *dst, sph_u64 val)
643  {
644  #if defined SPH_UPTR
645  #if SPH_UNALIGNED
646  #if SPH_BIG_ENDIAN
647  	val = sph_bswap64(val);
648  #endif
649  	*(sph_u64 *)dst = val;
650  #else
651  	if (((SPH_UPTR)dst &amp; 7) == 0) {
652  #if SPH_BIG_ENDIAN
653  		val = sph_bswap64(val);
654  #endif
655  		*(sph_u64 *)dst = val;
656  	} else {
657  		((unsigned char *)dst)[0] = val;
658  		((unsigned char *)dst)[1] = (val &gt;&gt; 8);
659  		((unsigned char *)dst)[2] = (val &gt;&gt; 16);
660  		((unsigned char *)dst)[3] = (val &gt;&gt; 24);
661  		((unsigned char *)dst)[4] = (val &gt;&gt; 32);
662  		((unsigned char *)dst)[5] = (val &gt;&gt; 40);
663  		((unsigned char *)dst)[6] = (val &gt;&gt; 48);
664  		((unsigned char *)dst)[7] = (val &gt;&gt; 56);
665  	}
666  #endif
667  #else
668  	((unsigned char *)dst)[0] = val;
669  	((unsigned char *)dst)[1] = (val &gt;&gt; 8);
670  	((unsigned char *)dst)[2] = (val &gt;&gt; 16);
671  	((unsigned char *)dst)[3] = (val &gt;&gt; 24);
672  	((unsigned char *)dst)[4] = (val &gt;&gt; 32);
673  	((unsigned char *)dst)[5] = (val &gt;&gt; 40);
674  	((unsigned char *)dst)[6] = (val &gt;&gt; 48);
675  	((unsigned char *)dst)[7] = (val &gt;&gt; 56);
676  #endif
677  }
678  static SPH_INLINE void
679  sph_enc64le_aligned(void *dst, sph_u64 val)
680  {
681  #if SPH_LITTLE_ENDIAN
682  	*(sph_u64 *)dst = val;
683  #elif SPH_BIG_ENDIAN
684  	*(sph_u64 *)dst = sph_bswap64(val);
685  #else
686  	((unsigned char *)dst)[0] = val;
687  	((unsigned char *)dst)[1] = (val &gt;&gt; 8);
688  	((unsigned char *)dst)[2] = (val &gt;&gt; 16);
689  	((unsigned char *)dst)[3] = (val &gt;&gt; 24);
690  	((unsigned char *)dst)[4] = (val &gt;&gt; 32);
691  	((unsigned char *)dst)[5] = (val &gt;&gt; 40);
692  	((unsigned char *)dst)[6] = (val &gt;&gt; 48);
693  	((unsigned char *)dst)[7] = (val &gt;&gt; 56);
694  #endif
695  }
696  static SPH_INLINE sph_u64
697  sph_dec64le(const void *src)
698  {
699  #if defined SPH_UPTR
700  #if SPH_UNALIGNED
701  #if SPH_BIG_ENDIAN
702  	return sph_bswap64(*(const sph_u64 *)src);
703  #else
704  	return *(const sph_u64 *)src;
705  #endif
706  #else
707  	if (((SPH_UPTR)src &amp; 7) == 0) {
708  #if SPH_BIG_ENDIAN
709  #if SPH_SPARCV9_GCC_64 &amp;&amp; !SPH_NO_ASM
<span onclick='openModal()' class='match'>710  		sph_u64 tmp;
711  		__asm__ __volatile__ (
712  			&quot;ldxa [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
713  		return tmp;
714  #else
715  		return sph_bswap64(*(const sph_u64 *)src);
716  #endif
717  #else
718  		return *(const sph_u64 *)src;
</span>719  #endif
720  	} else {
721  		return (sph_u64)(((const unsigned char *)src)[0])
722  			| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 8)
723  			| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 16)
724  			| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 24)
725  			| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 32)
726  			| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 40)
727  			| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 48)
728  			| ((sph_u64)(((const unsigned char *)src)[7]) &lt;&lt; 56);
729  	}
730  #endif
731  #else
732  	return (sph_u64)(((const unsigned char *)src)[0])
733  		| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 8)
734  		| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 16)
735  		| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 24)
736  		| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 32)
737  		| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 40)
738  		| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 48)
739  		| ((sph_u64)(((const unsigned char *)src)[7]) &lt;&lt; 56);
740  #endif
741  }
742  static SPH_INLINE sph_u64
743  sph_dec64le_aligned(const void *src)
744  {
745  #if SPH_LITTLE_ENDIAN
746  	return *(const sph_u64 *)src;
747  #elif SPH_BIG_ENDIAN
748  #if SPH_SPARCV9_GCC_64 &amp;&amp; !SPH_NO_ASM
749  	sph_u64 tmp;
750  	__asm__ __volatile__ (&quot;ldxa [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
751  	return tmp;
752  #else
753  	return sph_bswap64(*(const sph_u64 *)src);
754  #endif
755  #else
756  	return (sph_u64)(((const unsigned char *)src)[0])
757  		| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 8)
758  		| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 16)
759  		| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 24)
760  		| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 32)
761  		| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 40)
762  		| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 48)
763  		| ((sph_u64)(((const unsigned char *)src)[7]) &lt;&lt; 56);
764  #endif
765  }
766  #endif
767  #endif &amp;bsol;* Doxygen excluded block */
768  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_types.h</h3>
            <pre><code>1  #ifndef SPH_TYPES_H__
2  #define SPH_TYPES_H__
3  #include &lt;limits.h&gt;
4  #if CHAR_BIT != 8
5  #error This code requires 8-bit bytes
6  #endif
7  #ifdef DOXYGEN_IGNORE
8  typedef __arch_dependant__ sph_u32;
9  typedef __arch_dependant__ sph_s32;
10  typedef __arch_dependant__ sph_u64;
11  typedef __arch_dependant__ sph_s64;
12  #define SPH_C32(x)
13  #define SPH_T32(x)
14  #define SPH_ROTL32(x, n)
15  #define SPH_ROTR32(x, n)
16  #define SPH_64
17  #define SPH_64_TRUE
18  #define SPH_C64(x)
19  #define SPH_T64(x)
20  #define SPH_ROTL64(x, n)
21  #define SPH_ROTR64(x, n)
22  #define SPH_INLINE
23  #define SPH_LITTLE_ENDIAN
24  #define SPH_BIG_ENDIAN
25  #define SPH_LITTLE_FAST
26  #define SPH_BIG_FAST
27  #define SPH_UPTR
28  #define SPH_UNALIGNED
29  static inline sph_u32 sph_bswap32(sph_u32 x);
30  static inline sph_u64 sph_bswap64(sph_u64 x);
31  static inline unsigned sph_dec16le(const void *src);
32  static inline void sph_enc16le(void *dst, unsigned val);
33  static inline unsigned sph_dec16be(const void *src);
34  static inline void sph_enc16be(void *dst, unsigned val);
35  static inline sph_u32 sph_dec32le(const void *src);
36  static inline sph_u32 sph_dec32le_aligned(const void *src);
37  static inline void sph_enc32le(void *dst, sph_u32 val);
38  static inline void sph_enc32le_aligned(void *dst, sph_u32 val);
39  static inline sph_u32 sph_dec32be(const void *src);
40  static inline sph_u32 sph_dec32be_aligned(const void *src);
41  static inline void sph_enc32be(void *dst, sph_u32 val);
42  static inline void sph_enc32be_aligned(void *dst, sph_u32 val);
43  static inline sph_u64 sph_dec64le(const void *src);
44  static inline sph_u64 sph_dec64le_aligned(const void *src);
45  static inline void sph_enc64le(void *dst, sph_u64 val);
46  static inline void sph_enc64le_aligned(void *dst, sph_u64 val);
47  static inline sph_u64 sph_dec64be(const void *src);
48  static inline sph_u64 sph_dec64be_aligned(const void *src);
49  static inline void sph_enc64be(void *dst, sph_u64 val);
50  static inline void sph_enc64be_aligned(void *dst, sph_u64 val);
51  #endif
52  #ifndef DOXYGEN_IGNORE
53  #undef SPH_64
54  #undef SPH_64_TRUE
55  #if defined __STDC__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L
56  #include &lt;stdint.h&gt;
57  #ifdef UINT32_MAX
58  typedef uint32_t sph_u32;
59  typedef int32_t sph_s32;
60  #else
61  typedef uint_fast32_t sph_u32;
62  typedef int_fast32_t sph_s32;
63  #endif
64  #if !SPH_NO_64
65  #ifdef UINT64_MAX
66  typedef uint64_t sph_u64;
67  typedef int64_t sph_s64;
68  #else
69  typedef uint_fast64_t sph_u64;
70  typedef int_fast64_t sph_s64;
71  #endif
72  #endif
73  #define SPH_C32(x)    ((sph_u32)(x))
74  #if !SPH_NO_64
75  #define SPH_C64(x)    ((sph_u64)(x))
76  #define SPH_64  1
77  #endif
78  #else
79  #if ((UINT_MAX &gt;&gt; 11) &gt;&gt; 11) &gt;= 0x3FF
80  typedef unsigned int sph_u32;
81  typedef int sph_s32;
82  #define SPH_C32(x)    ((sph_u32)(x ## U))
83  #else
84  typedef unsigned long sph_u32;
85  typedef long sph_s32;
86  #define SPH_C32(x)    ((sph_u32)(x ## UL))
87  #endif
88  #if !SPH_NO_64
89  #if ((ULONG_MAX &gt;&gt; 31) &gt;&gt; 31) &gt;= 3
90  typedef unsigned long sph_u64;
91  typedef long sph_s64;
92  #define SPH_C64(x)    ((sph_u64)(x ## UL))
93  #define SPH_64  1
94  #elif ((ULLONG_MAX &gt;&gt; 31) &gt;&gt; 31) &gt;= 3 || defined __GNUC__
95  typedef unsigned long long sph_u64;
96  typedef long long sph_s64;
97  #define SPH_C64(x)    ((sph_u64)(x ## ULL))
98  #define SPH_64  1
99  #else
100  #endif
101  #endif
102  #endif
103  #if SPH_64 &amp;&amp; (((ULONG_MAX &gt;&gt; 31) &gt;&gt; 31) &gt;= 3 || defined _M_X64)
104  #define SPH_64_TRUE   1
105  #endif
106  #define SPH_T32(x)    ((x) &amp; SPH_C32(0xFFFFFFFF))
107  #define SPH_ROTL32(x, n)   SPH_T32(((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32 - (n))))
108  #define SPH_ROTR32(x, n)   SPH_ROTL32(x, (32 - (n)))
109  #if SPH_64
110  #define SPH_T64(x)    ((x) &amp; SPH_C64(0xFFFFFFFFFFFFFFFF))
111  #define SPH_ROTL64(x, n)   SPH_T64(((x) &lt;&lt; (n)) | ((x) &gt;&gt; (64 - (n))))
112  #define SPH_ROTR64(x, n)   SPH_ROTL64(x, (64 - (n)))
113  #endif
114  #ifndef DOXYGEN_IGNORE
115  #if (defined __STDC__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L) || defined __GNUC__
116  #define SPH_INLINE inline
117  #elif defined _MSC_VER
118  #define SPH_INLINE __inline
119  #else
120  #define SPH_INLINE
121  #endif
122  #endif
123  #if defined __i386__ || defined _M_IX86
124  #define SPH_DETECT_UNALIGNED         1
125  #define SPH_DETECT_LITTLE_ENDIAN     1
126  #define SPH_DETECT_UPTR              sph_u32
127  #ifdef __GNUC__
128  #define SPH_DETECT_I386_GCC          1
129  #endif
130  #ifdef _MSC_VER
131  #define SPH_DETECT_I386_MSVC         1
132  #endif
133  #elif defined __x86_64 || defined _M_X64
134  #define SPH_DETECT_UNALIGNED         1
135  #define SPH_DETECT_LITTLE_ENDIAN     1
136  #define SPH_DETECT_UPTR              sph_u64
137  #ifdef __GNUC__
138  #define SPH_DETECT_AMD64_GCC         1
139  #endif
140  #ifdef _MSC_VER
141  #define SPH_DETECT_AMD64_MSVC        1
142  #endif
143  #elif ((defined __sparc__ || defined __sparc) &amp;&amp; defined __arch64__) \
144  	|| defined __sparcv9
145  #define SPH_DETECT_BIG_ENDIAN        1
146  #define SPH_DETECT_UPTR              sph_u64
147  #ifdef __GNUC__
148  #define SPH_DETECT_SPARCV9_GCC_64    1
149  #define SPH_DETECT_LITTLE_FAST       1
150  #endif
151  #elif (defined __sparc__ || defined __sparc) \
152  	&amp;&amp; !(defined __sparcv9 || defined __arch64__)
153  #define SPH_DETECT_BIG_ENDIAN        1
154  #define SPH_DETECT_UPTR              sph_u32
155  #if defined __GNUC__ &amp;&amp; defined __sparc_v9__
156  #define SPH_DETECT_SPARCV9_GCC_32    1
157  #define SPH_DETECT_LITTLE_FAST       1
158  #endif
159  #elif defined __arm__ &amp;&amp; __ARMEL__
160  #define SPH_DETECT_LITTLE_ENDIAN     1
161  #elif MIPSEL || _MIPSEL || __MIPSEL || __MIPSEL__
162  #define SPH_DETECT_LITTLE_ENDIAN     1
163  #elif MIPSEB || _MIPSEB || __MIPSEB || __MIPSEB__
164  #define SPH_DETECT_BIG_ENDIAN        1
165  #elif defined __powerpc__ || defined __POWERPC__ || defined __ppc__ \
166  	|| defined _ARCH_PPC
167  #if defined __GNUC__
168  #if SPH_64_TRUE
169  #define SPH_DETECT_PPC64_GCC         1
170  #else
171  #define SPH_DETECT_PPC32_GCC         1
172  #endif
173  #endif
174  #if defined __BIG_ENDIAN__ || defined _BIG_ENDIAN
175  #define SPH_DETECT_BIG_ENDIAN        1
176  #elif defined __LITTLE_ENDIAN__ || defined _LITTLE_ENDIAN
177  #define SPH_DETECT_LITTLE_ENDIAN     1
178  #endif
179  #elif defined __ia64 || defined __ia64__ \
180  	|| defined __itanium__ || defined _M_IA64
181  #if defined __BIG_ENDIAN__ || defined _BIG_ENDIAN
182  #define SPH_DETECT_BIG_ENDIAN        1
183  #else
184  #define SPH_DETECT_LITTLE_ENDIAN     1
185  #endif
186  #if defined __LP64__ || defined _LP64
187  #define SPH_DETECT_UPTR              sph_u64
188  #else
189  #define SPH_DETECT_UPTR              sph_u32
190  #endif
191  #endif
192  #if defined SPH_DETECT_SPARCV9_GCC_32 || defined SPH_DETECT_SPARCV9_GCC_64
193  #define SPH_DETECT_SPARCV9_GCC       1
194  #endif
195  #if defined SPH_DETECT_UNALIGNED &amp;&amp; !defined SPH_UNALIGNED
196  #define SPH_UNALIGNED         SPH_DETECT_UNALIGNED
197  #endif
198  #if defined SPH_DETECT_UPTR &amp;&amp; !defined SPH_UPTR
199  #define SPH_UPTR              SPH_DETECT_UPTR
200  #endif
201  #if defined SPH_DETECT_LITTLE_ENDIAN &amp;&amp; !defined SPH_LITTLE_ENDIAN
202  #define SPH_LITTLE_ENDIAN     SPH_DETECT_LITTLE_ENDIAN
203  #endif
204  #if defined SPH_DETECT_BIG_ENDIAN &amp;&amp; !defined SPH_BIG_ENDIAN
205  #define SPH_BIG_ENDIAN        SPH_DETECT_BIG_ENDIAN
206  #endif
207  #if defined SPH_DETECT_LITTLE_FAST &amp;&amp; !defined SPH_LITTLE_FAST
208  #define SPH_LITTLE_FAST       SPH_DETECT_LITTLE_FAST
209  #endif
210  #if defined SPH_DETECT_BIG_FAST &amp;&amp; !defined SPH_BIG_FAST
211  #define SPH_BIG_FAST    SPH_DETECT_BIG_FAST
212  #endif
213  #if defined SPH_DETECT_SPARCV9_GCC_32 &amp;&amp; !defined SPH_SPARCV9_GCC_32
214  #define SPH_SPARCV9_GCC_32    SPH_DETECT_SPARCV9_GCC_32
215  #endif
216  #if defined SPH_DETECT_SPARCV9_GCC_64 &amp;&amp; !defined SPH_SPARCV9_GCC_64
217  #define SPH_SPARCV9_GCC_64    SPH_DETECT_SPARCV9_GCC_64
218  #endif
219  #if defined SPH_DETECT_SPARCV9_GCC &amp;&amp; !defined SPH_SPARCV9_GCC
220  #define SPH_SPARCV9_GCC       SPH_DETECT_SPARCV9_GCC
221  #endif
222  #if defined SPH_DETECT_I386_GCC &amp;&amp; !defined SPH_I386_GCC
223  #define SPH_I386_GCC          SPH_DETECT_I386_GCC
224  #endif
225  #if defined SPH_DETECT_I386_MSVC &amp;&amp; !defined SPH_I386_MSVC
226  #define SPH_I386_MSVC         SPH_DETECT_I386_MSVC
227  #endif
228  #if defined SPH_DETECT_AMD64_GCC &amp;&amp; !defined SPH_AMD64_GCC
229  #define SPH_AMD64_GCC         SPH_DETECT_AMD64_GCC
230  #endif
231  #if defined SPH_DETECT_AMD64_MSVC &amp;&amp; !defined SPH_AMD64_MSVC
232  #define SPH_AMD64_MSVC        SPH_DETECT_AMD64_MSVC
233  #endif
234  #if defined SPH_DETECT_PPC32_GCC &amp;&amp; !defined SPH_PPC32_GCC
235  #define SPH_PPC32_GCC         SPH_DETECT_PPC32_GCC
236  #endif
237  #if defined SPH_DETECT_PPC64_GCC &amp;&amp; !defined SPH_PPC64_GCC
238  #define SPH_PPC64_GCC         SPH_DETECT_PPC64_GCC
239  #endif
240  #if SPH_LITTLE_ENDIAN &amp;&amp; !defined SPH_LITTLE_FAST
241  #define SPH_LITTLE_FAST              1
242  #endif
243  #if SPH_BIG_ENDIAN &amp;&amp; !defined SPH_BIG_FAST
244  #define SPH_BIG_FAST                 1
245  #endif
246  #if defined SPH_UPTR &amp;&amp; !(SPH_LITTLE_ENDIAN || SPH_BIG_ENDIAN)
247  #error SPH_UPTR defined, but endianness is not known.
248  #endif
249  #if SPH_I386_GCC &amp;&amp; !SPH_NO_ASM
250  static SPH_INLINE sph_u32
251  sph_bswap32(sph_u32 x)
252  {
253  	__asm__ __volatile__ (&quot;bswapl %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
254  	return x;
255  }
256  #if SPH_64
257  static SPH_INLINE sph_u64
258  sph_bswap64(sph_u64 x)
259  {
260  	return ((sph_u64)sph_bswap32((sph_u32)x) &lt;&lt; 32)
261  		| (sph_u64)sph_bswap32((sph_u32)(x &gt;&gt; 32));
262  }
263  #endif
264  #elif SPH_AMD64_GCC &amp;&amp; !SPH_NO_ASM
265  static SPH_INLINE sph_u32
266  sph_bswap32(sph_u32 x)
267  {
268  	__asm__ __volatile__ (&quot;bswapl %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
269  	return x;
270  }
271  #if SPH_64
272  static SPH_INLINE sph_u64
273  sph_bswap64(sph_u64 x)
274  {
275  	__asm__ __volatile__ (&quot;bswapq %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
276  	return x;
277  }
278  #endif
279  #else
280  static SPH_INLINE sph_u32
281  sph_bswap32(sph_u32 x)
282  {
283  	x = SPH_T32((x &lt;&lt; 16) | (x &gt;&gt; 16));
284  	x = ((x &amp; SPH_C32(0xFF00FF00)) &gt;&gt; 8)
285  		| ((x &amp; SPH_C32(0x00FF00FF)) &lt;&lt; 8);
286  	return x;
287  }
288  #if SPH_64
289  static SPH_INLINE sph_u64
290  sph_bswap64(sph_u64 x)
291  {
292  	x = SPH_T64((x &lt;&lt; 32) | (x &gt;&gt; 32));
293  	x = ((x &amp; SPH_C64(0xFFFF0000FFFF0000)) &gt;&gt; 16)
294  		| ((x &amp; SPH_C64(0x0000FFFF0000FFFF)) &lt;&lt; 16);
295  	x = ((x &amp; SPH_C64(0xFF00FF00FF00FF00)) &gt;&gt; 8)
296  		| ((x &amp; SPH_C64(0x00FF00FF00FF00FF)) &lt;&lt; 8);
297  	return x;
298  }
299  #endif
300  #endif
301  #if SPH_SPARCV9_GCC &amp;&amp; !SPH_NO_ASM
302  #define SPH_SPARCV9_SET_ASI   \
303  	sph_u32 sph_sparcv9_asi; \
304  	__asm__ __volatile__ ( \
305  		&quot;rd %%asi,%0\n\twr %%g0,0x88,%%asi&quot; : &quot;=r&quot; (sph_sparcv9_asi));
306  #define SPH_SPARCV9_RESET_ASI  \
307  	__asm__ __volatile__ (&quot;wr %%g0,%0,%%asi&quot; : : &quot;r&quot; (sph_sparcv9_asi));
308  #define SPH_SPARCV9_DEC32LE(base, idx)   ({ \
309  		sph_u32 sph_sparcv9_tmp; \
310  		__asm__ __volatile__ (&quot;lda [%1+&quot; #idx &quot;*4]%%asi,%0&quot; \
311  			: &quot;=r&quot; (sph_sparcv9_tmp) : &quot;r&quot; (base)); \
312  		sph_sparcv9_tmp; \
313  	})
314  #endif
315  static SPH_INLINE void
316  sph_enc16be(void *dst, unsigned val)
317  {
318  	((unsigned char *)dst)[0] = (val &gt;&gt; 8);
319  	((unsigned char *)dst)[1] = val;
320  }
321  static SPH_INLINE unsigned
322  sph_dec16be(const void *src)
323  {
324  	return ((unsigned)(((const unsigned char *)src)[0]) &lt;&lt; 8)
325  		| (unsigned)(((const unsigned char *)src)[1]);
326  }
327  static SPH_INLINE void
328  sph_enc16le(void *dst, unsigned val)
329  {
330  	((unsigned char *)dst)[0] = val;
331  	((unsigned char *)dst)[1] = val &gt;&gt; 8;
332  }
333  static SPH_INLINE unsigned
334  sph_dec16le(const void *src)
335  {
336  	return (unsigned)(((const unsigned char *)src)[0])
337  		| ((unsigned)(((const unsigned char *)src)[1]) &lt;&lt; 8);
338  }
339  static SPH_INLINE void
340  sph_enc32be(void *dst, sph_u32 val)
341  {
342  #if defined SPH_UPTR
343  #if SPH_UNALIGNED
344  #if SPH_LITTLE_ENDIAN
345  	val = sph_bswap32(val);
346  #endif
347  	*(sph_u32 *)dst = val;
348  #else
349  	if (((SPH_UPTR)dst &amp; 3) == 0) {
350  #if SPH_LITTLE_ENDIAN
351  		val = sph_bswap32(val);
352  #endif
353  		*(sph_u32 *)dst = val;
354  	} else {
355  		((unsigned char *)dst)[0] = (val &gt;&gt; 24);
356  		((unsigned char *)dst)[1] = (val &gt;&gt; 16);
357  		((unsigned char *)dst)[2] = (val &gt;&gt; 8);
358  		((unsigned char *)dst)[3] = val;
359  	}
360  #endif
361  #else
362  	((unsigned char *)dst)[0] = (val &gt;&gt; 24);
363  	((unsigned char *)dst)[1] = (val &gt;&gt; 16);
364  	((unsigned char *)dst)[2] = (val &gt;&gt; 8);
365  	((unsigned char *)dst)[3] = val;
366  #endif
367  }
368  static SPH_INLINE void
369  sph_enc32be_aligned(void *dst, sph_u32 val)
370  {
371  #if SPH_LITTLE_ENDIAN
372  	*(sph_u32 *)dst = sph_bswap32(val);
373  #elif SPH_BIG_ENDIAN
374  	*(sph_u32 *)dst = val;
375  #else
376  	((unsigned char *)dst)[0] = (val &gt;&gt; 24);
377  	((unsigned char *)dst)[1] = (val &gt;&gt; 16);
378  	((unsigned char *)dst)[2] = (val &gt;&gt; 8);
379  	((unsigned char *)dst)[3] = val;
380  #endif
381  }
382  static SPH_INLINE sph_u32
383  sph_dec32be(const void *src)
384  {
385  #if defined SPH_UPTR
386  #if SPH_UNALIGNED
387  #if SPH_LITTLE_ENDIAN
388  	return sph_bswap32(*(const sph_u32 *)src);
389  #else
390  	return *(const sph_u32 *)src;
391  #endif
392  #else
393  	if (((SPH_UPTR)src &amp; 3) == 0) {
394  #if SPH_LITTLE_ENDIAN
395  		return sph_bswap32(*(const sph_u32 *)src);
396  #else
397  		return *(const sph_u32 *)src;
398  #endif
399  	} else {
400  		return ((sph_u32)(((const unsigned char *)src)[0]) &lt;&lt; 24)
401  			| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 16)
402  			| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 8)
403  			| (sph_u32)(((const unsigned char *)src)[3]);
404  	}
405  #endif
406  #else
407  	return ((sph_u32)(((const unsigned char *)src)[0]) &lt;&lt; 24)
408  		| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 16)
409  		| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 8)
410  		| (sph_u32)(((const unsigned char *)src)[3]);
411  #endif
412  }
413  static SPH_INLINE sph_u32
414  sph_dec32be_aligned(const void *src)
415  {
416  #if SPH_LITTLE_ENDIAN
417  	return sph_bswap32(*(const sph_u32 *)src);
418  #elif SPH_BIG_ENDIAN
419  	return *(const sph_u32 *)src;
420  #else
421  	return ((sph_u32)(((const unsigned char *)src)[0]) &lt;&lt; 24)
422  		| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 16)
423  		| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 8)
424  		| (sph_u32)(((const unsigned char *)src)[3]);
425  #endif
426  }
427  static SPH_INLINE void
428  sph_enc32le(void *dst, sph_u32 val)
429  {
430  #if defined SPH_UPTR
431  #if SPH_UNALIGNED
432  #if SPH_BIG_ENDIAN
433  	val = sph_bswap32(val);
434  #endif
435  	*(sph_u32 *)dst = val;
436  #else
437  	if (((SPH_UPTR)dst &amp; 3) == 0) {
438  #if SPH_BIG_ENDIAN
439  		val = sph_bswap32(val);
440  #endif
441  		*(sph_u32 *)dst = val;
442  	} else {
443  		((unsigned char *)dst)[0] = val;
444  		((unsigned char *)dst)[1] = (val &gt;&gt; 8);
445  		((unsigned char *)dst)[2] = (val &gt;&gt; 16);
446  		((unsigned char *)dst)[3] = (val &gt;&gt; 24);
447  	}
448  #endif
449  #else
450  	((unsigned char *)dst)[0] = val;
451  	((unsigned char *)dst)[1] = (val &gt;&gt; 8);
452  	((unsigned char *)dst)[2] = (val &gt;&gt; 16);
453  	((unsigned char *)dst)[3] = (val &gt;&gt; 24);
454  #endif
455  }
456  static SPH_INLINE void
457  sph_enc32le_aligned(void *dst, sph_u32 val)
458  {
459  #if SPH_LITTLE_ENDIAN
460  	*(sph_u32 *)dst = val;
461  #elif SPH_BIG_ENDIAN
462  	*(sph_u32 *)dst = sph_bswap32(val);
463  #else
464  	((unsigned char *)dst)[0] = val;
465  	((unsigned char *)dst)[1] = (val &gt;&gt; 8);
466  	((unsigned char *)dst)[2] = (val &gt;&gt; 16);
467  	((unsigned char *)dst)[3] = (val &gt;&gt; 24);
468  #endif
469  }
470  static SPH_INLINE sph_u32
471  sph_dec32le(const void *src)
472  {
473  #if defined SPH_UPTR
474  #if SPH_UNALIGNED
475  #if SPH_BIG_ENDIAN
476  	return sph_bswap32(*(const sph_u32 *)src);
477  #else
478  	return *(const sph_u32 *)src;
479  #endif
480  #else
481  	if (((SPH_UPTR)src &amp; 3) == 0) {
482  #if SPH_BIG_ENDIAN
483  #if SPH_SPARCV9_GCC &amp;&amp; !SPH_NO_ASM
484  		sph_u32 tmp;
485  		__asm__ __volatile__ (
486  			&quot;lda [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
487  		return tmp;
488  #else
489  		return sph_bswap32(*(const sph_u32 *)src);
490  #endif
491  #else
492  		return *(const sph_u32 *)src;
493  #endif
494  	} else {
495  		return (sph_u32)(((const unsigned char *)src)[0])
496  			| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 8)
497  			| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 16)
498  			| ((sph_u32)(((const unsigned char *)src)[3]) &lt;&lt; 24);
499  	}
500  #endif
501  #else
502  	return (sph_u32)(((const unsigned char *)src)[0])
503  		| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 8)
504  		| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 16)
505  		| ((sph_u32)(((const unsigned char *)src)[3]) &lt;&lt; 24);
506  #endif
507  }
508  static SPH_INLINE sph_u32
509  sph_dec32le_aligned(const void *src)
510  {
511  #if SPH_LITTLE_ENDIAN
512  	return *(const sph_u32 *)src;
513  #elif SPH_BIG_ENDIAN
514  #if SPH_SPARCV9_GCC &amp;&amp; !SPH_NO_ASM
<span onclick='openModal()' class='match'>515  	sph_u32 tmp;
516  	__asm__ __volatile__ (&quot;lda [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
517  	return tmp;
518  #else
519  	return sph_bswap32(*(const sph_u32 *)src);
520  #endif
521  #else
522  	return (sph_u32)(((const unsigned char *)src)[0])
</span>523  		| ((sph_u32)(((const unsigned char *)src)[1]) &lt;&lt; 8)
524  		| ((sph_u32)(((const unsigned char *)src)[2]) &lt;&lt; 16)
525  		| ((sph_u32)(((const unsigned char *)src)[3]) &lt;&lt; 24);
526  #endif
527  }
528  #if SPH_64
529  static SPH_INLINE void
530  sph_enc64be(void *dst, sph_u64 val)
531  {
532  #if defined SPH_UPTR
533  #if SPH_UNALIGNED
534  #if SPH_LITTLE_ENDIAN
535  	val = sph_bswap64(val);
536  #endif
537  	*(sph_u64 *)dst = val;
538  #else
539  	if (((SPH_UPTR)dst &amp; 7) == 0) {
540  #if SPH_LITTLE_ENDIAN
541  		val = sph_bswap64(val);
542  #endif
543  		*(sph_u64 *)dst = val;
544  	} else {
545  		((unsigned char *)dst)[0] = (val &gt;&gt; 56);
546  		((unsigned char *)dst)[1] = (val &gt;&gt; 48);
547  		((unsigned char *)dst)[2] = (val &gt;&gt; 40);
548  		((unsigned char *)dst)[3] = (val &gt;&gt; 32);
549  		((unsigned char *)dst)[4] = (val &gt;&gt; 24);
550  		((unsigned char *)dst)[5] = (val &gt;&gt; 16);
551  		((unsigned char *)dst)[6] = (val &gt;&gt; 8);
552  		((unsigned char *)dst)[7] = val;
553  	}
554  #endif
555  #else
556  	((unsigned char *)dst)[0] = (val &gt;&gt; 56);
557  	((unsigned char *)dst)[1] = (val &gt;&gt; 48);
558  	((unsigned char *)dst)[2] = (val &gt;&gt; 40);
559  	((unsigned char *)dst)[3] = (val &gt;&gt; 32);
560  	((unsigned char *)dst)[4] = (val &gt;&gt; 24);
561  	((unsigned char *)dst)[5] = (val &gt;&gt; 16);
562  	((unsigned char *)dst)[6] = (val &gt;&gt; 8);
563  	((unsigned char *)dst)[7] = val;
564  #endif
565  }
566  static SPH_INLINE void
567  sph_enc64be_aligned(void *dst, sph_u64 val)
568  {
569  #if SPH_LITTLE_ENDIAN
570  	*(sph_u64 *)dst = sph_bswap64(val);
571  #elif SPH_BIG_ENDIAN
572  	*(sph_u64 *)dst = val;
573  #else
574  	((unsigned char *)dst)[0] = (val &gt;&gt; 56);
575  	((unsigned char *)dst)[1] = (val &gt;&gt; 48);
576  	((unsigned char *)dst)[2] = (val &gt;&gt; 40);
577  	((unsigned char *)dst)[3] = (val &gt;&gt; 32);
578  	((unsigned char *)dst)[4] = (val &gt;&gt; 24);
579  	((unsigned char *)dst)[5] = (val &gt;&gt; 16);
580  	((unsigned char *)dst)[6] = (val &gt;&gt; 8);
581  	((unsigned char *)dst)[7] = val;
582  #endif
583  }
584  static SPH_INLINE sph_u64
585  sph_dec64be(const void *src)
586  {
587  #if defined SPH_UPTR
588  #if SPH_UNALIGNED
589  #if SPH_LITTLE_ENDIAN
590  	return sph_bswap64(*(const sph_u64 *)src);
591  #else
592  	return *(const sph_u64 *)src;
593  #endif
594  #else
595  	if (((SPH_UPTR)src &amp; 7) == 0) {
596  #if SPH_LITTLE_ENDIAN
597  		return sph_bswap64(*(const sph_u64 *)src);
598  #else
599  		return *(const sph_u64 *)src;
600  #endif
601  	} else {
602  		return ((sph_u64)(((const unsigned char *)src)[0]) &lt;&lt; 56)
603  			| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 48)
604  			| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 40)
605  			| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 32)
606  			| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 24)
607  			| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 16)
608  			| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 8)
609  			| (sph_u64)(((const unsigned char *)src)[7]);
610  	}
611  #endif
612  #else
613  	return ((sph_u64)(((const unsigned char *)src)[0]) &lt;&lt; 56)
614  		| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 48)
615  		| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 40)
616  		| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 32)
617  		| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 24)
618  		| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 16)
619  		| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 8)
620  		| (sph_u64)(((const unsigned char *)src)[7]);
621  #endif
622  }
623  static SPH_INLINE sph_u64
624  sph_dec64be_aligned(const void *src)
625  {
626  #if SPH_LITTLE_ENDIAN
627  	return sph_bswap64(*(const sph_u64 *)src);
628  #elif SPH_BIG_ENDIAN
629  	return *(const sph_u64 *)src;
630  #else
631  	return ((sph_u64)(((const unsigned char *)src)[0]) &lt;&lt; 56)
632  		| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 48)
633  		| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 40)
634  		| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 32)
635  		| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 24)
636  		| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 16)
637  		| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 8)
638  		| (sph_u64)(((const unsigned char *)src)[7]);
639  #endif
640  }
641  static SPH_INLINE void
642  sph_enc64le(void *dst, sph_u64 val)
643  {
644  #if defined SPH_UPTR
645  #if SPH_UNALIGNED
646  #if SPH_BIG_ENDIAN
647  	val = sph_bswap64(val);
648  #endif
649  	*(sph_u64 *)dst = val;
650  #else
651  	if (((SPH_UPTR)dst &amp; 7) == 0) {
652  #if SPH_BIG_ENDIAN
653  		val = sph_bswap64(val);
654  #endif
655  		*(sph_u64 *)dst = val;
656  	} else {
657  		((unsigned char *)dst)[0] = val;
658  		((unsigned char *)dst)[1] = (val &gt;&gt; 8);
659  		((unsigned char *)dst)[2] = (val &gt;&gt; 16);
660  		((unsigned char *)dst)[3] = (val &gt;&gt; 24);
661  		((unsigned char *)dst)[4] = (val &gt;&gt; 32);
662  		((unsigned char *)dst)[5] = (val &gt;&gt; 40);
663  		((unsigned char *)dst)[6] = (val &gt;&gt; 48);
664  		((unsigned char *)dst)[7] = (val &gt;&gt; 56);
665  	}
666  #endif
667  #else
668  	((unsigned char *)dst)[0] = val;
669  	((unsigned char *)dst)[1] = (val &gt;&gt; 8);
670  	((unsigned char *)dst)[2] = (val &gt;&gt; 16);
671  	((unsigned char *)dst)[3] = (val &gt;&gt; 24);
672  	((unsigned char *)dst)[4] = (val &gt;&gt; 32);
673  	((unsigned char *)dst)[5] = (val &gt;&gt; 40);
674  	((unsigned char *)dst)[6] = (val &gt;&gt; 48);
675  	((unsigned char *)dst)[7] = (val &gt;&gt; 56);
676  #endif
677  }
678  static SPH_INLINE void
679  sph_enc64le_aligned(void *dst, sph_u64 val)
680  {
681  #if SPH_LITTLE_ENDIAN
682  	*(sph_u64 *)dst = val;
683  #elif SPH_BIG_ENDIAN
684  	*(sph_u64 *)dst = sph_bswap64(val);
685  #else
686  	((unsigned char *)dst)[0] = val;
687  	((unsigned char *)dst)[1] = (val &gt;&gt; 8);
688  	((unsigned char *)dst)[2] = (val &gt;&gt; 16);
689  	((unsigned char *)dst)[3] = (val &gt;&gt; 24);
690  	((unsigned char *)dst)[4] = (val &gt;&gt; 32);
691  	((unsigned char *)dst)[5] = (val &gt;&gt; 40);
692  	((unsigned char *)dst)[6] = (val &gt;&gt; 48);
693  	((unsigned char *)dst)[7] = (val &gt;&gt; 56);
694  #endif
695  }
696  static SPH_INLINE sph_u64
697  sph_dec64le(const void *src)
698  {
699  #if defined SPH_UPTR
700  #if SPH_UNALIGNED
701  #if SPH_BIG_ENDIAN
702  	return sph_bswap64(*(const sph_u64 *)src);
703  #else
704  	return *(const sph_u64 *)src;
705  #endif
706  #else
707  	if (((SPH_UPTR)src &amp; 7) == 0) {
708  #if SPH_BIG_ENDIAN
709  #if SPH_SPARCV9_GCC_64 &amp;&amp; !SPH_NO_ASM
710  		sph_u64 tmp;
711  		__asm__ __volatile__ (
712  			&quot;ldxa [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
713  		return tmp;
714  #else
715  		return sph_bswap64(*(const sph_u64 *)src);
716  #endif
717  #else
718  		return *(const sph_u64 *)src;
719  #endif
720  	} else {
721  		return (sph_u64)(((const unsigned char *)src)[0])
722  			| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 8)
723  			| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 16)
724  			| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 24)
725  			| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 32)
726  			| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 40)
727  			| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 48)
728  			| ((sph_u64)(((const unsigned char *)src)[7]) &lt;&lt; 56);
729  	}
730  #endif
731  #else
732  	return (sph_u64)(((const unsigned char *)src)[0])
733  		| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 8)
734  		| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 16)
735  		| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 24)
736  		| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 32)
737  		| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 40)
738  		| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 48)
739  		| ((sph_u64)(((const unsigned char *)src)[7]) &lt;&lt; 56);
740  #endif
741  }
742  static SPH_INLINE sph_u64
743  sph_dec64le_aligned(const void *src)
744  {
745  #if SPH_LITTLE_ENDIAN
746  	return *(const sph_u64 *)src;
747  #elif SPH_BIG_ENDIAN
748  #if SPH_SPARCV9_GCC_64 &amp;&amp; !SPH_NO_ASM
749  	sph_u64 tmp;
750  	__asm__ __volatile__ (&quot;ldxa [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
751  	return tmp;
752  #else
753  	return sph_bswap64(*(const sph_u64 *)src);
754  #endif
755  #else
756  	return (sph_u64)(((const unsigned char *)src)[0])
757  		| ((sph_u64)(((const unsigned char *)src)[1]) &lt;&lt; 8)
758  		| ((sph_u64)(((const unsigned char *)src)[2]) &lt;&lt; 16)
759  		| ((sph_u64)(((const unsigned char *)src)[3]) &lt;&lt; 24)
760  		| ((sph_u64)(((const unsigned char *)src)[4]) &lt;&lt; 32)
761  		| ((sph_u64)(((const unsigned char *)src)[5]) &lt;&lt; 40)
762  		| ((sph_u64)(((const unsigned char *)src)[6]) &lt;&lt; 48)
763  		| ((sph_u64)(((const unsigned char *)src)[7]) &lt;&lt; 56);
764  #endif
765  }
766  #endif
767  #endif &amp;bsol;* Doxygen excluded block */
768  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_types.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_types.h</div>
                </div>
                <div class="column column_space"><pre><code>710  		sph_u64 tmp;
711  		__asm__ __volatile__ (
712  			&quot;ldxa [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
713  		return tmp;
714  #else
715  		return sph_bswap64(*(const sph_u64 *)src);
716  #endif
717  #else
718  		return *(const sph_u64 *)src;
</pre></code></div>
                <div class="column column_space"><pre><code>515  	sph_u32 tmp;
516  	__asm__ __volatile__ (&quot;lda [%1]0x88,%0&quot; : &quot;=r&quot; (tmp) : &quot;r&quot; (src));
517  	return tmp;
518  #else
519  	return sph_bswap32(*(const sph_u32 *)src);
520  #endif
521  #else
522  	return (sph_u32)(((const unsigned char *)src)[0])
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    