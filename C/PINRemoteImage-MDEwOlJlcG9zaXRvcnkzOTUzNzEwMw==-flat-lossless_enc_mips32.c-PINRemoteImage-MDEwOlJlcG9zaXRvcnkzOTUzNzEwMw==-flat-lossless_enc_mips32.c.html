
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 40, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_mips32.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #include "src/dsp/lossless.h"
3  #include "src/dsp/lossless_common.h"
4  #if defined(WEBP_USE_MIPS32)
5  #include <assert.h>
6  #include <math.h>
7  #include <stdlib.h>
8  #include <string.h>
9  static float FastSLog2Slow_MIPS32(uint32_t v) {
10    assert(v >= LOG_LOOKUP_IDX_MAX);
11    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
12      uint32_t log_cnt, y, correction;
13      const int c24 = 24;
14      const float v_f = (float)v;
15      uint32_t temp;
16      __asm__ volatile(
17        "clz      %[log_cnt], %[v]                      \n\t"
18        "addiu    %[y],       $zero,        1           \n\t"
19        "subu     %[log_cnt], %[c24],       %[log_cnt]  \n\t"
20        "sllv     %[y],       %[y],         %[log_cnt]  \n\t"
21        "srlv     %[temp],    %[v],         %[log_cnt]  \n\t"
22        : [log_cnt]"=&r"(log_cnt), [y]"=&r"(y),
23          [temp]"=r"(temp)
24        : [c24]"r"(c24), [v]"r"(v)
25      );
26      correction = (23 * (v & (y - 1))) >> 4;
27      return v_f * (kLog2Table[temp] + log_cnt) + correction;
28    } else {
29      return (float)(LOG_2_RECIPROCAL * v * log((double)v));
30    }
31  }
32  static float FastLog2Slow_MIPS32(uint32_t v) {
33    assert(v >= LOG_LOOKUP_IDX_MAX);
34    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
35      uint32_t log_cnt, y;
36      const int c24 = 24;
37      double log_2;
38      uint32_t temp;
39      __asm__ volatile(
40        "clz      %[log_cnt], %[v]                      \n\t"
41        "addiu    %[y],       $zero,        1           \n\t"
42        "subu     %[log_cnt], %[c24],       %[log_cnt]  \n\t"
43        "sllv     %[y],       %[y],         %[log_cnt]  \n\t"
44        "srlv     %[temp],    %[v],         %[log_cnt]  \n\t"
45        : [log_cnt]"=&r"(log_cnt), [y]"=&r"(y),
46          [temp]"=r"(temp)
47        : [c24]"r"(c24), [v]"r"(v)
48      );
49      log_2 = kLog2Table[temp] + log_cnt;
50      if (v >= APPROX_LOG_MAX) {
51        const uint32_t correction = (23 * (v & (y - 1))) >> 4;
52        log_2 += (double)correction / v;
53      }
54      return (float)log_2;
55    } else {
56      return (float)(LOG_2_RECIPROCAL * log((double)v));
57    }
58  }
59  static double ExtraCost_MIPS32(const uint32_t* const population, int length) {
60    int i, temp0, temp1;
<span onclick='openModal()' class='match'>61    const uint32_t* pop = &population[4];
62    const uint32_t* const LoopEnd = &population[length];
63    __asm__ volatile(
64      "mult   $zero,    $zero                  \n\t"
65      "xor    %[i],     %[i],       %[i]       \n\t"
66      "beq    %[pop],   %[LoopEnd], 2f         \n\t"
67    "1:                                        \n\t"
68      "lw     %[temp0], 0(%[pop])              \n\t"
69      "lw     %[temp1], 4(%[pop])              \n\t"
70      "addiu  %[i],     %[i],       1          \n\t"
71      "addiu  %[pop],   %[pop],     8          \n\t"
72      "madd   %[i],     %[temp0]               \n\t"
73      "madd   %[i],     %[temp1]               \n\t"
74      "bne    %[pop],   %[LoopEnd], 1b         \n\t"
75    "2:                                        \n\t"
76      "mfhi   %[temp0]                         \n\t"
77      "mflo   %[temp1]                         \n\t"
78      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),
</span>79        [i]"=&r"(i), [pop]"+r"(pop)
80      : [LoopEnd]"r"(LoopEnd)
81      : "memory", "hi", "lo"
82    );
83    return (double)((int64_t)temp0 << 32 | temp1);
84  }
85  static double ExtraCostCombined_MIPS32(const uint32_t* const X,
86                                         const uint32_t* const Y, int length) {
87    int i, temp0, temp1, temp2, temp3;
88    const uint32_t* pX = &X[4];
89    const uint32_t* pY = &Y[4];
90    const uint32_t* const LoopEnd = &X[length];
91    __asm__ volatile(
92      "mult   $zero,    $zero                  \n\t"
93      "xor    %[i],     %[i],       %[i]       \n\t"
94      "beq    %[pX],    %[LoopEnd], 2f         \n\t"
95    "1:                                        \n\t"
96      "lw     %[temp0], 0(%[pX])               \n\t"
97      "lw     %[temp1], 0(%[pY])               \n\t"
98      "lw     %[temp2], 4(%[pX])               \n\t"
99      "lw     %[temp3], 4(%[pY])               \n\t"
100      "addiu  %[i],     %[i],       1          \n\t"
101      "addu   %[temp0], %[temp0],   %[temp1]   \n\t"
102      "addu   %[temp2], %[temp2],   %[temp3]   \n\t"
103      "addiu  %[pX],    %[pX],      8          \n\t"
104      "addiu  %[pY],    %[pY],      8          \n\t"
105      "madd   %[i],     %[temp0]               \n\t"
106      "madd   %[i],     %[temp2]               \n\t"
107      "bne    %[pX],    %[LoopEnd], 1b         \n\t"
108    "2:                                        \n\t"
109      "mfhi   %[temp0]                         \n\t"
110      "mflo   %[temp1]                         \n\t"
111      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),
112        [temp2]"=&r"(temp2), [temp3]"=&r"(temp3),
113        [i]"=&r"(i), [pX]"+r"(pX), [pY]"+r"(pY)
114      : [LoopEnd]"r"(LoopEnd)
115      : "memory", "hi", "lo"
116    );
117    return (double)((int64_t)temp0 << 32 | temp1);
118  }
119  #define HUFFMAN_COST_PASS                                 \
120    __asm__ volatile(                                       \
121      "sll   %[temp1],  %[temp0],    3           \n\t"      \
122      "addiu %[temp3],  %[streak],   -3          \n\t"      \
123      "addu  %[temp2],  %[pstreaks], %[temp1]    \n\t"      \
124      "blez  %[temp3],  1f                       \n\t"      \
125      "srl   %[temp1],  %[temp1],    1           \n\t"      \
126      "addu  %[temp3],  %[pcnts],    %[temp1]    \n\t"      \
127      "lw    %[temp0],  4(%[temp2])              \n\t"      \
128      "lw    %[temp1],  0(%[temp3])              \n\t"      \
129      "addu  %[temp0],  %[temp0],    %[streak]   \n\t"      \
130      "addiu %[temp1],  %[temp1],    1           \n\t"      \
131      "sw    %[temp0],  4(%[temp2])              \n\t"      \
132      "sw    %[temp1],  0(%[temp3])              \n\t"      \
133      "b     2f                                  \n\t"      \
134    "1:                                          \n\t"      \
135      "lw    %[temp0],  0(%[temp2])              \n\t"      \
136      "addu  %[temp0],  %[temp0],    %[streak]   \n\t"      \
137      "sw    %[temp0],  0(%[temp2])              \n\t"      \
138    "2:                                          \n\t"      \
139      : [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),           \
140        [temp3]"=&r"(temp3), [temp0]"+r"(temp0)             \
141      : [pstreaks]"r"(pstreaks), [pcnts]"r"(pcnts),         \
142        [streak]"r"(streak)                                 \
143      : "memory"                                            \
144    );
145  static WEBP_INLINE void GetEntropyUnrefinedHelper(
146      uint32_t val, int i, uint32_t* const val_prev, int* const i_prev,
147      VP8LBitEntropy* const bit_entropy, VP8LStreaks* const stats) {
148    int* const pstreaks = &stats->streaks[0][0];
149    int* const pcnts = &stats->counts[0];
150    int temp0, temp1, temp2, temp3;
151    const int streak = i - *i_prev;
152    if (*val_prev != 0) {
153      bit_entropy->sum += (*val_prev) * streak;
154      bit_entropy->nonzeros += streak;
155      bit_entropy->nonzero_code = *i_prev;
156      bit_entropy->entropy -= VP8LFastSLog2(*val_prev) * streak;
157      if (bit_entropy->max_val < *val_prev) {
158        bit_entropy->max_val = *val_prev;
159      }
160    }
161    temp0 = (*val_prev != 0);
162    HUFFMAN_COST_PASS
163    *val_prev = val;
164    *i_prev = i;
165  }
166  static void GetEntropyUnrefined_MIPS32(const uint32_t X[], int length,
167                                         VP8LBitEntropy* const bit_entropy,
168                                         VP8LStreaks* const stats) {
169    int i;
170    int i_prev = 0;
171    uint32_t x_prev = X[0];
172    memset(stats, 0, sizeof(*stats));
173    VP8LBitEntropyInit(bit_entropy);
174    for (i = 1; i < length; ++i) {
175      const uint32_t x = X[i];
176      if (x != x_prev) {
177        GetEntropyUnrefinedHelper(x, i, &x_prev, &i_prev, bit_entropy, stats);
178      }
179    }
180    GetEntropyUnrefinedHelper(0, i, &x_prev, &i_prev, bit_entropy, stats);
181    bit_entropy->entropy += VP8LFastSLog2(bit_entropy->sum);
182  }
183  static void GetCombinedEntropyUnrefined_MIPS32(const uint32_t X[],
184                                                 const uint32_t Y[],
185                                                 int length,
186                                                 VP8LBitEntropy* const entropy,
187                                                 VP8LStreaks* const stats) {
188    int i = 1;
189    int i_prev = 0;
190    uint32_t xy_prev = X[0] + Y[0];
191    memset(stats, 0, sizeof(*stats));
192    VP8LBitEntropyInit(entropy);
193    for (i = 1; i < length; ++i) {
194      const uint32_t xy = X[i] + Y[i];
195      if (xy != xy_prev) {
196        GetEntropyUnrefinedHelper(xy, i, &xy_prev, &i_prev, entropy, stats);
197      }
198    }
199    GetEntropyUnrefinedHelper(0, i, &xy_prev, &i_prev, entropy, stats);
200    entropy->entropy += VP8LFastSLog2(entropy->sum);
201  }
202  #define ASM_START                                       \
203    __asm__ volatile(                                     \
204      ".set   push                            \n\t"       \
205      ".set   at                              \n\t"       \
206      ".set   macro                           \n\t"       \
207    "1:                                       \n\t"
208  #define ADD_TO_OUT(A, B, C, D, E, P0, P1, P2)           \
209      "ulw    %[temp0], " #A "(%[" #P0 "])    \n\t"       \
210      "ulw    %[temp1], " #B "(%[" #P0 "])    \n\t"       \
211      "ulw    %[temp2], " #C "(%[" #P0 "])    \n\t"       \
212      "ulw    %[temp3], " #D "(%[" #P0 "])    \n\t"       \
213      "ulw    %[temp4], " #A "(%[" #P1 "])    \n\t"       \
214      "ulw    %[temp5], " #B "(%[" #P1 "])    \n\t"       \
215      "ulw    %[temp6], " #C "(%[" #P1 "])    \n\t"       \
216      "ulw    %[temp7], " #D "(%[" #P1 "])    \n\t"       \
217      "addu   %[temp4], %[temp4],   %[temp0]  \n\t"       \
218      "addu   %[temp5], %[temp5],   %[temp1]  \n\t"       \
219      "addu   %[temp6], %[temp6],   %[temp2]  \n\t"       \
220      "addu   %[temp7], %[temp7],   %[temp3]  \n\t"       \
221      "addiu  %[" #P0 "],  %[" #P0 "],  16    \n\t"       \
222    ".if " #E " == 1                          \n\t"       \
223      "addiu  %[" #P1 "],  %[" #P1 "],  16    \n\t"       \
224    ".endif                                   \n\t"       \
225      "usw    %[temp4], " #A "(%[" #P2 "])    \n\t"       \
226      "usw    %[temp5], " #B "(%[" #P2 "])    \n\t"       \
227      "usw    %[temp6], " #C "(%[" #P2 "])    \n\t"       \
228      "usw    %[temp7], " #D "(%[" #P2 "])    \n\t"       \
229      "addiu  %[" #P2 "], %[" #P2 "],   16    \n\t"       \
230      "bne    %[" #P0 "], %[LoopEnd], 1b      \n\t"       \
231      ".set   pop                             \n\t"       \
232  
233  #define ASM_END_COMMON_0                                \
234      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),         \
235        [temp2]"=&r"(temp2), [temp3]"=&r"(temp3),         \
236        [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),         \
237        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7),         \
238        [pa]"+r"(pa), [pout]"+r"(pout)
239  #define ASM_END_COMMON_1                                \
240      : [LoopEnd]"r"(LoopEnd)                             \
241      : "memory", "at"                                    \
242    );
243  #define ASM_END_0                                       \
244      ASM_END_COMMON_0                                    \
245        , [pb]"+r"(pb)                                    \
246      ASM_END_COMMON_1
247  #define ASM_END_1                                       \
248      ASM_END_COMMON_0                                    \
249      ASM_END_COMMON_1
250  static void AddVector_MIPS32(const uint32_t* pa, const uint32_t* pb,
251                               uint32_t* pout, int size) {
252    uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
253    const uint32_t end = ((size) / 4) * 4;
254    const uint32_t* const LoopEnd = pa + end;
255    int i;
256    ASM_START
257    ADD_TO_OUT(0, 4, 8, 12, 1, pa, pb, pout)
258    ASM_END_0
259    for (i = end; i < size; ++i) pout[i] = pa[i] + pb[i];
260  }
261  static void AddVectorEq_MIPS32(const uint32_t* pa, uint32_t* pout, int size) {
262    uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
263    const uint32_t end = ((size) / 4) * 4;
264    const uint32_t* const LoopEnd = pa + end;
265    int i;
266    ASM_START
267    ADD_TO_OUT(0, 4, 8, 12, 0, pa, pout, pout)
268    ASM_END_1
269    for (i = end; i < size; ++i) pout[i] += pa[i];
270  }
271  #undef ASM_END_1
272  #undef ASM_END_0
273  #undef ASM_END_COMMON_1
274  #undef ASM_END_COMMON_0
275  #undef ADD_TO_OUT
276  #undef ASM_START
277  extern void VP8LEncDspInitMIPS32(void);
278  WEBP_TSAN_IGNORE_FUNCTION void VP8LEncDspInitMIPS32(void) {
279    VP8LFastSLog2Slow = FastSLog2Slow_MIPS32;
280    VP8LFastLog2Slow = FastLog2Slow_MIPS32;
281    VP8LExtraCost = ExtraCost_MIPS32;
282    VP8LExtraCostCombined = ExtraCostCombined_MIPS32;
283    VP8LGetEntropyUnrefined = GetEntropyUnrefined_MIPS32;
284    VP8LGetCombinedEntropyUnrefined = GetCombinedEntropyUnrefined_MIPS32;
285    VP8LAddVector = AddVector_MIPS32;
286    VP8LAddVectorEq = AddVectorEq_MIPS32;
287  }
288  #else  
289  WEBP_DSP_INIT_STUB(VP8LEncDspInitMIPS32)
290  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_mips32.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #include "src/dsp/lossless.h"
3  #include "src/dsp/lossless_common.h"
4  #if defined(WEBP_USE_MIPS32)
5  #include <assert.h>
6  #include <math.h>
7  #include <stdlib.h>
8  #include <string.h>
9  static float FastSLog2Slow_MIPS32(uint32_t v) {
10    assert(v >= LOG_LOOKUP_IDX_MAX);
11    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
12      uint32_t log_cnt, y, correction;
13      const int c24 = 24;
14      const float v_f = (float)v;
15      uint32_t temp;
16      __asm__ volatile(
17        "clz      %[log_cnt], %[v]                      \n\t"
18        "addiu    %[y],       $zero,        1           \n\t"
19        "subu     %[log_cnt], %[c24],       %[log_cnt]  \n\t"
20        "sllv     %[y],       %[y],         %[log_cnt]  \n\t"
21        "srlv     %[temp],    %[v],         %[log_cnt]  \n\t"
22        : [log_cnt]"=&r"(log_cnt), [y]"=&r"(y),
23          [temp]"=r"(temp)
24        : [c24]"r"(c24), [v]"r"(v)
25      );
26      correction = (23 * (v & (y - 1))) >> 4;
27      return v_f * (kLog2Table[temp] + log_cnt) + correction;
28    } else {
29      return (float)(LOG_2_RECIPROCAL * v * log((double)v));
30    }
31  }
32  static float FastLog2Slow_MIPS32(uint32_t v) {
33    assert(v >= LOG_LOOKUP_IDX_MAX);
34    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
35      uint32_t log_cnt, y;
36      const int c24 = 24;
37      double log_2;
38      uint32_t temp;
39      __asm__ volatile(
40        "clz      %[log_cnt], %[v]                      \n\t"
41        "addiu    %[y],       $zero,        1           \n\t"
42        "subu     %[log_cnt], %[c24],       %[log_cnt]  \n\t"
43        "sllv     %[y],       %[y],         %[log_cnt]  \n\t"
44        "srlv     %[temp],    %[v],         %[log_cnt]  \n\t"
45        : [log_cnt]"=&r"(log_cnt), [y]"=&r"(y),
46          [temp]"=r"(temp)
47        : [c24]"r"(c24), [v]"r"(v)
48      );
49      log_2 = kLog2Table[temp] + log_cnt;
50      if (v >= APPROX_LOG_MAX) {
51        const uint32_t correction = (23 * (v & (y - 1))) >> 4;
52        log_2 += (double)correction / v;
53      }
54      return (float)log_2;
55    } else {
56      return (float)(LOG_2_RECIPROCAL * log((double)v));
57    }
58  }
59  static double ExtraCost_MIPS32(const uint32_t* const population, int length) {
60    int i, temp0, temp1;
<span onclick='openModal()' class='match'>61    const uint32_t* pop = &population[4];
62    const uint32_t* const LoopEnd = &population[length];
63    __asm__ volatile(
64      "mult   $zero,    $zero                  \n\t"
65      "xor    %[i],     %[i],       %[i]       \n\t"
66      "beq    %[pop],   %[LoopEnd], 2f         \n\t"
67    "1:                                        \n\t"
68      "lw     %[temp0], 0(%[pop])              \n\t"
69      "lw     %[temp1], 4(%[pop])              \n\t"
70      "addiu  %[i],     %[i],       1          \n\t"
71      "addiu  %[pop],   %[pop],     8          \n\t"
72      "madd   %[i],     %[temp0]               \n\t"
73      "madd   %[i],     %[temp1]               \n\t"
74      "bne    %[pop],   %[LoopEnd], 1b         \n\t"
75    "2:                                        \n\t"
76      "mfhi   %[temp0]                         \n\t"
77      "mflo   %[temp1]                         \n\t"
78      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),
</span>79        [i]"=&r"(i), [pop]"+r"(pop)
80      : [LoopEnd]"r"(LoopEnd)
81      : "memory", "hi", "lo"
82    );
83    return (double)((int64_t)temp0 << 32 | temp1);
84  }
85  static double ExtraCostCombined_MIPS32(const uint32_t* const X,
86                                         const uint32_t* const Y, int length) {
87    int i, temp0, temp1, temp2, temp3;
88    const uint32_t* pX = &X[4];
89    const uint32_t* pY = &Y[4];
90    const uint32_t* const LoopEnd = &X[length];
91    __asm__ volatile(
92      "mult   $zero,    $zero                  \n\t"
93      "xor    %[i],     %[i],       %[i]       \n\t"
94      "beq    %[pX],    %[LoopEnd], 2f         \n\t"
95    "1:                                        \n\t"
96      "lw     %[temp0], 0(%[pX])               \n\t"
97      "lw     %[temp1], 0(%[pY])               \n\t"
98      "lw     %[temp2], 4(%[pX])               \n\t"
99      "lw     %[temp3], 4(%[pY])               \n\t"
100      "addiu  %[i],     %[i],       1          \n\t"
101      "addu   %[temp0], %[temp0],   %[temp1]   \n\t"
102      "addu   %[temp2], %[temp2],   %[temp3]   \n\t"
103      "addiu  %[pX],    %[pX],      8          \n\t"
104      "addiu  %[pY],    %[pY],      8          \n\t"
105      "madd   %[i],     %[temp0]               \n\t"
106      "madd   %[i],     %[temp2]               \n\t"
107      "bne    %[pX],    %[LoopEnd], 1b         \n\t"
108    "2:                                        \n\t"
109      "mfhi   %[temp0]                         \n\t"
110      "mflo   %[temp1]                         \n\t"
111      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),
112        [temp2]"=&r"(temp2), [temp3]"=&r"(temp3),
113        [i]"=&r"(i), [pX]"+r"(pX), [pY]"+r"(pY)
114      : [LoopEnd]"r"(LoopEnd)
115      : "memory", "hi", "lo"
116    );
117    return (double)((int64_t)temp0 << 32 | temp1);
118  }
119  #define HUFFMAN_COST_PASS                                 \
120    __asm__ volatile(                                       \
121      "sll   %[temp1],  %[temp0],    3           \n\t"      \
122      "addiu %[temp3],  %[streak],   -3          \n\t"      \
123      "addu  %[temp2],  %[pstreaks], %[temp1]    \n\t"      \
124      "blez  %[temp3],  1f                       \n\t"      \
125      "srl   %[temp1],  %[temp1],    1           \n\t"      \
126      "addu  %[temp3],  %[pcnts],    %[temp1]    \n\t"      \
127      "lw    %[temp0],  4(%[temp2])              \n\t"      \
128      "lw    %[temp1],  0(%[temp3])              \n\t"      \
129      "addu  %[temp0],  %[temp0],    %[streak]   \n\t"      \
130      "addiu %[temp1],  %[temp1],    1           \n\t"      \
131      "sw    %[temp0],  4(%[temp2])              \n\t"      \
132      "sw    %[temp1],  0(%[temp3])              \n\t"      \
133      "b     2f                                  \n\t"      \
134    "1:                                          \n\t"      \
135      "lw    %[temp0],  0(%[temp2])              \n\t"      \
136      "addu  %[temp0],  %[temp0],    %[streak]   \n\t"      \
137      "sw    %[temp0],  0(%[temp2])              \n\t"      \
138    "2:                                          \n\t"      \
139      : [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),           \
140        [temp3]"=&r"(temp3), [temp0]"+r"(temp0)             \
141      : [pstreaks]"r"(pstreaks), [pcnts]"r"(pcnts),         \
142        [streak]"r"(streak)                                 \
143      : "memory"                                            \
144    );
145  static WEBP_INLINE void GetEntropyUnrefinedHelper(
146      uint32_t val, int i, uint32_t* const val_prev, int* const i_prev,
147      VP8LBitEntropy* const bit_entropy, VP8LStreaks* const stats) {
148    int* const pstreaks = &stats->streaks[0][0];
149    int* const pcnts = &stats->counts[0];
150    int temp0, temp1, temp2, temp3;
151    const int streak = i - *i_prev;
152    if (*val_prev != 0) {
153      bit_entropy->sum += (*val_prev) * streak;
154      bit_entropy->nonzeros += streak;
155      bit_entropy->nonzero_code = *i_prev;
156      bit_entropy->entropy -= VP8LFastSLog2(*val_prev) * streak;
157      if (bit_entropy->max_val < *val_prev) {
158        bit_entropy->max_val = *val_prev;
159      }
160    }
161    temp0 = (*val_prev != 0);
162    HUFFMAN_COST_PASS
163    *val_prev = val;
164    *i_prev = i;
165  }
166  static void GetEntropyUnrefined_MIPS32(const uint32_t X[], int length,
167                                         VP8LBitEntropy* const bit_entropy,
168                                         VP8LStreaks* const stats) {
169    int i;
170    int i_prev = 0;
171    uint32_t x_prev = X[0];
172    memset(stats, 0, sizeof(*stats));
173    VP8LBitEntropyInit(bit_entropy);
174    for (i = 1; i < length; ++i) {
175      const uint32_t x = X[i];
176      if (x != x_prev) {
177        GetEntropyUnrefinedHelper(x, i, &x_prev, &i_prev, bit_entropy, stats);
178      }
179    }
180    GetEntropyUnrefinedHelper(0, i, &x_prev, &i_prev, bit_entropy, stats);
181    bit_entropy->entropy += VP8LFastSLog2(bit_entropy->sum);
182  }
183  static void GetCombinedEntropyUnrefined_MIPS32(const uint32_t X[],
184                                                 const uint32_t Y[],
185                                                 int length,
186                                                 VP8LBitEntropy* const entropy,
187                                                 VP8LStreaks* const stats) {
188    int i = 1;
189    int i_prev = 0;
190    uint32_t xy_prev = X[0] + Y[0];
191    memset(stats, 0, sizeof(*stats));
192    VP8LBitEntropyInit(entropy);
193    for (i = 1; i < length; ++i) {
194      const uint32_t xy = X[i] + Y[i];
195      if (xy != xy_prev) {
196        GetEntropyUnrefinedHelper(xy, i, &xy_prev, &i_prev, entropy, stats);
197      }
198    }
199    GetEntropyUnrefinedHelper(0, i, &xy_prev, &i_prev, entropy, stats);
200    entropy->entropy += VP8LFastSLog2(entropy->sum);
201  }
202  #define ASM_START                                       \
203    __asm__ volatile(                                     \
204      ".set   push                            \n\t"       \
205      ".set   at                              \n\t"       \
206      ".set   macro                           \n\t"       \
207    "1:                                       \n\t"
208  #define ADD_TO_OUT(A, B, C, D, E, P0, P1, P2)           \
209      "ulw    %[temp0], " #A "(%[" #P0 "])    \n\t"       \
210      "ulw    %[temp1], " #B "(%[" #P0 "])    \n\t"       \
211      "ulw    %[temp2], " #C "(%[" #P0 "])    \n\t"       \
212      "ulw    %[temp3], " #D "(%[" #P0 "])    \n\t"       \
213      "ulw    %[temp4], " #A "(%[" #P1 "])    \n\t"       \
214      "ulw    %[temp5], " #B "(%[" #P1 "])    \n\t"       \
215      "ulw    %[temp6], " #C "(%[" #P1 "])    \n\t"       \
216      "ulw    %[temp7], " #D "(%[" #P1 "])    \n\t"       \
217      "addu   %[temp4], %[temp4],   %[temp0]  \n\t"       \
218      "addu   %[temp5], %[temp5],   %[temp1]  \n\t"       \
219      "addu   %[temp6], %[temp6],   %[temp2]  \n\t"       \
220      "addu   %[temp7], %[temp7],   %[temp3]  \n\t"       \
221      "addiu  %[" #P0 "],  %[" #P0 "],  16    \n\t"       \
222    ".if " #E " == 1                          \n\t"       \
223      "addiu  %[" #P1 "],  %[" #P1 "],  16    \n\t"       \
224    ".endif                                   \n\t"       \
225      "usw    %[temp4], " #A "(%[" #P2 "])    \n\t"       \
226      "usw    %[temp5], " #B "(%[" #P2 "])    \n\t"       \
227      "usw    %[temp6], " #C "(%[" #P2 "])    \n\t"       \
228      "usw    %[temp7], " #D "(%[" #P2 "])    \n\t"       \
229      "addiu  %[" #P2 "], %[" #P2 "],   16    \n\t"       \
230      "bne    %[" #P0 "], %[LoopEnd], 1b      \n\t"       \
231      ".set   pop                             \n\t"       \
232  
233  #define ASM_END_COMMON_0                                \
234      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),         \
235        [temp2]"=&r"(temp2), [temp3]"=&r"(temp3),         \
236        [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),         \
237        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7),         \
238        [pa]"+r"(pa), [pout]"+r"(pout)
239  #define ASM_END_COMMON_1                                \
240      : [LoopEnd]"r"(LoopEnd)                             \
241      : "memory", "at"                                    \
242    );
243  #define ASM_END_0                                       \
244      ASM_END_COMMON_0                                    \
245        , [pb]"+r"(pb)                                    \
246      ASM_END_COMMON_1
247  #define ASM_END_1                                       \
248      ASM_END_COMMON_0                                    \
249      ASM_END_COMMON_1
250  static void AddVector_MIPS32(const uint32_t* pa, const uint32_t* pb,
251                               uint32_t* pout, int size) {
252    uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
253    const uint32_t end = ((size) / 4) * 4;
254    const uint32_t* const LoopEnd = pa + end;
255    int i;
256    ASM_START
257    ADD_TO_OUT(0, 4, 8, 12, 1, pa, pb, pout)
258    ASM_END_0
259    for (i = end; i < size; ++i) pout[i] = pa[i] + pb[i];
260  }
261  static void AddVectorEq_MIPS32(const uint32_t* pa, uint32_t* pout, int size) {
262    uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
263    const uint32_t end = ((size) / 4) * 4;
264    const uint32_t* const LoopEnd = pa + end;
265    int i;
266    ASM_START
267    ADD_TO_OUT(0, 4, 8, 12, 0, pa, pout, pout)
268    ASM_END_1
269    for (i = end; i < size; ++i) pout[i] += pa[i];
270  }
271  #undef ASM_END_1
272  #undef ASM_END_0
273  #undef ASM_END_COMMON_1
274  #undef ASM_END_COMMON_0
275  #undef ADD_TO_OUT
276  #undef ASM_START
277  extern void VP8LEncDspInitMIPS32(void);
278  WEBP_TSAN_IGNORE_FUNCTION void VP8LEncDspInitMIPS32(void) {
279    VP8LFastSLog2Slow = FastSLog2Slow_MIPS32;
280    VP8LFastLog2Slow = FastLog2Slow_MIPS32;
281    VP8LExtraCost = ExtraCost_MIPS32;
282    VP8LExtraCostCombined = ExtraCostCombined_MIPS32;
283    VP8LGetEntropyUnrefined = GetEntropyUnrefined_MIPS32;
284    VP8LGetCombinedEntropyUnrefined = GetCombinedEntropyUnrefined_MIPS32;
285    VP8LAddVector = AddVector_MIPS32;
286    VP8LAddVectorEq = AddVectorEq_MIPS32;
287  }
288  #else  
289  WEBP_DSP_INIT_STUB(VP8LEncDspInitMIPS32)
290  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_mips32.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_mips32.c</div>
                </div>
                <div class="column column_space"><pre><code>61    const uint32_t* pop = &population[4];
62    const uint32_t* const LoopEnd = &population[length];
63    __asm__ volatile(
64      "mult   $zero,    $zero                  \n\t"
65      "xor    %[i],     %[i],       %[i]       \n\t"
66      "beq    %[pop],   %[LoopEnd], 2f         \n\t"
67    "1:                                        \n\t"
68      "lw     %[temp0], 0(%[pop])              \n\t"
69      "lw     %[temp1], 4(%[pop])              \n\t"
70      "addiu  %[i],     %[i],       1          \n\t"
71      "addiu  %[pop],   %[pop],     8          \n\t"
72      "madd   %[i],     %[temp0]               \n\t"
73      "madd   %[i],     %[temp1]               \n\t"
74      "bne    %[pop],   %[LoopEnd], 1b         \n\t"
75    "2:                                        \n\t"
76      "mfhi   %[temp0]                         \n\t"
77      "mflo   %[temp1]                         \n\t"
78      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),
</pre></code></div>
                <div class="column column_space"><pre><code>61    const uint32_t* pop = &population[4];
62    const uint32_t* const LoopEnd = &population[length];
63    __asm__ volatile(
64      "mult   $zero,    $zero                  \n\t"
65      "xor    %[i],     %[i],       %[i]       \n\t"
66      "beq    %[pop],   %[LoopEnd], 2f         \n\t"
67    "1:                                        \n\t"
68      "lw     %[temp0], 0(%[pop])              \n\t"
69      "lw     %[temp1], 4(%[pop])              \n\t"
70      "addiu  %[i],     %[i],       1          \n\t"
71      "addiu  %[pop],   %[pop],     8          \n\t"
72      "madd   %[i],     %[temp0]               \n\t"
73      "madd   %[i],     %[temp1]               \n\t"
74      "bne    %[pop],   %[LoopEnd], 1b         \n\t"
75    "2:                                        \n\t"
76      "mfhi   %[temp0]                         \n\t"
77      "mflo   %[temp1]                         \n\t"
78      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    