<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for omhttp.c & mmkubernetes.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for omhttp.c & mmkubernetes.c
      </h3>
      <h1 align="center">
        14.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>omhttp.c (15.046839%)<TH>mmkubernetes.c (14.261931%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#0',2,'match369-1.html#0',3)" NAME="0">(200-228)<TD><A HREF="javascript:ZweiFrames('match369-0.html#0',2,'match369-1.html#0',3)" NAME="0">(221-253)</A><TD ALIGN=center><FONT COLOR="#ff0000">52</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#1',2,'match369-1.html#1',3)" NAME="1">(1892-1902)<TD><A HREF="javascript:ZweiFrames('match369-0.html#1',2,'match369-1.html#1',3)" NAME="1">(642-654)</A><TD ALIGN=center><FONT COLOR="#8e0000">29</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#2',2,'match369-1.html#2',3)" NAME="2">(1831-1838)<TD><A HREF="javascript:ZweiFrames('match369-0.html#2',2,'match369-1.html#2',3)" NAME="2">(589-602)</A><TD ALIGN=center><FONT COLOR="#750000">24</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#3',2,'match369-1.html#3',3)" NAME="3">(189-199)<TD><A HREF="javascript:ZweiFrames('match369-0.html#3',2,'match369-1.html#3',3)" NAME="3">(253-263)</A><TD ALIGN=center><FONT COLOR="#700000">23</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#4',2,'match369-1.html#4',3)" NAME="4">(1930-1938)<TD><A HREF="javascript:ZweiFrames('match369-0.html#4',2,'match369-1.html#4',3)" NAME="4">(1344-1354)</A><TD ALIGN=center><FONT COLOR="#6b0000">22</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#5',2,'match369-1.html#5',3)" NAME="5">(1874-1882)<TD><A HREF="javascript:ZweiFrames('match369-0.html#5',2,'match369-1.html#5',3)" NAME="5">(712-725)</A><TD ALIGN=center><FONT COLOR="#660000">21</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#6',2,'match369-1.html#6',3)" NAME="6">(1862-1870)<TD><A HREF="javascript:ZweiFrames('match369-0.html#6',2,'match369-1.html#6',3)" NAME="6">(1416-1429)</A><TD ALIGN=center><FONT COLOR="#5d0000">19</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#7',2,'match369-1.html#7',3)" NAME="7">(1919-1924)<TD><A HREF="javascript:ZweiFrames('match369-0.html#7',2,'match369-1.html#7',3)" NAME="7">(628-633)</A><TD ALIGN=center><FONT COLOR="#440000">14</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#8',2,'match369-1.html#8',3)" NAME="8">(1908-1913)<TD><A HREF="javascript:ZweiFrames('match369-0.html#8',2,'match369-1.html#8',3)" NAME="8">(614-620)</A><TD ALIGN=center><FONT COLOR="#440000">14</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#9',2,'match369-1.html#9',3)" NAME="9">(1848-1852)<TD><A HREF="javascript:ZweiFrames('match369-0.html#9',2,'match369-1.html#9',3)" NAME="9">(1296-1306)</A><TD ALIGN=center><FONT COLOR="#440000">14</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#10',2,'match369-1.html#10',3)" NAME="10">(1823-1827)<TD><A HREF="javascript:ZweiFrames('match369-0.html#10',2,'match369-1.html#10',3)" NAME="10">(668-674)</A><TD ALIGN=center><FONT COLOR="#3f0000">13</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match369-0.html#11',2,'match369-1.html#11',3)" NAME="11">(1854-1858)<TD><A HREF="javascript:ZweiFrames('match369-0.html#11',2,'match369-1.html#11',3)" NAME="11">(1369-1375)</A><TD ALIGN=center><FONT COLOR="#3a0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omhttp.c
 * This is an http output module based on omelasticsearch
 *
 * NOTE: read comments in module-template.h for more specifics!
 *
 * Copyright 2011 Nathan Scott.
 * Copyright 2009-2018 Rainer Gerhards and Adiscon GmbH.
 * Copyright 2018 Christian Tramnitz
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;curl/easy.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#if defined(__FreeBSD__)
#include &lt;unistd.h&gt;
#endif
#include &lt;json.h&gt;
#include &lt;zlib.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;obj-types.h&quot;
#include &quot;ratelimit.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;statsobj.h&quot;

#ifndef O_LARGEFILE
#  define O_LARGEFILE 0
#endif

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omhttp&quot;)

/* internal structures */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(statsobj)

statsobj_t *httpStats;
STATSCOUNTER_DEF(ctrMessagesSubmitted, mutCtrMessagesSubmitted); // Number of message submitted to module
STATSCOUNTER_DEF(ctrMessagesSuccess, mutCtrMessagesSuccess); // Number of messages successfully sent
STATSCOUNTER_DEF(ctrMessagesFail, mutCtrMessagesFail); // Number of messages that failed to send
STATSCOUNTER_DEF(ctrMessagesRetry, mutCtrMessagesRetry); // Number of messages requeued for retry
STATSCOUNTER_DEF(ctrHttpRequestCount, mutCtrHttpRequestCount); // Number of attempted HTTP requests
STATSCOUNTER_DEF(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess); // Number of successful HTTP requests
STATSCOUNTER_DEF(ctrHttpRequestFail, mutCtrHttpRequestFail); // Number of failed HTTP req, 4XX+ are NOT failures
STATSCOUNTER_DEF(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess); // Number of requests returning 1XX/2XX status
STATSCOUNTER_DEF(ctrHttpStatusFail, mutCtrHttpStatusFail); // Number of requests returning 300+ status

static prop_t *pInputName = NULL;

#define WRKR_DATA_TYPE_ES 0xBADF0001

#define HTTP_HEADER_CONTENT_JSON &quot;Content-Type: application/json; charset=utf-8&quot;
#define HTTP_HEADER_CONTENT_TEXT &quot;Content-Type: text/plain&quot;
#define HTTP_HEADER_CONTENT_KAFKA &quot;Content-Type: application/vnd.kafka.v1+json&quot;
#define HTTP_HEADER_ENCODING_GZIP &quot;Content-Encoding: gzip&quot;
#define HTTP_HEADER_EXPECT_EMPTY &quot;Expect:&quot;

#define VALID_BATCH_FORMATS &quot;newline jsonarray kafkarest lokirest&quot;
typedef enum batchFormat_e {
	FMT_NEWLINE,
	FMT_JSONARRAY,
	FMT_KAFKAREST,
	FMT_LOKIREST
} batchFormat_t;

/* REST API uses this URL:
 * https://&lt;hostName&gt;:&lt;restPort&gt;/restPath
*/
typedef struct curl_slist HEADER;
typedef struct instanceConf_s {
	int defaultPort;
	int fdErrFile;		/* error file fd or -1 if not open */
	pthread_mutex_t mutErrFile;
	uchar **serverBaseUrls;
	int numServers;
	long healthCheckTimeout;
	uchar *uid;
	uchar *pwd;
	uchar *authBuf;
	uchar *httpcontenttype;
	uchar *headerContentTypeBuf;
	uchar *httpheaderkey;
	uchar *httpheadervalue;
	uchar *headerBuf;
	uchar **httpHeaders;
	int nHttpHeaders;
	uchar *restPath;
	uchar *checkPath;
	uchar *tplName;
	uchar *errorFile;
	sbool batchMode;
	uchar *batchFormatName;
	batchFormat_t batchFormat;
	sbool bFreeBatchFormatName;
	sbool dynRestPath;
	size_t maxBatchBytes;
	size_t maxBatchSize;
	sbool compress;
	int compressionLevel;	/* Compression level for zlib, default=-1, fastest=1, best=9, none=0*/
	sbool useHttps;
	sbool allowUnsignedCerts;
	sbool skipVerifyHost;
	uchar *caCertFile;
	uchar *myCertFile;
	uchar *myPrivKeyFile;
	sbool reloadOnHup;
	sbool retryFailures;
	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	/* for retries */
	ratelimit_t *ratelimiter;
	uchar *retryRulesetName;
	ruleset_t *retryRuleset;
	struct instanceConf_s *next;
} instanceData;

struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
};
static modConfData_t *loadModConf = NULL;	/* modConf ptr to use for the current load process */

typedef struct wrkrInstanceData {
	PTR_ASSERT_DEF
	instanceData *pData;
	int serverIndex;
	int replyLen;
	char *reply;
	long httpStatusCode;	/* http status code of response */
	CURL	*curlCheckConnHandle;	/* libcurl session handle for checking the server connection */
	CURL	*curlPostHandle;	/* libcurl session handle for posting data to the server */
	HEADER	*curlHeader;	/* json POST request info */
	uchar *restURL;		/* last used URL for error reporting */
	sbool bzInitDone;
	z_stream zstrm; /* zip stream to use for gzip http compression */
	struct {
		uchar **data;		/* array of strings, this will be batched up lazily */
		uchar *restPath;	/* Helper for restpath in batch mode */
		size_t sizeBytes;	/* total length of this batch in bytes */
		size_t nmemb;		/* number of messages in batch (for statistics counting) */

	} batch;
	struct {
		uchar *buf;
		size_t curLen;
		size_t len;
	} compressCtx;
} wrkrInstanceData_t;
<A NAME="3"></A>
/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match369-1.html#3',3,'match369-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static struct cnfparamdescr actpdescr[] = {
	{ &quot;server&quot;, eCmdHdlrArray, 0 },
	{ &quot;serverport&quot;, eCmdHdlrInt, 0 },
	{ &quot;healthchecktimeout&quot;, eCmdHdlrInt, 0 },
	{ &quot;httpcontenttype&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;httpheaderkey&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;httpheadervalue&quot;, eCmdHdlrString, 0 },
	{ &quot;httpheaders&quot;, eCmdHdlrArray, 0 },
<A NAME="0"></A>	{ &quot;uid&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;pwd&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;restpath&quot;, eCmdHdlrGetWord, 0 },</B></FONT>
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match369-1.html#0',3,'match369-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;checkpath&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;dynrestpath&quot;, eCmdHdlrBinary, 0 },
	{ &quot;batch&quot;, eCmdHdlrBinary, 0 },
	{ &quot;batch.format&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;batch.maxbytes&quot;, eCmdHdlrSize, 0 },
	{ &quot;batch.maxsize&quot;, eCmdHdlrSize, 0 },
	{ &quot;compress&quot;, eCmdHdlrBinary, 0 },
	{ &quot;compress.level&quot;, eCmdHdlrInt, 0 },
	{ &quot;usehttps&quot;, eCmdHdlrBinary, 0 },
	{ &quot;errorfile&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;allowunsignedcerts&quot;, eCmdHdlrBinary, 0 },
	{ &quot;skipverifyhost&quot;, eCmdHdlrBinary, 0 },
	{ &quot;tls.cacert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.mycert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.myprivkey&quot;, eCmdHdlrString, 0 },
	{ &quot;reloadonhup&quot;, eCmdHdlrBinary, 0 },
	{ &quot;retry&quot;, eCmdHdlrBinary, 0 },
	{ &quot;retry.ruleset&quot;, eCmdHdlrString, 0 },
	{ &quot;ratelimit.interval&quot;, eCmdHdlrInt, 0 },
	{ &quot;ratelimit.burst&quot;, eCmdHdlrInt, 0 },
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

static rsRetVal curlSetup(wrkrInstanceData_t *pWrkrData);</B></FONT>
static void curlCleanup(wrkrInstanceData_t *pWrkrData);
static void curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData);

/* compressCtx functions */
static void ATTR_NONNULL()
initCompressCtx(wrkrInstanceData_t *pWrkrData);

static void ATTR_NONNULL()
freeCompressCtx(wrkrInstanceData_t *pWrkrData);

static rsRetVal ATTR_NONNULL()
resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len);

static rsRetVal ATTR_NONNULL()
growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen);

static rsRetVal ATTR_NONNULL()
appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen);

BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;fdErrFile = -1;
	pthread_mutex_init(&amp;pData-&gt;mutErrFile, NULL);
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
	pData-&gt;ratelimiter = NULL;
	pData-&gt;retryRulesetName = NULL;
	pData-&gt;retryRuleset = NULL;
ENDcreateInstance

BEGINcreateWrkrInstance
uchar **batchData;
CODESTARTcreateWrkrInstance
	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
	pWrkrData-&gt;curlHeader = NULL;
	pWrkrData-&gt;curlPostHandle = NULL;
	pWrkrData-&gt;curlCheckConnHandle = NULL;
	pWrkrData-&gt;serverIndex = 0;
	pWrkrData-&gt;httpStatusCode = 0;
	pWrkrData-&gt;restURL = NULL;
	pWrkrData-&gt;bzInitDone = 0;
	if(pData-&gt;batchMode) {
		pWrkrData-&gt;batch.nmemb = 0;
		pWrkrData-&gt;batch.sizeBytes = 0;
		batchData = (uchar **) malloc(pData-&gt;maxBatchSize * sizeof(uchar *));
		if (batchData == NULL) {
			LogError(0, RS_RET_OUT_OF_MEMORY,
				&quot;omhttp: cannot allocate memory for batch queue turning off batch mode\n&quot;);
			pData-&gt;batchMode = 0; /* at least it works */
		} else {
			pWrkrData-&gt;batch.data = batchData;
			pWrkrData-&gt;batch.restPath = NULL;
		}
	}
	initCompressCtx(pWrkrData);
	iRet = curlSetup(pWrkrData);
ENDcreateWrkrInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINfreeInstance
	int i;
CODESTARTfreeInstance
	if(pData-&gt;fdErrFile != -1)
		close(pData-&gt;fdErrFile);
	pthread_mutex_destroy(&amp;pData-&gt;mutErrFile);
	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
		free(pData-&gt;serverBaseUrls[i]);
	free(pData-&gt;serverBaseUrls);
	free(pData-&gt;uid);
	free(pData-&gt;httpcontenttype);
	free(pData-&gt;headerContentTypeBuf);
	free(pData-&gt;httpheaderkey);
	free(pData-&gt;httpheadervalue);
	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i) {
		free((void*) pData-&gt;httpHeaders[i]);
	}
	free(pData-&gt;httpHeaders);
	pData-&gt;nHttpHeaders = 0;
	free(pData-&gt;pwd);
	free(pData-&gt;authBuf);
	free(pData-&gt;headerBuf);
	free(pData-&gt;restPath);
	free(pData-&gt;checkPath);
	free(pData-&gt;tplName);
	free(pData-&gt;errorFile);
	free(pData-&gt;caCertFile);
	free(pData-&gt;myCertFile);
	free(pData-&gt;myPrivKeyFile);
	free(pData-&gt;retryRulesetName);
	if (pData-&gt;ratelimiter != NULL)
		ratelimitDestruct(pData-&gt;ratelimiter);
	if (pData-&gt;bFreeBatchFormatName)
		free(pData-&gt;batchFormatName);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	curlCleanup(pWrkrData);

	free(pWrkrData-&gt;restURL);
	pWrkrData-&gt;restURL = NULL;

	free(pWrkrData-&gt;batch.data);
	pWrkrData-&gt;batch.data = NULL;

	if (pWrkrData-&gt;batch.restPath != NULL)  {
		free(pWrkrData-&gt;batch.restPath);
		pWrkrData-&gt;batch.restPath = NULL;
	}

	if (pWrkrData-&gt;bzInitDone)
		deflateEnd(&amp;pWrkrData-&gt;zstrm);
	freeCompressCtx(pWrkrData);

ENDfreeWrkrInstance

BEGINdbgPrintInstInfo
	int i;
CODESTARTdbgPrintInstInfo
	dbgprintf(&quot;omhttp\n&quot;);
	dbgprintf(&quot;\ttemplate='%s'\n&quot;, pData-&gt;tplName);
	dbgprintf(&quot;\tnumServers=%d\n&quot;, pData-&gt;numServers);
	dbgprintf(&quot;\thealthCheckTimeout=%lu\n&quot;, pData-&gt;healthCheckTimeout);
	dbgprintf(&quot;\tserverBaseUrls=&quot;);
	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
		dbgprintf(&quot;%c'%s'&quot;, i == 0 ? '[' : ' ', pData-&gt;serverBaseUrls[i]);
	dbgprintf(&quot;]\n&quot;);
	dbgprintf(&quot;\tdefaultPort=%d\n&quot;, pData-&gt;defaultPort);
	dbgprintf(&quot;\tuid='%s'\n&quot;, pData-&gt;uid == NULL ? (uchar*)&quot;(not configured)&quot; : pData-&gt;uid);
	dbgprintf(&quot;\thttpcontenttype='%s'\n&quot;, pData-&gt;httpcontenttype == NULL ?
		(uchar*)&quot;(not configured)&quot; : pData-&gt;httpcontenttype);
	dbgprintf(&quot;\thttpheaderkey='%s'\n&quot;, pData-&gt;httpheaderkey == NULL ?
		(uchar*)&quot;(not configured)&quot; : pData-&gt;httpheaderkey);
	dbgprintf(&quot;\thttpheadervalue='%s'\n&quot;, pData-&gt;httpheadervalue == NULL ?
		(uchar*)&quot;(not configured)&quot; : pData-&gt;httpheadervalue);
	dbgprintf(&quot;\thttpHeaders=[&quot;);
	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i)
		dbgprintf(&quot;\t%s\n&quot;,pData-&gt;httpHeaders[i]);
	dbgprintf(&quot;\t]\n&quot;);
	dbgprintf(&quot;\tpwd=(%sconfigured)\n&quot;, pData-&gt;pwd == NULL ? &quot;not &quot; : &quot;&quot;);
	dbgprintf(&quot;\trest path='%s'\n&quot;, pData-&gt;restPath);
	dbgprintf(&quot;\tcheck path='%s'\n&quot;, pData-&gt;checkPath);
	dbgprintf(&quot;\tdynamic rest path=%d\n&quot;, pData-&gt;dynRestPath);
	dbgprintf(&quot;\tuse https=%d\n&quot;, pData-&gt;useHttps);
	dbgprintf(&quot;\tbatch=%d\n&quot;, pData-&gt;batchMode);
	dbgprintf(&quot;\tbatch.format='%s'\n&quot;, pData-&gt;batchFormatName);
	dbgprintf(&quot;\tbatch.maxbytes=%zu\n&quot;, pData-&gt;maxBatchBytes);
	dbgprintf(&quot;\tbatch.maxsize=%zu\n&quot;, pData-&gt;maxBatchSize);
	dbgprintf(&quot;\tcompress=%d\n&quot;, pData-&gt;compress);
	dbgprintf(&quot;\tcompress.level=%d\n&quot;, pData-&gt;compressionLevel);
	dbgprintf(&quot;\tallowUnsignedCerts=%d\n&quot;, pData-&gt;allowUnsignedCerts);
	dbgprintf(&quot;\tskipVerifyHost=%d\n&quot;, pData-&gt;skipVerifyHost);
	dbgprintf(&quot;\terrorfile='%s'\n&quot;, pData-&gt;errorFile == NULL ?
		(uchar*)&quot;(not configured)&quot; : pData-&gt;errorFile);
	dbgprintf(&quot;\ttls.cacert='%s'\n&quot;, pData-&gt;caCertFile);
	dbgprintf(&quot;\ttls.mycert='%s'\n&quot;, pData-&gt;myCertFile);
	dbgprintf(&quot;\ttls.myprivkey='%s'\n&quot;, pData-&gt;myPrivKeyFile);
	dbgprintf(&quot;\treloadonhup='%d'\n&quot;, pData-&gt;reloadOnHup);
	dbgprintf(&quot;\tretry='%d'\n&quot;, pData-&gt;retryFailures);
	dbgprintf(&quot;\tretry.ruleset='%s'\n&quot;, pData-&gt;retryRulesetName);
	dbgprintf(&quot;\tratelimit.interval='%u'\n&quot;, pData-&gt;ratelimitInterval);
	dbgprintf(&quot;\tratelimit.burst='%u'\n&quot;, pData-&gt;ratelimitBurst);
ENDdbgPrintInstInfo


/* http POST result string ... useful for debugging */
static size_t
curlResult(void *ptr, size_t size, size_t nmemb, void *userdata)
{
	char *p = (char *)ptr;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t*) userdata;
	char *buf;
	size_t newlen;
	PTR_ASSERT_CHK(pWrkrData, WRKR_DATA_TYPE_ES);
	newlen = pWrkrData-&gt;replyLen + size*nmemb;
	if((buf = realloc(pWrkrData-&gt;reply, newlen + 1)) == NULL) {
		LogError(errno, RS_RET_ERR, &quot;omhttp: realloc failed in curlResult&quot;);
		return 0; /* abort due to failure */
	}
	memcpy(buf+pWrkrData-&gt;replyLen, p, size*nmemb);
	pWrkrData-&gt;replyLen = newlen;
	pWrkrData-&gt;reply = buf;
	return size*nmemb;
}

/* Build basic URL part, which includes hostname and port as follows:
 * http://hostname:port/ based on a server param
 * Newly creates a cstr for this purpose.
 * Note: serverParam MUST NOT end in '/' (caller must strip if it exists)
 */
static rsRetVal
computeBaseUrl(const char*const serverParam,
	const int defaultPort,
	const sbool useHttps,
	uchar **baseUrl)
{
#	define SCHEME_HTTPS &quot;https://&quot;
#	define SCHEME_HTTP &quot;http://&quot;

	char portBuf[64];
	int r = 0;
	const char *host = serverParam;
	DEFiRet;

	assert(serverParam[strlen(serverParam)-1] != '/');

	es_str_t *urlBuf = es_newStr(256);
	if (urlBuf == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
		&quot;omhttp: failed to allocate es_str urlBuf in computeBaseUrl&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* Find where the hostname/ip of the server starts. If the scheme is not specified
	 * in the uri, start the buffer with a scheme corresponding to the useHttps parameter.
	 */
	if (strcasestr(serverParam, SCHEME_HTTP))
		host = serverParam + strlen(SCHEME_HTTP);
	else if (strcasestr(serverParam, SCHEME_HTTPS))
		host = serverParam + strlen(SCHEME_HTTPS);
	else
		r = useHttps ? es_addBuf(&amp;urlBuf, SCHEME_HTTPS, sizeof(SCHEME_HTTPS)-1) :
			es_addBuf(&amp;urlBuf, SCHEME_HTTP, sizeof(SCHEME_HTTP)-1);

	if (r == 0) r = es_addBuf(&amp;urlBuf, (char *)serverParam, strlen(serverParam));
	if (r == 0 &amp;&amp; !strchr(host, ':')) {
		snprintf(portBuf, sizeof(portBuf), &quot;:%d&quot;, defaultPort);
		r = es_addBuf(&amp;urlBuf, portBuf, strlen(portBuf));
	}
	if (r == 0) r = es_addChar(&amp;urlBuf, '/');
	if (r == 0) *baseUrl = (uchar*) es_str2cstr(urlBuf, NULL);

	if (r != 0 || baseUrl == NULL) {
		LogError(0, RS_RET_ERR,
			&quot;omhttp: error occurred computing baseUrl from server %s&quot;, serverParam);
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	if (urlBuf) {
		es_deleteStr(urlBuf);
	}
	RETiRet;
}

static inline void
incrementServerIndex(wrkrInstanceData_t *pWrkrData)
{
	pWrkrData-&gt;serverIndex = (pWrkrData-&gt;serverIndex + 1) % pWrkrData-&gt;pData-&gt;numServers;
}


/* checks if connection to ES can be established; also iterates over
 * potential servers to support high availability (HA) feature. If it
 * needs to switch server, will record new one in curl handle.
 */
static rsRetVal ATTR_NONNULL()
checkConn(wrkrInstanceData_t *const pWrkrData)
{
	CURL *curl;
	CURLcode res;
	es_str_t *urlBuf = NULL;
	char* healthUrl;
	char* serverUrl;
	char* checkPath;
	int i;
	int r;
	DEFiRet;

	if (pWrkrData-&gt;pData-&gt;checkPath == NULL) {
		DBGPRINTF(&quot;omhttp: checkConn no health check uri configured skipping it\n&quot;);
		FINALIZE;
	}

	pWrkrData-&gt;reply = NULL;
	pWrkrData-&gt;replyLen = 0;
	curl = pWrkrData-&gt;curlCheckConnHandle;
	urlBuf = es_newStr(256);
	if (urlBuf == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			&quot;omhttp: unable to allocate buffer for health check uri.&quot;);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	for(i = 0; i &lt; pWrkrData-&gt;pData-&gt;numServers; ++i) {
		serverUrl = (char*) pWrkrData-&gt;pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
		checkPath = (char*) pWrkrData-&gt;pData-&gt;checkPath;

		es_emptyStr(urlBuf);
		r = es_addBuf(&amp;urlBuf, serverUrl, strlen(serverUrl));
		if(r == 0 &amp;&amp; checkPath != NULL)
			r = es_addBuf(&amp;urlBuf, checkPath, strlen(checkPath));
		if(r == 0)
			healthUrl = es_str2cstr(urlBuf, NULL);
		if(r != 0 || healthUrl == NULL) {
			LogError(0, RS_RET_OUT_OF_MEMORY,
				&quot;omhttp: unable to allocate buffer for health check uri.&quot;);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}

		curlCheckConnSetup(pWrkrData);
		curl_easy_setopt(curl, CURLOPT_URL, healthUrl);
		res = curl_easy_perform(curl);
		free(healthUrl);

		if (res == CURLE_OK) {
			DBGPRINTF(&quot;omhttp: checkConn %s completed with success &quot;
				&quot;on attempt %d\n&quot;, serverUrl, i);
			ABORT_FINALIZE(RS_RET_OK);
		}

		DBGPRINTF(&quot;omhttp: checkConn %s failed on attempt %d: %s\n&quot;,
			serverUrl, i, curl_easy_strerror(res));
		incrementServerIndex(pWrkrData);
	}

	LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		&quot;omhttp: checkConn failed after %d attempts.&quot;, i);
	ABORT_FINALIZE(RS_RET_SUSPENDED);

finalize_it:
	if(urlBuf != NULL)
		es_deleteStr(urlBuf);

	free(pWrkrData-&gt;reply);
	pWrkrData-&gt;reply = NULL; /* don't leave dangling pointer */
	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	DBGPRINTF(&quot;omhttp: tryResume called\n&quot;);
	iRet = checkConn(pWrkrData);
ENDtryResume


/* get the current index and type for this message */
static void ATTR_NONNULL(1)
getRestPath(const instanceData *const pData, uchar **const tpls,
		      uchar **const restPath)
{
	*restPath = pData-&gt;restPath;
	if(tpls == NULL) {
		goto done;
	}

	int iNumTpls = 1;
	if(pData-&gt;dynRestPath) {
		*restPath = tpls[iNumTpls];
		++iNumTpls;
	}

done:
	assert(restPath != NULL);
	return;
}


static rsRetVal ATTR_NONNULL(1)
setPostURL(wrkrInstanceData_t *const pWrkrData, uchar **const tpls)
{
	uchar *restPath;
	char* baseUrl;
	es_str_t *url;
	int r;
	DEFiRet;
	instanceData *const pData = pWrkrData-&gt;pData;

	baseUrl = (char*)pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
	url = es_newStrFromCStr(baseUrl, strlen(baseUrl));
	if (url == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			&quot;omhttp: error allocating new estr for POST url.&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	
	if (pWrkrData-&gt;batch.restPath != NULL) {
		/* get from batch if set! */
		restPath = pWrkrData-&gt;batch.restPath;
	} else {
		getRestPath(pData, tpls, &amp;restPath);
	}

	r = 0;
	if (restPath != NULL)
		r = es_addBuf(&amp;url, (char*)restPath, ustrlen(restPath));

	if(r != 0) {
		LogError(0, RS_RET_ERR, &quot;omhttp: failure in creating restURL, &quot;
				&quot;error code: %d&quot;, r);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	if(pWrkrData-&gt;restURL != NULL)
		free(pWrkrData-&gt;restURL);

	pWrkrData-&gt;restURL = (uchar*)es_str2cstr(url, NULL);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_URL, pWrkrData-&gt;restURL);
	DBGPRINTF(&quot;omhttp: using REST URL: '%s'\n&quot;, pWrkrData-&gt;restURL);

finalize_it:
	if (url != NULL)
		es_deleteStr(url);
	RETiRet;
}

/*
 * Dumps entire bulk request and response in error log
 * {
 *	&quot;request&quot;: {
 *	 	&quot;url&quot;: &quot;https://url.com:443/path&quot;,
 *	 	&quot;postdata&quot;: &quot;mypayload&quot; }
 *	 &quot;response&quot; : {
 *	 	&quot;status&quot;: 400,
 *	 	&quot;response&quot;: &quot;error string&quot; }
 * }
 */
static rsRetVal
renderJsonErrorMessage(wrkrInstanceData_t *pWrkrData, uchar *reqmsg, char **rendered)
{
	DEFiRet;
	fjson_object *req = NULL;
	fjson_object *res = NULL;
	fjson_object *errRoot = NULL;

	if ((req = fjson_object_new_object()) == NULL)
		ABORT_FINALIZE(RS_RET_ERR);
	fjson_object_object_add(req, &quot;url&quot;, fjson_object_new_string((char *)pWrkrData-&gt;restURL));
	fjson_object_object_add(req, &quot;postdata&quot;, fjson_object_new_string((char *)reqmsg));

	if ((res = fjson_object_new_object()) == NULL) {
		fjson_object_put(req); // cleanup request object
		ABORT_FINALIZE(RS_RET_ERR);
	}

	#define ERR_MSG_NULL &quot;NULL: curl request failed or no response&quot;
	fjson_object_object_add(res, &quot;status&quot;, fjson_object_new_int(pWrkrData-&gt;httpStatusCode));
	if (pWrkrData-&gt;reply == NULL) {
		fjson_object_object_add(res, &quot;message&quot;,
			fjson_object_new_string_len(ERR_MSG_NULL, strlen(ERR_MSG_NULL)));
	} else {
		fjson_object_object_add(res, &quot;message&quot;,
			fjson_object_new_string_len(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen));
	}

	if ((errRoot = fjson_object_new_object()) == NULL) {
		fjson_object_put(req); // cleanup request object
		fjson_object_put(res); // cleanup response object
		ABORT_FINALIZE(RS_RET_ERR);
	}

	fjson_object_object_add(errRoot, &quot;request&quot;, req);
	fjson_object_object_add(errRoot, &quot;response&quot;, res);

	*rendered = strdup((char *) fjson_object_to_json_string(errRoot));

finalize_it:
	if (errRoot != NULL)
		fjson_object_put(errRoot);

	RETiRet;
}

/* write data error request/replies to separate error file
 * Note: we open the file but never close it before exit. If it
 * needs to be closed, HUP must be sent.
 */
static rsRetVal ATTR_NONNULL()
writeDataError(wrkrInstanceData_t *const pWrkrData,
	instanceData *const pData, uchar *const reqmsg)
{
	char *rendered = NULL;
	size_t toWrite;
	ssize_t wrRet;
	sbool bMutLocked = 0;

	DEFiRet;

	if(pData-&gt;errorFile == NULL) {
		DBGPRINTF(&quot;omhttp: no local error logger defined - &quot;
			&quot;ignoring REST error information\n&quot;);
		FINALIZE;
	}

	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
	bMutLocked = 1;

	CHKiRet(renderJsonErrorMessage(pWrkrData, reqmsg, &amp;rendered));

	if(pData-&gt;fdErrFile == -1) {
		pData-&gt;fdErrFile = open((char*)pData-&gt;errorFile,
					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
		if(pData-&gt;fdErrFile == -1) {
			LogError(errno, RS_RET_ERR, &quot;omhttp: error opening error file %s&quot;,
				pData-&gt;errorFile);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}

	/* we do not do real error-handling on the err file, as this finally complicates
	 * things way to much.
	 */
	DBGPRINTF(&quot;omhttp: error record: '%s'\n&quot;, rendered);
	toWrite = strlen(rendered) + 1;
	/* Note: we overwrite the '\0' terminator with '\n' -- so we avoid
	 * caling malloc() -- write() does NOT need '\0'!
	 */
	rendered[toWrite-1] = '\n'; /* NO LONGER A STRING! */
	wrRet = write(pData-&gt;fdErrFile, rendered, toWrite);
	if(wrRet != (ssize_t) toWrite) {
		LogError(errno, RS_RET_IO_ERROR,
			&quot;omhttp: error writing error file %s, write returned %lld&quot;,
			pData-&gt;errorFile, (long long) wrRet);
	}

finalize_it:
	if(bMutLocked)
		pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
	free(rendered);
	RETiRet;
}

static rsRetVal
queueBatchOnRetryRuleset(wrkrInstanceData_t *const pWrkrData, instanceData *const pData)
{
	uchar *msgData;
	smsg_t *pMsg;
	DEFiRet;

	if (pData-&gt;retryRuleset == NULL) {
		LogError(0, RS_RET_ERR, &quot;omhttp: queueBatchOnRetryRuleset invalid call with a NULL retryRuleset&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	for (size_t i = 0; i &lt; pWrkrData-&gt;batch.nmemb; i++) {
		msgData = pWrkrData-&gt;batch.data[i];
		DBGPRINTF(&quot;omhttp: queueBatchOnRetryRuleset putting message '%s' into retry ruleset '%s'\n&quot;,
			msgData, pData-&gt;retryRulesetName);

		// Construct the message object
		CHKiRet(msgConstruct(&amp;pMsg));
		CHKiRet(MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY));
		MsgSetInputName(pMsg, pInputName);
		MsgSetRawMsg(pMsg, (const char *)msgData, ustrlen(msgData));
		MsgSetMSGoffs(pMsg, 0); // No header
		MsgSetTAG(pMsg, (const uchar *)&quot;omhttp-retry&quot;, 12);

		// And place it on the retry ruleset
		MsgSetRuleset(pMsg, pData-&gt;retryRuleset);
		ratelimitAddMsg(pData-&gt;ratelimiter, NULL, pMsg);

		// Count here in case not entire batch succeeds
		STATSCOUNTER_INC(ctrMessagesRetry, mutCtrMessagesRetry);
	}
finalize_it:
	RETiRet;
}

static rsRetVal
checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
{
	instanceData *pData;
	long statusCode;
	size_t numMessages;
	DEFiRet;

	pData = pWrkrData-&gt;pData;
	statusCode = pWrkrData-&gt;httpStatusCode;

	if (pData-&gt;batchMode) {
		numMessages = pWrkrData-&gt;batch.nmemb;
	} else {
		numMessages = 1;
	}

	// 500+ errors return RS_RET_SUSPENDED if NOT batchMode and should be retried
	// status 0 is the default and the request failed for some reason, retry this too
	// 400-499 are malformed input and should not be retried just logged instead
	if (statusCode == 0) {
		// request failed, suspend or retry
		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
		iRet = RS_RET_SUSPENDED;
	} else if (statusCode &gt;= 500) {
		// server error, suspend or retry
		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
		iRet = RS_RET_SUSPENDED;
	} else if (statusCode &gt;= 300) {
		// redirection or client error, NO suspend nor retry
		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
		iRet = RS_RET_DATAFAIL;
	} else {
		// success, normal state
		// includes 2XX (success like 200-OK)
		// includes 1XX (informational like 100-Continue)
		STATSCOUNTER_INC(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
		STATSCOUNTER_ADD(ctrMessagesSuccess, mutCtrMessagesSuccess, numMessages);
		iRet = RS_RET_OK;
	}

	if (iRet != RS_RET_OK) {
		LogMsg(0, iRet, LOG_ERR, &quot;omhttp: checkResult error http status code: %ld reply: %s&quot;,
			statusCode, pWrkrData-&gt;reply != NULL ? pWrkrData-&gt;reply : &quot;NULL&quot;);

		writeDataError(pWrkrData, pWrkrData-&gt;pData, reqmsg);

		if (iRet == RS_RET_DATAFAIL)
			ABORT_FINALIZE(iRet);

		if (pData-&gt;batchMode &amp;&amp; pData-&gt;maxBatchSize &gt; 1) {
			// Write each message back to retry ruleset if configured
			if (pData-&gt;retryFailures &amp;&amp; pData-&gt;retryRuleset != NULL) {
				// Retry stats counted inside this function call
				iRet = queueBatchOnRetryRuleset(pWrkrData, pData);
				if (iRet != RS_RET_OK) {
					LogMsg(0, iRet, LOG_ERR,
						&quot;omhttp: checkResult error while queueing to retry ruleset&quot;
						&quot;some messages may be lost&quot;);
				}
			}
			iRet = RS_RET_OK; // We've done all we can tell rsyslog to carry on
		}
	}

finalize_it:
	RETiRet;
}

/* Compress a buffer before sending using zlib. Based on code from tools/omfwd.c
 * Initialize the zstrm object for gzip compression, using this init function.
 * deflateInit2(z_stream strm, int level, int method,
 *                             int windowBits, int memLevel, int strategy);
 * strm: the zlib stream held in pWrkrData
 * level: the compression level held in pData
 * method: the operation constant Z_DEFLATED
 * windowBits: the size of the compression window 15 = log_2(32768)
 *     to configure as gzip add 16 to windowBits (w | 16) for final value 31
 * memLevel: the memory optimization level 8 is default)
 * strategy: using Z_DEFAULT_STRATEGY is default
 */
static rsRetVal
compressHttpPayload(wrkrInstanceData_t *pWrkrData, uchar *message, unsigned len)
{
	int zRet;
	unsigned outavail;
	uchar zipBuf[32*1024];

	DEFiRet;

	if (!pWrkrData-&gt;bzInitDone) {
		pWrkrData-&gt;zstrm.zalloc = Z_NULL;
		pWrkrData-&gt;zstrm.zfree = Z_NULL;
		pWrkrData-&gt;zstrm.opaque = Z_NULL;
		zRet = deflateInit2(&amp;pWrkrData-&gt;zstrm, pWrkrData-&gt;pData-&gt;compressionLevel,
			Z_DEFLATED, 31, 8, Z_DEFAULT_STRATEGY);
		if (zRet != Z_OK) {
			DBGPRINTF(&quot;omhttp: compressHttpPayload error %d returned from zlib/deflateInit2()\n&quot;, zRet);
			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
		}
		pWrkrData-&gt;bzInitDone = 1;
	}

	CHKiRet(resetCompressCtx(pWrkrData, len));

	/* now doing the compression */
	pWrkrData-&gt;zstrm.next_in = (Bytef*) message;
	pWrkrData-&gt;zstrm.avail_in = len;
	/* run deflate() on buffer until everything has been compressed */
	do {
		DBGPRINTF(&quot;omhttp: compressHttpPayload in deflate() loop, avail_in %d, total_in %ld\n&quot;,
				pWrkrData-&gt;zstrm.avail_in, pWrkrData-&gt;zstrm.total_in);
		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
		pWrkrData-&gt;zstrm.next_out = zipBuf;

		zRet = deflate(&amp;pWrkrData-&gt;zstrm, Z_NO_FLUSH);
		DBGPRINTF(&quot;omhttp: compressHttpPayload after deflate, ret %d, avail_out %d\n&quot;,
				zRet, pWrkrData-&gt;zstrm.avail_out);
		if (zRet != Z_OK)
			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
		if (outavail != 0)
			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));

	} while (pWrkrData-&gt;zstrm.avail_out == 0);

	/* run deflate again with Z_FINISH with no new input */
	pWrkrData-&gt;zstrm.avail_in = 0;
	do {
		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
		pWrkrData-&gt;zstrm.next_out = zipBuf;
		deflate(&amp;pWrkrData-&gt;zstrm, Z_FINISH); /* returns Z_STREAM_END == 1 */
		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
		if (outavail != 0)
			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));

	} while (pWrkrData-&gt;zstrm.avail_out == 0);

finalize_it:
	if (pWrkrData-&gt;bzInitDone)
		deflateEnd(&amp;pWrkrData-&gt;zstrm);
	pWrkrData-&gt;bzInitDone = 0;
	RETiRet;

}

static void ATTR_NONNULL()
initCompressCtx(wrkrInstanceData_t *pWrkrData)
{
	pWrkrData-&gt;compressCtx.buf = NULL;
	pWrkrData-&gt;compressCtx.curLen = 0;
	pWrkrData-&gt;compressCtx.len = 0;
}

static void ATTR_NONNULL()
freeCompressCtx(wrkrInstanceData_t *pWrkrData)
{
	if (pWrkrData-&gt;compressCtx.buf != NULL) {
		free(pWrkrData-&gt;compressCtx.buf);
		pWrkrData-&gt;compressCtx.buf = NULL;
	}
}


static rsRetVal ATTR_NONNULL()
resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len)
{
	DEFiRet;
	pWrkrData-&gt;compressCtx.curLen = 0;
	pWrkrData-&gt;compressCtx.len = len;
	CHKiRet(growCompressCtx(pWrkrData, len));

finalize_it:
	if (iRet != RS_RET_OK)
		freeCompressCtx(pWrkrData);
	RETiRet;
}

static rsRetVal ATTR_NONNULL()
growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen)
{
	DEFiRet;
	if (pWrkrData-&gt;compressCtx.buf == NULL) {
		CHKmalloc(pWrkrData-&gt;compressCtx.buf = (uchar *)malloc(sizeof(uchar)*newLen));
	} else {
		uchar *const newbuf = (uchar *)realloc(pWrkrData-&gt;compressCtx.buf, sizeof(uchar)*newLen);
		CHKmalloc(newbuf);
		pWrkrData-&gt;compressCtx.buf = newbuf;
	}
	pWrkrData-&gt;compressCtx.len = newLen;
finalize_it:
	RETiRet;

}

static rsRetVal ATTR_NONNULL()
appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen)
{
	size_t newLen;
	DEFiRet;
	newLen = pWrkrData-&gt;compressCtx.curLen + srcLen;
	if (newLen &gt; pWrkrData-&gt;compressCtx.len)
		CHKiRet(growCompressCtx(pWrkrData, newLen));

	memcpy(pWrkrData-&gt;compressCtx.buf + pWrkrData-&gt;compressCtx.curLen,
		srcBuf, srcLen);
	pWrkrData-&gt;compressCtx.curLen = newLen;
finalize_it:
	if (iRet != RS_RET_OK)
		freeCompressCtx(pWrkrData);
	RETiRet;
}

/* Some duplicate code to curlSetup, but we need to add the gzip content-encoding
 * header at runtime, and if the compression fails, we do not want to send it.
 * Additionally, the curlCheckConnHandle should not be configured with a gzip header.
 */
static rsRetVal ATTR_NONNULL()
buildCurlHeaders(wrkrInstanceData_t *pWrkrData, sbool contentEncodeGzip)
{
	struct curl_slist *slist = NULL;

	DEFiRet;

	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
		// If content type specified use it, otherwise use a sane default
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
	} else {
		if (pWrkrData-&gt;pData-&gt;batchMode) {
			// If in batch mode, use the approprate content type header for the format,
			// defaulting to text/plain with newline
			switch (pWrkrData-&gt;pData-&gt;batchFormat) {
				case FMT_JSONARRAY:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
					break;
				case FMT_KAFKAREST:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_KAFKA);
					break;
				case FMT_NEWLINE:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
					break;
				case FMT_LOKIREST:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
					break;
				default:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
			}
		} else {
			// Otherwise non batch, presume most users are sending JSON
			slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
		}
	}

	CHKmalloc(slist);

	// Configured headers..
	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
		CHKmalloc(slist);
	}

	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
		CHKmalloc(slist);
	}

	// When sending more than 1Kb, libcurl automatically sends an Except: 100-Continue header
	// and will wait 1s for a response, could make this configurable but for now disable
	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
	CHKmalloc(slist);

	if (contentEncodeGzip) {
		slist = curl_slist_append(slist, HTTP_HEADER_ENCODING_GZIP);
		CHKmalloc(slist);
	}

	if (pWrkrData-&gt;curlHeader != NULL)
		curl_slist_free_all(pWrkrData-&gt;curlHeader);

	pWrkrData-&gt;curlHeader = slist;

finalize_it:
	if (iRet != RS_RET_OK) {
		curl_slist_free_all(slist);
		LogError(0, iRet, &quot;omhttp: error allocating curl header slist, using previous one&quot;);
	}
	RETiRet;
}



static rsRetVal ATTR_NONNULL(1, 2)
curlPost(wrkrInstanceData_t *pWrkrData, uchar *message, int msglen, uchar **tpls,
		const int nmsgs __attribute__((unused)))
{
	CURLcode curlCode;
	CURL *const curl = pWrkrData-&gt;curlPostHandle;
	char errbuf[CURL_ERROR_SIZE] = &quot;&quot;;

	char *postData;
	int postLen;
	sbool compressed;
	DEFiRet;

	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);

	if(pWrkrData-&gt;pData-&gt;numServers &gt; 1) {
		/* needs to be called to support ES HA feature */
		CHKiRet(checkConn(pWrkrData));
	}
	CHKiRet(setPostURL(pWrkrData, tpls));

	pWrkrData-&gt;reply = NULL;
	pWrkrData-&gt;replyLen = 0;
	pWrkrData-&gt;httpStatusCode = 0;

	postData = (char *)message;
	postLen = msglen;
	compressed = 0;

	if (pWrkrData-&gt;pData-&gt;compress) {
		iRet = compressHttpPayload(pWrkrData, message, msglen);
		if (iRet != RS_RET_OK) {
			LogError(0, iRet, &quot;omhttp: curlPost error while compressing, will default to uncompressed&quot;);
		} else {
			postData = (char *)pWrkrData-&gt;compressCtx.buf;
			postLen = pWrkrData-&gt;compressCtx.curLen;
			compressed = 1;
			DBGPRINTF(&quot;omhttp: curlPost compressed %d to %d bytes\n&quot;, msglen, postLen);
		}
	}

	buildCurlHeaders(pWrkrData, compressed);

	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, postLen);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
	curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);

	curlCode = curl_easy_perform(curl);
	DBGPRINTF(&quot;omhttp: curlPost curl returned %lld\n&quot;, (long long) curlCode);
	STATSCOUNTER_INC(ctrHttpRequestCount, mutCtrHttpRequestCount);

	if (curlCode != CURLE_OK) {
		STATSCOUNTER_INC(ctrHttpRequestFail, mutCtrHttpRequestFail);
		LogError(0, RS_RET_SUSPENDED,
			&quot;omhttp: suspending ourselves due to server failure %lld: %s&quot;,
			(long long) curlCode, errbuf);
		// Check the result here too and retry if needed, then we should suspend
		// Usually in batch mode we clobber any iRet values, but probably not a great
		// idea to keep hitting a dead server. The http status code will be 0 at this point.
		checkResult(pWrkrData, message);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	} else {
		STATSCOUNTER_INC(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
	}

	// Grab the HTTP Response code
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;pWrkrData-&gt;httpStatusCode);
	if(pWrkrData-&gt;reply == NULL) {
		DBGPRINTF(&quot;omhttp: curlPost pWrkrData reply==NULL, replyLen = '%d'\n&quot;,
			pWrkrData-&gt;replyLen);
	} else {
		DBGPRINTF(&quot;omhttp: curlPost pWrkrData replyLen = '%d'\n&quot;, pWrkrData-&gt;replyLen);
		if(pWrkrData-&gt;replyLen &gt; 0) {
			pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0';
			/* Append 0 Byte if replyLen is above 0 - byte has been reserved in malloc */
		}
		//TODO: replyLen++? because 0 Byte is appended
		DBGPRINTF(&quot;omhttp: curlPost pWrkrData reply: '%s'\n&quot;, pWrkrData-&gt;reply);
	}
	CHKiRet(checkResult(pWrkrData, message));

finalize_it:
	incrementServerIndex(pWrkrData);
	if (pWrkrData-&gt;reply != NULL) {
		free(pWrkrData-&gt;reply);
		pWrkrData-&gt;reply = NULL; /* don't leave dangling pointer */
	}
	RETiRet;
}

/* Build a JSON batch that conforms to the Kafka Rest Proxy format.
 * See https://docs.confluent.io/current/kafka-rest/docs/quickstart.html for more info.
 * Want {&quot;records&quot;: [{&quot;value&quot;: &quot;message1&quot;}, {&quot;value&quot;: &quot;message2&quot;}]}
 */
static rsRetVal
serializeBatchKafkaRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
{
	fjson_object *batchArray = NULL;
	fjson_object *recordObj = NULL;
	fjson_object *valueObj = NULL;
	fjson_object *msgObj = NULL;

	size_t numMessages = pWrkrData-&gt;batch.nmemb;
	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; // messages + brackets + commas
	DBGPRINTF(&quot;omhttp: serializeBatchKafkaRest numMessages=%zd sizeTotal=%zd\n&quot;, numMessages, sizeTotal);

	DEFiRet;

	batchArray = fjson_object_new_array();
	if (batchArray == NULL) {
		LogError(0, RS_RET_ERR, &quot;omhttp: serializeBatchKafkaRest failed to create array&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	for (size_t i = 0; i &lt; numMessages; i++) {
		valueObj = fjson_object_new_object();
		if (valueObj == NULL) {
			fjson_object_put(batchArray); // cleanup
			LogError(0, RS_RET_ERR, &quot;omhttp: serializeBatchKafkaRest failed to create value object&quot;);
			ABORT_FINALIZE(RS_RET_ERR);
		}

		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
		if (msgObj == NULL) {
			LogError(0, NO_ERRCODE,
				&quot;omhttp: serializeBatchKafkaRest failed to parse %s as json ignoring it&quot;,
				pWrkrData-&gt;batch.data[i]);
			continue;
		}
		fjson_object_object_add(valueObj, &quot;value&quot;, msgObj);
		fjson_object_array_add(batchArray, valueObj);
	}

	recordObj = fjson_object_new_object();
	if (recordObj == NULL) {
		fjson_object_put(batchArray); // cleanup
		LogError(0, RS_RET_ERR, &quot;omhttp: serializeBatchKafkaRest failed to create record object&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	fjson_object_object_add(recordObj, &quot;records&quot;, batchArray);

	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
	*batchBuf = strndup(batchString, strlen(batchString));

finalize_it:
	if (recordObj != NULL) {
		fjson_object_put(recordObj);
		recordObj = NULL;
	}

	RETiRet;
}

static rsRetVal
serializeBatchLokiRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
{
	fjson_object *batchArray = NULL;
	fjson_object *recordObj = NULL;
	fjson_object *msgObj = NULL;

	size_t numMessages = pWrkrData-&gt;batch.nmemb;
	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; // messages + brackets + commas
	DBGPRINTF(&quot;omhttp: serializeBatchLokiRest numMessages=%zd sizeTotal=%zd\n&quot;, numMessages, sizeTotal);

	DEFiRet;

	batchArray = fjson_object_new_array();
	if (batchArray == NULL) {
		LogError(0, RS_RET_ERR, &quot;omhttp: serializeBatchLokiRest failed to create array&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	for (size_t i = 0; i &lt; numMessages; i++) {
		DBGPRINTF(&quot;omhttp: serializeBatchLokiRest parsing message [%s]\n&quot;,(char *) pWrkrData-&gt;batch.data[i]);
		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
		if (msgObj == NULL) {
			LogError(0, NO_ERRCODE,
				&quot;omhttp: serializeBatchLokiRest failed to parse %s as json ignoring it&quot;,
				pWrkrData-&gt;batch.data[i]);
			continue;
		}
		fjson_object_array_add(batchArray, msgObj);
	}

	recordObj = fjson_object_new_object();
	if (recordObj == NULL) {
		fjson_object_put(batchArray); // cleanup
		LogError(0, RS_RET_ERR, &quot;omhttp: serializeBatchLokiRest failed to create record object&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	fjson_object_object_add(recordObj, &quot;streams&quot;, batchArray);

	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
	*batchBuf = strndup(batchString, strlen(batchString));

finalize_it:
	if (recordObj != NULL) {
		fjson_object_put(recordObj);
		recordObj = NULL;
	}

	RETiRet;
}
/* Build a JSON batch by placing each element in an array.
 */
static rsRetVal
serializeBatchJsonArray(wrkrInstanceData_t *pWrkrData, char **batchBuf)
{
	fjson_object *batchArray = NULL;
	fjson_object *msgObj = NULL;
	size_t numMessages = pWrkrData-&gt;batch.nmemb;
	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; // messages + brackets + commas
	DBGPRINTF(&quot;omhttp: serializeBatchJsonArray numMessages=%zd sizeTotal=%zd\n&quot;, numMessages, sizeTotal);

	DEFiRet;

	batchArray = fjson_object_new_array();
	if (batchArray == NULL) {
		LogError(0, RS_RET_ERR, &quot;omhttp: serializeBatchJsonArray failed to create array&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	for (size_t i = 0; i &lt; numMessages; i++) {
		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
		if (msgObj == NULL) {
			LogError(0, NO_ERRCODE,
				&quot;omhttp: serializeBatchJsonArray failed to parse %s as json, ignoring it&quot;,
				pWrkrData-&gt;batch.data[i]);
			continue;
		}
		fjson_object_array_add(batchArray, msgObj);
	}

	const char *batchString = fjson_object_to_json_string_ext(batchArray, FJSON_TO_STRING_PLAIN);
	*batchBuf = strndup(batchString, strlen(batchString));

finalize_it:
	if (batchArray != NULL) {
		fjson_object_put(batchArray);
		batchArray = NULL;
	}
	RETiRet;
}

/* Build a batch by joining each element with a newline character.
 */
static rsRetVal
serializeBatchNewline(wrkrInstanceData_t *pWrkrData, char **batchBuf)
{
	DEFiRet;
	size_t numMessages = pWrkrData-&gt;batch.nmemb;
	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages; // message + newline + null term
	int r = 0;

	DBGPRINTF(&quot;omhttp: serializeBatchNewline numMessages=%zd sizeTotal=%zd\n&quot;, numMessages, sizeTotal);

	es_str_t *batchString = es_newStr(1024);

	if (batchString == NULL)
		ABORT_FINALIZE(RS_RET_ERR);

	for (size_t i = 0; i &lt; numMessages; i++) {
		size_t nToCopy = ustrlen(pWrkrData-&gt;batch.data[i]);
		if (r == 0) r = es_addBuf(&amp;batchString, (char *)pWrkrData-&gt;batch.data[i], nToCopy);
		if (i == numMessages - 1) break;
		if (r == 0) r = es_addChar(&amp;batchString, '\n');
	}

	if (r == 0) *batchBuf = (char *) es_str2cstr(batchString, NULL);

	if (r != 0 || *batchBuf== NULL) {
		LogError(0, RS_RET_ERR, &quot;omhttp: serializeBatchNewline failed to build batch string&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

finalize_it:
	if (batchString != NULL)
		es_deleteStr(batchString);

	RETiRet;
}

/* Return the final batch size in bytes for each serialization method.
 * Used to decide if a batch should be flushed early.
 */
static size_t
computeBatchSize(wrkrInstanceData_t *pWrkrData)
{
	size_t extraBytes = 0;
	size_t sizeBytes = pWrkrData-&gt;batch.sizeBytes;
	size_t numMessages = pWrkrData-&gt;batch.nmemb;

	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
		case FMT_JSONARRAY:
			// square brackets, commas between each message
			// 2 + numMessages - 1 = numMessages + 1
			extraBytes = numMessages &gt; 0 ? numMessages + 1 : 2;
			break;
		case FMT_KAFKAREST:
			// '{}', '[]', '&quot;records&quot;:'= 2 + 2 + 10 = 14
			// '{&quot;value&quot;:}' for each message = n * 10
			// numMessages == 0 handled implicitly in multiplication
			extraBytes = (numMessages * 10) + 14;
			break;
		case FMT_NEWLINE:
			// newlines between each message
			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
			break;
		case FMT_LOKIREST:
			// {&quot;streams&quot;:[ '{}', '[]', '&quot;streams&quot;:' = 14
			//    {&quot;stream&quot;: {key:value}..., &quot;values&quot;:[[timestamp: msg1]]},
			//    {&quot;stream&quot;: {key:value}..., &quot;values&quot;:[[timestamp: msg2]]}
			// ]}
			// message (11) * numMessages + header ( 16 )
			extraBytes = (numMessages * 2) + 14;
			break;
		default:
			// newlines between each message
			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
	}

	return sizeBytes + extraBytes + 1; // plus a null
}

static void ATTR_NONNULL()
initializeBatch(wrkrInstanceData_t *pWrkrData)
{
	pWrkrData-&gt;batch.sizeBytes = 0;
	pWrkrData-&gt;batch.nmemb = 0;
	if (pWrkrData-&gt;batch.restPath != NULL)  {
		free(pWrkrData-&gt;batch.restPath);
		pWrkrData-&gt;batch.restPath = NULL;
	}
}

/* Adds a message to this worker's batch
 */
static rsRetVal
buildBatch(wrkrInstanceData_t *pWrkrData, uchar *message)
{
	DEFiRet;

	if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
		LogError(0, RS_RET_ERR, &quot;omhttp: buildBatch something has gone wrong,&quot;
			&quot;number of messages in batch is bigger than the max batch size, bailing&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	pWrkrData-&gt;batch.data[pWrkrData-&gt;batch.nmemb] = message;
	pWrkrData-&gt;batch.sizeBytes += strlen((char *)message);
	pWrkrData-&gt;batch.nmemb++;

finalize_it:
	RETiRet;
}

static rsRetVal
submitBatch(wrkrInstanceData_t *pWrkrData, uchar **tpls)
{
	DEFiRet;
	char *batchBuf = NULL;

	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
		case FMT_JSONARRAY:
			iRet = serializeBatchJsonArray(pWrkrData, &amp;batchBuf);
			break;
		case FMT_KAFKAREST:
			iRet = serializeBatchKafkaRest(pWrkrData, &amp;batchBuf);
			break;
		case FMT_LOKIREST:
			iRet = serializeBatchLokiRest(pWrkrData, &amp;batchBuf);
			break;
		case FMT_NEWLINE:
			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
			break;
		default:
			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
	}

	if (iRet != RS_RET_OK || batchBuf == NULL)
		ABORT_FINALIZE(iRet);

	DBGPRINTF(&quot;omhttp: submitBatch, batch: '%s' tpls: '%p'\n&quot;, batchBuf, tpls);

	CHKiRet(curlPost(pWrkrData, (uchar*) batchBuf, strlen(batchBuf),
		tpls, pWrkrData-&gt;batch.nmemb));

finalize_it:
	if (batchBuf != NULL)
		free(batchBuf);
	RETiRet;
}

BEGINbeginTransaction
CODESTARTbeginTransaction
	if(!pWrkrData-&gt;pData-&gt;batchMode) {
		FINALIZE;
	}

	initializeBatch(pWrkrData);
finalize_it:
ENDbeginTransaction

BEGINdoAction
size_t nBytes;
sbool submit;
CODESTARTdoAction
	instanceData *const pData = pWrkrData-&gt;pData;
	uchar *restPath = NULL;
	STATSCOUNTER_INC(ctrMessagesSubmitted, mutCtrMessagesSubmitted);

	if (pWrkrData-&gt;pData-&gt;batchMode) {
		if(pData-&gt;dynRestPath) {
			/* Get copy of restpath in batch mode if dynRestPath enabled */
			getRestPath(pData, ppString, &amp;restPath);
			if (pWrkrData-&gt;batch.restPath == NULL) {
				pWrkrData-&gt;batch.restPath = (uchar*)strdup((char*)restPath);
			} else if (strcmp((char*)pWrkrData-&gt;batch.restPath, (char*)restPath) != 0) {
				/* Check if the restPath changed - if yes submit the current batch first*/
				CHKiRet(submitBatch(pWrkrData, NULL));
				initializeBatch(pWrkrData);
			}
		}

		/* If the maxbatchsize is 1, then build and immediately post a batch with 1 element.
		 * This mode will play nicely with rsyslog's action.resumeRetryCount logic.
		 */
		if (pWrkrData-&gt;pData-&gt;maxBatchSize == 1) {
			initializeBatch(pWrkrData);
			CHKiRet(buildBatch(pWrkrData, ppString[0]));
			CHKiRet(submitBatch(pWrkrData, ppString));
			FINALIZE;
		}

		/* We should submit if any of these conditions are true
		 * 1. Total batch size &gt; pWrkrData-&gt;pData-&gt;maxBatchSize
		 * 2. Total bytes &gt; pWrkrData-&gt;pData-&gt;maxBatchBytes
		 */
		nBytes = ustrlen((char *)ppString[0]) - 1 ;
		submit = 0;

		if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
			submit = 1;
			DBGPRINTF(&quot;omhttp: maxbatchsize limit reached submitting batch of %zd elements.\n&quot;,
				pWrkrData-&gt;batch.nmemb);
		} else if (computeBatchSize(pWrkrData) + nBytes &gt; pWrkrData-&gt;pData-&gt;maxBatchBytes) {
			submit = 1;
			DBGPRINTF(&quot;omhttp: maxbytes limit reached submitting partial batch of %zd elements.\n&quot;,
				pWrkrData-&gt;batch.nmemb);
		}

		if (submit) {
			CHKiRet(submitBatch(pWrkrData, ppString));
			initializeBatch(pWrkrData);
		}

		CHKiRet(buildBatch(pWrkrData, ppString[0]));

		/* If there is only one item in the batch, all previous items have been
	 	 * submitted or this is the first item for this transaction. Return previous
		 * committed so that all items leading up to the current (exclusive)
		 * are not replayed should a failure occur anywhere else in the transaction. */
		iRet = pWrkrData-&gt;batch.nmemb == 1 ? RS_RET_PREVIOUS_COMMITTED : RS_RET_DEFER_COMMIT;
	} else {
		CHKiRet(curlPost(pWrkrData, ppString[0], strlen((char*)ppString[0]), ppString, 1));
	}
finalize_it:
ENDdoAction


BEGINendTransaction
CODESTARTendTransaction
	/* End Transaction only if batch data is not empty */
	if (pWrkrData-&gt;batch.nmemb &gt; 0) {
		CHKiRet(submitBatch(pWrkrData, NULL));
	} else {
		dbgprintf(&quot;omhttp: endTransaction, pWrkrData-&gt;batch.nmemb = 0, &quot;
			&quot;nothing to send. \n&quot;);
	}
finalize_it:
ENDendTransaction

/* Creates authentication header uid:pwd
 */
static rsRetVal
computeAuthHeader(char* uid, char* pwd, uchar** authBuf)
{
	int r;
	DEFiRet;

	es_str_t* auth = es_newStr(1024);
	if (auth == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			&quot;omhttp: failed to allocate es_str auth for auth header construction&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	r = es_addBuf(&amp;auth, uid, strlen(uid));
	if(r == 0) r = es_addChar(&amp;auth, ':');
	if(r == 0 &amp;&amp; pwd != NULL) r = es_addBuf(&amp;auth, pwd, strlen(pwd));
	if(r == 0) *authBuf = (uchar*) es_str2cstr(auth, NULL);

	if (r != 0 || *authBuf == NULL) {
		LogError(0, RS_RET_ERR, &quot;omhttp: failed to build auth header\n&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

finalize_it:
	if (auth != NULL)
		es_deleteStr(auth);
	RETiRet;
}

static rsRetVal
computeApiHeader(char* key, char* value, uchar** headerBuf)
{
	int r;
	DEFiRet;

	es_str_t* header = es_newStr(10240);
	if (header == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
		&quot;omhttp: failed to allocate es_str auth for api header construction&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	r = es_addBuf(&amp;header, key, strlen(key));
	if(r == 0) r = es_addChar(&amp;header, ':');
	if(r == 0) r = es_addChar(&amp;header, ' ');
	if(r == 0 &amp;&amp; value != NULL) r = es_addBuf(&amp;header, value, strlen(value));
	if(r == 0) *headerBuf = (uchar*) es_str2cstr(header, NULL);

	if (r != 0 || *headerBuf == NULL) {
		LogError(0, RS_RET_ERR, &quot;omhttp: failed to build http header\n&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

finalize_it:
	if (header != NULL)
		es_deleteStr(header);
	RETiRet;
}

static void ATTR_NONNULL()
curlSetupCommon(wrkrInstanceData_t *const pWrkrData, CURL *const handle)
{
	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
	curl_easy_setopt(handle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
	curl_easy_setopt(handle, CURLOPT_NOSIGNAL, TRUE);
	curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, curlResult);
	curl_easy_setopt(handle, CURLOPT_WRITEDATA, pWrkrData);
	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYPEER, FALSE);
	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYHOST, FALSE);
	if(pWrkrData-&gt;pData-&gt;authBuf != NULL) {
		curl_easy_setopt(handle, CURLOPT_USERPWD, pWrkrData-&gt;pData-&gt;authBuf);
		curl_easy_setopt(handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
	}
	if(pWrkrData-&gt;pData-&gt;caCertFile)
		curl_easy_setopt(handle, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
	if(pWrkrData-&gt;pData-&gt;myCertFile)
		curl_easy_setopt(handle, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
		curl_easy_setopt(handle, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
	/* uncomment for in-dept debuggung:
	curl_easy_setopt(handle, CURLOPT_VERBOSE, TRUE); */
}

static void ATTR_NONNULL()
curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData)
{
	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlCheckConnHandle);
	curl_easy_setopt(pWrkrData-&gt;curlCheckConnHandle,
		CURLOPT_TIMEOUT_MS, pWrkrData-&gt;pData-&gt;healthCheckTimeout);
}

static void ATTR_NONNULL(1)
curlPostSetup(wrkrInstanceData_t *const pWrkrData)
{
	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlPostHandle);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_POST, 1);
	CURLcode cRet;
	/* Enable TCP keep-alive for this transfer */
	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPALIVE, 1L);
	if (cRet != CURLE_OK)
		DBGPRINTF(&quot;omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPALIVE\n&quot;);
	/* keep-alive idle time to 120 seconds */
	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPIDLE, 120L);
	if (cRet != CURLE_OK)
		DBGPRINTF(&quot;omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPIDLE\n&quot;);
	/* interval time between keep-alive probes: 60 seconds */
	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPINTVL, 60L);
	if (cRet != CURLE_OK)
		DBGPRINTF(&quot;omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPINTVL\n&quot;);
}

static rsRetVal ATTR_NONNULL()
curlSetup(wrkrInstanceData_t *const pWrkrData)
{
	struct curl_slist *slist = NULL;

	DEFiRet;
	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
	} else {
		slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
	}

	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
		CHKmalloc(slist);
	}

	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
		CHKmalloc(slist);
	}

	// When sending more than 1Kb, libcurl automatically sends an Except: 100-Continue header
	// and will wait 1s for a response, could make this configurable but for now disable
	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
	pWrkrData-&gt;curlHeader = slist;
	CHKmalloc(pWrkrData-&gt;curlPostHandle = curl_easy_init());
	curlPostSetup(pWrkrData);

	CHKmalloc(pWrkrData-&gt;curlCheckConnHandle = curl_easy_init());
	curlCheckConnSetup(pWrkrData);

finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; pWrkrData-&gt;curlPostHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
		pWrkrData-&gt;curlPostHandle = NULL;
	}
	RETiRet;
}

static void ATTR_NONNULL()
curlCleanup(wrkrInstanceData_t *const pWrkrData)
{
	if (pWrkrData-&gt;curlHeader != NULL) {
		curl_slist_free_all(pWrkrData-&gt;curlHeader);
		pWrkrData-&gt;curlHeader = NULL;
	}
	if (pWrkrData-&gt;curlCheckConnHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlCheckConnHandle);
		pWrkrData-&gt;curlCheckConnHandle = NULL;
	}
	if (pWrkrData-&gt;curlPostHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
		pWrkrData-&gt;curlPostHandle = NULL;
	}
}

static void ATTR_NONNULL()
setInstParamDefaults(instanceData *const pData)
{
	pData-&gt;serverBaseUrls = NULL;
	pData-&gt;defaultPort = 443;
	pData-&gt;healthCheckTimeout = 3500;
	pData-&gt;uid = NULL;
	pData-&gt;httpcontenttype = NULL;
	pData-&gt;headerContentTypeBuf = NULL;
	pData-&gt;httpheaderkey = NULL;
	pData-&gt;httpheadervalue = NULL;
	pData-&gt;httpHeaders = NULL;
	pData-&gt;nHttpHeaders = 0;
	pData-&gt;pwd = NULL;
	pData-&gt;authBuf = NULL;
	pData-&gt;restPath = NULL;
	pData-&gt;checkPath = NULL;
	pData-&gt;dynRestPath = 0;
	pData-&gt;batchMode = 0;
	pData-&gt;batchFormatName = (uchar *)&quot;newline&quot;;
	pData-&gt;batchFormat = FMT_NEWLINE;
	pData-&gt;bFreeBatchFormatName = 0;
	pData-&gt;useHttps = 1;
	pData-&gt;maxBatchBytes = 10485760; //i.e. 10 MB Is the default max message size for AWS API Gateway
	pData-&gt;maxBatchSize = 100; // 100 messages
	pData-&gt;compress = 0; // off
	pData-&gt;compressionLevel = -1; // default compression
	pData-&gt;allowUnsignedCerts = 0;
	pData-&gt;skipVerifyHost = 0;
	pData-&gt;tplName = NULL;
	pData-&gt;errorFile = NULL;
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
	pData-&gt;reloadOnHup= 0;
	pData-&gt;retryFailures = 0;
	pData-&gt;ratelimitBurst = 20000;
	pData-&gt;ratelimitInterval = 600;
	pData-&gt;ratelimiter = NULL;
	pData-&gt;retryRulesetName = NULL;
	pData-&gt;retryRuleset = NULL;
}

static rsRetVal
checkHeaderParam(char *const param)
{
	DEFiRet;
	char *val = strstr(param, &quot;:&quot;);
	if(val == NULL) {
		LogError(0, RS_RET_PARAM_ERROR, &quot;missing ':' delimiter in &quot;
				&quot;parameter '%s'&quot;, param);
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
finalize_it:
	RETiRet;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	char* serverParam = NULL;
	struct cnfarray* servers = NULL;
	int i;
	int iNumTpls;
	FILE *fp;
	char errStr[1024];
	char *batchFormatName;
	int compressionLevel = -1;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

<A NAME="10"></A>	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match369-1.html#10',3,'match369-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		if(!strcmp(actpblk.descr[i].name, &quot;server&quot;)) {
			servers = pvals[i].val.d.ar;
		} else if(!strcmp(actpblk.descr[i].name, &quot;errorfile&quot;)) {
			pData-&gt;errorFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;serverport&quot;)) {</B></FONT>
<A NAME="2"></A>			pData-&gt;defaultPort = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;healthchecktimeout&quot;)) {
			pData-&gt;healthCheckTimeout = (long) pvals[i].val.d.n;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match369-1.html#2',3,'match369-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;uid&quot;)) {
			pData-&gt;uid = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;httpcontenttype&quot;)) {
			pData-&gt;httpcontenttype = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;httpheaderkey&quot;)) {
			pData-&gt;httpheaderkey = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;httpheadervalue&quot;)) {
			pData-&gt;httpheadervalue = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
		} else if(!strcmp(actpblk.descr[i].name, &quot;httpheaders&quot;)) {
			pData-&gt;nHttpHeaders = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(pData-&gt;httpHeaders = malloc(sizeof(uchar *) * pvals[i].val.d.ar-&gt;nmemb ));
			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				CHKiRet(checkHeaderParam(cstr));
<A NAME="9"></A>				pData-&gt;httpHeaders[j] = (uchar *)cstr;
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;pwd&quot;)) {
<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match369-1.html#9',3,'match369-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;restpath&quot;)) {
			pData-&gt;restPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<A NAME="11"></A>		} else if(!strcmp(actpblk.descr[i].name, &quot;checkpath&quot;)) {
			pData-&gt;checkPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
		} else if(!strcmp(actpblk.descr[i].name, &quot;dynrestpath&quot;)) {
<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match369-1.html#11',3,'match369-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			pData-&gt;dynRestPath = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;batch&quot;)) {
			pData-&gt;batchMode = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;batch.format&quot;)) {
			batchFormatName = es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
<A NAME="6"></A>			if (strstr(VALID_BATCH_FORMATS, batchFormatName) != NULL) {
				pData-&gt;batchFormatName = (uchar *)batchFormatName;
				pData-&gt;bFreeBatchFormatName = 1;
<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match369-1.html#6',3,'match369-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>				if (!strcmp(batchFormatName, &quot;newline&quot;)) {
					pData-&gt;batchFormat = FMT_NEWLINE;
				} else if (!strcmp(batchFormatName, &quot;jsonarray&quot;)) {
					pData-&gt;batchFormat = FMT_JSONARRAY;
				} else if (!strcmp(batchFormatName, &quot;kafkarest&quot;)) {
					pData-&gt;batchFormat = FMT_KAFKAREST;
				} else if (!strcmp(batchFormatName, &quot;lokirest&quot;)) {
					pData-&gt;batchFormat = FMT_LOKIREST;
				}</B></FONT>
<A NAME="5"></A>			} else {
				LogError(0, NO_ERRCODE, &quot;error: 'batch.format' %s unknown defaulting to 'newline'&quot;,
					batchFormatName);
<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match369-1.html#5',3,'match369-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;batch.maxbytes&quot;)) {
			pData-&gt;maxBatchBytes = (size_t) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;batch.maxsize&quot;)) {
			pData-&gt;maxBatchSize = (size_t) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;compress&quot;)) {
			pData-&gt;compress = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;compress.level&quot;)) {
			compressionLevel = pvals[i].val.d.n;</B></FONT>
			if (compressionLevel == -1 || (compressionLevel &gt;= 0 &amp;&amp; compressionLevel &lt; 10)) {
				pData-&gt;compressionLevel = compressionLevel;
			} else {
				LogError(0, NO_ERRCODE, &quot;omhttp: invalid compress.level %d using default instead,&quot;
					&quot;valid levels are -1 and 0-9&quot;,
					compressionLevel);
<A NAME="1"></A>			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;allowunsignedcerts&quot;)) {
			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match369-1.html#1',3,'match369-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;skipverifyhost&quot;)) {
			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;usehttps&quot;)) {
			pData-&gt;useHttps = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.cacert&quot;)) {
			pData-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;caCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));</B></FONT>
				LogError(0, RS_RET_NO_FILE_ACCESS,
						&quot;error: 'tls.cacert' file %s couldn't be accessed: %s\n&quot;,
<A NAME="8"></A>						pData-&gt;caCertFile, errStr);
			} else {
				fclose(fp);
<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match369-1.html#8',3,'match369-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.mycert&quot;)) {
			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));</B></FONT>
				LogError(0, RS_RET_NO_FILE_ACCESS,
						&quot;error: 'tls.mycert' file %s couldn't be accessed: %s\n&quot;,
<A NAME="7"></A>						pData-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match369-1.html#7',3,'match369-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.myprivkey&quot;)) {
			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myPrivKeyFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));</B></FONT>
				LogError(0, RS_RET_NO_FILE_ACCESS,
						&quot;error: 'tls.myprivkey' file %s couldn't be accessed: %s\n&quot;,
<A NAME="4"></A>						pData-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match369-1.html#4',3,'match369-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;reloadonhup&quot;)) {
			pData-&gt;reloadOnHup= pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;retry&quot;)) {
			pData-&gt;retryFailures = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;retry.ruleset&quot;)) {
			pData-&gt;retryRulesetName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;ratelimit.burst&quot;)) {
			pData-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;</B></FONT>
		} else if(!strcmp(actpblk.descr[i].name, &quot;ratelimit.interval&quot;)) {
			pData-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else {
			LogError(0, RS_RET_INTERNAL_ERROR, &quot;omhttp: program error, &quot;
				&quot;non-handled param '%s'&quot;, actpblk.descr[i].name);
		}
	}

	if(pData-&gt;pwd != NULL &amp;&amp; pData-&gt;uid == NULL) {
		LogError(0, RS_RET_UID_MISSING,
			&quot;omhttp: password is provided, but no uid &quot;
			&quot;- action definition invalid&quot;);
		ABORT_FINALIZE(RS_RET_UID_MISSING);
	}
	if(pData-&gt;httpheaderkey != NULL &amp;&amp; pData-&gt;httpheadervalue == NULL) {
		LogError(0, RS_RET_UID_MISSING,
			&quot;omhttp: http header key is provided, but no http header value &quot;
			&quot;- action definition invalid&quot;);
		ABORT_FINALIZE(RS_RET_UID_MISSING);
	}
	if(pData-&gt;dynRestPath &amp;&amp; pData-&gt;restPath == NULL) {
		LogError(0, RS_RET_CONFIG_ERROR,
			&quot;omhttp: requested dynamic rest path, but no name for rest &quot;
			&quot;path template given - action definition invalid&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	if (pData-&gt;uid != NULL)
		CHKiRet(computeAuthHeader((char*) pData-&gt;uid, (char*) pData-&gt;pwd, &amp;pData-&gt;authBuf));
	if (pData-&gt;httpcontenttype != NULL)
		CHKiRet(computeApiHeader((char*) &quot;Content-Type&quot;,
				(char*) pData-&gt;httpcontenttype, &amp;pData-&gt;headerContentTypeBuf));

	if (pData-&gt;httpheaderkey != NULL)
		CHKiRet(computeApiHeader((char*) pData-&gt;httpheaderkey,
				(char*) pData-&gt;httpheadervalue, &amp;pData-&gt;headerBuf));

	iNumTpls = 1;
	if(pData-&gt;dynRestPath) ++iNumTpls;
	DBGPRINTF(&quot;omhttp: requesting %d templates\n&quot;, iNumTpls);
	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)

	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
					    &quot; StdJSONFmt&quot; : (char*)pData-&gt;tplName),
		OMSR_NO_RQD_TPL_OPTS));


	/* we need to request additional templates. If we have a dynamic search index,
	 * it will always be string 1. Type may be 1 or 2, depending on whether search
	 * index is dynamic as well. Rule needs to be followed throughout the module.
	 */
	iNumTpls = 1;
	if(pData-&gt;dynRestPath) {
		CHKiRet(OMSRsetEntry(*ppOMSR, iNumTpls, ustrdup(pData-&gt;restPath),
			OMSR_NO_RQD_TPL_OPTS));
		++iNumTpls;
	}

	if (servers != NULL) {
		pData-&gt;numServers = servers-&gt;nmemb;
		pData-&gt;serverBaseUrls = malloc(servers-&gt;nmemb * sizeof(uchar*));
		if (pData-&gt;serverBaseUrls == NULL) {
			LogError(0, RS_RET_ERR, &quot;omhttp: unable to allocate buffer &quot;
					&quot;for http server configuration.&quot;);
			ABORT_FINALIZE(RS_RET_ERR);
		}

		for(i = 0 ; i &lt; servers-&gt;nmemb ; ++i) {
			serverParam = es_str2cstr(servers-&gt;arr[i], NULL);
			if (serverParam == NULL) {
				LogError(0, RS_RET_ERR, &quot;omhttp: unable to allocate buffer &quot;
					&quot;for http server configuration.&quot;);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			/* Remove a trailing slash if it exists */
			const size_t serverParamLastChar = strlen(serverParam)-1;
			if (serverParam[serverParamLastChar] == '/') {
				serverParam[serverParamLastChar] = '\0';
			}
			CHKiRet(computeBaseUrl(serverParam, pData-&gt;defaultPort, pData-&gt;useHttps,
				pData-&gt;serverBaseUrls + i));
			free(serverParam);
			serverParam = NULL;
		}
	} else {
		LogMsg(0, RS_RET_OK, LOG_WARNING,
			&quot;omhttp: No servers specified, using localhost&quot;);
		pData-&gt;numServers = 1;
		pData-&gt;serverBaseUrls = malloc(sizeof(uchar*));
		if (pData-&gt;serverBaseUrls == NULL) {
			LogError(0, RS_RET_ERR, &quot;omhttp: unable to allocate buffer &quot;
					&quot;for http server configuration.&quot;);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		CHKiRet(computeBaseUrl(&quot;localhost&quot;, pData-&gt;defaultPort, pData-&gt;useHttps, pData-&gt;serverBaseUrls));
	}

	if (pData-&gt;retryFailures) {
		CHKiRet(ratelimitNew(&amp;pData-&gt;ratelimiter, &quot;omhttp&quot;, NULL));
		ratelimitSetLinuxLike(pData-&gt;ratelimiter, pData-&gt;ratelimitInterval, pData-&gt;ratelimitBurst);
		ratelimitSetNoTimeCache(pData-&gt;ratelimiter);
	}

	/* node created, let's add to list of instance configs for the module */
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = pData;
	} else {
		loadModConf-&gt;tail-&gt;next = pData;
		loadModConf-&gt;tail = pData;
	}

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
	if (serverParam)
		free(serverParam);
ENDnewActInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;root = pModConf-&gt;tail = NULL;
ENDbeginCnfLoad


BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
ENDendCnfLoad


BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		ruleset_t *pRuleset;
		rsRetVal localRet;

		if (inst-&gt;retryRulesetName) {
			localRet = ruleset.GetRuleset(pModConf-&gt;pConf, &amp;pRuleset, inst-&gt;retryRulesetName);
			if(localRet == RS_RET_NOT_FOUND) {
				LogError(0, localRet, &quot;omhttp: retry.ruleset '%s' not found - &quot;
						&quot;no retry ruleset will be used&quot;, inst-&gt;retryRulesetName);
			} else {
				inst-&gt;retryRuleset = pRuleset;
			}
		}
	}
ENDcheckCnf


BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


// HUP handling for the instance...
BEGINdoHUP
CODESTARTdoHUP
	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
	if (pData-&gt;fdErrFile != -1) {
		close(pData-&gt;fdErrFile);
		pData-&gt;fdErrFile = -1;
	}
	pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
ENDdoHUP


// HUP handling for the worker...
BEGINdoHUPWrkr
CODESTARTdoHUPWrkr
	if (pWrkrData-&gt;pData-&gt;reloadOnHup) {
		LogMsg(0, NO_ERRCODE, LOG_INFO, &quot;omhttp: received HUP reloading curl handles&quot;);
		curlCleanup(pWrkrData);
		CHKiRet(curlSetup(pWrkrData));
	}
finalize_it:
ENDdoHUPWrkr


BEGINmodExit
CODESTARTmodExit
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
	curl_global_cleanup();
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	statsobj.Destruct(&amp;httpStats);
ENDmodExit

NO_LEGACY_CONF_parseSelectorAct

BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_doHUP
CODEqueryEtryPt_doHUPWrkr /* Load the worker HUP handling code */
CODEqueryEtryPt_TXIF_OMOD_QUERIES /* we support the transactional interface! */
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	CHKiRet(statsobj.Construct(&amp;httpStats));
	CHKiRet(statsobj.SetName(httpStats, (uchar *)&quot;omhttp&quot;));
	CHKiRet(statsobj.SetOrigin(httpStats, (uchar*)&quot;omhttp&quot;));

	STATSCOUNTER_INIT(ctrMessagesSubmitted, mutCtrMessagesSubmitted);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)&quot;messages.submitted&quot;,
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSubmitted));

	STATSCOUNTER_INIT(ctrMessagesSuccess, mutCtrMessagesSuccess);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)&quot;messages.success&quot;,
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSuccess));

	STATSCOUNTER_INIT(ctrMessagesFail, mutCtrMessagesFail);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)&quot;messages.fail&quot;,
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesFail));

	STATSCOUNTER_INIT(ctrMessagesRetry, mutCtrMessagesRetry);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)&quot;messages.retry&quot;,
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesRetry));

	STATSCOUNTER_INIT(ctrHttpRequestCount, mutCtrHttpRequestCount);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)&quot;request.count&quot;,
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestCount));

	STATSCOUNTER_INIT(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)&quot;request.success&quot;,
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestSuccess));

	STATSCOUNTER_INIT(ctrHttpRequestFail, mutCtrHttpRequestFail);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)&quot;request.fail&quot;,
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestFail));

	STATSCOUNTER_INIT(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)&quot;request.status.success&quot;,
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusSuccess));

	STATSCOUNTER_INIT(ctrHttpStatusFail, mutCtrHttpStatusFail);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)&quot;request.status.fail&quot;,
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusFail));

	CHKiRet(statsobj.ConstructFinalize(httpStats));

	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
		LogError(0, RS_RET_OBJ_CREATION_FAILED, &quot;CURL fail. -http disabled&quot;);
		ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
	}

	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT(&quot;omhttp&quot;), sizeof(&quot;omhttp&quot;) - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
ENDmodInit

/* vi:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmkubernetes.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmkubernetes.c
 * This is a message modification module. It uses metadata obtained
 * from the message to query Kubernetes and obtain additional metadata
 * relating to the container instance.
 *
 * Inspired by:
 * https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter
 *
 * NOTE: read comments in module-template.h for details on the calling interface!
 *
 * Copyright 2016 Red Hat Inc.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* needed for asprintf */
#ifndef _GNU_SOURCE
#  define _GNU_SOURCE
#endif

#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;libestr.h&gt;
#include &lt;liblognorm.h&gt;
#include &lt;json.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;curl/easy.h&gt;
#include &lt;pthread.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;regexp.h&quot;
#include &quot;hashtable.h&quot;
#include &quot;hashtable_itr.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;datetime.h&quot;

/* static data */
MODULE_TYPE_OUTPUT /* this is technically an output plugin */
MODULE_TYPE_KEEP /* releasing the module would cause a leak through libcurl */
MODULE_CNFNAME(&quot;mmkubernetes&quot;)
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(regexp)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(datetime)

#define HAVE_LOADSAMPLESFROMSTRING 1
#if defined(NO_LOADSAMPLESFROMSTRING)
#undef HAVE_LOADSAMPLESFROMSTRING
#endif
/* original from fluentd plugin:
 * 'var\.log\.containers\.(?&lt;pod_name&gt;[a-z0-9]([-a-z0-9]*[a-z0-9])?\
 *   (\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*)_(?&lt;namespace&gt;[^_]+)_\
 *   (?&lt;container_name&gt;.+)-(?&lt;docker_id&gt;[a-z0-9]{64})\.log$'
 * this is for _tag_ match, not actual filename match - in_tail turns filename
 * into a fluentd tag
 */
#define DFLT_FILENAME_LNRULES &quot;rule=:/var/log/containers/%pod_name:char-to:_%_&quot;\
	&quot;%namespace_name:char-to:_%_%container_name_and_id:char-to:.%.log&quot;
#define DFLT_FILENAME_RULEBASE &quot;/etc/rsyslog.d/k8s_filename.rulebase&quot;
/* original from fluentd plugin:
 *   '^(?&lt;name_prefix&gt;[^_]+)_(?&lt;container_name&gt;[^\._]+)\
 *     (\.(?&lt;container_hash&gt;[^_]+))?_(?&lt;pod_name&gt;[^_]+)_\
 *     (?&lt;namespace&gt;[^_]+)_[^_]+_[^_]+$'
 */
#define DFLT_CONTAINER_LNRULES &quot;rule=:%k8s_prefix:char-to:_%_%container_name:char-to:.%.&quot;\
	&quot;%container_hash:char-to:_%_&quot;\
	&quot;%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%\n&quot;\
	&quot;rule=:%k8s_prefix:char-to:_%_%container_name:char-to:_%_&quot;\
	&quot;%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%&quot;
#define DFLT_CONTAINER_RULEBASE &quot;/etc/rsyslog.d/k8s_container_name.rulebase&quot;
#define DFLT_SRCMD_PATH &quot;$!metadata!filename&quot;
#define DFLT_DSTMD_PATH &quot;$!&quot;
#define DFLT_DE_DOT 1 /* true */
#define DFLT_DE_DOT_SEPARATOR &quot;_&quot;
#define DFLT_CONTAINER_NAME &quot;$!CONTAINER_NAME&quot; /* name of variable holding CONTAINER_NAME value */
#define DFLT_CONTAINER_ID_FULL &quot;$!CONTAINER_ID_FULL&quot; /* name of variable holding CONTAINER_ID_FULL value */
#define DFLT_KUBERNETES_URL &quot;https://kubernetes.default.svc.cluster.local:443&quot;
#define DFLT_BUSY_RETRY_INTERVAL 5 /* retry every 5 seconds */
#define DFLT_SSL_PARTIAL_CHAIN 0 /* disallow X509_V_FLAG_PARTIAL_CHAIN by default */
#define DFLT_CACHE_ENTRY_TTL 3600 /* delete entries from the cache older than 3600 seconds */
#define DFLT_CACHE_EXPIRE_INTERVAL -1 /* delete all expired entries from the cache every N seconds
					 -1 disables cache expiration/ttl checking
					 0 means - run cache expiration for every record */

/* only support setting the partial chain flag on openssl platforms that have the define */
#if defined(ENABLE_OPENSSL) &amp;&amp; defined(X509_V_FLAG_PARTIAL_CHAIN)
#define SUPPORT_SSL_PARTIAL_CHAIN 1
#endif

struct cache_entry_s {
	time_t ttl; /* when this entry should expire */
	void *data; /* the user data */
};

static struct cache_s {
	const uchar *kbUrl;
	struct hashtable *mdHt;
	struct hashtable *nsHt;
	pthread_mutex_t *cacheMtx;
	int lastBusyTime; /* when we got the last busy response from kubernetes */
	time_t expirationTime; /* if cache expiration checking is enable, time to check for expiration */
} **caches;

typedef struct {
	int nmemb;
	uchar **patterns;
	regex_t *regexps;
} annotation_match_t;

/* module configuration data */
struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	uchar *kubernetesUrl;	/* scheme, host, port, and optional path prefix for Kubernetes API lookups */
	uchar *srcMetadataPath;	/* where to get data for kubernetes queries */
	uchar *dstMetadataPath;	/* where to put metadata obtained from kubernetes */
	uchar *caCertFile; /* File holding the CA cert (+optional chain) of CA that issued the Kubernetes server cert */
	uchar *myCertFile; /* File holding cert corresponding to private key used for client cert auth */
	uchar *myPrivKeyFile; /* File holding private key corresponding to cert used for client cert auth */
	sbool allowUnsignedCerts; /* For testing/debugging - do not check for CA certs (CURLOPT_SSL_VERIFYPEER FALSE) */
	sbool skipVerifyHost; /* For testing/debugging - skip cert hostname verify (CURLOPT_SSL_VERIFYHOST FALSE) */
	uchar *token; /* The token value to use to authenticate to Kubernetes - takes precedence over tokenFile */
	uchar *tokenFile; /* The file whose contents is the token value to use to authenticate to Kubernetes */
	sbool de_dot; /* If true (default), convert '.' characters in labels &amp; annotations to de_dot_separator */
	uchar *de_dot_separator; /* separator character (default '_') to use for de_dotting */
	size_t de_dot_separator_len; /* length of separator character */
	annotation_match_t annotation_match; /* annotation keys must match these to be included in record */
	char *fnRules; /* lognorm rules for container log filename match */
	uchar *fnRulebase; /* lognorm rulebase filename for container log filename match */
	char *contRules; /* lognorm rules for CONTAINER_NAME value match */
	uchar *contRulebase; /* lognorm rulebase filename for CONTAINER_NAME value match */
	int busyRetryInterval; /* how to handle 429 response - 0 means error, non-zero means retry every N seconds */
	sbool sslPartialChain; /* if true, allow using intermediate certs without root certs */
	int cacheEntryTTL; /* delete entries from the cache if they are older than this many seconds */
	int cacheExpireInterval; /* delete all expired entries from the cache every this many seconds */
};

/* action (instance) configuration data */
typedef struct _instanceData {
	uchar *kubernetesUrl;	/* scheme, host, port, and optional path prefix for Kubernetes API lookups */
	msgPropDescr_t *srcMetadataDescr;	/* where to get data for kubernetes queries */
	uchar *dstMetadataPath;	/* where to put metadata obtained from kubernetes */
	uchar *caCertFile; /* File holding the CA cert (+optional chain) of CA that issued the Kubernetes server cert */
	uchar *myCertFile; /* File holding cert corresponding to private key used for client cert auth */
	uchar *myPrivKeyFile; /* File holding private key corresponding to cert used for client cert auth */
	sbool allowUnsignedCerts; /* For testing/debugging - do not check for CA certs (CURLOPT_SSL_VERIFYPEER FALSE) */
	sbool skipVerifyHost; /* For testing/debugging - skip cert hostname verify (CURLOPT_SSL_VERIFYHOST FALSE) */
	uchar *token; /* The token value to use to authenticate to Kubernetes - takes precedence over tokenFile */
	uchar *tokenFile; /* The file whose contents is the token value to use to authenticate to Kubernetes */
	sbool de_dot; /* If true (default), convert '.' characters in labels &amp; annotations to de_dot_separator */
	uchar *de_dot_separator; /* separator character (default '_') to use for de_dotting */
	size_t de_dot_separator_len; /* length of separator character */
	annotation_match_t annotation_match; /* annotation keys must match these to be included in record */
	char *fnRules; /* lognorm rules for container log filename match */
	uchar *fnRulebase; /* lognorm rulebase filename for container log filename match */
	ln_ctx fnCtxln;	/**&lt; context to be used for liblognorm */
	char *contRules; /* lognorm rules for CONTAINER_NAME value match */
	uchar *contRulebase; /* lognorm rulebase filename for CONTAINER_NAME value match */
	ln_ctx contCtxln;	/**&lt; context to be used for liblognorm */
	msgPropDescr_t *contNameDescr; /* CONTAINER_NAME field */
	msgPropDescr_t *contIdFullDescr; /* CONTAINER_ID_FULL field */
	struct cache_s *cache;
	int busyRetryInterval; /* how to handle 429 response - 0 means error, non-zero means retry every N seconds */
	sbool sslPartialChain; /* if true, allow using intermediate certs without root certs */
	int cacheEntryTTL; /* delete entries from the cache if they are older than this many seconds */
	int cacheExpireInterval; /* delete all expired entries from the cache every this many seconds */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	CURL *curlCtx;
	struct curl_slist *curlHdr;
	char *curlRply;
	size_t curlRplyLen;
	statsobj_t *stats; /* stats for this instance */
	STATSCOUNTER_DEF(k8sRecordSeen, mutK8sRecordSeen);
	STATSCOUNTER_DEF(namespaceMetadataSuccess, mutNamespaceMetadataSuccess);
	STATSCOUNTER_DEF(namespaceMetadataNotFound, mutNamespaceMetadataNotFound);
	STATSCOUNTER_DEF(namespaceMetadataBusy, mutNamespaceMetadataBusy);
	STATSCOUNTER_DEF(namespaceMetadataError, mutNamespaceMetadataError);
	STATSCOUNTER_DEF(podMetadataSuccess, mutPodMetadataSuccess);
	STATSCOUNTER_DEF(podMetadataNotFound, mutPodMetadataNotFound);
	STATSCOUNTER_DEF(podMetadataBusy, mutPodMetadataBusy);
	STATSCOUNTER_DEF(podMetadataError, mutPodMetadataError);
	STATSCOUNTER_DEF(podCacheNumEntries, mutPodCacheNumEntries);
	STATSCOUNTER_DEF(namespaceCacheNumEntries, mutNamespaceCacheNumEntries);
	STATSCOUNTER_DEF(podCacheHits, mutPodCacheHits);
	STATSCOUNTER_DEF(namespaceCacheHits, mutNamespaceCacheHits);
	/* cache misses should correspond to metadata success, busy, etc. k8s api calls */
	STATSCOUNTER_DEF(podCacheMisses, mutPodCacheMisses);
	STATSCOUNTER_DEF(namespaceCacheMisses, mutNamespaceCacheMisses);
} wrkrInstanceData_t;
<A NAME="0"></A>
/* module parameters (v6 config format) */
static struct cnfparamdescr modpdescr[] = {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#0',2,'match369-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;kubernetesurl&quot;, eCmdHdlrString, 0 },
	{ &quot;srcmetadatapath&quot;, eCmdHdlrString, 0 },
	{ &quot;dstmetadatapath&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.cacert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.mycert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.myprivkey&quot;, eCmdHdlrString, 0 },
	{ &quot;allowunsignedcerts&quot;, eCmdHdlrBinary, 0 },
	{ &quot;skipverifyhost&quot;, eCmdHdlrBinary, 0 },
	{ &quot;token&quot;, eCmdHdlrString, 0 },
	{ &quot;tokenfile&quot;, eCmdHdlrString, 0 },
	{ &quot;annotation_match&quot;, eCmdHdlrArray, 0 },
	{ &quot;de_dot&quot;, eCmdHdlrBinary, 0 },
	{ &quot;de_dot_separator&quot;, eCmdHdlrString, 0 },
	{ &quot;filenamerulebase&quot;, eCmdHdlrString, 0 },
	{ &quot;containerrulebase&quot;, eCmdHdlrString, 0 },
	{ &quot;busyretryinterval&quot;, eCmdHdlrInt, 0 },
	{ &quot;sslpartialchain&quot;, eCmdHdlrBinary, 0 },
	{ &quot;cacheentryttl&quot;, eCmdHdlrInt, 0 },
	{ &quot;cacheexpireinterval&quot;, eCmdHdlrInt, 0 }
#if HAVE_LOADSAMPLESFROMSTRING == 1
	,
	{ &quot;filenamerules&quot;, eCmdHdlrArray, 0 },
	{ &quot;containerrules&quot;, eCmdHdlrArray, 0 }
#endif
};
static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
<A NAME="3"></A>};

/* action (instance) parameters (v6 config format) */
static struct cnfparamdescr actpdescr[] = {</B></FONT><FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#3',2,'match369-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>
	{ &quot;kubernetesurl&quot;, eCmdHdlrString, 0 },
	{ &quot;srcmetadatapath&quot;, eCmdHdlrString, 0 },
	{ &quot;dstmetadatapath&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.cacert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.mycert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.myprivkey&quot;, eCmdHdlrString, 0 },
	{ &quot;allowunsignedcerts&quot;, eCmdHdlrBinary, 0 },
	{ &quot;skipverifyhost&quot;, eCmdHdlrBinary, 0 },
	{ &quot;token&quot;, eCmdHdlrString, 0 },
	{ &quot;tokenfile&quot;, eCmdHdlrString, 0 },</B></FONT>
	{ &quot;annotation_match&quot;, eCmdHdlrArray, 0 },
	{ &quot;de_dot&quot;, eCmdHdlrBinary, 0 },
	{ &quot;de_dot_separator&quot;, eCmdHdlrString, 0 },
	{ &quot;filenamerulebase&quot;, eCmdHdlrString, 0 },
	{ &quot;containerrulebase&quot;, eCmdHdlrString, 0 },
	{ &quot;busyretryinterval&quot;, eCmdHdlrInt, 0 },
	{ &quot;sslpartialchain&quot;, eCmdHdlrBinary, 0 },
	{ &quot;cacheentryttl&quot;, eCmdHdlrInt, 0 },
	{ &quot;cacheexpireinterval&quot;, eCmdHdlrInt, 0 }
#if HAVE_LOADSAMPLESFROMSTRING == 1
	,
	{ &quot;filenamerules&quot;, eCmdHdlrArray, 0 },
	{ &quot;containerrules&quot;, eCmdHdlrArray, 0 }
#endif
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

static modConfData_t *loadModConf = NULL;	/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;	/* modConf ptr to use for the current exec process */

static void free_annotationmatch(annotation_match_t *match) {
	if (match) {
		for(int ii = 0 ; ii &lt; match-&gt;nmemb; ++ii) {
			if (match-&gt;patterns)
				free(match-&gt;patterns[ii]);
			if (match-&gt;regexps)
				regexp.regfree(&amp;match-&gt;regexps[ii]);
		}
		free(match-&gt;patterns);
		match-&gt;patterns = NULL;
		free(match-&gt;regexps);
		match-&gt;regexps = NULL;
		match-&gt;nmemb = 0;
	}
}

static int init_annotationmatch(annotation_match_t *match, struct cnfarray *ar) {
	DEFiRet;

	match-&gt;nmemb = ar-&gt;nmemb;
	CHKmalloc(match-&gt;patterns = calloc(sizeof(uchar*), match-&gt;nmemb));
	CHKmalloc(match-&gt;regexps = calloc(sizeof(regex_t), match-&gt;nmemb));
	for(int jj = 0; jj &lt; ar-&gt;nmemb; ++jj) {
		int rexret = 0;
		match-&gt;patterns[jj] = (uchar*)es_str2cstr(ar-&gt;arr[jj], NULL);
		rexret = regexp.regcomp(&amp;match-&gt;regexps[jj],
				(char *)match-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
		if (0 != rexret) {
			char errMsg[512];
			regexp.regerror(rexret, &amp;match-&gt;regexps[jj], errMsg, sizeof(errMsg));
			iRet = RS_RET_CONFIG_ERROR;
			LogError(0, iRet,
					&quot;error: could not compile annotation_match string [%s]&quot;
					&quot; into an extended regexp - %d: %s\n&quot;,
					match-&gt;patterns[jj], rexret, errMsg);
			break;
		}
	}
finalize_it:
	if (iRet)
		free_annotationmatch(match);
	RETiRet;
}

static int copy_annotationmatch(annotation_match_t *src, annotation_match_t *dest) {
	DEFiRet;

	dest-&gt;nmemb = src-&gt;nmemb;
	CHKmalloc(dest-&gt;patterns = malloc(sizeof(uchar*) * dest-&gt;nmemb));
	CHKmalloc(dest-&gt;regexps = calloc(sizeof(regex_t), dest-&gt;nmemb));
	for(int jj = 0 ; jj &lt; src-&gt;nmemb ; ++jj) {
		CHKmalloc(dest-&gt;patterns[jj] = (uchar*)strdup((char *)src-&gt;patterns[jj]));
		/* assumes was already successfully compiled */
		regexp.regcomp(&amp;dest-&gt;regexps[jj], (char *)dest-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
	}
finalize_it:
	if (iRet)
	free_annotationmatch(dest);
	RETiRet;
}

/* takes a hash of annotations and returns another json object hash containing only the
 * keys that match - this logic is taken directly from fluent-plugin-kubernetes_metadata_filter
 * except that we do not add the key multiple times to the object to be returned
 */
static struct json_object *match_annotations(annotation_match_t *match,
		struct json_object *annotations) {
	struct json_object *ret = NULL;

	for (int jj = 0; jj &lt; match-&gt;nmemb; ++jj) {
		struct json_object_iterator it = json_object_iter_begin(annotations);
		struct json_object_iterator itEnd = json_object_iter_end(annotations);
		for (;!json_object_iter_equal(&amp;it, &amp;itEnd); json_object_iter_next(&amp;it)) {
			const char *const key = json_object_iter_peek_name(&amp;it);
			if (!ret || !fjson_object_object_get_ex(ret, key, NULL)) {
				if (!regexp.regexec(&amp;match-&gt;regexps[jj], key, 0, NULL, 0)) {
					if (!ret) {
						ret = json_object_new_object();
					}
					json_object_object_add(ret, key,
						json_object_get(json_object_iter_peek_value(&amp;it)));
				}
			}
		}
	}
	return ret;
}

/* This will take a hash of labels or annotations and will de_dot the keys.
 * It will return a brand new hash.  AFAICT, there is no safe way to
 * iterate over the hash while modifying it in place.
 */
static struct json_object *de_dot_json_object(struct json_object *jobj,
		const char *delim, size_t delim_len) {
	struct json_object *ret = NULL;
	struct json_object_iterator it = json_object_iter_begin(jobj);
	struct json_object_iterator itEnd = json_object_iter_end(jobj);
	es_str_t *new_es_key = NULL;
	DEFiRet;

	ret = json_object_new_object();
	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
		const char *const key = json_object_iter_peek_name(&amp;it);
		const char *cc = strstr(key, &quot;.&quot;);
		if (NULL == cc) {
			json_object_object_add(ret, key,
					json_object_get(json_object_iter_peek_value(&amp;it)));
		} else {
			char *new_key = NULL;
			const char *prevcc = key;
			new_es_key = es_newStrFromCStr(key, (es_size_t)(cc-prevcc));
			while (cc) {
				if (es_addBuf(&amp;new_es_key, (char *)delim, (es_size_t)delim_len))
					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
				cc += 1; /* one past . */
				prevcc = cc; /* beginning of next substring */
				if ((cc = strstr(prevcc, &quot;.&quot;)) || (cc = strchr(prevcc, '\0'))) {
					if (es_addBuf(&amp;new_es_key, (char *)prevcc, (es_size_t)(cc-prevcc)))
						ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
					if (!*cc)
						cc = NULL; /* EOS - done */
				}
			}
			new_key = es_str2cstr(new_es_key, NULL);
			es_deleteStr(new_es_key);
			new_es_key = NULL;
			json_object_object_add(ret, new_key,
					json_object_get(json_object_iter_peek_value(&amp;it)));
			free(new_key);
		}
		json_object_iter_next(&amp;it);
	}
finalize_it:
	if (iRet != RS_RET_OK) {
		json_object_put(ret);
		ret = NULL;
	}
	if (new_es_key)
		es_deleteStr(new_es_key);
	return ret;
}

/* given a &quot;metadata&quot; object field, do
 * - make sure &quot;annotations&quot; field has only the matching keys
 * - de_dot the &quot;labels&quot; and &quot;annotations&quot; fields keys
 * This modifies the jMetadata object in place
 */
static void parse_labels_annotations(struct json_object *jMetadata,
		annotation_match_t *match, sbool de_dot,
		const char *delim, size_t delim_len) {
	struct json_object *jo = NULL;

	if (fjson_object_object_get_ex(jMetadata, &quot;annotations&quot;, &amp;jo)) {
		if ((jo = match_annotations(match, jo)))
			json_object_object_add(jMetadata, &quot;annotations&quot;, jo);
		else
			json_object_object_del(jMetadata, &quot;annotations&quot;);
	}
	/* dedot labels and annotations */
	if (de_dot) {
		struct json_object *jo2 = NULL;
		if (fjson_object_object_get_ex(jMetadata, &quot;annotations&quot;, &amp;jo)) {
			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
				json_object_object_add(jMetadata, &quot;annotations&quot;, jo2);
			}
		}
		if (fjson_object_object_get_ex(jMetadata, &quot;labels&quot;, &amp;jo)) {
			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
				json_object_object_add(jMetadata, &quot;labels&quot;, jo2);
			}
		}
	}
}

#if HAVE_LOADSAMPLESFROMSTRING == 1
static int array_to_rules(struct cnfarray *ar, char **rules) {
	DEFiRet;
	es_str_t *tmpstr = NULL;
	es_size_t size = 0;

	if (rules == NULL)
		FINALIZE;
	*rules = NULL;
	if (!ar-&gt;nmemb)
		FINALIZE;
	for (int jj = 0; jj &lt; ar-&gt;nmemb; jj++)
		size += es_strlen(ar-&gt;arr[jj]);
	if (!size)
		FINALIZE;
	CHKmalloc(tmpstr = es_newStr(size));
	CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[0])));
	CHKiRet((es_addBufConstcstr(&amp;tmpstr, &quot;\n&quot;)));
	for(int jj=1; jj &lt; ar-&gt;nmemb; ++jj) {
		CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[jj])));
		CHKiRet((es_addBufConstcstr(&amp;tmpstr, &quot;\n&quot;)));
	}
	CHKiRet((es_addBufConstcstr(&amp;tmpstr, &quot;\0&quot;)));
	CHKmalloc(*rules = es_str2cstr(tmpstr, NULL));
finalize_it:
	if (tmpstr) {
		es_deleteStr(tmpstr);
	}
	if (iRet != RS_RET_OK) {
		free(*rules);
		*rules = NULL;
	}
	RETiRet;
}
#endif

/* callback for liblognorm error messages */
static void
errCallBack(void __attribute__((unused)) *cookie, const char *msg,
	    size_t __attribute__((unused)) lenMsg)
{
	LogError(0, RS_RET_ERR_LIBLOGNORM, &quot;liblognorm error: %s&quot;, msg);
}

static rsRetVal
set_lnctx(ln_ctx *ctxln, char *instRules, uchar *instRulebase, char *modRules, uchar *modRulebase)
{
	DEFiRet;
	if (ctxln == NULL)
		FINALIZE;
	CHKmalloc(*ctxln = ln_initCtx());
	ln_setErrMsgCB(*ctxln, errCallBack, NULL);
	if(instRules) {
#if HAVE_LOADSAMPLESFROMSTRING == 1
		if(ln_loadSamplesFromString(*ctxln, instRules) !=0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rules '%s' &quot;
					&quot;could not be loaded&quot;, instRules);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
#else
		(void)instRules;
#endif
	} else if(instRulebase) {
		if(ln_loadSamples(*ctxln, (char*) instRulebase) != 0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rulebase '%s' &quot;
					&quot;could not be loaded&quot;, instRulebase);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
	} else if(modRules) {
#if HAVE_LOADSAMPLESFROMSTRING == 1
		if(ln_loadSamplesFromString(*ctxln, modRules) !=0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rules '%s' &quot;
					&quot;could not be loaded&quot;, modRules);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
#else
		(void)modRules;
#endif
	} else if(modRulebase) {
		if(ln_loadSamples(*ctxln, (char*) modRulebase) != 0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rulebase '%s' &quot;
					&quot;could not be loaded&quot;, modRulebase);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
	}
finalize_it:
	if (iRet != RS_RET_OK){
		ln_exitCtx(*ctxln);
		*ctxln = NULL;
	}
	RETiRet;
}

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
	FILE *fp = NULL;
	int ret;
	char errStr[1024];
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;mmkubernetes: &quot;
			&quot;error processing module config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for mmkubernetes:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	loadModConf-&gt;de_dot = DFLT_DE_DOT;
	loadModConf-&gt;busyRetryInterval = DFLT_BUSY_RETRY_INTERVAL;
	loadModConf-&gt;sslPartialChain = DFLT_SSL_PARTIAL_CHAIN;
	loadModConf-&gt;cacheEntryTTL = DFLT_CACHE_ENTRY_TTL;
	loadModConf-&gt;cacheExpireInterval = DFLT_CACHE_EXPIRE_INTERVAL;
<A NAME="2"></A>	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#2',2,'match369-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;kubernetesurl&quot;)) {
			free(loadModConf-&gt;kubernetesUrl);
			loadModConf-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;srcmetadatapath&quot;)) {
			free(loadModConf-&gt;srcMetadataPath);
			loadModConf-&gt;srcMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			/* todo: sanitize the path */
		} else if(!strcmp(modpblk.descr[i].name, &quot;dstmetadatapath&quot;)) {
			free(loadModConf-&gt;dstMetadataPath);
			loadModConf-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			/* todo: sanitize the path */
		} else if(!strcmp(modpblk.descr[i].name, &quot;tls.cacert&quot;)) {
			free(loadModConf-&gt;caCertFile);
			loadModConf-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			fp = fopen((const char*)loadModConf-&gt;caCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.cacert' file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;caCertFile, errStr);
				ABORT_FINALIZE(iRet);
<A NAME="8"></A>			} else {
				fclose(fp);
				fp = NULL;
<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#8',2,'match369-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;tls.mycert&quot;)) {
			free(loadModConf-&gt;myCertFile);
			loadModConf-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;myCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));</B></FONT>
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.mycert' file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;myCertFile, errStr);
<A NAME="7"></A>			} else {
				fclose(fp);
				fp = NULL;
<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#7',2,'match369-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;tls.myprivkey&quot;)) {
			loadModConf-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;myPrivKeyFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));</B></FONT>
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.myprivkey' file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;myPrivKeyFile, errStr);
			} else {
<A NAME="1"></A>				fclose(fp);
				fp = NULL;
			}
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#1',2,'match369-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;allowunsignedcerts&quot;)) {
			loadModConf-&gt;allowUnsignedCerts = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;skipverifyhost&quot;)) {
			loadModConf-&gt;skipVerifyHost = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;token&quot;)) {
			free(loadModConf-&gt;token);
			loadModConf-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;tokenfile&quot;)) {
			free(loadModConf-&gt;tokenFile);
			loadModConf-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;tokenFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));</B></FONT>
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: token file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;tokenFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;annotation_match&quot;)) {
<A NAME="10"></A>			free_annotationmatch(&amp;loadModConf-&gt;annotation_match);
			if ((ret = init_annotationmatch(&amp;loadModConf-&gt;annotation_match, pvals[i].val.d.ar)))
				ABORT_FINALIZE(ret);
<FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#10',2,'match369-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;de_dot&quot;)) {
			loadModConf-&gt;de_dot = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;de_dot_separator&quot;)) {
			free(loadModConf-&gt;de_dot_separator);
			loadModConf-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, &quot;filenamerules&quot;)) {</B></FONT>
			free(loadModConf-&gt;fnRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;fnRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;filenamerulebase&quot;)) {
			free(loadModConf-&gt;fnRulebase);
			loadModConf-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;fnRulebase, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: filenamerulebase file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;fnRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, &quot;containerrules&quot;)) {
			free(loadModConf-&gt;contRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;contRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;containerrulebase&quot;)) {
			free(loadModConf-&gt;contRulebase);
			loadModConf-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;contRulebase, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: containerrulebase file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;contRulebase, errStr);
				ABORT_FINALIZE(iRet);
<A NAME="5"></A>			} else {
				fclose(fp);
				fp = NULL;
<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#5',2,'match369-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;busyretryinterval&quot;)) {
			loadModConf-&gt;busyRetryInterval = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;sslpartialchain&quot;)) {
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
			loadModConf-&gt;sslPartialChain = pvals[i].val.d.n;
#else
			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
					&quot;sslpartialchain is only supported for OpenSSL\n&quot;);
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;cacheentryttl&quot;)) {
			loadModConf-&gt;cacheEntryTTL = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;cacheexpireinterval&quot;)) {
			loadModConf-&gt;cacheExpireInterval = pvals[i].val.d.n;</B></FONT>
		} else {
			dbgprintf(&quot;mmkubernetes: program error, non-handled &quot;
				&quot;param '%s' in module() block\n&quot;, modpblk.descr[i].name);
			/* todo: error message? */
		}
	}

#if HAVE_LOADSAMPLESFROMSTRING == 1
	if (loadModConf-&gt;fnRules &amp;&amp; loadModConf-&gt;fnRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
				&quot;mmkubernetes: only 1 of filenamerules or filenamerulebase may be used&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (loadModConf-&gt;contRules &amp;&amp; loadModConf-&gt;contRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
				&quot;mmkubernetes: only 1 of containerrules or containerrulebase may be used&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
#endif

	if ((loadModConf-&gt;cacheExpireInterval &gt; -1)) {
		if ((loadModConf-&gt;cacheEntryTTL &lt; 0)) {
			LogError(0, RS_RET_CONFIG_ERROR,
					&quot;mmkubernetes: cacheentryttl value [%d] is invalid - &quot;
					&quot;value must be 0 or greater&quot;,
					loadModConf-&gt;cacheEntryTTL);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}

	/* set defaults */
	if(loadModConf-&gt;srcMetadataPath == NULL)
		loadModConf-&gt;srcMetadataPath = (uchar *) strdup(DFLT_SRCMD_PATH);
	if(loadModConf-&gt;dstMetadataPath == NULL)
		loadModConf-&gt;dstMetadataPath = (uchar *) strdup(DFLT_DSTMD_PATH);
	if(loadModConf-&gt;de_dot_separator == NULL)
		loadModConf-&gt;de_dot_separator = (uchar *) strdup(DFLT_DE_DOT_SEPARATOR);
	if(loadModConf-&gt;de_dot_separator)
		loadModConf-&gt;de_dot_separator_len = strlen((const char *)loadModConf-&gt;de_dot_separator);
#if HAVE_LOADSAMPLESFROMSTRING == 1
	if (loadModConf-&gt;fnRules == NULL &amp;&amp; loadModConf-&gt;fnRulebase == NULL)
		loadModConf-&gt;fnRules = strdup(DFLT_FILENAME_LNRULES);
	if (loadModConf-&gt;contRules == NULL &amp;&amp; loadModConf-&gt;contRulebase == NULL)
		loadModConf-&gt;contRules = strdup(DFLT_CONTAINER_LNRULES);
#else
	if (loadModConf-&gt;fnRulebase == NULL)
		loadModConf-&gt;fnRulebase = (uchar *)strdup(DFLT_FILENAME_RULEBASE);
	if (loadModConf-&gt;contRulebase == NULL)
		loadModConf-&gt;contRulebase = (uchar *)strdup(DFLT_CONTAINER_RULEBASE);
#endif
	caches = calloc(1, sizeof(struct cache_s *));

finalize_it:
	if (fp)
		fclose(fp);
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;kubernetesUrl);
	msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
	free(pData-&gt;srcMetadataDescr);
	free(pData-&gt;dstMetadataPath);
	free(pData-&gt;caCertFile);
	free(pData-&gt;myCertFile);
	free(pData-&gt;myPrivKeyFile);
	free(pData-&gt;token);
	free(pData-&gt;tokenFile);
	free(pData-&gt;fnRules);
	free(pData-&gt;fnRulebase);
	ln_exitCtx(pData-&gt;fnCtxln);
	free(pData-&gt;contRules);
	free(pData-&gt;contRulebase);
	ln_exitCtx(pData-&gt;contCtxln);
	free_annotationmatch(&amp;pData-&gt;annotation_match);
	free(pData-&gt;de_dot_separator);
	msgPropDescrDestruct(pData-&gt;contNameDescr);
	free(pData-&gt;contNameDescr);
	msgPropDescrDestruct(pData-&gt;contIdFullDescr);
	free(pData-&gt;contIdFullDescr);
ENDfreeInstance

static size_t curlCB(char *data, size_t size, size_t nmemb, void *usrptr)
{
	DEFiRet;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t *) usrptr;
	char * buf;
	size_t newlen;

	newlen = pWrkrData-&gt;curlRplyLen + size * nmemb;
	CHKmalloc(buf = realloc(pWrkrData-&gt;curlRply, newlen));
	memcpy(buf + pWrkrData-&gt;curlRplyLen, data, size * nmemb);
	pWrkrData-&gt;curlRply = buf;
	pWrkrData-&gt;curlRplyLen = newlen;

finalize_it:
	if (iRet != RS_RET_OK) {
		return 0;
	}
	return size * nmemb;
}

#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
static CURLcode set_ssl_partial_chain(CURL *curl, void *ssl_ctx, void *userptr)
{
	(void)userptr; /* currently unused */
	CURLcode rv = CURLE_ABORTED_BY_CALLBACK;
	X509_STORE *store = NULL;

	store = SSL_CTX_get_cert_store((SSL_CTX *)ssl_ctx);
	if(!store)
		goto finalize_it;
	if(!X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN))
		goto finalize_it;
	rv = CURLE_OK;
finalize_it:
	return rv;
}
#endif

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	CURL *ctx;
	struct curl_slist *hdr = NULL;
	char *tokenHdr = NULL;
	FILE *fp = NULL;
	char *token = NULL;
	char *statsName = NULL;

	CHKiRet(statsobj.Construct(&amp;(pWrkrData-&gt;stats)));
	if ((-1 == asprintf(&amp;statsName, &quot;mmkubernetes(%s)&quot;, pWrkrData-&gt;pData-&gt;kubernetesUrl)) ||
		(!statsName)) {
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	CHKiRet(statsobj.SetName(pWrkrData-&gt;stats, (uchar *)statsName));
	free(statsName);
	statsName = NULL;
	CHKiRet(statsobj.SetOrigin(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;mmkubernetes&quot;)));
	STATSCOUNTER_INIT(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;recordseen&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;k8sRecordSeen)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataSuccess, pWrkrData-&gt;mutNamespaceMetadataSuccess);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacemetadatasuccess&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataSuccess)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataNotFound, pWrkrData-&gt;mutNamespaceMetadataNotFound);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacemetadatanotfound&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataNotFound)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataBusy, pWrkrData-&gt;mutNamespaceMetadataBusy);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacemetadatabusy&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataBusy)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataError, pWrkrData-&gt;mutNamespaceMetadataError);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacemetadataerror&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataError)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podmetadatasuccess&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataSuccess)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podmetadatanotfound&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataNotFound)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podmetadatabusy&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataBusy)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podmetadataerror&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataError)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheNumEntries, pWrkrData-&gt;mutNamespaceCacheNumEntries);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacecachenumentries&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheNumEntries)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheNumEntries, pWrkrData-&gt;mutPodCacheNumEntries);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podcachenumentries&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheNumEntries)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheHits, pWrkrData-&gt;mutNamespaceCacheHits);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacecachehits&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheHits)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheHits, pWrkrData-&gt;mutPodCacheHits);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podcachehits&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheHits)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheMisses, pWrkrData-&gt;mutNamespaceCacheMisses);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacecachemisses&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheMisses)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheMisses, pWrkrData-&gt;mutPodCacheMisses);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podcachemisses&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheMisses)));
	CHKiRet(statsobj.ConstructFinalize(pWrkrData-&gt;stats));

	hdr = curl_slist_append(hdr, &quot;Content-Type: text/json; charset=utf-8&quot;);
	if (pWrkrData-&gt;pData-&gt;token) {
		if ((-1 == asprintf(&amp;tokenHdr, &quot;Authorization: Bearer %s&quot;, pWrkrData-&gt;pData-&gt;token)) ||
			(!tokenHdr)) {
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
	} else if (pWrkrData-&gt;pData-&gt;tokenFile) {
		struct stat statbuf;
		fp = fopen((const char*)pWrkrData-&gt;pData-&gt;tokenFile, &quot;r&quot;);
		if (fp &amp;&amp; !fstat(fileno(fp), &amp;statbuf)) {
			size_t bytesread;
			CHKmalloc(token = malloc((statbuf.st_size+1)*sizeof(char)));
			if (0 &lt; (bytesread = fread(token, sizeof(char), statbuf.st_size, fp))) {
				token[bytesread] = '\0';
				if ((-1 == asprintf(&amp;tokenHdr, &quot;Authorization: Bearer %s&quot;, token)) ||
					(!tokenHdr)) {
					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
				}
			}
			free(token);
			token = NULL;
		}
		if (fp) {
			fclose(fp);
			fp = NULL;
		}
	}
	if (tokenHdr) {
		hdr = curl_slist_append(hdr, tokenHdr);
		free(tokenHdr);
	}
	pWrkrData-&gt;curlHdr = hdr;
	ctx = curl_easy_init();
	curl_easy_setopt(ctx, CURLOPT_HTTPHEADER, hdr);
	curl_easy_setopt(ctx, CURLOPT_WRITEFUNCTION, curlCB);
	curl_easy_setopt(ctx, CURLOPT_WRITEDATA, pWrkrData);
	if(pWrkrData-&gt;pData-&gt;caCertFile)
		curl_easy_setopt(ctx, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
	if(pWrkrData-&gt;pData-&gt;myCertFile)
		curl_easy_setopt(ctx, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
		curl_easy_setopt(ctx, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYPEER, 0);
	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYHOST, 0);
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
	if(pWrkrData-&gt;pData-&gt;sslPartialChain) {
		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_FUNCTION, set_ssl_partial_chain);
		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_DATA, NULL);
	}
#endif
	pWrkrData-&gt;curlCtx = ctx;
finalize_it:
	free(token);
	free(statsName);
	if ((iRet != RS_RET_OK) &amp;&amp; pWrkrData-&gt;stats) {
		statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
	}
	if (fp) {
		fclose(fp);
	}
ENDcreateWrkrInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	curl_easy_cleanup(pWrkrData-&gt;curlCtx);
	curl_slist_free_all(pWrkrData-&gt;curlHdr);
	statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
ENDfreeWrkrInstance


/* next function is work-around to avoid type-unsafe casts. It looks
 * like not really needed in practice, but gcc 8 complains and doing
 * it 100% correct for sure does not hurt ;-) -- rgerhards, 2018-07-19
 */
static void
hashtable_json_object_put(void *jso)
{
	json_object_put((struct fjson_object *)jso);
}

static void
cache_entry_free(struct cache_entry_s *cache_entry)
{
	if (NULL != cache_entry) {
		if (cache_entry-&gt;data) {
			hashtable_json_object_put(cache_entry-&gt;data);
			cache_entry-&gt;data = NULL;
		}
		free(cache_entry);
	}
}

static void
cache_entry_free_raw(void *cache_entry_void)
{
	cache_entry_free((struct cache_entry_s *)cache_entry_void);
}

static struct cache_s *
cacheNew(instanceData *pData)
{
	DEFiRet;
	struct cache_s *cache = NULL;
	time_t now;
	int need_mutex_destroy = 0;

	CHKmalloc(cache = (struct cache_s *)calloc(1, sizeof(struct cache_s)));
	CHKmalloc(cache-&gt;cacheMtx = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)));
	CHKmalloc(cache-&gt;mdHt = create_hashtable(100, hash_from_string,
		key_equals_string, cache_entry_free_raw));
	CHKmalloc(cache-&gt;nsHt = create_hashtable(100, hash_from_string,
		key_equals_string, cache_entry_free_raw));
	CHKiConcCtrl(pthread_mutex_init(cache-&gt;cacheMtx, NULL));
	need_mutex_destroy = 1;
	datetime.GetTime(&amp;now);
	cache-&gt;kbUrl = pData-&gt;kubernetesUrl;
	cache-&gt;expirationTime = 0;
	if (pData-&gt;cacheExpireInterval &gt; -1)
		cache-&gt;expirationTime = pData-&gt;cacheExpireInterval + pData-&gt;cacheEntryTTL + now;
	cache-&gt;lastBusyTime = 0;
	dbgprintf(&quot;mmkubernetes: created cache mdht [%p] nsht [%p]\n&quot;,
			cache-&gt;mdHt, cache-&gt;nsHt);

finalize_it:
	if (iRet != RS_RET_OK) {
	        LogError(errno, iRet, &quot;mmkubernetes: cacheNew: unable to create metadata cache for %s&quot;,
	                 pData-&gt;kubernetesUrl);
		if (cache) {
			if (cache-&gt;mdHt)
				hashtable_destroy(cache-&gt;mdHt, 1);
			if (cache-&gt;nsHt)
				hashtable_destroy(cache-&gt;nsHt, 1);
			if (cache-&gt;cacheMtx) {
				if (need_mutex_destroy)
					pthread_mutex_destroy(cache-&gt;cacheMtx);
				free(cache-&gt;cacheMtx);
			}
			free(cache);
			cache = NULL;
		}
	}
	return cache;
}


static void cacheFree(struct cache_s *cache)
{
	hashtable_destroy(cache-&gt;mdHt, 1);
	hashtable_destroy(cache-&gt;nsHt, 1);
	pthread_mutex_destroy(cache-&gt;cacheMtx);
	free(cache-&gt;cacheMtx);
	free(cache);
}

/* must be called with cache-&gt;cacheMtx held */
/* assumes caller has reference to jso (json_object_get or is a new object) */
static struct cache_entry_s *cache_entry_new(time_t ttl, struct fjson_object *jso)
{
	DEFiRet;
	struct cache_entry_s *cache_entry = NULL;

	CHKmalloc(cache_entry = malloc(sizeof(struct cache_entry_s)));
	cache_entry-&gt;ttl = ttl;
	cache_entry-&gt;data = (void *)jso;
finalize_it:
	if (iRet) {
		free(cache_entry);
		cache_entry = NULL;
	}
	return cache_entry;
}

static int cache_delete_expired_entries(wrkrInstanceData_t *pWrkrData, int isnsmd, time_t now)
{
	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
	struct hashtable_itr *itr = NULL;
	int more;

	if ((pWrkrData-&gt;pData-&gt;cacheExpireInterval &lt; 0) || (now &lt; pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime)) {
		return 0; /* not enabled or not time yet */
	}

	/* set next expiration time */
	pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime = now + pWrkrData-&gt;pData-&gt;cacheExpireInterval;

	if (hashtable_count(ht) &lt; 1)
		return 1; /* expire interval hit but nothing to do */

	itr = hashtable_iterator(ht);
	if (NULL == itr)
		return 1; /* expire interval hit but nothing to do - err? */

	do {
		struct cache_entry_s *cache_entry = (struct cache_entry_s *)hashtable_iterator_value(itr);

		if (now &gt;= cache_entry-&gt;ttl) {
			cache_entry_free(cache_entry);
			if (isnsmd) {
				STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
						 pWrkrData-&gt;mutNamespaceCacheNumEntries);
			} else {
				STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
						 pWrkrData-&gt;mutPodCacheNumEntries);
			}
			more = hashtable_iterator_remove(itr);
		} else {
			more = hashtable_iterator_advance(itr);
		}
	} while (more);
	free(itr);
	dbgprintf(&quot;mmkubernetes: cache_delete_expired_entries: cleaned [%s] cache - size is now [%llu]\n&quot;,
		  isnsmd ? &quot;namespace&quot; : &quot;pod&quot;,
		  isnsmd ? pWrkrData-&gt;namespaceCacheNumEntries : pWrkrData-&gt;podCacheNumEntries);
	return 1;
}

/* must be called with cache-&gt;cacheMtx held */
static struct fjson_object *
cache_entry_get(wrkrInstanceData_t *pWrkrData,
		int isnsmd, const char *key, time_t now)
{
	struct fjson_object *jso = NULL;
	struct cache_entry_s *cache_entry = NULL;
	int checkttl = 1;
	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;

	/* see if it is time for a general cache expiration */
	if (cache_delete_expired_entries(pWrkrData, isnsmd, now))
		checkttl = 0; /* no need to check ttl now */
	cache_entry = (struct cache_entry_s *)hashtable_search(ht, (void *)key);
	if (cache_entry &amp;&amp; checkttl &amp;&amp; (now &gt;= cache_entry-&gt;ttl)) {
		cache_entry = (struct cache_entry_s *)hashtable_remove(ht, (void *)key);
		if (isnsmd) {
			STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
		} else {
			STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
					 pWrkrData-&gt;mutPodCacheNumEntries);
		}
		cache_entry_free(cache_entry);
		cache_entry = NULL;
	}
	if (cache_entry) {
		jso = (struct fjson_object *)cache_entry-&gt;data;
		if (isnsmd) {
			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheHits,
					 pWrkrData-&gt;mutNamespaceCacheHits);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podCacheHits,
					 pWrkrData-&gt;mutPodCacheHits);
		}
		dbgprintf(&quot;mmkubernetes: cache_entry_get: cache hit for [%s] cache key [%s] - hits is now [%llu]\n&quot;,
			  isnsmd ? &quot;namespace&quot; : &quot;pod&quot;, key,
			  isnsmd ? pWrkrData-&gt;namespaceCacheHits : pWrkrData-&gt;podCacheHits);
	} else {
		if (isnsmd) {
			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheMisses,
					 pWrkrData-&gt;mutNamespaceCacheMisses);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podCacheMisses,
					 pWrkrData-&gt;mutPodCacheMisses);
		}
		dbgprintf(&quot;mmkubernetes: cache_entry_get: cache miss for [%s] cache key [%s] - misses is now [%llu]\n&quot;,
			  isnsmd ? &quot;namespace&quot; : &quot;pod&quot;, key,
			  isnsmd ? pWrkrData-&gt;namespaceCacheMisses : pWrkrData-&gt;podCacheMisses);
	}

	return jso;
}

/* must be called with cache-&gt;cacheMtx held */
/* key is passed in - caller must copy or otherwise ensure it is ok to pass off
 * ownership
 */
static rsRetVal
cache_entry_add(wrkrInstanceData_t *pWrkrData,
		int isnsmd, const char *key, struct fjson_object *jso, time_t now, const int bDupKey)
{
	DEFiRet;
	struct cache_entry_s *cache_entry = NULL;
	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;

	/* see if it is time for a general cache expiration */
	(void)cache_delete_expired_entries(pWrkrData, isnsmd, now);
	CHKmalloc(cache_entry = cache_entry_new(now + pWrkrData-&gt;pData-&gt;cacheEntryTTL, jso));
	if (cache_entry) {
		if (!hashtable_insert(ht, (void *)(bDupKey ? strdup(key) : key), cache_entry))
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);

		if (isnsmd) {
			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheNumEntries,
					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podCacheNumEntries,
					 pWrkrData-&gt;mutPodCacheNumEntries);
		}
		cache_entry = NULL;
	}
finalize_it:
	if (cache_entry)
		cache_entry_free(cache_entry);
	return iRet;
}

/* must be called with cache-&gt;cacheMtx held */
static struct fjson_object *cache_entry_get_md(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
{
	return cache_entry_get(pWrkrData, 0, key, now);
}

/* must be called with cache-&gt;cacheMtx held */
static struct fjson_object *cache_entry_get_nsmd(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
{
	return cache_entry_get(pWrkrData, 1, key, now);
}

/* must be called with cache-&gt;cacheMtx held */
static rsRetVal cache_entry_add_md(wrkrInstanceData_t *pWrkrData, const char *key,
				   struct fjson_object *jso, time_t now)
{
	return cache_entry_add(pWrkrData, 0, key, jso, now, 0);
}

/* must be called with cache-&gt;cacheMtx held */
static rsRetVal cache_entry_add_nsmd(wrkrInstanceData_t *pWrkrData, const char *key,
				     struct fjson_object *jso, time_t now)
{
	return cache_entry_add(pWrkrData, 1, key, jso, now, 1);
}


BEGINnewActInst
	struct cnfparamvals *pvals = NULL;
	int i;
	FILE *fp = NULL;
	char *rxstr = NULL;
	char *srcMetadataPath = NULL;
	char errStr[1024];
CODESTARTnewActInst
	DBGPRINTF(&quot;newActInst (mmkubernetes)\n&quot;);

	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;mmkubernetes: &quot;
			&quot;error processing config parameters [action(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;action param blk in mmkubernetes:\n&quot;);
		cnfparamsPrint(&amp;actpblk, pvals);
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));

	pData-&gt;de_dot = loadModConf-&gt;de_dot;
	pData-&gt;allowUnsignedCerts = loadModConf-&gt;allowUnsignedCerts;
	pData-&gt;skipVerifyHost = loadModConf-&gt;skipVerifyHost;
	pData-&gt;busyRetryInterval = loadModConf-&gt;busyRetryInterval;
	pData-&gt;sslPartialChain = loadModConf-&gt;sslPartialChain;
	pData-&gt;cacheEntryTTL = loadModConf-&gt;cacheEntryTTL;
	pData-&gt;cacheExpireInterval = loadModConf-&gt;cacheExpireInterval;
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		} else if(!strcmp(actpblk.descr[i].name, &quot;kubernetesurl&quot;)) {
			free(pData-&gt;kubernetesUrl);
			pData-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;srcmetadatapath&quot;)) {
<A NAME="9"></A>			msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
			free(pData-&gt;srcMetadataDescr);
			CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#9',2,'match369-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			srcMetadataPath = es_str2cstr(pvals[i].val.d.estr, NULL);
			CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, (uchar *)srcMetadataPath,
				strlen(srcMetadataPath)));
			/* todo: sanitize the path */
		} else if(!strcmp(actpblk.descr[i].name, &quot;dstmetadatapath&quot;)) {
			free(pData-&gt;dstMetadataPath);
			pData-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			/* todo: sanitize the path */
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.cacert&quot;)) {
			free(pData-&gt;caCertFile);
			pData-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			fp = fopen((const char*)pData-&gt;caCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;caCertFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.mycert&quot;)) {
			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.mycert' file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.myprivkey&quot;)) {
			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myPrivKeyFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.myprivkey' file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;myPrivKeyFile, errStr);
<A NAME="4"></A>			} else {
				fclose(fp);
				fp = NULL;
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#4',2,'match369-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;allowunsignedcerts&quot;)) {
			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;skipverifyhost&quot;)) {
			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;token&quot;)) {
			free(pData-&gt;token);
			pData-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;tokenfile&quot;)) {
			free(pData-&gt;tokenFile);
			pData-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			fp = fopen((const char*)pData-&gt;tokenFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: token file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;tokenFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
<A NAME="11"></A>			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;annotation_match&quot;)) {
			free_annotationmatch(&amp;pData-&gt;annotation_match);
<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#11',2,'match369-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			if (RS_RET_OK != (iRet = init_annotationmatch(&amp;pData-&gt;annotation_match, pvals[i].val.d.ar)))
				ABORT_FINALIZE(iRet);
		} else if(!strcmp(actpblk.descr[i].name, &quot;de_dot&quot;)) {
			pData-&gt;de_dot = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;de_dot_separator&quot;)) {
			free(pData-&gt;de_dot_separator);
			pData-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, &quot;filenamerules&quot;)) {
			free(pData-&gt;fnRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;fnRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;filenamerulebase&quot;)) {
			free(pData-&gt;fnRulebase);
			pData-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;fnRulebase, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: filenamerulebase file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;fnRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, &quot;containerrules&quot;)) {
			free(pData-&gt;contRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;contRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;containerrulebase&quot;)) {
			free(pData-&gt;contRulebase);
			pData-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;contRulebase, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: containerrulebase file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;contRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
<A NAME="6"></A>				fclose(fp);
				fp = NULL;
			}
<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match369-0.html#6',2,'match369-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;busyretryinterval&quot;)) {
			pData-&gt;busyRetryInterval = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;sslpartialchain&quot;)) {
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
			pData-&gt;sslPartialChain = pvals[i].val.d.n;
#else
			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
					&quot;sslpartialchain is only supported for OpenSSL\n&quot;);
#endif
		} else if(!strcmp(actpblk.descr[i].name, &quot;cacheentryttl&quot;)) {
			pData-&gt;cacheEntryTTL = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;cacheexpireinterval&quot;)) {
			pData-&gt;cacheExpireInterval = pvals[i].val.d.n;
		} else {</B></FONT>
			dbgprintf(&quot;mmkubernetes: program error, non-handled &quot;
				&quot;param '%s' in action() block\n&quot;, actpblk.descr[i].name);
			/* todo: error message? */
		}
	}

#if HAVE_LOADSAMPLESFROMSTRING == 1
	if (pData-&gt;fnRules &amp;&amp; pData-&gt;fnRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
		    &quot;mmkubernetes: only 1 of filenamerules or filenamerulebase may be used&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (pData-&gt;contRules &amp;&amp; pData-&gt;contRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
			&quot;mmkubernetes: only 1 of containerrules or containerrulebase may be used&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
#endif
	CHKiRet(set_lnctx(&amp;pData-&gt;fnCtxln, pData-&gt;fnRules, pData-&gt;fnRulebase,
			loadModConf-&gt;fnRules, loadModConf-&gt;fnRulebase));
	CHKiRet(set_lnctx(&amp;pData-&gt;contCtxln, pData-&gt;contRules, pData-&gt;contRulebase,
			loadModConf-&gt;contRules, loadModConf-&gt;contRulebase));

	if ((pData-&gt;cacheExpireInterval &gt; -1)) {
		if ((pData-&gt;cacheEntryTTL &lt; 0)) {
			LogError(0, RS_RET_CONFIG_ERROR,
					&quot;mmkubernetes: cacheentryttl value [%d] is invalid - &quot;
					&quot;value must be 0 or greater&quot;,
					pData-&gt;cacheEntryTTL);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}

	if(pData-&gt;kubernetesUrl == NULL) {
		if(loadModConf-&gt;kubernetesUrl == NULL) {
			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup(DFLT_KUBERNETES_URL));
		} else {
			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup((char *) loadModConf-&gt;kubernetesUrl));
		}
	}
	if(pData-&gt;srcMetadataDescr == NULL) {
		CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
		CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, loadModConf-&gt;srcMetadataPath,
			strlen((char *)loadModConf-&gt;srcMetadataPath)));
	}
	if(pData-&gt;dstMetadataPath == NULL)
		pData-&gt;dstMetadataPath = (uchar *) strdup((char *) loadModConf-&gt;dstMetadataPath);
	if(pData-&gt;caCertFile == NULL &amp;&amp; loadModConf-&gt;caCertFile)
		pData-&gt;caCertFile = (uchar *) strdup((char *) loadModConf-&gt;caCertFile);
	if(pData-&gt;myCertFile == NULL &amp;&amp; loadModConf-&gt;myCertFile)
		pData-&gt;myCertFile = (uchar *) strdup((char *) loadModConf-&gt;myCertFile);
	if(pData-&gt;myPrivKeyFile == NULL &amp;&amp; loadModConf-&gt;myPrivKeyFile)
		pData-&gt;myPrivKeyFile = (uchar *) strdup((char *) loadModConf-&gt;myPrivKeyFile);
	if(pData-&gt;token == NULL &amp;&amp; loadModConf-&gt;token)
		pData-&gt;token = (uchar *) strdup((char *) loadModConf-&gt;token);
	if(pData-&gt;tokenFile == NULL &amp;&amp; loadModConf-&gt;tokenFile)
		pData-&gt;tokenFile = (uchar *) strdup((char *) loadModConf-&gt;tokenFile);
	if(pData-&gt;de_dot_separator == NULL &amp;&amp; loadModConf-&gt;de_dot_separator)
		pData-&gt;de_dot_separator = (uchar *) strdup((char *) loadModConf-&gt;de_dot_separator);
	if((pData-&gt;annotation_match.nmemb == 0) &amp;&amp; (loadModConf-&gt;annotation_match.nmemb &gt; 0))
		copy_annotationmatch(&amp;loadModConf-&gt;annotation_match, &amp;pData-&gt;annotation_match);

	if(pData-&gt;de_dot_separator)
		pData-&gt;de_dot_separator_len = strlen((const char *)pData-&gt;de_dot_separator);

	CHKmalloc(pData-&gt;contNameDescr = malloc(sizeof(msgPropDescr_t)));
	CHKiRet(msgPropDescrFill(pData-&gt;contNameDescr, (uchar*) DFLT_CONTAINER_NAME,
			strlen(DFLT_CONTAINER_NAME)));
	CHKmalloc(pData-&gt;contIdFullDescr = malloc(sizeof(msgPropDescr_t)));
	CHKiRet(msgPropDescrFill(pData-&gt;contIdFullDescr, (uchar*) DFLT_CONTAINER_ID_FULL,
			strlen(DFLT_CONTAINER_NAME)));

	/* get the cache for this url */
	for(i = 0; caches[i] != NULL; i++) {
		if(!strcmp((char *) pData-&gt;kubernetesUrl, (char *) caches[i]-&gt;kbUrl))
			break;
	}
	if(caches[i] != NULL) {
		pData-&gt;cache = caches[i];
	} else {
		CHKmalloc(pData-&gt;cache = cacheNew(pData));
		struct cache_s **new_caches = realloc(caches, (i + 2) * sizeof(struct cache_s *));
		CHKmalloc(new_caches);
		caches = new_caches;
		caches[i] = pData-&gt;cache;
		caches[i + 1] = NULL;
	}
CODE_STD_FINALIZERnewActInst
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;actpblk);
	if(fp)
		fclose(fp);
	free(rxstr);
	free(srcMetadataPath);
ENDnewActInst


/* legacy config format is not supported */
BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(strncmp((char *) p, &quot;:mmkubernetes:&quot;, sizeof(&quot;:mmkubernetes:&quot;) - 1)) {
		LogError(0, RS_RET_LEGA_ACT_NOT_SUPPORTED,
			&quot;mmkubernetes supports only v6+ config format, use: &quot;
			&quot;action(type=\&quot;mmkubernetes\&quot; ...)&quot;);
	}
	ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad


BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf


BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
	int i;

	free(pModConf-&gt;kubernetesUrl);
	free(pModConf-&gt;srcMetadataPath);
	free(pModConf-&gt;dstMetadataPath);
	free(pModConf-&gt;caCertFile);
	free(pModConf-&gt;myCertFile);
	free(pModConf-&gt;myPrivKeyFile);
	free(pModConf-&gt;token);
	free(pModConf-&gt;tokenFile);
	free(pModConf-&gt;de_dot_separator);
	free(pModConf-&gt;fnRules);
	free(pModConf-&gt;fnRulebase);
	free(pModConf-&gt;contRules);
	free(pModConf-&gt;contRulebase);
	free_annotationmatch(&amp;pModConf-&gt;annotation_match);
	for(i = 0; caches[i] != NULL; i++) {
		dbgprintf(&quot;mmkubernetes: freeing cache [%d] mdht [%p] nsht [%p]\n&quot;,
				i, caches[i]-&gt;mdHt, caches[i]-&gt;nsHt);
		cacheFree(caches[i]);
	}
	free(caches);
ENDfreeCnf


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf(&quot;mmkubernetes\n&quot;);
	dbgprintf(&quot;\tkubernetesUrl='%s'\n&quot;, pData-&gt;kubernetesUrl);
	dbgprintf(&quot;\tsrcMetadataPath='%s'\n&quot;, pData-&gt;srcMetadataDescr-&gt;name);
	dbgprintf(&quot;\tdstMetadataPath='%s'\n&quot;, pData-&gt;dstMetadataPath);
	dbgprintf(&quot;\ttls.cacert='%s'\n&quot;, pData-&gt;caCertFile);
	dbgprintf(&quot;\ttls.mycert='%s'\n&quot;, pData-&gt;myCertFile);
	dbgprintf(&quot;\ttls.myprivkey='%s'\n&quot;, pData-&gt;myPrivKeyFile);
	dbgprintf(&quot;\tallowUnsignedCerts='%d'\n&quot;, pData-&gt;allowUnsignedCerts);
	dbgprintf(&quot;\tskipVerifyHost='%d'\n&quot;, pData-&gt;skipVerifyHost);
	dbgprintf(&quot;\ttoken='%s'\n&quot;, pData-&gt;token);
	dbgprintf(&quot;\ttokenFile='%s'\n&quot;, pData-&gt;tokenFile);
	dbgprintf(&quot;\tde_dot='%d'\n&quot;, pData-&gt;de_dot);
	dbgprintf(&quot;\tde_dot_separator='%s'\n&quot;, pData-&gt;de_dot_separator);
	dbgprintf(&quot;\tfilenamerulebase='%s'\n&quot;, pData-&gt;fnRulebase);
	dbgprintf(&quot;\tcontainerrulebase='%s'\n&quot;, pData-&gt;contRulebase);
#if HAVE_LOADSAMPLESFROMSTRING == 1
	dbgprintf(&quot;\tfilenamerules='%s'\n&quot;, pData-&gt;fnRules);
	dbgprintf(&quot;\tcontainerrules='%s'\n&quot;, pData-&gt;contRules);
#endif
	dbgprintf(&quot;\tbusyretryinterval='%d'\n&quot;, pData-&gt;busyRetryInterval);
	dbgprintf(&quot;\tcacheentryttl='%d'\n&quot;, pData-&gt;cacheEntryTTL);
	dbgprintf(&quot;\tcacheexpireinterval='%d'\n&quot;, pData-&gt;cacheExpireInterval);
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume

static rsRetVal
extractMsgMetadata(smsg_t *pMsg, instanceData *pData, struct json_object **json)
{
	DEFiRet;
	uchar *filename = NULL, *container_name = NULL, *container_id_full = NULL;
	rs_size_t fnLen, container_name_len, container_id_full_len;
	unsigned short freeFn = 0, free_container_name = 0, free_container_id_full = 0;
	int lnret;
	struct json_object *cnid = NULL;

	if (!json)
		FINALIZE;
	*json = NULL;
	/* extract metadata from the CONTAINER_NAME field and see if CONTAINER_ID_FULL is present */
	container_name = MsgGetProp(pMsg, NULL, pData-&gt;contNameDescr,
				    &amp;container_name_len, &amp;free_container_name, NULL);
	container_id_full = MsgGetProp(
		pMsg, NULL, pData-&gt;contIdFullDescr, &amp;container_id_full_len, &amp;free_container_id_full, NULL);

	if (container_name &amp;&amp; container_id_full &amp;&amp; container_name_len &amp;&amp; container_id_full_len) {
		dbgprintf(&quot;mmkubernetes: CONTAINER_NAME: '%s'  CONTAINER_ID_FULL: '%s'.\n&quot;,
			  container_name, container_id_full);
		if ((lnret = ln_normalize(pData-&gt;contCtxln, (char*)container_name,
					  container_name_len, json))) {
			if (LN_WRONGPARSER != lnret) {
				LogMsg(0, RS_RET_ERR, LOG_ERR,
					&quot;mmkubernetes: error parsing container_name [%s]: [%d]&quot;,
					container_name, lnret);

				ABORT_FINALIZE(RS_RET_ERR);
			}
			/* else assume parser didn't find a match and fall through */
		} else if (fjson_object_object_get_ex(*json, &quot;pod_name&quot;, NULL) &amp;&amp;
			fjson_object_object_get_ex(*json, &quot;namespace_name&quot;, NULL) &amp;&amp;
			fjson_object_object_get_ex(*json, &quot;container_name&quot;, NULL)) {
			/* if we have fields for pod name, namespace name, container name,
			 * and container id, we are good to go */
			/* add field for container id */
			json_object_object_add(*json, &quot;container_id&quot;,
				json_object_new_string_len((const char *)container_id_full,
							   container_id_full_len));
			ABORT_FINALIZE(RS_RET_OK);
		}
	}

	/* extract metadata from the file name */
	filename = MsgGetProp(pMsg, NULL, pData-&gt;srcMetadataDescr, &amp;fnLen, &amp;freeFn, NULL);
	if((filename == NULL) || (fnLen == 0))
		ABORT_FINALIZE(RS_RET_NOT_FOUND);

	dbgprintf(&quot;mmkubernetes: filename: '%s' len %d.\n&quot;, filename, fnLen);
	if ((lnret = ln_normalize(pData-&gt;fnCtxln, (char*)filename, fnLen, json))) {
		if (LN_WRONGPARSER != lnret) {
			LogMsg(0, RS_RET_ERR, LOG_ERR,
				&quot;mmkubernetes: error parsing container_name [%s]: [%d]&quot;,
				filename, lnret);

			ABORT_FINALIZE(RS_RET_ERR);
		} else {
			/* no match */
			ABORT_FINALIZE(RS_RET_NOT_FOUND);
		}
	}
	/* if we have fields for pod name, namespace name, container name,
	 * and container id, we are good to go */
	if (fjson_object_object_get_ex(*json, &quot;pod_name&quot;, NULL) &amp;&amp;
		fjson_object_object_get_ex(*json, &quot;namespace_name&quot;, NULL) &amp;&amp;
		fjson_object_object_get_ex(*json, &quot;container_name_and_id&quot;, &amp;cnid)) {
		/* parse container_name_and_id into container_name and container_id */
		const char *container_name_and_id = json_object_get_string(cnid);
		const char *last_dash = NULL;
		if (container_name_and_id &amp;&amp; (last_dash = strrchr(container_name_and_id, '-')) &amp;&amp;
			*(last_dash + 1) &amp;&amp; (last_dash != container_name_and_id)) {
			json_object_object_add(*json, &quot;container_name&quot;,
				json_object_new_string_len(container_name_and_id,
							   (int)(last_dash-container_name_and_id)));
			json_object_object_add(*json, &quot;container_id&quot;,
					json_object_new_string(last_dash + 1));
			ABORT_FINALIZE(RS_RET_OK);
		}
	}
	ABORT_FINALIZE(RS_RET_NOT_FOUND);
finalize_it:
	if(freeFn)
		free(filename);
	if (free_container_name)
		free(container_name);
	if (free_container_id_full)
		free(container_id_full);
	if (iRet != RS_RET_OK) {
		json_object_put(*json);
		*json = NULL;
	}
	RETiRet;
}


static rsRetVal
queryKB(wrkrInstanceData_t *pWrkrData, char *url, time_t now, struct json_object **rply)
{
	DEFiRet;
	CURLcode ccode;
	struct json_tokener *jt = NULL;
	struct json_object *jo;
	long resp_code = 400;

	if (pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime) {
		now -= pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime;
		if (now &lt; pWrkrData-&gt;pData-&gt;busyRetryInterval) {
			LogMsg(0, RS_RET_RETRY, LOG_DEBUG,
				&quot;mmkubernetes: Waited [%ld] of [%d] seconds for the requested url [%s]\n&quot;,
				now, pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
			ABORT_FINALIZE(RS_RET_RETRY);
		} else {
			LogMsg(0, RS_RET_OK, LOG_DEBUG,
				&quot;mmkubernetes: Cleared busy status after [%d] seconds - &quot;
				&quot;will retry the requested url [%s]\n&quot;,
				pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = 0;
		}
	}

	/* query kubernetes for pod info */
	ccode = curl_easy_setopt(pWrkrData-&gt;curlCtx, CURLOPT_URL, url);
	if(ccode != CURLE_OK)
		ABORT_FINALIZE(RS_RET_ERR);
	if(CURLE_OK != (ccode = curl_easy_perform(pWrkrData-&gt;curlCtx))) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: failed to connect to [%s] - %d:%s\n&quot;,
			      url, ccode, curl_easy_strerror(ccode));
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
	if(CURLE_OK != (ccode = curl_easy_getinfo(pWrkrData-&gt;curlCtx,
					CURLINFO_RESPONSE_CODE, &amp;resp_code))) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: could not get response code from query to [%s] - %d:%s\n&quot;,
			      url, ccode, curl_easy_strerror(ccode));
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(resp_code == 401) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: Unauthorized: not allowed to view url - &quot;
			      &quot;check token/auth credentials [%s]\n&quot;,
			      url);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(resp_code == 403) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: Forbidden: no access - &quot;
			      &quot;check permissions to view url [%s]\n&quot;,
			      url);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(resp_code == 404) {
		LogMsg(0, RS_RET_NOT_FOUND, LOG_INFO,
			      &quot;mmkubernetes: Not Found: the resource does not exist at url [%s]\n&quot;,
			      url);
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
	if(resp_code == 429) {
		if (pWrkrData-&gt;pData-&gt;busyRetryInterval) {
			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = now;
		}

		LogMsg(0, RS_RET_RETRY, LOG_INFO,
			      &quot;mmkubernetes: Too Many Requests: the server is too heavily loaded &quot;
			      &quot;to provide the data for the requested url [%s]\n&quot;,
			      url);
		ABORT_FINALIZE(RS_RET_RETRY);
	}
	if(resp_code != 200) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: server returned unexpected code [%ld] for url [%s]\n&quot;,
			      resp_code, url);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	/* parse retrieved data */
	jt = json_tokener_new();
	json_tokener_reset(jt);
	jo = json_tokener_parse_ex(jt, pWrkrData-&gt;curlRply, pWrkrData-&gt;curlRplyLen);
	json_tokener_free(jt);
	if(!json_object_is_type(jo, json_type_object)) {
		json_object_put(jo);
		jo = NULL;
		LogMsg(0, RS_RET_JSON_PARSE_ERR, LOG_INFO,
			      &quot;mmkubernetes: unable to parse string as JSON:[%.*s]\n&quot;,
			      (int)pWrkrData-&gt;curlRplyLen, pWrkrData-&gt;curlRply);
		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}

	dbgprintf(&quot;mmkubernetes: queryKB reply:\n%s\n&quot;,
		json_object_to_json_string_ext(jo, JSON_C_TO_STRING_PRETTY));

	*rply = jo;

finalize_it:
	if(pWrkrData-&gt;curlRply != NULL) {
		free(pWrkrData-&gt;curlRply);
		pWrkrData-&gt;curlRply = NULL;
		pWrkrData-&gt;curlRplyLen = 0;
	}
	RETiRet;
}


/* versions &lt; 8.16.0 don't support BEGINdoAction_NoStrings */
#if defined(BEGINdoAction_NoStrings)
BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
#else
BEGINdoAction
	smsg_t *pMsg = (smsg_t*) ppString[0];
#endif
	const char *podName = NULL, *ns = NULL, *containerName = NULL,
		*containerID = NULL;
	char *mdKey = NULL;
	struct json_object *jMetadata = NULL, *jMetadataCopy = NULL, *jMsgMeta = NULL,
			*jo = NULL;
	int add_pod_metadata = 1;
	time_t now;

CODESTARTdoAction
	CHKiRet_Hdlr(extractMsgMetadata(pMsg, pWrkrData-&gt;pData, &amp;jMsgMeta)) {
		ABORT_FINALIZE((iRet == RS_RET_NOT_FOUND) ? RS_RET_OK : iRet);
	}

	datetime.GetTime(&amp;now);
	STATSCOUNTER_INC(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);

	if (fjson_object_object_get_ex(jMsgMeta, &quot;pod_name&quot;, &amp;jo))
		podName = json_object_get_string(jo);
	if (fjson_object_object_get_ex(jMsgMeta, &quot;namespace_name&quot;, &amp;jo))
		ns = json_object_get_string(jo);
	if (fjson_object_object_get_ex(jMsgMeta, &quot;container_name&quot;, &amp;jo))
		containerName = json_object_get_string(jo);
	if (fjson_object_object_get_ex(jMsgMeta, &quot;container_id&quot;, &amp;jo))
		containerID = json_object_get_string(jo);
	assert(podName != NULL);
	assert(ns != NULL);
	assert(containerName != NULL);
	assert(containerID != NULL);

	dbgprintf(&quot;mmkubernetes:\n  podName: '%s'\n  namespace: '%s'\n  containerName: '%s'\n&quot;
		&quot;  containerID: '%s'\n&quot;, podName, ns, containerName, containerID);

	/* check cache for metadata */
	if ((-1 == asprintf(&amp;mdKey, &quot;%s_%s_%s&quot;, ns, podName, containerName)) ||
		(!mdKey)) {
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	pthread_mutex_lock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
	jMetadata = cache_entry_get_md(pWrkrData, mdKey, now);

	if(jMetadata == NULL) {
		char *url = NULL;
		struct json_object *jReply = NULL, *jo2 = NULL, *jNsMeta = NULL, *jPodData = NULL;

		/* check cache for namespace metadata */
		jNsMeta = cache_entry_get_nsmd(pWrkrData, (const char *)ns, now);

		if(jNsMeta == NULL) {
			/* query kubernetes for namespace info */
			/* todo: move url definitions elsewhere */
			if ((-1 == asprintf(&amp;url, &quot;%s/api/v1/namespaces/%s&quot;,
				 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns)) ||
				(!url)) {
				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
			iRet = queryKB(pWrkrData, url, now, &amp;jReply);
			free(url);
			if (iRet == RS_RET_NOT_FOUND) {
				/* negative cache namespace - make a dummy empty namespace metadata object */
				jNsMeta = json_object_new_object();
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataNotFound,
						 pWrkrData-&gt;mutNamespaceMetadataNotFound);
			} else if (iRet == RS_RET_RETRY) {
				/* server is busy - retry or error */
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataBusy,
						 pWrkrData-&gt;mutNamespaceMetadataBusy);
				if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
					pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
					ABORT_FINALIZE(RS_RET_ERR);
				}
				add_pod_metadata = 0; /* don't cache pod metadata either - retry both */
			} else if (iRet != RS_RET_OK) {
				/* one of many possible transient errors: apiserver error, network, config, auth.
				 * Instead of causing hard error and disabling this module, we can return
				 * basic namespace metadata that is extracted from container log file path.
				 * When transient error resolves, other metadata will become
				 * available. For a new a new pod whose metadata is not yet cached, this
				 * will allow 401, 403, 500, etc. return status from apiserver treated
				 * similar to 404 returns.
				 * */
				jNsMeta = json_object_new_object();
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataError,
						 pWrkrData-&gt;mutNamespaceMetadataError);
			} else if (fjson_object_object_get_ex(jReply, &quot;metadata&quot;, &amp;jNsMeta)) {
				jNsMeta = json_object_get(jNsMeta);
				parse_labels_annotations(jNsMeta, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
					pWrkrData-&gt;pData-&gt;de_dot,
					(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
					pWrkrData-&gt;pData-&gt;de_dot_separator_len);
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
			} else {
				/* namespace with no metadata??? */
				LogMsg(0, RS_RET_ERR, LOG_INFO,
					      &quot;mmkubernetes: namespace [%s] has no metadata!\n&quot;, ns);
				/* negative cache namespace - make a dummy empty namespace metadata object */
				jNsMeta = json_object_new_object();
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
			}

			if(jNsMeta) {
				if ((iRet = cache_entry_add_nsmd(pWrkrData, ns, jNsMeta, now))) {
					ABORT_FINALIZE(iRet);
				}
			}
			json_object_put(jReply);
			jReply = NULL;
		}

		if ((-1 == asprintf(&amp;url, &quot;%s/api/v1/namespaces/%s/pods/%s&quot;,
			 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns, podName)) ||
			(!url)) {
			pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
		iRet = queryKB(pWrkrData, url, now, &amp;jReply);
		free(url);
		if (iRet == RS_RET_NOT_FOUND) {
			/* negative cache pod - make a dummy empty pod metadata object */
			iRet = RS_RET_OK;
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
		} else if (iRet == RS_RET_RETRY) {
			/* server is busy - retry or error */
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
			if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			add_pod_metadata = 0; /* do not cache so that we can retry */
			iRet = RS_RET_OK;
		} else if(iRet != RS_RET_OK) {
			/* This is likely caused by transient apiserver errors: 401, 403, 500, etc.
			 * Treat it similar to 404 while returning file path based pod metadata.
			 * When transient error condition resolves, additional metadata will be
			 * available for events originating from a new pod whose metatadata is not
			 * yet cached.
			 * */
			iRet = RS_RET_OK;
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
		}

		jo = json_object_new_object();
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, &quot;uid&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;namespace_id&quot;, json_object_get(jo2));
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, &quot;labels&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;namespace_labels&quot;, json_object_get(jo2));
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, &quot;annotations&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;namespace_annotations&quot;, json_object_get(jo2));
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, &quot;creationTimestamp&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;creation_timestamp&quot;, json_object_get(jo2));
		if(fjson_object_object_get_ex(jReply, &quot;metadata&quot;, &amp;jPodData)) {
			if(fjson_object_object_get_ex(jPodData, &quot;uid&quot;, &amp;jo2))
				json_object_object_add(jo, &quot;pod_id&quot;, json_object_get(jo2));
			parse_labels_annotations(jPodData, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
				pWrkrData-&gt;pData-&gt;de_dot,
				(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
				pWrkrData-&gt;pData-&gt;de_dot_separator_len);
			if(fjson_object_object_get_ex(jPodData, &quot;annotations&quot;, &amp;jo2))
				json_object_object_add(jo, &quot;annotations&quot;, json_object_get(jo2));
			if(fjson_object_object_get_ex(jPodData, &quot;labels&quot;, &amp;jo2))
				json_object_object_add(jo, &quot;labels&quot;, json_object_get(jo2));
		}
		if(fjson_object_object_get_ex(jReply, &quot;spec&quot;, &amp;jPodData)) {
			if(fjson_object_object_get_ex(jPodData, &quot;nodeName&quot;, &amp;jo2)) {
				json_object_object_add(jo, &quot;host&quot;, json_object_get(jo2));
			}
		}
		json_object_put(jReply);
		jReply = NULL;

		if (fjson_object_object_get_ex(jMsgMeta, &quot;pod_name&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;pod_name&quot;, json_object_get(jo2));
		if (fjson_object_object_get_ex(jMsgMeta, &quot;namespace_name&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;namespace_name&quot;, json_object_get(jo2));
		if (fjson_object_object_get_ex(jMsgMeta, &quot;container_name&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;container_name&quot;, json_object_get(jo2));
		json_object_object_add(jo, &quot;master_url&quot;,
			json_object_new_string((const char *)pWrkrData-&gt;pData-&gt;kubernetesUrl));
		jMetadata = json_object_new_object();
		json_object_object_add(jMetadata, &quot;kubernetes&quot;, jo);
		jo = json_object_new_object();
		if (fjson_object_object_get_ex(jMsgMeta, &quot;container_id&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;container_id&quot;, json_object_get(jo2));
		json_object_object_add(jMetadata, &quot;docker&quot;, jo);

		if (add_pod_metadata) {
			if ((iRet = cache_entry_add_md(pWrkrData, mdKey, jMetadata, now)))
				ABORT_FINALIZE(iRet);
			mdKey = NULL;
		}
	}

	/* make a copy of the metadata for the msg to own */
	/* todo: use json_object_deep_copy when implementation available in libfastjson */
	/* yes, this is expensive - but there is no other way to make this thread safe - we
	 * can't allow the msg to have a shared pointer to an element inside the cache,
	 * outside of the cache lock
	 */
	jMetadataCopy = json_tokener_parse(json_object_get_string(jMetadata));
	if (!add_pod_metadata) {
		/* jMetadata object was created from scratch and not cached */
		json_object_put(jMetadata);
		jMetadata = NULL;
	}
	pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
	/* the +1 is there to skip the leading '$' */
	msgAddJSON(pMsg, (uchar *) pWrkrData-&gt;pData-&gt;dstMetadataPath + 1, jMetadataCopy, 0, 0);

finalize_it:
	json_object_put(jMsgMeta);
	free(mdKey);
ENDdoAction


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


/* all the macros bellow have to be in a specific order */
BEGINmodExit
CODESTARTmodExit
	curl_global_cleanup();

	objRelease(datetime, CORE_COMPONENT);
	objRelease(regexp, LM_REGEXP_FILENAME);
	objRelease(statsobj, CORE_COMPONENT);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF(&quot;mmkubernetes: module compiled with rsyslog version %s.\n&quot;, VERSION);
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(regexp, LM_REGEXP_FILENAME));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	/* CURL_GLOBAL_ALL initializes more than is needed but the
	 * libcurl documentation discourages use of other values
	 */
	curl_global_init(CURL_GLOBAL_ALL);
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
