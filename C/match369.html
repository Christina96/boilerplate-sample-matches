<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omhttp.c &amp; mmkubernetes.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omhttp.c &amp; mmkubernetes.c
      </h3>
<h1 align="center">
        14.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omhttp.c (15.046839%)<th>mmkubernetes.c (14.261931%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(200-228)<td><a href="#" name="0">(221-253)</a><td align="center"><font color="#ff0000">52</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1892-1902)<td><a href="#" name="1">(642-654)</a><td align="center"><font color="#8e0000">29</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1831-1838)<td><a href="#" name="2">(589-602)</a><td align="center"><font color="#750000">24</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(189-199)<td><a href="#" name="3">(253-263)</a><td align="center"><font color="#700000">23</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1930-1938)<td><a href="#" name="4">(1344-1354)</a><td align="center"><font color="#6b0000">22</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1874-1882)<td><a href="#" name="5">(712-725)</a><td align="center"><font color="#660000">21</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(1862-1870)<td><a href="#" name="6">(1416-1429)</a><td align="center"><font color="#5d0000">19</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1919-1924)<td><a href="#" name="7">(628-633)</a><td align="center"><font color="#440000">14</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1908-1913)<td><a href="#" name="8">(614-620)</a><td align="center"><font color="#440000">14</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(1848-1852)<td><a href="#" name="9">(1296-1306)</a><td align="center"><font color="#440000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1823-1827)<td><a href="#" name="10">(668-674)</a><td align="center"><font color="#3f0000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1854-1858)<td><a href="#" name="11">(1369-1375)</a><td align="center"><font color="#3a0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;memory.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;curl/curl.h&gt;
9 #include &lt;curl/easy.h&gt;
10 #include &lt;assert.h&gt;
11 #include &lt;signal.h&gt;
12 #include &lt;errno.h&gt;
13 #include &lt;time.h&gt;
14 #include &lt;sys/types.h&gt;
15 #include &lt;sys/stat.h&gt;
16 #include &lt;fcntl.h&gt;
17 #if defined(__FreeBSD__)
18 #include &lt;unistd.h&gt;
19 #endif
20 #include &lt;json.h&gt;
21 #include &lt;zlib.h&gt;
22 #include "conf.h"
23 #include "syslogd-types.h"
24 #include "srUtils.h"
25 #include "template.h"
26 #include "module-template.h"
27 #include "errmsg.h"
28 #include "cfsysline.h"
29 #include "unicode-helper.h"
30 #include "obj-types.h"
31 #include "ratelimit.h"
32 #include "ruleset.h"
33 #include "statsobj.h"
34 #ifndef O_LARGEFILE
35 #  define O_LARGEFILE 0
36 #endif
37 MODULE_TYPE_OUTPUT
38 MODULE_TYPE_NOKEEP
39 MODULE_CNFNAME("omhttp")
40 DEF_OMOD_STATIC_DATA
41 DEFobjCurrIf(prop)
42 DEFobjCurrIf(ruleset)
43 DEFobjCurrIf(statsobj)
44 statsobj_t *httpStats;
45 STATSCOUNTER_DEF(ctrMessagesSubmitted, mutCtrMessagesSubmitted); STATSCOUNTER_DEF(ctrMessagesSuccess, mutCtrMessagesSuccess); STATSCOUNTER_DEF(ctrMessagesFail, mutCtrMessagesFail); STATSCOUNTER_DEF(ctrMessagesRetry, mutCtrMessagesRetry); STATSCOUNTER_DEF(ctrHttpRequestCount, mutCtrHttpRequestCount); STATSCOUNTER_DEF(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess); STATSCOUNTER_DEF(ctrHttpRequestFail, mutCtrHttpRequestFail); STATSCOUNTER_DEF(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess); STATSCOUNTER_DEF(ctrHttpStatusFail, mutCtrHttpStatusFail); 
46 static prop_t *pInputName = NULL;
47 #define WRKR_DATA_TYPE_ES 0xBADF0001
48 #define HTTP_HEADER_CONTENT_JSON "Content-Type: application/json; charset=utf-8"
49 #define HTTP_HEADER_CONTENT_TEXT "Content-Type: text/plain"
50 #define HTTP_HEADER_CONTENT_KAFKA "Content-Type: application/vnd.kafka.v1+json"
51 #define HTTP_HEADER_ENCODING_GZIP "Content-Encoding: gzip"
52 #define HTTP_HEADER_EXPECT_EMPTY "Expect:"
53 #define VALID_BATCH_FORMATS "newline jsonarray kafkarest lokirest"
54 typedef enum batchFormat_e {
55 	FMT_NEWLINE,
56 	FMT_JSONARRAY,
57 	FMT_KAFKAREST,
58 	FMT_LOKIREST
59 } batchFormat_t;
60 typedef struct curl_slist HEADER;
61 typedef struct instanceConf_s {
62 	int defaultPort;
63 	int fdErrFile;			pthread_mutex_t mutErrFile;
64 	uchar **serverBaseUrls;
65 	int numServers;
66 	long healthCheckTimeout;
67 	uchar *uid;
68 	uchar *pwd;
69 	uchar *authBuf;
70 	uchar *httpcontenttype;
71 	uchar *headerContentTypeBuf;
72 	uchar *httpheaderkey;
73 	uchar *httpheadervalue;
74 	uchar *headerBuf;
75 	uchar **httpHeaders;
76 	int nHttpHeaders;
77 	uchar *restPath;
78 	uchar *checkPath;
79 	uchar *tplName;
80 	uchar *errorFile;
81 	sbool batchMode;
82 	uchar *batchFormatName;
83 	batchFormat_t batchFormat;
84 	sbool bFreeBatchFormatName;
85 	sbool dynRestPath;
86 	size_t maxBatchBytes;
87 	size_t maxBatchSize;
88 	sbool compress;
89 	sbool useHttps;
90 	sbool allowUnsignedCerts;
91 	sbool skipVerifyHost;
92 	uchar *caCertFile;
93 	uchar *myCertFile;
94 	uchar *myPrivKeyFile;
95 	sbool reloadOnHup;
96 	sbool retryFailures;
97 	unsigned int ratelimitInterval;
98 	unsigned int ratelimitBurst;
99 	ratelimit_t *ratelimiter;
100 	uchar *retryRulesetName;
101 	ruleset_t *retryRuleset;
102 	struct instanceConf_s *next;
103 } instanceData;
104 struct modConfData_s {
105 	rsconf_t *pConf;			instanceConf_t *root, *tail;
106 };
107 static modConfData_t *loadModConf = NULL;	
108 typedef struct wrkrInstanceData {
109 	PTR_ASSERT_DEF
110 	instanceData *pData;
111 	int serverIndex;
112 	int replyLen;
113 	char *reply;
114 	long httpStatusCode;		CURL	*curlCheckConnHandle;		CURL	*curlPostHandle;		HEADER	*curlHeader;		uchar *restURL;			sbool bzInitDone;
115 	z_stream zstrm; 	struct {
116 		uchar **data;				uchar *restPath;			size_t sizeBytes;			size_t nmemb;		
117 	} batch;
118 	struct {
119 		uchar *buf;
120 		size_t curLen;
121 		size_t len;
122 	} compressCtx;
123 } wrkrInstanceData_t;
124 <a name="3"></a>
125 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr actpdescr[] = {
126 	{ "server", eCmdHdlrArray, 0 },
127 	{ "serverport", eCmdHdlrInt, 0 },
128 	{ "healthchecktimeout", eCmdHdlrInt, 0 },
129 	{ "httpcontenttype", eCmdHdlrGetWord, 0 },
130 	{ "httpheaderkey", eCmdHdlrGetWord, 0 },
131 	{ "httpheadervalue", eCmdHdlrString, 0 },
132 	{ "httpheaders", eCmdHdlrArray, 0 },
133 <a name="0"></a>	{ "uid", eCmdHdlrGetWord, 0 },
134 	{ "pwd", eCmdHdlrGetWord, 0 },
135 	{ "restpath", eCmdHdlrGetWord, 0 },</b></font>
136 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "checkpath", eCmdHdlrGetWord, 0 },
137 	{ "dynrestpath", eCmdHdlrBinary, 0 },
138 	{ "batch", eCmdHdlrBinary, 0 },
139 	{ "batch.format", eCmdHdlrGetWord, 0 },
140 	{ "batch.maxbytes", eCmdHdlrSize, 0 },
141 	{ "batch.maxsize", eCmdHdlrSize, 0 },
142 	{ "compress", eCmdHdlrBinary, 0 },
143 	{ "compress.level", eCmdHdlrInt, 0 },
144 	{ "usehttps", eCmdHdlrBinary, 0 },
145 	{ "errorfile", eCmdHdlrGetWord, 0 },
146 	{ "template", eCmdHdlrGetWord, 0 },
147 	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
148 	{ "skipverifyhost", eCmdHdlrBinary, 0 },
149 	{ "tls.cacert", eCmdHdlrString, 0 },
150 	{ "tls.mycert", eCmdHdlrString, 0 },
151 	{ "tls.myprivkey", eCmdHdlrString, 0 },
152 	{ "reloadonhup", eCmdHdlrBinary, 0 },
153 	{ "retry", eCmdHdlrBinary, 0 },
154 	{ "retry.ruleset", eCmdHdlrString, 0 },
155 	{ "ratelimit.interval", eCmdHdlrInt, 0 },
156 	{ "ratelimit.burst", eCmdHdlrInt, 0 },
157 };
158 static struct cnfparamblk actpblk =
159 	{ CNFPARAMBLK_VERSION,
160 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
161 	  actpdescr
162 	};
163 static rsRetVal curlSetup(wrkrInstanceData_t *pWrkrData);</b></font>
164 static void curlCleanup(wrkrInstanceData_t *pWrkrData);
165 static void curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData);
166 static void ATTR_NONNULL()
167 initCompressCtx(wrkrInstanceData_t *pWrkrData);
168 static void ATTR_NONNULL()
169 freeCompressCtx(wrkrInstanceData_t *pWrkrData);
170 static rsRetVal ATTR_NONNULL()
171 resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len);
172 static rsRetVal ATTR_NONNULL()
173 growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen);
174 static rsRetVal ATTR_NONNULL()
175 appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen);
176 BEGINcreateInstance
177 CODESTARTcreateInstance
178 	pData-&gt;fdErrFile = -1;
179 	pthread_mutex_init(&amp;pData-&gt;mutErrFile, NULL);
180 	pData-&gt;caCertFile = NULL;
181 	pData-&gt;myCertFile = NULL;
182 	pData-&gt;myPrivKeyFile = NULL;
183 	pData-&gt;ratelimiter = NULL;
184 	pData-&gt;retryRulesetName = NULL;
185 	pData-&gt;retryRuleset = NULL;
186 ENDcreateInstance
187 BEGINcreateWrkrInstance
188 uchar **batchData;
189 CODESTARTcreateWrkrInstance
190 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
191 	pWrkrData-&gt;curlHeader = NULL;
192 	pWrkrData-&gt;curlPostHandle = NULL;
193 	pWrkrData-&gt;curlCheckConnHandle = NULL;
194 	pWrkrData-&gt;serverIndex = 0;
195 	pWrkrData-&gt;httpStatusCode = 0;
196 	pWrkrData-&gt;restURL = NULL;
197 	pWrkrData-&gt;bzInitDone = 0;
198 	if(pData-&gt;batchMode) {
199 		pWrkrData-&gt;batch.nmemb = 0;
200 		pWrkrData-&gt;batch.sizeBytes = 0;
201 		batchData = (uchar **) malloc(pData-&gt;maxBatchSize * sizeof(uchar *));
202 		if (batchData == NULL) {
203 			LogError(0, RS_RET_OUT_OF_MEMORY,
204 				"omhttp: cannot allocate memory for batch queue turning off batch mode\n");
205 			pData-&gt;batchMode = 0; 		} else {
206 			pWrkrData-&gt;batch.data = batchData;
207 			pWrkrData-&gt;batch.restPath = NULL;
208 		}
209 	}
210 	initCompressCtx(pWrkrData);
211 	iRet = curlSetup(pWrkrData);
212 ENDcreateWrkrInstance
213 BEGINisCompatibleWithFeature
214 CODESTARTisCompatibleWithFeature
215 	if(eFeat == sFEATURERepeatedMsgReduction)
216 		iRet = RS_RET_OK;
217 ENDisCompatibleWithFeature
218 BEGINfreeInstance
219 	int i;
220 CODESTARTfreeInstance
221 	if(pData-&gt;fdErrFile != -1)
222 		close(pData-&gt;fdErrFile);
223 	pthread_mutex_destroy(&amp;pData-&gt;mutErrFile);
224 	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
225 		free(pData-&gt;serverBaseUrls[i]);
226 	free(pData-&gt;serverBaseUrls);
227 	free(pData-&gt;uid);
228 	free(pData-&gt;httpcontenttype);
229 	free(pData-&gt;headerContentTypeBuf);
230 	free(pData-&gt;httpheaderkey);
231 	free(pData-&gt;httpheadervalue);
232 	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i) {
233 		free((void*) pData-&gt;httpHeaders[i]);
234 	}
235 	free(pData-&gt;httpHeaders);
236 	pData-&gt;nHttpHeaders = 0;
237 	free(pData-&gt;pwd);
238 	free(pData-&gt;authBuf);
239 	free(pData-&gt;headerBuf);
240 	free(pData-&gt;restPath);
241 	free(pData-&gt;checkPath);
242 	free(pData-&gt;tplName);
243 	free(pData-&gt;errorFile);
244 	free(pData-&gt;caCertFile);
245 	free(pData-&gt;myCertFile);
246 	free(pData-&gt;myPrivKeyFile);
247 	free(pData-&gt;retryRulesetName);
248 	if (pData-&gt;ratelimiter != NULL)
249 		ratelimitDestruct(pData-&gt;ratelimiter);
250 	if (pData-&gt;bFreeBatchFormatName)
251 		free(pData-&gt;batchFormatName);
252 ENDfreeInstance
253 BEGINfreeWrkrInstance
254 CODESTARTfreeWrkrInstance
255 	curlCleanup(pWrkrData);
256 	free(pWrkrData-&gt;restURL);
257 	pWrkrData-&gt;restURL = NULL;
258 	free(pWrkrData-&gt;batch.data);
259 	pWrkrData-&gt;batch.data = NULL;
260 	if (pWrkrData-&gt;batch.restPath != NULL)  {
261 		free(pWrkrData-&gt;batch.restPath);
262 		pWrkrData-&gt;batch.restPath = NULL;
263 	}
264 	if (pWrkrData-&gt;bzInitDone)
265 		deflateEnd(&amp;pWrkrData-&gt;zstrm);
266 	freeCompressCtx(pWrkrData);
267 ENDfreeWrkrInstance
268 BEGINdbgPrintInstInfo
269 	int i;
270 CODESTARTdbgPrintInstInfo
271 	dbgprintf("omhttp\n");
272 	dbgprintf("\ttemplate='%s'\n", pData-&gt;tplName);
273 	dbgprintf("\tnumServers=%d\n", pData-&gt;numServers);
274 	dbgprintf("\thealthCheckTimeout=%lu\n", pData-&gt;healthCheckTimeout);
275 	dbgprintf("\tserverBaseUrls=");
276 	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
277 		dbgprintf("%c'%s'", i == 0 ? '[' : ' ', pData-&gt;serverBaseUrls[i]);
278 	dbgprintf("]\n");
279 	dbgprintf("\tdefaultPort=%d\n", pData-&gt;defaultPort);
280 	dbgprintf("\tuid='%s'\n", pData-&gt;uid == NULL ? (uchar*)"(not configured)" : pData-&gt;uid);
281 	dbgprintf("\thttpcontenttype='%s'\n", pData-&gt;httpcontenttype == NULL ?
282 		(uchar*)"(not configured)" : pData-&gt;httpcontenttype);
283 	dbgprintf("\thttpheaderkey='%s'\n", pData-&gt;httpheaderkey == NULL ?
284 		(uchar*)"(not configured)" : pData-&gt;httpheaderkey);
285 	dbgprintf("\thttpheadervalue='%s'\n", pData-&gt;httpheadervalue == NULL ?
286 		(uchar*)"(not configured)" : pData-&gt;httpheadervalue);
287 	dbgprintf("\thttpHeaders=[");
288 	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i)
289 		dbgprintf("\t%s\n",pData-&gt;httpHeaders[i]);
290 	dbgprintf("\t]\n");
291 	dbgprintf("\tpwd=(%sconfigured)\n", pData-&gt;pwd == NULL ? "not " : "");
292 	dbgprintf("\trest path='%s'\n", pData-&gt;restPath);
293 	dbgprintf("\tcheck path='%s'\n", pData-&gt;checkPath);
294 	dbgprintf("\tdynamic rest path=%d\n", pData-&gt;dynRestPath);
295 	dbgprintf("\tuse https=%d\n", pData-&gt;useHttps);
296 	dbgprintf("\tbatch=%d\n", pData-&gt;batchMode);
297 	dbgprintf("\tbatch.format='%s'\n", pData-&gt;batchFormatName);
298 	dbgprintf("\tbatch.maxbytes=%zu\n", pData-&gt;maxBatchBytes);
299 	dbgprintf("\tbatch.maxsize=%zu\n", pData-&gt;maxBatchSize);
300 	dbgprintf("\tcompress=%d\n", pData-&gt;compress);
301 	dbgprintf("\tcompress.level=%d\n", pData-&gt;compressionLevel);
302 	dbgprintf("\tallowUnsignedCerts=%d\n", pData-&gt;allowUnsignedCerts);
303 	dbgprintf("\tskipVerifyHost=%d\n", pData-&gt;skipVerifyHost);
304 	dbgprintf("\terrorfile='%s'\n", pData-&gt;errorFile == NULL ?
305 		(uchar*)"(not configured)" : pData-&gt;errorFile);
306 	dbgprintf("\ttls.cacert='%s'\n", pData-&gt;caCertFile);
307 	dbgprintf("\ttls.mycert='%s'\n", pData-&gt;myCertFile);
308 	dbgprintf("\ttls.myprivkey='%s'\n", pData-&gt;myPrivKeyFile);
309 	dbgprintf("\treloadonhup='%d'\n", pData-&gt;reloadOnHup);
310 	dbgprintf("\tretry='%d'\n", pData-&gt;retryFailures);
311 	dbgprintf("\tretry.ruleset='%s'\n", pData-&gt;retryRulesetName);
312 	dbgprintf("\tratelimit.interval='%u'\n", pData-&gt;ratelimitInterval);
313 	dbgprintf("\tratelimit.burst='%u'\n", pData-&gt;ratelimitBurst);
314 ENDdbgPrintInstInfo
315 static size_t
316 curlResult(void *ptr, size_t size, size_t nmemb, void *userdata)
317 {
318 	char *p = (char *)ptr;
319 	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t*) userdata;
320 	char *buf;
321 	size_t newlen;
322 	PTR_ASSERT_CHK(pWrkrData, WRKR_DATA_TYPE_ES);
323 	newlen = pWrkrData-&gt;replyLen + size*nmemb;
324 	if((buf = realloc(pWrkrData-&gt;reply, newlen + 1)) == NULL) {
325 		LogError(errno, RS_RET_ERR, "omhttp: realloc failed in curlResult");
326 		return 0; 	}
327 	memcpy(buf+pWrkrData-&gt;replyLen, p, size*nmemb);
328 	pWrkrData-&gt;replyLen = newlen;
329 	pWrkrData-&gt;reply = buf;
330 	return size*nmemb;
331 }
332 static rsRetVal
333 computeBaseUrl(const char*const serverParam,
334 	const int defaultPort,
335 	const sbool useHttps,
336 	uchar **baseUrl)
337 {
338 #	define SCHEME_HTTPS "https://"
339 #	define SCHEME_HTTP "http://"
340 	char portBuf[64];
341 	int r = 0;
342 	const char *host = serverParam;
343 	DEFiRet;
344 	assert(serverParam[strlen(serverParam)-1] != '/');
345 	es_str_t *urlBuf = es_newStr(256);
346 	if (urlBuf == NULL) {
347 		LogError(0, RS_RET_OUT_OF_MEMORY,
348 		"omhttp: failed to allocate es_str urlBuf in computeBaseUrl");
349 		ABORT_FINALIZE(RS_RET_ERR);
350 	}
351 	if (strcasestr(serverParam, SCHEME_HTTP))
352 		host = serverParam + strlen(SCHEME_HTTP);
353 	else if (strcasestr(serverParam, SCHEME_HTTPS))
354 		host = serverParam + strlen(SCHEME_HTTPS);
355 	else
356 		r = useHttps ? es_addBuf(&amp;urlBuf, SCHEME_HTTPS, sizeof(SCHEME_HTTPS)-1) :
357 			es_addBuf(&amp;urlBuf, SCHEME_HTTP, sizeof(SCHEME_HTTP)-1);
358 	if (r == 0) r = es_addBuf(&amp;urlBuf, (char *)serverParam, strlen(serverParam));
359 	if (r == 0 &amp;&amp; !strchr(host, ':')) {
360 		snprintf(portBuf, sizeof(portBuf), ":%d", defaultPort);
361 		r = es_addBuf(&amp;urlBuf, portBuf, strlen(portBuf));
362 	}
363 	if (r == 0) r = es_addChar(&amp;urlBuf, '/');
364 	if (r == 0) *baseUrl = (uchar*) es_str2cstr(urlBuf, NULL);
365 	if (r != 0 || baseUrl == NULL) {
366 		LogError(0, RS_RET_ERR,
367 			"omhttp: error occurred computing baseUrl from server %s", serverParam);
368 		ABORT_FINALIZE(RS_RET_ERR);
369 	}
370 finalize_it:
371 	if (urlBuf) {
372 		es_deleteStr(urlBuf);
373 	}
374 	RETiRet;
375 }
376 static inline void
377 incrementServerIndex(wrkrInstanceData_t *pWrkrData)
378 {
379 	pWrkrData-&gt;serverIndex = (pWrkrData-&gt;serverIndex + 1) % pWrkrData-&gt;pData-&gt;numServers;
380 }
381 static rsRetVal ATTR_NONNULL()
382 checkConn(wrkrInstanceData_t *const pWrkrData)
383 {
384 	CURL *curl;
385 	CURLcode res;
386 	es_str_t *urlBuf = NULL;
387 	char* healthUrl;
388 	char* serverUrl;
389 	char* checkPath;
390 	int i;
391 	int r;
392 	DEFiRet;
393 	if (pWrkrData-&gt;pData-&gt;checkPath == NULL) {
394 		DBGPRINTF("omhttp: checkConn no health check uri configured skipping it\n");
395 		FINALIZE;
396 	}
397 	pWrkrData-&gt;reply = NULL;
398 	pWrkrData-&gt;replyLen = 0;
399 	curl = pWrkrData-&gt;curlCheckConnHandle;
400 	urlBuf = es_newStr(256);
401 	if (urlBuf == NULL) {
402 		LogError(0, RS_RET_OUT_OF_MEMORY,
403 			"omhttp: unable to allocate buffer for health check uri.");
404 		ABORT_FINALIZE(RS_RET_SUSPENDED);
405 	}
406 	for(i = 0; i &lt; pWrkrData-&gt;pData-&gt;numServers; ++i) {
407 		serverUrl = (char*) pWrkrData-&gt;pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
408 		checkPath = (char*) pWrkrData-&gt;pData-&gt;checkPath;
409 		es_emptyStr(urlBuf);
410 		r = es_addBuf(&amp;urlBuf, serverUrl, strlen(serverUrl));
411 		if(r == 0 &amp;&amp; checkPath != NULL)
412 			r = es_addBuf(&amp;urlBuf, checkPath, strlen(checkPath));
413 		if(r == 0)
414 			healthUrl = es_str2cstr(urlBuf, NULL);
415 		if(r != 0 || healthUrl == NULL) {
416 			LogError(0, RS_RET_OUT_OF_MEMORY,
417 				"omhttp: unable to allocate buffer for health check uri.");
418 			ABORT_FINALIZE(RS_RET_SUSPENDED);
419 		}
420 		curlCheckConnSetup(pWrkrData);
421 		curl_easy_setopt(curl, CURLOPT_URL, healthUrl);
422 		res = curl_easy_perform(curl);
423 		free(healthUrl);
424 		if (res == CURLE_OK) {
425 			DBGPRINTF("omhttp: checkConn %s completed with success "
426 				"on attempt %d\n", serverUrl, i);
427 			ABORT_FINALIZE(RS_RET_OK);
428 		}
429 		DBGPRINTF("omhttp: checkConn %s failed on attempt %d: %s\n",
430 			serverUrl, i, curl_easy_strerror(res));
431 		incrementServerIndex(pWrkrData);
432 	}
433 	LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
434 		"omhttp: checkConn failed after %d attempts.", i);
435 	ABORT_FINALIZE(RS_RET_SUSPENDED);
436 finalize_it:
437 	if(urlBuf != NULL)
438 		es_deleteStr(urlBuf);
439 	free(pWrkrData-&gt;reply);
440 	pWrkrData-&gt;reply = NULL; 	RETiRet;
441 }
442 BEGINtryResume
443 CODESTARTtryResume
444 	DBGPRINTF("omhttp: tryResume called\n");
445 	iRet = checkConn(pWrkrData);
446 ENDtryResume
447 static void ATTR_NONNULL(1)
448 getRestPath(const instanceData *const pData, uchar **const tpls,
449 		      uchar **const restPath)
450 {
451 	*restPath = pData-&gt;restPath;
452 	if(tpls == NULL) {
453 		goto done;
454 	}
455 	int iNumTpls = 1;
456 	if(pData-&gt;dynRestPath) {
457 		*restPath = tpls[iNumTpls];
458 		++iNumTpls;
459 	}
460 done:
461 	assert(restPath != NULL);
462 	return;
463 }
464 static rsRetVal ATTR_NONNULL(1)
465 setPostURL(wrkrInstanceData_t *const pWrkrData, uchar **const tpls)
466 {
467 	uchar *restPath;
468 	char* baseUrl;
469 	es_str_t *url;
470 	int r;
471 	DEFiRet;
472 	instanceData *const pData = pWrkrData-&gt;pData;
473 	baseUrl = (char*)pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
474 	url = es_newStrFromCStr(baseUrl, strlen(baseUrl));
475 	if (url == NULL) {
476 		LogError(0, RS_RET_OUT_OF_MEMORY,
477 			"omhttp: error allocating new estr for POST url.");
478 		ABORT_FINALIZE(RS_RET_ERR);
479 	}
480 	if (pWrkrData-&gt;batch.restPath != NULL) {
481 		restPath = pWrkrData-&gt;batch.restPath;
482 	} else {
483 		getRestPath(pData, tpls, &amp;restPath);
484 	}
485 	r = 0;
486 	if (restPath != NULL)
487 		r = es_addBuf(&amp;url, (char*)restPath, ustrlen(restPath));
488 	if(r != 0) {
489 		LogError(0, RS_RET_ERR, "omhttp: failure in creating restURL, "
490 				"error code: %d", r);
491 		ABORT_FINALIZE(RS_RET_ERR);
492 	}
493 	if(pWrkrData-&gt;restURL != NULL)
494 		free(pWrkrData-&gt;restURL);
495 	pWrkrData-&gt;restURL = (uchar*)es_str2cstr(url, NULL);
496 	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_URL, pWrkrData-&gt;restURL);
497 	DBGPRINTF("omhttp: using REST URL: '%s'\n", pWrkrData-&gt;restURL);
498 finalize_it:
499 	if (url != NULL)
500 		es_deleteStr(url);
501 	RETiRet;
502 }
503 static rsRetVal
504 renderJsonErrorMessage(wrkrInstanceData_t *pWrkrData, uchar *reqmsg, char **rendered)
505 {
506 	DEFiRet;
507 	fjson_object *req = NULL;
508 	fjson_object *res = NULL;
509 	fjson_object *errRoot = NULL;
510 	if ((req = fjson_object_new_object()) == NULL)
511 		ABORT_FINALIZE(RS_RET_ERR);
512 	fjson_object_object_add(req, "url", fjson_object_new_string((char *)pWrkrData-&gt;restURL));
513 	fjson_object_object_add(req, "postdata", fjson_object_new_string((char *)reqmsg));
514 	if ((res = fjson_object_new_object()) == NULL) {
515 		fjson_object_put(req); 		ABORT_FINALIZE(RS_RET_ERR);
516 	}
517 	#define ERR_MSG_NULL "NULL: curl request failed or no response"
518 	fjson_object_object_add(res, "status", fjson_object_new_int(pWrkrData-&gt;httpStatusCode));
519 	if (pWrkrData-&gt;reply == NULL) {
520 		fjson_object_object_add(res, "message",
521 			fjson_object_new_string_len(ERR_MSG_NULL, strlen(ERR_MSG_NULL)));
522 	} else {
523 		fjson_object_object_add(res, "message",
524 			fjson_object_new_string_len(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen));
525 	}
526 	if ((errRoot = fjson_object_new_object()) == NULL) {
527 		fjson_object_put(req); 		fjson_object_put(res); 		ABORT_FINALIZE(RS_RET_ERR);
528 	}
529 	fjson_object_object_add(errRoot, "request", req);
530 	fjson_object_object_add(errRoot, "response", res);
531 	*rendered = strdup((char *) fjson_object_to_json_string(errRoot));
532 finalize_it:
533 	if (errRoot != NULL)
534 		fjson_object_put(errRoot);
535 	RETiRet;
536 }
537 static rsRetVal ATTR_NONNULL()
538 writeDataError(wrkrInstanceData_t *const pWrkrData,
539 	instanceData *const pData, uchar *const reqmsg)
540 {
541 	char *rendered = NULL;
542 	size_t toWrite;
543 	ssize_t wrRet;
544 	sbool bMutLocked = 0;
545 	DEFiRet;
546 	if(pData-&gt;errorFile == NULL) {
547 		DBGPRINTF("omhttp: no local error logger defined - "
548 			"ignoring REST error information\n");
549 		FINALIZE;
550 	}
551 	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
552 	bMutLocked = 1;
553 	CHKiRet(renderJsonErrorMessage(pWrkrData, reqmsg, &amp;rendered));
554 	if(pData-&gt;fdErrFile == -1) {
555 		pData-&gt;fdErrFile = open((char*)pData-&gt;errorFile,
556 					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
557 					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
558 		if(pData-&gt;fdErrFile == -1) {
559 			LogError(errno, RS_RET_ERR, "omhttp: error opening error file %s",
560 				pData-&gt;errorFile);
561 			ABORT_FINALIZE(RS_RET_ERR);
562 		}
563 	}
564 	DBGPRINTF("omhttp: error record: '%s'\n", rendered);
565 	toWrite = strlen(rendered) + 1;
566 	rendered[toWrite-1] = '\n'; 	wrRet = write(pData-&gt;fdErrFile, rendered, toWrite);
567 	if(wrRet != (ssize_t) toWrite) {
568 		LogError(errno, RS_RET_IO_ERROR,
569 			"omhttp: error writing error file %s, write returned %lld",
570 			pData-&gt;errorFile, (long long) wrRet);
571 	}
572 finalize_it:
573 	if(bMutLocked)
574 		pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
575 	free(rendered);
576 	RETiRet;
577 }
578 static rsRetVal
579 queueBatchOnRetryRuleset(wrkrInstanceData_t *const pWrkrData, instanceData *const pData)
580 {
581 	uchar *msgData;
582 	smsg_t *pMsg;
583 	DEFiRet;
584 	if (pData-&gt;retryRuleset == NULL) {
585 		LogError(0, RS_RET_ERR, "omhttp: queueBatchOnRetryRuleset invalid call with a NULL retryRuleset");
586 		ABORT_FINALIZE(RS_RET_ERR);
587 	}
588 	for (size_t i = 0; i &lt; pWrkrData-&gt;batch.nmemb; i++) {
589 		msgData = pWrkrData-&gt;batch.data[i];
590 		DBGPRINTF("omhttp: queueBatchOnRetryRuleset putting message '%s' into retry ruleset '%s'\n",
591 			msgData, pData-&gt;retryRulesetName);
592 		CHKiRet(msgConstruct(&amp;pMsg));
593 		CHKiRet(MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY));
594 		MsgSetInputName(pMsg, pInputName);
595 		MsgSetRawMsg(pMsg, (const char *)msgData, ustrlen(msgData));
596 		MsgSetMSGoffs(pMsg, 0); 		MsgSetTAG(pMsg, (const uchar *)"omhttp-retry", 12);
597 		MsgSetRuleset(pMsg, pData-&gt;retryRuleset);
598 		ratelimitAddMsg(pData-&gt;ratelimiter, NULL, pMsg);
599 		STATSCOUNTER_INC(ctrMessagesRetry, mutCtrMessagesRetry);
600 	}
601 finalize_it:
602 	RETiRet;
603 }
604 static rsRetVal
605 checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
606 {
607 	instanceData *pData;
608 	long statusCode;
609 	size_t numMessages;
610 	DEFiRet;
611 	pData = pWrkrData-&gt;pData;
612 	statusCode = pWrkrData-&gt;httpStatusCode;
613 	if (pData-&gt;batchMode) {
614 		numMessages = pWrkrData-&gt;batch.nmemb;
615 	} else {
616 		numMessages = 1;
617 	}
618 	if (statusCode == 0) {
619 		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
620 		iRet = RS_RET_SUSPENDED;
621 	} else if (statusCode &gt;= 500) {
622 		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
623 		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
624 		iRet = RS_RET_SUSPENDED;
625 	} else if (statusCode &gt;= 300) {
626 		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
627 		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
628 		iRet = RS_RET_DATAFAIL;
629 	} else {
630 		STATSCOUNTER_INC(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
631 		STATSCOUNTER_ADD(ctrMessagesSuccess, mutCtrMessagesSuccess, numMessages);
632 		iRet = RS_RET_OK;
633 	}
634 	if (iRet != RS_RET_OK) {
635 		LogMsg(0, iRet, LOG_ERR, "omhttp: checkResult error http status code: %ld reply: %s",
636 			statusCode, pWrkrData-&gt;reply != NULL ? pWrkrData-&gt;reply : "NULL");
637 		writeDataError(pWrkrData, pWrkrData-&gt;pData, reqmsg);
638 		if (iRet == RS_RET_DATAFAIL)
639 			ABORT_FINALIZE(iRet);
640 		if (pData-&gt;batchMode &amp;&amp; pData-&gt;maxBatchSize &gt; 1) {
641 			if (pData-&gt;retryFailures &amp;&amp; pData-&gt;retryRuleset != NULL) {
642 				iRet = queueBatchOnRetryRuleset(pWrkrData, pData);
643 				if (iRet != RS_RET_OK) {
644 					LogMsg(0, iRet, LOG_ERR,
645 						"omhttp: checkResult error while queueing to retry ruleset"
646 						"some messages may be lost");
647 				}
648 			}
649 			iRet = RS_RET_OK; 		}
650 	}
651 finalize_it:
652 	RETiRet;
653 }
654 static rsRetVal
655 compressHttpPayload(wrkrInstanceData_t *pWrkrData, uchar *message, unsigned len)
656 {
657 	int zRet;
658 	unsigned outavail;
659 	uchar zipBuf[32*1024];
660 	DEFiRet;
661 	if (!pWrkrData-&gt;bzInitDone) {
662 		pWrkrData-&gt;zstrm.zalloc = Z_NULL;
663 		pWrkrData-&gt;zstrm.zfree = Z_NULL;
664 		pWrkrData-&gt;zstrm.opaque = Z_NULL;
665 		zRet = deflateInit2(&amp;pWrkrData-&gt;zstrm, pWrkrData-&gt;pData-&gt;compressionLevel,
666 			Z_DEFLATED, 31, 8, Z_DEFAULT_STRATEGY);
667 		if (zRet != Z_OK) {
668 			DBGPRINTF("omhttp: compressHttpPayload error %d returned from zlib/deflateInit2()\n", zRet);
669 			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
670 		}
671 		pWrkrData-&gt;bzInitDone = 1;
672 	}
673 	CHKiRet(resetCompressCtx(pWrkrData, len));
674 	pWrkrData-&gt;zstrm.next_in = (Bytef*) message;
675 	pWrkrData-&gt;zstrm.avail_in = len;
676 	do {
677 		DBGPRINTF("omhttp: compressHttpPayload in deflate() loop, avail_in %d, total_in %ld\n",
678 				pWrkrData-&gt;zstrm.avail_in, pWrkrData-&gt;zstrm.total_in);
679 		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
680 		pWrkrData-&gt;zstrm.next_out = zipBuf;
681 		zRet = deflate(&amp;pWrkrData-&gt;zstrm, Z_NO_FLUSH);
682 		DBGPRINTF("omhttp: compressHttpPayload after deflate, ret %d, avail_out %d\n",
683 				zRet, pWrkrData-&gt;zstrm.avail_out);
684 		if (zRet != Z_OK)
685 			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
686 		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
687 		if (outavail != 0)
688 			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));
689 	} while (pWrkrData-&gt;zstrm.avail_out == 0);
690 	pWrkrData-&gt;zstrm.avail_in = 0;
691 	do {
692 		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
693 		pWrkrData-&gt;zstrm.next_out = zipBuf;
694 		deflate(&amp;pWrkrData-&gt;zstrm, Z_FINISH); 		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
695 		if (outavail != 0)
696 			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));
697 	} while (pWrkrData-&gt;zstrm.avail_out == 0);
698 finalize_it:
699 	if (pWrkrData-&gt;bzInitDone)
700 		deflateEnd(&amp;pWrkrData-&gt;zstrm);
701 	pWrkrData-&gt;bzInitDone = 0;
702 	RETiRet;
703 }
704 static void ATTR_NONNULL()
705 initCompressCtx(wrkrInstanceData_t *pWrkrData)
706 {
707 	pWrkrData-&gt;compressCtx.buf = NULL;
708 	pWrkrData-&gt;compressCtx.curLen = 0;
709 	pWrkrData-&gt;compressCtx.len = 0;
710 }
711 static void ATTR_NONNULL()
712 freeCompressCtx(wrkrInstanceData_t *pWrkrData)
713 {
714 	if (pWrkrData-&gt;compressCtx.buf != NULL) {
715 		free(pWrkrData-&gt;compressCtx.buf);
716 		pWrkrData-&gt;compressCtx.buf = NULL;
717 	}
718 }
719 static rsRetVal ATTR_NONNULL()
720 resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len)
721 {
722 	DEFiRet;
723 	pWrkrData-&gt;compressCtx.curLen = 0;
724 	pWrkrData-&gt;compressCtx.len = len;
725 	CHKiRet(growCompressCtx(pWrkrData, len));
726 finalize_it:
727 	if (iRet != RS_RET_OK)
728 		freeCompressCtx(pWrkrData);
729 	RETiRet;
730 }
731 static rsRetVal ATTR_NONNULL()
732 growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen)
733 {
734 	DEFiRet;
735 	if (pWrkrData-&gt;compressCtx.buf == NULL) {
736 		CHKmalloc(pWrkrData-&gt;compressCtx.buf = (uchar *)malloc(sizeof(uchar)*newLen));
737 	} else {
738 		uchar *const newbuf = (uchar *)realloc(pWrkrData-&gt;compressCtx.buf, sizeof(uchar)*newLen);
739 		CHKmalloc(newbuf);
740 		pWrkrData-&gt;compressCtx.buf = newbuf;
741 	}
742 	pWrkrData-&gt;compressCtx.len = newLen;
743 finalize_it:
744 	RETiRet;
745 }
746 static rsRetVal ATTR_NONNULL()
747 appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen)
748 {
749 	size_t newLen;
750 	DEFiRet;
751 	newLen = pWrkrData-&gt;compressCtx.curLen + srcLen;
752 	if (newLen &gt; pWrkrData-&gt;compressCtx.len)
753 		CHKiRet(growCompressCtx(pWrkrData, newLen));
754 	memcpy(pWrkrData-&gt;compressCtx.buf + pWrkrData-&gt;compressCtx.curLen,
755 		srcBuf, srcLen);
756 	pWrkrData-&gt;compressCtx.curLen = newLen;
757 finalize_it:
758 	if (iRet != RS_RET_OK)
759 		freeCompressCtx(pWrkrData);
760 	RETiRet;
761 }
762 static rsRetVal ATTR_NONNULL()
763 buildCurlHeaders(wrkrInstanceData_t *pWrkrData, sbool contentEncodeGzip)
764 {
765 	struct curl_slist *slist = NULL;
766 	DEFiRet;
767 	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
768 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
769 	} else {
770 		if (pWrkrData-&gt;pData-&gt;batchMode) {
771 			switch (pWrkrData-&gt;pData-&gt;batchFormat) {
772 				case FMT_JSONARRAY:
773 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
774 					break;
775 				case FMT_KAFKAREST:
776 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_KAFKA);
777 					break;
778 				case FMT_NEWLINE:
779 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
780 					break;
781 				case FMT_LOKIREST:
782 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
783 					break;
784 				default:
785 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
786 			}
787 		} else {
788 			slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
789 		}
790 	}
791 	CHKmalloc(slist);
792 	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
793 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
794 		CHKmalloc(slist);
795 	}
796 	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
797 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
798 		CHKmalloc(slist);
799 	}
800 	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
801 	CHKmalloc(slist);
802 	if (contentEncodeGzip) {
803 		slist = curl_slist_append(slist, HTTP_HEADER_ENCODING_GZIP);
804 		CHKmalloc(slist);
805 	}
806 	if (pWrkrData-&gt;curlHeader != NULL)
807 		curl_slist_free_all(pWrkrData-&gt;curlHeader);
808 	pWrkrData-&gt;curlHeader = slist;
809 finalize_it:
810 	if (iRet != RS_RET_OK) {
811 		curl_slist_free_all(slist);
812 		LogError(0, iRet, "omhttp: error allocating curl header slist, using previous one");
813 	}
814 	RETiRet;
815 }
816 static rsRetVal ATTR_NONNULL(1, 2)
817 curlPost(wrkrInstanceData_t *pWrkrData, uchar *message, int msglen, uchar **tpls,
818 		const int nmsgs __attribute__((unused)))
819 {
820 	CURLcode curlCode;
821 	CURL *const curl = pWrkrData-&gt;curlPostHandle;
822 	char errbuf[CURL_ERROR_SIZE] = "";
823 	char *postData;
824 	int postLen;
825 	sbool compressed;
826 	DEFiRet;
827 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
828 	if(pWrkrData-&gt;pData-&gt;numServers &gt; 1) {
829 		CHKiRet(checkConn(pWrkrData));
830 	}
831 	CHKiRet(setPostURL(pWrkrData, tpls));
832 	pWrkrData-&gt;reply = NULL;
833 	pWrkrData-&gt;replyLen = 0;
834 	pWrkrData-&gt;httpStatusCode = 0;
835 	postData = (char *)message;
836 	postLen = msglen;
837 	compressed = 0;
838 	if (pWrkrData-&gt;pData-&gt;compress) {
839 		iRet = compressHttpPayload(pWrkrData, message, msglen);
840 		if (iRet != RS_RET_OK) {
841 			LogError(0, iRet, "omhttp: curlPost error while compressing, will default to uncompressed");
842 		} else {
843 			postData = (char *)pWrkrData-&gt;compressCtx.buf;
844 			postLen = pWrkrData-&gt;compressCtx.curLen;
845 			compressed = 1;
846 			DBGPRINTF("omhttp: curlPost compressed %d to %d bytes\n", msglen, postLen);
847 		}
848 	}
849 	buildCurlHeaders(pWrkrData, compressed);
850 	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData);
851 	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, postLen);
852 	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
853 	curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
854 	curlCode = curl_easy_perform(curl);
855 	DBGPRINTF("omhttp: curlPost curl returned %lld\n", (long long) curlCode);
856 	STATSCOUNTER_INC(ctrHttpRequestCount, mutCtrHttpRequestCount);
857 	if (curlCode != CURLE_OK) {
858 		STATSCOUNTER_INC(ctrHttpRequestFail, mutCtrHttpRequestFail);
859 		LogError(0, RS_RET_SUSPENDED,
860 			"omhttp: suspending ourselves due to server failure %lld: %s",
861 			(long long) curlCode, errbuf);
862 		checkResult(pWrkrData, message);
863 		ABORT_FINALIZE(RS_RET_SUSPENDED);
864 	} else {
865 		STATSCOUNTER_INC(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
866 	}
867 	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;pWrkrData-&gt;httpStatusCode);
868 	if(pWrkrData-&gt;reply == NULL) {
869 		DBGPRINTF("omhttp: curlPost pWrkrData reply==NULL, replyLen = '%d'\n",
870 			pWrkrData-&gt;replyLen);
871 	} else {
872 		DBGPRINTF("omhttp: curlPost pWrkrData replyLen = '%d'\n", pWrkrData-&gt;replyLen);
873 		if(pWrkrData-&gt;replyLen &gt; 0) {
874 			pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0';
875 		}
876 		DBGPRINTF("omhttp: curlPost pWrkrData reply: '%s'\n", pWrkrData-&gt;reply);
877 	}
878 	CHKiRet(checkResult(pWrkrData, message));
879 finalize_it:
880 	incrementServerIndex(pWrkrData);
881 	if (pWrkrData-&gt;reply != NULL) {
882 		free(pWrkrData-&gt;reply);
883 		pWrkrData-&gt;reply = NULL; 	}
884 	RETiRet;
885 }
886 static rsRetVal
887 serializeBatchKafkaRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
888 {
889 	fjson_object *batchArray = NULL;
890 	fjson_object *recordObj = NULL;
891 	fjson_object *valueObj = NULL;
892 	fjson_object *msgObj = NULL;
893 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
894 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchKafkaRest numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
895 	DEFiRet;
896 	batchArray = fjson_object_new_array();
897 	if (batchArray == NULL) {
898 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create array");
899 		ABORT_FINALIZE(RS_RET_ERR);
900 	}
901 	for (size_t i = 0; i &lt; numMessages; i++) {
902 		valueObj = fjson_object_new_object();
903 		if (valueObj == NULL) {
904 			fjson_object_put(batchArray); 			LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create value object");
905 			ABORT_FINALIZE(RS_RET_ERR);
906 		}
907 		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
908 		if (msgObj == NULL) {
909 			LogError(0, NO_ERRCODE,
910 				"omhttp: serializeBatchKafkaRest failed to parse %s as json ignoring it",
911 				pWrkrData-&gt;batch.data[i]);
912 			continue;
913 		}
914 		fjson_object_object_add(valueObj, "value", msgObj);
915 		fjson_object_array_add(batchArray, valueObj);
916 	}
917 	recordObj = fjson_object_new_object();
918 	if (recordObj == NULL) {
919 		fjson_object_put(batchArray); 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create record object");
920 		ABORT_FINALIZE(RS_RET_ERR);
921 	}
922 	fjson_object_object_add(recordObj, "records", batchArray);
923 	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
924 	*batchBuf = strndup(batchString, strlen(batchString));
925 finalize_it:
926 	if (recordObj != NULL) {
927 		fjson_object_put(recordObj);
928 		recordObj = NULL;
929 	}
930 	RETiRet;
931 }
932 static rsRetVal
933 serializeBatchLokiRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
934 {
935 	fjson_object *batchArray = NULL;
936 	fjson_object *recordObj = NULL;
937 	fjson_object *msgObj = NULL;
938 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
939 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchLokiRest numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
940 	DEFiRet;
941 	batchArray = fjson_object_new_array();
942 	if (batchArray == NULL) {
943 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchLokiRest failed to create array");
944 		ABORT_FINALIZE(RS_RET_ERR);
945 	}
946 	for (size_t i = 0; i &lt; numMessages; i++) {
947 		DBGPRINTF("omhttp: serializeBatchLokiRest parsing message [%s]\n",(char *) pWrkrData-&gt;batch.data[i]);
948 		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
949 		if (msgObj == NULL) {
950 			LogError(0, NO_ERRCODE,
951 				"omhttp: serializeBatchLokiRest failed to parse %s as json ignoring it",
952 				pWrkrData-&gt;batch.data[i]);
953 			continue;
954 		}
955 		fjson_object_array_add(batchArray, msgObj);
956 	}
957 	recordObj = fjson_object_new_object();
958 	if (recordObj == NULL) {
959 		fjson_object_put(batchArray); 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchLokiRest failed to create record object");
960 		ABORT_FINALIZE(RS_RET_ERR);
961 	}
962 	fjson_object_object_add(recordObj, "streams", batchArray);
963 	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
964 	*batchBuf = strndup(batchString, strlen(batchString));
965 finalize_it:
966 	if (recordObj != NULL) {
967 		fjson_object_put(recordObj);
968 		recordObj = NULL;
969 	}
970 	RETiRet;
971 }
972 static rsRetVal
973 serializeBatchJsonArray(wrkrInstanceData_t *pWrkrData, char **batchBuf)
974 {
975 	fjson_object *batchArray = NULL;
976 	fjson_object *msgObj = NULL;
977 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
978 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchJsonArray numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
979 	DEFiRet;
980 	batchArray = fjson_object_new_array();
981 	if (batchArray == NULL) {
982 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchJsonArray failed to create array");
983 		ABORT_FINALIZE(RS_RET_ERR);
984 	}
985 	for (size_t i = 0; i &lt; numMessages; i++) {
986 		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
987 		if (msgObj == NULL) {
988 			LogError(0, NO_ERRCODE,
989 				"omhttp: serializeBatchJsonArray failed to parse %s as json, ignoring it",
990 				pWrkrData-&gt;batch.data[i]);
991 			continue;
992 		}
993 		fjson_object_array_add(batchArray, msgObj);
994 	}
995 	const char *batchString = fjson_object_to_json_string_ext(batchArray, FJSON_TO_STRING_PLAIN);
996 	*batchBuf = strndup(batchString, strlen(batchString));
997 finalize_it:
998 	if (batchArray != NULL) {
999 		fjson_object_put(batchArray);
1000 		batchArray = NULL;
1001 	}
1002 	RETiRet;
1003 }
1004 static rsRetVal
1005 serializeBatchNewline(wrkrInstanceData_t *pWrkrData, char **batchBuf)
1006 {
1007 	DEFiRet;
1008 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
1009 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages; 	int r = 0;
1010 	DBGPRINTF("omhttp: serializeBatchNewline numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
1011 	es_str_t *batchString = es_newStr(1024);
1012 	if (batchString == NULL)
1013 		ABORT_FINALIZE(RS_RET_ERR);
1014 	for (size_t i = 0; i &lt; numMessages; i++) {
1015 		size_t nToCopy = ustrlen(pWrkrData-&gt;batch.data[i]);
1016 		if (r == 0) r = es_addBuf(&amp;batchString, (char *)pWrkrData-&gt;batch.data[i], nToCopy);
1017 		if (i == numMessages - 1) break;
1018 		if (r == 0) r = es_addChar(&amp;batchString, '\n');
1019 	}
1020 	if (r == 0) *batchBuf = (char *) es_str2cstr(batchString, NULL);
1021 	if (r != 0 || *batchBuf== NULL) {
1022 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchNewline failed to build batch string");
1023 		ABORT_FINALIZE(RS_RET_ERR);
1024 	}
1025 finalize_it:
1026 	if (batchString != NULL)
1027 		es_deleteStr(batchString);
1028 	RETiRet;
1029 }
1030 static size_t
1031 computeBatchSize(wrkrInstanceData_t *pWrkrData)
1032 {
1033 	size_t extraBytes = 0;
1034 	size_t sizeBytes = pWrkrData-&gt;batch.sizeBytes;
1035 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
1036 	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
1037 		case FMT_JSONARRAY:
1038 			extraBytes = numMessages &gt; 0 ? numMessages + 1 : 2;
1039 			break;
1040 		case FMT_KAFKAREST:
1041 			extraBytes = (numMessages * 10) + 14;
1042 			break;
1043 		case FMT_NEWLINE:
1044 			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
1045 			break;
1046 		case FMT_LOKIREST:
1047 			extraBytes = (numMessages * 2) + 14;
1048 			break;
1049 		default:
1050 			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
1051 	}
1052 	return sizeBytes + extraBytes + 1; }
1053 static void ATTR_NONNULL()
1054 initializeBatch(wrkrInstanceData_t *pWrkrData)
1055 {
1056 	pWrkrData-&gt;batch.sizeBytes = 0;
1057 	pWrkrData-&gt;batch.nmemb = 0;
1058 	if (pWrkrData-&gt;batch.restPath != NULL)  {
1059 		free(pWrkrData-&gt;batch.restPath);
1060 		pWrkrData-&gt;batch.restPath = NULL;
1061 	}
1062 }
1063 static rsRetVal
1064 buildBatch(wrkrInstanceData_t *pWrkrData, uchar *message)
1065 {
1066 	DEFiRet;
1067 	if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
1068 		LogError(0, RS_RET_ERR, "omhttp: buildBatch something has gone wrong,"
1069 			"number of messages in batch is bigger than the max batch size, bailing");
1070 		ABORT_FINALIZE(RS_RET_ERR);
1071 	}
1072 	pWrkrData-&gt;batch.data[pWrkrData-&gt;batch.nmemb] = message;
1073 	pWrkrData-&gt;batch.sizeBytes += strlen((char *)message);
1074 	pWrkrData-&gt;batch.nmemb++;
1075 finalize_it:
1076 	RETiRet;
1077 }
1078 static rsRetVal
1079 submitBatch(wrkrInstanceData_t *pWrkrData, uchar **tpls)
1080 {
1081 	DEFiRet;
1082 	char *batchBuf = NULL;
1083 	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
1084 		case FMT_JSONARRAY:
1085 			iRet = serializeBatchJsonArray(pWrkrData, &amp;batchBuf);
1086 			break;
1087 		case FMT_KAFKAREST:
1088 			iRet = serializeBatchKafkaRest(pWrkrData, &amp;batchBuf);
1089 			break;
1090 		case FMT_LOKIREST:
1091 			iRet = serializeBatchLokiRest(pWrkrData, &amp;batchBuf);
1092 			break;
1093 		case FMT_NEWLINE:
1094 			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
1095 			break;
1096 		default:
1097 			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
1098 	}
1099 	if (iRet != RS_RET_OK || batchBuf == NULL)
1100 		ABORT_FINALIZE(iRet);
1101 	DBGPRINTF("omhttp: submitBatch, batch: '%s' tpls: '%p'\n", batchBuf, tpls);
1102 	CHKiRet(curlPost(pWrkrData, (uchar*) batchBuf, strlen(batchBuf),
1103 		tpls, pWrkrData-&gt;batch.nmemb));
1104 finalize_it:
1105 	if (batchBuf != NULL)
1106 		free(batchBuf);
1107 	RETiRet;
1108 }
1109 BEGINbeginTransaction
1110 CODESTARTbeginTransaction
1111 	if(!pWrkrData-&gt;pData-&gt;batchMode) {
1112 		FINALIZE;
1113 	}
1114 	initializeBatch(pWrkrData);
1115 finalize_it:
1116 ENDbeginTransaction
1117 BEGINdoAction
1118 size_t nBytes;
1119 sbool submit;
1120 CODESTARTdoAction
1121 	instanceData *const pData = pWrkrData-&gt;pData;
1122 	uchar *restPath = NULL;
1123 	STATSCOUNTER_INC(ctrMessagesSubmitted, mutCtrMessagesSubmitted);
1124 	if (pWrkrData-&gt;pData-&gt;batchMode) {
1125 		if(pData-&gt;dynRestPath) {
1126 			getRestPath(pData, ppString, &amp;restPath);
1127 			if (pWrkrData-&gt;batch.restPath == NULL) {
1128 				pWrkrData-&gt;batch.restPath = (uchar*)strdup((char*)restPath);
1129 			} else if (strcmp((char*)pWrkrData-&gt;batch.restPath, (char*)restPath) != 0) {
1130 				CHKiRet(submitBatch(pWrkrData, NULL));
1131 				initializeBatch(pWrkrData);
1132 			}
1133 		}
1134 		if (pWrkrData-&gt;pData-&gt;maxBatchSize == 1) {
1135 			initializeBatch(pWrkrData);
1136 			CHKiRet(buildBatch(pWrkrData, ppString[0]));
1137 			CHKiRet(submitBatch(pWrkrData, ppString));
1138 			FINALIZE;
1139 		}
1140 		nBytes = ustrlen((char *)ppString[0]) - 1 ;
1141 		submit = 0;
1142 		if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
1143 			submit = 1;
1144 			DBGPRINTF("omhttp: maxbatchsize limit reached submitting batch of %zd elements.\n",
1145 				pWrkrData-&gt;batch.nmemb);
1146 		} else if (computeBatchSize(pWrkrData) + nBytes &gt; pWrkrData-&gt;pData-&gt;maxBatchBytes) {
1147 			submit = 1;
1148 			DBGPRINTF("omhttp: maxbytes limit reached submitting partial batch of %zd elements.\n",
1149 				pWrkrData-&gt;batch.nmemb);
1150 		}
1151 		if (submit) {
1152 			CHKiRet(submitBatch(pWrkrData, ppString));
1153 			initializeBatch(pWrkrData);
1154 		}
1155 		CHKiRet(buildBatch(pWrkrData, ppString[0]));
1156 		iRet = pWrkrData-&gt;batch.nmemb == 1 ? RS_RET_PREVIOUS_COMMITTED : RS_RET_DEFER_COMMIT;
1157 	} else {
1158 		CHKiRet(curlPost(pWrkrData, ppString[0], strlen((char*)ppString[0]), ppString, 1));
1159 	}
1160 finalize_it:
1161 ENDdoAction
1162 BEGINendTransaction
1163 CODESTARTendTransaction
1164 	if (pWrkrData-&gt;batch.nmemb &gt; 0) {
1165 		CHKiRet(submitBatch(pWrkrData, NULL));
1166 	} else {
1167 		dbgprintf("omhttp: endTransaction, pWrkrData-&gt;batch.nmemb = 0, "
1168 			"nothing to send. \n");
1169 	}
1170 finalize_it:
1171 ENDendTransaction
1172 static rsRetVal
1173 computeAuthHeader(char* uid, char* pwd, uchar** authBuf)
1174 {
1175 	int r;
1176 	DEFiRet;
1177 	es_str_t* auth = es_newStr(1024);
1178 	if (auth == NULL) {
1179 		LogError(0, RS_RET_OUT_OF_MEMORY,
1180 			"omhttp: failed to allocate es_str auth for auth header construction");
1181 		ABORT_FINALIZE(RS_RET_ERR);
1182 	}
1183 	r = es_addBuf(&amp;auth, uid, strlen(uid));
1184 	if(r == 0) r = es_addChar(&amp;auth, ':');
1185 	if(r == 0 &amp;&amp; pwd != NULL) r = es_addBuf(&amp;auth, pwd, strlen(pwd));
1186 	if(r == 0) *authBuf = (uchar*) es_str2cstr(auth, NULL);
1187 	if (r != 0 || *authBuf == NULL) {
1188 		LogError(0, RS_RET_ERR, "omhttp: failed to build auth header\n");
1189 		ABORT_FINALIZE(RS_RET_ERR);
1190 	}
1191 finalize_it:
1192 	if (auth != NULL)
1193 		es_deleteStr(auth);
1194 	RETiRet;
1195 }
1196 static rsRetVal
1197 computeApiHeader(char* key, char* value, uchar** headerBuf)
1198 {
1199 	int r;
1200 	DEFiRet;
1201 	es_str_t* header = es_newStr(10240);
1202 	if (header == NULL) {
1203 		LogError(0, RS_RET_OUT_OF_MEMORY,
1204 		"omhttp: failed to allocate es_str auth for api header construction");
1205 		ABORT_FINALIZE(RS_RET_ERR);
1206 	}
1207 	r = es_addBuf(&amp;header, key, strlen(key));
1208 	if(r == 0) r = es_addChar(&amp;header, ':');
1209 	if(r == 0) r = es_addChar(&amp;header, ' ');
1210 	if(r == 0 &amp;&amp; value != NULL) r = es_addBuf(&amp;header, value, strlen(value));
1211 	if(r == 0) *headerBuf = (uchar*) es_str2cstr(header, NULL);
1212 	if (r != 0 || *headerBuf == NULL) {
1213 		LogError(0, RS_RET_ERR, "omhttp: failed to build http header\n");
1214 		ABORT_FINALIZE(RS_RET_ERR);
1215 	}
1216 finalize_it:
1217 	if (header != NULL)
1218 		es_deleteStr(header);
1219 	RETiRet;
1220 }
1221 static void ATTR_NONNULL()
1222 curlSetupCommon(wrkrInstanceData_t *const pWrkrData, CURL *const handle)
1223 {
1224 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
1225 	curl_easy_setopt(handle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
1226 	curl_easy_setopt(handle, CURLOPT_NOSIGNAL, TRUE);
1227 	curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, curlResult);
1228 	curl_easy_setopt(handle, CURLOPT_WRITEDATA, pWrkrData);
1229 	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
1230 		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYPEER, FALSE);
1231 	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
1232 		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYHOST, FALSE);
1233 	if(pWrkrData-&gt;pData-&gt;authBuf != NULL) {
1234 		curl_easy_setopt(handle, CURLOPT_USERPWD, pWrkrData-&gt;pData-&gt;authBuf);
1235 		curl_easy_setopt(handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
1236 	}
1237 	if(pWrkrData-&gt;pData-&gt;caCertFile)
1238 		curl_easy_setopt(handle, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
1239 	if(pWrkrData-&gt;pData-&gt;myCertFile)
1240 		curl_easy_setopt(handle, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
1241 	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
1242 		curl_easy_setopt(handle, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
1243 }
1244 static void ATTR_NONNULL()
1245 curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData)
1246 {
1247 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
1248 	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlCheckConnHandle);
1249 	curl_easy_setopt(pWrkrData-&gt;curlCheckConnHandle,
1250 		CURLOPT_TIMEOUT_MS, pWrkrData-&gt;pData-&gt;healthCheckTimeout);
1251 }
1252 static void ATTR_NONNULL(1)
1253 curlPostSetup(wrkrInstanceData_t *const pWrkrData)
1254 {
1255 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
1256 	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlPostHandle);
1257 	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_POST, 1);
1258 	CURLcode cRet;
1259 	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPALIVE, 1L);
1260 	if (cRet != CURLE_OK)
1261 		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPALIVE\n");
1262 	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPIDLE, 120L);
1263 	if (cRet != CURLE_OK)
1264 		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPIDLE\n");
1265 	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPINTVL, 60L);
1266 	if (cRet != CURLE_OK)
1267 		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPINTVL\n");
1268 }
1269 static rsRetVal ATTR_NONNULL()
1270 curlSetup(wrkrInstanceData_t *const pWrkrData)
1271 {
1272 	struct curl_slist *slist = NULL;
1273 	DEFiRet;
1274 	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
1275 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
1276 	} else {
1277 		slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
1278 	}
1279 	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
1280 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
1281 		CHKmalloc(slist);
1282 	}
1283 	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
1284 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
1285 		CHKmalloc(slist);
1286 	}
1287 	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
1288 	pWrkrData-&gt;curlHeader = slist;
1289 	CHKmalloc(pWrkrData-&gt;curlPostHandle = curl_easy_init());
1290 	curlPostSetup(pWrkrData);
1291 	CHKmalloc(pWrkrData-&gt;curlCheckConnHandle = curl_easy_init());
1292 	curlCheckConnSetup(pWrkrData);
1293 finalize_it:
1294 	if(iRet != RS_RET_OK &amp;&amp; pWrkrData-&gt;curlPostHandle != NULL) {
1295 		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
1296 		pWrkrData-&gt;curlPostHandle = NULL;
1297 	}
1298 	RETiRet;
1299 }
1300 static void ATTR_NONNULL()
1301 curlCleanup(wrkrInstanceData_t *const pWrkrData)
1302 {
1303 	if (pWrkrData-&gt;curlHeader != NULL) {
1304 		curl_slist_free_all(pWrkrData-&gt;curlHeader);
1305 		pWrkrData-&gt;curlHeader = NULL;
1306 	}
1307 	if (pWrkrData-&gt;curlCheckConnHandle != NULL) {
1308 		curl_easy_cleanup(pWrkrData-&gt;curlCheckConnHandle);
1309 		pWrkrData-&gt;curlCheckConnHandle = NULL;
1310 	}
1311 	if (pWrkrData-&gt;curlPostHandle != NULL) {
1312 		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
1313 		pWrkrData-&gt;curlPostHandle = NULL;
1314 	}
1315 }
1316 static void ATTR_NONNULL()
1317 setInstParamDefaults(instanceData *const pData)
1318 {
1319 	pData-&gt;serverBaseUrls = NULL;
1320 	pData-&gt;defaultPort = 443;
1321 	pData-&gt;healthCheckTimeout = 3500;
1322 	pData-&gt;uid = NULL;
1323 	pData-&gt;httpcontenttype = NULL;
1324 	pData-&gt;headerContentTypeBuf = NULL;
1325 	pData-&gt;httpheaderkey = NULL;
1326 	pData-&gt;httpheadervalue = NULL;
1327 	pData-&gt;httpHeaders = NULL;
1328 	pData-&gt;nHttpHeaders = 0;
1329 	pData-&gt;pwd = NULL;
1330 	pData-&gt;authBuf = NULL;
1331 	pData-&gt;restPath = NULL;
1332 	pData-&gt;checkPath = NULL;
1333 	pData-&gt;dynRestPath = 0;
1334 	pData-&gt;batchMode = 0;
1335 	pData-&gt;batchFormatName = (uchar *)"newline";
1336 	pData-&gt;batchFormat = FMT_NEWLINE;
1337 	pData-&gt;bFreeBatchFormatName = 0;
1338 	pData-&gt;useHttps = 1;
1339 	pData-&gt;maxBatchBytes = 10485760; //i.e. 10 MB Is the default max message size for AWS API Gateway
1340 	pData-&gt;maxBatchSize = 100; 	pData-&gt;compress = 0; 	pData-&gt;compressionLevel = -1; 	pData-&gt;allowUnsignedCerts = 0;
1341 	pData-&gt;skipVerifyHost = 0;
1342 	pData-&gt;tplName = NULL;
1343 	pData-&gt;errorFile = NULL;
1344 	pData-&gt;caCertFile = NULL;
1345 	pData-&gt;myCertFile = NULL;
1346 	pData-&gt;myPrivKeyFile = NULL;
1347 	pData-&gt;reloadOnHup= 0;
1348 	pData-&gt;retryFailures = 0;
1349 	pData-&gt;ratelimitBurst = 20000;
1350 	pData-&gt;ratelimitInterval = 600;
1351 	pData-&gt;ratelimiter = NULL;
1352 	pData-&gt;retryRulesetName = NULL;
1353 	pData-&gt;retryRuleset = NULL;
1354 }
1355 static rsRetVal
1356 checkHeaderParam(char *const param)
1357 {
1358 	DEFiRet;
1359 	char *val = strstr(param, ":");
1360 	if(val == NULL) {
1361 		LogError(0, RS_RET_PARAM_ERROR, "missing ':' delimiter in "
1362 				"parameter '%s'", param);
1363 		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
1364 	}
1365 finalize_it:
1366 	RETiRet;
1367 }
1368 BEGINnewActInst
1369 	struct cnfparamvals *pvals;
1370 	char* serverParam = NULL;
1371 	struct cnfarray* servers = NULL;
1372 	int i;
1373 	int iNumTpls;
1374 	FILE *fp;
1375 	char errStr[1024];
1376 	char *batchFormatName;
1377 	int compressionLevel = -1;
1378 CODESTARTnewActInst
1379 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
1380 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1381 	}
1382 	CHKiRet(createInstance(&amp;pData));
1383 	setInstParamDefaults(pData);
1384 <a name="10"></a>	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
1385 		if(!pvals[i].bUsed)
1386 			continue;
1387 <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		if(!strcmp(actpblk.descr[i].name, "server")) {
1388 			servers = pvals[i].val.d.ar;
1389 		} else if(!strcmp(actpblk.descr[i].name, "errorfile")) {
1390 			pData-&gt;errorFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1391 		} else if(!strcmp(actpblk.descr[i].name, "serverport")) {</b></font>
1392 <a name="2"></a>			pData-&gt;defaultPort = (int) pvals[i].val.d.n;
1393 		} else if(!strcmp(actpblk.descr[i].name, "healthchecktimeout")) {
1394 			pData-&gt;healthCheckTimeout = (long) pvals[i].val.d.n;
1395 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "uid")) {
1396 			pData-&gt;uid = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1397 		} else if(!strcmp(actpblk.descr[i].name, "httpcontenttype")) {
1398 			pData-&gt;httpcontenttype = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1399 		} else if(!strcmp(actpblk.descr[i].name, "httpheaderkey")) {
1400 			pData-&gt;httpheaderkey = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1401 		} else if(!strcmp(actpblk.descr[i].name, "httpheadervalue")) {
1402 			pData-&gt;httpheadervalue = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1403 		} else if(!strcmp(actpblk.descr[i].name, "httpheaders")) {
1404 			pData-&gt;nHttpHeaders = pvals[i].val.d.ar-&gt;nmemb;
1405 			CHKmalloc(pData-&gt;httpHeaders = malloc(sizeof(uchar *) * pvals[i].val.d.ar-&gt;nmemb ));
1406 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
1407 				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
1408 				CHKiRet(checkHeaderParam(cstr));
1409 <a name="9"></a>				pData-&gt;httpHeaders[j] = (uchar *)cstr;
1410 			}
1411 		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
1412 <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1413 		} else if(!strcmp(actpblk.descr[i].name, "restpath")) {
1414 			pData-&gt;restPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1415 <a name="11"></a>		} else if(!strcmp(actpblk.descr[i].name, "checkpath")) {
1416 			pData-&gt;checkPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1417 		} else if(!strcmp(actpblk.descr[i].name, "dynrestpath")) {
1418 <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			pData-&gt;dynRestPath = pvals[i].val.d.n;
1419 		} else if(!strcmp(actpblk.descr[i].name, "batch")) {
1420 			pData-&gt;batchMode = pvals[i].val.d.n;
1421 		} else if(!strcmp(actpblk.descr[i].name, "batch.format")) {
1422 			batchFormatName = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1423 <a name="6"></a>			if (strstr(VALID_BATCH_FORMATS, batchFormatName) != NULL) {
1424 				pData-&gt;batchFormatName = (uchar *)batchFormatName;
1425 				pData-&gt;bFreeBatchFormatName = 1;
1426 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>				if (!strcmp(batchFormatName, "newline")) {
1427 					pData-&gt;batchFormat = FMT_NEWLINE;
1428 				} else if (!strcmp(batchFormatName, "jsonarray")) {
1429 					pData-&gt;batchFormat = FMT_JSONARRAY;
1430 				} else if (!strcmp(batchFormatName, "kafkarest")) {
1431 					pData-&gt;batchFormat = FMT_KAFKAREST;
1432 				} else if (!strcmp(batchFormatName, "lokirest")) {
1433 					pData-&gt;batchFormat = FMT_LOKIREST;
1434 				}</b></font>
1435 <a name="5"></a>			} else {
1436 				LogError(0, NO_ERRCODE, "error: 'batch.format' %s unknown defaulting to 'newline'",
1437 					batchFormatName);
1438 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			}
1439 		} else if(!strcmp(actpblk.descr[i].name, "batch.maxbytes")) {
1440 			pData-&gt;maxBatchBytes = (size_t) pvals[i].val.d.n;
1441 		} else if(!strcmp(actpblk.descr[i].name, "batch.maxsize")) {
1442 			pData-&gt;maxBatchSize = (size_t) pvals[i].val.d.n;
1443 		} else if(!strcmp(actpblk.descr[i].name, "compress")) {
1444 			pData-&gt;compress = pvals[i].val.d.n;
1445 		} else if(!strcmp(actpblk.descr[i].name, "compress.level")) {
1446 			compressionLevel = pvals[i].val.d.n;</b></font>
1447 			if (compressionLevel == -1 || (compressionLevel &gt;= 0 &amp;&amp; compressionLevel &lt; 10)) {
1448 				pData-&gt;compressionLevel = compressionLevel;
1449 			} else {
1450 				LogError(0, NO_ERRCODE, "omhttp: invalid compress.level %d using default instead,"
1451 					"valid levels are -1 and 0-9",
1452 					compressionLevel);
1453 <a name="1"></a>			}
1454 		} else if(!strcmp(actpblk.descr[i].name, "allowunsignedcerts")) {
1455 			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
1456 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "skipverifyhost")) {
1457 			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
1458 		} else if(!strcmp(actpblk.descr[i].name, "usehttps")) {
1459 			pData-&gt;useHttps = pvals[i].val.d.n;
1460 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
1461 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1462 		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
1463 			pData-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1464 			fp = fopen((const char*)pData-&gt;caCertFile, "r");
1465 			if(fp == NULL) {
1466 				rs_strerror_r(errno, errStr, sizeof(errStr));</b></font>
1467 				LogError(0, RS_RET_NO_FILE_ACCESS,
1468 						"error: 'tls.cacert' file %s couldn't be accessed: %s\n",
1469 <a name="8"></a>						pData-&gt;caCertFile, errStr);
1470 			} else {
1471 				fclose(fp);
1472 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			}
1473 		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
1474 			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1475 			fp = fopen((const char*)pData-&gt;myCertFile, "r");
1476 			if(fp == NULL) {
1477 				rs_strerror_r(errno, errStr, sizeof(errStr));</b></font>
1478 				LogError(0, RS_RET_NO_FILE_ACCESS,
1479 						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
1480 <a name="7"></a>						pData-&gt;myCertFile, errStr);
1481 			} else {
1482 				fclose(fp);
1483 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			}
1484 		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
1485 			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1486 			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
1487 			if(fp == NULL) {
1488 				rs_strerror_r(errno, errStr, sizeof(errStr));</b></font>
1489 				LogError(0, RS_RET_NO_FILE_ACCESS,
1490 						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
1491 <a name="4"></a>						pData-&gt;myPrivKeyFile, errStr);
1492 			} else {
1493 				fclose(fp);
1494 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			}
1495 		} else if(!strcmp(actpblk.descr[i].name, "reloadonhup")) {
1496 			pData-&gt;reloadOnHup= pvals[i].val.d.n;
1497 		} else if(!strcmp(actpblk.descr[i].name, "retry")) {
1498 			pData-&gt;retryFailures = pvals[i].val.d.n;
1499 		} else if(!strcmp(actpblk.descr[i].name, "retry.ruleset")) {
1500 			pData-&gt;retryRulesetName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1501 		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.burst")) {
1502 			pData-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;</b></font>
1503 		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.interval")) {
1504 			pData-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
1505 		} else {
1506 			LogError(0, RS_RET_INTERNAL_ERROR, "omhttp: program error, "
1507 				"non-handled param '%s'", actpblk.descr[i].name);
1508 		}
1509 	}
1510 	if(pData-&gt;pwd != NULL &amp;&amp; pData-&gt;uid == NULL) {
1511 		LogError(0, RS_RET_UID_MISSING,
1512 			"omhttp: password is provided, but no uid "
1513 			"- action definition invalid");
1514 		ABORT_FINALIZE(RS_RET_UID_MISSING);
1515 	}
1516 	if(pData-&gt;httpheaderkey != NULL &amp;&amp; pData-&gt;httpheadervalue == NULL) {
1517 		LogError(0, RS_RET_UID_MISSING,
1518 			"omhttp: http header key is provided, but no http header value "
1519 			"- action definition invalid");
1520 		ABORT_FINALIZE(RS_RET_UID_MISSING);
1521 	}
1522 	if(pData-&gt;dynRestPath &amp;&amp; pData-&gt;restPath == NULL) {
1523 		LogError(0, RS_RET_CONFIG_ERROR,
1524 			"omhttp: requested dynamic rest path, but no name for rest "
1525 			"path template given - action definition invalid");
1526 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1527 	}
1528 	if (pData-&gt;uid != NULL)
1529 		CHKiRet(computeAuthHeader((char*) pData-&gt;uid, (char*) pData-&gt;pwd, &amp;pData-&gt;authBuf));
1530 	if (pData-&gt;httpcontenttype != NULL)
1531 		CHKiRet(computeApiHeader((char*) "Content-Type",
1532 				(char*) pData-&gt;httpcontenttype, &amp;pData-&gt;headerContentTypeBuf));
1533 	if (pData-&gt;httpheaderkey != NULL)
1534 		CHKiRet(computeApiHeader((char*) pData-&gt;httpheaderkey,
1535 				(char*) pData-&gt;httpheadervalue, &amp;pData-&gt;headerBuf));
1536 	iNumTpls = 1;
1537 	if(pData-&gt;dynRestPath) ++iNumTpls;
1538 	DBGPRINTF("omhttp: requesting %d templates\n", iNumTpls);
1539 	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
1540 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
1541 					    " StdJSONFmt" : (char*)pData-&gt;tplName),
1542 		OMSR_NO_RQD_TPL_OPTS));
1543 	iNumTpls = 1;
1544 	if(pData-&gt;dynRestPath) {
1545 		CHKiRet(OMSRsetEntry(*ppOMSR, iNumTpls, ustrdup(pData-&gt;restPath),
1546 			OMSR_NO_RQD_TPL_OPTS));
1547 		++iNumTpls;
1548 	}
1549 	if (servers != NULL) {
1550 		pData-&gt;numServers = servers-&gt;nmemb;
1551 		pData-&gt;serverBaseUrls = malloc(servers-&gt;nmemb * sizeof(uchar*));
1552 		if (pData-&gt;serverBaseUrls == NULL) {
1553 			LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
1554 					"for http server configuration.");
1555 			ABORT_FINALIZE(RS_RET_ERR);
1556 		}
1557 		for(i = 0 ; i &lt; servers-&gt;nmemb ; ++i) {
1558 			serverParam = es_str2cstr(servers-&gt;arr[i], NULL);
1559 			if (serverParam == NULL) {
1560 				LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
1561 					"for http server configuration.");
1562 				ABORT_FINALIZE(RS_RET_ERR);
1563 			}
1564 			const size_t serverParamLastChar = strlen(serverParam)-1;
1565 			if (serverParam[serverParamLastChar] == '/') {
1566 				serverParam[serverParamLastChar] = '\0';
1567 			}
1568 			CHKiRet(computeBaseUrl(serverParam, pData-&gt;defaultPort, pData-&gt;useHttps,
1569 				pData-&gt;serverBaseUrls + i));
1570 			free(serverParam);
1571 			serverParam = NULL;
1572 		}
1573 	} else {
1574 		LogMsg(0, RS_RET_OK, LOG_WARNING,
1575 			"omhttp: No servers specified, using localhost");
1576 		pData-&gt;numServers = 1;
1577 		pData-&gt;serverBaseUrls = malloc(sizeof(uchar*));
1578 		if (pData-&gt;serverBaseUrls == NULL) {
1579 			LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
1580 					"for http server configuration.");
1581 			ABORT_FINALIZE(RS_RET_ERR);
1582 		}
1583 		CHKiRet(computeBaseUrl("localhost", pData-&gt;defaultPort, pData-&gt;useHttps, pData-&gt;serverBaseUrls));
1584 	}
1585 	if (pData-&gt;retryFailures) {
1586 		CHKiRet(ratelimitNew(&amp;pData-&gt;ratelimiter, "omhttp", NULL));
1587 		ratelimitSetLinuxLike(pData-&gt;ratelimiter, pData-&gt;ratelimitInterval, pData-&gt;ratelimitBurst);
1588 		ratelimitSetNoTimeCache(pData-&gt;ratelimiter);
1589 	}
1590 	if(loadModConf-&gt;tail == NULL) {
1591 		loadModConf-&gt;tail = loadModConf-&gt;root = pData;
1592 	} else {
1593 		loadModConf-&gt;tail-&gt;next = pData;
1594 		loadModConf-&gt;tail = pData;
1595 	}
1596 CODE_STD_FINALIZERnewActInst
1597 	cnfparamvalsDestruct(pvals, &amp;actpblk);
1598 	if (serverParam)
1599 		free(serverParam);
1600 ENDnewActInst
1601 BEGINbeginCnfLoad
1602 CODESTARTbeginCnfLoad
1603 	loadModConf = pModConf;
1604 	pModConf-&gt;pConf = pConf;
1605 	pModConf-&gt;root = pModConf-&gt;tail = NULL;
1606 ENDbeginCnfLoad
1607 BEGINendCnfLoad
1608 CODESTARTendCnfLoad
1609 	loadModConf = NULL; ENDendCnfLoad
1610 BEGINcheckCnf
1611 	instanceConf_t *inst;
1612 CODESTARTcheckCnf
1613 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1614 		ruleset_t *pRuleset;
1615 		rsRetVal localRet;
1616 		if (inst-&gt;retryRulesetName) {
1617 			localRet = ruleset.GetRuleset(pModConf-&gt;pConf, &amp;pRuleset, inst-&gt;retryRulesetName);
1618 			if(localRet == RS_RET_NOT_FOUND) {
1619 				LogError(0, localRet, "omhttp: retry.ruleset '%s' not found - "
1620 						"no retry ruleset will be used", inst-&gt;retryRulesetName);
1621 			} else {
1622 				inst-&gt;retryRuleset = pRuleset;
1623 			}
1624 		}
1625 	}
1626 ENDcheckCnf
1627 BEGINactivateCnf
1628 CODESTARTactivateCnf
1629 ENDactivateCnf
1630 BEGINfreeCnf
1631 CODESTARTfreeCnf
1632 ENDfreeCnf
1633 BEGINdoHUP
1634 CODESTARTdoHUP
1635 	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
1636 	if (pData-&gt;fdErrFile != -1) {
1637 		close(pData-&gt;fdErrFile);
1638 		pData-&gt;fdErrFile = -1;
1639 	}
1640 	pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
1641 ENDdoHUP
1642 BEGINdoHUPWrkr
1643 CODESTARTdoHUPWrkr
1644 	if (pWrkrData-&gt;pData-&gt;reloadOnHup) {
1645 		LogMsg(0, NO_ERRCODE, LOG_INFO, "omhttp: received HUP reloading curl handles");
1646 		curlCleanup(pWrkrData);
1647 		CHKiRet(curlSetup(pWrkrData));
1648 	}
1649 finalize_it:
1650 ENDdoHUPWrkr
1651 BEGINmodExit
1652 CODESTARTmodExit
1653 	if(pInputName != NULL)
1654 		prop.Destruct(&amp;pInputName);
1655 	curl_global_cleanup();
1656 	objRelease(prop, CORE_COMPONENT);
1657 	objRelease(ruleset, CORE_COMPONENT);
1658 	objRelease(statsobj, CORE_COMPONENT);
1659 	statsobj.Destruct(&amp;httpStats);
1660 ENDmodExit
1661 NO_LEGACY_CONF_parseSelectorAct
1662 BEGINqueryEtryPt
1663 CODESTARTqueryEtryPt
1664 CODEqueryEtryPt_STD_OMOD_QUERIES
1665 CODEqueryEtryPt_STD_OMOD8_QUERIES
1666 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
1667 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1668 CODEqueryEtryPt_doHUP
1669 CODEqueryEtryPt_doHUPWrkr CODEqueryEtryPt_TXIF_OMOD_QUERIES CODEqueryEtryPt_STD_CONF2_QUERIES
1670 ENDqueryEtryPt
1671 BEGINmodInit()
1672 CODESTARTmodInit
1673 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1674 	CHKiRet(objUse(prop, CORE_COMPONENT));
1675 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
1676 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1677 	CHKiRet(statsobj.Construct(&amp;httpStats));
1678 	CHKiRet(statsobj.SetName(httpStats, (uchar *)"omhttp"));
1679 	CHKiRet(statsobj.SetOrigin(httpStats, (uchar*)"omhttp"));
1680 	STATSCOUNTER_INIT(ctrMessagesSubmitted, mutCtrMessagesSubmitted);
1681 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.submitted",
1682 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSubmitted));
1683 	STATSCOUNTER_INIT(ctrMessagesSuccess, mutCtrMessagesSuccess);
1684 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.success",
1685 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSuccess));
1686 	STATSCOUNTER_INIT(ctrMessagesFail, mutCtrMessagesFail);
1687 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.fail",
1688 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesFail));
1689 	STATSCOUNTER_INIT(ctrMessagesRetry, mutCtrMessagesRetry);
1690 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.retry",
1691 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesRetry));
1692 	STATSCOUNTER_INIT(ctrHttpRequestCount, mutCtrHttpRequestCount);
1693 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.count",
1694 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestCount));
1695 	STATSCOUNTER_INIT(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
1696 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.success",
1697 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestSuccess));
1698 	STATSCOUNTER_INIT(ctrHttpRequestFail, mutCtrHttpRequestFail);
1699 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.fail",
1700 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestFail));
1701 	STATSCOUNTER_INIT(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
1702 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.status.success",
1703 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusSuccess));
1704 	STATSCOUNTER_INIT(ctrHttpStatusFail, mutCtrHttpStatusFail);
1705 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.status.fail",
1706 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusFail));
1707 	CHKiRet(statsobj.ConstructFinalize(httpStats));
1708 	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
1709 		LogError(0, RS_RET_OBJ_CREATION_FAILED, "CURL fail. -http disabled");
1710 		ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
1711 	}
1712 	CHKiRet(prop.Construct(&amp;pInputName));
1713 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("omhttp"), sizeof("omhttp") - 1));
1714 	CHKiRet(prop.ConstructFinalize(pInputName));
1715 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmkubernetes.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef _GNU_SOURCE
2 #  define _GNU_SOURCE
3 #endif
4 #include "config.h"
5 #include "rsyslog.h"
6 #include &lt;stdio.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;stdlib.h&gt;
9 #include &lt;string.h&gt;
10 #include &lt;assert.h&gt;
11 #include &lt;errno.h&gt;
12 #include &lt;unistd.h&gt;
13 #include &lt;sys/stat.h&gt;
14 #include &lt;libestr.h&gt;
15 #include &lt;liblognorm.h&gt;
16 #include &lt;json.h&gt;
17 #include &lt;curl/curl.h&gt;
18 #include &lt;curl/easy.h&gt;
19 #include &lt;pthread.h&gt;
20 #include "conf.h"
21 #include "syslogd-types.h"
22 #include "module-template.h"
23 #include "errmsg.h"
24 #include "statsobj.h"
25 #include "regexp.h"
26 #include "hashtable.h"
27 #include "hashtable_itr.h"
28 #include "srUtils.h"
29 #include "unicode-helper.h"
30 #include "datetime.h"
31 MODULE_TYPE_OUTPUT MODULE_TYPE_KEEP MODULE_CNFNAME("mmkubernetes")
32 DEF_OMOD_STATIC_DATA
33 DEFobjCurrIf(regexp)
34 DEFobjCurrIf(statsobj)
35 DEFobjCurrIf(datetime)
36 #define HAVE_LOADSAMPLESFROMSTRING 1
37 #if defined(NO_LOADSAMPLESFROMSTRING)
38 #undef HAVE_LOADSAMPLESFROMSTRING
39 #endif
40 #define DFLT_FILENAME_LNRULES "rule=:/var/log/containers/%pod_name:char-to:_%_"\
41 	"%namespace_name:char-to:_%_%container_name_and_id:char-to:.%.log"
42 #define DFLT_FILENAME_RULEBASE "/etc/rsyslog.d/k8s_filename.rulebase"
43 #define DFLT_CONTAINER_LNRULES "rule=:%k8s_prefix:char-to:_%_%container_name:char-to:.%."\
44 	"%container_hash:char-to:_%_"\
45 	"%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%\n"\
46 	"rule=:%k8s_prefix:char-to:_%_%container_name:char-to:_%_"\
47 	"%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%"
48 #define DFLT_CONTAINER_RULEBASE "/etc/rsyslog.d/k8s_container_name.rulebase"
49 #define DFLT_SRCMD_PATH "$!metadata!filename"
50 #define DFLT_DSTMD_PATH "$!"
51 #define DFLT_DE_DOT 1 #define DFLT_DE_DOT_SEPARATOR "_"
52 #define DFLT_CONTAINER_NAME "$!CONTAINER_NAME" #define DFLT_CONTAINER_ID_FULL "$!CONTAINER_ID_FULL" #define DFLT_KUBERNETES_URL "https://kubernetes.default.svc.cluster.local:443"
53 #if defined(ENABLE_OPENSSL) &amp;&amp; defined(X509_V_FLAG_PARTIAL_CHAIN)
54 #define SUPPORT_SSL_PARTIAL_CHAIN 1
55 #endif
56 struct cache_entry_s {
57 	time_t ttl; 	void *data; };
58 static struct cache_s {
59 	const uchar *kbUrl;
60 	struct hashtable *mdHt;
61 	struct hashtable *nsHt;
62 	pthread_mutex_t *cacheMtx;
63 	int lastBusyTime; 	time_t expirationTime; } **caches;
64 typedef struct {
65 	int nmemb;
66 	uchar **patterns;
67 	regex_t *regexps;
68 } annotation_match_t;
69 struct modConfData_s {
70 	rsconf_t *pConf;		uchar *kubernetesUrl;		uchar *srcMetadataPath;		uchar *dstMetadataPath;		uchar *caCertFile; 	uchar *myCertFile; 	uchar *myPrivKeyFile; 	sbool allowUnsignedCerts; 	sbool skipVerifyHost; 	uchar *token; 	uchar *tokenFile; 	sbool de_dot; 	uchar *de_dot_separator; 	size_t de_dot_separator_len; 	annotation_match_t annotation_match; 	char *fnRules; 	uchar *fnRulebase; 	char *contRules; 	uchar *contRulebase; 	int busyRetryInterval; 	sbool sslPartialChain; 	int cacheEntryTTL; 	int cacheExpireInterval; };
71 typedef struct _instanceData {
72 	msgPropDescr_t *contNameDescr; 	msgPropDescr_t *contIdFullDescr; 	struct cache_s *cache;
73 	int busyRetryInterval; 	sbool sslPartialChain; 	int cacheEntryTTL; 	int cacheExpireInterval; } instanceData;
74 typedef struct wrkrInstanceData {
75 	instanceData *pData;
76 	CURL *curlCtx;
77 	struct curl_slist *curlHdr;
78 	char *curlRply;
79 	size_t curlRplyLen;
80 	statsobj_t *stats; 	STATSCOUNTER_DEF(k8sRecordSeen, mutK8sRecordSeen);
81 	STATSCOUNTER_DEF(namespaceMetadataSuccess, mutNamespaceMetadataSuccess);
82 	STATSCOUNTER_DEF(namespaceMetadataNotFound, mutNamespaceMetadataNotFound);
83 	STATSCOUNTER_DEF(namespaceMetadataBusy, mutNamespaceMetadataBusy);
84 	STATSCOUNTER_DEF(namespaceMetadataError, mutNamespaceMetadataError);
85 	STATSCOUNTER_DEF(podMetadataSuccess, mutPodMetadataSuccess);
86 	STATSCOUNTER_DEF(podMetadataNotFound, mutPodMetadataNotFound);
87 	STATSCOUNTER_DEF(podMetadataBusy, mutPodMetadataBusy);
88 	STATSCOUNTER_DEF(podMetadataError, mutPodMetadataError);
89 	STATSCOUNTER_DEF(podCacheNumEntries, mutPodCacheNumEntries);
90 	STATSCOUNTER_DEF(namespaceCacheNumEntries, mutNamespaceCacheNumEntries);
91 	STATSCOUNTER_DEF(podCacheHits, mutPodCacheHits);
92 	STATSCOUNTER_DEF(namespaceCacheHits, mutNamespaceCacheHits);
93 	STATSCOUNTER_DEF(podCacheMisses, mutPodCacheMisses);
94 	STATSCOUNTER_DEF(namespaceCacheMisses, mutNamespaceCacheMisses);
95 } wrkrInstanceData_t;
96 <a name="0"></a>
97 static struct cnfparamdescr modpdescr[] = {
98 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "kubernetesurl", eCmdHdlrString, 0 },
99 	{ "srcmetadatapath", eCmdHdlrString, 0 },
100 	{ "dstmetadatapath", eCmdHdlrString, 0 },
101 	{ "tls.cacert", eCmdHdlrString, 0 },
102 	{ "tls.mycert", eCmdHdlrString, 0 },
103 	{ "tls.myprivkey", eCmdHdlrString, 0 },
104 	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
105 	{ "skipverifyhost", eCmdHdlrBinary, 0 },
106 	{ "token", eCmdHdlrString, 0 },
107 	{ "tokenfile", eCmdHdlrString, 0 },
108 	{ "annotation_match", eCmdHdlrArray, 0 },
109 	{ "de_dot", eCmdHdlrBinary, 0 },
110 	{ "de_dot_separator", eCmdHdlrString, 0 },
111 	{ "filenamerulebase", eCmdHdlrString, 0 },
112 	{ "containerrulebase", eCmdHdlrString, 0 },
113 	{ "busyretryinterval", eCmdHdlrInt, 0 },
114 	{ "sslpartialchain", eCmdHdlrBinary, 0 },
115 	{ "cacheentryttl", eCmdHdlrInt, 0 },
116 	{ "cacheexpireinterval", eCmdHdlrInt, 0 }
117 #if HAVE_LOADSAMPLESFROMSTRING == 1
118 	,
119 	{ "filenamerules", eCmdHdlrArray, 0 },
120 	{ "containerrules", eCmdHdlrArray, 0 }
121 #endif
122 };
123 static struct cnfparamblk modpblk = {
124 	CNFPARAMBLK_VERSION,
125 	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
126 	modpdescr
127 <a name="3"></a>};
128 static struct cnfparamdescr actpdescr[] = {</b></font><font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>
129 	{ "kubernetesurl", eCmdHdlrString, 0 },
130 	{ "srcmetadatapath", eCmdHdlrString, 0 },
131 	{ "dstmetadatapath", eCmdHdlrString, 0 },
132 	{ "tls.cacert", eCmdHdlrString, 0 },
133 	{ "tls.mycert", eCmdHdlrString, 0 },
134 	{ "tls.myprivkey", eCmdHdlrString, 0 },
135 	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
136 	{ "skipverifyhost", eCmdHdlrBinary, 0 },
137 	{ "token", eCmdHdlrString, 0 },
138 	{ "tokenfile", eCmdHdlrString, 0 },</b></font>
139 	{ "annotation_match", eCmdHdlrArray, 0 },
140 	{ "de_dot", eCmdHdlrBinary, 0 },
141 	{ "de_dot_separator", eCmdHdlrString, 0 },
142 	{ "filenamerulebase", eCmdHdlrString, 0 },
143 	{ "containerrulebase", eCmdHdlrString, 0 },
144 	{ "busyretryinterval", eCmdHdlrInt, 0 },
145 	{ "sslpartialchain", eCmdHdlrBinary, 0 },
146 	{ "cacheentryttl", eCmdHdlrInt, 0 },
147 	{ "cacheexpireinterval", eCmdHdlrInt, 0 }
148 #if HAVE_LOADSAMPLESFROMSTRING == 1
149 	,
150 	{ "filenamerules", eCmdHdlrArray, 0 },
151 	{ "containerrules", eCmdHdlrArray, 0 }
152 #endif
153 };
154 static struct cnfparamblk actpblk =
155 	{ CNFPARAMBLK_VERSION,
156 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
157 	  actpdescr
158 	};
159 static modConfData_t *loadModConf = NULL;	static modConfData_t *runModConf = NULL;	
160 static void free_annotationmatch(annotation_match_t *match) {
161 	if (match) {
162 		for(int ii = 0 ; ii &lt; match-&gt;nmemb; ++ii) {
163 			if (match-&gt;patterns)
164 				free(match-&gt;patterns[ii]);
165 			if (match-&gt;regexps)
166 				regexp.regfree(&amp;match-&gt;regexps[ii]);
167 		}
168 		free(match-&gt;patterns);
169 		match-&gt;patterns = NULL;
170 		free(match-&gt;regexps);
171 		match-&gt;regexps = NULL;
172 		match-&gt;nmemb = 0;
173 	}
174 }
175 static int init_annotationmatch(annotation_match_t *match, struct cnfarray *ar) {
176 	DEFiRet;
177 	match-&gt;nmemb = ar-&gt;nmemb;
178 	CHKmalloc(match-&gt;patterns = calloc(sizeof(uchar*), match-&gt;nmemb));
179 	CHKmalloc(match-&gt;regexps = calloc(sizeof(regex_t), match-&gt;nmemb));
180 	for(int jj = 0; jj &lt; ar-&gt;nmemb; ++jj) {
181 		int rexret = 0;
182 		match-&gt;patterns[jj] = (uchar*)es_str2cstr(ar-&gt;arr[jj], NULL);
183 		rexret = regexp.regcomp(&amp;match-&gt;regexps[jj],
184 				(char *)match-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
185 		if (0 != rexret) {
186 			char errMsg[512];
187 			regexp.regerror(rexret, &amp;match-&gt;regexps[jj], errMsg, sizeof(errMsg));
188 			iRet = RS_RET_CONFIG_ERROR;
189 			LogError(0, iRet,
190 					"error: could not compile annotation_match string [%s]"
191 					" into an extended regexp - %d: %s\n",
192 					match-&gt;patterns[jj], rexret, errMsg);
193 			break;
194 		}
195 	}
196 finalize_it:
197 	if (iRet)
198 		free_annotationmatch(match);
199 	RETiRet;
200 }
201 static int copy_annotationmatch(annotation_match_t *src, annotation_match_t *dest) {
202 	DEFiRet;
203 	dest-&gt;nmemb = src-&gt;nmemb;
204 	CHKmalloc(dest-&gt;patterns = malloc(sizeof(uchar*) * dest-&gt;nmemb));
205 	CHKmalloc(dest-&gt;regexps = calloc(sizeof(regex_t), dest-&gt;nmemb));
206 	for(int jj = 0 ; jj &lt; src-&gt;nmemb ; ++jj) {
207 		CHKmalloc(dest-&gt;patterns[jj] = (uchar*)strdup((char *)src-&gt;patterns[jj]));
208 		regexp.regcomp(&amp;dest-&gt;regexps[jj], (char *)dest-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
209 	}
210 finalize_it:
211 	if (iRet)
212 	free_annotationmatch(dest);
213 	RETiRet;
214 }
215 static struct json_object *match_annotations(annotation_match_t *match,
216 		struct json_object *annotations) {
217 	struct json_object *ret = NULL;
218 	for (int jj = 0; jj &lt; match-&gt;nmemb; ++jj) {
219 		struct json_object_iterator it = json_object_iter_begin(annotations);
220 		struct json_object_iterator itEnd = json_object_iter_end(annotations);
221 		for (;!json_object_iter_equal(&amp;it, &amp;itEnd); json_object_iter_next(&amp;it)) {
222 			const char *const key = json_object_iter_peek_name(&amp;it);
223 			if (!ret || !fjson_object_object_get_ex(ret, key, NULL)) {
224 				if (!regexp.regexec(&amp;match-&gt;regexps[jj], key, 0, NULL, 0)) {
225 					if (!ret) {
226 						ret = json_object_new_object();
227 					}
228 					json_object_object_add(ret, key,
229 						json_object_get(json_object_iter_peek_value(&amp;it)));
230 				}
231 			}
232 		}
233 	}
234 	return ret;
235 }
236 static struct json_object *de_dot_json_object(struct json_object *jobj,
237 		const char *delim, size_t delim_len) {
238 	struct json_object *ret = NULL;
239 	struct json_object_iterator it = json_object_iter_begin(jobj);
240 	struct json_object_iterator itEnd = json_object_iter_end(jobj);
241 	es_str_t *new_es_key = NULL;
242 	DEFiRet;
243 	ret = json_object_new_object();
244 	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
245 		const char *const key = json_object_iter_peek_name(&amp;it);
246 		const char *cc = strstr(key, ".");
247 		if (NULL == cc) {
248 			json_object_object_add(ret, key,
249 					json_object_get(json_object_iter_peek_value(&amp;it)));
250 		} else {
251 			char *new_key = NULL;
252 			const char *prevcc = key;
253 			new_es_key = es_newStrFromCStr(key, (es_size_t)(cc-prevcc));
254 			while (cc) {
255 				if (es_addBuf(&amp;new_es_key, (char *)delim, (es_size_t)delim_len))
256 					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
257 				cc += 1; 				prevcc = cc; 				if ((cc = strstr(prevcc, ".")) || (cc = strchr(prevcc, '\0'))) {
258 					if (es_addBuf(&amp;new_es_key, (char *)prevcc, (es_size_t)(cc-prevcc)))
259 						ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
260 					if (!*cc)
261 						cc = NULL; 				}
262 			}
263 			new_key = es_str2cstr(new_es_key, NULL);
264 			es_deleteStr(new_es_key);
265 			new_es_key = NULL;
266 			json_object_object_add(ret, new_key,
267 					json_object_get(json_object_iter_peek_value(&amp;it)));
268 			free(new_key);
269 		}
270 		json_object_iter_next(&amp;it);
271 	}
272 finalize_it:
273 	if (iRet != RS_RET_OK) {
274 		json_object_put(ret);
275 		ret = NULL;
276 	}
277 	if (new_es_key)
278 		es_deleteStr(new_es_key);
279 	return ret;
280 }
281 static void parse_labels_annotations(struct json_object *jMetadata,
282 		annotation_match_t *match, sbool de_dot,
283 		const char *delim, size_t delim_len) {
284 	struct json_object *jo = NULL;
285 	if (fjson_object_object_get_ex(jMetadata, "annotations", &amp;jo)) {
286 		if ((jo = match_annotations(match, jo)))
287 			json_object_object_add(jMetadata, "annotations", jo);
288 		else
289 			json_object_object_del(jMetadata, "annotations");
290 	}
291 	if (de_dot) {
292 		struct json_object *jo2 = NULL;
293 		if (fjson_object_object_get_ex(jMetadata, "annotations", &amp;jo)) {
294 			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
295 				json_object_object_add(jMetadata, "annotations", jo2);
296 			}
297 		}
298 		if (fjson_object_object_get_ex(jMetadata, "labels", &amp;jo)) {
299 			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
300 				json_object_object_add(jMetadata, "labels", jo2);
301 			}
302 		}
303 	}
304 }
305 #if HAVE_LOADSAMPLESFROMSTRING == 1
306 static int array_to_rules(struct cnfarray *ar, char **rules) {
307 	DEFiRet;
308 	es_str_t *tmpstr = NULL;
309 	es_size_t size = 0;
310 	if (rules == NULL)
311 		FINALIZE;
312 	*rules = NULL;
313 	if (!ar-&gt;nmemb)
314 		FINALIZE;
315 	for (int jj = 0; jj &lt; ar-&gt;nmemb; jj++)
316 		size += es_strlen(ar-&gt;arr[jj]);
317 	if (!size)
318 		FINALIZE;
319 	CHKmalloc(tmpstr = es_newStr(size));
320 	CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[0])));
321 	CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\n")));
322 	for(int jj=1; jj &lt; ar-&gt;nmemb; ++jj) {
323 		CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[jj])));
324 		CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\n")));
325 	}
326 	CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\0")));
327 	CHKmalloc(*rules = es_str2cstr(tmpstr, NULL));
328 finalize_it:
329 	if (tmpstr) {
330 		es_deleteStr(tmpstr);
331 	}
332 	if (iRet != RS_RET_OK) {
333 		free(*rules);
334 		*rules = NULL;
335 	}
336 	RETiRet;
337 }
338 #endif
339 static void
340 errCallBack(void __attribute__((unused)) *cookie, const char *msg,
341 	    size_t __attribute__((unused)) lenMsg)
342 {
343 	LogError(0, RS_RET_ERR_LIBLOGNORM, "liblognorm error: %s", msg);
344 }
345 static rsRetVal
346 set_lnctx(ln_ctx *ctxln, char *instRules, uchar *instRulebase, char *modRules, uchar *modRulebase)
347 {
348 	DEFiRet;
349 	if (ctxln == NULL)
350 		FINALIZE;
351 	CHKmalloc(*ctxln = ln_initCtx());
352 	ln_setErrMsgCB(*ctxln, errCallBack, NULL);
353 	if(instRules) {
354 #if HAVE_LOADSAMPLESFROMSTRING == 1
355 		if(ln_loadSamplesFromString(*ctxln, instRules) !=0) {
356 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rules '%s' "
357 					"could not be loaded", instRules);
358 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
359 		}
360 #else
361 		(void)instRules;
362 #endif
363 	} else if(instRulebase) {
364 		if(ln_loadSamples(*ctxln, (char*) instRulebase) != 0) {
365 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
366 					"could not be loaded", instRulebase);
367 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
368 		}
369 	} else if(modRules) {
370 #if HAVE_LOADSAMPLESFROMSTRING == 1
371 		if(ln_loadSamplesFromString(*ctxln, modRules) !=0) {
372 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rules '%s' "
373 					"could not be loaded", modRules);
374 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
375 		}
376 #else
377 		(void)modRules;
378 #endif
379 	} else if(modRulebase) {
380 		if(ln_loadSamples(*ctxln, (char*) modRulebase) != 0) {
381 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
382 					"could not be loaded", modRulebase);
383 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
384 		}
385 	}
386 finalize_it:
387 	if (iRet != RS_RET_OK){
388 		ln_exitCtx(*ctxln);
389 		*ctxln = NULL;
390 	}
391 	RETiRet;
392 }
393 BEGINbeginCnfLoad
394 CODESTARTbeginCnfLoad
395 	loadModConf = pModConf;
396 	pModConf-&gt;pConf = pConf;
397 ENDbeginCnfLoad
398 BEGINsetModCnf
399 	struct cnfparamvals *pvals = NULL;
400 	int i;
401 	FILE *fp = NULL;
402 	int ret;
403 	char errStr[1024];
404 CODESTARTsetModCnf
405 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
406 	if(pvals == NULL) {
407 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmkubernetes: "
408 			"error processing module config parameters [module(...)]");
409 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
410 	}
411 	if(Debug) {
412 		dbgprintf("module (global) param blk for mmkubernetes:\n");
413 		cnfparamsPrint(&amp;modpblk, pvals);
414 	}
415 	loadModConf-&gt;de_dot = DFLT_DE_DOT;
416 	loadModConf-&gt;busyRetryInterval = DFLT_BUSY_RETRY_INTERVAL;
417 	loadModConf-&gt;sslPartialChain = DFLT_SSL_PARTIAL_CHAIN;
418 	loadModConf-&gt;cacheEntryTTL = DFLT_CACHE_ENTRY_TTL;
419 	loadModConf-&gt;cacheExpireInterval = DFLT_CACHE_EXPIRE_INTERVAL;
420 <a name="2"></a>	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
421 		if(!pvals[i].bUsed) {
422 			continue;
423 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "kubernetesurl")) {
424 			free(loadModConf-&gt;kubernetesUrl);
425 			loadModConf-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
426 		} else if(!strcmp(modpblk.descr[i].name, "srcmetadatapath")) {
427 			free(loadModConf-&gt;srcMetadataPath);
428 			loadModConf-&gt;srcMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
429 		} else if(!strcmp(modpblk.descr[i].name, "dstmetadatapath")) {
430 			free(loadModConf-&gt;dstMetadataPath);
431 			loadModConf-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
432 		} else if(!strcmp(modpblk.descr[i].name, "tls.cacert")) {
433 			free(loadModConf-&gt;caCertFile);
434 			loadModConf-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
435 			fp = fopen((const char*)loadModConf-&gt;caCertFile, "r");
436 			if(fp == NULL) {
437 				rs_strerror_r(errno, errStr, sizeof(errStr));
438 				iRet = RS_RET_NO_FILE_ACCESS;
439 				LogError(0, iRet,
440 						"error: 'tls.cacert' file %s couldn't be accessed: %s\n",
441 						loadModConf-&gt;caCertFile, errStr);
442 				ABORT_FINALIZE(iRet);
443 <a name="8"></a>			} else {
444 				fclose(fp);
445 				fp = NULL;
446 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			}
447 		} else if(!strcmp(modpblk.descr[i].name, "tls.mycert")) {
448 			free(loadModConf-&gt;myCertFile);
449 			loadModConf-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
450 			fp = fopen((const char*)loadModConf-&gt;myCertFile, "r");
451 			if(fp == NULL) {
452 				rs_strerror_r(errno, errStr, sizeof(errStr));</b></font>
453 				iRet = RS_RET_NO_FILE_ACCESS;
454 				LogError(0, iRet,
455 						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
456 						loadModConf-&gt;myCertFile, errStr);
457 <a name="7"></a>			} else {
458 				fclose(fp);
459 				fp = NULL;
460 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			}
461 		} else if(!strcmp(modpblk.descr[i].name, "tls.myprivkey")) {
462 			loadModConf-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
463 			fp = fopen((const char*)loadModConf-&gt;myPrivKeyFile, "r");
464 			if(fp == NULL) {
465 				rs_strerror_r(errno, errStr, sizeof(errStr));</b></font>
466 				iRet = RS_RET_NO_FILE_ACCESS;
467 				LogError(0, iRet,
468 						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
469 						loadModConf-&gt;myPrivKeyFile, errStr);
470 			} else {
471 <a name="1"></a>				fclose(fp);
472 				fp = NULL;
473 			}
474 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "allowunsignedcerts")) {
475 			loadModConf-&gt;allowUnsignedCerts = pvals[i].val.d.n;
476 		} else if(!strcmp(modpblk.descr[i].name, "skipverifyhost")) {
477 			loadModConf-&gt;skipVerifyHost = pvals[i].val.d.n;
478 		} else if(!strcmp(modpblk.descr[i].name, "token")) {
479 			free(loadModConf-&gt;token);
480 			loadModConf-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
481 		} else if(!strcmp(modpblk.descr[i].name, "tokenfile")) {
482 			free(loadModConf-&gt;tokenFile);
483 			loadModConf-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
484 			fp = fopen((const char*)loadModConf-&gt;tokenFile, "r");
485 			if(fp == NULL) {
486 				rs_strerror_r(errno, errStr, sizeof(errStr));</b></font>
487 				iRet = RS_RET_NO_FILE_ACCESS;
488 				LogError(0, iRet,
489 						"error: token file %s couldn't be accessed: %s\n",
490 						loadModConf-&gt;tokenFile, errStr);
491 				ABORT_FINALIZE(iRet);
492 			} else {
493 				fclose(fp);
494 				fp = NULL;
495 			}
496 		} else if(!strcmp(modpblk.descr[i].name, "annotation_match")) {
497 <a name="10"></a>			free_annotationmatch(&amp;loadModConf-&gt;annotation_match);
498 			if ((ret = init_annotationmatch(&amp;loadModConf-&gt;annotation_match, pvals[i].val.d.ar)))
499 				ABORT_FINALIZE(ret);
500 <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "de_dot")) {
501 			loadModConf-&gt;de_dot = pvals[i].val.d.n;
502 		} else if(!strcmp(modpblk.descr[i].name, "de_dot_separator")) {
503 			free(loadModConf-&gt;de_dot_separator);
504 			loadModConf-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
505 #if HAVE_LOADSAMPLESFROMSTRING == 1
506 		} else if(!strcmp(modpblk.descr[i].name, "filenamerules")) {</b></font>
507 			free(loadModConf-&gt;fnRules);
508 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;fnRules)));
509 #endif
510 		} else if(!strcmp(modpblk.descr[i].name, "filenamerulebase")) {
511 			free(loadModConf-&gt;fnRulebase);
512 			loadModConf-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
513 			fp = fopen((const char*)loadModConf-&gt;fnRulebase, "r");
514 			if(fp == NULL) {
515 				rs_strerror_r(errno, errStr, sizeof(errStr));
516 				iRet = RS_RET_NO_FILE_ACCESS;
517 				LogError(0, iRet,
518 						"error: filenamerulebase file %s couldn't be accessed: %s\n",
519 						loadModConf-&gt;fnRulebase, errStr);
520 				ABORT_FINALIZE(iRet);
521 			} else {
522 				fclose(fp);
523 				fp = NULL;
524 			}
525 #if HAVE_LOADSAMPLESFROMSTRING == 1
526 		} else if(!strcmp(modpblk.descr[i].name, "containerrules")) {
527 			free(loadModConf-&gt;contRules);
528 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;contRules)));
529 #endif
530 		} else if(!strcmp(modpblk.descr[i].name, "containerrulebase")) {
531 			free(loadModConf-&gt;contRulebase);
532 			loadModConf-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
533 			fp = fopen((const char*)loadModConf-&gt;contRulebase, "r");
534 			if(fp == NULL) {
535 				rs_strerror_r(errno, errStr, sizeof(errStr));
536 				iRet = RS_RET_NO_FILE_ACCESS;
537 				LogError(0, iRet,
538 						"error: containerrulebase file %s couldn't be accessed: %s\n",
539 						loadModConf-&gt;contRulebase, errStr);
540 				ABORT_FINALIZE(iRet);
541 <a name="5"></a>			} else {
542 				fclose(fp);
543 				fp = NULL;
544 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			}
545 		} else if(!strcmp(modpblk.descr[i].name, "busyretryinterval")) {
546 			loadModConf-&gt;busyRetryInterval = pvals[i].val.d.n;
547 		} else if(!strcmp(modpblk.descr[i].name, "sslpartialchain")) {
548 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
549 			loadModConf-&gt;sslPartialChain = pvals[i].val.d.n;
550 #else
551 			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
552 					"sslpartialchain is only supported for OpenSSL\n");
553 #endif
554 		} else if(!strcmp(modpblk.descr[i].name, "cacheentryttl")) {
555 			loadModConf-&gt;cacheEntryTTL = pvals[i].val.d.n;
556 		} else if(!strcmp(modpblk.descr[i].name, "cacheexpireinterval")) {
557 			loadModConf-&gt;cacheExpireInterval = pvals[i].val.d.n;</b></font>
558 		} else {
559 			dbgprintf("mmkubernetes: program error, non-handled "
560 				"param '%s' in module() block\n", modpblk.descr[i].name);
561 		}
562 	}
563 #if HAVE_LOADSAMPLESFROMSTRING == 1
564 	if (loadModConf-&gt;fnRules &amp;&amp; loadModConf-&gt;fnRulebase) {
565 		LogError(0, RS_RET_CONFIG_ERROR,
566 				"mmkubernetes: only 1 of filenamerules or filenamerulebase may be used");
567 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
568 	}
569 	if (loadModConf-&gt;contRules &amp;&amp; loadModConf-&gt;contRulebase) {
570 		LogError(0, RS_RET_CONFIG_ERROR,
571 				"mmkubernetes: only 1 of containerrules or containerrulebase may be used");
572 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
573 	}
574 #endif
575 	if ((loadModConf-&gt;cacheExpireInterval &gt; -1)) {
576 		if ((loadModConf-&gt;cacheEntryTTL &lt; 0)) {
577 			LogError(0, RS_RET_CONFIG_ERROR,
578 					"mmkubernetes: cacheentryttl value [%d] is invalid - "
579 					"value must be 0 or greater",
580 					loadModConf-&gt;cacheEntryTTL);
581 			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
582 		}
583 	}
584 	if(loadModConf-&gt;srcMetadataPath == NULL)
585 		loadModConf-&gt;srcMetadataPath = (uchar *) strdup(DFLT_SRCMD_PATH);
586 	if(loadModConf-&gt;dstMetadataPath == NULL)
587 		loadModConf-&gt;dstMetadataPath = (uchar *) strdup(DFLT_DSTMD_PATH);
588 	if(loadModConf-&gt;de_dot_separator == NULL)
589 		loadModConf-&gt;de_dot_separator = (uchar *) strdup(DFLT_DE_DOT_SEPARATOR);
590 	if(loadModConf-&gt;de_dot_separator)
591 		loadModConf-&gt;de_dot_separator_len = strlen((const char *)loadModConf-&gt;de_dot_separator);
592 #if HAVE_LOADSAMPLESFROMSTRING == 1
593 	if (loadModConf-&gt;fnRules == NULL &amp;&amp; loadModConf-&gt;fnRulebase == NULL)
594 		loadModConf-&gt;fnRules = strdup(DFLT_FILENAME_LNRULES);
595 	if (loadModConf-&gt;contRules == NULL &amp;&amp; loadModConf-&gt;contRulebase == NULL)
596 		loadModConf-&gt;contRules = strdup(DFLT_CONTAINER_LNRULES);
597 #else
598 	if (loadModConf-&gt;fnRulebase == NULL)
599 		loadModConf-&gt;fnRulebase = (uchar *)strdup(DFLT_FILENAME_RULEBASE);
600 	if (loadModConf-&gt;contRulebase == NULL)
601 		loadModConf-&gt;contRulebase = (uchar *)strdup(DFLT_CONTAINER_RULEBASE);
602 #endif
603 	caches = calloc(1, sizeof(struct cache_s *));
604 finalize_it:
605 	if (fp)
606 		fclose(fp);
607 	if(pvals != NULL)
608 		cnfparamvalsDestruct(pvals, &amp;modpblk);
609 ENDsetModCnf
610 BEGINcreateInstance
611 CODESTARTcreateInstance
612 ENDcreateInstance
613 BEGINfreeInstance
614 CODESTARTfreeInstance
615 	free(pData-&gt;kubernetesUrl);
616 	msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
617 	free(pData-&gt;srcMetadataDescr);
618 	free(pData-&gt;dstMetadataPath);
619 	free(pData-&gt;caCertFile);
620 	free(pData-&gt;myCertFile);
621 	free(pData-&gt;myPrivKeyFile);
622 	free(pData-&gt;token);
623 	free(pData-&gt;tokenFile);
624 	free(pData-&gt;fnRules);
625 	free(pData-&gt;fnRulebase);
626 	ln_exitCtx(pData-&gt;fnCtxln);
627 	free(pData-&gt;contRules);
628 	free(pData-&gt;contRulebase);
629 	ln_exitCtx(pData-&gt;contCtxln);
630 	free_annotationmatch(&amp;pData-&gt;annotation_match);
631 	free(pData-&gt;de_dot_separator);
632 	msgPropDescrDestruct(pData-&gt;contNameDescr);
633 	free(pData-&gt;contNameDescr);
634 	msgPropDescrDestruct(pData-&gt;contIdFullDescr);
635 	free(pData-&gt;contIdFullDescr);
636 ENDfreeInstance
637 static size_t curlCB(char *data, size_t size, size_t nmemb, void *usrptr)
638 {
639 	DEFiRet;
640 	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t *) usrptr;
641 	char * buf;
642 	size_t newlen;
643 	newlen = pWrkrData-&gt;curlRplyLen + size * nmemb;
644 	CHKmalloc(buf = realloc(pWrkrData-&gt;curlRply, newlen));
645 	memcpy(buf + pWrkrData-&gt;curlRplyLen, data, size * nmemb);
646 	pWrkrData-&gt;curlRply = buf;
647 	pWrkrData-&gt;curlRplyLen = newlen;
648 finalize_it:
649 	if (iRet != RS_RET_OK) {
650 		return 0;
651 	}
652 	return size * nmemb;
653 }
654 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
655 static CURLcode set_ssl_partial_chain(CURL *curl, void *ssl_ctx, void *userptr)
656 {
657 	(void)userptr; 	CURLcode rv = CURLE_ABORTED_BY_CALLBACK;
658 	X509_STORE *store = NULL;
659 	store = SSL_CTX_get_cert_store((SSL_CTX *)ssl_ctx);
660 	if(!store)
661 		goto finalize_it;
662 	if(!X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN))
663 		goto finalize_it;
664 	rv = CURLE_OK;
665 finalize_it:
666 	return rv;
667 }
668 #endif
669 BEGINcreateWrkrInstance
670 CODESTARTcreateWrkrInstance
671 	CURL *ctx;
672 	struct curl_slist *hdr = NULL;
673 	char *tokenHdr = NULL;
674 	FILE *fp = NULL;
675 	char *token = NULL;
676 	char *statsName = NULL;
677 	CHKiRet(statsobj.Construct(&amp;(pWrkrData-&gt;stats)));
678 	if ((-1 == asprintf(&amp;statsName, "mmkubernetes(%s)", pWrkrData-&gt;pData-&gt;kubernetesUrl)) ||
679 		(!statsName)) {
680 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
681 	}
682 	CHKiRet(statsobj.SetName(pWrkrData-&gt;stats, (uchar *)statsName));
683 	free(statsName);
684 	statsName = NULL;
685 	CHKiRet(statsobj.SetOrigin(pWrkrData-&gt;stats, UCHAR_CONSTANT("mmkubernetes")));
686 	STATSCOUNTER_INIT(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
687 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("recordseen"),
688 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;k8sRecordSeen)));
689 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataSuccess, pWrkrData-&gt;mutNamespaceMetadataSuccess);
690 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatasuccess"),
691 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataSuccess)));
692 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataNotFound, pWrkrData-&gt;mutNamespaceMetadataNotFound);
693 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatanotfound"),
694 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataNotFound)));
695 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataBusy, pWrkrData-&gt;mutNamespaceMetadataBusy);
696 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatabusy"),
697 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataBusy)));
698 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataError, pWrkrData-&gt;mutNamespaceMetadataError);
699 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadataerror"),
700 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataError)));
701 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
702 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatasuccess"),
703 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataSuccess)));
704 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
705 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatanotfound"),
706 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataNotFound)));
707 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
708 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatabusy"),
709 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataBusy)));
710 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
711 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadataerror"),
712 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataError)));
713 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheNumEntries, pWrkrData-&gt;mutNamespaceCacheNumEntries);
714 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachenumentries"),
715 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheNumEntries)));
716 	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheNumEntries, pWrkrData-&gt;mutPodCacheNumEntries);
717 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachenumentries"),
718 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheNumEntries)));
719 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheHits, pWrkrData-&gt;mutNamespaceCacheHits);
720 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachehits"),
721 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheHits)));
722 	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheHits, pWrkrData-&gt;mutPodCacheHits);
723 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachehits"),
724 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheHits)));
725 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheMisses, pWrkrData-&gt;mutNamespaceCacheMisses);
726 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachemisses"),
727 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheMisses)));
728 	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheMisses, pWrkrData-&gt;mutPodCacheMisses);
729 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachemisses"),
730 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheMisses)));
731 	CHKiRet(statsobj.ConstructFinalize(pWrkrData-&gt;stats));
732 	hdr = curl_slist_append(hdr, "Content-Type: text/json; charset=utf-8");
733 	if (pWrkrData-&gt;pData-&gt;token) {
734 		if ((-1 == asprintf(&amp;tokenHdr, "Authorization: Bearer %s", pWrkrData-&gt;pData-&gt;token)) ||
735 			(!tokenHdr)) {
736 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
737 		}
738 	} else if (pWrkrData-&gt;pData-&gt;tokenFile) {
739 		struct stat statbuf;
740 		fp = fopen((const char*)pWrkrData-&gt;pData-&gt;tokenFile, "r");
741 		if (fp &amp;&amp; !fstat(fileno(fp), &amp;statbuf)) {
742 			size_t bytesread;
743 			CHKmalloc(token = malloc((statbuf.st_size+1)*sizeof(char)));
744 			if (0 &lt; (bytesread = fread(token, sizeof(char), statbuf.st_size, fp))) {
745 				token[bytesread] = '\0';
746 				if ((-1 == asprintf(&amp;tokenHdr, "Authorization: Bearer %s", token)) ||
747 					(!tokenHdr)) {
748 					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
749 				}
750 			}
751 			free(token);
752 			token = NULL;
753 		}
754 		if (fp) {
755 			fclose(fp);
756 			fp = NULL;
757 		}
758 	}
759 	if (tokenHdr) {
760 		hdr = curl_slist_append(hdr, tokenHdr);
761 		free(tokenHdr);
762 	}
763 	pWrkrData-&gt;curlHdr = hdr;
764 	ctx = curl_easy_init();
765 	curl_easy_setopt(ctx, CURLOPT_HTTPHEADER, hdr);
766 	curl_easy_setopt(ctx, CURLOPT_WRITEFUNCTION, curlCB);
767 	curl_easy_setopt(ctx, CURLOPT_WRITEDATA, pWrkrData);
768 	if(pWrkrData-&gt;pData-&gt;caCertFile)
769 		curl_easy_setopt(ctx, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
770 	if(pWrkrData-&gt;pData-&gt;myCertFile)
771 		curl_easy_setopt(ctx, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
772 	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
773 		curl_easy_setopt(ctx, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
774 	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
775 		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYPEER, 0);
776 	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
777 		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYHOST, 0);
778 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
779 	if(pWrkrData-&gt;pData-&gt;sslPartialChain) {
780 		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_FUNCTION, set_ssl_partial_chain);
781 		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_DATA, NULL);
782 	}
783 #endif
784 	pWrkrData-&gt;curlCtx = ctx;
785 finalize_it:
786 	free(token);
787 	free(statsName);
788 	if ((iRet != RS_RET_OK) &amp;&amp; pWrkrData-&gt;stats) {
789 		statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
790 	}
791 	if (fp) {
792 		fclose(fp);
793 	}
794 ENDcreateWrkrInstance
795 BEGINfreeWrkrInstance
796 CODESTARTfreeWrkrInstance
797 	curl_easy_cleanup(pWrkrData-&gt;curlCtx);
798 	curl_slist_free_all(pWrkrData-&gt;curlHdr);
799 	statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
800 ENDfreeWrkrInstance
801 static void
802 hashtable_json_object_put(void *jso)
803 {
804 	json_object_put((struct fjson_object *)jso);
805 }
806 static void
807 cache_entry_free(struct cache_entry_s *cache_entry)
808 {
809 	if (NULL != cache_entry) {
810 		if (cache_entry-&gt;data) {
811 			hashtable_json_object_put(cache_entry-&gt;data);
812 			cache_entry-&gt;data = NULL;
813 		}
814 		free(cache_entry);
815 	}
816 }
817 static void
818 cache_entry_free_raw(void *cache_entry_void)
819 {
820 	cache_entry_free((struct cache_entry_s *)cache_entry_void);
821 }
822 static struct cache_s *
823 cacheNew(instanceData *pData)
824 {
825 	DEFiRet;
826 	struct cache_s *cache = NULL;
827 	time_t now;
828 	int need_mutex_destroy = 0;
829 	CHKmalloc(cache = (struct cache_s *)calloc(1, sizeof(struct cache_s)));
830 	CHKmalloc(cache-&gt;cacheMtx = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)));
831 	CHKmalloc(cache-&gt;mdHt = create_hashtable(100, hash_from_string,
832 		key_equals_string, cache_entry_free_raw));
833 	CHKmalloc(cache-&gt;nsHt = create_hashtable(100, hash_from_string,
834 		key_equals_string, cache_entry_free_raw));
835 	CHKiConcCtrl(pthread_mutex_init(cache-&gt;cacheMtx, NULL));
836 	need_mutex_destroy = 1;
837 	datetime.GetTime(&amp;now);
838 	cache-&gt;kbUrl = pData-&gt;kubernetesUrl;
839 	cache-&gt;expirationTime = 0;
840 	if (pData-&gt;cacheExpireInterval &gt; -1)
841 		cache-&gt;expirationTime = pData-&gt;cacheExpireInterval + pData-&gt;cacheEntryTTL + now;
842 	cache-&gt;lastBusyTime = 0;
843 	dbgprintf("mmkubernetes: created cache mdht [%p] nsht [%p]\n",
844 			cache-&gt;mdHt, cache-&gt;nsHt);
845 finalize_it:
846 	if (iRet != RS_RET_OK) {
847 	        LogError(errno, iRet, "mmkubernetes: cacheNew: unable to create metadata cache for %s",
848 	                 pData-&gt;kubernetesUrl);
849 		if (cache) {
850 			if (cache-&gt;mdHt)
851 				hashtable_destroy(cache-&gt;mdHt, 1);
852 			if (cache-&gt;nsHt)
853 				hashtable_destroy(cache-&gt;nsHt, 1);
854 			if (cache-&gt;cacheMtx) {
855 				if (need_mutex_destroy)
856 					pthread_mutex_destroy(cache-&gt;cacheMtx);
857 				free(cache-&gt;cacheMtx);
858 			}
859 			free(cache);
860 			cache = NULL;
861 		}
862 	}
863 	return cache;
864 }
865 static void cacheFree(struct cache_s *cache)
866 {
867 	hashtable_destroy(cache-&gt;mdHt, 1);
868 	hashtable_destroy(cache-&gt;nsHt, 1);
869 	pthread_mutex_destroy(cache-&gt;cacheMtx);
870 	free(cache-&gt;cacheMtx);
871 	free(cache);
872 }
873 static struct cache_entry_s *cache_entry_new(time_t ttl, struct fjson_object *jso)
874 {
875 	DEFiRet;
876 	struct cache_entry_s *cache_entry = NULL;
877 	CHKmalloc(cache_entry = malloc(sizeof(struct cache_entry_s)));
878 	cache_entry-&gt;ttl = ttl;
879 	cache_entry-&gt;data = (void *)jso;
880 finalize_it:
881 	if (iRet) {
882 		free(cache_entry);
883 		cache_entry = NULL;
884 	}
885 	return cache_entry;
886 }
887 static int cache_delete_expired_entries(wrkrInstanceData_t *pWrkrData, int isnsmd, time_t now)
888 {
889 	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
890 	struct hashtable_itr *itr = NULL;
891 	int more;
892 	if ((pWrkrData-&gt;pData-&gt;cacheExpireInterval &lt; 0) || (now &lt; pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime)) {
893 		return 0; 	}
894 	pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime = now + pWrkrData-&gt;pData-&gt;cacheExpireInterval;
895 	if (hashtable_count(ht) &lt; 1)
896 		return 1; 
897 	itr = hashtable_iterator(ht);
898 	if (NULL == itr)
899 		return 1; 
900 	do {
901 		struct cache_entry_s *cache_entry = (struct cache_entry_s *)hashtable_iterator_value(itr);
902 		if (now &gt;= cache_entry-&gt;ttl) {
903 			cache_entry_free(cache_entry);
904 			if (isnsmd) {
905 				STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
906 						 pWrkrData-&gt;mutNamespaceCacheNumEntries);
907 			} else {
908 				STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
909 						 pWrkrData-&gt;mutPodCacheNumEntries);
910 			}
911 			more = hashtable_iterator_remove(itr);
912 		} else {
913 			more = hashtable_iterator_advance(itr);
914 		}
915 	} while (more);
916 	free(itr);
917 	dbgprintf("mmkubernetes: cache_delete_expired_entries: cleaned [%s] cache - size is now [%llu]\n",
918 		  isnsmd ? "namespace" : "pod",
919 		  isnsmd ? pWrkrData-&gt;namespaceCacheNumEntries : pWrkrData-&gt;podCacheNumEntries);
920 	return 1;
921 }
922 static struct fjson_object *
923 cache_entry_get(wrkrInstanceData_t *pWrkrData,
924 		int isnsmd, const char *key, time_t now)
925 {
926 	struct fjson_object *jso = NULL;
927 	struct cache_entry_s *cache_entry = NULL;
928 	int checkttl = 1;
929 	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
930 	if (cache_delete_expired_entries(pWrkrData, isnsmd, now))
931 		checkttl = 0; 	cache_entry = (struct cache_entry_s *)hashtable_search(ht, (void *)key);
932 	if (cache_entry &amp;&amp; checkttl &amp;&amp; (now &gt;= cache_entry-&gt;ttl)) {
933 		cache_entry = (struct cache_entry_s *)hashtable_remove(ht, (void *)key);
934 		if (isnsmd) {
935 			STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
936 					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
937 		} else {
938 			STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
939 					 pWrkrData-&gt;mutPodCacheNumEntries);
940 		}
941 		cache_entry_free(cache_entry);
942 		cache_entry = NULL;
943 	}
944 	if (cache_entry) {
945 		jso = (struct fjson_object *)cache_entry-&gt;data;
946 		if (isnsmd) {
947 			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheHits,
948 					 pWrkrData-&gt;mutNamespaceCacheHits);
949 		} else {
950 			STATSCOUNTER_INC(pWrkrData-&gt;podCacheHits,
951 					 pWrkrData-&gt;mutPodCacheHits);
952 		}
953 		dbgprintf("mmkubernetes: cache_entry_get: cache hit for [%s] cache key [%s] - hits is now [%llu]\n",
954 			  isnsmd ? "namespace" : "pod", key,
955 			  isnsmd ? pWrkrData-&gt;namespaceCacheHits : pWrkrData-&gt;podCacheHits);
956 	} else {
957 		if (isnsmd) {
958 			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheMisses,
959 					 pWrkrData-&gt;mutNamespaceCacheMisses);
960 		} else {
961 			STATSCOUNTER_INC(pWrkrData-&gt;podCacheMisses,
962 					 pWrkrData-&gt;mutPodCacheMisses);
963 		}
964 		dbgprintf("mmkubernetes: cache_entry_get: cache miss for [%s] cache key [%s] - misses is now [%llu]\n",
965 			  isnsmd ? "namespace" : "pod", key,
966 			  isnsmd ? pWrkrData-&gt;namespaceCacheMisses : pWrkrData-&gt;podCacheMisses);
967 	}
968 	return jso;
969 }
970 static rsRetVal
971 cache_entry_add(wrkrInstanceData_t *pWrkrData,
972 		int isnsmd, const char *key, struct fjson_object *jso, time_t now, const int bDupKey)
973 {
974 	DEFiRet;
975 	struct cache_entry_s *cache_entry = NULL;
976 	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
977 	(void)cache_delete_expired_entries(pWrkrData, isnsmd, now);
978 	CHKmalloc(cache_entry = cache_entry_new(now + pWrkrData-&gt;pData-&gt;cacheEntryTTL, jso));
979 	if (cache_entry) {
980 		if (!hashtable_insert(ht, (void *)(bDupKey ? strdup(key) : key), cache_entry))
981 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
982 		if (isnsmd) {
983 			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheNumEntries,
984 					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
985 		} else {
986 			STATSCOUNTER_INC(pWrkrData-&gt;podCacheNumEntries,
987 					 pWrkrData-&gt;mutPodCacheNumEntries);
988 		}
989 		cache_entry = NULL;
990 	}
991 finalize_it:
992 	if (cache_entry)
993 		cache_entry_free(cache_entry);
994 	return iRet;
995 }
996 static struct fjson_object *cache_entry_get_md(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
997 {
998 	return cache_entry_get(pWrkrData, 0, key, now);
999 }
1000 static struct fjson_object *cache_entry_get_nsmd(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
1001 {
1002 	return cache_entry_get(pWrkrData, 1, key, now);
1003 }
1004 static rsRetVal cache_entry_add_md(wrkrInstanceData_t *pWrkrData, const char *key,
1005 				   struct fjson_object *jso, time_t now)
1006 {
1007 	return cache_entry_add(pWrkrData, 0, key, jso, now, 0);
1008 }
1009 static rsRetVal cache_entry_add_nsmd(wrkrInstanceData_t *pWrkrData, const char *key,
1010 				     struct fjson_object *jso, time_t now)
1011 {
1012 	return cache_entry_add(pWrkrData, 1, key, jso, now, 1);
1013 }
1014 BEGINnewActInst
1015 	struct cnfparamvals *pvals = NULL;
1016 	int i;
1017 	FILE *fp = NULL;
1018 	char *rxstr = NULL;
1019 	char *srcMetadataPath = NULL;
1020 	char errStr[1024];
1021 CODESTARTnewActInst
1022 	DBGPRINTF("newActInst (mmkubernetes)\n");
1023 	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
1024 	if(pvals == NULL) {
1025 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmkubernetes: "
1026 			"error processing config parameters [action(...)]");
1027 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1028 	}
1029 	if(Debug) {
1030 		dbgprintf("action param blk in mmkubernetes:\n");
1031 		cnfparamsPrint(&amp;actpblk, pvals);
1032 	}
1033 	CODE_STD_STRING_REQUESTnewActInst(1)
1034 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
1035 	CHKiRet(createInstance(&amp;pData));
1036 	pData-&gt;de_dot = loadModConf-&gt;de_dot;
1037 	pData-&gt;allowUnsignedCerts = loadModConf-&gt;allowUnsignedCerts;
1038 	pData-&gt;skipVerifyHost = loadModConf-&gt;skipVerifyHost;
1039 	pData-&gt;busyRetryInterval = loadModConf-&gt;busyRetryInterval;
1040 	pData-&gt;sslPartialChain = loadModConf-&gt;sslPartialChain;
1041 	pData-&gt;cacheEntryTTL = loadModConf-&gt;cacheEntryTTL;
1042 	pData-&gt;cacheExpireInterval = loadModConf-&gt;cacheExpireInterval;
1043 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
1044 		if(!pvals[i].bUsed) {
1045 			continue;
1046 		} else if(!strcmp(actpblk.descr[i].name, "kubernetesurl")) {
1047 			free(pData-&gt;kubernetesUrl);
1048 			pData-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1049 		} else if(!strcmp(actpblk.descr[i].name, "srcmetadatapath")) {
1050 <a name="9"></a>			msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
1051 			free(pData-&gt;srcMetadataDescr);
1052 			CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
1053 <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			srcMetadataPath = es_str2cstr(pvals[i].val.d.estr, NULL);
1054 			CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, (uchar *)srcMetadataPath,
1055 				strlen(srcMetadataPath)));
1056 		} else if(!strcmp(actpblk.descr[i].name, "dstmetadatapath")) {
1057 			free(pData-&gt;dstMetadataPath);
1058 			pData-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1059 		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
1060 			free(pData-&gt;caCertFile);
1061 			pData-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1062 			fp = fopen((const char*)pData-&gt;caCertFile, "r");
1063 			if(fp == NULL) {
1064 				rs_strerror_r(errno, errStr, sizeof(errStr));
1065 				iRet = RS_RET_NO_FILE_ACCESS;
1066 				LogError(0, iRet,
1067 						"error: certificate file %s couldn't be accessed: %s\n",
1068 						pData-&gt;caCertFile, errStr);
1069 				ABORT_FINALIZE(iRet);
1070 			} else {
1071 				fclose(fp);
1072 				fp = NULL;
1073 			}
1074 		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
1075 			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1076 			fp = fopen((const char*)pData-&gt;myCertFile, "r");
1077 			if(fp == NULL) {
1078 				rs_strerror_r(errno, errStr, sizeof(errStr));
1079 				iRet = RS_RET_NO_FILE_ACCESS;
1080 				LogError(0, iRet,
1081 						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
1082 						pData-&gt;myCertFile, errStr);
1083 			} else {
1084 				fclose(fp);
1085 				fp = NULL;
1086 			}
1087 		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
1088 			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1089 			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
1090 			if(fp == NULL) {
1091 				rs_strerror_r(errno, errStr, sizeof(errStr));
1092 				iRet = RS_RET_NO_FILE_ACCESS;
1093 				LogError(0, iRet,
1094 						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
1095 						pData-&gt;myPrivKeyFile, errStr);
1096 <a name="4"></a>			} else {
1097 				fclose(fp);
1098 				fp = NULL;
1099 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			}
1100 		} else if(!strcmp(actpblk.descr[i].name, "allowunsignedcerts")) {
1101 			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
1102 		} else if(!strcmp(actpblk.descr[i].name, "skipverifyhost")) {
1103 			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
1104 		} else if(!strcmp(actpblk.descr[i].name, "token")) {
1105 			free(pData-&gt;token);
1106 			pData-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1107 		} else if(!strcmp(actpblk.descr[i].name, "tokenfile")) {
1108 			free(pData-&gt;tokenFile);
1109 			pData-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1110 			fp = fopen((const char*)pData-&gt;tokenFile, "r");
1111 			if(fp == NULL) {
1112 				rs_strerror_r(errno, errStr, sizeof(errStr));
1113 				iRet = RS_RET_NO_FILE_ACCESS;
1114 				LogError(0, iRet,
1115 						"error: token file %s couldn't be accessed: %s\n",
1116 						pData-&gt;tokenFile, errStr);
1117 				ABORT_FINALIZE(iRet);
1118 			} else {
1119 				fclose(fp);
1120 				fp = NULL;
1121 <a name="11"></a>			}
1122 		} else if(!strcmp(actpblk.descr[i].name, "annotation_match")) {
1123 			free_annotationmatch(&amp;pData-&gt;annotation_match);
1124 <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			if (RS_RET_OK != (iRet = init_annotationmatch(&amp;pData-&gt;annotation_match, pvals[i].val.d.ar)))
1125 				ABORT_FINALIZE(iRet);
1126 		} else if(!strcmp(actpblk.descr[i].name, "de_dot")) {
1127 			pData-&gt;de_dot = pvals[i].val.d.n;
1128 		} else if(!strcmp(actpblk.descr[i].name, "de_dot_separator")) {
1129 			free(pData-&gt;de_dot_separator);
1130 			pData-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1131 #if HAVE_LOADSAMPLESFROMSTRING == 1
1132 		} else if(!strcmp(modpblk.descr[i].name, "filenamerules")) {
1133 			free(pData-&gt;fnRules);
1134 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;fnRules)));
1135 #endif
1136 		} else if(!strcmp(modpblk.descr[i].name, "filenamerulebase")) {
1137 			free(pData-&gt;fnRulebase);
1138 			pData-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1139 			fp = fopen((const char*)pData-&gt;fnRulebase, "r");
1140 			if(fp == NULL) {
1141 				rs_strerror_r(errno, errStr, sizeof(errStr));
1142 				iRet = RS_RET_NO_FILE_ACCESS;
1143 				LogError(0, iRet,
1144 						"error: filenamerulebase file %s couldn't be accessed: %s\n",
1145 						pData-&gt;fnRulebase, errStr);
1146 				ABORT_FINALIZE(iRet);
1147 			} else {
1148 				fclose(fp);
1149 				fp = NULL;
1150 			}
1151 #if HAVE_LOADSAMPLESFROMSTRING == 1
1152 		} else if(!strcmp(modpblk.descr[i].name, "containerrules")) {
1153 			free(pData-&gt;contRules);
1154 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;contRules)));
1155 #endif
1156 		} else if(!strcmp(modpblk.descr[i].name, "containerrulebase")) {
1157 			free(pData-&gt;contRulebase);
1158 			pData-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1159 			fp = fopen((const char*)pData-&gt;contRulebase, "r");
1160 			if(fp == NULL) {
1161 				rs_strerror_r(errno, errStr, sizeof(errStr));
1162 				iRet = RS_RET_NO_FILE_ACCESS;
1163 				LogError(0, iRet,
1164 						"error: containerrulebase file %s couldn't be accessed: %s\n",
1165 						pData-&gt;contRulebase, errStr);
1166 				ABORT_FINALIZE(iRet);
1167 			} else {
1168 <a name="6"></a>				fclose(fp);
1169 				fp = NULL;
1170 			}
1171 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "busyretryinterval")) {
1172 			pData-&gt;busyRetryInterval = pvals[i].val.d.n;
1173 		} else if(!strcmp(actpblk.descr[i].name, "sslpartialchain")) {
1174 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
1175 			pData-&gt;sslPartialChain = pvals[i].val.d.n;
1176 #else
1177 			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
1178 					"sslpartialchain is only supported for OpenSSL\n");
1179 #endif
1180 		} else if(!strcmp(actpblk.descr[i].name, "cacheentryttl")) {
1181 			pData-&gt;cacheEntryTTL = pvals[i].val.d.n;
1182 		} else if(!strcmp(actpblk.descr[i].name, "cacheexpireinterval")) {
1183 			pData-&gt;cacheExpireInterval = pvals[i].val.d.n;
1184 		} else {</b></font>
1185 			dbgprintf("mmkubernetes: program error, non-handled "
1186 				"param '%s' in action() block\n", actpblk.descr[i].name);
1187 		}
1188 	}
1189 #if HAVE_LOADSAMPLESFROMSTRING == 1
1190 	if (pData-&gt;fnRules &amp;&amp; pData-&gt;fnRulebase) {
1191 		LogError(0, RS_RET_CONFIG_ERROR,
1192 		    "mmkubernetes: only 1 of filenamerules or filenamerulebase may be used");
1193 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1194 	}
1195 	if (pData-&gt;contRules &amp;&amp; pData-&gt;contRulebase) {
1196 		LogError(0, RS_RET_CONFIG_ERROR,
1197 			"mmkubernetes: only 1 of containerrules or containerrulebase may be used");
1198 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1199 	}
1200 #endif
1201 	CHKiRet(set_lnctx(&amp;pData-&gt;fnCtxln, pData-&gt;fnRules, pData-&gt;fnRulebase,
1202 			loadModConf-&gt;fnRules, loadModConf-&gt;fnRulebase));
1203 	CHKiRet(set_lnctx(&amp;pData-&gt;contCtxln, pData-&gt;contRules, pData-&gt;contRulebase,
1204 			loadModConf-&gt;contRules, loadModConf-&gt;contRulebase));
1205 	if ((pData-&gt;cacheExpireInterval &gt; -1)) {
1206 		if ((pData-&gt;cacheEntryTTL &lt; 0)) {
1207 			LogError(0, RS_RET_CONFIG_ERROR,
1208 					"mmkubernetes: cacheentryttl value [%d] is invalid - "
1209 					"value must be 0 or greater",
1210 					pData-&gt;cacheEntryTTL);
1211 			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1212 		}
1213 	}
1214 	if(pData-&gt;kubernetesUrl == NULL) {
1215 		if(loadModConf-&gt;kubernetesUrl == NULL) {
1216 			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup(DFLT_KUBERNETES_URL));
1217 		} else {
1218 			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup((char *) loadModConf-&gt;kubernetesUrl));
1219 		}
1220 	}
1221 	if(pData-&gt;srcMetadataDescr == NULL) {
1222 		CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
1223 		CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, loadModConf-&gt;srcMetadataPath,
1224 			strlen((char *)loadModConf-&gt;srcMetadataPath)));
1225 	}
1226 	if(pData-&gt;dstMetadataPath == NULL)
1227 		pData-&gt;dstMetadataPath = (uchar *) strdup((char *) loadModConf-&gt;dstMetadataPath);
1228 	if(pData-&gt;caCertFile == NULL &amp;&amp; loadModConf-&gt;caCertFile)
1229 		pData-&gt;caCertFile = (uchar *) strdup((char *) loadModConf-&gt;caCertFile);
1230 	if(pData-&gt;myCertFile == NULL &amp;&amp; loadModConf-&gt;myCertFile)
1231 		pData-&gt;myCertFile = (uchar *) strdup((char *) loadModConf-&gt;myCertFile);
1232 	if(pData-&gt;myPrivKeyFile == NULL &amp;&amp; loadModConf-&gt;myPrivKeyFile)
1233 		pData-&gt;myPrivKeyFile = (uchar *) strdup((char *) loadModConf-&gt;myPrivKeyFile);
1234 	if(pData-&gt;token == NULL &amp;&amp; loadModConf-&gt;token)
1235 		pData-&gt;token = (uchar *) strdup((char *) loadModConf-&gt;token);
1236 	if(pData-&gt;tokenFile == NULL &amp;&amp; loadModConf-&gt;tokenFile)
1237 		pData-&gt;tokenFile = (uchar *) strdup((char *) loadModConf-&gt;tokenFile);
1238 	if(pData-&gt;de_dot_separator == NULL &amp;&amp; loadModConf-&gt;de_dot_separator)
1239 		pData-&gt;de_dot_separator = (uchar *) strdup((char *) loadModConf-&gt;de_dot_separator);
1240 	if((pData-&gt;annotation_match.nmemb == 0) &amp;&amp; (loadModConf-&gt;annotation_match.nmemb &gt; 0))
1241 		copy_annotationmatch(&amp;loadModConf-&gt;annotation_match, &amp;pData-&gt;annotation_match);
1242 	if(pData-&gt;de_dot_separator)
1243 		pData-&gt;de_dot_separator_len = strlen((const char *)pData-&gt;de_dot_separator);
1244 	CHKmalloc(pData-&gt;contNameDescr = malloc(sizeof(msgPropDescr_t)));
1245 	CHKiRet(msgPropDescrFill(pData-&gt;contNameDescr, (uchar*) DFLT_CONTAINER_NAME,
1246 			strlen(DFLT_CONTAINER_NAME)));
1247 	CHKmalloc(pData-&gt;contIdFullDescr = malloc(sizeof(msgPropDescr_t)));
1248 	CHKiRet(msgPropDescrFill(pData-&gt;contIdFullDescr, (uchar*) DFLT_CONTAINER_ID_FULL,
1249 			strlen(DFLT_CONTAINER_NAME)));
1250 	for(i = 0; caches[i] != NULL; i++) {
1251 		if(!strcmp((char *) pData-&gt;kubernetesUrl, (char *) caches[i]-&gt;kbUrl))
1252 			break;
1253 	}
1254 	if(caches[i] != NULL) {
1255 		pData-&gt;cache = caches[i];
1256 	} else {
1257 		CHKmalloc(pData-&gt;cache = cacheNew(pData));
1258 		struct cache_s **new_caches = realloc(caches, (i + 2) * sizeof(struct cache_s *));
1259 		CHKmalloc(new_caches);
1260 		caches = new_caches;
1261 		caches[i] = pData-&gt;cache;
1262 		caches[i + 1] = NULL;
1263 	}
1264 CODE_STD_FINALIZERnewActInst
1265 	if(pvals != NULL)
1266 		cnfparamvalsDestruct(pvals, &amp;actpblk);
1267 	if(fp)
1268 		fclose(fp);
1269 	free(rxstr);
1270 	free(srcMetadataPath);
1271 ENDnewActInst
1272 BEGINparseSelectorAct
1273 CODESTARTparseSelectorAct
1274 CODE_STD_STRING_REQUESTparseSelectorAct(1)
1275 	if(strncmp((char *) p, ":mmkubernetes:", sizeof(":mmkubernetes:") - 1)) {
1276 		LogError(0, RS_RET_LEGA_ACT_NOT_SUPPORTED,
1277 			"mmkubernetes supports only v6+ config format, use: "
1278 			"action(type=\"mmkubernetes\" ...)");
1279 	}
1280 	ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
1281 CODE_STD_FINALIZERparseSelectorAct
1282 ENDparseSelectorAct
1283 BEGINendCnfLoad
1284 CODESTARTendCnfLoad
1285 ENDendCnfLoad
1286 BEGINcheckCnf
1287 CODESTARTcheckCnf
1288 ENDcheckCnf
1289 BEGINactivateCnf
1290 CODESTARTactivateCnf
1291 	runModConf = pModConf;
1292 ENDactivateCnf
1293 BEGINfreeCnf
1294 CODESTARTfreeCnf
1295 	int i;
1296 	free(pModConf-&gt;kubernetesUrl);
1297 	free(pModConf-&gt;srcMetadataPath);
1298 	free(pModConf-&gt;dstMetadataPath);
1299 	free(pModConf-&gt;caCertFile);
1300 	free(pModConf-&gt;myCertFile);
1301 	free(pModConf-&gt;myPrivKeyFile);
1302 	free(pModConf-&gt;token);
1303 	free(pModConf-&gt;tokenFile);
1304 	free(pModConf-&gt;de_dot_separator);
1305 	free(pModConf-&gt;fnRules);
1306 	free(pModConf-&gt;fnRulebase);
1307 	free(pModConf-&gt;contRules);
1308 	free(pModConf-&gt;contRulebase);
1309 	free_annotationmatch(&amp;pModConf-&gt;annotation_match);
1310 	for(i = 0; caches[i] != NULL; i++) {
1311 		dbgprintf("mmkubernetes: freeing cache [%d] mdht [%p] nsht [%p]\n",
1312 				i, caches[i]-&gt;mdHt, caches[i]-&gt;nsHt);
1313 		cacheFree(caches[i]);
1314 	}
1315 	free(caches);
1316 ENDfreeCnf
1317 BEGINdbgPrintInstInfo
1318 CODESTARTdbgPrintInstInfo
1319 	dbgprintf("mmkubernetes\n");
1320 	dbgprintf("\tkubernetesUrl='%s'\n", pData-&gt;kubernetesUrl);
1321 	dbgprintf("\tsrcMetadataPath='%s'\n", pData-&gt;srcMetadataDescr-&gt;name);
1322 	dbgprintf("\tdstMetadataPath='%s'\n", pData-&gt;dstMetadataPath);
1323 	dbgprintf("\ttls.cacert='%s'\n", pData-&gt;caCertFile);
1324 	dbgprintf("\ttls.mycert='%s'\n", pData-&gt;myCertFile);
1325 	dbgprintf("\ttls.myprivkey='%s'\n", pData-&gt;myPrivKeyFile);
1326 	dbgprintf("\tallowUnsignedCerts='%d'\n", pData-&gt;allowUnsignedCerts);
1327 	dbgprintf("\tskipVerifyHost='%d'\n", pData-&gt;skipVerifyHost);
1328 	dbgprintf("\ttoken='%s'\n", pData-&gt;token);
1329 	dbgprintf("\ttokenFile='%s'\n", pData-&gt;tokenFile);
1330 	dbgprintf("\tde_dot='%d'\n", pData-&gt;de_dot);
1331 	dbgprintf("\tde_dot_separator='%s'\n", pData-&gt;de_dot_separator);
1332 	dbgprintf("\tfilenamerulebase='%s'\n", pData-&gt;fnRulebase);
1333 	dbgprintf("\tcontainerrulebase='%s'\n", pData-&gt;contRulebase);
1334 #if HAVE_LOADSAMPLESFROMSTRING == 1
1335 	dbgprintf("\tfilenamerules='%s'\n", pData-&gt;fnRules);
1336 	dbgprintf("\tcontainerrules='%s'\n", pData-&gt;contRules);
1337 #endif
1338 	dbgprintf("\tbusyretryinterval='%d'\n", pData-&gt;busyRetryInterval);
1339 	dbgprintf("\tcacheentryttl='%d'\n", pData-&gt;cacheEntryTTL);
1340 	dbgprintf("\tcacheexpireinterval='%d'\n", pData-&gt;cacheExpireInterval);
1341 ENDdbgPrintInstInfo
1342 BEGINtryResume
1343 CODESTARTtryResume
1344 ENDtryResume
1345 static rsRetVal
1346 extractMsgMetadata(smsg_t *pMsg, instanceData *pData, struct json_object **json)
1347 {
1348 	DEFiRet;
1349 	uchar *filename = NULL, *container_name = NULL, *container_id_full = NULL;
1350 	rs_size_t fnLen, container_name_len, container_id_full_len;
1351 	unsigned short freeFn = 0, free_container_name = 0, free_container_id_full = 0;
1352 	int lnret;
1353 	struct json_object *cnid = NULL;
1354 	if (!json)
1355 		FINALIZE;
1356 	*json = NULL;
1357 	container_name = MsgGetProp(pMsg, NULL, pData-&gt;contNameDescr,
1358 				    &amp;container_name_len, &amp;free_container_name, NULL);
1359 	container_id_full = MsgGetProp(
1360 		pMsg, NULL, pData-&gt;contIdFullDescr, &amp;container_id_full_len, &amp;free_container_id_full, NULL);
1361 	if (container_name &amp;&amp; container_id_full &amp;&amp; container_name_len &amp;&amp; container_id_full_len) {
1362 		dbgprintf("mmkubernetes: CONTAINER_NAME: '%s'  CONTAINER_ID_FULL: '%s'.\n",
1363 			  container_name, container_id_full);
1364 		if ((lnret = ln_normalize(pData-&gt;contCtxln, (char*)container_name,
1365 					  container_name_len, json))) {
1366 			if (LN_WRONGPARSER != lnret) {
1367 				LogMsg(0, RS_RET_ERR, LOG_ERR,
1368 					"mmkubernetes: error parsing container_name [%s]: [%d]",
1369 					container_name, lnret);
1370 				ABORT_FINALIZE(RS_RET_ERR);
1371 			}
1372 		} else if (fjson_object_object_get_ex(*json, "pod_name", NULL) &amp;&amp;
1373 			fjson_object_object_get_ex(*json, "namespace_name", NULL) &amp;&amp;
1374 			fjson_object_object_get_ex(*json, "container_name", NULL)) {
1375 			json_object_object_add(*json, "container_id",
1376 				json_object_new_string_len((const char *)container_id_full,
1377 							   container_id_full_len));
1378 			ABORT_FINALIZE(RS_RET_OK);
1379 		}
1380 	}
1381 	filename = MsgGetProp(pMsg, NULL, pData-&gt;srcMetadataDescr, &amp;fnLen, &amp;freeFn, NULL);
1382 	if((filename == NULL) || (fnLen == 0))
1383 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
1384 	dbgprintf("mmkubernetes: filename: '%s' len %d.\n", filename, fnLen);
1385 	if ((lnret = ln_normalize(pData-&gt;fnCtxln, (char*)filename, fnLen, json))) {
1386 		if (LN_WRONGPARSER != lnret) {
1387 			LogMsg(0, RS_RET_ERR, LOG_ERR,
1388 				"mmkubernetes: error parsing container_name [%s]: [%d]",
1389 				filename, lnret);
1390 			ABORT_FINALIZE(RS_RET_ERR);
1391 		} else {
1392 			ABORT_FINALIZE(RS_RET_NOT_FOUND);
1393 		}
1394 	}
1395 	if (fjson_object_object_get_ex(*json, "pod_name", NULL) &amp;&amp;
1396 		fjson_object_object_get_ex(*json, "namespace_name", NULL) &amp;&amp;
1397 		fjson_object_object_get_ex(*json, "container_name_and_id", &amp;cnid)) {
1398 		const char *container_name_and_id = json_object_get_string(cnid);
1399 		const char *last_dash = NULL;
1400 		if (container_name_and_id &amp;&amp; (last_dash = strrchr(container_name_and_id, '-')) &amp;&amp;
1401 			*(last_dash + 1) &amp;&amp; (last_dash != container_name_and_id)) {
1402 			json_object_object_add(*json, "container_name",
1403 				json_object_new_string_len(container_name_and_id,
1404 							   (int)(last_dash-container_name_and_id)));
1405 			json_object_object_add(*json, "container_id",
1406 					json_object_new_string(last_dash + 1));
1407 			ABORT_FINALIZE(RS_RET_OK);
1408 		}
1409 	}
1410 	ABORT_FINALIZE(RS_RET_NOT_FOUND);
1411 finalize_it:
1412 	if(freeFn)
1413 		free(filename);
1414 	if (free_container_name)
1415 		free(container_name);
1416 	if (free_container_id_full)
1417 		free(container_id_full);
1418 	if (iRet != RS_RET_OK) {
1419 		json_object_put(*json);
1420 		*json = NULL;
1421 	}
1422 	RETiRet;
1423 }
1424 static rsRetVal
1425 queryKB(wrkrInstanceData_t *pWrkrData, char *url, time_t now, struct json_object **rply)
1426 {
1427 	DEFiRet;
1428 	CURLcode ccode;
1429 	struct json_tokener *jt = NULL;
1430 	struct json_object *jo;
1431 	long resp_code = 400;
1432 	if (pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime) {
1433 		now -= pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime;
1434 		if (now &lt; pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1435 			LogMsg(0, RS_RET_RETRY, LOG_DEBUG,
1436 				"mmkubernetes: Waited [%ld] of [%d] seconds for the requested url [%s]\n",
1437 				now, pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
1438 			ABORT_FINALIZE(RS_RET_RETRY);
1439 		} else {
1440 			LogMsg(0, RS_RET_OK, LOG_DEBUG,
1441 				"mmkubernetes: Cleared busy status after [%d] seconds - "
1442 				"will retry the requested url [%s]\n",
1443 				pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
1444 			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = 0;
1445 		}
1446 	}
1447 	ccode = curl_easy_setopt(pWrkrData-&gt;curlCtx, CURLOPT_URL, url);
1448 	if(ccode != CURLE_OK)
1449 		ABORT_FINALIZE(RS_RET_ERR);
1450 	if(CURLE_OK != (ccode = curl_easy_perform(pWrkrData-&gt;curlCtx))) {
1451 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1452 			      "mmkubernetes: failed to connect to [%s] - %d:%s\n",
1453 			      url, ccode, curl_easy_strerror(ccode));
1454 		ABORT_FINALIZE(RS_RET_SUSPENDED);
1455 	}
1456 	if(CURLE_OK != (ccode = curl_easy_getinfo(pWrkrData-&gt;curlCtx,
1457 					CURLINFO_RESPONSE_CODE, &amp;resp_code))) {
1458 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1459 			      "mmkubernetes: could not get response code from query to [%s] - %d:%s\n",
1460 			      url, ccode, curl_easy_strerror(ccode));
1461 		ABORT_FINALIZE(RS_RET_ERR);
1462 	}
1463 	if(resp_code == 401) {
1464 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1465 			      "mmkubernetes: Unauthorized: not allowed to view url - "
1466 			      "check token/auth credentials [%s]\n",
1467 			      url);
1468 		ABORT_FINALIZE(RS_RET_ERR);
1469 	}
1470 	if(resp_code == 403) {
1471 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1472 			      "mmkubernetes: Forbidden: no access - "
1473 			      "check permissions to view url [%s]\n",
1474 			      url);
1475 		ABORT_FINALIZE(RS_RET_ERR);
1476 	}
1477 	if(resp_code == 404) {
1478 		LogMsg(0, RS_RET_NOT_FOUND, LOG_INFO,
1479 			      "mmkubernetes: Not Found: the resource does not exist at url [%s]\n",
1480 			      url);
1481 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
1482 	}
1483 	if(resp_code == 429) {
1484 		if (pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1485 			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = now;
1486 		}
1487 		LogMsg(0, RS_RET_RETRY, LOG_INFO,
1488 			      "mmkubernetes: Too Many Requests: the server is too heavily loaded "
1489 			      "to provide the data for the requested url [%s]\n",
1490 			      url);
1491 		ABORT_FINALIZE(RS_RET_RETRY);
1492 	}
1493 	if(resp_code != 200) {
1494 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1495 			      "mmkubernetes: server returned unexpected code [%ld] for url [%s]\n",
1496 			      resp_code, url);
1497 		ABORT_FINALIZE(RS_RET_ERR);
1498 	}
1499 	jt = json_tokener_new();
1500 	json_tokener_reset(jt);
1501 	jo = json_tokener_parse_ex(jt, pWrkrData-&gt;curlRply, pWrkrData-&gt;curlRplyLen);
1502 	json_tokener_free(jt);
1503 	if(!json_object_is_type(jo, json_type_object)) {
1504 		json_object_put(jo);
1505 		jo = NULL;
1506 		LogMsg(0, RS_RET_JSON_PARSE_ERR, LOG_INFO,
1507 			      "mmkubernetes: unable to parse string as JSON:[%.*s]\n",
1508 			      (int)pWrkrData-&gt;curlRplyLen, pWrkrData-&gt;curlRply);
1509 		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
1510 	}
1511 	dbgprintf("mmkubernetes: queryKB reply:\n%s\n",
1512 		json_object_to_json_string_ext(jo, JSON_C_TO_STRING_PRETTY));
1513 	*rply = jo;
1514 finalize_it:
1515 	if(pWrkrData-&gt;curlRply != NULL) {
1516 		free(pWrkrData-&gt;curlRply);
1517 		pWrkrData-&gt;curlRply = NULL;
1518 		pWrkrData-&gt;curlRplyLen = 0;
1519 	}
1520 	RETiRet;
1521 }
1522 #if defined(BEGINdoAction_NoStrings)
1523 BEGINdoAction_NoStrings
1524 	smsg_t **ppMsg = (smsg_t **) pMsgData;
1525 	smsg_t *pMsg = ppMsg[0];
1526 #else
1527 BEGINdoAction
1528 	smsg_t *pMsg = (smsg_t*) ppString[0];
1529 #endif
1530 	const char *podName = NULL, *ns = NULL, *containerName = NULL,
1531 		*containerID = NULL;
1532 	char *mdKey = NULL;
1533 	struct json_object *jMetadata = NULL, *jMetadataCopy = NULL, *jMsgMeta = NULL,
1534 			*jo = NULL;
1535 	int add_pod_metadata = 1;
1536 	time_t now;
1537 CODESTARTdoAction
1538 	CHKiRet_Hdlr(extractMsgMetadata(pMsg, pWrkrData-&gt;pData, &amp;jMsgMeta)) {
1539 		ABORT_FINALIZE((iRet == RS_RET_NOT_FOUND) ? RS_RET_OK : iRet);
1540 	}
1541 	datetime.GetTime(&amp;now);
1542 	STATSCOUNTER_INC(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
1543 	if (fjson_object_object_get_ex(jMsgMeta, "pod_name", &amp;jo))
1544 		podName = json_object_get_string(jo);
1545 	if (fjson_object_object_get_ex(jMsgMeta, "namespace_name", &amp;jo))
1546 		ns = json_object_get_string(jo);
1547 	if (fjson_object_object_get_ex(jMsgMeta, "container_name", &amp;jo))
1548 		containerName = json_object_get_string(jo);
1549 	if (fjson_object_object_get_ex(jMsgMeta, "container_id", &amp;jo))
1550 		containerID = json_object_get_string(jo);
1551 	assert(podName != NULL);
1552 	assert(ns != NULL);
1553 	assert(containerName != NULL);
1554 	assert(containerID != NULL);
1555 	dbgprintf("mmkubernetes:\n  podName: '%s'\n  namespace: '%s'\n  containerName: '%s'\n"
1556 		"  containerID: '%s'\n", podName, ns, containerName, containerID);
1557 	if ((-1 == asprintf(&amp;mdKey, "%s_%s_%s", ns, podName, containerName)) ||
1558 		(!mdKey)) {
1559 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1560 	}
1561 	pthread_mutex_lock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1562 	jMetadata = cache_entry_get_md(pWrkrData, mdKey, now);
1563 	if(jMetadata == NULL) {
1564 		char *url = NULL;
1565 		struct json_object *jReply = NULL, *jo2 = NULL, *jNsMeta = NULL, *jPodData = NULL;
1566 		jNsMeta = cache_entry_get_nsmd(pWrkrData, (const char *)ns, now);
1567 		if(jNsMeta == NULL) {
1568 			if ((-1 == asprintf(&amp;url, "%s/api/v1/namespaces/%s",
1569 				 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns)) ||
1570 				(!url)) {
1571 				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1572 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1573 			}
1574 			iRet = queryKB(pWrkrData, url, now, &amp;jReply);
1575 			free(url);
1576 			if (iRet == RS_RET_NOT_FOUND) {
1577 				jNsMeta = json_object_new_object();
1578 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataNotFound,
1579 						 pWrkrData-&gt;mutNamespaceMetadataNotFound);
1580 			} else if (iRet == RS_RET_RETRY) {
1581 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataBusy,
1582 						 pWrkrData-&gt;mutNamespaceMetadataBusy);
1583 				if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1584 					pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1585 					ABORT_FINALIZE(RS_RET_ERR);
1586 				}
1587 				add_pod_metadata = 0; 			} else if (iRet != RS_RET_OK) {
1588 				jNsMeta = json_object_new_object();
1589 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataError,
1590 						 pWrkrData-&gt;mutNamespaceMetadataError);
1591 			} else if (fjson_object_object_get_ex(jReply, "metadata", &amp;jNsMeta)) {
1592 				jNsMeta = json_object_get(jNsMeta);
1593 				parse_labels_annotations(jNsMeta, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
1594 					pWrkrData-&gt;pData-&gt;de_dot,
1595 					(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
1596 					pWrkrData-&gt;pData-&gt;de_dot_separator_len);
1597 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
1598 						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
1599 			} else {
1600 				LogMsg(0, RS_RET_ERR, LOG_INFO,
1601 					      "mmkubernetes: namespace [%s] has no metadata!\n", ns);
1602 				jNsMeta = json_object_new_object();
1603 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
1604 						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
1605 			}
1606 			if(jNsMeta) {
1607 				if ((iRet = cache_entry_add_nsmd(pWrkrData, ns, jNsMeta, now))) {
1608 					ABORT_FINALIZE(iRet);
1609 				}
1610 			}
1611 			json_object_put(jReply);
1612 			jReply = NULL;
1613 		}
1614 		if ((-1 == asprintf(&amp;url, "%s/api/v1/namespaces/%s/pods/%s",
1615 			 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns, podName)) ||
1616 			(!url)) {
1617 			pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1618 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1619 		}
1620 		iRet = queryKB(pWrkrData, url, now, &amp;jReply);
1621 		free(url);
1622 		if (iRet == RS_RET_NOT_FOUND) {
1623 			iRet = RS_RET_OK;
1624 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
1625 		} else if (iRet == RS_RET_RETRY) {
1626 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
1627 			if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1628 				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1629 				ABORT_FINALIZE(RS_RET_ERR);
1630 			}
1631 			add_pod_metadata = 0; 			iRet = RS_RET_OK;
1632 		} else if(iRet != RS_RET_OK) {
1633 			iRet = RS_RET_OK;
1634 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
1635 		} else {
1636 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
1637 		}
1638 		jo = json_object_new_object();
1639 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "uid", &amp;jo2))
1640 			json_object_object_add(jo, "namespace_id", json_object_get(jo2));
1641 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "labels", &amp;jo2))
1642 			json_object_object_add(jo, "namespace_labels", json_object_get(jo2));
1643 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "annotations", &amp;jo2))
1644 			json_object_object_add(jo, "namespace_annotations", json_object_get(jo2));
1645 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "creationTimestamp", &amp;jo2))
1646 			json_object_object_add(jo, "creation_timestamp", json_object_get(jo2));
1647 		if(fjson_object_object_get_ex(jReply, "metadata", &amp;jPodData)) {
1648 			if(fjson_object_object_get_ex(jPodData, "uid", &amp;jo2))
1649 				json_object_object_add(jo, "pod_id", json_object_get(jo2));
1650 			parse_labels_annotations(jPodData, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
1651 				pWrkrData-&gt;pData-&gt;de_dot,
1652 				(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
1653 				pWrkrData-&gt;pData-&gt;de_dot_separator_len);
1654 			if(fjson_object_object_get_ex(jPodData, "annotations", &amp;jo2))
1655 				json_object_object_add(jo, "annotations", json_object_get(jo2));
1656 			if(fjson_object_object_get_ex(jPodData, "labels", &amp;jo2))
1657 				json_object_object_add(jo, "labels", json_object_get(jo2));
1658 		}
1659 		if(fjson_object_object_get_ex(jReply, "spec", &amp;jPodData)) {
1660 			if(fjson_object_object_get_ex(jPodData, "nodeName", &amp;jo2)) {
1661 				json_object_object_add(jo, "host", json_object_get(jo2));
1662 			}
1663 		}
1664 		json_object_put(jReply);
1665 		jReply = NULL;
1666 		if (fjson_object_object_get_ex(jMsgMeta, "pod_name", &amp;jo2))
1667 			json_object_object_add(jo, "pod_name", json_object_get(jo2));
1668 		if (fjson_object_object_get_ex(jMsgMeta, "namespace_name", &amp;jo2))
1669 			json_object_object_add(jo, "namespace_name", json_object_get(jo2));
1670 		if (fjson_object_object_get_ex(jMsgMeta, "container_name", &amp;jo2))
1671 			json_object_object_add(jo, "container_name", json_object_get(jo2));
1672 		json_object_object_add(jo, "master_url",
1673 			json_object_new_string((const char *)pWrkrData-&gt;pData-&gt;kubernetesUrl));
1674 		jMetadata = json_object_new_object();
1675 		json_object_object_add(jMetadata, "kubernetes", jo);
1676 		jo = json_object_new_object();
1677 		if (fjson_object_object_get_ex(jMsgMeta, "container_id", &amp;jo2))
1678 			json_object_object_add(jo, "container_id", json_object_get(jo2));
1679 		json_object_object_add(jMetadata, "docker", jo);
1680 		if (add_pod_metadata) {
1681 			if ((iRet = cache_entry_add_md(pWrkrData, mdKey, jMetadata, now)))
1682 				ABORT_FINALIZE(iRet);
1683 			mdKey = NULL;
1684 		}
1685 	}
1686 	jMetadataCopy = json_tokener_parse(json_object_get_string(jMetadata));
1687 	if (!add_pod_metadata) {
1688 		json_object_put(jMetadata);
1689 		jMetadata = NULL;
1690 	}
1691 	pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1692 	msgAddJSON(pMsg, (uchar *) pWrkrData-&gt;pData-&gt;dstMetadataPath + 1, jMetadataCopy, 0, 0);
1693 finalize_it:
1694 	json_object_put(jMsgMeta);
1695 	free(mdKey);
1696 ENDdoAction
1697 BEGINisCompatibleWithFeature
1698 CODESTARTisCompatibleWithFeature
1699 ENDisCompatibleWithFeature
1700 BEGINmodExit
1701 CODESTARTmodExit
1702 	curl_global_cleanup();
1703 	objRelease(datetime, CORE_COMPONENT);
1704 	objRelease(regexp, LM_REGEXP_FILENAME);
1705 	objRelease(statsobj, CORE_COMPONENT);
1706 ENDmodExit
1707 BEGINqueryEtryPt
1708 CODESTARTqueryEtryPt
1709 CODEqueryEtryPt_STD_OMOD_QUERIES
1710 CODEqueryEtryPt_STD_OMOD8_QUERIES
1711 CODEqueryEtryPt_STD_CONF2_QUERIES
1712 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
1713 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1714 ENDqueryEtryPt
1715 BEGINmodInit()
1716 CODESTARTmodInit
1717 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1718 	DBGPRINTF("mmkubernetes: module compiled with rsyslog version %s.\n", VERSION);
1719 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1720 	CHKiRet(objUse(regexp, LM_REGEXP_FILENAME));
1721 	CHKiRet(objUse(datetime, CORE_COMPONENT));
1722 	curl_global_init(CURL_GLOBAL_ALL);
1723 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
